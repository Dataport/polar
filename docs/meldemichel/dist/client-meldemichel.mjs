const M_ = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection"
};
class S_ extends Error {
  /**
   * @param {number} code Error code.
   */
  constructor(t) {
    const n = M_[t];
    super(n), this.code = t, this.name = "AssertionError", this.message = n;
  }
}
const wT = S_;
class I_ {
  /**
   * @param {string} type Type.
   */
  constructor(t) {
    this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const Ui = I_, Hl = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class __ {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const $v = __;
function D_(e, t, n) {
  let s, r;
  n = n || Ao;
  let i = 0, a = e.length, o = !1;
  for (; i < a; )
    s = i + (a - i >> 1), r = +n(e[s], t), r < 0 ? i = s + 1 : (a = s, o = !r);
  return o ? i : ~i;
}
function Ao(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}
function vf(e, t, n) {
  const s = e.length;
  if (e[0] <= t)
    return 0;
  if (t <= e[s - 1])
    return s - 1;
  {
    let r;
    if (n > 0) {
      for (r = 1; r < s; ++r)
        if (e[r] < t)
          return r - 1;
    } else if (n < 0) {
      for (r = 1; r < s; ++r)
        if (e[r] <= t)
          return r;
    } else
      for (r = 1; r < s; ++r) {
        if (e[r] == t)
          return r;
        if (e[r] < t)
          return typeof n == "function" ? n(t, e[r - 1], e[r]) > 0 ? r - 1 : r : e[r - 1] - t < t - e[r] ? r - 1 : r;
      }
    return s - 1;
  }
}
function A_(e, t, n) {
  for (; t < n; ) {
    const s = e[t];
    e[t] = e[n], e[n] = s, ++t, --n;
  }
}
function Kn(e, t) {
  const n = Array.isArray(t) ? t : [t], s = n.length;
  for (let r = 0; r < s; r++)
    e[e.length] = n[r];
}
function Yo(e, t) {
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let s = 0; s < n; s++)
    if (e[s] !== t[s])
      return !1;
  return !0;
}
function L_(e, t) {
  const n = e.length, s = Array(e.length);
  let r;
  for (r = 0; r < n; r++)
    s[r] = { index: r, value: e[r] };
  for (s.sort(function(i, a) {
    return t(i.value, a.value) || i.index - a.index;
  }), r = 0; r < e.length; r++)
    e[r] = s[r].value;
}
function R_(e, t, n) {
  const s = t || Ao;
  return e.every(function(r, i) {
    if (i === 0)
      return !0;
    const a = s(e[i - 1], r);
    return !(a > 0 || n && a === 0);
  });
}
function ds() {
  return !0;
}
function au() {
  return !1;
}
function Lo() {
}
function w_(e) {
  let t = !1, n, s, r;
  return function() {
    const i = Array.prototype.slice.call(arguments);
    return (!t || this !== r || !Yo(i, s)) && (t = !0, r = this, s = i, n = e.apply(this, arguments)), n;
  };
}
function ou(e) {
  for (const t in e)
    delete e[t];
}
function Ro(e) {
  let t;
  for (t in e)
    return !1;
  return !t;
}
class V_ extends $v {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(t) {
    super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(t, n) {
    if (!t || !n)
      return;
    const s = this.listeners_ || (this.listeners_ = {}), r = s[t] || (s[t] = []);
    r.includes(n) || r.push(n);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(t) {
    const n = typeof t == "string", s = n ? t : t.type, r = this.listeners_ && this.listeners_[s];
    if (!r)
      return;
    const i = n ? new Ui(t) : (
      /** @type {Event} */
      t
    );
    i.target || (i.target = this.eventTarget_ || this);
    const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    s in a || (a[s] = 0, o[s] = 0), ++a[s];
    let l;
    for (let f = 0, d = r.length; f < d; ++f)
      if ("handleEvent" in r[f] ? l = /** @type {import("../events.js").ListenerObject} */
      r[f].handleEvent(i) : l = /** @type {import("../events.js").ListenerFunction} */
      r[f].call(this, i), l === !1 || i.propagationStopped) {
        l = !1;
        break;
      }
    if (--a[s] === 0) {
      let f = o[s];
      for (delete o[s]; f--; )
        this.removeEventListener(s, Lo);
      delete a[s];
    }
    return l;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && ou(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(t) {
    return this.listeners_ && this.listeners_[t] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(t) {
    return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(t, n) {
    const s = this.listeners_ && this.listeners_[t];
    if (s) {
      const r = s.indexOf(n);
      r !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (s[r] = Lo, ++this.pendingRemovals_[t]) : (s.splice(r, 1), s.length === 0 && delete this.listeners_[t]));
    }
  }
}
const wc = V_, Kt = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function ge(e, t, n, s, r) {
  if (s && s !== e && (n = n.bind(s)), r) {
    const a = n;
    n = function() {
      e.removeEventListener(t, n), a.apply(this, arguments);
    };
  }
  const i = {
    target: e,
    type: t,
    listener: n
  };
  return e.addEventListener(t, n), i;
}
function dd(e, t, n, s) {
  return ge(e, t, n, s, !0);
}
function We(e) {
  e && e.target && (e.target.removeEventListener(e.type, e.listener), ou(e));
}
class yf extends wc {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(t, n) {
    if (Array.isArray(t)) {
      const s = t.length, r = new Array(s);
      for (let i = 0; i < s; ++i)
        r[i] = ge(this, t[i], n);
      return r;
    } else
      return ge(
        this,
        /** @type {string} */
        t,
        n
      );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(t, n) {
    let s;
    if (Array.isArray(t)) {
      const r = t.length;
      s = new Array(r);
      for (let i = 0; i < r; ++i)
        s[i] = dd(this, t[i], n);
    } else
      s = dd(
        this,
        /** @type {string} */
        t,
        n
      );
    return n.ol_key = s, s;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(t, n) {
    const s = (
      /** @type {Object} */
      n.ol_key
    );
    if (s)
      Fs(s);
    else if (Array.isArray(t))
      for (let r = 0, i = t.length; r < i; ++r)
        this.removeEventListener(t[r], n);
    else
      this.removeEventListener(t, n);
  }
}
yf.prototype.on;
yf.prototype.once;
yf.prototype.un;
function Fs(e) {
  if (Array.isArray(e))
    for (let t = 0, n = e.length; t < n; ++t)
      We(e[t]);
  else
    We(
      /** @type {import("./events.js").EventsKey} */
      e
    );
}
const VT = yf;
function Gt() {
  throw new Error("Unimplemented abstract method.");
}
let B_ = 0;
function Xt(e) {
  return e.ol_uid || (e.ol_uid = String(++B_));
}
class OE extends Ui {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(t, n, s) {
    super(t), this.key = n, this.oldValue = s;
  }
}
class N_ extends VT {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, Xt(this), this.values_ = null, t !== void 0 && this.setProperties(t);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(t) {
    let n;
    return this.values_ && this.values_.hasOwnProperty(t) && (n = this.values_[t]), n;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(t, n) {
    let s;
    s = `change:${t}`, this.hasListener(s) && this.dispatchEvent(new OE(s, t, n)), s = Hl.PROPERTYCHANGE, this.hasListener(s) && this.dispatchEvent(new OE(s, t, n));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(t, n) {
    this.addEventListener(`change:${t}`, n);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(t, n) {
    this.removeEventListener(`change:${t}`, n);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(t, n, s) {
    const r = this.values_ || (this.values_ = {});
    if (s)
      r[t] = n;
    else {
      const i = r[t];
      r[t] = n, i !== n && this.notify(t, i);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(t, n) {
    for (const s in t)
      this.set(s, t[s], n);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(t) {
    t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(t, n) {
    if (this.values_ && t in this.values_) {
      const s = this.values_[t];
      delete this.values_[t], Ro(this.values_) && (this.values_ = null), n || this.notify(t, s);
    }
  }
}
const Er = N_, $n = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, TE = {
  LENGTH: "length"
};
class hh extends Ui {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(t, n, s) {
    super(t), this.element = n, this.index = s;
  }
}
class F_ extends Er {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(t, n) {
    if (super(), this.on, this.once, this.un, n = n || {}, this.unique_ = !!n.unique, this.array_ = t || [], this.unique_)
      for (let s = 0, r = this.array_.length; s < r; ++s)
        this.assertUnique_(this.array_[s], s);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(t) {
    for (let n = 0, s = t.length; n < s; ++n)
      this.push(t[n]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(t) {
    const n = this.array_;
    for (let s = 0, r = n.length; s < r; ++s)
      t(n[s], s, n);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(t) {
    return this.array_[t];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(TE.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(t, n) {
    if (t < 0 || t > this.getLength())
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(n), this.array_.splice(t, 0, n), this.updateLength_(), this.dispatchEvent(
      new hh($n.ADD, n, t)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(t) {
    this.unique_ && this.assertUnique_(t);
    const n = this.getLength();
    return this.insertAt(n, t), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(t) {
    const n = this.array_;
    for (let s = 0, r = n.length; s < r; ++s)
      if (n[s] === t)
        return this.removeAt(s);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(t) {
    if (t < 0 || t >= this.getLength())
      return;
    const n = this.array_[t];
    return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new hh($n.REMOVE, n, t)
    ), n;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(t, n) {
    const s = this.getLength();
    if (t >= s) {
      this.insertAt(t, n);
      return;
    }
    if (t < 0)
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(n, t);
    const r = this.array_[t];
    this.array_[t] = n, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new hh($n.REMOVE, r, t)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new hh($n.ADD, n, t)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(TE.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(t, n) {
    for (let s = 0, r = this.array_.length; s < r; ++s)
      if (this.array_[s] === t && s !== n)
        throw new wT(58);
  }
}
const Vi = F_;
function Zt(e, t) {
  if (!e)
    throw new wT(t);
}
class zv extends Er {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(t) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
      if (typeof /** @type {?} */
      t.getSimplifiedGeometry == "function") {
        const n = (
          /** @type {Geometry} */
          t
        );
        this.setGeometry(n);
      } else {
        const n = t;
        this.setProperties(n);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const t = (
      /** @type {Feature<Geometry>} */
      new zv(this.hasProperties() ? this.getProperties() : null)
    );
    t.setGeometryName(this.getGeometryName());
    const n = this.getGeometry();
    n && t.setGeometry(
      /** @type {Geometry} */
      n.clone()
    );
    const s = this.getStyle();
    return s && t.setStyle(s), t;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (We(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const t = this.getGeometry();
    t && (this.geometryChangeKey_ = ge(
      t,
      Kt.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(t) {
    this.set(this.geometryName_, t);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(t) {
    this.style_ = t, this.styleFunction_ = t ? j_(t) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(t) {
    this.id_ = t, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(t) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function j_(e) {
  if (typeof e == "function")
    return e;
  {
    let t;
    return Array.isArray(e) ? t = e : (Zt(typeof /** @type {?} */
    e.getZIndex == "function", 41), t = [
      /** @type {import("./style/Style.js").default} */
      e
    ]), function() {
      return t;
    };
  }
}
const Xi = zv, Fa = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", U_ = Fa.includes("firefox"), W_ = Fa.includes("safari") && !Fa.includes("chrom");
W_ && (Fa.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Fa));
const $_ = Fa.includes("webkit") && !Fa.includes("edge"), BT = Fa.includes("macintosh"), Ef = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Kv = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, z_ = typeof Image < "u" && Image.prototype.decode, NT = function() {
  let e = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get: function() {
        e = !0;
      }
    });
    window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
  } catch {
  }
  return e;
}(), FT = new Array(6);
function Qi() {
  return [1, 0, 0, 1, 0, 0];
}
function PE(e) {
  return Cf(e, 1, 0, 0, 1, 0, 0);
}
function Gv(e, t) {
  const n = e[0], s = e[1], r = e[2], i = e[3], a = e[4], o = e[5], l = t[0], f = t[1], d = t[2], u = t[3], c = t[4], h = t[5];
  return e[0] = n * l + r * f, e[1] = s * l + i * f, e[2] = n * d + r * u, e[3] = s * d + i * u, e[4] = n * c + r * h + a, e[5] = s * c + i * h + o, e;
}
function Cf(e, t, n, s, r, i, a) {
  return e[0] = t, e[1] = n, e[2] = s, e[3] = r, e[4] = i, e[5] = a, e;
}
function K_(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function An(e, t) {
  const n = t[0], s = t[1];
  return t[0] = e[0] * n + e[2] * s + e[4], t[1] = e[1] * n + e[3] * s + e[5], t;
}
function id(e, t, n) {
  return Gv(e, Cf(FT, t, 0, 0, n, 0, 0));
}
function G_(e, t, n) {
  return Cf(e, t, 0, 0, n, 0, 0);
}
function k_(e, t, n) {
  return Gv(e, Cf(FT, 1, 0, 0, 1, t, n));
}
function Fr(e, t, n, s, r, i, a, o) {
  const l = Math.sin(i), f = Math.cos(i);
  return e[0] = s * f, e[1] = r * l, e[2] = -s * l, e[3] = r * f, e[4] = a * s * f - o * s * l + t, e[5] = a * r * l + o * r * f + n, e;
}
function xf(e, t) {
  const n = H_(t);
  Zt(n !== 0, 32);
  const s = t[0], r = t[1], i = t[2], a = t[3], o = t[4], l = t[5];
  return e[0] = a / n, e[1] = -r / n, e[2] = -i / n, e[3] = s / n, e[4] = (i * l - a * o) / n, e[5] = -(s * l - r * o) / n, e;
}
function H_(e) {
  return e[0] * e[3] - e[1] * e[2];
}
let ME;
function kv(e) {
  const t = "matrix(" + e.join(", ") + ")";
  if (Kv)
    return t;
  const n = ME || (ME = document.createElement("div"));
  return n.style.transform = t, n.style.transform;
}
const Wn = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Yl(e) {
  const t = Ni();
  for (let n = 0, s = e.length; n < s; ++n)
    Qu(t, e[n]);
  return t;
}
function Y_(e, t, n) {
  const s = Math.min.apply(null, e), r = Math.min.apply(null, t), i = Math.max.apply(null, e), a = Math.max.apply(null, t);
  return er(s, r, i, a, n);
}
function wr(e, t, n) {
  return n ? (n[0] = e[0] - t, n[1] = e[1] - t, n[2] = e[2] + t, n[3] = e[3] + t, n) : [
    e[0] - t,
    e[1] - t,
    e[2] + t,
    e[3] + t
  ];
}
function jT(e, t) {
  return t ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : e.slice();
}
function Xo(e, t, n) {
  let s, r;
  return t < e[0] ? s = e[0] - t : e[2] < t ? s = t - e[2] : s = 0, n < e[1] ? r = e[1] - n : e[3] < n ? r = n - e[3] : r = 0, s * s + r * r;
}
function Vc(e, t) {
  return Hv(e, t[0], t[1]);
}
function Ar(e, t) {
  return e[0] <= t[0] && t[2] <= e[2] && e[1] <= t[1] && t[3] <= e[3];
}
function Hv(e, t, n) {
  return e[0] <= t && t <= e[2] && e[1] <= n && n <= e[3];
}
function xg(e, t) {
  const n = e[0], s = e[1], r = e[2], i = e[3], a = t[0], o = t[1];
  let l = Wn.UNKNOWN;
  return a < n ? l = l | Wn.LEFT : a > r && (l = l | Wn.RIGHT), o < s ? l = l | Wn.BELOW : o > i && (l = l | Wn.ABOVE), l === Wn.UNKNOWN && (l = Wn.INTERSECTING), l;
}
function Ni() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function er(e, t, n, s, r) {
  return r ? (r[0] = e, r[1] = t, r[2] = n, r[3] = s, r) : [e, t, n, s];
}
function Bc(e) {
  return er(1 / 0, 1 / 0, -1 / 0, -1 / 0, e);
}
function Yv(e, t) {
  const n = e[0], s = e[1];
  return er(n, s, n, s, t);
}
function Xv(e, t, n, s, r) {
  const i = Bc(r);
  return WT(i, e, t, n, s);
}
function wo(e, t) {
  return e[0] == t[0] && e[2] == t[2] && e[1] == t[1] && e[3] == t[3];
}
function UT(e, t) {
  return t[0] < e[0] && (e[0] = t[0]), t[2] > e[2] && (e[2] = t[2]), t[1] < e[1] && (e[1] = t[1]), t[3] > e[3] && (e[3] = t[3]), e;
}
function Qu(e, t) {
  t[0] < e[0] && (e[0] = t[0]), t[0] > e[2] && (e[2] = t[0]), t[1] < e[1] && (e[1] = t[1]), t[1] > e[3] && (e[3] = t[1]);
}
function WT(e, t, n, s, r) {
  for (; n < s; n += r)
    X_(e, t[n], t[n + 1]);
  return e;
}
function X_(e, t, n) {
  e[0] = Math.min(e[0], t), e[1] = Math.min(e[1], n), e[2] = Math.max(e[2], t), e[3] = Math.max(e[3], n);
}
function Zv(e, t) {
  let n;
  return n = t(Oo(e)), n || (n = t(Xl(e)), n) || (n = t(To(e)), n) || (n = t(fs(e)), n) ? n : !1;
}
function bg(e) {
  let t = 0;
  return bf(e) || (t = ye(e) * In(e)), t;
}
function Oo(e) {
  return [e[0], e[1]];
}
function Xl(e) {
  return [e[2], e[1]];
}
function Fi(e) {
  return [(e[0] + e[2]) / 2, (e[1] + e[3]) / 2];
}
function Z_(e, t) {
  let n;
  return t === "bottom-left" ? n = Oo(e) : t === "bottom-right" ? n = Xl(e) : t === "top-left" ? n = fs(e) : t === "top-right" ? n = To(e) : Zt(!1, 13), n;
}
function Nl(e, t, n, s, r) {
  const [i, a, o, l, f, d, u, c] = Og(
    e,
    t,
    n,
    s
  );
  return er(
    Math.min(i, o, f, u),
    Math.min(a, l, d, c),
    Math.max(i, o, f, u),
    Math.max(a, l, d, c),
    r
  );
}
function Og(e, t, n, s) {
  const r = t * s[0] / 2, i = t * s[1] / 2, a = Math.cos(n), o = Math.sin(n), l = r * a, f = r * o, d = i * a, u = i * o, c = e[0], h = e[1];
  return [
    c - l + u,
    h - f - d,
    c - l - u,
    h - f + d,
    c + l - u,
    h + f + d,
    c + l + u,
    h + f - d,
    c - l + u,
    h - f - d
  ];
}
function In(e) {
  return e[3] - e[1];
}
function zs(e, t, n) {
  const s = n || Ni();
  return cn(e, t) ? (e[0] > t[0] ? s[0] = e[0] : s[0] = t[0], e[1] > t[1] ? s[1] = e[1] : s[1] = t[1], e[2] < t[2] ? s[2] = e[2] : s[2] = t[2], e[3] < t[3] ? s[3] = e[3] : s[3] = t[3]) : Bc(s), s;
}
function fs(e) {
  return [e[0], e[3]];
}
function To(e) {
  return [e[2], e[3]];
}
function ye(e) {
  return e[2] - e[0];
}
function cn(e, t) {
  return e[0] <= t[2] && e[2] >= t[0] && e[1] <= t[3] && e[3] >= t[1];
}
function bf(e) {
  return e[2] < e[0] || e[3] < e[1];
}
function J_(e, t) {
  return t ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : e;
}
function Q_(e, t, n) {
  let s = !1;
  const r = xg(e, t), i = xg(e, n);
  if (r === Wn.INTERSECTING || i === Wn.INTERSECTING)
    s = !0;
  else {
    const a = e[0], o = e[1], l = e[2], f = e[3], d = t[0], u = t[1], c = n[0], h = n[1], p = (h - u) / (c - d);
    let g, m;
    i & Wn.ABOVE && !(r & Wn.ABOVE) && (g = c - (h - f) / p, s = g >= a && g <= l), !s && i & Wn.RIGHT && !(r & Wn.RIGHT) && (m = h - (c - l) * p, s = m >= o && m <= f), !s && i & Wn.BELOW && !(r & Wn.BELOW) && (g = c - (h - o) / p, s = g >= a && g <= l), !s && i & Wn.LEFT && !(r & Wn.LEFT) && (m = h - (c - a) * p, s = m >= o && m <= f);
  }
  return s;
}
function q_(e, t, n, s) {
  let r = [];
  if (s > 1) {
    const o = e[2] - e[0], l = e[3] - e[1];
    for (let f = 0; f < s; ++f)
      r.push(
        e[0] + o * f / s,
        e[1],
        e[2],
        e[1] + l * f / s,
        e[2] - o * f / s,
        e[3],
        e[0],
        e[3] - l * f / s
      );
  } else
    r = [
      e[0],
      e[1],
      e[2],
      e[1],
      e[2],
      e[3],
      e[0],
      e[3]
    ];
  t(r, r, 2);
  const i = [], a = [];
  for (let o = 0, l = r.length; o < l; o += 2)
    i.push(r[o]), a.push(r[o + 1]);
  return Y_(i, a, n);
}
function $T(e, t) {
  const n = t.getExtent(), s = Fi(e);
  if (t.canWrapX() && (s[0] < n[0] || s[0] >= n[2])) {
    const r = ye(n), a = Math.floor(
      (s[0] - n[0]) / r
    ) * r;
    e[0] -= a, e[2] -= a;
  }
  return e;
}
function tD(e, t) {
  if (t.canWrapX()) {
    const n = t.getExtent();
    if (!isFinite(e[0]) || !isFinite(e[2]))
      return [[n[0], e[1], n[2], e[3]]];
    $T(e, t);
    const s = ye(n);
    if (ye(e) > s)
      return [[n[0], e[1], n[2], e[3]]];
    if (e[0] < n[0])
      return [
        [e[0] + s, e[1], n[2], e[3]],
        [n[0], e[1], e[2], e[3]]
      ];
    if (e[2] > n[2])
      return [
        [e[0], e[1], n[2], e[3]],
        [n[0], e[1], e[2] - s, e[3]]
      ];
  }
  return [e];
}
const Zl = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let eD = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Zl[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const Of = eD, Nc = 6378137, Ol = Math.PI * Nc, nD = [-Ol, -Ol, Ol, Ol], iD = [-180, -85, 180, 85], dh = Nc * Math.log(Math.tan(Math.PI / 2));
class rl extends Of {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: nD,
      global: !0,
      worldExtent: iD,
      getPointResolution: function(n, s) {
        return n / Math.cosh(s[1] / Nc);
      }
    });
  }
}
const SE = [
  new rl("EPSG:3857"),
  new rl("EPSG:102100"),
  new rl("EPSG:102113"),
  new rl("EPSG:900913"),
  new rl("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new rl("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function rD(e, t, n) {
  const s = e.length;
  n = n > 1 ? n : 2, t === void 0 && (n > 2 ? t = e.slice() : t = new Array(s));
  for (let r = 0; r < s; r += n) {
    t[r] = Ol * e[r] / 180;
    let i = Nc * Math.log(Math.tan(Math.PI * (+e[r + 1] + 90) / 360));
    i > dh ? i = dh : i < -dh && (i = -dh), t[r + 1] = i;
  }
  return t;
}
function sD(e, t, n) {
  const s = e.length;
  n = n > 1 ? n : 2, t === void 0 && (n > 2 ? t = e.slice() : t = new Array(s));
  for (let r = 0; r < s; r += n)
    t[r] = 180 * e[r] / Ol, t[r + 1] = 360 * Math.atan(Math.exp(e[r + 1] / Nc)) / Math.PI - 90;
  return t;
}
const aD = 6378137, IE = [-180, -90, 180, 90], oD = Math.PI * aD / 180;
class oo extends Of {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, n) {
    super({
      code: t,
      units: "degrees",
      extent: IE,
      axisOrientation: n,
      global: !0,
      metersPerUnit: oD,
      worldExtent: IE
    });
  }
}
const _E = [
  new oo("CRS:84"),
  new oo("EPSG:4326", "neu"),
  new oo("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new oo("urn:ogc:def:crs:OGC:2:84"),
  new oo("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new oo("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new oo("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Tg = {};
function lD(e) {
  return Tg[e] || Tg[e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function uD(e, t) {
  Tg[e] = t;
}
let Fl = {};
function Jl(e, t, n) {
  const s = e.getCode(), r = t.getCode();
  s in Fl || (Fl[s] = {}), Fl[s][r] = n;
}
function zT(e, t) {
  let n;
  return e in Fl && t in Fl[e] && (n = Fl[e][t]), n;
}
function hn(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function cD(e, t, n, s, r, i) {
  const a = r - n, o = i - s;
  if (a !== 0 || o !== 0) {
    const l = ((e - n) * a + (t - s) * o) / (a * a + o * o);
    l > 1 ? (n = r, s = i) : l > 0 && (n += a * l, s += o * l);
  }
  return Ks(e, t, n, s);
}
function Ks(e, t, n, s) {
  const r = n - e, i = s - t;
  return r * r + i * i;
}
function hD(e) {
  const t = e.length;
  for (let s = 0; s < t; s++) {
    let r = s, i = Math.abs(e[s][s]);
    for (let o = s + 1; o < t; o++) {
      const l = Math.abs(e[o][s]);
      l > i && (i = l, r = o);
    }
    if (i === 0)
      return null;
    const a = e[r];
    e[r] = e[s], e[s] = a;
    for (let o = s + 1; o < t; o++) {
      const l = -e[o][s] / e[s][s];
      for (let f = s; f < t + 1; f++)
        s == f ? e[o][f] = 0 : e[o][f] += l * e[s][f];
    }
  }
  const n = new Array(t);
  for (let s = t - 1; s >= 0; s--) {
    n[s] = e[s][t] / e[s][s];
    for (let r = s - 1; r >= 0; r--)
      e[r][t] -= e[r][s] * n[s];
  }
  return n;
}
function DE(e) {
  return e * 180 / Math.PI;
}
function Po(e) {
  return e * Math.PI / 180;
}
function _a(e, t) {
  const n = e % t;
  return n * t < 0 ? n + t : n;
}
function Bs(e, t, n) {
  return e + n * (t - e);
}
function Tf(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
function AE(e, t) {
  return Math.round(Tf(e, t));
}
function Tl(e, t) {
  return Math.floor(Tf(e, t));
}
function xa(e, t) {
  return Math.ceil(Tf(e, t));
}
function KT(e, t) {
  const n = ("" + e).split("."), s = ("" + t).split(".");
  for (let r = 0; r < Math.max(n.length, s.length); r++) {
    const i = parseInt(n[r] || "0", 10), a = parseInt(s[r] || "0", 10);
    if (i > a)
      return 1;
    if (a > i)
      return -1;
  }
  return 0;
}
function GT(e, t) {
  return e[0] += +t[0], e[1] += +t[1], e;
}
function fd(e, t) {
  let n = !0;
  for (let s = e.length - 1; s >= 0; --s)
    if (e[s] != t[s]) {
      n = !1;
      break;
    }
  return n;
}
function Jv(e, t) {
  const n = Math.cos(t), s = Math.sin(t), r = e[0] * n - e[1] * s, i = e[1] * n + e[0] * s;
  return e[0] = r, e[1] = i, e;
}
function kT(e, t) {
  return e[0] *= t, e[1] *= t, e;
}
function HT(e, t) {
  const n = e[0] - t[0], s = e[1] - t[1];
  return n * n + s * s;
}
function YT(e, t) {
  return Math.sqrt(HT(e, t));
}
function Qv(e, t) {
  if (t.canWrapX()) {
    const n = ye(t.getExtent()), s = XT(e, t, n);
    s && (e[0] -= s * n);
  }
  return e;
}
function XT(e, t, n) {
  const s = t.getExtent();
  let r = 0;
  return t.canWrapX() && (e[0] < s[0] || e[0] > s[2]) && (n = n || ye(s), r = Math.floor(
    (e[0] - s[0]) / n
  )), r;
}
const ZT = 63710088e-1;
function LE(e, t, n) {
  n = n || ZT;
  const s = Po(e[1]), r = Po(t[1]), i = (r - s) / 2, a = Po(t[0] - e[0]) / 2, o = Math.sin(i) * Math.sin(i) + Math.sin(a) * Math.sin(a) * Math.cos(s) * Math.cos(r);
  return 2 * n * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o));
}
function dD(e, t, n, s) {
  s = s || ZT;
  const r = Po(e[1]), i = Po(e[0]), a = t / s, o = Math.asin(
    Math.sin(r) * Math.cos(a) + Math.cos(r) * Math.sin(a) * Math.cos(n)
  ), l = i + Math.atan2(
    Math.sin(n) * Math.sin(a) * Math.cos(r),
    Math.cos(a) - Math.sin(r) * Math.sin(o)
  );
  return [DE(l), DE(o)];
}
let Pg = !0;
function fD(e) {
  Pg = !(e === void 0 ? !0 : e);
}
function qv(e, t, n) {
  if (t !== void 0) {
    for (let s = 0, r = e.length; s < r; ++s)
      t[s] = e[s];
    t = t;
  } else
    t = e.slice();
  return t;
}
function ty(e, t, n) {
  if (t !== void 0 && e !== t) {
    for (let s = 0, r = e.length; s < r; ++s)
      t[s] = e[s];
    e = t;
  }
  return e;
}
function ey(e) {
  uD(e.getCode(), e), Jl(e, e, qv);
}
function pD(e) {
  e.forEach(ey);
}
function Wt(e) {
  return typeof e == "string" ? lD(
    /** @type {string} */
    e
  ) : (
    /** @type {Projection} */
    e || null
  );
}
function RE(e, t, n, s) {
  e = Wt(e);
  let r;
  const i = e.getPointResolutionFunc();
  if (i) {
    if (r = i(t, n), s && s !== e.getUnits()) {
      const a = e.getMetersPerUnit();
      a && (r = r * a / Zl[s]);
    }
  } else {
    const a = e.getUnits();
    if (a == "degrees" && !s || s == "degrees")
      r = t;
    else {
      const o = Pf(
        e,
        Wt("EPSG:4326")
      );
      if (o === ty && a !== "degrees")
        r = t * e.getMetersPerUnit();
      else {
        let f = [
          n[0] - t / 2,
          n[1],
          n[0] + t / 2,
          n[1],
          n[0],
          n[1] - t / 2,
          n[0],
          n[1] + t / 2
        ];
        f = o(f, f, 2);
        const d = LE(f.slice(0, 2), f.slice(2, 4)), u = LE(f.slice(4, 6), f.slice(6, 8));
        r = (d + u) / 2;
      }
      const l = s ? Zl[s] : e.getMetersPerUnit();
      l !== void 0 && (r /= l);
    }
  }
  return r;
}
function Mg(e) {
  pD(e), e.forEach(function(t) {
    e.forEach(function(n) {
      t !== n && Jl(t, n, qv);
    });
  });
}
function mD(e, t, n, s) {
  e.forEach(function(r) {
    t.forEach(function(i) {
      Jl(r, i, n), Jl(i, r, s);
    });
  });
}
function ny(e, t) {
  return e ? typeof e == "string" ? Wt(e) : (
    /** @type {Projection} */
    e
  ) : Wt(t);
}
function wE(e) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(t, n, s) {
      const r = t.length;
      s = s !== void 0 ? s : 2, n = n !== void 0 ? n : new Array(r);
      for (let i = 0; i < r; i += s) {
        const a = e(t.slice(i, i + s)), o = a.length;
        for (let l = 0, f = s; l < f; ++l)
          n[i + l] = l >= o ? t[i + l] : a[l];
      }
      return n;
    }
  );
}
function gD(e, t, n, s) {
  const r = Wt(e), i = Wt(t);
  Jl(
    r,
    i,
    wE(n)
  ), Jl(
    i,
    r,
    wE(s)
  );
}
function vD(e, t) {
  const n = ji(
    e,
    t !== void 0 ? t : "EPSG:3857",
    "EPSG:4326"
  ), s = n[0];
  return (s < -180 || s > 180) && (n[0] = _a(s + 180, 360) - 180), n;
}
function dr(e, t) {
  if (e === t)
    return !0;
  const n = e.getUnits() === t.getUnits();
  return (e.getCode() === t.getCode() || Pf(e, t) === qv) && n;
}
function Pf(e, t) {
  const n = e.getCode(), s = t.getCode();
  let r = zT(n, s);
  return r || (r = ty), r;
}
function ja(e, t) {
  const n = Wt(e), s = Wt(t);
  return Pf(n, s);
}
function ji(e, t, n) {
  return ja(t, n)(e, void 0, e.length);
}
function Fc(e, t, n, s) {
  const r = ja(t, n);
  return q_(e, r, void 0, s);
}
function Sg(e, t) {
  return e;
}
function _r(e, t) {
  return Pg && !fd(e, [0, 0]) && e[0] >= -180 && e[0] <= 180 && e[1] >= -90 && e[1] <= 90 && (Pg = !1, console.warn(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), e;
}
function JT(e, t) {
  return e;
}
function js(e, t) {
  return e;
}
function VE(e, t, n) {
  return function(s) {
    let r, i;
    if (e.canWrapX()) {
      const a = e.getExtent(), o = ye(a);
      s = s.slice(0), i = XT(s, e, o), i && (s[0] = s[0] - i * o), s[0] = hn(s[0], a[0], a[2]), s[1] = hn(s[1], a[1], a[3]), r = n(s);
    } else
      r = n(s);
    return i && t.canWrapX() && (r[0] += i * ye(t.getExtent())), r;
  };
}
function yD() {
  Mg(SE), Mg(_E), mD(
    _E,
    SE,
    rD,
    sD
  );
}
yD();
function Da(e, t, n, s, r, i) {
  i = i || [];
  let a = 0;
  for (let o = t; o < n; o += s) {
    const l = e[o], f = e[o + 1];
    i[a++] = r[0] * l + r[2] * f + r[4], i[a++] = r[1] * l + r[3] * f + r[5];
  }
  return i && i.length != a && (i.length = a), i;
}
function iy(e, t, n, s, r, i, a) {
  a = a || [];
  const o = Math.cos(r), l = Math.sin(r), f = i[0], d = i[1];
  let u = 0;
  for (let c = t; c < n; c += s) {
    const h = e[c] - f, p = e[c + 1] - d;
    a[u++] = f + h * o - p * l, a[u++] = d + h * l + p * o;
    for (let g = c + 2; g < c + s; ++g)
      a[u++] = e[g];
  }
  return a && a.length != u && (a.length = u), a;
}
function ED(e, t, n, s, r, i, a, o) {
  o = o || [];
  const l = a[0], f = a[1];
  let d = 0;
  for (let u = t; u < n; u += s) {
    const c = e[u] - l, h = e[u + 1] - f;
    o[d++] = l + r * c, o[d++] = f + i * h;
    for (let p = u + 2; p < u + s; ++p)
      o[d++] = e[p];
  }
  return o && o.length != d && (o.length = d), o;
}
function QT(e, t, n, s, r, i, a) {
  a = a || [];
  let o = 0;
  for (let l = t; l < n; l += s) {
    a[o++] = e[l] + r, a[o++] = e[l + 1] + i;
    for (let f = l + 2; f < l + s; ++f)
      a[o++] = e[f];
  }
  return a && a.length != o && (a.length = o), a;
}
const BE = Qi();
class CD extends Er {
  constructor() {
    super(), this.extent_ = Ni(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = w_(function(t, n, s) {
      if (!s)
        return this.getSimplifiedGeometry(n);
      const r = this.clone();
      return r.applyTransform(s), r.getSimplifiedGeometry(n);
    });
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(t, n) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      t,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Gt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return Gt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.getClosestPoint([t, n]);
    return s[0] === t && s[1] === n;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(t, n) {
    return n = n || [NaN, NaN], this.closestPointXY(t[0], t[1], n, 1 / 0), n;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(t) {
    return this.containsXY(t[0], t[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Gt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(t) {
    if (this.extentRevision_ != this.getRevision()) {
      const n = this.computeExtent(this.extent_);
      (isNaN(n[0]) || isNaN(n[1])) && Bc(n), this.extentRevision_ = this.getRevision();
    }
    return J_(this.extent_, t);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    Gt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    Gt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(t) {
    return this.getSimplifiedGeometry(t * t);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return Gt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Gt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(t) {
    Gt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(t) {
    return Gt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    Gt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(t, n) {
    const s = Wt(t), r = s.getUnits() == "tile-pixels" ? function(i, a, o) {
      const l = s.getExtent(), f = s.getWorldExtent(), d = In(f) / In(l);
      return Fr(
        BE,
        f[0],
        f[3],
        d,
        -d,
        0,
        0,
        0
      ), Da(
        i,
        0,
        i.length,
        o,
        BE,
        a
      ), ja(s, n)(
        i,
        a,
        o
      );
    } : ja(s, n);
    return this.applyTransform(r), this;
  }
}
const pd = CD;
class xD extends pd {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Xv(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Gt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const n = this.getSimplifiedGeometryInternal(t);
    return n.getFlatCoordinates().length < this.flatCoordinates.length ? n : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(t, n) {
    this.stride = md(t), this.layout = t, this.flatCoordinates = n;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(t, n) {
    Gt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(t, n, s) {
    let r;
    if (t)
      r = md(t);
    else {
      for (let i = 0; i < s; ++i)
        if (n.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        } else
          n = /** @type {Array} */
          n[0];
      r = n.length, t = bD(r);
    }
    this.layout = t, this.stride = r;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.getFlatCoordinates();
    if (s) {
      const r = this.getStride();
      iy(
        s,
        0,
        s.length,
        r,
        t,
        n,
        s
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    n === void 0 && (n = t), s || (s = Fi(this.getExtent()));
    const r = this.getFlatCoordinates();
    if (r) {
      const i = this.getStride();
      ED(
        r,
        0,
        r.length,
        i,
        t,
        n,
        s,
        r
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.getFlatCoordinates();
    if (s) {
      const r = this.getStride();
      QT(
        s,
        0,
        s.length,
        r,
        t,
        n,
        s
      ), this.changed();
    }
  }
}
function bD(e) {
  let t;
  return e == 2 ? t = "XY" : e == 3 ? t = "XYZ" : e == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  t;
}
function md(e) {
  let t;
  return e == "XY" ? t = 2 : e == "XYZ" || e == "XYM" ? t = 3 : e == "XYZM" && (t = 4), /** @type {number} */
  t;
}
function OD(e, t, n) {
  const s = e.getFlatCoordinates();
  if (s) {
    const r = e.getStride();
    return Da(
      s,
      0,
      s.length,
      r,
      t,
      n
    );
  } else
    return null;
}
const na = xD;
function NE(e, t, n, s, r, i, a) {
  const o = e[t], l = e[t + 1], f = e[n] - o, d = e[n + 1] - l;
  let u;
  if (f === 0 && d === 0)
    u = t;
  else {
    const c = ((r - o) * f + (i - l) * d) / (f * f + d * d);
    if (c > 1)
      u = n;
    else if (c > 0) {
      for (let h = 0; h < s; ++h)
        a[h] = Bs(
          e[t + h],
          e[n + h],
          c
        );
      a.length = s;
      return;
    } else
      u = t;
  }
  for (let c = 0; c < s; ++c)
    a[c] = e[u + c];
  a.length = s;
}
function ry(e, t, n, s, r) {
  let i = e[t], a = e[t + 1];
  for (t += s; t < n; t += s) {
    const o = e[t], l = e[t + 1], f = Ks(i, a, o, l);
    f > r && (r = f), i = o, a = l;
  }
  return r;
}
function sy(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r = ry(e, t, o, s, r), t = o;
  }
  return r;
}
function TD(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r = sy(e, t, o, s, r), t = o[o.length - 1];
  }
  return r;
}
function ay(e, t, n, s, r, i, a, o, l, f, d) {
  if (t == n)
    return f;
  let u, c;
  if (r === 0)
    if (c = Ks(
      a,
      o,
      e[t],
      e[t + 1]
    ), c < f) {
      for (u = 0; u < s; ++u)
        l[u] = e[t + u];
      return l.length = s, c;
    } else
      return f;
  d = d || [NaN, NaN];
  let h = t + s;
  for (; h < n; )
    if (NE(
      e,
      h - s,
      h,
      s,
      a,
      o,
      d
    ), c = Ks(a, o, d[0], d[1]), c < f) {
      for (f = c, u = 0; u < s; ++u)
        l[u] = d[u];
      l.length = s, h += s;
    } else
      h += s * Math.max(
        (Math.sqrt(c) - Math.sqrt(f)) / r | 0,
        1
      );
  if (i && (NE(
    e,
    n - s,
    t,
    s,
    a,
    o,
    d
  ), c = Ks(a, o, d[0], d[1]), c < f)) {
    for (f = c, u = 0; u < s; ++u)
      l[u] = d[u];
    l.length = s;
  }
  return f;
}
function oy(e, t, n, s, r, i, a, o, l, f, d) {
  d = d || [NaN, NaN];
  for (let u = 0, c = n.length; u < c; ++u) {
    const h = n[u];
    f = ay(
      e,
      t,
      h,
      s,
      r,
      i,
      a,
      o,
      l,
      f,
      d
    ), t = h;
  }
  return f;
}
function PD(e, t, n, s, r, i, a, o, l, f, d) {
  d = d || [NaN, NaN];
  for (let u = 0, c = n.length; u < c; ++u) {
    const h = n[u];
    f = oy(
      e,
      t,
      h,
      s,
      r,
      i,
      a,
      o,
      l,
      f,
      d
    ), t = h[h.length - 1];
  }
  return f;
}
function qT(e, t, n, s) {
  for (let r = 0, i = n.length; r < i; ++r)
    e[t++] = n[r];
  return t;
}
function Mf(e, t, n, s) {
  for (let r = 0, i = n.length; r < i; ++r) {
    const a = n[r];
    for (let o = 0; o < s; ++o)
      e[t++] = a[o];
  }
  return t;
}
function ly(e, t, n, s, r) {
  r = r || [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = Mf(
      e,
      t,
      n[a],
      s
    );
    r[i++] = l, t = l;
  }
  return r.length = i, r;
}
function MD(e, t, n, s, r) {
  r = r || [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = ly(
      e,
      t,
      n[a],
      s,
      r[i]
    );
    l.length === 0 && (l[0] = t), r[i++] = l, t = l[l.length - 1];
  }
  return r.length = i, r;
}
function uy(e, t, n, s, r, i, a) {
  const o = (n - t) / s;
  if (o < 3) {
    for (; t < n; t += s)
      i[a++] = e[t], i[a++] = e[t + 1];
    return a;
  }
  const l = new Array(o);
  l[0] = 1, l[o - 1] = 1;
  const f = [t, n - s];
  let d = 0;
  for (; f.length > 0; ) {
    const u = f.pop(), c = f.pop();
    let h = 0;
    const p = e[c], g = e[c + 1], m = e[u], v = e[u + 1];
    for (let y = c + s; y < u; y += s) {
      const E = e[y], C = e[y + 1], x = cD(E, C, p, g, m, v);
      x > h && (d = y, h = x);
    }
    h > r && (l[(d - t) / s] = 1, c + s < d && f.push(c, d), d + s < u && f.push(d, u));
  }
  for (let u = 0; u < o; ++u)
    l[u] && (i[a++] = e[t + u * s], i[a++] = e[t + u * s + 1]);
  return a;
}
function SD(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    a = uy(
      e,
      t,
      d,
      s,
      r,
      i,
      a
    ), o.push(a), t = d;
  }
  return a;
}
function mo(e, t) {
  return t * Math.round(e / t);
}
function ID(e, t, n, s, r, i, a) {
  if (t == n)
    return a;
  let o = mo(e[t], r), l = mo(e[t + 1], r);
  t += s, i[a++] = o, i[a++] = l;
  let f, d;
  do
    if (f = mo(e[t], r), d = mo(e[t + 1], r), t += s, t == n)
      return i[a++] = f, i[a++] = d, a;
  while (f == o && d == l);
  for (; t < n; ) {
    const u = mo(e[t], r), c = mo(e[t + 1], r);
    if (t += s, u == f && c == d)
      continue;
    const h = f - o, p = d - l, g = u - o, m = c - l;
    if (h * m == p * g && (h < 0 && g < h || h == g || h > 0 && g > h) && (p < 0 && m < p || p == m || p > 0 && m > p)) {
      f = u, d = c;
      continue;
    }
    i[a++] = f, i[a++] = d, o = f, l = d, f = u, d = c;
  }
  return i[a++] = f, i[a++] = d, a;
}
function tP(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    a = ID(
      e,
      t,
      d,
      s,
      r,
      i,
      a
    ), o.push(a), t = d;
  }
  return a;
}
function _D(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l], u = [];
    a = tP(
      e,
      t,
      d,
      s,
      r,
      i,
      a,
      u
    ), o.push(u), t = d[d.length - 1];
  }
  return a;
}
function ba(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = t; a < n; a += s)
    r[i++] = e.slice(a, a + s);
  return r.length = i, r;
}
function ac(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    r[i++] = ba(
      e,
      t,
      l,
      s,
      r[i]
    ), t = l;
  }
  return r.length = i, r;
}
function Ig(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    r[i++] = l.length === 1 && l[0] === t ? [] : ac(
      e,
      t,
      l,
      s,
      r[i]
    ), t = l[l.length - 1];
  }
  return r.length = i, r;
}
function eP(e, t, n, s) {
  let r = 0, i = e[n - s], a = e[n - s + 1];
  for (; t < n; t += s) {
    const o = e[t], l = e[t + 1];
    r += a * o - i * l, i = o, a = l;
  }
  return r / 2;
}
function nP(e, t, n, s) {
  let r = 0;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r += eP(e, t, o, s), t = o;
  }
  return r;
}
function DD(e, t, n, s) {
  let r = 0;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r += nP(e, t, o, s), t = o[o.length - 1];
  }
  return r;
}
class gd extends na {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new gd(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Xo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ry(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), ay(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return eP(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return ba(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [];
    return n.length = uy(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      0
    ), new gd(n, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const vd = gd;
let AD = class iP extends na {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.setCoordinates(t, n);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const t = new iP(this.flatCoordinates.slice(), this.layout);
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    const i = this.flatCoordinates, a = Ks(
      t,
      n,
      i[0],
      i[1]
    );
    if (a < r) {
      const o = this.stride;
      for (let l = 0; l < o; ++l)
        s[l] = i[l];
      return s.length = o, a;
    } else
      return r;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates ? this.flatCoordinates.slice() : [];
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Yv(this.flatCoordinates, t);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return Hv(t, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = qT(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
};
const hi = AD;
function LD(e, t, n, s, r) {
  return !Zv(
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(a) {
      return !vo(
        e,
        t,
        n,
        s,
        a[0],
        a[1]
      );
    }
  );
}
function vo(e, t, n, s, r, i) {
  let a = 0, o = e[n - s], l = e[n - s + 1];
  for (; t < n; t += s) {
    const f = e[t], d = e[t + 1];
    l <= i ? d > i && (f - o) * (i - l) - (r - o) * (d - l) > 0 && a++ : d <= i && (f - o) * (i - l) - (r - o) * (d - l) < 0 && a--, o = f, l = d;
  }
  return a !== 0;
}
function cy(e, t, n, s, r, i) {
  if (n.length === 0 || !vo(e, t, n[0], s, r, i))
    return !1;
  for (let a = 1, o = n.length; a < o; ++a)
    if (vo(e, n[a - 1], n[a], s, r, i))
      return !1;
  return !0;
}
function RD(e, t, n, s, r, i) {
  if (n.length === 0)
    return !1;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    if (cy(e, t, l, s, r, i))
      return !0;
    t = l[l.length - 1];
  }
  return !1;
}
function hy(e, t, n, s, r, i, a) {
  let o, l, f, d, u, c, h;
  const p = r[i + 1], g = [];
  for (let y = 0, E = n.length; y < E; ++y) {
    const C = n[y];
    for (d = e[C - s], c = e[C - s + 1], o = t; o < C; o += s)
      u = e[o], h = e[o + 1], (p <= c && h <= p || c <= p && p <= h) && (f = (p - c) / (h - c) * (u - d) + d, g.push(f)), d = u, c = h;
  }
  let m = NaN, v = -1 / 0;
  for (g.sort(Ao), d = g[0], o = 1, l = g.length; o < l; ++o) {
    u = g[o];
    const y = Math.abs(u - d);
    y > v && (f = (d + u) / 2, cy(e, t, n, s, f, p) && (m = f, v = y)), d = u;
  }
  return isNaN(m) && (m = r[i]), a ? (a.push(m, p, v), a) : [m, p, v];
}
function rP(e, t, n, s, r) {
  let i = [];
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    i = hy(
      e,
      t,
      l,
      s,
      r,
      2 * a,
      i
    ), t = l[l.length - 1];
  }
  return i;
}
function sP(e, t, n, s, r) {
  let i;
  for (t += s; t < n; t += s)
    if (i = r(
      e.slice(t - s, t),
      e.slice(t, t + s)
    ), i)
      return i;
  return !1;
}
function Sf(e, t, n, s, r) {
  const i = WT(
    Ni(),
    e,
    t,
    n,
    s
  );
  return cn(r, i) ? Ar(r, i) || i[0] >= r[0] && i[2] <= r[2] || i[1] >= r[1] && i[3] <= r[3] ? !0 : sP(
    e,
    t,
    n,
    s,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(a, o) {
      return Q_(r, a, o);
    }
  ) : !1;
}
function wD(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    if (Sf(e, t, n[i], s, r))
      return !0;
    t = n[i];
  }
  return !1;
}
function aP(e, t, n, s, r) {
  return !!(Sf(e, t, n, s, r) || vo(
    e,
    t,
    n,
    s,
    r[0],
    r[1]
  ) || vo(
    e,
    t,
    n,
    s,
    r[0],
    r[3]
  ) || vo(
    e,
    t,
    n,
    s,
    r[2],
    r[1]
  ) || vo(
    e,
    t,
    n,
    s,
    r[2],
    r[3]
  ));
}
function oP(e, t, n, s, r) {
  if (!aP(e, t, n[0], s, r))
    return !1;
  if (n.length === 1)
    return !0;
  for (let i = 1, a = n.length; i < a; ++i)
    if (LD(
      e,
      n[i - 1],
      n[i],
      s,
      r
    ) && !Sf(
      e,
      n[i - 1],
      n[i],
      s,
      r
    ))
      return !1;
  return !0;
}
function VD(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    if (oP(e, t, o, s, r))
      return !0;
    t = o[o.length - 1];
  }
  return !1;
}
function BD(e, t, n, s) {
  for (; t < n - s; ) {
    for (let r = 0; r < s; ++r) {
      const i = e[t + r];
      e[t + r] = e[n - s + r], e[n - s + r] = i;
    }
    t += s, n -= s;
  }
}
function dy(e, t, n, s) {
  let r = 0, i = e[n - s], a = e[n - s + 1];
  for (; t < n; t += s) {
    const o = e[t], l = e[t + 1];
    r += (o - i) * (l + a), i = o, a = l;
  }
  return r === 0 ? void 0 : r > 0;
}
function lP(e, t, n, s, r) {
  r = r !== void 0 ? r : !1;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i], l = dy(
      e,
      t,
      o,
      s
    );
    if (i === 0) {
      if (r && l || !r && !l)
        return !1;
    } else if (r && !l || !r && l)
      return !1;
    t = o;
  }
  return !0;
}
function ND(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    if (!lP(e, t, o, s, r))
      return !1;
    o.length && (t = o[o.length - 1]);
  }
  return !0;
}
function _g(e, t, n, s, r) {
  r = r !== void 0 ? r : !1;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i], l = dy(
      e,
      t,
      o,
      s
    );
    (i === 0 ? r && l || !r && !l : r && !l || !r && l) && BD(e, t, o, s), t = o;
  }
  return t;
}
function FE(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i)
    t = _g(
      e,
      t,
      n[i],
      s,
      r
    );
  return t;
}
function FD(e, t) {
  const n = [];
  let s = 0, r = 0;
  for (let i = 0, a = t.length; i < a; ++i) {
    const o = t[i];
    if (!dy(e, s, o, 2))
      n.push(t.slice(r, i + 1));
    else {
      if (n.length === 0)
        continue;
      n[n.length - 1].push(t[r]);
    }
    r = i + 1, s = o;
  }
  return n;
}
class Ql extends na {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(t, n, s) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, n !== void 0 && s ? (this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ), this.ends_ = s) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      t,
      n
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const t = new Ql(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Xo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      sy(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), oy(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    return cy(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t,
      n
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return nP(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let n;
    return t !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), _g(n, 0, this.ends_, this.stride, t)) : n = this.flatCoordinates, ac(n, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const t = Fi(this.getExtent());
      this.flatInteriorPoint_ = hy(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new hi(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(t) {
    return t < 0 || this.ends_.length <= t ? null : new vd(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const t = this.layout, n = this.flatCoordinates, s = this.ends_, r = [];
    let i = 0;
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a], f = new vd(
        n.slice(i, l),
        t
      );
      r.push(f), i = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      lP(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = _g(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = tP(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(t),
      n,
      0,
      s
    ), new Ql(n, "XY", s);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return oP(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const s = ly(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1], this.changed();
  }
}
const nr = Ql;
function uP(e, t, n, s) {
  n = n || 32;
  const r = [];
  for (let i = 0; i < n; ++i)
    Kn(
      r,
      dD(e, t, 2 * Math.PI * i / n, s)
    );
  return r.push(r[0], r[1]), new Ql(r, "XY", [r.length]);
}
function jE(e) {
  const t = e[0], n = e[1], s = e[2], r = e[3], i = [
    t,
    n,
    t,
    r,
    s,
    r,
    s,
    n,
    t,
    n
  ];
  return new Ql(i, "XY", [i.length]);
}
const on = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
};
class jD extends Ui {
  /**
   * @param {GeolocationPositionError} error error object.
   */
  constructor(t) {
    super(Kt.ERROR), this.code = t.code, this.message = t.message;
  }
}
class UD extends Er {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.position_ = null, this.transform_ = ty, this.watchId_ = void 0, this.addChangeListener(on.PROJECTION, this.handleProjectionChanged_), this.addChangeListener(on.TRACKING, this.handleTrackingChanged_), t.projection !== void 0 && this.setProjection(t.projection), t.trackingOptions !== void 0 && this.setTrackingOptions(t.trackingOptions), this.setTracking(t.tracking !== void 0 ? t.tracking : !1);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setTracking(!1), super.disposeInternal();
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    const t = this.getProjection();
    t && (this.transform_ = Pf(
      Wt("EPSG:4326"),
      t
    ), this.position_ && this.set(on.POSITION, this.transform_(this.position_)));
  }
  /**
   * @private
   */
  handleTrackingChanged_() {
    if ("geolocation" in navigator) {
      const t = this.getTracking();
      t && this.watchId_ === void 0 ? this.watchId_ = navigator.geolocation.watchPosition(
        this.positionChange_.bind(this),
        this.positionError_.bind(this),
        this.getTrackingOptions()
      ) : !t && this.watchId_ !== void 0 && (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0);
    }
  }
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */
  positionChange_(t) {
    const n = t.coords;
    this.set(on.ACCURACY, n.accuracy), this.set(
      on.ALTITUDE,
      n.altitude === null ? void 0 : n.altitude
    ), this.set(
      on.ALTITUDE_ACCURACY,
      n.altitudeAccuracy === null ? void 0 : n.altitudeAccuracy
    ), this.set(
      on.HEADING,
      n.heading === null ? void 0 : Po(n.heading)
    ), this.position_ ? (this.position_[0] = n.longitude, this.position_[1] = n.latitude) : this.position_ = [n.longitude, n.latitude];
    const s = this.transform_(this.position_);
    this.set(on.POSITION, s), this.set(on.SPEED, n.speed === null ? void 0 : n.speed);
    const r = uP(this.position_, n.accuracy);
    r.applyTransform(this.transform_), this.set(on.ACCURACY_GEOMETRY, r), this.changed();
  }
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */
  positionError_(t) {
    this.dispatchEvent(new jD(t));
  }
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */
  getAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(on.ACCURACY)
    );
  }
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */
  getAccuracyGeometry() {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(on.ACCURACY_GEOMETRY) || null
    );
  }
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */
  getAltitude() {
    return (
      /** @type {number|undefined} */
      this.get(on.ALTITUDE)
    );
  }
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */
  getAltitudeAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(on.ALTITUDE_ACCURACY)
    );
  }
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */
  getHeading() {
    return (
      /** @type {number|undefined} */
      this.get(on.HEADING)
    );
  }
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(on.POSITION)
    );
  }
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(on.PROJECTION)
    );
  }
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */
  getSpeed() {
    return (
      /** @type {number|undefined} */
      this.get(on.SPEED)
    );
  }
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */
  getTracking() {
    return (
      /** @type {boolean} */
      this.get(on.TRACKING)
    );
  }
  /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  getTrackingOptions() {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(on.TRACKING_OPTIONS)
    );
  }
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  setProjection(t) {
    this.set(on.PROJECTION, Wt(t));
  }
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */
  setTracking(t) {
    this.set(on.TRACKING, t);
  }
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  setTrackingOptions(t) {
    this.set(on.TRACKING_OPTIONS, t);
  }
}
const WD = UD, Aa = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};
class fy {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new fy({
      color: Array.isArray(t) ? t.slice() : t || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
}
const Lr = fy;
function yd(e, t, n, s, r, i, a) {
  let o, l;
  const f = (n - t) / s;
  if (f === 1)
    o = t;
  else if (f === 2)
    o = t, l = r;
  else if (f !== 0) {
    let d = e[t], u = e[t + 1], c = 0;
    const h = [0];
    for (let m = t + s; m < n; m += s) {
      const v = e[m], y = e[m + 1];
      c += Math.sqrt((v - d) * (v - d) + (y - u) * (y - u)), h.push(c), d = v, u = y;
    }
    const p = r * c, g = D_(h, p);
    g < 0 ? (l = (p - h[-g - 2]) / (h[-g - 1] - h[-g - 2]), o = t + (-g - 2) * s) : o = t + g * s;
  }
  a = a > 1 ? a : 2, i = i || new Array(a);
  for (let d = 0; d < a; ++d)
    i[d] = o === void 0 ? NaN : l === void 0 ? e[o + d] : Bs(e[o + d], e[o + s + d], l);
  return i;
}
function Dg(e, t, n, s, r, i) {
  if (n == t)
    return null;
  let a;
  if (r < e[t + s - 1])
    return i ? (a = e.slice(t, t + s), a[s - 1] = r, a) : null;
  if (e[n - 1] < r)
    return i ? (a = e.slice(n - s, n), a[s - 1] = r, a) : null;
  if (r == e[t + s - 1])
    return e.slice(t, t + s);
  let o = t / s, l = n / s;
  for (; o < l; ) {
    const c = o + l >> 1;
    r < e[(c + 1) * s - 1] ? l = c : o = c + 1;
  }
  const f = e[o * s - 1];
  if (r == f)
    return e.slice((o - 1) * s, (o - 1) * s + s);
  const d = e[(o + 1) * s - 1], u = (r - f) / (d - f);
  a = [];
  for (let c = 0; c < s - 1; ++c)
    a.push(
      Bs(
        e[(o - 1) * s + c],
        e[o * s + c],
        u
      )
    );
  return a.push(r), a;
}
function $D(e, t, n, s, r, i, a) {
  if (a)
    return Dg(
      e,
      t,
      n[n.length - 1],
      s,
      r,
      i
    );
  let o;
  if (r < e[s - 1])
    return i ? (o = e.slice(0, s), o[s - 1] = r, o) : null;
  if (e[e.length - 1] < r)
    return i ? (o = e.slice(e.length - s), o[s - 1] = r, o) : null;
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    if (t != d) {
      if (r < e[t + s - 1])
        return null;
      if (r <= e[d - 1])
        return Dg(
          e,
          t,
          d,
          s,
          r,
          !1
        );
      t = d;
    }
  }
  return null;
}
function cP(e, t, n, s) {
  let r = e[t], i = e[t + 1], a = 0;
  for (let o = t + s; o < n; o += s) {
    const l = e[o], f = e[o + 1];
    a += Math.sqrt((l - r) * (l - r) + (f - i) * (f - i)), r = l, i = f;
  }
  return a;
}
class Ed extends na {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const t = new Ed(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Xo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ry(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), ay(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(t) {
    return sP(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, n) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (n = n !== void 0 ? n : !1, Dg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return ba(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(t, n) {
    return yd(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return cP(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [];
    return n.length = uy(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      0
    ), new Ed(n, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return Sf(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const qi = Ed;
class py {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new py({
      color: Array.isArray(t) ? t.slice() : t || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(t) {
    this.lineCap_ = t;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(t) {
    this.lineDash_ = t;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(t) {
    this.lineDashOffset_ = t;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(t) {
    this.lineJoin_ = t;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(t) {
    this.miterLimit_ = t;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(t) {
    this.width_ = t;
  }
}
const pr = py, ce = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function UE(e, t, n) {
  return n === void 0 && (n = [0, 0]), n[0] = e[0] + 2 * t, n[1] = e[1] + 2 * t, n;
}
function WE(e) {
  return e[0] > 0 && e[1] > 0;
}
function hP(e, t, n) {
  return n === void 0 && (n = [0, 0]), n[0] = e[0] * t + 0.5 | 0, n[1] = e[1] * t + 0.5 | 0, n;
}
function ti(e, t) {
  return Array.isArray(e) ? e : (t === void 0 ? t = [e, e] : (t[0] = e, t[1] = e), t);
}
class my {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = ti(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new my({
      opacity: this.getOpacity(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Gt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getImage(t) {
    return Gt();
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getHitDetectionImage() {
    return Gt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Gt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Gt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Gt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Gt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(t) {
    this.displacement_ = t;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(t) {
    this.opacity_ = t;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = ti(t);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    Gt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Gt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    Gt();
  }
}
const dP = my, zD = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, KD = /^([a-z]*)$|^hsla?\(.*\)$/i;
function fP(e) {
  return typeof e == "string" ? e : pP(e);
}
function GD(e) {
  const t = document.createElement("div");
  if (t.style.color = e, t.style.color !== "") {
    document.body.appendChild(t);
    const n = getComputedStyle(t).color;
    return document.body.removeChild(t), n;
  } else
    return "";
}
const kD = function() {
  const t = {};
  let n = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function(s) {
      let r;
      if (t.hasOwnProperty(s))
        r = t[s];
      else {
        if (n >= 1024) {
          let i = 0;
          for (const a in t)
            i++ & 3 || (delete t[a], --n);
        }
        r = HD(s), t[s] = r, ++n;
      }
      return r;
    }
  );
}();
function Cd(e) {
  return Array.isArray(e) ? e : kD(e);
}
function HD(e) {
  let t, n, s, r, i;
  if (KD.exec(e) && (e = GD(e)), zD.exec(e)) {
    const a = e.length - 1;
    let o;
    a <= 4 ? o = 1 : o = 2;
    const l = a === 4 || a === 8;
    t = parseInt(e.substr(1 + 0 * o, o), 16), n = parseInt(e.substr(1 + 1 * o, o), 16), s = parseInt(e.substr(1 + 2 * o, o), 16), l ? r = parseInt(e.substr(1 + 3 * o, o), 16) : r = 255, o == 1 && (t = (t << 4) + t, n = (n << 4) + n, s = (s << 4) + s, l && (r = (r << 4) + r)), i = [t, n, s, r / 255];
  } else
    e.startsWith("rgba(") ? (i = e.slice(5, -1).split(",").map(Number), $E(i)) : e.startsWith("rgb(") ? (i = e.slice(4, -1).split(",").map(Number), i.push(1), $E(i)) : Zt(!1, 14);
  return i;
}
function $E(e) {
  return e[0] = hn(e[0] + 0.5 | 0, 0, 255), e[1] = hn(e[1] + 0.5 | 0, 0, 255), e[2] = hn(e[2] + 0.5 | 0, 0, 255), e[3] = hn(e[3], 0, 1), e;
}
function pP(e) {
  let t = e[0];
  t != (t | 0) && (t = t + 0.5 | 0);
  let n = e[1];
  n != (n | 0) && (n = n + 0.5 | 0);
  let s = e[2];
  s != (s | 0) && (s = s + 0.5 | 0);
  const r = e[3] === void 0 ? 1 : Math.round(e[3] * 100) / 100;
  return "rgba(" + t + "," + n + "," + s + "," + r + ")";
}
function os(e) {
  return Array.isArray(e) ? pP(e) : e;
}
function Ii(e, t, n, s) {
  let r;
  return n && n.length ? r = n.shift() : Kv ? r = new OffscreenCanvas(e || 300, t || 300) : r = document.createElement("canvas"), e && (r.width = e), t && (r.height = t), /** @type {CanvasRenderingContext2D} */
  r.getContext("2d", s);
}
function gy(e) {
  const t = e.canvas;
  t.width = 1, t.height = 1, e.clearRect(0, 0, 1, 1);
}
function YD(e) {
  let t = e.offsetWidth;
  const n = getComputedStyle(e);
  return t += parseInt(n.marginLeft, 10) + parseInt(n.marginRight, 10), t;
}
function XD(e) {
  let t = e.offsetHeight;
  const n = getComputedStyle(e);
  return t += parseInt(n.marginTop, 10) + parseInt(n.marginBottom, 10), t;
}
function zE(e, t) {
  const n = t.parentNode;
  n && n.replaceChild(e, t);
}
function xd(e) {
  return e && e.parentNode ? e.parentNode.removeChild(e) : null;
}
function mP(e) {
  for (; e.lastChild; )
    e.removeChild(e.lastChild);
}
function ZD(e, t) {
  const n = e.childNodes;
  for (let s = 0; ; ++s) {
    const r = n[s], i = t[s];
    if (!r && !i)
      break;
    if (r !== i) {
      if (!r) {
        e.appendChild(i);
        continue;
      }
      if (!i) {
        e.removeChild(r), --s;
        continue;
      }
      e.insertBefore(i, r);
    }
  }
}
const fh = "ol-hidden", JD = "ol-selectable", If = "ol-unselectable", vy = "ol-control", KE = "ol-collapsed", QD = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), GE = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], gP = function(e) {
  const t = e.match(QD);
  if (!t)
    return null;
  const n = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let s = 0, r = GE.length; s < r; ++s) {
    const i = t[s + 1];
    i !== void 0 && (n[GE[s]] = i);
  }
  return n.families = n.family.split(/,\s?/), n;
}, vP = "10px sans-serif", Gs = "#000", bd = "round", oc = [], lc = 0, ql = "round", uc = 10, cc = "#000", hc = "center", Od = "middle", yo = [0, 0, 0, 0], dc = 1, Rs = new Er();
let pl = null, Ag;
const Lg = {}, qD = function() {
  const t = "32px ", n = ["monospace", "serif"], s = n.length, r = "wmytzilWMYTZIL@#/&?$%10";
  let i, a;
  function o(f, d, u) {
    let c = !0;
    for (let h = 0; h < s; ++h) {
      const p = n[h];
      if (a = Td(
        f + " " + d + " " + t + p,
        r
      ), u != p) {
        const g = Td(
          f + " " + d + " " + t + u + "," + p,
          r
        );
        c = c && g != a;
      }
    }
    return !!c;
  }
  function l() {
    let f = !0;
    const d = Rs.getKeys();
    for (let u = 0, c = d.length; u < c; ++u) {
      const h = d[u];
      Rs.get(h) < 100 && (o.apply(this, h.split(`
`)) ? (ou(Lg), pl = null, Ag = void 0, Rs.set(h, 100)) : (Rs.set(h, Rs.get(h) + 1, !0), f = !1));
    }
    f && (clearInterval(i), i = void 0);
  }
  return function(f) {
    const d = gP(f);
    if (!d)
      return;
    const u = d.families;
    for (let c = 0, h = u.length; c < h; ++c) {
      const p = u[c], g = d.style + `
` + d.weight + `
` + p;
      Rs.get(g) === void 0 && (Rs.set(g, 100, !0), o(d.style, d.weight, p) || (Rs.set(g, 0, !0), i === void 0 && (i = setInterval(l, 32))));
    }
  };
}(), tA = function() {
  let e;
  return function(t) {
    let n = Lg[t];
    if (n == null) {
      if (Kv) {
        const s = gP(t), r = yP(t, "Žg");
        n = (isNaN(Number(s.lineHeight)) ? 1.2 : Number(s.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
      } else
        e || (e = document.createElement("div"), e.innerHTML = "M", e.style.minHeight = "0", e.style.maxHeight = "none", e.style.height = "auto", e.style.padding = "0", e.style.border = "none", e.style.position = "absolute", e.style.display = "block", e.style.left = "-99999px"), e.style.font = t, document.body.appendChild(e), n = e.offsetHeight, document.body.removeChild(e);
      Lg[t] = n;
    }
    return n;
  };
}();
function yP(e, t) {
  return pl || (pl = Ii(1, 1)), e != Ag && (pl.font = e, Ag = pl.font), pl.measureText(t);
}
function Td(e, t) {
  return yP(e, t).width;
}
function kE(e, t, n) {
  if (t in n)
    return n[t];
  const s = t.split(`
`).reduce((r, i) => Math.max(r, Td(e, i)), 0);
  return n[t] = s, s;
}
function eA(e, t) {
  const n = [], s = [], r = [];
  let i = 0, a = 0, o = 0, l = 0;
  for (let f = 0, d = t.length; f <= d; f += 2) {
    const u = t[f];
    if (u === `
` || f === d) {
      i = Math.max(i, a), r.push(a), a = 0, o += l;
      continue;
    }
    const c = t[f + 1] || e.font, h = Td(c, u);
    n.push(h), a += h;
    const p = tA(c);
    s.push(p), l = Math.max(l, p);
  }
  return { width: i, height: o, widths: n, heights: s, lineWidths: r };
}
function nA(e, t, n, s, r, i, a, o, l, f, d) {
  e.save(), n !== 1 && (e.globalAlpha *= n), t && e.setTransform.apply(e, t), /** @type {*} */
  s.contextInstructions ? (e.translate(l, f), e.scale(d[0], d[1]), iA(
    /** @type {Label} */
    s,
    e
  )) : d[0] < 0 || d[1] < 0 ? (e.translate(l, f), e.scale(d[0], d[1]), e.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    s,
    r,
    i,
    a,
    o,
    0,
    0,
    a,
    o
  )) : e.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    s,
    r,
    i,
    a,
    o,
    l,
    f,
    a * d[0],
    o * d[1]
  ), e.restore();
}
function iA(e, t) {
  const n = e.contextInstructions;
  for (let s = 0, r = n.length; s < r; s += 2)
    Array.isArray(n[s + 1]) ? t[n[s]].apply(
      t,
      n[s + 1]
    ) : t[n[s]] = n[s + 1];
}
class yy extends dP {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    const n = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: 1,
      rotateWithView: n,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      scale: t.scale !== void 0 ? t.scale : 1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = t.radius !== void 0 ? t.radius : t.radius1, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), n = new yy({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const t = this.size_;
    if (!t)
      return null;
    const n = this.getDisplacement(), s = this.getScaleArray();
    return [
      t[0] / 2 - n[0] / s[0],
      t[1] / 2 + n[1] / s[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    let n = this.canvas_[t];
    if (!n) {
      const s = this.renderOptions_, r = Ii(
        s.size * t,
        s.size * t
      );
      this.draw_(s, r, t), n = r.canvas, this.canvas_[t] = n;
    }
    return n;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return t;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return ce.LOADED;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(t, n, s) {
    if (n === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
      return n;
    let r = this.radius_, i = this.radius2_ === void 0 ? r : this.radius2_;
    if (r < i) {
      const b = r;
      r = i, i = b;
    }
    const a = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, o = 2 * Math.PI / a, l = i * Math.sin(o), f = Math.sqrt(i * i - l * l), d = r - f, u = Math.sqrt(l * l + d * d), c = u / l;
    if (t === "miter" && c <= s)
      return c * n;
    const h = n / 2 / c, p = n / 2 * (d / u), m = Math.sqrt((r + h) * (r + h) + p * p) - r;
    if (this.radius2_ === void 0 || t === "bevel")
      return m * 2;
    const v = r * Math.sin(o), y = Math.sqrt(r * r - v * v), E = i - y, x = Math.sqrt(v * v + E * E) / v;
    if (x <= s) {
      const b = x * n / 2 - i - r;
      return 2 * Math.max(m, b);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let t = ql, n = 0, s = null, r = 0, i, a = 0;
    this.stroke_ && (i = this.stroke_.getColor(), i === null && (i = cc), i = os(i), a = this.stroke_.getWidth(), a === void 0 && (a = dc), s = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset(), t = this.stroke_.getLineJoin(), t === void 0 && (t = ql), n = this.stroke_.getMiterLimit(), n === void 0 && (n = uc));
    const o = this.calculateLineJoinSize_(t, a, n), l = Math.max(this.radius_, this.radius2_ || 0), f = Math.ceil(2 * l + o);
    return {
      strokeStyle: i,
      strokeWidth: a,
      size: f,
      lineDash: s,
      lineDashOffset: r,
      lineJoin: t,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const t = this.renderOptions_.size;
    this.canvas_ = {}, this.size_ = [t, t];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(t, n, s) {
    if (n.scale(s, s), n.translate(t.size / 2, t.size / 2), this.createPath_(n), this.fill_) {
      let r = this.fill_.getColor();
      r === null && (r = Gs), n.fillStyle = os(r), n.fill();
    }
    this.stroke_ && (n.strokeStyle = t.strokeStyle, n.lineWidth = t.strokeWidth, t.lineDash && (n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset), n.lineJoin = t.lineJoin, n.miterLimit = t.miterLimit, n.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(t) {
    if (this.fill_) {
      let n = this.fill_.getColor(), s = 0;
      if (typeof n == "string" && (n = Cd(n)), n === null ? s = 1 : Array.isArray(n) && (s = n.length === 4 ? n[3] : 1), s === 0) {
        const r = Ii(
          t.size,
          t.size
        );
        this.hitDetectionCanvas_ = r.canvas, this.drawHitDetectionCanvas_(t, r);
      }
    }
    this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(t) {
    let n = this.points_;
    const s = this.radius_;
    if (n === 1 / 0)
      t.arc(0, 0, s, 0, 2 * Math.PI);
    else {
      const r = this.radius2_ === void 0 ? s : this.radius2_;
      this.radius2_ !== void 0 && (n *= 2);
      const i = this.angle_ - Math.PI / 2, a = 2 * Math.PI / n;
      for (let o = 0; o < n; o++) {
        const l = i + o * a, f = o % 2 === 0 ? s : r;
        t.lineTo(f * Math.cos(l), f * Math.sin(l));
      }
      t.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(t, n) {
    n.translate(t.size / 2, t.size / 2), this.createPath_(n), n.fillStyle = Gs, n.fill(), this.stroke_ && (n.strokeStyle = t.strokeStyle, n.lineWidth = t.strokeWidth, t.lineDash && (n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset), n.lineJoin = t.lineJoin, n.miterLimit = t.miterLimit, n.stroke());
  }
}
const EP = yy;
class Ey extends EP {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || { radius: 5 }, super({
      points: 1 / 0,
      fill: t.fill,
      radius: t.radius,
      stroke: t.stroke,
      scale: t.scale !== void 0 ? t.scale : 1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), n = new Ey({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(t) {
    this.radius_ = t, this.render();
  }
}
const _f = Ey;
class Oa {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(t) {
    t = t || {}, this.geometry_ = null, this.geometryFunction_ = HE, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let t = this.getGeometry();
    return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
    t.clone()), new Oa({
      geometry: t,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(t) {
    this.renderer_ = t;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(t) {
    this.hitDetectionRenderer_ = t;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(t) {
    typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(n) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        n.get(t)
      );
    } : t ? t !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t
      );
    }) : this.geometryFunction_ = HE, this.geometry_ = t;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(t) {
    this.zIndex_ = t;
  }
}
function rA(e) {
  let t;
  if (typeof e == "function")
    t = e;
  else {
    let n;
    Array.isArray(e) ? n = e : (Zt(typeof /** @type {?} */
    e.getZIndex == "function", 41), n = [
      /** @type {Style} */
      e
    ]), t = function() {
      return n;
    };
  }
  return t;
}
let lp = null;
function sA(e, t) {
  if (!lp) {
    const n = new Lr({
      color: "rgba(255,255,255,0.4)"
    }), s = new pr({
      color: "#3399CC",
      width: 1.25
    });
    lp = [
      new Oa({
        image: new _f({
          fill: n,
          stroke: s,
          radius: 5
        }),
        fill: n,
        stroke: s
      })
    ];
  }
  return lp;
}
function CP() {
  const e = {}, t = [255, 255, 255, 1], n = [0, 153, 255, 1], s = 3;
  return e.Polygon = [
    new Oa({
      fill: new Lr({
        color: [255, 255, 255, 0.5]
      })
    })
  ], e.MultiPolygon = e.Polygon, e.LineString = [
    new Oa({
      stroke: new pr({
        color: t,
        width: s + 2
      })
    }),
    new Oa({
      stroke: new pr({
        color: n,
        width: s
      })
    })
  ], e.MultiLineString = e.LineString, e.Circle = e.Polygon.concat(e.LineString), e.Point = [
    new Oa({
      image: new _f({
        radius: s * 2,
        fill: new Lr({
          color: n
        }),
        stroke: new pr({
          color: t,
          width: s / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], e.MultiPoint = e.Point, e.GeometryCollection = e.Polygon.concat(
    e.LineString,
    e.Point
  ), e;
}
function HE(e) {
  return e.getGeometry();
}
const zn = Oa, aA = "#333";
class Cy {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = ti(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new Lr({ color: aA }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Cy({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(t) {
    this.overflow_ = t;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(t) {
    this.font_ = t;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(t) {
    this.maxAngle_ = t;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(t) {
    this.offsetX_ = t;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(t) {
    this.offsetY_ = t;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(t) {
    this.placement_ = t;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = ti(t !== void 0 ? t : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(t) {
    this.textAlign_ = t;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(t) {
    this.justify_ = t;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(t) {
    this.textBaseline_ = t;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(t) {
    this.backgroundFill_ = t;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(t) {
    this.backgroundStroke_ = t;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(t) {
    this.padding_ = t;
  }
}
const xP = Cy, Be = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class oA extends Er {
  /**
   * @param {Options} options Layer options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.background_ = t.background;
    const n = Object.assign({}, t);
    typeof t.properties == "object" && (delete n.properties, Object.assign(n, t.properties)), n[Be.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, Zt(typeof n[Be.OPACITY] == "number", 64), n[Be.VISIBLE] = t.visible !== void 0 ? t.visible : !0, n[Be.Z_INDEX] = t.zIndex, n[Be.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, n[Be.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, n[Be.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, n[Be.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = n.className !== void 0 ? n.className : "ol-layer", delete n.className, this.setProperties(n), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(t) {
    const n = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: t === void 0 ? !0 : t
    }, s = this.getZIndex();
    return n.opacity = hn(Math.round(this.getOpacity() * 100) / 100, 0, 1), n.visible = this.getVisible(), n.extent = this.getExtent(), n.zIndex = s === void 0 && !n.managed ? 1 / 0 : s, n.maxResolution = this.getMaxResolution(), n.minResolution = Math.max(this.getMinResolution(), 0), n.minZoom = this.getMinZoom(), n.maxZoom = this.getMaxZoom(), this.state_ = n, n;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return Gt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return Gt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Be.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Be.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Be.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Be.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Be.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Be.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Gt();
  }
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Be.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number} */
      this.get(Be.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(t) {
    this.background_ = t, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(t) {
    this.set(Be.EXTENT, t);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(t) {
    this.set(Be.MAX_RESOLUTION, t);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(t) {
    this.set(Be.MIN_RESOLUTION, t);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(t) {
    this.set(Be.MAX_ZOOM, t);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(t) {
    this.set(Be.MIN_ZOOM, t);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(t) {
    Zt(typeof t == "number", 64), this.set(Be.OPACITY, t);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(t) {
    this.set(Be.VISIBLE, t);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(t) {
    this.set(Be.Z_INDEX, t);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const bP = oA;
class lA extends bP {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(t) {
    const n = Object.assign({}, t);
    delete n.source, super(n), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
      Be.SOURCE,
      this.handleSourcePropertyChange_
    );
    const s = t.source ? (
      /** @type {SourceType} */
      t.source
    ) : null;
    this.setSource(s);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t || [], t.push(this), t;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return t = t || [], t.push(this.getLayerState()), t;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Be.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const t = this.getSource();
    return t ? t.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (We(this.sourceChangeKey_), this.sourceChangeKey_ = null);
    const t = this.getSource();
    t && (this.sourceChangeKey_ = ge(
      t,
      Kt.CHANGE,
      this.handleSourceChange_,
      this
    )), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return this.renderer_ ? this.renderer_.getFeatures(t) : new Promise((n) => n([]));
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */
  render(t, n) {
    const s = this.getRenderer();
    if (s.prepareFrame(t))
      return this.rendered = !0, s.renderFrame(t, n);
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(t) {
    t || this.unrender(), this.set(Be.MAP, t);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Be.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.mapPrecomposeKey_ && (We(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (We(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = ge(
      t,
      Aa.PRECOMPOSE,
      function(n) {
        const r = /** @type {import("../render/Event.js").default} */ n.frameState.layerStatesArray, i = this.getLayerState(!1);
        Zt(
          !r.some(function(a) {
            return a.layer === i.layer;
          }),
          67
        ), r.push(i);
      },
      this
    ), this.mapRenderKey_ = ge(this, Kt.CHANGE, t.render, t), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(t) {
    this.set(Be.SOURCE, t);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function xy(e, t) {
  if (!e.visible)
    return !1;
  const n = t.resolution;
  if (n < e.minResolution || n >= e.maxResolution)
    return !1;
  const s = t.zoom;
  return s > e.minZoom && s <= e.maxZoom;
}
const lu = lA;
function uA(e, t, n, s, r) {
  OP(e, t, n || 0, s || e.length - 1, r || cA);
}
function OP(e, t, n, s, r) {
  for (; s > n; ) {
    if (s - n > 600) {
      var i = s - n + 1, a = t - n + 1, o = Math.log(i), l = 0.5 * Math.exp(2 * o / 3), f = 0.5 * Math.sqrt(o * l * (i - l) / i) * (a - i / 2 < 0 ? -1 : 1), d = Math.max(n, Math.floor(t - a * l / i + f)), u = Math.min(s, Math.floor(t + (i - a) * l / i + f));
      OP(e, t, d, u, r);
    }
    var c = e[t], h = n, p = s;
    for (Ru(e, n, t), r(e[s], c) > 0 && Ru(e, n, s); h < p; ) {
      for (Ru(e, h, p), h++, p--; r(e[h], c) < 0; )
        h++;
      for (; r(e[p], c) > 0; )
        p--;
    }
    r(e[n], c) === 0 ? Ru(e, n, p) : (p++, Ru(e, p, s)), p <= t && (n = p + 1), t <= p && (s = p - 1);
  }
}
function Ru(e, t, n) {
  var s = e[t];
  e[t] = e[n], e[n] = s;
}
function cA(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
let TP = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const s = [];
    if (!mh(t, n))
      return s;
    const r = this.toBBox, i = [];
    for (; n; ) {
      for (let a = 0; a < n.children.length; a++) {
        const o = n.children[a], l = n.leaf ? r(o) : o;
        mh(t, l) && (n.leaf ? s.push(o) : cp(t, l) ? this._all(o, s) : i.push(o));
      }
      n = i.pop();
    }
    return s;
  }
  collides(t) {
    let n = this.data;
    if (!mh(t, n))
      return !1;
    const s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const i = n.children[r], a = n.leaf ? this.toBBox(i) : i;
        if (mh(t, a)) {
          if (n.leaf || cp(t, a))
            return !0;
          s.push(i);
        }
      }
      n = s.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length))
      return this;
    if (t.length < this._minEntries) {
      for (let s = 0; s < t.length; s++)
        this.insert(t[s]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const s = this.data;
        this.data = n, n = s;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = ml([]), this;
  }
  remove(t, n) {
    if (!t)
      return this;
    let s = this.data;
    const r = this.toBBox(t), i = [], a = [];
    let o, l, f;
    for (; s || i.length; ) {
      if (s || (s = i.pop(), l = i[i.length - 1], o = a.pop(), f = !0), s.leaf) {
        const d = hA(t, s.children, n);
        if (d !== -1)
          return s.children.splice(d, 1), i.push(s), this._condense(i), this;
      }
      !f && !s.leaf && cp(s, r) ? (i.push(s), a.push(o), o = 0, l = s, s = s.children[0]) : l ? (o++, s = l.children[o], f = !1) : s = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const s = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : s.push(...t.children), t = s.pop();
    return n;
  }
  _build(t, n, s, r) {
    const i = s - n + 1;
    let a = this._maxEntries, o;
    if (i <= a)
      return o = ml(t.slice(n, s + 1)), sl(o, this.toBBox), o;
    r || (r = Math.ceil(Math.log(i) / Math.log(a)), a = Math.ceil(i / Math.pow(a, r - 1))), o = ml([]), o.leaf = !1, o.height = r;
    const l = Math.ceil(i / a), f = l * Math.ceil(Math.sqrt(a));
    YE(t, n, s, f, this.compareMinX);
    for (let d = n; d <= s; d += f) {
      const u = Math.min(d + f - 1, s);
      YE(t, d, u, l, this.compareMinY);
      for (let c = d; c <= u; c += l) {
        const h = Math.min(c + l - 1, u);
        o.children.push(this._build(t, c, h, r - 1));
      }
    }
    return sl(o, this.toBBox), o;
  }
  _chooseSubtree(t, n, s, r) {
    for (; r.push(n), !(n.leaf || r.length - 1 === s); ) {
      let i = 1 / 0, a = 1 / 0, o;
      for (let l = 0; l < n.children.length; l++) {
        const f = n.children[l], d = up(f), u = pA(t, f) - d;
        u < a ? (a = u, i = d < i ? d : i, o = f) : u === a && d < i && (i = d, o = f);
      }
      n = o || n.children[0];
    }
    return n;
  }
  _insert(t, n, s) {
    const r = s ? t : this.toBBox(t), i = [], a = this._chooseSubtree(r, this.data, n, i);
    for (a.children.push(t), ku(a, r); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(r, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const s = t[n], r = s.children.length, i = this._minEntries;
    this._chooseSplitAxis(s, i, r);
    const a = this._chooseSplitIndex(s, i, r), o = ml(s.children.splice(a, s.children.length - a));
    o.height = s.height, o.leaf = s.leaf, sl(s, this.toBBox), sl(o, this.toBBox), n ? t[n - 1].children.push(o) : this._splitRoot(s, o);
  }
  _splitRoot(t, n) {
    this.data = ml([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, sl(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, s) {
    let r, i = 1 / 0, a = 1 / 0;
    for (let o = n; o <= s - n; o++) {
      const l = Gu(t, 0, o, this.toBBox), f = Gu(t, o, s, this.toBBox), d = mA(l, f), u = up(l) + up(f);
      d < i ? (i = d, r = o, a = u < a ? u : a) : d === i && u < a && (a = u, r = o);
    }
    return r || s - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, s) {
    const r = t.leaf ? this.compareMinX : dA, i = t.leaf ? this.compareMinY : fA, a = this._allDistMargin(t, n, s, r), o = this._allDistMargin(t, n, s, i);
    a < o && t.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, s, r) {
    t.children.sort(r);
    const i = this.toBBox, a = Gu(t, 0, n, i), o = Gu(t, s - n, s, i);
    let l = ph(a) + ph(o);
    for (let f = n; f < s - n; f++) {
      const d = t.children[f];
      ku(a, t.leaf ? i(d) : d), l += ph(a);
    }
    for (let f = s - n - 1; f >= n; f--) {
      const d = t.children[f];
      ku(o, t.leaf ? i(d) : d), l += ph(o);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, s) {
    for (let r = s; r >= 0; r--)
      ku(n[r], t);
  }
  _condense(t) {
    for (let n = t.length - 1, s; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (s = t[n - 1].children, s.splice(s.indexOf(t[n]), 1)) : this.clear() : sl(t[n], this.toBBox);
  }
};
function hA(e, t, n) {
  if (!n)
    return t.indexOf(e);
  for (let s = 0; s < t.length; s++)
    if (n(e, t[s]))
      return s;
  return -1;
}
function sl(e, t) {
  Gu(e, 0, e.children.length, t, e);
}
function Gu(e, t, n, s, r) {
  r || (r = ml(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const a = e.children[i];
    ku(r, e.leaf ? s(a) : a);
  }
  return r;
}
function ku(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function dA(e, t) {
  return e.minX - t.minX;
}
function fA(e, t) {
  return e.minY - t.minY;
}
function up(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function ph(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function pA(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function mA(e, t) {
  const n = Math.max(e.minX, t.minX), s = Math.max(e.minY, t.minY), r = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, r - n) * Math.max(0, i - s);
}
function cp(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function mh(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function ml(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function YE(e, t, n, s, r) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= s)
      continue;
    const a = t + Math.ceil((n - t) / s / 2) * s;
    uA(e, a, t, n, r), i.push(t, a, a, n);
  }
}
class gA {
  constructor() {
    this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let t = 0;
      for (const n in this.cache_) {
        const s = this.cache_[n];
        !(t++ & 3) && !s.hasListener() && (delete this.cache_[n], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(t, n, s) {
    const r = XE(t, n, s);
    return r in this.cache_ ? this.cache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */
  set(t, n, s, r) {
    const i = XE(t, n, s);
    this.cache_[i] = r, ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(t) {
    this.maxCacheSize_ = t, this.expire();
  }
}
function XE(e, t, n) {
  const s = n ? fP(n) : "null";
  return t + ":" + e + ":" + s;
}
const Pd = new gA();
class vA extends wc {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  constructor(t, n, s, r) {
    super(), this.extent = t, this.pixelRatio_ = s, this.resolution = n, this.state = r;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return Gt();
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Gt();
  }
}
const PP = vA;
class yA extends PP {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, s, ce.IDLE), this.src_ = r, this.image_ = new Image(), i !== null && (this.image_.crossOrigin = i), this.unlisten_ = null, this.state = ce.IDLE, this.imageLoadFunction_ = a;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = ce.ERROR, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    this.resolution === void 0 && (this.resolution = In(this.extent) / this.image_.height), this.state = ce.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */
  load() {
    (this.state == ce.IDLE || this.state == ce.ERROR) && (this.state = ce.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = by(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  setImage(t) {
    this.image_ = t, this.resolution = In(this.extent) / this.image_.height;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function by(e, t, n) {
  const s = (
    /** @type {HTMLImageElement} */
    e
  );
  let r = !0, i = !1, a = !1;
  const o = [
    dd(s, Kt.LOAD, function() {
      a = !0, i || t();
    })
  ];
  return s.src && z_ ? (i = !0, s.decode().then(function() {
    r && t();
  }).catch(function(l) {
    r && (a ? t() : n());
  })) : o.push(dd(s, Kt.ERROR, n)), function() {
    r = !1, o.forEach(We);
  };
}
const MP = yA;
let wu = null;
class EA extends wc {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(t, n, s, r, i, a) {
    super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = r, this.canvas_ = {}, this.color_ = a, this.unlisten_ = null, this.imageState_ = i, this.size_ = s, this.src_ = n, this.tainted_;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ce.LOADED) {
      wu || (wu = Ii(1, 1)), wu.drawImage(this.image_, 0, 0);
      try {
        wu.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        wu = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = ce.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = ce.LOADED, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  getImage(t) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(t) {
    return this.replaceColor_(t), this.canvas_[t] ? t : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const t = this.size_[0], n = this.size_[1], s = Ii(t, n);
        s.fillRect(0, 0, t, n), this.hitDetectionImage_ = s.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === ce.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = ce.LOADING;
      try {
        this.image_.src = this.src_;
      } catch {
        this.handleImageError_();
      }
      this.unlisten_ = by(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(t) {
    if (!this.color_ || this.canvas_[t] || this.imageState_ !== ce.LOADED)
      return;
    const n = this.image_, s = document.createElement("canvas");
    s.width = Math.ceil(n.width * t), s.height = Math.ceil(n.height * t);
    const r = s.getContext("2d");
    r.scale(t, t), r.drawImage(n, 0, 0), r.globalCompositeOperation = "multiply", r.fillStyle = fP(this.color_), r.fillRect(0, 0, s.width / t, s.height / t), r.globalCompositeOperation = "destination-in", r.drawImage(n, 0, 0), this.canvas_[t] = s;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function CA(e, t, n, s, r, i) {
  let a = Pd.get(t, s, i);
  return a || (a = new EA(e, t, n, s, r, i), Pd.set(t, s, i, a)), a;
}
class Oy extends dP {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = t.opacity !== void 0 ? t.opacity : 1, s = t.rotation !== void 0 ? t.rotation : 0, r = t.scale !== void 0 ? t.scale : 1, i = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: n,
      rotation: s,
      scale: r,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      rotateWithView: i,
      declutterMode: t.declutterMode
    }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
    const a = t.img !== void 0 ? t.img : null;
    this.imgSize_ = t.imgSize;
    let o = t.src;
    Zt(!(o !== void 0 && a), 4), Zt(!a || a && this.imgSize_, 5), (o === void 0 || o.length === 0) && a && (o = /** @type {HTMLImageElement} */
    a.src || Xt(a)), Zt(o !== void 0 && o.length > 0, 6);
    const l = t.src !== void 0 ? ce.IDLE : ce.LOADED;
    this.color_ = t.color !== void 0 ? Cd(t.color) : null, this.iconImage_ = CA(
      a,
      /** @type {string} */
      o,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Oy({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: Array.isArray(t) ? t.slice() : t,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let t = this.normalizedAnchor_;
    if (!t) {
      t = this.anchor_;
      const r = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!r)
          return null;
        t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= r[0]), this.anchorYUnits_ == "fraction" && (t[1] *= r[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!r)
          return null;
        t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + r[1]);
      }
      this.normalizedAnchor_ = t;
    }
    const n = this.getDisplacement(), s = this.getScaleArray();
    return [
      t[0] - n[0] / s[0],
      t[1] + n[1] / s[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(t) {
    this.anchor_ = t, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    return this.iconImage_.getImage(t);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(t) {
    return this.iconImage_.getPixelRatio(t);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let t = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const n = this.getSize(), s = this.iconImage_.getSize();
      if (!n || !s)
        return null;
      t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = s[0] - n[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = s[1] - n[1] - t[1]);
    }
    return this.origin_ = t, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    this.iconImage_.addEventListener(Kt.CHANGE, t);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    this.iconImage_.removeEventListener(Kt.CHANGE, t);
  }
}
const Ua = Oy;
function ZE(e) {
  return new zn({
    fill: fc(e, ""),
    stroke: pc(e, ""),
    text: xA(e),
    image: bA(e)
  });
}
function fc(e, t) {
  const n = e[t + "fill-color"];
  if (n)
    return new Lr({ color: n });
}
function pc(e, t) {
  const n = e[t + "stroke-width"], s = e[t + "stroke-color"];
  if (!(!n && !s))
    return new pr({
      width: n,
      color: s,
      lineCap: e[t + "stroke-line-cap"],
      lineJoin: e[t + "stroke-line-join"],
      lineDash: e[t + "stroke-line-dash"],
      lineDashOffset: e[t + "stroke-line-dash-offset"],
      miterLimit: e[t + "stroke-miter-limit"]
    });
}
function xA(e) {
  const t = e["text-value"];
  return t ? new xP({
    text: t,
    font: e["text-font"],
    maxAngle: e["text-max-angle"],
    offsetX: e["text-offset-x"],
    offsetY: e["text-offset-y"],
    overflow: e["text-overflow"],
    placement: e["text-placement"],
    scale: e["text-scale"],
    rotateWithView: e["text-rotate-with-view"],
    rotation: e["text-rotation"],
    textAlign: e["text-align"],
    justify: e["text-justify"],
    textBaseline: e["text-baseline"],
    padding: e["text-padding"],
    fill: fc(e, "text-"),
    backgroundFill: fc(e, "text-background-"),
    stroke: pc(e, "text-"),
    backgroundStroke: pc(e, "text-background-")
  }) : void 0;
}
function bA(e) {
  const t = e["icon-src"], n = e["icon-img"];
  if (t || n)
    return new Ua({
      src: t,
      img: n,
      imgSize: e["icon-img-size"],
      anchor: e["icon-anchor"],
      anchorOrigin: e["icon-anchor-origin"],
      anchorXUnits: e["icon-anchor-x-units"],
      anchorYUnits: e["icon-anchor-y-units"],
      color: e["icon-color"],
      crossOrigin: e["icon-cross-origin"],
      offset: e["icon-offset"],
      displacement: e["icon-displacement"],
      opacity: e["icon-opacity"],
      scale: e["icon-scale"],
      rotation: e["icon-rotation"],
      rotateWithView: e["icon-rotate-with-view"],
      size: e["icon-size"],
      declutterMode: e["icon-declutter-mode"]
    });
  const s = e["shape-points"];
  if (s) {
    const i = "shape-";
    return new EP({
      points: s,
      fill: fc(e, i),
      stroke: pc(e, i),
      radius: e["shape-radius"],
      radius1: e["shape-radius1"],
      radius2: e["shape-radius2"],
      angle: e["shape-angle"],
      displacement: e["shape-displacement"],
      rotation: e["shape-rotation"],
      rotateWithView: e["shape-rotate-with-view"],
      scale: e["shape-scale"],
      declutterMode: e["shape-declutter-mode"]
    });
  }
  const r = e["circle-radius"];
  if (r) {
    const i = "circle-";
    return new _f({
      radius: r,
      fill: fc(e, i),
      stroke: pc(e, i),
      displacement: e["circle-displacement"],
      scale: e["circle-scale"],
      rotation: e["circle-rotation"],
      rotateWithView: e["circle-rotate-with-view"],
      declutterMode: e["circle-declutter-mode"]
    });
  }
}
const JE = {
  RENDER_ORDER: "renderOrder"
};
class OA extends lu {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = Object.assign({}, t);
    delete n.style, delete n.renderBuffer, delete n.updateWhileAnimating, delete n.updateWhileInteracting, super(n), this.declutter_ = t.declutter !== void 0 ? t.declutter : !1, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
  }
  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(JE.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    t.declutterTree || (t.declutterTree = new TP(9)), this.getRenderer().renderDeclutter(t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(t) {
    this.set(JE.RENDER_ORDER, t);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use "flat" style object literals instead of
   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(t) {
    let n;
    if (t === void 0)
      n = sA;
    else if (t === null)
      n = null;
    else if (typeof t == "function")
      n = t;
    else if (t instanceof zn)
      n = t;
    else if (Array.isArray(t)) {
      const s = t.length, r = new Array(s);
      for (let i = 0; i < s; ++i) {
        const a = t[i];
        a instanceof zn ? r[i] = a : r[i] = ZE(a);
      }
      n = r;
    } else
      n = ZE(t);
    this.style_ = n, this.styleFunction_ = t === null ? void 0 : rA(this.style_), this.changed();
  }
}
const SP = OA, jc = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, gh = [jc.FILL], Ta = [jc.STROKE], Eo = [jc.BEGIN_PATH], QE = [jc.CLOSE_PATH], Yt = jc;
class TA {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(t, n, s, r) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(t) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(t) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(t, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(t, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(t, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(t, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(t, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(t, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(t, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(t, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(t, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(t, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(t, n) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(t, n) {
  }
}
const IP = TA;
class PA extends IP {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(), this.tolerance = t, this.maxExtent = n, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = s, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(t) {
    const n = this.pixelRatio;
    return n == 1 ? t : t.map(function(s) {
      return s * n;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(t, n) {
    const s = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, i = this.coordinates;
    let a = i.length;
    for (let o = 0, l = t.length; o < l; o += n)
      r[0] = t[o], r[1] = t[o + 1], Vc(s, r) && (i[a++] = r[0], i[a++] = r[1]);
    return a;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(t, n, s, r, i, a) {
    const o = this.coordinates;
    let l = o.length;
    const f = this.getBufferedMaxExtent();
    a && (n += r);
    let d = t[n], u = t[n + 1];
    const c = this.tmpCoordinate_;
    let h = !0, p, g, m;
    for (p = n + r; p < s; p += r)
      c[0] = t[p], c[1] = t[p + 1], m = xg(f, c), m !== g ? (h && (o[l++] = d, o[l++] = u, h = !1), o[l++] = c[0], o[l++] = c[1]) : m === Wn.INTERSECTING ? (o[l++] = c[0], o[l++] = c[1], h = !1) : h = !0, d = c[0], u = c[1], g = m;
    return (i && h || p === n + r) && (o[l++] = d, o[l++] = u), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(t, n, s, r, i) {
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a], f = this.appendFlatLineCoordinates(
        t,
        n,
        l,
        r,
        !1,
        !1
      );
      i.push(f), n = l;
    }
    return n;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(t, n, s, r) {
    this.beginGeometry(t, n);
    const i = t.getType(), a = t.getStride(), o = this.coordinates.length;
    let l, f, d, u, c;
    switch (i) {
      case "MultiPolygon":
        l = /** @type {import("../../geom/MultiPolygon.js").default} */
        t.getOrientedFlatCoordinates(), u = [];
        const h = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        c = 0;
        for (let p = 0, g = h.length; p < g; ++p) {
          const m = [];
          c = this.drawCustomCoordinates_(
            l,
            c,
            h[p],
            a,
            m
          ), u.push(m);
        }
        this.instructions.push([
          Yt.CUSTOM,
          o,
          u,
          t,
          s,
          Ig
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          u,
          t,
          r || s,
          Ig
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        d = [], l = i == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          t.getOrientedFlatCoordinates()
        ) : t.getFlatCoordinates(), c = this.drawCustomCoordinates_(
          l,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          t.getEnds(),
          a,
          d
        ), this.instructions.push([
          Yt.CUSTOM,
          o,
          d,
          t,
          s,
          ac
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          d,
          t,
          r || s,
          ac
        ]);
        break;
      case "LineString":
      case "Circle":
        l = t.getFlatCoordinates(), f = this.appendFlatLineCoordinates(
          l,
          0,
          l.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s,
          ba
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s,
          ba
        ]);
        break;
      case "MultiPoint":
        l = t.getFlatCoordinates(), f = this.appendFlatPointCoordinates(l, a), f > o && (this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s,
          ba
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s,
          ba
        ]));
        break;
      case "Point":
        l = t.getFlatCoordinates(), this.coordinates.push(l[0], l[1]), f = this.coordinates.length, this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s
        ]);
        break;
    }
    this.endGeometry(n);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(t, n) {
    this.beginGeometryInstruction1_ = [
      Yt.BEGIN_GEOMETRY,
      n,
      0,
      t
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      Yt.BEGIN_GEOMETRY,
      n,
      0,
      t
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const t = this.hitDetectionInstructions;
    t.reverse();
    let n;
    const s = t.length;
    let r, i, a = -1;
    for (n = 0; n < s; ++n)
      r = t[n], i = /** @type {import("./Instruction.js").default} */
      r[0], i == Yt.END_GEOMETRY ? a = n : i == Yt.BEGIN_GEOMETRY && (r[2] = n, A_(this.hitDetectionInstructions, a, n), a = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
    const s = this.state;
    if (t) {
      const r = t.getColor();
      s.fillStyle = os(
        r || Gs
      );
    } else
      s.fillStyle = void 0;
    if (n) {
      const r = n.getColor();
      s.strokeStyle = os(
        r || cc
      );
      const i = n.getLineCap();
      s.lineCap = i !== void 0 ? i : bd;
      const a = n.getLineDash();
      s.lineDash = a ? a.slice() : oc;
      const o = n.getLineDashOffset();
      s.lineDashOffset = o || lc;
      const l = n.getLineJoin();
      s.lineJoin = l !== void 0 ? l : ql;
      const f = n.getWidth();
      s.lineWidth = f !== void 0 ? f : dc;
      const d = n.getMiterLimit();
      s.miterLimit = d !== void 0 ? d : uc, s.lineWidth > this.maxLineWidth && (this.maxLineWidth = s.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      s.strokeStyle = void 0, s.lineCap = void 0, s.lineDash = null, s.lineDashOffset = void 0, s.lineJoin = void 0, s.lineWidth = void 0, s.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(t) {
    const n = t.fillStyle, s = [Yt.SET_FILL_STYLE, n];
    return typeof n != "string" && s.push(!0), s;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    this.instructions.push(this.createStroke(t));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(t) {
    return [
      Yt.SET_STROKE_STYLE,
      t.strokeStyle,
      t.lineWidth * this.pixelRatio,
      t.lineCap,
      t.lineJoin,
      t.miterLimit,
      this.applyPixelRatio(t.lineDash),
      t.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(t, n) {
    const s = t.fillStyle;
    (typeof s != "string" || t.currentFillStyle != s) && (s !== void 0 && this.instructions.push(n.call(this, t)), t.currentFillStyle = s);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(t, n) {
    const s = t.strokeStyle, r = t.lineCap, i = t.lineDash, a = t.lineDashOffset, o = t.lineJoin, l = t.lineWidth, f = t.miterLimit;
    (t.currentStrokeStyle != s || t.currentLineCap != r || i != t.currentLineDash && !Yo(t.currentLineDash, i) || t.currentLineDashOffset != a || t.currentLineJoin != o || t.currentLineWidth != l || t.currentMiterLimit != f) && (s !== void 0 && n.call(this, t), t.currentStrokeStyle = s, t.currentLineCap = r, t.currentLineDash = i, t.currentLineDashOffset = a, t.currentLineJoin = o, t.currentLineWidth = l, t.currentMiterLimit = f);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(t) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const n = [Yt.END_GEOMETRY, t];
    this.instructions.push(n), this.hitDetectionInstructions.push(n);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = jT(this.maxExtent), this.maxLineWidth > 0)) {
      const t = this.resolution * (this.maxLineWidth + 1) / 2;
      wr(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const Uc = PA;
class MA extends Uc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(t, n);
    const s = t.getFlatCoordinates(), r = t.getStride(), i = this.coordinates.length, a = this.appendFlatPointCoordinates(s, r);
    this.instructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(t, n);
    const s = t.getFlatCoordinates(), r = t.getStride(), i = this.coordinates.length, a = this.appendFlatPointCoordinates(s, r);
    this.instructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(t, n) {
    const s = t.getAnchor(), r = t.getSize(), i = t.getOrigin();
    this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = s[0], this.anchorY_ = s[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = t.getOpacity(), this.originX_ = i[0], this.originY_ = i[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = r[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = n;
  }
}
const SA = MA;
class IA extends Uc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(t, n, s, r) {
    const i = this.coordinates.length, a = this.appendFlatLineCoordinates(
      t,
      n,
      s,
      r,
      !1,
      !1
    ), o = [
      Yt.MOVE_TO_LINE_TO,
      i,
      a
    ];
    return this.instructions.push(o), this.hitDetectionInstructions.push(o), s;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(t, n) {
    const s = this.state, r = s.strokeStyle, i = s.lineWidth;
    if (r === void 0 || i === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, n), this.hitDetectionInstructions.push(
      [
        Yt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        oc,
        lc
      ],
      Eo
    );
    const a = t.getFlatCoordinates(), o = t.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      o
    ), this.hitDetectionInstructions.push(Ta), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(t, n) {
    const s = this.state, r = s.strokeStyle, i = s.lineWidth;
    if (r === void 0 || i === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, n), this.hitDetectionInstructions.push(
      [
        Yt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        s.lineDash,
        s.lineDashOffset
      ],
      Eo
    );
    const a = t.getEnds(), o = t.getFlatCoordinates(), l = t.getStride();
    let f = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      f = this.drawFlatCoordinates_(
        o,
        f,
        /** @type {number} */
        a[d],
        l
      );
    this.hitDetectionInstructions.push(Ta), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = this.state;
    return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(Ta), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(Ta), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(Eo);
  }
}
const _A = IA;
class DA extends Uc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(t, n, s, r) {
    const i = this.state, a = i.fillStyle !== void 0, o = i.strokeStyle !== void 0, l = s.length;
    this.instructions.push(Eo), this.hitDetectionInstructions.push(Eo);
    for (let f = 0; f < l; ++f) {
      const d = s[f], u = this.coordinates.length, c = this.appendFlatLineCoordinates(
        t,
        n,
        d,
        r,
        !0,
        !o
      ), h = [
        Yt.MOVE_TO_LINE_TO,
        u,
        c
      ];
      this.instructions.push(h), this.hitDetectionInstructions.push(h), o && (this.instructions.push(QE), this.hitDetectionInstructions.push(QE)), n = d;
    }
    return a && (this.instructions.push(gh), this.hitDetectionInstructions.push(gh)), o && (this.instructions.push(Ta), this.hitDetectionInstructions.push(Ta)), n;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Gs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getFlatCoordinates(), o = t.getStride(), l = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      o,
      !1,
      !1
    );
    const f = [Yt.CIRCLE, l];
    this.instructions.push(Eo, f), this.hitDetectionInstructions.push(Eo, f), s.fillStyle !== void 0 && (this.instructions.push(gh), this.hitDetectionInstructions.push(gh)), s.strokeStyle !== void 0 && (this.instructions.push(Ta), this.hitDetectionInstructions.push(Ta)), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Gs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getEnds(), o = t.getOrientedFlatCoordinates(), l = t.getStride();
    this.drawFlatCoordinatess_(
      o,
      0,
      /** @type {Array<number>} */
      a,
      l
    ), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Gs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getEndss(), o = t.getOrientedFlatCoordinates(), l = t.getStride();
    let f = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      f = this.drawFlatCoordinatess_(
        o,
        f,
        a[d],
        l
      );
    this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const t = this.tolerance;
    if (t !== 0) {
      const n = this.coordinates;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s] = mo(n[s], t);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const t = this.state;
    t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
  }
}
const qE = DA;
function AA(e, t, n, s, r) {
  let i = n, a = n, o = 0, l = 0, f = n, d, u, c, h, p, g, m, v, y, E;
  for (u = n; u < s; u += r) {
    const C = t[u], x = t[u + 1];
    p !== void 0 && (y = C - p, E = x - g, h = Math.sqrt(y * y + E * E), m !== void 0 && (l += c, d = Math.acos((m * y + v * E) / (c * h)), d > e && (l > o && (o = l, i = f, a = u), l = 0, f = u - r)), c = h, m = y, v = E), p = C, g = x;
  }
  return l += h, l > o ? [f, u] : [i, a];
}
const qu = {
  left: 0,
  end: 0,
  center: 0.5,
  right: 1,
  start: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class LA extends Uc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = super.finish();
    return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(t, n) {
    const s = this.textFillState_, r = this.textStrokeState_, i = this.textState_;
    if (this.text_ === "" || !i || !s && !r)
      return;
    const a = this.coordinates;
    let o = a.length;
    const l = t.getType();
    let f = null, d = t.getStride();
    if (i.placement === "line" && (l == "LineString" || l == "MultiLineString" || l == "Polygon" || l == "MultiPolygon")) {
      if (!cn(this.getBufferedMaxExtent(), t.getExtent()))
        return;
      let u;
      if (f = t.getFlatCoordinates(), l == "LineString")
        u = [f.length];
      else if (l == "MultiLineString")
        u = /** @type {import("../../geom/MultiLineString.js").default} */
        t.getEnds();
      else if (l == "Polygon")
        u = /** @type {import("../../geom/Polygon.js").default} */
        t.getEnds().slice(0, 1);
      else if (l == "MultiPolygon") {
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        u = [];
        for (let m = 0, v = g.length; m < v; ++m)
          u.push(g[m][0]);
      }
      this.beginGeometry(t, n);
      const c = i.textAlign;
      let h = 0, p;
      for (let g = 0, m = u.length; g < m; ++g) {
        if (c == null) {
          const y = AA(
            i.maxAngle,
            f,
            h,
            u[g],
            d
          );
          h = y[0], p = y[1];
        } else
          p = u[g];
        for (let y = h; y < p; y += d)
          a.push(f[y], f[y + 1]);
        const v = a.length;
        h = u[g], this.drawChars_(o, v), o = v;
      }
      this.endGeometry(n);
    } else {
      let u = i.overflow ? null : [];
      switch (l) {
        case "Point":
        case "MultiPoint":
          f = /** @type {import("../../geom/MultiPoint.js").default} */
          t.getFlatCoordinates();
          break;
        case "LineString":
          f = /** @type {import("../../geom/LineString.js").default} */
          t.getFlatMidpoint();
          break;
        case "Circle":
          f = /** @type {import("../../geom/Circle.js").default} */
          t.getCenter();
          break;
        case "MultiLineString":
          f = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getFlatMidpoints(), d = 2;
          break;
        case "Polygon":
          f = /** @type {import("../../geom/Polygon.js").default} */
          t.getFlatInteriorPoint(), i.overflow || u.push(f[2] / this.resolution), d = 3;
          break;
        case "MultiPolygon":
          const m = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getFlatInteriorPoints()
          );
          f = [];
          for (let v = 0, y = m.length; v < y; v += 3)
            i.overflow || u.push(m[v + 2] / this.resolution), f.push(m[v], m[v + 1]);
          if (f.length === 0)
            return;
          d = 2;
          break;
      }
      const c = this.appendFlatPointCoordinates(f, d);
      if (c === o)
        return;
      if (u && (c - o) / 2 !== f.length / d) {
        let m = o / 2;
        u = u.filter((v, y) => {
          const E = a[(m + y) * 2] === f[y * d] && a[(m + y) * 2 + 1] === f[y * d + 1];
          return E || --m, E;
        });
      }
      this.saveTextStates_(), (i.backgroundFill || i.backgroundStroke) && (this.setFillStrokeStyle(
        i.backgroundFill,
        i.backgroundStroke
      ), i.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), i.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, n);
      let h = i.padding;
      if (h != yo && (i.scale[0] < 0 || i.scale[1] < 0)) {
        let m = i.padding[0], v = i.padding[1], y = i.padding[2], E = i.padding[3];
        i.scale[0] < 0 && (v = -v, E = -E), i.scale[1] < 0 && (m = -m, y = -y), h = [m, v, y, E];
      }
      const p = this.pixelRatio;
      this.instructions.push([
        Yt.DRAW_IMAGE,
        o,
        c,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        h == yo ? yo : h.map(function(m) {
          return m * p;
        }),
        !!i.backgroundFill,
        !!i.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]);
      const g = 1 / p;
      this.hitDetectionInstructions.push([
        Yt.DRAW_IMAGE,
        o,
        c,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [g, g],
        NaN,
        void 0,
        this.declutterImageWithText_,
        h,
        !!i.backgroundFill,
        !!i.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]), this.endGeometry(n);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const t = this.textStrokeState_, n = this.textState_, s = this.textFillState_, r = this.strokeKey_;
    t && (r in this.strokeStates || (this.strokeStates[r] = {
      strokeStyle: t.strokeStyle,
      lineCap: t.lineCap,
      lineDashOffset: t.lineDashOffset,
      lineWidth: t.lineWidth,
      lineJoin: t.lineJoin,
      miterLimit: t.miterLimit,
      lineDash: t.lineDash
    }));
    const i = this.textKey_;
    i in this.textStates || (this.textStates[i] = {
      font: n.font,
      textAlign: n.textAlign || hc,
      justify: n.justify,
      textBaseline: n.textBaseline || Od,
      scale: n.scale
    });
    const a = this.fillKey_;
    s && (a in this.fillStates || (this.fillStates[a] = {
      fillStyle: s.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(t, n) {
    const s = this.textStrokeState_, r = this.textState_, i = this.strokeKey_, a = this.textKey_, o = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, f = qu[r.textBaseline], d = this.textOffsetY_ * l, u = this.text_, c = s ? s.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
    this.instructions.push([
      Yt.DRAW_CHARS,
      t,
      n,
      f,
      r.overflow,
      o,
      r.maxAngle,
      l,
      d,
      i,
      c * l,
      u,
      a,
      1
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_CHARS,
      t,
      n,
      f,
      r.overflow,
      o,
      r.maxAngle,
      1,
      d,
      i,
      c,
      u,
      a,
      1 / l
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(t, n) {
    let s, r, i;
    if (!t)
      this.text_ = "";
    else {
      const a = t.getFill();
      a ? (r = this.textFillState_, r || (r = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = r), r.fillStyle = os(
        a.getColor() || Gs
      )) : (r = null, this.textFillState_ = r);
      const o = t.getStroke();
      if (!o)
        i = null, this.textStrokeState_ = i;
      else {
        i = this.textStrokeState_, i || (i = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = i);
        const p = o.getLineDash(), g = o.getLineDashOffset(), m = o.getWidth(), v = o.getMiterLimit();
        i.lineCap = o.getLineCap() || bd, i.lineDash = p ? p.slice() : oc, i.lineDashOffset = g === void 0 ? lc : g, i.lineJoin = o.getLineJoin() || ql, i.lineWidth = m === void 0 ? dc : m, i.miterLimit = v === void 0 ? uc : v, i.strokeStyle = os(
          o.getColor() || cc
        );
      }
      s = this.textState_;
      const l = t.getFont() || vP;
      qD(l);
      const f = t.getScaleArray();
      s.overflow = t.getOverflow(), s.font = l, s.maxAngle = t.getMaxAngle(), s.placement = t.getPlacement(), s.textAlign = t.getTextAlign(), s.justify = t.getJustify(), s.textBaseline = t.getTextBaseline() || Od, s.backgroundFill = t.getBackgroundFill(), s.backgroundStroke = t.getBackgroundStroke(), s.padding = t.getPadding() || yo, s.scale = f === void 0 ? [1, 1] : f;
      const d = t.getOffsetX(), u = t.getOffsetY(), c = t.getRotateWithView(), h = t.getRotation();
      this.text_ = t.getText() || "", this.textOffsetX_ = d === void 0 ? 0 : d, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = c === void 0 ? !1 : c, this.textRotation_ = h === void 0 ? 0 : h, this.strokeKey_ = i ? (typeof i.strokeStyle == "string" ? i.strokeStyle : Xt(i.strokeStyle)) + i.lineCap + i.lineDashOffset + "|" + i.lineWidth + i.lineJoin + i.miterLimit + "[" + i.lineDash.join() + "]" : "", this.textKey_ = s.font + s.scale + (s.textAlign || "?") + (s.justify || "?") + (s.textBaseline || "?"), this.fillKey_ = r ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + Xt(r.fillStyle) : "";
    }
    this.declutterImageWithText_ = n;
  }
}
const RA = {
  Circle: qE,
  Default: Uc,
  Image: SA,
  LineString: _A,
  Polygon: qE,
  Text: LA
};
class wA {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    this.tolerance_ = t, this.maxExtent_ = n, this.pixelRatio_ = r, this.resolution_ = s, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const t = {};
    for (const n in this.buildersByZIndex_) {
      t[n] = t[n] || {};
      const s = this.buildersByZIndex_[n];
      for (const r in s) {
        const i = s[r].finish();
        t[n][r] = i;
      }
    }
    return t;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(t, n) {
    const s = t !== void 0 ? t.toString() : "0";
    let r = this.buildersByZIndex_[s];
    r === void 0 && (r = {}, this.buildersByZIndex_[s] = r);
    let i = r[n];
    if (i === void 0) {
      const a = RA[n];
      i = new a(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), r[n] = i;
    }
    return i;
  }
}
const Md = wA;
class VA extends VT {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return Gt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return Gt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    return Gt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, n, s) {
    t[n] || (t[n] = {}), t[n][s.tileCoord.toString()] = s;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(t, n, s) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */
      (function(r, i) {
        const a = this.loadedTileCallback.bind(this, s, r);
        return t.forEachLoadedTile(n, r, i, a);
      }).bind(this)
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(t) {
    /** @type {import("../Image.js").default} */
    t.target.getState() === ce.LOADED && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(t) {
    let n = t.getState();
    return n != ce.LOADED && n != ce.ERROR && t.addEventListener(Kt.CHANGE, this.boundHandleImageChange_), n == ce.IDLE && (t.load(), n = t.getState()), n == ce.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const t = this.getLayer();
    t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const BA = VA;
class NA extends Ui {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(t, n, s, r) {
    super(t), this.inversePixelTransform = n, this.frameState = s, this.context = r;
  }
}
const _P = NA, tC = [];
let gl = null;
function FA() {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1, gl = e.getContext("2d");
}
class jA extends BA {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(t), this.container = null, this.renderedResolution, this.tempTransform = Qi(), this.pixelTransform = Qi(), this.inversePixelTransform = Qi(), this.context = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(t, n, s) {
    gl || FA(), gl.clearRect(0, 0, 1, 1);
    let r;
    try {
      gl.drawImage(t, n, s, 1, 1, 0, 0, 1, 1), r = gl.getImageData(0, 0, 1, 1).data;
    } catch {
      return gl = null, null;
    }
    return r;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(t) {
    let s = this.getLayer().getBackground();
    return typeof s == "function" && (s = s(t.viewState.resolution)), s || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(t, n, s) {
    const r = this.getLayer().getClassName();
    let i, a;
    if (t && t.className === r && (!s || t && t.style.backgroundColor && Yo(
      Cd(t.style.backgroundColor),
      Cd(s)
    ))) {
      const o = t.firstElementChild;
      o instanceof HTMLCanvasElement && (a = o.getContext("2d"));
    }
    if (a && a.canvas.style.transform === n ? (this.container = t, this.context = a, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
      i = document.createElement("div"), i.className = r;
      let o = i.style;
      o.position = "absolute", o.width = "100%", o.height = "100%", a = Ii();
      const l = a.canvas;
      i.appendChild(l), o = l.style, o.position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = i, this.context = a;
    }
    !this.containerReused && s && !this.container.style.backgroundColor && (this.container.style.backgroundColor = s);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(t, n, s) {
    const r = fs(s), i = To(s), a = Xl(s), o = Oo(s);
    An(n.coordinateToPixelTransform, r), An(n.coordinateToPixelTransform, i), An(n.coordinateToPixelTransform, a), An(n.coordinateToPixelTransform, o);
    const l = this.inversePixelTransform;
    An(l, r), An(l, i), An(l, a), An(l, o), t.save(), t.beginPath(), t.moveTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(i[0]), Math.round(i[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(t, n, s) {
    const r = this.getLayer();
    if (r.hasListener(t)) {
      const i = new _P(
        t,
        this.inversePixelTransform,
        s,
        n
      );
      r.dispatchEvent(i);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(t, n) {
    this.frameState = n, this.dispatchRenderEvent_(Aa.PRERENDER, t, n);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(t, n) {
    this.dispatchRenderEvent_(Aa.POSTRENDER, t, n);
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(t, n, s, r, i, a, o) {
    const l = i / 2, f = a / 2, d = r / n, u = -d, c = -t[0] + o, h = -t[1];
    return Fr(
      this.tempTransform,
      l,
      f,
      d,
      u,
      -s,
      c,
      h
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const Ty = jA;
function UA(e, t, n, s, r, i, a, o, l, f, d, u) {
  let c = e[t], h = e[t + 1], p = 0, g = 0, m = 0, v = 0;
  function y() {
    p = c, g = h, t += s, c = e[t], h = e[t + 1], v += m, m = Math.sqrt((c - p) * (c - p) + (h - g) * (h - g));
  }
  do
    y();
  while (t < n - s && v + m < i);
  let E = m === 0 ? 0 : (i - v) / m;
  const C = Bs(p, c, E), x = Bs(g, h, E), b = t - s, P = v, T = i + o * l(f, r, d);
  for (; t < n - s && v + m < T; )
    y();
  E = m === 0 ? 0 : (T - v) / m;
  const O = Bs(p, c, E), S = Bs(g, h, E);
  let L;
  if (u) {
    const B = [C, x, O, S];
    iy(B, 0, 4, 2, u, B, B), L = B[0] > B[2];
  } else
    L = C > O;
  const A = Math.PI, D = [], _ = b + s === t;
  t = b, m = 0, v = P, c = e[t], h = e[t + 1];
  let w;
  if (_) {
    y(), w = Math.atan2(h - g, c - p), L && (w += w > 0 ? -A : A);
    const B = (O + C) / 2, j = (S + x) / 2;
    return D[0] = [B, j, (T - i) / 2, w, r], D;
  }
  r = r.replace(/\n/g, " ");
  for (let B = 0, j = r.length; B < j; ) {
    y();
    let k = Math.atan2(h - g, c - p);
    if (L && (k += k > 0 ? -A : A), w !== void 0) {
      let vt = k - w;
      if (vt += vt > A ? -2 * A : vt < -A ? 2 * A : 0, Math.abs(vt) > a)
        return null;
    }
    w = k;
    const X = B;
    let rt = 0;
    for (; B < j; ++B) {
      const vt = L ? j - B - 1 : B, bt = o * l(f, r[vt], d);
      if (t + s < n && v + m < i + rt + bt / 2)
        break;
      rt += bt;
    }
    if (B === X)
      continue;
    const et = L ? r.substring(j - X, j - B) : r.substring(X, B);
    E = m === 0 ? 0 : (i + rt / 2 - v) / m;
    const Z = Bs(p, c, E), dt = Bs(g, h, E);
    D.push([Z, dt, rt / 2, k, et]), i += rt;
  }
  return D;
}
const al = Ni(), ca = [], Ss = [], Is = [], ha = [];
function eC(e) {
  return e[3].declutterBox;
}
const WA = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function nC(e, t) {
  return (t === "start" || t === "end") && !WA.test(e) && (t = t === "start" ? "left" : "right"), qu[t];
}
function $A(e, t, n) {
  return n > 0 && e.push(`
`, ""), e.push(t, ""), e;
}
class zA {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(t, n, s, r) {
    this.overlaps = s, this.pixelRatio = n, this.resolution = t, this.alignFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = Qi(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(t, n, s, r) {
    const i = t + n + s + r;
    if (this.labels_[i])
      return this.labels_[i];
    const a = r ? this.strokeStates[r] : null, o = s ? this.fillStates[s] : null, l = this.textStates[n], f = this.pixelRatio, d = [
      l.scale[0] * f,
      l.scale[1] * f
    ], u = Array.isArray(t), c = l.justify ? qu[l.justify] : nC(
      Array.isArray(t) ? t[0] : t,
      l.textAlign || hc
    ), h = r && a.lineWidth ? a.lineWidth : 0, p = u ? t : t.split(`
`).reduce($A, []), { width: g, height: m, widths: v, heights: y, lineWidths: E } = eA(
      l,
      p
    ), C = g + h, x = [], b = (C + 2) * d[0], P = (m + h) * d[1], T = {
      width: b < 0 ? Math.floor(b) : Math.ceil(b),
      height: P < 0 ? Math.floor(P) : Math.ceil(P),
      contextInstructions: x
    };
    (d[0] != 1 || d[1] != 1) && x.push("scale", d), r && (x.push("strokeStyle", a.strokeStyle), x.push("lineWidth", h), x.push("lineCap", a.lineCap), x.push("lineJoin", a.lineJoin), x.push("miterLimit", a.miterLimit), x.push("setLineDash", [a.lineDash]), x.push("lineDashOffset", a.lineDashOffset)), s && x.push("fillStyle", o.fillStyle), x.push("textBaseline", "middle"), x.push("textAlign", "center");
    const O = 0.5 - c;
    let S = c * C + O * h;
    const L = [], A = [];
    let D = 0, _ = 0, w = 0, B = 0, j;
    for (let k = 0, X = p.length; k < X; k += 2) {
      const rt = p[k];
      if (rt === `
`) {
        _ += D, D = 0, S = c * C + O * h, ++B;
        continue;
      }
      const et = p[k + 1] || l.font;
      et !== j && (r && L.push("font", et), s && A.push("font", et), j = et), D = Math.max(D, y[w]);
      const Z = [
        rt,
        S + O * v[w] + c * (v[w] - E[B]),
        0.5 * (h + D) + _
      ];
      S += v[w], r && L.push("strokeText", Z), s && A.push("fillText", Z), ++w;
    }
    return Array.prototype.push.apply(x, L), Array.prototype.push.apply(x, A), this.labels_[i] = T, T;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(t, n, s, r, i, a, o) {
    t.beginPath(), t.moveTo.apply(t, n), t.lineTo.apply(t, s), t.lineTo.apply(t, r), t.lineTo.apply(t, i), t.lineTo.apply(t, n), a && (this.alignFill_ = /** @type {boolean} */
    a[2], this.fill_(t)), o && (this.setStrokeStyle_(
      t,
      /** @type {Array<*>} */
      o
    ), t.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m) {
    o *= c[0], l *= c[1];
    let v = s - o, y = r - l;
    const E = i + f > t ? t - f : i, C = a + d > n ? n - d : a, x = p[3] + E * c[0] + p[1], b = p[0] + C * c[1] + p[2], P = v - p[3], T = y - p[0];
    (g || u !== 0) && (ca[0] = P, ha[0] = P, ca[1] = T, Ss[1] = T, Ss[0] = P + x, Is[0] = Ss[0], Is[1] = T + b, ha[1] = Is[1]);
    let O;
    return u !== 0 ? (O = Fr(
      Qi(),
      s,
      r,
      1,
      1,
      u,
      -s,
      -r
    ), An(O, ca), An(O, Ss), An(O, Is), An(O, ha), er(
      Math.min(ca[0], Ss[0], Is[0], ha[0]),
      Math.min(ca[1], Ss[1], Is[1], ha[1]),
      Math.max(ca[0], Ss[0], Is[0], ha[0]),
      Math.max(ca[1], Ss[1], Is[1], ha[1]),
      al
    )) : er(
      Math.min(P, P + x),
      Math.min(T, T + b),
      Math.max(P, P + x),
      Math.max(T, T + b),
      al
    ), h && (v = Math.round(v), y = Math.round(y)), {
      drawImageX: v,
      drawImageY: y,
      drawImageW: E,
      drawImageH: C,
      originX: f,
      originY: d,
      declutterBox: {
        minX: al[0],
        minY: al[1],
        maxX: al[2],
        maxY: al[3],
        value: m
      },
      canvasTransform: O,
      scale: c
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(t, n, s, r, i, a, o) {
    const l = !!(a || o), f = r.declutterBox, d = t.canvas, u = o ? o[2] * r.scale[0] / 2 : 0;
    return f.minX - u <= d.width / n && f.maxX + u >= 0 && f.minY - u <= d.height / n && f.maxY + u >= 0 && (l && this.replayTextBackground_(
      t,
      ca,
      Ss,
      Is,
      ha,
      /** @type {Array<*>} */
      a,
      /** @type {Array<*>} */
      o
    ), nA(
      t,
      r.canvasTransform,
      i,
      s,
      r.originX,
      r.originY,
      r.drawImageW,
      r.drawImageH,
      r.drawImageX,
      r.drawImageY,
      r.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(t) {
    if (this.alignFill_) {
      const n = An(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
      t.save(), t.translate(n[0] % s, n[1] % s), t.rotate(this.viewRotation_);
    }
    t.fill(), this.alignFill_ && t.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(t, n) {
    t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    n[1], t.lineWidth = /** @type {number} */
    n[2], t.lineCap = /** @type {CanvasLineCap} */
    n[3], t.lineJoin = /** @type {CanvasLineJoin} */
    n[4], t.miterLimit = /** @type {number} */
    n[5], t.lineDashOffset = /** @type {number} */
    n[7], t.setLineDash(
      /** @type {Array<number>} */
      n[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(t, n, s, r) {
    const i = this.textStates[n], a = this.createLabel(t, n, r, s), o = this.strokeStates[s], l = this.pixelRatio, f = nC(
      Array.isArray(t) ? t[0] : t,
      i.textAlign || hc
    ), d = qu[i.textBaseline || Od], u = o && o.lineWidth ? o.lineWidth : 0, c = a.width / l - 2 * i.scale[0], h = f * c + 2 * (0.5 - f) * u, p = d * a.height / l + 2 * (0.5 - d) * u;
    return {
      label: a,
      anchorX: h,
      anchorY: p
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(t, n, s, r, i, a, o, l) {
    let f;
    this.pixelCoordinates_ && Yo(s, this.renderedTransform_) ? f = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), f = Da(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      s,
      this.pixelCoordinates_
    ), K_(this.renderedTransform_, s));
    let d = 0;
    const u = r.length;
    let c = 0, h, p, g, m, v, y, E, C, x, b, P, T, O = 0, S = 0, L = null, A = null;
    const D = this.coordinateCache_, _ = this.viewRotation_, w = Math.round(Math.atan2(-s[1], s[0]) * 1e12) / 1e12, B = (
      /** @type {import("../../render.js").State} */
      {
        context: t,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: _
      }
    ), j = this.instructions != r || this.overlaps ? 0 : 200;
    let k, X, rt, et;
    for (; d < u; ) {
      const Z = r[d];
      switch (
        /** @type {import("./Instruction.js").default} */
        Z[0]
      ) {
        case Yt.BEGIN_GEOMETRY:
          k = /** @type {import("../../Feature.js").FeatureLike} */
          Z[1], et = Z[3], k.getGeometry() ? o !== void 0 && !cn(o, et.getExtent()) ? d = /** @type {number} */
          Z[2] + 1 : ++d : d = /** @type {number} */
          Z[2];
          break;
        case Yt.BEGIN_PATH:
          O > j && (this.fill_(t), O = 0), S > j && (t.stroke(), S = 0), !O && !S && (t.beginPath(), m = NaN, v = NaN), ++d;
          break;
        case Yt.CIRCLE:
          c = /** @type {number} */
          Z[1];
          const vt = f[c], bt = f[c + 1], it = f[c + 2], R = f[c + 3], V = it - vt, tt = R - bt, Y = Math.sqrt(V * V + tt * tt);
          t.moveTo(vt + Y, bt), t.arc(vt, bt, Y, 0, 2 * Math.PI, !0), ++d;
          break;
        case Yt.CLOSE_PATH:
          t.closePath(), ++d;
          break;
        case Yt.CUSTOM:
          c = /** @type {number} */
          Z[1], h = Z[2];
          const $ = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            Z[3]
          ), z = Z[4], at = Z.length == 6 ? Z[5] : void 0;
          B.geometry = $, B.feature = k, d in D || (D[d] = []);
          const ct = D[d];
          at ? at(f, c, h, 2, ct) : (ct[0] = f[c], ct[1] = f[c + 1], ct.length = 2), z(ct, B), ++d;
          break;
        case Yt.DRAW_IMAGE:
          c = /** @type {number} */
          Z[1], h = /** @type {number} */
          Z[2], C = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          Z[3], p = /** @type {number} */
          Z[4], g = /** @type {number} */
          Z[5];
          let St = (
            /** @type {number} */
            Z[6]
          );
          const F = (
            /** @type {number} */
            Z[7]
          ), M = (
            /** @type {number} */
            Z[8]
          ), I = (
            /** @type {number} */
            Z[9]
          ), N = (
            /** @type {boolean} */
            Z[10]
          );
          let G = (
            /** @type {number} */
            Z[11]
          );
          const nt = (
            /** @type {import("../../size.js").Size} */
            Z[12]
          );
          let lt = (
            /** @type {number} */
            Z[13]
          );
          const yt = (
            /** @type {"declutter"|"obstacle"|"none"|undefined} */
            Z[14]
          ), Lt = (
            /** @type {import("../canvas.js").DeclutterImageWithText} */
            Z[15]
          );
          if (!C && Z.length >= 20) {
            x = /** @type {string} */
            Z[19], b = /** @type {string} */
            Z[20], P = /** @type {string} */
            Z[21], T = /** @type {string} */
            Z[22];
            const we = this.drawLabelWithPointPlacement_(
              x,
              b,
              P,
              T
            );
            C = we.label, Z[3] = C;
            const gn = (
              /** @type {number} */
              Z[23]
            );
            p = (we.anchorX - gn) * this.pixelRatio, Z[4] = p;
            const ze = (
              /** @type {number} */
              Z[24]
            );
            g = (we.anchorY - ze) * this.pixelRatio, Z[5] = g, St = C.height, Z[6] = St, lt = C.width, Z[13] = lt;
          }
          let Nt;
          Z.length > 25 && (Nt = /** @type {number} */
          Z[25]);
          let Jt, J, ft;
          Z.length > 17 ? (Jt = /** @type {Array<number>} */
          Z[16], J = /** @type {boolean} */
          Z[17], ft = /** @type {boolean} */
          Z[18]) : (Jt = yo, J = !1, ft = !1), N && w ? G += _ : !N && !w && (G -= _);
          let Ct = 0;
          for (; c < h; c += 2) {
            if (Nt && Nt[Ct++] < lt / this.pixelRatio)
              continue;
            const we = this.calculateImageOrLabelDimensions_(
              C.width,
              C.height,
              f[c],
              f[c + 1],
              lt,
              St,
              p,
              g,
              M,
              I,
              G,
              nt,
              i,
              Jt,
              J || ft,
              k
            ), gn = [
              t,
              n,
              C,
              we,
              F,
              J ? (
                /** @type {Array<*>} */
                L
              ) : null,
              ft ? (
                /** @type {Array<*>} */
                A
              ) : null
            ];
            if (l) {
              if (yt === "none")
                continue;
              if (yt === "obstacle") {
                l.insert(we.declutterBox);
                continue;
              } else {
                let ze, On;
                if (Lt) {
                  const qe = h - c;
                  if (!Lt[qe]) {
                    Lt[qe] = gn;
                    continue;
                  }
                  if (ze = Lt[qe], delete Lt[qe], On = eC(ze), l.collides(On))
                    continue;
                }
                if (l.collides(we.declutterBox))
                  continue;
                ze && (l.insert(On), this.replayImageOrLabel_.apply(this, ze)), l.insert(we.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, gn);
          }
          ++d;
          break;
        case Yt.DRAW_CHARS:
          const Mt = (
            /** @type {number} */
            Z[1]
          ), Ot = (
            /** @type {number} */
            Z[2]
          ), kt = (
            /** @type {number} */
            Z[3]
          ), de = (
            /** @type {number} */
            Z[4]
          );
          T = /** @type {string} */
          Z[5];
          const Pe = (
            /** @type {number} */
            Z[6]
          ), Me = (
            /** @type {number} */
            Z[7]
          ), Ce = (
            /** @type {number} */
            Z[8]
          );
          P = /** @type {string} */
          Z[9];
          const $e = (
            /** @type {number} */
            Z[10]
          );
          x = /** @type {string} */
          Z[11], b = /** @type {string} */
          Z[12];
          const bn = [
            /** @type {number} */
            Z[13],
            /** @type {number} */
            Z[13]
          ], Ye = this.textStates[b], Hn = Ye.font, fn = [
            Ye.scale[0] * Me,
            Ye.scale[1] * Me
          ];
          let Fe;
          Hn in this.widths_ ? Fe = this.widths_[Hn] : (Fe = {}, this.widths_[Hn] = Fe);
          const pn = cP(f, Mt, Ot, 2), mn = Math.abs(fn[0]) * kE(Hn, x, Fe);
          if (de || mn <= pn) {
            const we = this.textStates[b].textAlign, gn = (pn - mn) * qu[we], ze = UA(
              f,
              Mt,
              Ot,
              2,
              x,
              gn,
              Pe,
              Math.abs(fn[0]),
              kE,
              Hn,
              Fe,
              w ? 0 : this.viewRotation_
            );
            t:
              if (ze) {
                const On = [];
                let qe, se, mi, Xe, sn;
                if (P)
                  for (qe = 0, se = ze.length; qe < se; ++qe) {
                    sn = ze[qe], mi = /** @type {string} */
                    sn[4], Xe = this.createLabel(mi, b, "", P), p = /** @type {number} */
                    sn[2] + (fn[0] < 0 ? -$e : $e), g = kt * Xe.height + (0.5 - kt) * 2 * $e * fn[1] / fn[0] - Ce;
                    const Ue = this.calculateImageOrLabelDimensions_(
                      Xe.width,
                      Xe.height,
                      sn[0],
                      sn[1],
                      Xe.width,
                      Xe.height,
                      p,
                      g,
                      0,
                      0,
                      sn[3],
                      bn,
                      !1,
                      yo,
                      !1,
                      k
                    );
                    if (l && l.collides(Ue.declutterBox))
                      break t;
                    On.push([
                      t,
                      n,
                      Xe,
                      Ue,
                      1,
                      null,
                      null
                    ]);
                  }
                if (T)
                  for (qe = 0, se = ze.length; qe < se; ++qe) {
                    sn = ze[qe], mi = /** @type {string} */
                    sn[4], Xe = this.createLabel(mi, b, T, ""), p = /** @type {number} */
                    sn[2], g = kt * Xe.height - Ce;
                    const Ue = this.calculateImageOrLabelDimensions_(
                      Xe.width,
                      Xe.height,
                      sn[0],
                      sn[1],
                      Xe.width,
                      Xe.height,
                      p,
                      g,
                      0,
                      0,
                      sn[3],
                      bn,
                      !1,
                      yo,
                      !1,
                      k
                    );
                    if (l && l.collides(Ue.declutterBox))
                      break t;
                    On.push([
                      t,
                      n,
                      Xe,
                      Ue,
                      1,
                      null,
                      null
                    ]);
                  }
                l && l.load(On.map(eC));
                for (let Ue = 0, wn = On.length; Ue < wn; ++Ue)
                  this.replayImageOrLabel_.apply(this, On[Ue]);
              }
          }
          ++d;
          break;
        case Yt.END_GEOMETRY:
          if (a !== void 0) {
            k = /** @type {import("../../Feature.js").FeatureLike} */
            Z[1];
            const we = a(k, et);
            if (we)
              return we;
          }
          ++d;
          break;
        case Yt.FILL:
          j ? O++ : this.fill_(t), ++d;
          break;
        case Yt.MOVE_TO_LINE_TO:
          for (c = /** @type {number} */
          Z[1], h = /** @type {number} */
          Z[2], X = f[c], rt = f[c + 1], y = X + 0.5 | 0, E = rt + 0.5 | 0, (y !== m || E !== v) && (t.moveTo(X, rt), m = y, v = E), c += 2; c < h; c += 2)
            X = f[c], rt = f[c + 1], y = X + 0.5 | 0, E = rt + 0.5 | 0, (c == h - 2 || y !== m || E !== v) && (t.lineTo(X, rt), m = y, v = E);
          ++d;
          break;
        case Yt.SET_FILL_STYLE:
          L = Z, this.alignFill_ = Z[2], O && (this.fill_(t), O = 0, S && (t.stroke(), S = 0)), t.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
          Z[1], ++d;
          break;
        case Yt.SET_STROKE_STYLE:
          A = Z, S && (t.stroke(), S = 0), this.setStrokeStyle_(
            t,
            /** @type {Array<*>} */
            Z
          ), ++d;
          break;
        case Yt.STROKE:
          j ? S++ : t.stroke(), ++d;
          break;
        default:
          ++d;
          break;
      }
    }
    O && this.fill_(t), S && t.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, n, s, r, i, a) {
    this.viewRotation_ = r, this.execute_(
      t,
      n,
      s,
      this.instructions,
      i,
      void 0,
      void 0,
      a
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(t, n, s, r, i) {
    return this.viewRotation_ = s, this.execute_(
      t,
      1,
      n,
      this.hitDetectionInstructions,
      !0,
      r,
      i
    );
  }
}
const KA = zA, hp = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class GA {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(t, n, s, r, i, a) {
    this.maxExtent_ = t, this.overlaps_ = r, this.pixelRatio_ = s, this.resolution_ = n, this.renderBuffer_ = a, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = Qi(), this.createExecutors_(i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(t, n) {
    const s = this.getClipCoords(n);
    t.beginPath(), t.moveTo(s[0], s[1]), t.lineTo(s[2], s[3]), t.lineTo(s[4], s[5]), t.lineTo(s[6], s[7]), t.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(t) {
    for (const n in t) {
      let s = this.executorsByZIndex_[n];
      s === void 0 && (s = {}, this.executorsByZIndex_[n] = s);
      const r = t[n];
      for (const i in r) {
        const a = r[i];
        s[i] = new KA(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(t) {
    for (const n in this.executorsByZIndex_) {
      const s = this.executorsByZIndex_[n];
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r] in s)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i, a) {
    r = Math.round(r);
    const o = r * 2 + 1, l = Fr(
      this.hitDetectionTransform_,
      r + 0.5,
      r + 0.5,
      1 / n,
      -1 / n,
      -s,
      -t[0],
      -t[1]
    ), f = !this.hitDetectionContext_;
    f && (this.hitDetectionContext_ = Ii(
      o,
      o
    ));
    const d = this.hitDetectionContext_;
    d.canvas.width !== o || d.canvas.height !== o ? (d.canvas.width = o, d.canvas.height = o) : f || d.clearRect(0, 0, o, o);
    let u;
    this.renderBuffer_ !== void 0 && (u = Ni(), Qu(u, t), wr(
      u,
      n * (this.renderBuffer_ + r),
      u
    ));
    const c = kA(r);
    let h;
    function p(x, b) {
      const P = d.getImageData(
        0,
        0,
        o,
        o
      ).data;
      for (let T = 0, O = c.length; T < O; T++)
        if (P[c[T]] > 0) {
          if (!a || h !== "Image" && h !== "Text" || a.includes(x)) {
            const S = (c[T] - 3) / 4, L = r - S % o, A = r - (S / o | 0), D = i(x, b, L * L + A * A);
            if (D)
              return D;
          }
          d.clearRect(0, 0, o, o);
          break;
        }
    }
    const g = Object.keys(this.executorsByZIndex_).map(Number);
    g.sort(Ao);
    let m, v, y, E, C;
    for (m = g.length - 1; m >= 0; --m) {
      const x = g[m].toString();
      for (y = this.executorsByZIndex_[x], v = hp.length - 1; v >= 0; --v)
        if (h = hp[v], E = y[h], E !== void 0 && (C = E.executeHitDetection(
          d,
          l,
          s,
          p,
          u
        ), C))
          return C;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(t) {
    const n = this.maxExtent_;
    if (!n)
      return null;
    const s = n[0], r = n[1], i = n[2], a = n[3], o = [s, r, s, a, i, a, i, r];
    return Da(o, 0, 8, 2, t, o), o;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Ro(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, n, s, r, i, a, o) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(Ao), this.maxExtent_ && (t.save(), this.clip(t, s)), a = a || hp;
    let f, d, u, c, h, p;
    for (o && l.reverse(), f = 0, d = l.length; f < d; ++f) {
      const g = l[f].toString();
      for (h = this.executorsByZIndex_[g], u = 0, c = a.length; u < c; ++u) {
        const m = a[u];
        p = h[m], p !== void 0 && p.execute(
          t,
          n,
          s,
          r,
          i,
          o
        );
      }
    }
    this.maxExtent_ && t.restore();
  }
}
const dp = {};
function kA(e) {
  if (dp[e] !== void 0)
    return dp[e];
  const t = e * 2 + 1, n = e * e, s = new Array(n + 1);
  for (let i = 0; i <= e; ++i)
    for (let a = 0; a <= e; ++a) {
      const o = i * i + a * a;
      if (o > n)
        break;
      let l = s[o];
      l || (l = [], s[o] = l), l.push(((e + i) * t + (e + a)) * 4 + 3), i > 0 && l.push(((e - i) * t + (e + a)) * 4 + 3), a > 0 && (l.push(((e + i) * t + (e - a)) * 4 + 3), i > 0 && l.push(((e - i) * t + (e - a)) * 4 + 3));
    }
  const r = [];
  for (let i = 0, a = s.length; i < a; ++i)
    s[i] && r.push(...s[i]);
  return dp[e] = r, r;
}
const Sd = GA, tn = {
  ANIMATING: 0,
  INTERACTING: 1
};
class HA extends IP {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(t, n, s, r, i, a, o) {
    super(), this.context_ = t, this.pixelRatio_ = n, this.extent_ = s, this.transform_ = r, this.viewRotation_ = i, this.squaredTolerance_ = a, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = Qi();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(t, n, s, r) {
    if (!this.image_)
      return;
    const i = Da(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_, o = this.tmpLocalTransform_, l = a.globalAlpha;
    this.imageOpacity_ != 1 && (a.globalAlpha = l * this.imageOpacity_);
    let f = this.imageRotation_;
    this.imageRotateWithView_ && (f += this.viewRotation_);
    for (let d = 0, u = i.length; d < u; d += 2) {
      const c = i[d] - this.imageAnchorX_, h = i[d + 1] - this.imageAnchorY_;
      if (f !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const p = c + this.imageAnchorX_, g = h + this.imageAnchorY_;
        Fr(
          o,
          p,
          g,
          1,
          1,
          f,
          -p,
          -g
        ), a.setTransform.apply(a, o), a.translate(p, g), a.scale(this.imageScale_[0], this.imageScale_[1]), a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), a.setTransform(1, 0, 0, 1, 0, 0);
      } else
        a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          c,
          h,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (a.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(t, n, s, r) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const i = Da(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_;
    let o = this.textRotation_;
    for (this.textRotateWithView_ && (o += this.viewRotation_); n < s; n += r) {
      const l = i[n] + this.textOffsetX_, f = i[n + 1] + this.textOffsetY_;
      o !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (a.translate(l - this.textOffsetX_, f - this.textOffsetY_), a.rotate(o), a.translate(this.textOffsetX_, this.textOffsetY_), a.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && a.strokeText(this.text_, 0, 0), this.textFillState_ && a.fillText(this.text_, 0, 0), a.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && a.strokeText(this.text_, l, f), this.textFillState_ && a.fillText(this.text_, l, f));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(t, n, s, r, i) {
    const a = this.context_, o = Da(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    );
    a.moveTo(o[0], o[1]);
    let l = o.length;
    i && (l -= 2);
    for (let f = 2; f < l; f += 2)
      a.lineTo(o[f], o[f + 1]);
    return i && a.closePath(), s;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(t, n, s, r) {
    for (let i = 0, a = s.length; i < a; ++i)
      n = this.moveToLineTo_(
        t,
        n,
        s[i],
        r,
        !0
      );
    return n;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(t) {
    if (cn(this.extent_, t.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = OD(
          t,
          this.transform_,
          this.pixelCoordinates_
        ), s = n[2] - n[0], r = n[3] - n[1], i = Math.sqrt(s * s + r * r), a = this.context_;
        a.beginPath(), a.arc(
          n[0],
          n[1],
          i,
          0,
          2 * Math.PI
        ), this.fillState_ && a.fill(), this.strokeState_ && a.stroke();
      }
      this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(t) {
    this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(t) {
    this.transform_ = t;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(t) {
    switch (t.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          t
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          t
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          t
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          t
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          t
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          t
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          t
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(t, n) {
    const s = n.getGeometryFunction()(t);
    !s || !cn(this.extent_, s.getExtent()) || (this.setStyle(n), this.drawGeometry(s));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(t) {
    const n = t.getGeometriesArray();
    for (let s = 0, r = n.length; s < r; ++s)
      this.drawGeometry(n[s]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getFlatCoordinates(), s = t.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, s), this.text_ !== "" && this.drawText_(n, 0, n.length, s);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getFlatCoordinates(), s = t.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, s), this.text_ !== "" && this.drawText_(n, 0, n.length, s);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!cn(this.extent_, t.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, s = t.getFlatCoordinates();
        n.beginPath(), this.moveToLineTo_(
          s,
          0,
          s.length,
          t.getStride(),
          !1
        ), n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatMidpoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getExtent();
    if (cn(this.extent_, n)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const s = this.context_, r = t.getFlatCoordinates();
        let i = 0;
        const a = (
          /** @type {Array<number>} */
          t.getEnds()
        ), o = t.getStride();
        s.beginPath();
        for (let l = 0, f = a.length; l < f; ++l)
          i = this.moveToLineTo_(
            r,
            i,
            a[l],
            o,
            !1
          );
        s.stroke();
      }
      if (this.text_ !== "") {
        const s = t.getFlatMidpoints();
        this.drawText_(s, 0, s.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!cn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_;
        n.beginPath(), this.drawRings_(
          t.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          t.getEnds(),
          t.getStride()
        ), this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatInteriorPoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!cn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, s = t.getOrientedFlatCoordinates();
        let r = 0;
        const i = t.getEndss(), a = t.getStride();
        n.beginPath();
        for (let o = 0, l = i.length; o < l; ++o) {
          const f = i[o];
          r = this.drawRings_(s, r, f, a);
        }
        this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatInteriorPoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(t) {
    const n = this.context_, s = this.contextFillState_;
    s ? s.fillStyle != t.fillStyle && (s.fillStyle = t.fillStyle, n.fillStyle = t.fillStyle) : (n.fillStyle = t.fillStyle, this.contextFillState_ = {
      fillStyle: t.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(t) {
    const n = this.context_, s = this.contextStrokeState_;
    s ? (s.lineCap != t.lineCap && (s.lineCap = t.lineCap, n.lineCap = t.lineCap), Yo(s.lineDash, t.lineDash) || n.setLineDash(
      s.lineDash = t.lineDash
    ), s.lineDashOffset != t.lineDashOffset && (s.lineDashOffset = t.lineDashOffset, n.lineDashOffset = t.lineDashOffset), s.lineJoin != t.lineJoin && (s.lineJoin = t.lineJoin, n.lineJoin = t.lineJoin), s.lineWidth != t.lineWidth && (s.lineWidth = t.lineWidth, n.lineWidth = t.lineWidth), s.miterLimit != t.miterLimit && (s.miterLimit = t.miterLimit, n.miterLimit = t.miterLimit), s.strokeStyle != t.strokeStyle && (s.strokeStyle = t.strokeStyle, n.strokeStyle = t.strokeStyle)) : (n.lineCap = t.lineCap, n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset, n.lineJoin = t.lineJoin, n.lineWidth = t.lineWidth, n.miterLimit = t.miterLimit, n.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
      lineCap: t.lineCap,
      lineDash: t.lineDash,
      lineDashOffset: t.lineDashOffset,
      lineJoin: t.lineJoin,
      lineWidth: t.lineWidth,
      miterLimit: t.miterLimit,
      strokeStyle: t.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(t) {
    const n = this.context_, s = this.contextTextState_, r = t.textAlign ? t.textAlign : hc;
    s ? (s.font != t.font && (s.font = t.font, n.font = t.font), s.textAlign != r && (s.textAlign = r, n.textAlign = r), s.textBaseline != t.textBaseline && (s.textBaseline = t.textBaseline, n.textBaseline = t.textBaseline)) : (n.font = t.font, n.textAlign = r, n.textBaseline = t.textBaseline, this.contextTextState_ = {
      font: t.font,
      textAlign: r,
      textBaseline: t.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
    if (!t)
      this.fillState_ = null;
    else {
      const s = t.getColor();
      this.fillState_ = {
        fillStyle: os(
          s || Gs
        )
      };
    }
    if (!n)
      this.strokeState_ = null;
    else {
      const s = n.getColor(), r = n.getLineCap(), i = n.getLineDash(), a = n.getLineDashOffset(), o = n.getLineJoin(), l = n.getWidth(), f = n.getMiterLimit(), d = i || oc;
      this.strokeState_ = {
        lineCap: r !== void 0 ? r : bd,
        lineDash: this.pixelRatio_ === 1 ? d : d.map((u) => u * this.pixelRatio_),
        lineDashOffset: (a || lc) * this.pixelRatio_,
        lineJoin: o !== void 0 ? o : ql,
        lineWidth: (l !== void 0 ? l : dc) * this.pixelRatio_,
        miterLimit: f !== void 0 ? f : uc,
        strokeStyle: os(
          s || cc
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(t) {
    let n;
    if (!t || !(n = t.getSize())) {
      this.image_ = null;
      return;
    }
    const s = t.getPixelRatio(this.pixelRatio_), r = t.getAnchor(), i = t.getOrigin();
    this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * s, this.imageAnchorY_ = r[1] * s, this.imageHeight_ = n[1] * s, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = i[0], this.imageOriginY_ = i[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
    const a = t.getScaleArray();
    this.imageScale_ = [
      a[0] * this.pixelRatio_ / s,
      a[1] * this.pixelRatio_ / s
    ], this.imageWidth_ = n[0] * s;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(t) {
    if (!t)
      this.text_ = "";
    else {
      const n = t.getFill();
      if (!n)
        this.textFillState_ = null;
      else {
        const h = n.getColor();
        this.textFillState_ = {
          fillStyle: os(
            h || Gs
          )
        };
      }
      const s = t.getStroke();
      if (!s)
        this.textStrokeState_ = null;
      else {
        const h = s.getColor(), p = s.getLineCap(), g = s.getLineDash(), m = s.getLineDashOffset(), v = s.getLineJoin(), y = s.getWidth(), E = s.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: p !== void 0 ? p : bd,
          lineDash: g || oc,
          lineDashOffset: m || lc,
          lineJoin: v !== void 0 ? v : ql,
          lineWidth: y !== void 0 ? y : dc,
          miterLimit: E !== void 0 ? E : uc,
          strokeStyle: os(
            h || cc
          )
        };
      }
      const r = t.getFont(), i = t.getOffsetX(), a = t.getOffsetY(), o = t.getRotateWithView(), l = t.getRotation(), f = t.getScaleArray(), d = t.getText(), u = t.getTextAlign(), c = t.getTextBaseline();
      this.textState_ = {
        font: r !== void 0 ? r : vP,
        textAlign: u !== void 0 ? u : hc,
        textBaseline: c !== void 0 ? c : Od
      }, this.text_ = d !== void 0 ? Array.isArray(d) ? d.reduce((h, p, g) => h += g % 2 ? " " : p, "") : d : "", this.textOffsetX_ = i !== void 0 ? this.pixelRatio_ * i : 0, this.textOffsetY_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textRotateWithView_ = o !== void 0 ? o : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * f[0],
        this.pixelRatio_ * f[1]
      ];
    }
  }
}
const DP = HA, Zi = 0.5;
function AP(e, t, n, s, r, i, a) {
  const o = e[0] * Zi, l = e[1] * Zi, f = Ii(o, l);
  f.imageSmoothingEnabled = !1;
  const d = f.canvas, u = new DP(
    f,
    Zi,
    r,
    null,
    a
  ), c = n.length, h = Math.floor((256 * 256 * 256 - 1) / c), p = {};
  for (let m = 1; m <= c; ++m) {
    const v = n[m - 1], y = v.getStyleFunction() || s;
    if (!s)
      continue;
    let E = y(v, i);
    if (!E)
      continue;
    Array.isArray(E) || (E = [E]);
    const x = "#" + ("000000" + (m * h).toString(16)).slice(-6);
    for (let b = 0, P = E.length; b < P; ++b) {
      const T = E[b], O = T.getGeometryFunction()(v);
      if (!O || !cn(r, O.getExtent()))
        continue;
      const S = T.clone(), L = S.getFill();
      L && L.setColor(x);
      const A = S.getStroke();
      A && (A.setColor(x), A.setLineDash(null)), S.setText(void 0);
      const D = T.getImage();
      if (D && D.getOpacity() !== 0) {
        const B = D.getImageSize();
        if (!B)
          continue;
        const j = Ii(
          B[0],
          B[1],
          void 0,
          { alpha: !1 }
        ), k = j.canvas;
        j.fillStyle = x, j.fillRect(0, 0, k.width, k.height), S.setImage(
          new Ua({
            img: k,
            imgSize: B,
            anchor: D.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: D.getOrigin(),
            opacity: 1,
            size: D.getSize(),
            scale: D.getScale(),
            rotation: D.getRotation(),
            rotateWithView: D.getRotateWithView()
          })
        );
      }
      const _ = S.getZIndex() || 0;
      let w = p[_];
      w || (w = {}, p[_] = w, w.Polygon = [], w.Circle = [], w.LineString = [], w.Point = []), w[O.getType().replace("Multi", "")].push(
        O,
        S
      );
    }
  }
  const g = Object.keys(p).map(Number).sort(Ao);
  for (let m = 0, v = g.length; m < v; ++m) {
    const y = p[g[m]];
    for (const E in y) {
      const C = y[E];
      for (let x = 0, b = C.length; x < b; x += 2) {
        u.setStyle(C[x + 1]);
        for (let P = 0, T = t.length; P < T; ++P)
          u.setTransform(t[P]), u.drawGeometry(C[x]);
      }
    }
  }
  return f.getImageData(0, 0, d.width, d.height);
}
function LP(e, t, n) {
  const s = [];
  if (n) {
    const r = Math.floor(Math.round(e[0]) * Zi), i = Math.floor(Math.round(e[1]) * Zi), a = (hn(r, 0, n.width - 1) + hn(i, 0, n.height - 1) * n.width) * 4, o = n.data[a], l = n.data[a + 1], d = n.data[a + 2] + 256 * (l + 256 * o), u = Math.floor((256 * 256 * 256 - 1) / t.length);
    d && d % u === 0 && s.push(t[d / u - 1]);
  }
  return s;
}
const YA = 0.5, RP = {
  Point: nL,
  LineString: qA,
  Polygon: rL,
  MultiPoint: iL,
  MultiLineString: tL,
  MultiPolygon: eL,
  GeometryCollection: QA,
  Circle: ZA
};
function XA(e, t) {
  return parseInt(Xt(e), 10) - parseInt(Xt(t), 10);
}
function wP(e, t) {
  const n = Rg(e, t);
  return n * n;
}
function Rg(e, t) {
  return YA * e / t;
}
function ZA(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (i || a) {
    const l = e.getBuilder(n.getZIndex(), "Circle");
    l.setFillStrokeStyle(i, a), l.drawCircle(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
function Id(e, t, n, s, r, i, a) {
  let o = !1;
  const l = n.getImage();
  if (l) {
    const f = l.getImageState();
    f == ce.LOADED || f == ce.ERROR ? l.unlistenImageChange(r) : (f == ce.IDLE && l.load(), l.listenImageChange(r), o = !0);
  }
  return JA(
    e,
    t,
    n,
    s,
    i,
    a
  ), o;
}
function JA(e, t, n, s, r, i) {
  const a = n.getGeometryFunction()(t);
  if (!a)
    return;
  const o = a.simplifyTransformed(
    s,
    r
  );
  if (n.getRenderer())
    VP(e, o, n, t);
  else {
    const f = RP[o.getType()];
    f(
      e,
      o,
      n,
      t,
      i
    );
  }
}
function VP(e, t, n, s) {
  if (t.getType() == "GeometryCollection") {
    const i = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      t.getGeometries()
    );
    for (let a = 0, o = i.length; a < o; ++a)
      VP(e, i[a], n, s);
    return;
  }
  e.getBuilder(n.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    t,
    s,
    n.getRenderer(),
    n.getHitDetectionRenderer()
  );
}
function QA(e, t, n, s, r) {
  const i = t.getGeometriesArray();
  let a, o;
  for (a = 0, o = i.length; a < o; ++a) {
    const l = RP[i[a].getType()];
    l(
      e,
      i[a],
      n,
      s,
      r
    );
  }
}
function qA(e, t, n, s, r) {
  const i = n.getStroke();
  if (i) {
    const o = e.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, i), o.drawLineString(t, s);
  }
  const a = n.getText();
  if (a && a.getText()) {
    const o = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(t, s);
  }
}
function tL(e, t, n, s, r) {
  const i = n.getStroke();
  if (i) {
    const o = e.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, i), o.drawMultiLineString(t, s);
  }
  const a = n.getText();
  if (a && a.getText()) {
    const o = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(t, s);
  }
}
function eL(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (a || i) {
    const l = e.getBuilder(n.getZIndex(), "Polygon");
    l.setFillStrokeStyle(i, a), l.drawMultiPolygon(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
function nL(e, t, n, s, r) {
  const i = n.getImage(), a = n.getText();
  let o;
  if (i) {
    if (i.getImageState() != ce.LOADED)
      return;
    let l = e;
    if (r) {
      const d = i.getDeclutterMode();
      if (d !== "none")
        if (l = r, d === "obstacle") {
          const u = e.getBuilder(
            n.getZIndex(),
            "Image"
          );
          u.setImageStyle(i, o), u.drawPoint(t, s);
        } else
          a && a.getText() && (o = {});
    }
    const f = l.getBuilder(
      n.getZIndex(),
      "Image"
    );
    f.setImageStyle(i, o), f.drawPoint(t, s);
  }
  if (a && a.getText()) {
    let l = e;
    r && (l = r);
    const f = l.getBuilder(n.getZIndex(), "Text");
    f.setTextStyle(a, o), f.drawText(t, s);
  }
}
function iL(e, t, n, s, r) {
  const i = n.getImage(), a = n.getText();
  let o;
  if (i) {
    if (i.getImageState() != ce.LOADED)
      return;
    let l = e;
    if (r) {
      const d = i.getDeclutterMode();
      if (d !== "none")
        if (l = r, d === "obstacle") {
          const u = e.getBuilder(
            n.getZIndex(),
            "Image"
          );
          u.setImageStyle(i, o), u.drawMultiPoint(t, s);
        } else
          a && a.getText() && (o = {});
    }
    const f = l.getBuilder(
      n.getZIndex(),
      "Image"
    );
    f.setImageStyle(i, o), f.drawMultiPoint(t, s);
  }
  if (a && a.getText()) {
    let l = e;
    r && (l = r);
    const f = l.getBuilder(n.getZIndex(), "Text");
    f.setTextStyle(a, o), f.drawText(t, s);
  }
}
function rL(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (i || a) {
    const l = e.getBuilder(n.getZIndex(), "Polygon");
    l.setFillStrokeStyle(i, a), l.drawPolygon(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
class sL extends Ty {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Ni(), this.wrappedRenderedExtent_ = Ni(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.declutterExecutorGroup = null, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(t, n, s) {
    const r = n.extent, i = n.viewState, a = i.center, o = i.resolution, l = i.projection, f = i.rotation, d = l.getExtent(), u = this.getLayer().getSource(), c = n.pixelRatio, h = n.viewHints, p = !(h[tn.ANIMATING] || h[tn.INTERACTING]), g = this.compositionContext_, m = Math.round(n.size[0] * c), v = Math.round(n.size[1] * c), y = u.getWrapX() && l.canWrapX(), E = y ? ye(d) : null, C = y ? Math.ceil((r[2] - d[2]) / E) + 1 : 1;
    let x = y ? Math.floor((r[0] - d[0]) / E) : 0;
    do {
      const b = this.getRenderTransform(
        a,
        o,
        f,
        c,
        m,
        v,
        x * E
      );
      t.execute(
        g,
        1,
        b,
        f,
        p,
        void 0,
        s
      );
    } while (++x < C);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const t = Ii(
        this.context.canvas.width,
        this.context.canvas.height,
        tC
      );
      this.compositionContext_ = t;
    } else
      this.compositionContext_ = this.context;
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const t = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = t, gy(this.compositionContext_), tC.push(this.compositionContext_.canvas), this.compositionContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(
      this.declutterExecutorGroup,
      t,
      t.declutterTree
    ), this.releaseCompositionContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = t.pixelRatio, r = t.layerStatesArray[t.layerIndex];
    G_(this.pixelTransform, 1 / s, 1 / s), xf(this.inversePixelTransform, this.pixelTransform);
    const i = kv(this.pixelTransform);
    this.useContainer(n, i, this.getBackground(t));
    const a = this.context, o = a.canvas, l = this.replayGroup_, f = this.declutterExecutorGroup;
    if ((!l || l.isEmpty()) && (!f || f.isEmpty()))
      return null;
    const d = Math.round(t.size[0] * s), u = Math.round(t.size[1] * s);
    o.width != d || o.height != u ? (o.width = d, o.height = u, o.style.transform !== i && (o.style.transform = i)) : this.containerReused || a.clearRect(0, 0, d, u), this.preRender(a, t);
    const c = t.viewState;
    c.projection, this.opacity_ = r.opacity, this.setupCompositionContext_();
    let h = !1, p = !0;
    if (r.extent && this.clipping) {
      const g = js(r.extent);
      p = cn(g, t.extent), h = p && !Ar(g, t.extent), h && this.clipUnrotated(this.compositionContext_, t, g);
    }
    return p && this.renderWorlds(l, t), h && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(a, t), this.renderedRotation_ !== c.rotation && (this.renderedRotation_ = c.rotation, this.hitDetectionImageData_ = null), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise(
      /**
       * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
       * @this {CanvasVectorLayerRenderer}
       */
      (function(n) {
        if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const s = [this.context.canvas.width, this.context.canvas.height];
          An(this.pixelTransform, s);
          const r = this.renderedCenter_, i = this.renderedResolution_, a = this.renderedRotation_, o = this.renderedProjection_, l = this.wrappedRenderedExtent_, f = this.getLayer(), d = [], u = s[0] * Zi, c = s[1] * Zi;
          d.push(
            this.getRenderTransform(
              r,
              i,
              a,
              Zi,
              u,
              c,
              0
            ).slice()
          );
          const h = f.getSource(), p = o.getExtent();
          if (h.getWrapX() && o.canWrapX() && !Ar(p, l)) {
            let g = l[0];
            const m = ye(p);
            let v = 0, y;
            for (; g < p[0]; )
              --v, y = m * v, d.push(
                this.getRenderTransform(
                  r,
                  i,
                  a,
                  Zi,
                  u,
                  c,
                  y
                ).slice()
              ), g += m;
            for (v = 0, g = l[2]; g > p[2]; )
              ++v, y = m * v, d.push(
                this.getRenderTransform(
                  r,
                  i,
                  a,
                  Zi,
                  u,
                  c,
                  y
                ).slice()
              ), g -= m;
          }
          this.hitDetectionImageData_ = AP(
            s,
            d,
            this.renderedFeatures_,
            f.getStyleFunction(),
            l,
            i,
            a
          );
        }
        n(
          LP(t, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      }).bind(this)
    );
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
    if (!this.replayGroup_)
      return;
    const a = n.viewState.resolution, o = n.viewState.rotation, l = this.getLayer(), f = {}, d = function(h, p, g) {
      const m = Xt(h), v = f[m];
      if (v) {
        if (v !== !0 && g < v.distanceSq) {
          if (g === 0)
            return f[m] = !0, i.splice(i.lastIndexOf(v), 1), r(h, l, p);
          v.geometry = p, v.distanceSq = g;
        }
      } else {
        if (g === 0)
          return f[m] = !0, r(h, l, p);
        i.push(
          f[m] = {
            feature: h,
            layer: l,
            geometry: p,
            distanceSq: g,
            callback: r
          }
        );
      }
    };
    let u;
    const c = [this.replayGroup_];
    return this.declutterExecutorGroup && c.push(this.declutterExecutorGroup), c.some((h) => u = h.forEachFeatureAtCoordinate(
      t,
      a,
      o,
      s,
      d,
      h === this.declutterExecutorGroup && n.declutterTree ? n.declutterTree.all().map((p) => p.value) : null
    )), u;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.replayGroup_ && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = this.getLayer(), s = n.getSource();
    if (!s)
      return !1;
    const r = t.viewHints[tn.ANIMATING], i = t.viewHints[tn.INTERACTING], a = n.getUpdateWhileAnimating(), o = n.getUpdateWhileInteracting();
    if (this.ready && !a && r || !o && i)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = t.extent, f = t.viewState, d = f.projection, u = f.resolution, c = t.pixelRatio, h = n.getRevision(), p = n.getRenderBuffer();
    let g = n.getRenderOrder();
    g === void 0 && (g = XA);
    const m = f.center.slice(), v = wr(
      l,
      p * u
    ), y = v.slice(), E = [v.slice()], C = d.getExtent();
    if (s.getWrapX() && d.canWrapX() && !Ar(C, t.extent)) {
      const w = ye(C), B = Math.max(ye(v) / 2, w);
      v[0] = C[0] - B, v[2] = C[2] + B, Qv(m, d);
      const j = $T(E[0], d);
      j[0] < C[0] && j[2] < C[2] ? E.push([
        j[0] + w,
        j[1],
        j[2] + w,
        j[3]
      ]) : j[0] > C[0] && j[2] > C[2] && E.push([
        j[0] - w,
        j[1],
        j[2] - w,
        j[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == h && this.renderedRenderOrder_ == g && Ar(this.wrappedRenderedExtent_, v))
      return Yo(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const x = new Md(
      Rg(u, c),
      v,
      u,
      c
    );
    let b;
    this.getLayer().getDeclutter() && (b = new Md(
      Rg(u, c),
      v,
      u,
      c
    ));
    let P;
    for (let w = 0, B = E.length; w < B; ++w)
      s.loadFeatures(E[w], u, d);
    const T = wP(u, c);
    let O = !0;
    const S = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @this {CanvasVectorLayerRenderer}
       */
      (function(w) {
        let B;
        const j = w.getStyleFunction() || n.getStyleFunction();
        if (j && (B = j(w, u)), B) {
          const k = this.renderFeature(
            w,
            T,
            B,
            x,
            P,
            b
          );
          O = O && !k;
        }
      }).bind(this)
    ), L = JT(v), A = s.getFeaturesInExtent(L);
    g && A.sort(g);
    for (let w = 0, B = A.length; w < B; ++w)
      S(A[w]);
    this.renderedFeatures_ = A, this.ready = O;
    const D = x.finish(), _ = new Sd(
      v,
      u,
      c,
      s.getOverlaps(),
      D,
      n.getRenderBuffer()
    );
    return b && (this.declutterExecutorGroup = new Sd(
      v,
      u,
      c,
      s.getOverlaps(),
      b.finish(),
      n.getRenderBuffer()
    )), this.renderedResolution_ = u, this.renderedRevision_ = h, this.renderedRenderOrder_ = g, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = m, this.renderedProjection_ = d, this.replayGroup_ = _, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, n, s, r, i, a) {
    if (!s)
      return !1;
    let o = !1;
    if (Array.isArray(s))
      for (let l = 0, f = s.length; l < f; ++l)
        o = Id(
          r,
          t,
          s[l],
          n,
          this.boundHandleStyleImageChange_,
          i,
          a
        ) || o;
    else
      o = Id(
        r,
        t,
        s,
        n,
        this.boundHandleStyleImageChange_,
        i,
        a
      );
    return o;
  }
}
const aL = sL;
class oL extends SP {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new aL(this);
  }
}
const vr = oL;
class lL {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(t) {
    this.rbush_ = new TP(t), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(t, n) {
    const s = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3],
      value: n
    };
    this.rbush_.insert(s), this.items_[Xt(n)] = s;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(t, n) {
    const s = new Array(n.length);
    for (let r = 0, i = n.length; r < i; r++) {
      const a = t[r], o = n[r], l = {
        minX: a[0],
        minY: a[1],
        maxX: a[2],
        maxY: a[3],
        value: o
      };
      s[r] = l, this.items_[Xt(o)] = l;
    }
    this.rbush_.load(s);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(t) {
    const n = Xt(t), s = this.items_[n];
    return delete this.items_[n], this.rbush_.remove(s) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(t, n) {
    const s = this.items_[Xt(n)], r = [s.minX, s.minY, s.maxX, s.maxY];
    wo(r, t) || (this.remove(n), this.insert(t, n));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(n) {
      return n.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(t) {
    const n = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3]
    };
    return this.rbush_.search(n).map(function(r) {
      return r.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(t) {
    return this.forEach_(this.getAll(), t);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(t, n) {
    return this.forEach_(this.getInExtent(t), n);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(t, n) {
    let s;
    for (let r = 0, i = t.length; r < i; r++)
      if (s = n(t[r]), s)
        return s;
    return s;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Ro(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(t) {
    const n = this.rbush_.toJSON();
    return er(n.minX, n.minY, n.maxX, n.maxY, t);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(t) {
    this.rbush_.load(t.rbush_.all());
    for (const n in t.items_)
      this.items_[n] = t.items_[n];
  }
}
const iC = lL;
class uL extends Er {
  /**
   * @param {Options} options Source options.
   */
  constructor(t) {
    super(), this.projection = Wt(t.projection), this.attributions_ = rC(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible !== void 0 ? t.attributionsCollapsible : !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const n = this;
    this.viewPromise_ = new Promise(function(s, r) {
      n.viewResolver = s, n.viewRejector = r;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @abstract
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return Gt();
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(t) {
    this.attributions_ = rC(t), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(t) {
    this.state_ = t, this.changed();
  }
}
function rC(e) {
  return e ? Array.isArray(e) ? function(t) {
    return e;
  } : typeof e == "function" ? e : function(t) {
    return [e];
  } : null;
}
const Py = uL, Mr = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function cL(e, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function wg(e, t) {
  return [e];
}
let hL = !1;
function BP(e, t, n, s, r, i, a) {
  const o = new XMLHttpRequest();
  o.open(
    "GET",
    typeof e == "function" ? e(n, s, r) : e,
    !0
  ), t.getType() == "arraybuffer" && (o.responseType = "arraybuffer"), o.withCredentials = hL, o.onload = function(l) {
    if (!o.status || o.status >= 200 && o.status < 300) {
      const f = t.getType();
      let d;
      f == "json" || f == "text" ? d = o.responseText : f == "xml" ? (d = o.responseXML, d || (d = new DOMParser().parseFromString(
        o.responseText,
        "application/xml"
      ))) : f == "arraybuffer" && (d = /** @type {ArrayBuffer} */
      o.response), d ? i(
        /** @type {Array<import("./Feature.js").default>} */
        t.readFeatures(d, {
          extent: n,
          featureProjection: r
        }),
        t.readProjection(d)
      ) : a();
    } else
      a();
  }, o.onerror = a, o.send();
}
function sC(e, t) {
  return function(n, s, r, i, a) {
    const o = (
      /** @type {import("./source/Vector").default} */
      this
    );
    BP(
      e,
      t,
      n,
      s,
      r,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(l, f) {
        o.addFeatures(l), i !== void 0 && i(l);
      },
      /* FIXME handle error */
      a || Lo
    );
  };
}
class da extends Ui {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(t, n, s) {
    super(t), this.feature = n, this.features = s;
  }
}
class dL extends Py {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Lo, this.format_ = t.format, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (Zt(this.format_, 7), this.loader_ = sC(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = t.strategy !== void 0 ? t.strategy : cL;
    const n = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
    this.featuresRtree_ = n ? new iC() : null, this.loadedExtentsRtree_ = new iC(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let s, r;
    Array.isArray(t.features) ? r = t.features : t.features && (s = t.features, r = s.getArray()), !n && s === void 0 && (s = new Vi(r)), r !== void 0 && this.addFeaturesInternal(r), s !== void 0 && this.bindFeaturesCollection_(s);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(t) {
    this.addFeatureInternal(t), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(t) {
    const n = Xt(t);
    if (!this.addToIndex_(n, t)) {
      this.featuresCollection_ && this.featuresCollection_.remove(t);
      return;
    }
    this.setupChangeEvents_(n, t);
    const s = t.getGeometry();
    if (s) {
      const r = s.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(r, t);
    } else
      this.nullGeometryFeatures_[n] = t;
    this.dispatchEvent(
      new da(Mr.ADDFEATURE, t)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(t, n) {
    this.featureChangeKeys_[t] = [
      ge(n, Kt.CHANGE, this.handleFeatureChange_, this),
      ge(
        n,
        Hl.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(t, n) {
    let s = !0;
    const r = n.getId();
    return r !== void 0 && (r.toString() in this.idIndex_ ? s = !1 : this.idIndex_[r.toString()] = n), s && (Zt(!(t in this.uidIndex_), 30), this.uidIndex_[t] = n), s;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(t) {
    this.addFeaturesInternal(t), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(t) {
    const n = [], s = [], r = [];
    for (let i = 0, a = t.length; i < a; i++) {
      const o = t[i], l = Xt(o);
      this.addToIndex_(l, o) && s.push(o);
    }
    for (let i = 0, a = s.length; i < a; i++) {
      const o = s[i], l = Xt(o);
      this.setupChangeEvents_(l, o);
      const f = o.getGeometry();
      if (f) {
        const d = f.getExtent();
        n.push(d), r.push(o);
      } else
        this.nullGeometryFeatures_[l] = o;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(n, r), this.hasListener(Mr.ADDFEATURE))
      for (let i = 0, a = s.length; i < a; i++)
        this.dispatchEvent(
          new da(Mr.ADDFEATURE, s[i])
        );
  }
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(t) {
    let n = !1;
    this.addEventListener(
      Mr.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(s) {
        n || (n = !0, t.push(s.feature), n = !1);
      }
    ), this.addEventListener(
      Mr.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(s) {
        n || (n = !0, t.remove(s.feature), n = !1);
      }
    ), t.addEventListener(
      $n.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (function(s) {
        n || (n = !0, this.addFeature(s.element), n = !1);
      }).bind(this)
    ), t.addEventListener(
      $n.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (function(s) {
        n || (n = !0, this.removeFeature(s.element), n = !1);
      }).bind(this)
    ), this.featuresCollection_ = t;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(t) {
    if (t) {
      for (const s in this.featureChangeKeys_)
        this.featureChangeKeys_[s].forEach(We);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const s = (function(r) {
        this.removeFeatureInternal(r);
      }).bind(this);
      this.featuresRtree_.forEach(s);
      for (const r in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[r]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const n = new da(Mr.CLEAR);
    this.dispatchEvent(n), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(t, n) {
    const s = [t[0], t[1], t[0], t[1]];
    return this.forEachFeatureInExtent(s, function(r) {
      if (r.getGeometry().intersectsCoordinate(t))
        return n(r);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(t, n) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(t, n);
    this.featuresCollection_ && this.featuresCollection_.forEach(n);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(t, n) {
    return this.forEachFeatureInExtent(
      t,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(s) {
        if (s.getGeometry().intersectsExtent(t)) {
          const i = n(s);
          if (i)
            return i;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let t;
    return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), Ro(this.nullGeometryFeatures_) || Kn(t, Object.values(this.nullGeometryFeatures_))), /** @type {Array<import("../Feature.js").default<Geometry>>} */
    t;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(t) {
    const n = [];
    return this.forEachFeatureAtCoordinateDirect(t, function(s) {
      n.push(s);
    }), n;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(t, n) {
    if (this.featuresRtree_) {
      if (!(n && n.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(t);
      const r = tD(t, n);
      return [].concat(
        ...r.map((i) => this.featuresRtree_.getInExtent(i))
      );
    } else
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(t, n) {
    const s = t[0], r = t[1];
    let i = null;
    const a = [NaN, NaN];
    let o = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return n = n || ds, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function(f) {
        if (n(f)) {
          const d = f.getGeometry(), u = o;
          if (o = d.closestPointXY(
            s,
            r,
            a,
            o
          ), o < u) {
            i = f;
            const c = Math.sqrt(o);
            l[0] = s - c, l[1] = r - c, l[2] = s + c, l[3] = r + c;
          }
        }
      }
    ), i;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(t) {
    return this.featuresRtree_.getExtent(t);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(t) {
    const n = this.idIndex_[t.toString()];
    return n !== void 0 ? n : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(t) {
    const n = this.uidIndex_[t];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(t) {
    const n = (
      /** @type {import("../Feature.js").default<Geometry>} */
      t.target
    ), s = Xt(n), r = n.getGeometry();
    if (!r)
      s in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(n), this.nullGeometryFeatures_[s] = n);
    else {
      const a = r.getExtent();
      s in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[s], this.featuresRtree_ && this.featuresRtree_.insert(a, n)) : this.featuresRtree_ && this.featuresRtree_.update(a, n);
    }
    const i = n.getId();
    if (i !== void 0) {
      const a = i.toString();
      this.idIndex_[a] !== n && (this.removeFromIdIndex_(n), this.idIndex_[a] = n);
    } else
      this.removeFromIdIndex_(n), this.uidIndex_[s] = n;
    this.changed(), this.dispatchEvent(
      new da(Mr.CHANGEFEATURE, n)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(t) {
    const n = t.getId();
    return n !== void 0 ? n in this.idIndex_ : Xt(t) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Ro(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, n, s) {
    const r = this.loadedExtentsRtree_, i = this.strategy_(t, n, s);
    for (let a = 0, o = i.length; a < o; ++a) {
      const l = i[a];
      r.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(d) {
          return Ar(d.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new da(Mr.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        n,
        s,
        (function(d) {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new da(
              Mr.FEATURESLOADEND,
              void 0,
              d
            )
          );
        }).bind(this),
        (function() {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new da(Mr.FEATURESLOADERROR)
          );
        }).bind(this)
      ), r.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(t) {
    const n = this.loadedExtentsRtree_;
    let s;
    n.forEachInExtent(t, function(r) {
      if (wo(r.extent, t))
        return s = r, !0;
    }), s && n.remove(s);
  }
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(t) {
    if (!t)
      return;
    const n = Xt(t);
    n in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[n] : this.featuresRtree_ && this.featuresRtree_.remove(t), this.removeFeatureInternal(t) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(t) {
    const n = Xt(t), s = this.featureChangeKeys_[n];
    if (!s)
      return;
    s.forEach(We), delete this.featureChangeKeys_[n];
    const r = t.getId();
    return r !== void 0 && delete this.idIndex_[r.toString()], delete this.uidIndex_[n], this.dispatchEvent(
      new da(Mr.REMOVEFEATURE, t)
    ), t;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(t) {
    let n = !1;
    for (const s in this.idIndex_)
      if (this.idIndex_[s] === t) {
        delete this.idIndex_[s], n = !0;
        break;
      }
    return n;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(t) {
    Zt(this.format_, 7), this.url_ = t, this.setLoader(sC(t, this.format_));
  }
}
const jr = dL;
function fL(e, t) {
  const n = e.canvas;
  t = t || {};
  const s = t.pixelRatio || Ef, r = t.size;
  r && (n.width = r[0] * s, n.height = r[1] * s, n.style.width = r[0] + "px", n.style.height = r[1] + "px");
  const i = [0, 0, n.width, n.height], a = id(Qi(), s, s);
  return new DP(e, s, i, a, 0);
}
const It = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
function NP(e) {
  return Math.pow(e, 3);
}
function Zo(e) {
  return 1 - NP(1 - e);
}
function pL(e) {
  return 3 * e * e - 2 * e * e * e;
}
function FP(e) {
  return e;
}
let mL = class extends wc {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(t, n, s) {
    super(), s = s || {}, this.tileCoord = t, this.state = n, this.interimTile = null, this.key = "", this.transition_ = s.transition === void 0 ? 250 : s.transition, this.transitionStarts_ = {}, this.interpolate = !!s.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === It.ERROR && this.setState(It.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile)
      return this;
    let t = this.interimTile;
    do {
      if (t.getState() == It.LOADED)
        return this.transition_ = 0, t;
      t = t.interimTile;
    } while (t);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile)
      return;
    let t = this.interimTile, n = this;
    do {
      if (t.getState() == It.LOADED) {
        t.interimTile = null;
        break;
      } else
        t.getState() == It.LOADING ? n = t : t.getState() == It.IDLE ? n.interimTile = t.interimTile : n = t;
      t = n.interimTile;
    } while (t);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(t) {
    if (this.state !== It.ERROR && this.state > t)
      throw new Error("Tile load sequence violation");
    this.state = t, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    Gt();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(t, n) {
    if (!this.transition_)
      return 1;
    let s = this.transitionStarts_[t];
    if (!s)
      s = n, this.transitionStarts_[t] = s;
    else if (s === -1)
      return 1;
    const r = n - s + 1e3 / 60;
    return r >= this.transition_ ? 1 : NP(r / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(t) {
    return this.transition_ ? this.transitionStarts_[t] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(t) {
    this.transition_ && (this.transitionStarts_[t] = -1);
  }
};
const Df = mL;
class gL extends Df {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, a), this.crossOrigin_ = r, this.src_ = s, this.key = s, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.unlisten_ = null, this.tileLoadFunction_ = i;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(t) {
    this.image_ = t, this.state = It.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = It.ERROR, this.unlistenImage_(), this.image_ = vL(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const t = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    t.naturalWidth && t.naturalHeight ? this.state = It.LOADED : this.state = It.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == It.ERROR && (this.state = It.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == It.IDLE && (this.state = It.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = by(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function vL() {
  const e = Ii(1, 1);
  return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), e.canvas;
}
const jP = gL;
class yL {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(t, n, s) {
    this.decay_ = t, this.minVelocity_ = n, this.delay_ = s, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(t, n) {
    this.points_.push(t, n, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const t = Date.now() - this.delay_, n = this.points_.length - 3;
    if (this.points_[n + 2] < t)
      return !1;
    let s = n - 3;
    for (; s > 0 && this.points_[s + 2] > t; )
      s -= 3;
    const r = this.points_[n + 2] - this.points_[s + 2];
    if (r < 1e3 / 60)
      return !1;
    const i = this.points_[n] - this.points_[s], a = this.points_[n + 1] - this.points_[s + 1];
    return this.angle_ = Math.atan2(a, i), this.initialVelocity_ = Math.sqrt(i * i + a * a) / r, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const EL = yL;
class CL extends $v {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(), this.map_ = t;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(t, n) {
    Gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(t) {
    const n = t.viewState, s = t.coordinateToPixelTransform, r = t.pixelToCoordinateTransform;
    Fr(
      s,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / n.resolution,
      -1 / n.resolution,
      -n.rotation,
      -n.center[0],
      -n.center[1]
    ), xf(r, s);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(t, n, s, r, i, a, o, l) {
    let f;
    const d = n.viewState;
    function u(C, x, b, P) {
      return i.call(a, x, C ? b : null, P);
    }
    const c = d.projection, h = Qv(t.slice(), c), p = [[0, 0]];
    if (c.canWrapX() && r) {
      const C = c.getExtent(), x = ye(C);
      p.push([-x, 0], [x, 0]);
    }
    const g = n.layerStatesArray, m = g.length, v = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), y = [];
    for (let C = 0; C < p.length; C++)
      for (let x = m - 1; x >= 0; --x) {
        const b = g[x], P = b.layer;
        if (P.hasRenderer() && xy(b, d) && o.call(l, P)) {
          const T = P.getRenderer(), O = P.getSource();
          if (T && O) {
            const S = O.getWrapX() ? h : t, L = u.bind(
              null,
              b.managed
            );
            y[0] = S[0] + p[C][0], y[1] = S[1] + p[C][1], f = T.forEachFeatureAtCoordinate(
              y,
              n,
              s,
              L,
              v
            );
          }
          if (f)
            return f;
        }
      }
    if (v.length === 0)
      return;
    const E = 1 / v.length;
    return v.forEach((C, x) => C.distanceSq += x * E), v.sort((C, x) => C.distanceSq - x.distanceSq), v.some((C) => f = C.callback(C.feature, C.layer, C.geometry)), f;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(t, n, s, r, i, a) {
    return this.forEachFeatureAtCoordinate(
      t,
      n,
      s,
      r,
      ds,
      this,
      i,
      a
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(t) {
    Gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(t) {
    Pd.canExpireCache() && t.postRenderFunctions.push(xL);
  }
}
function xL(e, t) {
  Pd.expire();
}
const bL = CL;
class OL extends bL {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(t), this.fontChangeListenerKey_ = ge(
      Rs,
      Hl.PROPERTYCHANGE,
      t.redrawText.bind(t)
    ), this.element_ = document.createElement("div");
    const n = this.element_.style;
    n.position = "absolute", n.width = "100%", n.height = "100%", n.zIndex = "0", this.element_.className = If + " ol-layers";
    const s = t.getViewport();
    s.insertBefore(this.element_, s.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(t, n) {
    const s = this.getMap();
    if (s.hasListener(t)) {
      const r = new _P(t, void 0, n);
      s.dispatchEvent(r);
    }
  }
  disposeInternal() {
    We(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(t) {
    if (!t) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(t), this.dispatchRenderEvent(Aa.PRECOMPOSE, t);
    const n = t.layerStatesArray.sort(function(a, o) {
      return a.zIndex - o.zIndex;
    }), s = t.viewState;
    this.children_.length = 0;
    const r = [];
    let i = null;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a];
      t.layerIndex = a;
      const f = l.layer, d = f.getSourceState();
      if (!xy(l, s) || d != "ready" && d != "undefined") {
        f.unrender();
        continue;
      }
      const u = f.render(t, i);
      u && (u !== i && (this.children_.push(u), i = u), "getDeclutter" in f && r.push(
        /** @type {import("../layer/BaseVector.js").default} */
        f
      ));
    }
    for (let a = r.length - 1; a >= 0; --a)
      r[a].renderDeclutter(t);
    ZD(this.element_, this.children_), this.dispatchRenderEvent(Aa.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t);
  }
}
const TL = OL;
class va extends Ui {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(t, n) {
    super(t), this.layer = n;
  }
}
const fp = {
  LAYERS: "layers"
};
class My extends bP {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {Options} */
      Object.assign({}, t)
    );
    delete n.layers;
    let s = t.layers;
    super(n), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(fp.LAYERS, this.handleLayersChanged_), s ? Array.isArray(s) ? s = new Vi(s.slice(), { unique: !0 }) : Zt(typeof /** @type {?} */
    s.getArray == "function", 43) : s = new Vi(void 0, { unique: !0 }), this.setLayers(s);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(We), this.layersListenerKeys_.length = 0;
    const t = this.getLayers();
    this.layersListenerKeys_.push(
      ge(t, $n.ADD, this.handleLayersAdd_, this),
      ge(t, $n.REMOVE, this.handleLayersRemove_, this)
    );
    for (const s in this.listenerKeys_)
      this.listenerKeys_[s].forEach(We);
    ou(this.listenerKeys_);
    const n = t.getArray();
    for (let s = 0, r = n.length; s < r; s++) {
      const i = n[s];
      this.registerLayerListeners_(i), this.dispatchEvent(new va("addlayer", i));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(t) {
    const n = [
      ge(
        t,
        Hl.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      ge(t, Kt.CHANGE, this.handleLayerChange_, this)
    ];
    t instanceof My && n.push(
      ge(t, "addlayer", this.handleLayerGroupAdd_, this),
      ge(t, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[Xt(t)] = n;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(t) {
    this.dispatchEvent(new va("addlayer", t.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(t) {
    this.dispatchEvent(new va("removelayer", t.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(t) {
    const n = t.element;
    this.registerLayerListeners_(n), this.dispatchEvent(new va("addlayer", n)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(t) {
    const n = t.element, s = Xt(n);
    this.listenerKeys_[s].forEach(We), delete this.listenerKeys_[s], this.dispatchEvent(new va("removelayer", n)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(fp.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(t) {
    const n = this.getLayers();
    if (n) {
      const s = n.getArray();
      for (let r = 0, i = s.length; r < i; ++r)
        this.dispatchEvent(new va("removelayer", s[r]));
    }
    this.set(fp.LAYERS, t);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t !== void 0 ? t : [], this.getLayers().forEach(function(n) {
      n.getLayersArray(t);
    }), t;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    const n = t !== void 0 ? t : [], s = n.length;
    this.getLayers().forEach(function(a) {
      a.getLayerStatesArray(n);
    });
    const r = this.getLayerState();
    let i = r.zIndex;
    !t && r.zIndex === void 0 && (i = 0);
    for (let a = s, o = n.length; a < o; a++) {
      const l = n[a];
      l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(
        l.maxResolution,
        r.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        r.minResolution
      ), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = zs(
        l.extent,
        r.extent
      ) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = i);
    }
    return n;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const Wa = My;
class PL extends Ui {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(t, n, s) {
    super(t), this.map = n, this.frameState = s !== void 0 ? s : null;
  }
}
const vl = PL;
class ML extends vl {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, i), this.originalEvent = s, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : !1, this.activePointers = a;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(t) {
    this.pixel_ = t;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(t) {
    this.coordinate_ = t;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const ws = ML, Te = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: Kt.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: Kt.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Vg = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class SL extends wc {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(t, n) {
    super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = n === void 0 ? 1 : n, this.down_ = null;
    const s = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = s, this.pointerdownListenerKey_ = ge(
      s,
      Vg.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = ge(
      s,
      Vg.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      Kt.TOUCHMOVE,
      this.boundHandleTouchMove_,
      NT ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(t) {
    let n = new ws(
      Te.CLICK,
      this.map_,
      t
    );
    this.dispatchEvent(n), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, n = new ws(
      Te.DBLCLICK,
      this.map_,
      t
    ), this.dispatchEvent(n)) : this.clickTimeoutId_ = setTimeout(
      /** @this {MapBrowserEventHandler} */
      (function() {
        this.clickTimeoutId_ = void 0;
        const s = new ws(
          Te.SINGLECLICK,
          this.map_,
          t
        );
        this.dispatchEvent(s);
      }).bind(this),
      250
    );
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(t) {
    const n = t, s = n.pointerId;
    if (n.type == Te.POINTERUP || n.type == Te.POINTERCANCEL) {
      delete this.trackedTouches_[s];
      for (const r in this.trackedTouches_)
        if (this.trackedTouches_[r].target !== n.target) {
          delete this.trackedTouches_[r];
          break;
        }
    } else
      (n.type == Te.POINTERDOWN || n.type == Te.POINTERMOVE) && (this.trackedTouches_[s] = n);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(t) {
    this.updateActivePointers_(t);
    const n = new ws(
      Te.POINTERUP,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(n), this.emulateClicks_ && !n.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(We), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(t) {
    return t.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(t) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
    const n = new ws(
      Te.POINTERDOWN,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(n), this.down_ = /** @type {PointerEvent} */
    {};
    for (const s in t) {
      const r = t[s];
      this.down_[s] = typeof r == "function" ? Lo : r;
    }
    if (this.dragListenerKeys_.length === 0) {
      const s = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        ge(
          s,
          Te.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        ge(s, Te.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        ge(
          this.element_,
          Te.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== s && this.dragListenerKeys_.push(
        ge(
          this.element_.getRootNode(),
          Te.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.isMoving_(t)) {
      this.updateActivePointers_(t), this.dragging_ = !0;
      const n = new ws(
        Te.POINTERDRAG,
        this.map_,
        t,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(n);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(t) {
    this.originalPointerMoveEvent_ = t;
    const n = !!(this.down_ && this.isMoving_(t));
    this.dispatchEvent(
      new ws(
        Te.POINTERMOVE,
        this.map_,
        t,
        n
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(t) {
    const n = this.originalPointerMoveEvent_;
    (!n || n.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === !0) && t.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(t) {
    return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (We(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      Kt.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (We(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(We), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const IL = SL, Vs = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, oi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, _d = 1 / 0;
class _L {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(t, n) {
    this.priorityFunction_ = t, this.keyFunction_ = n, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, ou(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const t = this.elements_, n = this.priorities_, s = t[0];
    t.length == 1 ? (t.length = 0, n.length = 0) : (t[0] = t.pop(), n[0] = n.pop(), this.siftUp_(0));
    const r = this.keyFunction_(s);
    return delete this.queuedElements_[r], s;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(t) {
    Zt(!(this.keyFunction_(t) in this.queuedElements_), 31);
    const n = this.priorityFunction_(t);
    return n != _d ? (this.elements_.push(t), this.priorities_.push(n), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(t) {
    return t * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(t) {
    return t * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(t) {
    return t - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let t;
    for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
      this.siftUp_(t);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(t) {
    return t in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(t) {
    return this.isKeyQueued(this.keyFunction_(t));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(t) {
    const n = this.elements_, s = this.priorities_, r = n.length, i = n[t], a = s[t], o = t;
    for (; t < r >> 1; ) {
      const l = this.getLeftChildIndex_(t), f = this.getRightChildIndex_(t), d = f < r && s[f] < s[l] ? f : l;
      n[t] = n[d], s[t] = s[d], t = d;
    }
    n[t] = i, s[t] = a, this.siftDown_(o, t);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(t, n) {
    const s = this.elements_, r = this.priorities_, i = s[n], a = r[n];
    for (; n > t; ) {
      const o = this.getParentIndex_(n);
      if (r[o] > a)
        s[n] = s[o], r[n] = r[o], n = o;
      else
        break;
    }
    s[n] = i, r[n] = a;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const t = this.priorityFunction_, n = this.elements_, s = this.priorities_;
    let r = 0;
    const i = n.length;
    let a, o, l;
    for (o = 0; o < i; ++o)
      a = n[o], l = t(a), l == _d ? delete this.queuedElements_[this.keyFunction_(a)] : (s[r] = l, n[r++] = a);
    n.length = r, s.length = r, this.heapify_();
  }
}
const DL = _L;
class AL extends DL {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(t, n) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(s) {
        return t.apply(null, s);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(s) {
        return (
          /** @type {import("./Tile.js").default} */
          s[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = n, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(t) {
    const n = super.enqueue(t);
    return n && t[0].addEventListener(Kt.CHANGE, this.boundHandleTileChange_), n;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const n = (
      /** @type {import("./Tile.js").default} */
      t.target
    ), s = n.getState();
    if (s === It.LOADED || s === It.ERROR || s === It.EMPTY) {
      s !== It.ERROR && n.removeEventListener(Kt.CHANGE, this.boundHandleTileChange_);
      const r = n.getKey();
      r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(t, n) {
    let s = 0, r, i, a;
    for (; this.tilesLoading_ < t && s < n && this.getCount() > 0; )
      i = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], a = i.getKey(), r = i.getState(), r === It.IDLE && !(a in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[a] = !0, ++this.tilesLoading_, ++s, i.load());
  }
}
const LL = AL;
function RL(e, t, n, s, r) {
  if (!e || !(n in e.wantedTiles) || !e.wantedTiles[n][t.getKey()])
    return _d;
  const i = e.viewState.center, a = s[0] - i[0], o = s[1] - i[1];
  return 65536 * Math.log(r) + Math.sqrt(a * a + o * o) / r;
}
const Sr = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, UP = 42, Sy = 256;
function aC(e, t, n) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(s, r, i, a, o) {
      if (!s)
        return;
      if (!r && !t)
        return s;
      const l = t ? 0 : i[0] * r, f = t ? 0 : i[1] * r, d = o ? o[0] : 0, u = o ? o[1] : 0;
      let c = e[0] + l / 2 + d, h = e[2] - l / 2 + d, p = e[1] + f / 2 + u, g = e[3] - f / 2 + u;
      c > h && (c = (h + c) / 2, h = c), p > g && (p = (g + p) / 2, g = p);
      let m = hn(s[0], c, h), v = hn(s[1], p, g);
      if (a && n && r) {
        const y = 30 * r;
        m += -y * Math.log(1 + Math.max(0, c - s[0]) / y) + y * Math.log(1 + Math.max(0, s[0] - h) / y), v += -y * Math.log(1 + Math.max(0, p - s[1]) / y) + y * Math.log(1 + Math.max(0, s[1] - g) / y);
      }
      return [m, v];
    }
  );
}
function wL(e) {
  return e;
}
function Iy(e, t, n, s) {
  const r = ye(t) / n[0], i = In(t) / n[1];
  return s ? Math.min(e, Math.max(r, i)) : Math.min(e, Math.min(r, i));
}
function _y(e, t, n) {
  let s = Math.min(e, t);
  const r = 50;
  return s *= Math.log(1 + r * Math.max(0, e / t - 1)) / r + 1, n && (s = Math.max(s, n), s /= Math.log(1 + r * Math.max(0, n / e - 1)) / r + 1), hn(s, n / 2, t * 2);
}
function VL(e, t, n, s) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, i, a, o) {
    if (r !== void 0) {
      const l = e[0], f = e[e.length - 1], d = n ? Iy(
        l,
        n,
        a,
        s
      ) : l;
      if (o)
        return t ? _y(
          r,
          d,
          f
        ) : hn(r, f, d);
      const u = Math.min(d, r), c = Math.floor(vf(e, u, i));
      return e[c] > d && c < e.length - 1 ? e[c + 1] : e[c];
    } else
      return;
  };
}
function BL(e, t, n, s, r, i) {
  return s = s !== void 0 ? s : !0, n = n !== void 0 ? n : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, l, f) {
    if (a !== void 0) {
      const d = r ? Iy(
        t,
        r,
        l,
        i
      ) : t;
      if (f)
        return s ? _y(
          a,
          d,
          n
        ) : hn(a, n, d);
      const u = 1e-9, c = Math.ceil(
        Math.log(t / d) / Math.log(e) - u
      ), h = -o * (0.5 - u) + 0.5, p = Math.min(d, a), g = Math.floor(
        Math.log(t / p) / Math.log(e) + h
      ), m = Math.max(c, g), v = t / Math.pow(e, m);
      return hn(v, n, d);
    } else
      return;
  };
}
function oC(e, t, n, s, r) {
  return n = n !== void 0 ? n : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(i, a, o, l) {
    if (i !== void 0) {
      const f = s ? Iy(
        e,
        s,
        o,
        r
      ) : e;
      return !n || !l ? hn(i, t, f) : _y(
        i,
        f,
        t
      );
    } else
      return;
  };
}
function Dy(e) {
  if (e !== void 0)
    return 0;
}
function lC(e) {
  if (e !== void 0)
    return e;
}
function NL(e) {
  const t = 2 * Math.PI / e;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(n, s) {
      if (s)
        return n;
      if (n !== void 0)
        return n = Math.floor(n / t + 0.5) * t, n;
    }
  );
}
function FL(e) {
  return e = e || Po(5), /**
   * @param {number|undefined} rotation Rotation.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Rotation.
   */
  function(t, n) {
    if (n)
      return t;
    if (t !== void 0)
      return Math.abs(t) <= e ? 0 : t;
  };
}
const pp = 0;
class jL extends Er {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = ny(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && fD(), t.center && (t.center = _r(t.center, this.projection_)), t.extent && (t.extent = js(t.extent, this.projection_)), this.applyOptions_(t);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(t) {
    const n = Object.assign({}, t);
    for (const o in Sr)
      delete n[o];
    this.setProperties(n, !0);
    const s = WL(t);
    this.maxResolution_ = s.maxResolution, this.minResolution_ = s.minResolution, this.zoomFactor_ = s.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = s.minZoom;
    const r = UL(t), i = s.constraint, a = $L(t);
    this.constraints_ = {
      center: r,
      resolution: i,
      rotation: a
    }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
      t.center !== void 0 ? t.center : null
    ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(t) {
    let n = this.padding_;
    this.padding_ = t;
    const s = this.getCenter();
    if (s) {
      const r = t || [0, 0, 0, 0];
      n = n || [0, 0, 0, 0];
      const i = this.getResolution(), a = i / 2 * (r[3] - n[3] + n[1] - r[1]), o = i / 2 * (r[0] - n[0] + n[2] - r[2]);
      this.setCenterInternal([s[0] + a, s[1] - o]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(t) {
    const n = this.getProperties();
    return n.resolution !== void 0 ? n.resolution = this.getResolution() : n.zoom = this.getZoom(), n.center = this.getCenterInternal(), n.rotation = this.getRotation(), Object.assign({}, n, t);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(t) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const n = new Array(arguments.length);
    for (let s = 0; s < n.length; ++s) {
      let r = arguments[s];
      r.center && (r = Object.assign({}, r), r.center = _r(
        r.center,
        this.getProjection()
      )), r.anchor && (r = Object.assign({}, r), r.anchor = _r(
        r.anchor,
        this.getProjection()
      )), n[s] = r;
    }
    this.animateInternal.apply(this, n);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(t) {
    let n = arguments.length, s;
    n > 1 && typeof arguments[n - 1] == "function" && (s = arguments[n - 1], --n);
    let r = 0;
    for (; r < n && !this.isDef(); ++r) {
      const d = arguments[r];
      d.center && this.setCenterInternal(d.center), d.zoom !== void 0 ? this.setZoom(d.zoom) : d.resolution && this.setResolution(d.resolution), d.rotation !== void 0 && this.setRotation(d.rotation);
    }
    if (r === n) {
      s && vh(s, !0);
      return;
    }
    let i = Date.now(), a = this.targetCenter_.slice(), o = this.targetResolution_, l = this.targetRotation_;
    const f = [];
    for (; r < n; ++r) {
      const d = (
        /** @type {AnimationOptions} */
        arguments[r]
      ), u = {
        start: i,
        complete: !1,
        anchor: d.anchor,
        duration: d.duration !== void 0 ? d.duration : 1e3,
        easing: d.easing || pL,
        callback: s
      };
      if (d.center && (u.sourceCenter = a, u.targetCenter = d.center.slice(), a = u.targetCenter), d.zoom !== void 0 ? (u.sourceResolution = o, u.targetResolution = this.getResolutionForZoom(d.zoom), o = u.targetResolution) : d.resolution && (u.sourceResolution = o, u.targetResolution = d.resolution, o = u.targetResolution), d.rotation !== void 0) {
        u.sourceRotation = l;
        const c = _a(d.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        u.targetRotation = l + c, l = u.targetRotation;
      }
      zL(u) ? u.complete = !0 : i += u.duration, f.push(u);
    }
    this.animations_.push(f), this.setHint(tn.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[tn.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[tn.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(tn.ANIMATING, -this.hints_[tn.ANIMATING]);
    let t;
    for (let n = 0, s = this.animations_.length; n < s; ++n) {
      const r = this.animations_[n];
      if (r[0].callback && vh(r[0].callback, !1), !t)
        for (let i = 0, a = r.length; i < a; ++i) {
          const o = r[i];
          if (!o.complete) {
            t = o.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const t = Date.now();
    let n = !1;
    for (let s = this.animations_.length - 1; s >= 0; --s) {
      const r = this.animations_[s];
      let i = !0;
      for (let a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        if (l.complete)
          continue;
        const f = t - l.start;
        let d = l.duration > 0 ? f / l.duration : 1;
        d >= 1 ? (l.complete = !0, d = 1) : i = !1;
        const u = l.easing(d);
        if (l.sourceCenter) {
          const c = l.sourceCenter[0], h = l.sourceCenter[1], p = l.targetCenter[0], g = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = c + u * (p - c), v = h + u * (g - h);
          this.targetCenter_ = [m, v];
        }
        if (l.sourceResolution && l.targetResolution) {
          const c = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const h = this.getViewportSize_(this.getRotation()), p = this.constraints_.resolution(
              c,
              0,
              h,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              p,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = c, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const c = u === 1 ? _a(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const h = this.constraints_.rotation(
              c,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              h,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = c;
        }
        if (this.applyTargetState_(!0), n = !0, !l.complete)
          break;
      }
      if (i) {
        this.animations_[s] = null, this.setHint(tn.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const a = r[0].callback;
        a && vh(a, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), n && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(t, n) {
    let s;
    const r = this.getCenterInternal();
    return r !== void 0 && (s = [r[0] - n[0], r[1] - n[1]], Jv(s, t - this.getRotation()), GT(s, n)), s;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(t, n) {
    let s;
    const r = this.getCenterInternal(), i = this.getResolution();
    if (r !== void 0 && i !== void 0) {
      const a = n[0] - t * (n[0] - r[0]) / i, o = n[1] - t * (n[1] - r[1]) / i;
      s = [a, o];
    }
    return s;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(t) {
    const n = this.viewportSize_;
    if (t) {
      const s = n[0], r = n[1];
      return [
        Math.abs(s * Math.cos(t)) + Math.abs(r * Math.sin(t)),
        Math.abs(s * Math.sin(t)) + Math.abs(r * Math.cos(t))
      ];
    } else
      return n;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(t) {
    this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const t = this.getCenterInternal();
    return t && Sg(t, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Sr.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(t) {
    return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(t) {
    const n = this.calculateExtentInternal(t);
    return JT(n, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(t) {
    t = t || this.getViewportSizeMinusPadding_();
    const n = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Zt(n, 1);
    const s = (
      /** @type {!number} */
      this.getResolution()
    );
    Zt(s !== void 0, 2);
    const r = (
      /** @type {!number} */
      this.getRotation()
    );
    return Zt(r !== void 0, 3), Nl(n, s, r, t);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(t) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Sr.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(t, n) {
    return this.getResolutionForExtentInternal(
      js(t, this.getProjection()),
      n
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(t, n) {
    n = n || this.getViewportSizeMinusPadding_();
    const s = ye(t) / n[0], r = In(t) / n[1];
    return Math.max(s, r);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(t) {
    t = t || 2;
    const n = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, r = Math.log(n / s) / Math.log(t);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(i) {
        return n / Math.pow(t, i * r);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Sr.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(t) {
    const n = Math.log(t || 2), s = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, i = Math.log(s / r) / n;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(a) {
        return Math.log(s / a) / n / i;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(t) {
    let n = this.getViewportSize_(t);
    const s = this.padding_;
    return s && (n = [
      n[0] - s[1] - s[3],
      n[1] - s[0] - s[2]
    ]), n;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const t = this.getProjection(), n = this.getResolution(), s = this.getRotation();
    let r = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const i = this.padding_;
    if (i) {
      const a = this.getViewportSizeMinusPadding_();
      r = mp(
        r,
        this.getViewportSize_(),
        [a[0] / 2 + i[3], a[1] / 2 + i[0]],
        n,
        s
      );
    }
    return {
      center: r.slice(0),
      projection: t !== void 0 ? t : null,
      resolution: n,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: s,
      zoom: this.getZoom()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let t;
    const n = this.getResolution();
    return n !== void 0 && (t = this.getZoomForResolution(n)), t;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(t) {
    let n = this.minZoom_ || 0, s, r;
    if (this.resolutions_) {
      const i = vf(this.resolutions_, t, 1);
      n = i, s = this.resolutions_[i], i == this.resolutions_.length - 1 ? r = 2 : r = s / this.resolutions_[i + 1];
    } else
      s = this.maxResolution_, r = this.zoomFactor_;
    return n + Math.log(s / t) / Math.log(r);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(t) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const n = hn(
        Math.floor(t),
        0,
        this.resolutions_.length - 2
      ), s = this.resolutions_[n] / this.resolutions_[n + 1];
      return this.resolutions_[n] / Math.pow(s, hn(t - n, 0, 1));
    } else
      return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(t, n) {
    let s;
    if (Zt(
      Array.isArray(t) || typeof /** @type {?} */
      t.getSimplifiedGeometry == "function",
      24
    ), Array.isArray(t)) {
      Zt(!bf(t), 25);
      const r = js(t, this.getProjection());
      s = jE(r);
    } else if (t.getType() === "Circle") {
      const r = js(
        t.getExtent(),
        this.getProjection()
      );
      s = jE(r), s.rotate(this.getRotation(), Fi(r));
    } else
      s = t;
    this.fitInternal(s, n);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(t) {
    const n = this.getRotation(), s = Math.cos(n), r = Math.sin(-n), i = t.getFlatCoordinates(), a = t.getStride();
    let o = 1 / 0, l = 1 / 0, f = -1 / 0, d = -1 / 0;
    for (let u = 0, c = i.length; u < c; u += a) {
      const h = i[u] * s - i[u + 1] * r, p = i[u] * r + i[u + 1] * s;
      o = Math.min(o, h), l = Math.min(l, p), f = Math.max(f, h), d = Math.max(d, p);
    }
    return [o, l, f, d];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(t, n) {
    n = n || {};
    let s = n.size;
    s || (s = this.getViewportSizeMinusPadding_());
    const r = n.padding !== void 0 ? n.padding : [0, 0, 0, 0], i = n.nearest !== void 0 ? n.nearest : !1;
    let a;
    n.minResolution !== void 0 ? a = n.minResolution : n.maxZoom !== void 0 ? a = this.getResolutionForZoom(n.maxZoom) : a = 0;
    const o = this.rotatedExtentForGeometry(t);
    let l = this.getResolutionForExtentInternal(o, [
      s[0] - r[1] - r[3],
      s[1] - r[0] - r[2]
    ]);
    l = isNaN(l) ? a : Math.max(l, a), l = this.getConstrainedResolution(l, i ? 0 : 1);
    const f = this.getRotation(), d = Math.sin(f), u = Math.cos(f), c = Fi(o);
    c[0] += (r[1] - r[3]) / 2 * l, c[1] += (r[0] - r[2]) / 2 * l;
    const h = c[0] * u - c[1] * d, p = c[1] * u + c[0] * d, g = this.getConstrainedCenter([h, p], l), m = n.callback ? n.callback : Lo;
    n.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: g,
        duration: n.duration,
        easing: n.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = g, this.applyTargetState_(!1, !0), vh(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(t, n, s) {
    this.centerOnInternal(
      _r(t, this.getProjection()),
      n,
      s
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(t, n, s) {
    this.setCenterInternal(
      mp(
        t,
        n,
        s,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(t, n, s, r) {
    let i;
    const a = this.padding_;
    if (a && t) {
      const o = this.getViewportSizeMinusPadding_(-s), l = mp(
        t,
        r,
        [o[0] / 2 + a[3], o[1] / 2 + a[0]],
        n,
        s
      );
      i = [
        t[0] - l[0],
        t[1] - l[1]
      ];
    }
    return i;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(t) {
    const n = Sg(this.targetCenter_, this.getProjection());
    this.setCenter([
      n[0] + t[0],
      n[1] + t[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(t) {
    const n = this.targetCenter_;
    this.setCenterInternal([
      n[0] + t[0],
      n[1] + t[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(t, n) {
    n = n && _r(n, this.getProjection()), this.adjustResolutionInternal(t, n);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(t, n) {
    const s = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), i = this.constraints_.resolution(
      this.targetResolution_ * t,
      0,
      r,
      s
    );
    n && (this.targetCenter_ = this.calculateCenterZoom(i, n)), this.targetResolution_ *= t, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(t, n) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -t), n);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(t, n) {
    n && (n = _r(n, this.getProjection())), this.adjustRotationInternal(t, n);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(t, n) {
    const s = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(
      this.targetRotation_ + t,
      s
    );
    n && (this.targetCenter_ = this.calculateCenterRotate(r, n)), this.targetRotation_ += t, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(t) {
    this.setCenterInternal(
      t && _r(t, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(t) {
    this.targetCenter_ = t, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(t, n) {
    return this.hints_[t] += n, this.changed(), this.hints_[t];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(t) {
    this.targetResolution_ = t, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(t) {
    this.targetRotation_ = t, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(t) {
    this.setResolution(this.getResolutionForZoom(t));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(t, n) {
    const s = this.getAnimating() || this.getInteracting() || n, r = this.constraints_.rotation(
      this.targetRotation_,
      s
    ), i = this.getViewportSize_(r), a = this.constraints_.resolution(
      this.targetResolution_,
      0,
      i,
      s
    ), o = this.constraints_.center(
      this.targetCenter_,
      a,
      i,
      s,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        r,
        i
      )
    );
    this.get(Sr.ROTATION) !== r && this.set(Sr.ROTATION, r), this.get(Sr.RESOLUTION) !== a && (this.set(Sr.RESOLUTION, a), this.set("zoom", this.getZoom(), !0)), (!o || !this.get(Sr.CENTER) || !fd(this.get(Sr.CENTER), o)) && this.set(Sr.CENTER, o), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(t, n, s) {
    t = t !== void 0 ? t : 200;
    const r = n || 0, i = this.constraints_.rotation(this.targetRotation_), a = this.getViewportSize_(i), o = this.constraints_.resolution(
      this.targetResolution_,
      r,
      a
    ), l = this.constraints_.center(
      this.targetCenter_,
      o,
      a,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        i,
        a
      )
    );
    if (t === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = o, this.targetRotation_ = i, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    s = s || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== o || this.getRotation() !== i || !this.getCenterInternal() || !fd(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: i,
      center: l,
      resolution: o,
      duration: t,
      easing: Zo,
      anchor: s
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(tn.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(t, n, s) {
    s = s && _r(s, this.getProjection()), this.endInteractionInternal(t, n, s);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(t, n, s) {
    this.setHint(tn.INTERACTING, -1), this.resolveConstraints(t, n, s);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(t, n) {
    const s = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      t,
      n || this.getResolution(),
      s
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(t, n) {
    const s = this.getResolutionForZoom(t);
    return this.getZoomForResolution(
      this.getConstrainedResolution(s, n)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(t, n) {
    n = n || 0;
    const s = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(t, n, s);
  }
}
function vh(e, t) {
  setTimeout(function() {
    e(t);
  }, 0);
}
function UL(e) {
  if (e.extent !== void 0) {
    const n = e.smoothExtentConstraint !== void 0 ? e.smoothExtentConstraint : !0;
    return aC(e.extent, e.constrainOnlyCenter, n);
  }
  const t = ny(e.projection, "EPSG:3857");
  if (e.multiWorld !== !0 && t.isGlobal()) {
    const n = t.getExtent().slice();
    return n[0] = -1 / 0, n[2] = 1 / 0, aC(n, !1, !1);
  }
  return wL;
}
function WL(e) {
  let t, n, s, a = e.minZoom !== void 0 ? e.minZoom : pp, o = e.maxZoom !== void 0 ? e.maxZoom : 28;
  const l = e.zoomFactor !== void 0 ? e.zoomFactor : 2, f = e.multiWorld !== void 0 ? e.multiWorld : !1, d = e.smoothResolutionConstraint !== void 0 ? e.smoothResolutionConstraint : !0, u = e.showFullExtent !== void 0 ? e.showFullExtent : !1, c = ny(e.projection, "EPSG:3857"), h = c.getExtent();
  let p = e.constrainOnlyCenter, g = e.extent;
  if (!f && !g && c.isGlobal() && (p = !1, g = h), e.resolutions !== void 0) {
    const m = e.resolutions;
    n = m[a], s = m[o] !== void 0 ? m[o] : m[m.length - 1], e.constrainResolution ? t = VL(
      m,
      d,
      !p && g,
      u
    ) : t = oC(
      n,
      s,
      d,
      !p && g,
      u
    );
  } else {
    const v = (h ? Math.max(ye(h), In(h)) : (
      // use an extent that can fit the whole world if need be
      360 * Zl.degrees / c.getMetersPerUnit()
    )) / Sy / Math.pow(2, pp), y = v / Math.pow(2, 28 - pp);
    n = e.maxResolution, n !== void 0 ? a = 0 : n = v / Math.pow(l, a), s = e.minResolution, s === void 0 && (e.maxZoom !== void 0 ? e.maxResolution !== void 0 ? s = n / Math.pow(l, o) : s = v / Math.pow(l, o) : s = y), o = a + Math.floor(
      Math.log(n / s) / Math.log(l)
    ), s = n / Math.pow(l, o - a), e.constrainResolution ? t = BL(
      l,
      n,
      s,
      d,
      !p && g,
      u
    ) : t = oC(
      n,
      s,
      d,
      !p && g,
      u
    );
  }
  return {
    constraint: t,
    maxResolution: n,
    minResolution: s,
    minZoom: a,
    zoomFactor: l
  };
}
function $L(e) {
  if (e.enableRotation !== void 0 ? e.enableRotation : !0) {
    const n = e.constrainRotation;
    return n === void 0 || n === !0 ? FL() : n === !1 ? lC : typeof n == "number" ? NL(n) : lC;
  } else
    return Dy;
}
function zL(e) {
  return !(e.sourceCenter && e.targetCenter && !fd(e.sourceCenter, e.targetCenter) || e.sourceResolution !== e.targetResolution || e.sourceRotation !== e.targetRotation);
}
function mp(e, t, n, s, r) {
  const i = Math.cos(-r);
  let a = Math.sin(-r), o = e[0] * i - e[1] * a, l = e[1] * i + e[0] * a;
  o += (t[0] / 2 - n[0]) * s, l += (n[1] - t[1] / 2) * s, a = -a;
  const f = o * i - l * a, d = l * i + o * a;
  return [f, d];
}
const ya = jL;
class KL extends Er {
  /**
   * @param {Options} options Control options.
   */
  constructor(t) {
    super();
    const n = t.element;
    n && !t.target && !n.style.pointerEvents && (n.style.pointerEvents = "auto"), this.element = n || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    xd(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.map_ && xd(this.element);
    for (let n = 0, s = this.listenerKeys.length; n < s; ++n)
      We(this.listenerKeys[n]);
    this.listenerKeys.length = 0, this.map_ = t, t && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Lo && this.listenerKeys.push(
      ge(t, Vs.POSTRENDER, this.render, this)
    ), t.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(t) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(t) {
    this.target_ = typeof t == "string" ? document.getElementById(t) : t;
  }
}
const Ay = KL;
class GL extends Ay {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const n = t.className !== void 0 ? t.className : "ol-attribution", s = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", r = t.expandClassName !== void 0 ? t.expandClassName : n + "-expand", i = t.collapseLabel !== void 0 ? t.collapseLabel : "›", a = t.collapseClassName !== void 0 ? t.collapseClassName : n + "-collapse";
    typeof i == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = i, this.collapseLabel_.className = a) : this.collapseLabel_ = i;
    const o = t.label !== void 0 ? t.label : "i";
    typeof o == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = r) : this.label_ = o;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = s, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const f = n + " " + If + " " + vy + (this.collapsed_ && this.collapsible_ ? " " + KE : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), d = this.element;
    d.className = f, d.appendChild(this.toggleButton_), d.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(t) {
    const n = {}, s = [];
    let r = !0;
    const i = t.layerStatesArray;
    for (let a = 0, o = i.length; a < o; ++a) {
      const l = i[a];
      if (!xy(l, t.viewState))
        continue;
      const f = (
        /** @type {import("../layer/Layer.js").default} */
        l.layer.getSource()
      );
      if (!f)
        continue;
      const d = f.getAttributions();
      if (!d)
        continue;
      const u = d(t);
      if (u)
        if (r = r && f.getAttributionsCollapsible() !== !1, Array.isArray(u))
          for (let c = 0, h = u.length; c < h; ++c)
            u[c] in n || (s.push(u[c]), n[u[c]] = !0);
        else
          u in n || (s.push(u), n[u] = !0);
    }
    return this.overrideCollapsible_ || this.setCollapsible(r), s;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(t) {
    if (!t) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const n = this.collectSourceAttributions_(t), s = n.length > 0;
    if (this.renderedVisible_ != s && (this.element.style.display = s ? "" : "none", this.renderedVisible_ = s), !Yo(n, this.renderedAttributions_)) {
      mP(this.ulElement_);
      for (let r = 0, i = n.length; r < i; ++r) {
        const a = document.createElement("li");
        a.innerHTML = n[r], this.ulElement_.appendChild(a);
      }
      this.renderedAttributions_ = n;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(KE), this.collapsed_ ? zE(this.collapseLabel_, this.label_) : zE(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(t) {
    this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(t) {
    this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    this.updateElement_(t.frameState);
  }
}
const kL = GL;
class HL extends Ay {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    });
    const n = t.className !== void 0 ? t.className : "ol-rotate", s = t.label !== void 0 ? t.label : "⇧", r = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
    this.label_ = null, typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = s) : (this.label_ = s, this.label_.classList.add(r));
    const i = t.tipLabel ? t.tipLabel : "Reset rotation", a = document.createElement("button");
    a.className = n + "-reset", a.setAttribute("type", "button"), a.title = i, a.appendChild(this.label_), a.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const o = n + " " + If + " " + vy, l = this.element;
    l.className = o, l.appendChild(a), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(fh);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const n = this.getMap().getView();
    if (!n)
      return;
    const s = n.getRotation();
    s !== void 0 && (this.duration_ > 0 && s % (2 * Math.PI) !== 0 ? n.animate({
      rotation: 0,
      duration: this.duration_,
      easing: Zo
    }) : n.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    const n = t.frameState;
    if (!n)
      return;
    const s = n.viewState.rotation;
    if (s != this.rotation_) {
      const r = "rotate(" + s + "rad)";
      if (this.autoHide_) {
        const i = this.element.classList.contains(fh);
        !i && s === 0 ? this.element.classList.add(fh) : i && s !== 0 && this.element.classList.remove(fh);
      }
      this.label_.style.transform = r;
    }
    this.rotation_ = s;
  }
}
const YL = HL;
let XL = class extends Ay {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      target: t.target
    });
    const n = t.className !== void 0 ? t.className : "ol-zoom", s = t.delta !== void 0 ? t.delta : 1, r = t.zoomInClassName !== void 0 ? t.zoomInClassName : n + "-in", i = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : n + "-out", a = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", o = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "–", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", f = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", d = document.createElement("button");
    d.className = r, d.setAttribute("type", "button"), d.title = l, d.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), d.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this, s),
      !1
    );
    const u = document.createElement("button");
    u.className = i, u.setAttribute("type", "button"), u.title = f, u.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), u.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this, -s),
      !1
    );
    const c = n + " " + If + " " + vy, h = this.element;
    h.className = c, h.appendChild(d), h.appendChild(u), this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t, n) {
    n.preventDefault(), this.zoomByDelta_(t);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(t) {
    const s = this.getMap().getView();
    if (!s)
      return;
    const r = s.getZoom();
    if (r !== void 0) {
      const i = s.getConstrainedZoom(r + t);
      this.duration_ > 0 ? (s.getAnimating() && s.cancelAnimations(), s.animate({
        zoom: i,
        duration: this.duration_,
        easing: Zo
      })) : s.setZoom(i);
    }
  }
};
const ZL = XL;
function JL(e) {
  e = e || {};
  const t = new Vi();
  return (e.zoom !== void 0 ? e.zoom : !0) && t.push(new ZL(e.zoomOptions)), (e.rotate !== void 0 ? e.rotate : !0) && t.push(new YL(e.rotateOptions)), (e.attribution !== void 0 ? e.attribution : !0) && t.push(new kL(e.attributionOptions)), t;
}
const Dd = {
  ACTIVE: "active"
};
class QL extends Er {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Dd.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(t) {
    this.set(Dd.ACTIVE, t);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    this.map_ = t;
  }
}
function qL(e, t, n) {
  const s = e.getCenterInternal();
  if (s) {
    const r = [s[0] + t[0], s[1] + t[1]];
    e.animateInternal({
      duration: n !== void 0 ? n : 250,
      easing: FP,
      center: e.getConstrainedCenter(r)
    });
  }
}
function Ly(e, t, n, s) {
  const r = e.getZoom();
  if (r === void 0)
    return;
  const i = e.getConstrainedZoom(r + t), a = e.getResolutionForZoom(i);
  e.getAnimating() && e.cancelAnimations(), e.animate({
    resolution: a,
    anchor: n,
    duration: s !== void 0 ? s : 250,
    easing: Zo
  });
}
const uu = QL;
class tR extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Te.DBLCLICK) {
      const s = (
        /** @type {MouseEvent} */
        t.originalEvent
      ), r = t.map, i = t.coordinate, a = s.shiftKey ? -this.delta_ : this.delta_, o = r.getView();
      Ly(o, a, i, this.duration_), s.preventDefault(), n = !0;
    }
    return !n;
  }
}
const eR = tR;
class nR extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(t) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(t) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    if (!t.originalEvent)
      return !0;
    let n = !1;
    if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
      if (t.type == Te.POINTERDRAG)
        this.handleDragEvent(t), t.originalEvent.preventDefault();
      else if (t.type == Te.POINTERUP) {
        const s = this.handleUpEvent(t);
        this.handlingDownUpSequence = s && this.targetPointers.length > 0;
      }
    } else if (t.type == Te.POINTERDOWN) {
      const s = this.handleDownEvent(t);
      this.handlingDownUpSequence = s, n = this.stopDown(s);
    } else
      t.type == Te.POINTERMOVE && this.handleMoveEvent(t);
    return !n;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(t) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(t) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(t) {
    return t;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(t) {
    t.activePointers && (this.targetPointers = t.activePointers);
  }
}
function Ry(e) {
  const t = e.length;
  let n = 0, s = 0;
  for (let r = 0; r < t; r++)
    n += e[r].clientX, s += e[r].clientY;
  return [n / t, s / t];
}
const Jo = nR;
function Bg(e) {
  const t = arguments;
  return function(n) {
    let s = !0;
    for (let r = 0, i = t.length; r < i && (s = s && t[r](n), !!s); ++r)
      ;
    return s;
  };
}
const iR = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, rR = function(e) {
  const t = e.map.getTargetElement(), n = e.map.getOwnerDocument().activeElement;
  return t.contains(n);
}, WP = function(e) {
  return e.map.getTargetElement().hasAttribute("tabindex") ? rR(e) : !0;
}, Ad = ds, $P = function(e) {
  const t = (
    /** @type {MouseEvent} */
    e.originalEvent
  );
  return t.button == 0 && !($_ && BT && t.ctrlKey);
}, Ng = au, sR = function(e) {
  return e.type == "pointermove";
}, aR = function(e) {
  return e.type == Te.SINGLECLICK;
}, wy = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
}, oR = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && (BT ? t.metaKey : t.ctrlKey) && !t.shiftKey;
}, Vy = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, zP = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  ), n = (
    /** @type {Element} */
    t.target.tagName
  );
  return n !== "INPUT" && n !== "SELECT" && n !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !t.target.isContentEditable;
}, gp = function(e) {
  const t = (
    /** @type {import("../MapBrowserEvent").default} */
    e.originalEvent
  );
  return Zt(t !== void 0, 56), t.pointerType == "mouse";
}, lR = function(e) {
  const t = (
    /** @type {import("../MapBrowserEvent").default} */
    e.originalEvent
  );
  return Zt(t !== void 0, 56), t.isPrimary && t.button === 0;
};
class uR extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super({
      stopDown: au
    }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const n = t.condition ? t.condition : Bg(wy, lR);
    this.condition_ = t.onFocusOnly ? Bg(WP, n) : n, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    this.panning_ || (this.panning_ = !0, this.getMap().getView().beginInteraction());
    const n = this.targetPointers, s = Ry(n);
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(s[0], s[1]), this.lastCentroid) {
        const r = [
          this.lastCentroid[0] - s[0],
          s[1] - this.lastCentroid[1]
        ], a = t.map.getView();
        kT(r, a.getResolution()), Jv(r, a.getRotation()), a.adjustCenterInternal(r);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = s, this.lastPointersCount_ = n.length, t.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    const n = t.map, s = n.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const r = this.kinetic_.getDistance(), i = this.kinetic_.getAngle(), a = s.getCenterInternal(), o = n.getPixelFromCoordinateInternal(a), l = n.getCoordinateFromPixelInternal([
          o[0] - r * Math.cos(i),
          o[1] - r * Math.sin(i)
        ]);
        s.animateInternal({
          center: s.getConstrainedCenter(l),
          duration: 500,
          easing: Zo
        });
      }
      return this.panning_ && (this.panning_ = !1, s.endInteraction()), !1;
    } else
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length > 0 && this.condition_(t)) {
      const s = t.map.getView();
      return this.lastCentroid = null, s.getAnimating() && s.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    } else
      return !1;
  }
}
const Fg = uR;
class cR extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super({
      stopDown: au
    }), this.condition_ = t.condition ? t.condition : iR, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    if (!gp(t))
      return;
    const n = t.map, s = n.getView();
    if (s.getConstraints().rotation === Dy)
      return;
    const r = n.getSize(), i = t.pixel, a = Math.atan2(r[1] / 2 - i[1], i[0] - r[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const o = a - this.lastAngle_;
      s.adjustRotationInternal(-o);
    }
    this.lastAngle_ = a;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    return gp(t) ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return gp(t) && $P(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
const hR = cR;
class dR extends $v {
  /**
   * @param {string} className CSS class name.
   */
  constructor(t) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const t = this.startPixel_, n = this.endPixel_, s = "px", r = this.element_.style;
    r.left = Math.min(t[0], n[0]) + s, r.top = Math.min(t[1], n[1]) + s, r.width = Math.abs(n[0] - t[0]) + s, r.height = Math.abs(n[1] - t[1]) + s;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const n = this.element_.style;
      n.left = "inherit", n.top = "inherit", n.width = "inherit", n.height = "inherit";
    }
    this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(t, n) {
    this.startPixel_ = t, this.endPixel_ = n, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const t = this.startPixel_, n = this.endPixel_, r = [
      t,
      [t[0], n[1]],
      n,
      [n[0], t[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new nr([r]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const fR = dR, yh = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class vp extends Ui {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(t, n, s) {
    super(t), this.coordinate = n, this.mapBrowserEvent = s;
  }
}
class pR extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.box_ = new fR(t.className || "ol-dragbox"), this.minArea_ = t.minArea !== void 0 ? t.minArea : 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ? t.condition : $P, this.boxEndCondition_ = t.boxEndCondition ? t.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(t, n, s) {
    const r = s[0] - n[0], i = s[1] - n[1];
    return r * r + i * i >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(
      new vp(
        yh.BOXDRAG,
        t.coordinate,
        t
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    this.box_.setMap(null);
    const n = this.boxEndCondition_(
      t,
      this.startPixel_,
      t.pixel
    );
    return n && this.onBoxEnd(t), this.dispatchEvent(
      new vp(
        n ? yh.BOXEND : yh.BOXCANCEL,
        t.coordinate,
        t
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new vp(
        yh.BOXSTART,
        t.coordinate,
        t
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(t) {
  }
}
const mR = pR;
class gR extends mR {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = t.condition ? t.condition : Vy;
    super({
      condition: n,
      className: t.className || "ol-dragzoom",
      minArea: t.minArea
    }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(t) {
    const s = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let r = this.getGeometry();
    if (this.out_) {
      const i = s.rotatedExtentForGeometry(r), a = s.getResolutionForExtentInternal(i), o = s.getResolution() / a;
      r = r.clone(), r.scale(o * o);
    }
    s.fitInternal(r, {
      duration: this.duration_,
      easing: Zo
    });
  }
}
const vR = gR, lo = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
class yR extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.defaultCondition_ = function(n) {
      return wy(n) && zP(n);
    }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Kt.KEYDOWN) {
      const s = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = s.keyCode;
      if (this.condition_(t) && (r == lo.DOWN || r == lo.LEFT || r == lo.RIGHT || r == lo.UP)) {
        const a = t.map.getView(), o = a.getResolution() * this.pixelDelta_;
        let l = 0, f = 0;
        r == lo.DOWN ? f = -o : r == lo.LEFT ? l = -o : r == lo.RIGHT ? l = o : f = o;
        const d = [l, f];
        Jv(d, a.getRotation()), qL(a, d, this.duration_), s.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
const ER = yR;
class CR extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.condition_ = t.condition ? t.condition : zP, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Kt.KEYDOWN || t.type == Kt.KEYPRESS) {
      const s = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = s.charCode;
      if (this.condition_(t) && (r == "+".charCodeAt(0) || r == "-".charCodeAt(0))) {
        const i = t.map, a = r == "+".charCodeAt(0) ? this.delta_ : -this.delta_, o = i.getView();
        Ly(o, a, void 0, this.duration_), s.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
const xR = CR;
class bR extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : !0, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : !1;
    const n = t.condition ? t.condition : Ad;
    this.condition_ = t.onFocusOnly ? Bg(WP, n) : n, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const t = this.getMap();
    if (!t)
      return;
    t.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(t) {
    if (!this.condition_(t) || t.type !== Kt.WHEEL)
      return !0;
    const s = t.map, r = (
      /** @type {WheelEvent} */
      t.originalEvent
    );
    r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.coordinate);
    let i;
    if (t.type == Kt.WHEEL && (i = r.deltaY, U_ && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (i /= Ef), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (i *= 40)), i === 0)
      return !1;
    this.lastDelta_ = i;
    const a = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = a), (!this.mode_ || a - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(i) < 4 ? "trackpad" : "wheel");
    const o = s.getView();
    if (this.mode_ === "trackpad" && !(o.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), o.adjustZoom(-i / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = a, !1;
    this.totalDelta_ += i;
    const l = Math.max(this.timeout_ - (a - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, s),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(t) {
    const n = t.getView();
    n.getAnimating() && n.cancelAnimations();
    let s = -hn(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (n.getConstrainResolution() || this.constrainResolution_) && (s = s ? s > 0 ? 1 : -1 : 0), Ly(n, s, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(t) {
    this.useAnchor_ = t, t || (this.lastAnchor_ = null);
  }
}
const jg = bR;
class OR extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = au), super(n), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    let n = 0;
    const s = this.targetPointers[0], r = this.targetPointers[1], i = Math.atan2(
      r.clientY - s.clientY,
      r.clientX - s.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const d = i - this.lastAngle_;
      this.rotationDelta_ += d, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), n = d;
    }
    this.lastAngle_ = i;
    const a = t.map, o = a.getView();
    if (o.getConstraints().rotation === Dy)
      return;
    const l = a.getViewport().getBoundingClientRect(), f = Ry(this.targetPointers);
    f[0] -= l.left, f[1] -= l.top, this.anchor_ = a.getCoordinateFromPixelInternal(f), this.rotating_ && (a.render(), o.adjustRotationInternal(n, this.anchor_));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const n = t.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }
}
const TR = OR;
class PR extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = au), super(n), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    let n = 1;
    const s = this.targetPointers[0], r = this.targetPointers[1], i = s.clientX - r.clientX, a = s.clientY - r.clientY, o = Math.sqrt(i * i + a * a);
    this.lastDistance_ !== void 0 && (n = this.lastDistance_ / o), this.lastDistance_ = o;
    const l = t.map, f = l.getView();
    n != 1 && (this.lastScaleDelta_ = n);
    const d = l.getViewport().getBoundingClientRect(), u = Ry(this.targetPointers);
    u[0] -= d.left, u[1] -= d.top, this.anchor_ = l.getCoordinateFromPixelInternal(u), l.render(), f.adjustResolutionInternal(n, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    if (this.targetPointers.length < 2) {
      const s = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
      return s.endInteraction(this.duration_, r), !1;
    } else
      return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const n = t.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }
}
const MR = PR;
function By(e) {
  e = e || {};
  const t = new Vi(), n = new EL(-5e-3, 0.05, 100);
  return (e.altShiftDragRotate !== void 0 ? e.altShiftDragRotate : !0) && t.push(new hR()), (e.doubleClickZoom !== void 0 ? e.doubleClickZoom : !0) && t.push(
    new eR({
      delta: e.zoomDelta,
      duration: e.zoomDuration
    })
  ), (e.dragPan !== void 0 ? e.dragPan : !0) && t.push(
    new Fg({
      onFocusOnly: e.onFocusOnly,
      kinetic: n
    })
  ), (e.pinchRotate !== void 0 ? e.pinchRotate : !0) && t.push(new TR()), (e.pinchZoom !== void 0 ? e.pinchZoom : !0) && t.push(
    new MR({
      duration: e.zoomDuration
    })
  ), (e.keyboard !== void 0 ? e.keyboard : !0) && (t.push(new ER()), t.push(
    new xR({
      delta: e.zoomDelta,
      duration: e.zoomDuration
    })
  )), (e.mouseWheelZoom !== void 0 ? e.mouseWheelZoom : !0) && t.push(
    new jg({
      onFocusOnly: e.onFocusOnly,
      duration: e.zoomDuration
    })
  ), (e.shiftDragZoom !== void 0 ? e.shiftDragZoom : !0) && t.push(
    new vR({
      duration: e.zoomDuration
    })
  ), t;
}
function KP(e) {
  if (e instanceof lu) {
    e.setMapInternal(null);
    return;
  }
  e instanceof Wa && e.getLayers().forEach(KP);
}
function GP(e, t) {
  if (e instanceof lu) {
    e.setMapInternal(t);
    return;
  }
  if (e instanceof Wa) {
    const n = e.getLayers().getArray();
    for (let s = 0, r = n.length; s < r; ++s)
      GP(n[s], t);
  }
}
let SR = class extends Er {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(t) {
    super(), t = t || {}, this.on, this.once, this.un;
    const n = IR(t);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : Ef, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = Qi(), this.pixelToCoordinateTransform_ = Qi(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = n.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.controls = n.controls || JL(), this.interactions = n.interactions || By({
      onFocusOnly: !0
    }), this.overlays_ = n.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new LL(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      oi.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(oi.VIEW, this.handleViewChanged_), this.addChangeListener(oi.SIZE, this.handleSizeChanged_), this.addChangeListener(oi.TARGET, this.handleTargetChanged_), this.setProperties(n.values);
    const s = this;
    t.view && !(t.view instanceof ya) && t.view.then(function(r) {
      s.setView(new ya(r));
    }), this.controls.addEventListener(
      $n.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (function(r) {
        r.element.setMap(this);
      }).bind(this)
    ), this.controls.addEventListener(
      $n.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(null);
      }).bind(this)
    ), this.interactions.addEventListener(
      $n.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(this);
      }).bind(this)
    ), this.interactions.addEventListener(
      $n.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(null);
      }).bind(this)
    ), this.overlays_.addEventListener(
      $n.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (function(r) {
        this.addOverlayInternal_(r.element);
      }).bind(this)
    ), this.overlays_.addEventListener(
      $n.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (function(r) {
        const i = r.element.getId();
        i !== void 0 && delete this.overlayIdIndex_[i.toString()], r.element.setMap(null);
      }).bind(this)
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       * @this {Map}
       */
      (function(r) {
        r.setMap(this);
      }).bind(this)
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {Map}
       */
      (function(r) {
        r.setMap(this);
      }).bind(this)
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(t) {
    this.getControls().push(t);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(t) {
    this.getInteractions().push(t);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(t) {
    this.getLayerGroup().getLayers().push(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(t) {
    GP(t.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(t) {
    this.getOverlays().push(t);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(t) {
    const n = t.getId();
    n !== void 0 && (this.overlayIdIndex_[n.toString()] = t), t.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(t, n, s) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const r = this.getCoordinateFromPixelInternal(t);
    s = s !== void 0 ? s : {};
    const i = s.hitTolerance !== void 0 ? s.hitTolerance : 0, a = s.layerFilter !== void 0 ? s.layerFilter : ds, o = s.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      r,
      this.frameState_,
      i,
      o,
      n,
      null,
      a,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(t, n) {
    const s = [];
    return this.forEachFeatureAtPixel(
      t,
      function(r) {
        s.push(r);
      },
      n
    ), s;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const t = [];
    function n(s) {
      s.forEach(function(r) {
        r instanceof Wa ? n(r.getLayers()) : t.push(r);
      });
    }
    return n(this.getLayers()), t;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(t, n) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const s = this.getCoordinateFromPixelInternal(t);
    n = n !== void 0 ? n : {};
    const r = n.layerFilter !== void 0 ? n.layerFilter : ds, i = n.hitTolerance !== void 0 ? n.hitTolerance : 0, a = n.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      s,
      this.frameState_,
      i,
      a,
      r,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(t) {
    return this.getCoordinateFromPixel(this.getEventPixel(t));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(t) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(t) {
    const n = this.viewport_.getBoundingClientRect(), s = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in t ? (
        /** @type {TouchEvent} */
        t.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        t
      )
    );
    return [
      s.clientX - n.left,
      s.clientY - n.top
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(oi.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    const t = this.getTarget();
    return t !== void 0 ? typeof t == "string" ? document.getElementById(t) : t : null;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(t) {
    return Sg(
      this.getCoordinateFromPixelInternal(t),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(t) {
    const n = this.frameState_;
    return n ? An(
      n.pixelToCoordinateTransform,
      t.slice()
    ) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(t) {
    const n = this.overlayIdIndex_[t.toString()];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(oi.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(t) {
    const n = this.getLayerGroup();
    if (t instanceof Vi) {
      n.setLayers(t);
      return;
    }
    const s = n.getLayers();
    s.clear(), s.extend(t);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const t = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, s = t.length; n < s; ++n) {
      const r = t[n];
      if (!r.visible)
        continue;
      const i = r.layer.getRenderer();
      if (i && !i.ready)
        return !0;
      const a = r.layer.getSource();
      if (a && a.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(t) {
    const n = _r(
      t,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(n);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(t) {
    const n = this.frameState_;
    return n ? An(
      n.coordinateToPixelTransform,
      t.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(oi.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(oi.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const t = this.getTargetElement();
    return t ? t.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(t, n, s, r) {
    return RL(
      this.frameState_,
      t,
      n,
      s,
      r
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(t, n) {
    n = n || t.type;
    const s = new ws(n, this, t);
    this.handleMapBrowserEvent(s);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(t) {
    if (!this.frameState_)
      return;
    const n = (
      /** @type {PointerEvent} */
      t.originalEvent
    ), s = n.type;
    if (s === Vg.POINTERDOWN || s === Kt.WHEEL || s === Kt.KEYDOWN) {
      const r = this.getOwnerDocument(), i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, a = (
        /** @type {Node} */
        n.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(a) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(i === r ? r.documentElement : i).contains(a)
      )
        return;
    }
    if (t.frameState = this.frameState_, this.dispatchEvent(t) !== !1) {
      const r = this.getInteractions().getArray().slice();
      for (let i = r.length - 1; i >= 0; i--) {
        const a = r[i];
        if (a.getMap() !== this || !a.getActive() || !this.getTargetElement())
          continue;
        if (!a.handleEvent(t) || t.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const t = this.frameState_, n = this.tileQueue_;
    if (!n.isEmpty()) {
      let r = this.maxTilesLoading_, i = r;
      if (t) {
        const a = t.viewHints;
        if (a[tn.ANIMATING] || a[tn.INTERACTING]) {
          const o = Date.now() - t.time > 8;
          r = o ? 0 : 8, i = o ? 0 : 2;
        }
      }
      n.getTilesLoading() < r && (n.reprioritize(), n.loadMoreTiles(r, i));
    }
    t && this.renderer_ && !t.animate && (this.renderComplete_ === !0 ? (this.hasListener(Aa.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Aa.RENDERCOMPLETE,
      t
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new vl(Vs.LOADEND, this, t)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new vl(Vs.LOADSTART, this, t)
    )));
    const s = this.postRenderFunctions_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r](this, t);
    s.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, s = this.targetChangeHandlerKeys_.length; n < s; ++n)
        We(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        Kt.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        Kt.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, xd(this.viewport_);
    }
    const t = this.getTargetElement();
    if (!t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new TL(this)), this.mapBrowserEventHandler_ = new IL(
        this,
        this.moveTolerance_
      );
      for (const r in Te)
        this.mapBrowserEventHandler_.addEventListener(
          Te[r],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        Kt.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        Kt.WHEEL,
        this.boundHandleBrowserEvent_,
        NT ? { passive: !1 } : !1
      );
      const n = this.getOwnerDocument().defaultView, s = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        ge(
          s,
          Kt.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        ge(
          s,
          Kt.KEYPRESS,
          this.handleBrowserEvent,
          this
        ),
        ge(n, Kt.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (We(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (We(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const t = this.getView();
    t && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = ge(
      t,
      Hl.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = ge(
      t,
      Kt.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), t.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(We), this.layerGroupPropertyListenerKeys_ = null);
    const t = this.getLayerGroup();
    t && (this.handleLayerAdd_(new va("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [
      ge(t, Hl.PROPERTYCHANGE, this.render, this),
      ge(t, Kt.CHANGE, this.render, this),
      ge(t, "addlayer", this.handleLayerAdd_, this),
      ge(t, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const t = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, s = t.length; n < s; ++n) {
      const r = t[n].layer;
      r.hasRenderer() && r.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(t) {
    return this.getControls().remove(t);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(t) {
    return this.getInteractions().remove(t);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(t) {
    return this.getLayerGroup().getLayers().remove(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(t) {
    KP(t.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(t) {
    return this.getOverlays().remove(t);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(t) {
    const n = this.getSize(), s = this.getView(), r = this.frameState_;
    let i = null;
    if (n !== void 0 && WE(n) && s && s.isDef()) {
      const a = s.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), o = s.getState();
      if (i = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: Nl(
          o.center,
          o.resolution,
          o.rotation,
          n
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: n,
        tileQueue: this.tileQueue_,
        time: t,
        usedTiles: {},
        viewState: o,
        viewHints: a,
        wantedTiles: {},
        mapId: Xt(this),
        renderTargets: {}
      }, o.nextCenter && o.nextResolution) {
        const l = isNaN(o.nextRotation) ? o.rotation : o.nextRotation;
        i.nextExtent = Nl(
          o.nextCenter,
          o.nextResolution,
          l,
          n
        );
      }
    }
    this.frameState_ = i, this.renderer_.renderFrame(i), i && (i.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      i.postRenderFunctions
    ), r && (!this.previousExtent_ || !bf(this.previousExtent_) && !wo(i.extent, this.previousExtent_)) && (this.dispatchEvent(
      new vl(Vs.MOVESTART, this, r)
    ), this.previousExtent_ = Bc(this.previousExtent_)), this.previousExtent_ && !i.viewHints[tn.ANIMATING] && !i.viewHints[tn.INTERACTING] && !wo(i.extent, this.previousExtent_) && (this.dispatchEvent(
      new vl(Vs.MOVEEND, this, i)
    ), jT(i.extent, this.previousExtent_))), this.dispatchEvent(new vl(Vs.POSTRENDER, this, i)), this.renderComplete_ = this.hasListener(Vs.LOADSTART) || this.hasListener(Vs.LOADEND) || this.hasListener(Aa.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(t) {
    const n = this.getLayerGroup();
    n && this.handleLayerRemove_(new va("removelayer", n)), this.set(oi.LAYERGROUP, t);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(t) {
    this.set(oi.SIZE, t);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(t) {
    this.set(oi.TARGET, t);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(t) {
    if (!t || t instanceof ya) {
      this.set(oi.VIEW, t);
      return;
    }
    this.set(oi.VIEW, new ya());
    const n = this;
    t.then(function(s) {
      n.setView(new ya(s));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const t = this.getTargetElement();
    let n;
    if (t) {
      const s = getComputedStyle(t), r = t.offsetWidth - parseFloat(s.borderLeftWidth) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) - parseFloat(s.borderRightWidth), i = t.offsetHeight - parseFloat(s.borderTopWidth) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) - parseFloat(s.borderBottomWidth);
      !isNaN(r) && !isNaN(i) && (n = [r, i], !WE(n) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && console.warn(
        "No map visible because the map container's width or height are 0."
      ));
    }
    this.setSize(n), this.updateViewportSize_();
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */
  updateViewportSize_() {
    const t = this.getView();
    if (t) {
      let n;
      const s = getComputedStyle(this.viewport_);
      s.width && s.height && (n = [
        parseInt(s.width, 10),
        parseInt(s.height, 10)
      ]), t.setViewportSize(n);
    }
  }
};
function IR(e) {
  let t = null;
  e.keyboardEventTarget !== void 0 && (t = typeof e.keyboardEventTarget == "string" ? document.getElementById(e.keyboardEventTarget) : e.keyboardEventTarget);
  const n = {}, s = e.layers && typeof /** @type {?} */
  e.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    e.layers
  ) : new Wa({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      e.layers
    )
  });
  n[oi.LAYERGROUP] = s, n[oi.TARGET] = e.target, n[oi.VIEW] = e.view instanceof ya ? e.view : new ya();
  let r;
  e.controls !== void 0 && (Array.isArray(e.controls) ? r = new Vi(e.controls.slice()) : (Zt(
    typeof /** @type {?} */
    e.controls.getArray == "function",
    47
  ), r = e.controls));
  let i;
  e.interactions !== void 0 && (Array.isArray(e.interactions) ? i = new Vi(e.interactions.slice()) : (Zt(
    typeof /** @type {?} */
    e.interactions.getArray == "function",
    48
  ), i = e.interactions));
  let a;
  return e.overlays !== void 0 ? Array.isArray(e.overlays) ? a = new Vi(e.overlays.slice()) : (Zt(
    typeof /** @type {?} */
    e.overlays.getArray == "function",
    49
  ), a = e.overlays) : a = new Vi(), {
    controls: r,
    interactions: i,
    keyboardEventTarget: t,
    overlays: a,
    values: n
  };
}
const Xs = SR, ai = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class _R extends Er {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : !0, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : !0, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + JD, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === !0 ? {} : t.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(ai.ELEMENT, this.handleElementChanged), this.addChangeListener(ai.MAP, this.handleMapChanged), this.addChangeListener(ai.OFFSET, this.handleOffsetChanged), this.addChangeListener(ai.POSITION, this.handlePositionChanged), this.addChangeListener(ai.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(ai.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(ai.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(ai.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ai.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(ai.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    mP(this.element);
    const t = this.getElement();
    t && this.element.appendChild(t);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (xd(this.element), We(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const t = this.getMap();
    if (t) {
      this.mapPostrenderListenerKey = ge(
        t,
        Vs.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const n = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
      this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(t) {
    this.set(ai.ELEMENT, t);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(t) {
    this.set(ai.MAP, t);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(t) {
    this.set(ai.OFFSET, t);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(t) {
    this.set(ai.POSITION, t);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(t) {
    const n = this.getMap();
    if (!n || !n.getTargetElement() || !this.get(ai.POSITION))
      return;
    const s = this.getRect(n.getTargetElement(), n.getSize()), r = this.getElement(), i = this.getRect(r, [
      YD(r),
      XD(r)
    ]);
    t = t || {};
    const a = t.margin === void 0 ? 20 : t.margin;
    if (!Ar(s, i)) {
      const o = i[0] - s[0], l = s[2] - i[2], f = i[1] - s[1], d = s[3] - i[3], u = [0, 0];
      if (o < 0 ? u[0] = o - a : l < 0 && (u[0] = Math.abs(l) + a), f < 0 ? u[1] = f - a : d < 0 && (u[1] = Math.abs(d) + a), u[0] !== 0 || u[1] !== 0) {
        const c = (
          /** @type {import("./coordinate.js").Coordinate} */
          n.getView().getCenterInternal()
        ), h = n.getPixelFromCoordinateInternal(c);
        if (!h)
          return;
        const p = [h[0] + u[0], h[1] + u[1]], g = t.animation || {};
        n.getView().animateInternal({
          center: n.getCoordinateFromPixelInternal(p),
          duration: g.duration,
          easing: g.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(t, n) {
    const s = t.getBoundingClientRect(), r = s.left + window.pageXOffset, i = s.top + window.pageYOffset;
    return [r, i, r + n[0], i + n[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(t) {
    this.set(ai.POSITIONING, t);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(t) {
    this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const t = this.getMap(), n = this.getPosition();
    if (!t || !t.isRendered() || !n) {
      this.setVisible(!1);
      return;
    }
    const s = t.getPixelFromCoordinate(n), r = t.getSize();
    this.updateRenderedPosition(s, r);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(t, n) {
    const s = this.element.style, r = this.getOffset(), i = this.getPositioning();
    this.setVisible(!0);
    const a = Math.round(t[0] + r[0]) + "px", o = Math.round(t[1] + r[1]) + "px";
    let l = "0%", f = "0%";
    i == "bottom-right" || i == "center-right" || i == "top-right" ? l = "-100%" : (i == "bottom-center" || i == "center-center" || i == "top-center") && (l = "-50%"), i == "bottom-left" || i == "bottom-center" || i == "bottom-right" ? f = "-100%" : (i == "center-left" || i == "center-center" || i == "center-right") && (f = "-50%");
    const d = `translate(${l}, ${f}) translate(${a}, ${o})`;
    this.rendered.transform_ != d && (this.rendered.transform_ = d, s.transform = d);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const kP = _R;
class DR {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(t) {
    this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(t) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(t) {
    return this.entries_.hasOwnProperty(t);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(t) {
    let n = this.oldest_;
    for (; n; )
      t(n.value_, n.key_, this), n = n.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(t, n) {
    const s = this.entries_[t];
    return Zt(s !== void 0, 15), s === this.newest_ || (s === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (s.newer.older = s.older, s.older.newer = s.newer), s.newer = null, s.older = this.newest_, this.newest_.newer = s, this.newest_ = s), s.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(t) {
    const n = this.entries_[t];
    return Zt(n !== void 0, 15), n === this.newest_ ? (this.newest_ = /** @type {Entry} */
    n.older, this.newest_ && (this.newest_.newer = null)) : n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    n.newer, this.oldest_ && (this.oldest_.older = null)) : (n.newer.older = n.older, n.older.newer = n.newer), delete this.entries_[t], --this.count_, n.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const t = new Array(this.count_);
    let n = 0, s;
    for (s = this.newest_; s; s = s.older)
      t[n++] = s.key_;
    return t;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const t = new Array(this.count_);
    let n = 0, s;
    for (s = this.newest_; s; s = s.older)
      t[n++] = s.value_;
    return t;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(t) {
    if (this.containsKey(t))
      return this.entries_[t].value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const t = this.oldest_;
    return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(t, n) {
    this.get(t), this.entries_[t].value_ = n;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(t, n) {
    Zt(!(t in this.entries_), 16);
    const s = {
      key_: t,
      newer: null,
      older: this.newest_,
      value_: n
    };
    this.newest_ ? this.newest_.newer = s : this.oldest_ = s, this.newest_ = s, this.entries_[t] = s, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(t) {
    this.highWaterMark = t;
  }
}
const Ug = DR;
function uC(e, t, n, s) {
  return s !== void 0 ? (s[0] = e, s[1] = t, s[2] = n, s) : [e, t, n];
}
function cu(e, t, n) {
  return e + "/" + t + "/" + n;
}
function HP(e) {
  return cu(e[0], e[1], e[2]);
}
function AR(e) {
  const [t, n, s] = e.substring(e.lastIndexOf("/") + 1, e.length).split(",").map(Number);
  return cu(t, n, s);
}
function YP(e) {
  return e.split("/").map(Number);
}
function XP(e) {
  return (e[1] << e[0]) + e[2];
}
function LR(e, t) {
  const n = e[0], s = e[1], r = e[2];
  if (t.getMinZoom() > n || n > t.getMaxZoom())
    return !1;
  const i = t.getFullTileRange(n);
  return i ? i.containsXY(s, r) : !0;
}
class RR extends Ug {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in t); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const t = this.peekFirstKey(), s = YP(t)[0];
    this.forEach(
      (function(r) {
        r.tileCoord[0] !== s && (this.remove(HP(r.tileCoord)), r.release());
      }).bind(this)
    );
  }
}
const Ny = RR;
class ZP {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(t, n, s, r) {
    this.minX = t, this.maxX = n, this.minY = s, this.maxY = r;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(t) {
    return this.containsXY(t[1], t[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(t) {
    return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(t, n) {
    return this.minX <= t && t <= this.maxX && this.minY <= n && n <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(t) {
    return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(t) {
    t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(t) {
    return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
  }
}
function ol(e, t, n, s, r) {
  return r !== void 0 ? (r.minX = e, r.maxX = t, r.minY = n, r.maxY = s, r) : new ZP(e, t, n, s);
}
const JP = ZP, cC = [];
class wR extends Df {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  constructor(t, n, s, r) {
    super(t, n, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.declutterExecutorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = r.bind(void 0, this), this.wrappedTileCoord = s;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  getContext(t) {
    const n = Xt(t);
    return n in this.context_ || (this.context_[n] = Ii(1, 1, cC)), this.context_[n];
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */
  hasContext(t) {
    return Xt(t) in this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage(t) {
    return this.hasContext(t) ? this.getContext(t).canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(t) {
    const n = Xt(t);
    return n in this.replayState_ || (this.replayState_[n] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[n];
  }
  /**
   * Load the tile.
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    for (const t in this.context_) {
      const n = this.context_[t];
      gy(n), cC.push(n.canvas), delete this.context_[t];
    }
    super.release();
  }
}
const VR = wR;
let BR = class extends Df {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, a), this.extent = null, this.format_ = r, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = i, this.url_ = s, this.key = s;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == It.IDLE && (this.setState(It.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(t, n) {
    this.setFeatures(t);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(It.ERROR);
  }
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */
  setFeatures(t) {
    this.features_ = t, this.setState(It.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
};
const NR = BR, fi = {
  target: "map",
  epsg: "EPSG:25832",
  backgroundImage: "",
  extent: [51e4, 585e4, 625000.4, 6e6],
  options: [
    { resolution: 66.14579761460263, scale: 25e4, zoomLevel: 0 },
    { resolution: 26.458319045841044, scale: 1e5, zoomLevel: 1 },
    { resolution: 15.874991427504629, scale: 6e4, zoomLevel: 2 },
    { resolution: 10.583327618336419, scale: 4e4, zoomLevel: 3 },
    { resolution: 5.2916638091682096, scale: 2e4, zoomLevel: 4 },
    { resolution: 2.6458319045841048, scale: 1e4, zoomLevel: 5 },
    { resolution: 1.3229159522920524, scale: 5e3, zoomLevel: 6 },
    { resolution: 0.6614579761460262, scale: 2500, zoomLevel: 7 },
    { resolution: 0.2645831904584105, scale: 1e3, zoomLevel: 8 },
    { resolution: 0.1322915952292052, scale: 500, zoomLevel: 9 }
  ],
  namedProjections: [
    ["EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"]
  ],
  startResolution: 15.874991427504629,
  startCenter: [565874, 5934140],
  layerConf: "https://geodienste.hamburg.de/services-internet.json",
  layers: [
    {
      id: "453",
      visibility: !0
    }
  ],
  gazetteerUrl: "https://geodienste.hamburg.de/HH_WFS_GAGES?service=WFS&request=GetFeature&version=2.0.0",
  showGeographicIdentifier: !1,
  sceneOptions: {
    camera: {
      enableTerrainAdjustmentWhenLoading: !0
    },
    globe: {
      depthTestAgainstTerrain: !0
      // is necessary for scene.pickedPosition and correct height of the terrain. @see {https://github.com/CesiumGS/cesium/issues/5676}
    },
    highDynamicRange: !1,
    pickTranslucentDepth: !0,
    shadowMap: {
      darkness: 0.6,
      maximumDistance: 5e3,
      size: 2048
    },
    shadows: !1
  }
};
function FR(e = {}, t = fi) {
  const n = {
    startZoomLevel: void 0,
    startResolution: void 0
  };
  return Object.prototype.hasOwnProperty.call(e, "startZoomLevel") && !Object.prototype.hasOwnProperty.call(e, "startResolution") ? n.startZoomLevel = t.startZoomLevel : n.startResolution = t.startResolution, n;
}
function QP(e) {
  const t = Object.assign({}, fi, e), n = FR(e, t);
  return new ya({
    projection: t.epsg,
    center: t.startCenter,
    extent: t.extent,
    zoom: n.startZoomLevel,
    options: t.options,
    resolution: n.startResolution,
    resolutions: t.options.map((s) => s.resolution),
    constrainResolution: !0,
    constrainOnlyCenter: !0,
    backgroundImage: t.backgroundImage
  });
}
function jR(e) {
  e("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), e("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), e("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), e.WGS84 = e["EPSG:4326"], e["EPSG:3785"] = e["EPSG:3857"], e.GOOGLE = e["EPSG:3857"], e["EPSG:900913"] = e["EPSG:3857"], e["EPSG:102113"] = e["EPSG:3857"];
}
var Vo = 1, Bo = 2, jl = 3, UR = 4, Wg = 5, hC = 6378137, WR = 6356752314e-3, dC = 0.0066943799901413165, tc = 484813681109536e-20, xt = Math.PI / 2, $R = 0.16666666666666666, zR = 0.04722222222222222, KR = 0.022156084656084655, Dt = 1e-10, Qn = 0.017453292519943295, ls = 57.29577951308232, _e = Math.PI / 4, mc = Math.PI * 2, Mn = 3.14159265359, Wi = {};
Wi.greenwich = 0;
Wi.lisbon = -9.131906111111;
Wi.paris = 2.337229166667;
Wi.bogota = -74.080916666667;
Wi.madrid = -3.687938888889;
Wi.rome = 12.452333333333;
Wi.bern = 7.439583333333;
Wi.jakarta = 106.807719444444;
Wi.ferro = -17.666666666667;
Wi.brussels = 4.367975;
Wi.stockholm = 18.058277777778;
Wi.athens = 23.7163375;
Wi.oslo = 10.722916666667;
const GR = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var fC = /[\s_\-\/\(\)]/g;
function $a(e, t) {
  if (e[t])
    return e[t];
  for (var n = Object.keys(e), s = t.toLowerCase().replace(fC, ""), r = -1, i, a; ++r < n.length; )
    if (i = n[r], a = i.toLowerCase().replace(fC, ""), a === s)
      return e[i];
}
function $g(e) {
  var t = {}, n = e.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, l) {
    var f = l.split("=");
    return f.push(!0), o[f[0].toLowerCase()] = f[1], o;
  }, {}), s, r, i, a = {
    proj: "projName",
    datum: "datumCode",
    rf: function(o) {
      t.rf = parseFloat(o);
    },
    lat_0: function(o) {
      t.lat0 = o * Qn;
    },
    lat_1: function(o) {
      t.lat1 = o * Qn;
    },
    lat_2: function(o) {
      t.lat2 = o * Qn;
    },
    lat_ts: function(o) {
      t.lat_ts = o * Qn;
    },
    lon_0: function(o) {
      t.long0 = o * Qn;
    },
    lon_1: function(o) {
      t.long1 = o * Qn;
    },
    lon_2: function(o) {
      t.long2 = o * Qn;
    },
    alpha: function(o) {
      t.alpha = parseFloat(o) * Qn;
    },
    gamma: function(o) {
      t.rectified_grid_angle = parseFloat(o);
    },
    lonc: function(o) {
      t.longc = o * Qn;
    },
    x_0: function(o) {
      t.x0 = parseFloat(o);
    },
    y_0: function(o) {
      t.y0 = parseFloat(o);
    },
    k_0: function(o) {
      t.k0 = parseFloat(o);
    },
    k: function(o) {
      t.k0 = parseFloat(o);
    },
    a: function(o) {
      t.a = parseFloat(o);
    },
    b: function(o) {
      t.b = parseFloat(o);
    },
    r_a: function() {
      t.R_A = !0;
    },
    zone: function(o) {
      t.zone = parseInt(o, 10);
    },
    south: function() {
      t.utmSouth = !0;
    },
    towgs84: function(o) {
      t.datum_params = o.split(",").map(function(l) {
        return parseFloat(l);
      });
    },
    to_meter: function(o) {
      t.to_meter = parseFloat(o);
    },
    units: function(o) {
      t.units = o;
      var l = $a(GR, o);
      l && (t.to_meter = l.to_meter);
    },
    from_greenwich: function(o) {
      t.from_greenwich = o * Qn;
    },
    pm: function(o) {
      var l = $a(Wi, o);
      t.from_greenwich = (l || parseFloat(o)) * Qn;
    },
    nadgrids: function(o) {
      o === "@null" ? t.datumCode = "none" : t.nadgrids = o;
    },
    axis: function(o) {
      var l = "ewnsud";
      o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (t.axis = o);
    },
    approx: function() {
      t.approx = !0;
    }
  };
  for (s in n)
    r = n[s], s in a ? (i = a[s], typeof i == "function" ? i(r) : t[i] = r) : t[s] = r;
  return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
}
var gc = 1, qP = 2, t1 = 3, Ld = 4, e1 = 5, Fy = -1, kR = /\s/, HR = /[A-Za-z]/, YR = /[A-Za-z84_]/, Af = /[,\]]/, n1 = /[\d\.E\-\+]/;
function ia(e) {
  if (typeof e != "string")
    throw new Error("not a string");
  this.text = e.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = gc;
}
ia.prototype.readCharicter = function() {
  var e = this.text[this.place++];
  if (this.state !== Ld)
    for (; kR.test(e); ) {
      if (this.place >= this.text.length)
        return;
      e = this.text[this.place++];
    }
  switch (this.state) {
    case gc:
      return this.neutral(e);
    case qP:
      return this.keyword(e);
    case Ld:
      return this.quoted(e);
    case e1:
      return this.afterquote(e);
    case t1:
      return this.number(e);
    case Fy:
      return;
  }
};
ia.prototype.afterquote = function(e) {
  if (e === '"') {
    this.word += '"', this.state = Ld;
    return;
  }
  if (Af.test(e)) {
    this.word = this.word.trim(), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in afterquote yet, index ' + this.place);
};
ia.prototype.afterItem = function(e) {
  if (e === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = gc;
    return;
  }
  if (e === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = gc, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Fy);
    return;
  }
};
ia.prototype.number = function(e) {
  if (n1.test(e)) {
    this.word += e;
    return;
  }
  if (Af.test(e)) {
    this.word = parseFloat(this.word), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in number yet, index ' + this.place);
};
ia.prototype.quoted = function(e) {
  if (e === '"') {
    this.state = e1;
    return;
  }
  this.word += e;
};
ia.prototype.keyword = function(e) {
  if (YR.test(e)) {
    this.word += e;
    return;
  }
  if (e === "[") {
    var t = [];
    t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = gc;
    return;
  }
  if (Af.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in keyword yet, index ' + this.place);
};
ia.prototype.neutral = function(e) {
  if (HR.test(e)) {
    this.word = e, this.state = qP;
    return;
  }
  if (e === '"') {
    this.word = "", this.state = Ld;
    return;
  }
  if (n1.test(e)) {
    this.word = e, this.state = t1;
    return;
  }
  if (Af.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in neutral yet, index ' + this.place);
};
ia.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Fy)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function XR(e) {
  var t = new ia(e);
  return t.output();
}
function pC(e, t, n) {
  Array.isArray(t) && (n.unshift(t), t = null);
  var s = t ? {} : e, r = n.reduce(function(i, a) {
    return Pl(a, i), i;
  }, s);
  t && (e[t] = r);
}
function Pl(e, t) {
  if (!Array.isArray(e)) {
    t[e] = !0;
    return;
  }
  var n = e.shift();
  if (n === "PARAMETER" && (n = e.shift()), e.length === 1) {
    if (Array.isArray(e[0])) {
      t[n] = {}, Pl(e[0], t[n]);
      return;
    }
    t[n] = e[0];
    return;
  }
  if (!e.length) {
    t[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    t[n] = e;
    return;
  }
  if (n === "AXIS") {
    n in t || (t[n] = []), t[n].push(e);
    return;
  }
  Array.isArray(n) || (t[n] = {});
  var s;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      t[n] = {
        name: e[0].toLowerCase(),
        convert: e[1]
      }, e.length === 3 && Pl(e[2], t[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      t[n] = {
        name: e[0],
        a: e[1],
        rf: e[2]
      }, e.length === 4 && Pl(e[3], t[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      e[0] = ["name", e[0]], pC(t, n, e);
      return;
    default:
      for (s = -1; ++s < e.length; )
        if (!Array.isArray(e[s]))
          return Pl(e, t[n]);
      return pC(t, n, e);
  }
}
var ZR = 0.017453292519943295;
function JR(e, t) {
  var n = t[0], s = t[1];
  !(n in e) && s in e && (e[n] = e[s], t.length === 3 && (e[n] = t[2](e[n])));
}
function is(e) {
  return e * ZR;
}
function QR(e) {
  if (e.type === "GEOGCS" ? e.projName = "longlat" : e.type === "LOCAL_CS" ? (e.projName = "identity", e.local = !0) : typeof e.PROJECTION == "object" ? e.projName = Object.keys(e.PROJECTION)[0] : e.projName = e.PROJECTION, e.AXIS) {
    for (var t = "", n = 0, s = e.AXIS.length; n < s; ++n) {
      var r = [e.AXIS[n][0].toLowerCase(), e.AXIS[n][1].toLowerCase()];
      r[0].indexOf("north") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "north" ? t += "n" : r[0].indexOf("south") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "south" ? t += "s" : r[0].indexOf("east") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "east" ? t += "e" : (r[0].indexOf("west") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "west") && (t += "w");
    }
    t.length === 2 && (t += "u"), t.length === 3 && (e.axis = t);
  }
  e.UNIT && (e.units = e.UNIT.name.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.UNIT.convert && (e.type === "GEOGCS" ? e.DATUM && e.DATUM.SPHEROID && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a) : e.to_meter = e.UNIT.convert));
  var i = e.GEOGCS;
  e.type === "GEOGCS" && (i = e), i && (i.DATUM ? e.datumCode = i.DATUM.name.toLowerCase() : e.datumCode = i.name.toLowerCase(), e.datumCode.slice(0, 2) === "d_" && (e.datumCode = e.datumCode.slice(2)), (e.datumCode === "new_zealand_geodetic_datum_1949" || e.datumCode === "new_zealand_1949") && (e.datumCode = "nzgd49"), (e.datumCode === "wgs_1984" || e.datumCode === "world_geodetic_system_1984") && (e.PROJECTION === "Mercator_Auxiliary_Sphere" && (e.sphere = !0), e.datumCode = "wgs84"), e.datumCode.slice(-6) === "_ferro" && (e.datumCode = e.datumCode.slice(0, -6)), e.datumCode.slice(-8) === "_jakarta" && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge") && (e.datumCode = "rnb72"), i.DATUM && i.DATUM.SPHEROID && (e.ellps = i.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), e.ellps.toLowerCase().slice(0, 13) === "international" && (e.ellps = "intl"), e.a = i.DATUM.SPHEROID.a, e.rf = parseFloat(i.DATUM.SPHEROID.rf, 10)), i.DATUM && i.DATUM.TOWGS84 && (e.datum_params = i.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936") && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952") && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf("geodetic_datum_of_1965")) && (e.datumCode = "ire65"), e.datumCode === "ch1903+" && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel") && (e.datumCode = "isr93")), e.b && !isFinite(e.b) && (e.b = e.a);
  function a(f) {
    var d = e.to_meter || 1;
    return f * d;
  }
  var o = function(f) {
    return JR(e, f);
  }, l = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", is],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", is],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", is],
    ["lat0", "latitude_of_origin", is],
    ["lat0", "standard_parallel_1", is],
    ["lat1", "standard_parallel_1", is],
    ["lat2", "standard_parallel_2", is],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", is],
    ["srsCode", "name"]
  ];
  l.forEach(o), !e.long0 && e.longc && (e.projName === "Albers_Conic_Equal_Area" || e.projName === "Lambert_Azimuthal_Equal_Area") && (e.long0 = e.longc), !e.lat_ts && e.lat1 && (e.projName === "Stereographic_South_Pole" || e.projName === "Polar Stereographic (variant B)") ? (e.lat0 = is(e.lat1 > 0 ? 90 : -90), e.lat_ts = e.lat1) : !e.lat_ts && e.lat0 && e.projName === "Polar_Stereographic" && (e.lat_ts = e.lat0, e.lat0 = is(e.lat0 > 0 ? 90 : -90));
}
function i1(e) {
  var t = XR(e), n = t.shift(), s = t.shift();
  t.unshift(["name", s]), t.unshift(["type", n]);
  var r = {};
  return Pl(t, r), QR(r), r;
}
function Oi(e) {
  var t = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Oi[e] = $g(arguments[1]) : Oi[e] = i1(arguments[1]) : Oi[e] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(e))
      return e.map(function(s) {
        Array.isArray(s) ? Oi.apply(t, s) : Oi(s);
      });
    if (typeof e == "string") {
      if (e in Oi)
        return Oi[e];
    } else
      "EPSG" in e ? Oi["EPSG:" + e.EPSG] = e : "ESRI" in e ? Oi["ESRI:" + e.ESRI] = e : "IAU2000" in e ? Oi["IAU2000:" + e.IAU2000] = e : console.log(e);
    return;
  }
}
jR(Oi);
function qR(e) {
  return typeof e == "string";
}
function tw(e) {
  return e in Oi;
}
var ew = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function nw(e) {
  return ew.some(function(t) {
    return e.indexOf(t) > -1;
  });
}
var iw = ["3857", "900913", "3785", "102113"];
function rw(e) {
  var t = $a(e, "authority");
  if (t) {
    var n = $a(t, "epsg");
    return n && iw.indexOf(n) > -1;
  }
}
function sw(e) {
  var t = $a(e, "extension");
  if (t)
    return $a(t, "proj4");
}
function aw(e) {
  return e[0] === "+";
}
function ow(e) {
  if (qR(e)) {
    if (tw(e))
      return Oi[e];
    if (nw(e)) {
      var t = i1(e);
      if (rw(t))
        return Oi["EPSG:3857"];
      var n = sw(t);
      return n ? $g(n) : t;
    }
    if (aw(e))
      return $g(e);
  } else
    return e;
}
function mC(e, t) {
  e = e || {};
  var n, s;
  if (!t)
    return e;
  for (s in t)
    n = t[s], n !== void 0 && (e[s] = n);
  return e;
}
function ps(e, t, n) {
  var s = e * t;
  return n / Math.sqrt(1 - s * s);
}
function Wc(e) {
  return e < 0 ? -1 : 1;
}
function Bt(e) {
  return Math.abs(e) <= Mn ? e : e - Wc(e) * mc;
}
function Vr(e, t, n) {
  var s = e * n, r = 0.5 * e;
  return s = Math.pow((1 - s) / (1 + s), r), Math.tan(0.5 * (xt - t)) / s;
}
function vc(e, t) {
  for (var n = 0.5 * e, s, r, i = xt - 2 * Math.atan(t), a = 0; a <= 15; a++)
    if (s = e * Math.sin(i), r = xt - 2 * Math.atan(t * Math.pow((1 - s) / (1 + s), n)) - i, i += r, Math.abs(r) <= 1e-10)
      return i;
  return -9999;
}
function lw() {
  var e = this.b / this.a;
  this.es = 1 - e * e, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ps(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function uw(e) {
  var t = e.x, n = e.y;
  if (n * ls > 90 && n * ls < -90 && t * ls > 180 && t * ls < -180)
    return null;
  var s, r;
  if (Math.abs(Math.abs(n) - xt) <= Dt)
    return null;
  if (this.sphere)
    s = this.x0 + this.a * this.k0 * Bt(t - this.long0), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(_e + 0.5 * n));
  else {
    var i = Math.sin(n), a = Vr(this.e, n, i);
    s = this.x0 + this.a * this.k0 * Bt(t - this.long0), r = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return e.x = s, e.y = r, e;
}
function cw(e) {
  var t = e.x - this.x0, n = e.y - this.y0, s, r;
  if (this.sphere)
    r = xt - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var i = Math.exp(-n / (this.a * this.k0));
    if (r = vc(this.e, i), r === -9999)
      return null;
  }
  return s = Bt(this.long0 + t / (this.a * this.k0)), e.x = s, e.y = r, e;
}
var hw = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const dw = {
  init: lw,
  forward: uw,
  inverse: cw,
  names: hw
};
function fw() {
}
function gC(e) {
  return e;
}
var pw = ["longlat", "identity"];
const mw = {
  init: fw,
  forward: gC,
  inverse: gC,
  names: pw
};
var gw = [dw, mw], rd = {}, Rd = [];
function r1(e, t) {
  var n = Rd.length;
  return e.names ? (Rd[n] = e, e.names.forEach(function(s) {
    rd[s.toLowerCase()] = n;
  }), this) : (console.log(t), !0);
}
function vw(e) {
  if (!e)
    return !1;
  var t = e.toLowerCase();
  if (typeof rd[t] < "u" && Rd[rd[t]])
    return Rd[rd[t]];
}
function yw() {
  gw.forEach(r1);
}
const Ew = {
  start: yw,
  add: r1,
  get: vw
};
var ee = {};
ee.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
ee.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
ee.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
ee.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
ee.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
ee.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
ee.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
ee.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
ee.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
ee.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
ee.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
ee.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
ee.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
ee.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
ee.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
ee.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
ee.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
ee.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
ee.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
ee.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
ee.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
ee.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
ee.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
ee.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
ee.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
ee.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
ee.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
ee.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
ee.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
ee.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
ee.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
ee.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
ee.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
ee.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
ee.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
ee.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
ee.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
ee.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
ee.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
ee.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
ee.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
ee.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var Cw = ee.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
ee.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function xw(e, t, n, s) {
  var r = e * e, i = t * t, a = (r - i) / r, o = 0;
  s ? (e *= 1 - a * ($R + a * (zR + a * KR)), r = e * e, a = 0) : o = Math.sqrt(a);
  var l = (r - i) / i;
  return {
    es: a,
    e: o,
    ep2: l
  };
}
function bw(e, t, n, s, r) {
  if (!e) {
    var i = $a(ee, s);
    i || (i = Cw), e = i.a, t = i.b, n = i.rf;
  }
  return n && !t && (t = (1 - 1 / n) * e), (n === 0 || Math.abs(e - t) < Dt) && (r = !0, t = e), {
    a: e,
    b: t,
    rf: n,
    sphere: r
  };
}
var kn = {};
kn.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
kn.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
kn.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
kn.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
kn.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
kn.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
kn.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
kn.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
kn.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
kn.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
kn.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
kn.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
kn.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
kn.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
kn.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
kn.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
kn.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function Ow(e, t, n, s, r, i, a) {
  var o = {};
  return e === void 0 || e === "none" ? o.datum_type = Wg : o.datum_type = UR, t && (o.datum_params = t.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = Vo), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = Bo, o.datum_params[3] *= tc, o.datum_params[4] *= tc, o.datum_params[5] *= tc, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = jl, o.grids = a), o.a = n, o.b = s, o.es = r, o.ep2 = i, o;
}
var s1 = {};
function Tw(e, t) {
  var n = new DataView(t), s = Sw(n), r = Iw(n, s), i = _w(n, r, s), a = { header: r, subgrids: i };
  return s1[e] = a, a;
}
function Pw(e) {
  if (e === void 0)
    return null;
  var t = e.split(",");
  return t.map(Mw);
}
function Mw(e) {
  if (e.length === 0)
    return null;
  var t = e[0] === "@";
  return t && (e = e.slice(1)), e === "null" ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : {
    name: e,
    mandatory: !t,
    grid: s1[e] || null,
    isNull: !1
  };
}
function Ml(e) {
  return e / 3600 * Math.PI / 180;
}
function Sw(e) {
  var t = e.getInt32(8, !1);
  return t === 11 ? !1 : (t = e.getInt32(8, !0), t !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function Iw(e, t) {
  return {
    nFields: e.getInt32(8, t),
    nSubgridFields: e.getInt32(24, t),
    nSubgrids: e.getInt32(40, t),
    shiftType: zg(e, 56, 56 + 8).trim(),
    fromSemiMajorAxis: e.getFloat64(120, t),
    fromSemiMinorAxis: e.getFloat64(136, t),
    toSemiMajorAxis: e.getFloat64(152, t),
    toSemiMinorAxis: e.getFloat64(168, t)
  };
}
function zg(e, t, n) {
  return String.fromCharCode.apply(null, new Uint8Array(e.buffer.slice(t, n)));
}
function _w(e, t, n) {
  for (var s = 176, r = [], i = 0; i < t.nSubgrids; i++) {
    var a = Aw(e, s, n), o = Lw(e, s, a, n), l = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), f = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    r.push({
      ll: [Ml(a.lowerLongitude), Ml(a.lowerLatitude)],
      del: [Ml(a.longitudeInterval), Ml(a.latitudeInterval)],
      lim: [l, f],
      count: a.gridNodeCount,
      cvs: Dw(o)
    }), s += 176 + a.gridNodeCount * 16;
  }
  return r;
}
function Dw(e) {
  return e.map(function(t) {
    return [Ml(t.longitudeShift), Ml(t.latitudeShift)];
  });
}
function Aw(e, t, n) {
  return {
    name: zg(e, t + 8, t + 16).trim(),
    parent: zg(e, t + 24, t + 24 + 8).trim(),
    lowerLatitude: e.getFloat64(t + 72, n),
    upperLatitude: e.getFloat64(t + 88, n),
    lowerLongitude: e.getFloat64(t + 104, n),
    upperLongitude: e.getFloat64(t + 120, n),
    latitudeInterval: e.getFloat64(t + 136, n),
    longitudeInterval: e.getFloat64(t + 152, n),
    gridNodeCount: e.getInt32(t + 168, n)
  };
}
function Lw(e, t, n, s) {
  for (var r = t + 176, i = 16, a = [], o = 0; o < n.gridNodeCount; o++) {
    var l = {
      latitudeShift: e.getFloat32(r + o * i, s),
      longitudeShift: e.getFloat32(r + o * i + 4, s),
      latitudeAccuracy: e.getFloat32(r + o * i + 8, s),
      longitudeAccuracy: e.getFloat32(r + o * i + 12, s)
    };
    a.push(l);
  }
  return a;
}
function hs(e, t) {
  if (!(this instanceof hs))
    return new hs(e);
  t = t || function(f) {
    if (f)
      throw f;
  };
  var n = ow(e);
  if (typeof n != "object") {
    t(e);
    return;
  }
  var s = hs.projections.get(n.projName);
  if (!s) {
    t(e);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var r = $a(kn, n.datumCode);
    r && (n.datum_params = n.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), n.ellps = r.ellipse, n.datumName = r.datumName ? r.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var i = bw(n.a, n.b, n.rf, n.ellps, n.sphere), a = xw(i.a, i.b, i.rf, n.R_A), o = Pw(n.nadgrids), l = n.datum || Ow(
    n.datumCode,
    n.datum_params,
    i.a,
    i.b,
    a.es,
    a.ep2,
    o
  );
  mC(this, n), mC(this, s), this.a = i.a, this.b = i.b, this.rf = i.rf, this.sphere = i.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), t(null, this);
}
hs.projections = Ew;
hs.projections.start();
function Rw(e, t) {
  return e.datum_type !== t.datum_type || e.a !== t.a || Math.abs(e.es - t.es) > 5e-11 ? !1 : e.datum_type === Vo ? e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] : e.datum_type === Bo ? e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] && e.datum_params[3] === t.datum_params[3] && e.datum_params[4] === t.datum_params[4] && e.datum_params[5] === t.datum_params[5] && e.datum_params[6] === t.datum_params[6] : !0;
}
function a1(e, t, n) {
  var s = e.x, r = e.y, i = e.z ? e.z : 0, a, o, l, f;
  if (r < -xt && r > -1.001 * xt)
    r = -xt;
  else if (r > xt && r < 1.001 * xt)
    r = xt;
  else {
    if (r < -xt)
      return { x: -1 / 0, y: -1 / 0, z: e.z };
    if (r > xt)
      return { x: 1 / 0, y: 1 / 0, z: e.z };
  }
  return s > Math.PI && (s -= 2 * Math.PI), o = Math.sin(r), f = Math.cos(r), l = o * o, a = n / Math.sqrt(1 - t * l), {
    x: (a + i) * f * Math.cos(s),
    y: (a + i) * f * Math.sin(s),
    z: (a * (1 - t) + i) * o
  };
}
function o1(e, t, n, s) {
  var r = 1e-12, i = r * r, a = 30, o, l, f, d, u, c, h, p, g, m, v, y, E, C = e.x, x = e.y, b = e.z ? e.z : 0, P, T, O;
  if (o = Math.sqrt(C * C + x * x), l = Math.sqrt(C * C + x * x + b * b), o / n < r) {
    if (P = 0, l / n < r)
      return T = xt, O = -s, {
        x: e.x,
        y: e.y,
        z: e.z
      };
  } else
    P = Math.atan2(x, C);
  f = b / l, d = o / l, u = 1 / Math.sqrt(1 - t * (2 - t) * d * d), p = d * (1 - t) * u, g = f * u, E = 0;
  do
    E++, h = n / Math.sqrt(1 - t * g * g), O = o * p + b * g - h * (1 - t * g * g), c = t * h / (h + O), u = 1 / Math.sqrt(1 - c * (2 - c) * d * d), m = d * (1 - c) * u, v = f * u, y = v * p - m * g, p = m, g = v;
  while (y * y > i && E < a);
  return T = Math.atan(v / Math.abs(m)), {
    x: P,
    y: T,
    z: O
  };
}
function ww(e, t, n) {
  if (t === Vo)
    return {
      x: e.x + n[0],
      y: e.y + n[1],
      z: e.z + n[2]
    };
  if (t === Bo) {
    var s = n[0], r = n[1], i = n[2], a = n[3], o = n[4], l = n[5], f = n[6];
    return {
      x: f * (e.x - l * e.y + o * e.z) + s,
      y: f * (l * e.x + e.y - a * e.z) + r,
      z: f * (-o * e.x + a * e.y + e.z) + i
    };
  }
}
function Vw(e, t, n) {
  if (t === Vo)
    return {
      x: e.x - n[0],
      y: e.y - n[1],
      z: e.z - n[2]
    };
  if (t === Bo) {
    var s = n[0], r = n[1], i = n[2], a = n[3], o = n[4], l = n[5], f = n[6], d = (e.x - s) / f, u = (e.y - r) / f, c = (e.z - i) / f;
    return {
      x: d + l * u - o * c,
      y: -l * d + u + a * c,
      z: o * d - a * u + c
    };
  }
}
function Eh(e) {
  return e === Vo || e === Bo;
}
function Bw(e, t, n) {
  if (Rw(e, t) || e.datum_type === Wg || t.datum_type === Wg)
    return n;
  var s = e.a, r = e.es;
  if (e.datum_type === jl) {
    var i = vC(e, !1, n);
    if (i !== 0)
      return;
    s = hC, r = dC;
  }
  var a = t.a, o = t.b, l = t.es;
  if (t.datum_type === jl && (a = hC, o = WR, l = dC), r === l && s === a && !Eh(e.datum_type) && !Eh(t.datum_type))
    return n;
  if (n = a1(n, r, s), Eh(e.datum_type) && (n = ww(n, e.datum_type, e.datum_params)), Eh(t.datum_type) && (n = Vw(n, t.datum_type, t.datum_params)), n = o1(n, l, a, o), t.datum_type === jl) {
    var f = vC(t, !0, n);
    if (f !== 0)
      return;
  }
  return n;
}
function vC(e, t, n) {
  if (e.grids === null || e.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var s = { x: -n.x, y: n.y }, r = { x: Number.NaN, y: Number.NaN }, i = [];
  t:
    for (var a = 0; a < e.grids.length; a++) {
      var o = e.grids[a];
      if (i.push(o.name), o.isNull) {
        r = s;
        break;
      }
      if (o.mandatory, o.grid === null) {
        if (o.mandatory)
          return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
        continue;
      }
      for (var l = o.grid.subgrids, f = 0, d = l.length; f < d; f++) {
        var u = l[f], c = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, h = u.ll[0] - c, p = u.ll[1] - c, g = u.ll[0] + (u.lim[0] - 1) * u.del[0] + c, m = u.ll[1] + (u.lim[1] - 1) * u.del[1] + c;
        if (!(p > s.y || h > s.x || m < s.y || g < s.x) && (r = Nw(s, t, u), !isNaN(r.x)))
          break t;
      }
    }
  return isNaN(r.x) ? (console.log("Failed to find a grid shift table for location '" + -s.x * ls + " " + s.y * ls + " tried: '" + i + "'"), -1) : (n.x = -r.x, n.y = r.y, 0);
}
function Nw(e, t, n) {
  var s = { x: Number.NaN, y: Number.NaN };
  if (isNaN(e.x))
    return s;
  var r = { x: e.x, y: e.y };
  r.x -= n.ll[0], r.y -= n.ll[1], r.x = Bt(r.x - Math.PI) + Math.PI;
  var i = yC(r, n);
  if (t) {
    if (isNaN(i.x))
      return s;
    i.x = r.x - i.x, i.y = r.y - i.y;
    var a = 9, o = 1e-12, l, f;
    do {
      if (f = yC(i, n), isNaN(f.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      l = { x: r.x - (f.x + i.x), y: r.y - (f.y + i.y) }, i.x += l.x, i.y += l.y;
    } while (a-- && Math.abs(l.x) > o && Math.abs(l.y) > o);
    if (a < 0)
      return console.log("Inverse grid shift iterator failed to converge."), s;
    s.x = Bt(i.x + n.ll[0]), s.y = i.y + n.ll[1];
  } else
    isNaN(i.x) || (s.x = e.x + i.x, s.y = e.y + i.y);
  return s;
}
function yC(e, t) {
  var n = { x: e.x / t.del[0], y: e.y / t.del[1] }, s = { x: Math.floor(n.x), y: Math.floor(n.y) }, r = { x: n.x - 1 * s.x, y: n.y - 1 * s.y }, i = { x: Number.NaN, y: Number.NaN }, a;
  if (s.x < 0 || s.x >= t.lim[0] || s.y < 0 || s.y >= t.lim[1])
    return i;
  a = s.y * t.lim[0] + s.x;
  var o = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a++;
  var l = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a += t.lim[0];
  var f = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a--;
  var d = { x: t.cvs[a][0], y: t.cvs[a][1] }, u = r.x * r.y, c = r.x * (1 - r.y), h = (1 - r.x) * (1 - r.y), p = (1 - r.x) * r.y;
  return i.x = h * o.x + c * l.x + p * d.x + u * f.x, i.y = h * o.y + c * l.y + p * d.y + u * f.y, i;
}
function EC(e, t, n) {
  var s = n.x, r = n.y, i = n.z || 0, a, o, l, f = {};
  for (l = 0; l < 3; l++)
    if (!(t && l === 2 && n.z === void 0))
      switch (l === 0 ? (a = s, "ew".indexOf(e.axis[l]) !== -1 ? o = "x" : o = "y") : l === 1 ? (a = r, "ns".indexOf(e.axis[l]) !== -1 ? o = "y" : o = "x") : (a = i, o = "z"), e.axis[l]) {
        case "e":
          f[o] = a;
          break;
        case "w":
          f[o] = -a;
          break;
        case "n":
          f[o] = a;
          break;
        case "s":
          f[o] = -a;
          break;
        case "u":
          n[o] !== void 0 && (f.z = a);
          break;
        case "d":
          n[o] !== void 0 && (f.z = -a);
          break;
        default:
          return null;
      }
  return f;
}
function l1(e) {
  var t = {
    x: e[0],
    y: e[1]
  };
  return e.length > 2 && (t.z = e[2]), e.length > 3 && (t.m = e[3]), t;
}
function Fw(e) {
  CC(e.x), CC(e.y);
}
function CC(e) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(e))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof e != "number" || e !== e || !isFinite(e))
    throw new TypeError("coordinates must be finite numbers");
}
function jw(e, t) {
  return (e.datum.datum_type === Vo || e.datum.datum_type === Bo || e.datum.datum_type === jl) && t.datumCode !== "WGS84" || (t.datum.datum_type === Vo || t.datum.datum_type === Bo || t.datum.datum_type === jl) && e.datumCode !== "WGS84";
}
function wd(e, t, n, s) {
  var r;
  Array.isArray(n) ? n = l1(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var i = n.z !== void 0;
  if (Fw(n), e.datum && t.datum && jw(e, t) && (r = new hs("WGS84"), n = wd(e, r, n, s), e = r), s && e.axis !== "enu" && (n = EC(e, !1, n)), e.projName === "longlat")
    n = {
      x: n.x * Qn,
      y: n.y * Qn,
      z: n.z || 0
    };
  else if (e.to_meter && (n = {
    x: n.x * e.to_meter,
    y: n.y * e.to_meter,
    z: n.z || 0
  }), n = e.inverse(n), !n)
    return;
  if (e.from_greenwich && (n.x += e.from_greenwich), n = Bw(e.datum, t.datum, n), !!n)
    return t.from_greenwich && (n = {
      x: n.x - t.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), t.projName === "longlat" ? n = {
      x: n.x * ls,
      y: n.y * ls,
      z: n.z || 0
    } : (n = t.forward(n), t.to_meter && (n = {
      x: n.x / t.to_meter,
      y: n.y / t.to_meter,
      z: n.z || 0
    })), s && t.axis !== "enu" ? EC(t, !0, n) : (n && !i && delete n.z, n);
}
var xC = hs("WGS84");
function yp(e, t, n, s) {
  var r, i, a;
  return Array.isArray(n) ? (r = wd(e, t, n, s) || { x: NaN, y: NaN }, n.length > 2 ? typeof e.name < "u" && e.name === "geocent" || typeof t.name < "u" && t.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(n.splice(3)) : [r.x, r.y, n[2]].concat(n.splice(3)) : [r.x, r.y].concat(n.splice(2)) : [r.x, r.y]) : (i = wd(e, t, n, s), a = Object.keys(n), a.length === 2 || a.forEach(function(o) {
    if (typeof e.name < "u" && e.name === "geocent" || typeof t.name < "u" && t.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    i[o] = n[o];
  }), i);
}
function bC(e) {
  return e instanceof hs ? e : e.oProj ? e.oProj : hs(e);
}
function dn(e, t, n) {
  e = bC(e);
  var s = !1, r;
  return typeof t > "u" ? (t = e, e = xC, s = !0) : (typeof t.x < "u" || Array.isArray(t)) && (n = t, t = e, e = xC, s = !0), t = bC(t), n ? yp(e, t, n) : (r = {
    forward: function(i, a) {
      return yp(e, t, i, a);
    },
    inverse: function(i, a) {
      return yp(t, e, i, a);
    }
  }, s && (r.oProj = t), r);
}
var OC = 6, u1 = "AJSAJS", c1 = "AFAFAF", Sl = 65, Ri = 73, hr = 79, Hu = 86, Yu = 90;
const Uw = {
  forward: h1,
  inverse: Ww,
  toPoint: d1
};
function h1(e, t) {
  return t = t || 5, Kw($w({
    lat: e[1],
    lon: e[0]
  }), t);
}
function Ww(e) {
  var t = jy(p1(e.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
}
function d1(e) {
  var t = jy(p1(e.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
}
function Ep(e) {
  return e * (Math.PI / 180);
}
function TC(e) {
  return 180 * (e / Math.PI);
}
function $w(e) {
  var t = e.lat, n = e.lon, s = 6378137, r = 669438e-8, i = 0.9996, a, o, l, f, d, u, c, h = Ep(t), p = Ep(n), g, m;
  m = Math.floor((n + 180) / 6) + 1, n === 180 && (m = 60), t >= 56 && t < 64 && n >= 3 && n < 12 && (m = 32), t >= 72 && t < 84 && (n >= 0 && n < 9 ? m = 31 : n >= 9 && n < 21 ? m = 33 : n >= 21 && n < 33 ? m = 35 : n >= 33 && n < 42 && (m = 37)), a = (m - 1) * 6 - 180 + 3, g = Ep(a), o = r / (1 - r), l = s / Math.sqrt(1 - r * Math.sin(h) * Math.sin(h)), f = Math.tan(h) * Math.tan(h), d = o * Math.cos(h) * Math.cos(h), u = Math.cos(h) * (p - g), c = s * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * h - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * h) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * h) - 35 * r * r * r / 3072 * Math.sin(6 * h));
  var v = i * l * (u + (1 - f + d) * u * u * u / 6 + (5 - 18 * f + f * f + 72 * d - 58 * o) * u * u * u * u * u / 120) + 5e5, y = i * (c + l * Math.tan(h) * (u * u / 2 + (5 - f + 9 * d + 4 * d * d) * u * u * u * u / 24 + (61 - 58 * f + f * f + 600 * d - 330 * o) * u * u * u * u * u * u / 720));
  return t < 0 && (y += 1e7), {
    northing: Math.round(y),
    easting: Math.round(v),
    zoneNumber: m,
    zoneLetter: zw(t)
  };
}
function jy(e) {
  var t = e.northing, n = e.easting, s = e.zoneLetter, r = e.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var i = 0.9996, a = 6378137, o = 669438e-8, l, f = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), d, u, c, h, p, g, m, v, y, E = n - 5e5, C = t;
  s < "N" && (C -= 1e7), m = (r - 1) * 6 - 180 + 3, l = o / (1 - o), g = C / i, v = g / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), y = v + (3 * f / 2 - 27 * f * f * f / 32) * Math.sin(2 * v) + (21 * f * f / 16 - 55 * f * f * f * f / 32) * Math.sin(4 * v) + 151 * f * f * f / 96 * Math.sin(6 * v), d = a / Math.sqrt(1 - o * Math.sin(y) * Math.sin(y)), u = Math.tan(y) * Math.tan(y), c = l * Math.cos(y) * Math.cos(y), h = a * (1 - o) / Math.pow(1 - o * Math.sin(y) * Math.sin(y), 1.5), p = E / (d * i);
  var x = y - d * Math.tan(y) / h * (p * p / 2 - (5 + 3 * u + 10 * c - 4 * c * c - 9 * l) * p * p * p * p / 24 + (61 + 90 * u + 298 * c + 45 * u * u - 252 * l - 3 * c * c) * p * p * p * p * p * p / 720);
  x = TC(x);
  var b = (p - (1 + 2 * u + c) * p * p * p / 6 + (5 - 2 * c + 28 * u - 3 * c * c + 8 * l + 24 * u * u) * p * p * p * p * p / 120) / Math.cos(y);
  b = m + TC(b);
  var P;
  if (e.accuracy) {
    var T = jy({
      northing: e.northing + e.accuracy,
      easting: e.easting + e.accuracy,
      zoneLetter: e.zoneLetter,
      zoneNumber: e.zoneNumber
    });
    P = {
      top: T.lat,
      right: T.lon,
      bottom: x,
      left: b
    };
  } else
    P = {
      lat: x,
      lon: b
    };
  return P;
}
function zw(e) {
  var t = "Z";
  return 84 >= e && e >= 72 ? t = "X" : 72 > e && e >= 64 ? t = "W" : 64 > e && e >= 56 ? t = "V" : 56 > e && e >= 48 ? t = "U" : 48 > e && e >= 40 ? t = "T" : 40 > e && e >= 32 ? t = "S" : 32 > e && e >= 24 ? t = "R" : 24 > e && e >= 16 ? t = "Q" : 16 > e && e >= 8 ? t = "P" : 8 > e && e >= 0 ? t = "N" : 0 > e && e >= -8 ? t = "M" : -8 > e && e >= -16 ? t = "L" : -16 > e && e >= -24 ? t = "K" : -24 > e && e >= -32 ? t = "J" : -32 > e && e >= -40 ? t = "H" : -40 > e && e >= -48 ? t = "G" : -48 > e && e >= -56 ? t = "F" : -56 > e && e >= -64 ? t = "E" : -64 > e && e >= -72 ? t = "D" : -72 > e && e >= -80 && (t = "C"), t;
}
function Kw(e, t) {
  var n = "00000" + e.easting, s = "00000" + e.northing;
  return e.zoneNumber + e.zoneLetter + Gw(e.easting, e.northing, e.zoneNumber) + n.substr(n.length - 5, t) + s.substr(s.length - 5, t);
}
function Gw(e, t, n) {
  var s = f1(n), r = Math.floor(e / 1e5), i = Math.floor(t / 1e5) % 20;
  return kw(r, i, s);
}
function f1(e) {
  var t = e % OC;
  return t === 0 && (t = OC), t;
}
function kw(e, t, n) {
  var s = n - 1, r = u1.charCodeAt(s), i = c1.charCodeAt(s), a = r + e - 1, o = i + t, l = !1;
  a > Yu && (a = a - Yu + Sl - 1, l = !0), (a === Ri || r < Ri && a > Ri || (a > Ri || r < Ri) && l) && a++, (a === hr || r < hr && a > hr || (a > hr || r < hr) && l) && (a++, a === Ri && a++), a > Yu && (a = a - Yu + Sl - 1), o > Hu ? (o = o - Hu + Sl - 1, l = !0) : l = !1, (o === Ri || i < Ri && o > Ri || (o > Ri || i < Ri) && l) && o++, (o === hr || i < hr && o > hr || (o > hr || i < hr) && l) && (o++, o === Ri && o++), o > Hu && (o = o - Hu + Sl - 1);
  var f = String.fromCharCode(a) + String.fromCharCode(o);
  return f;
}
function p1(e) {
  if (e && e.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var t = e.length, n = null, s = "", r, i = 0; !/[A-Z]/.test(r = e.charAt(i)); ) {
    if (i >= 2)
      throw "MGRSPoint bad conversion from: " + e;
    s += r, i++;
  }
  var a = parseInt(s, 10);
  if (i === 0 || i + 3 > t)
    throw "MGRSPoint bad conversion from: " + e;
  var o = e.charAt(i++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + e;
  n = e.substring(i, i += 2);
  for (var l = f1(a), f = Hw(n.charAt(0), l), d = Yw(n.charAt(1), l); d < Xw(o); )
    d += 2e6;
  var u = t - i;
  if (u % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + e;
  var c = u / 2, h = 0, p = 0, g, m, v, y, E;
  return c > 0 && (g = 1e5 / Math.pow(10, c), m = e.substring(i, i + c), h = parseFloat(m) * g, v = e.substring(i + c), p = parseFloat(v) * g), y = h + f, E = p + d, {
    easting: y,
    northing: E,
    zoneLetter: o,
    zoneNumber: a,
    accuracy: g
  };
}
function Hw(e, t) {
  for (var n = u1.charCodeAt(t - 1), s = 1e5, r = !1; n !== e.charCodeAt(0); ) {
    if (n++, n === Ri && n++, n === hr && n++, n > Yu) {
      if (r)
        throw "Bad character: " + e;
      n = Sl, r = !0;
    }
    s += 1e5;
  }
  return s;
}
function Yw(e, t) {
  if (e > "V")
    throw "MGRSPoint given invalid Northing " + e;
  for (var n = c1.charCodeAt(t - 1), s = 0, r = !1; n !== e.charCodeAt(0); ) {
    if (n++, n === Ri && n++, n === hr && n++, n > Hu) {
      if (r)
        throw "Bad character: " + e;
      n = Sl, r = !0;
    }
    s += 1e5;
  }
  return s;
}
function Xw(e) {
  var t;
  switch (e) {
    case "C":
      t = 11e5;
      break;
    case "D":
      t = 2e6;
      break;
    case "E":
      t = 28e5;
      break;
    case "F":
      t = 37e5;
      break;
    case "G":
      t = 46e5;
      break;
    case "H":
      t = 55e5;
      break;
    case "J":
      t = 64e5;
      break;
    case "K":
      t = 73e5;
      break;
    case "L":
      t = 82e5;
      break;
    case "M":
      t = 91e5;
      break;
    case "N":
      t = 0;
      break;
    case "P":
      t = 8e5;
      break;
    case "Q":
      t = 17e5;
      break;
    case "R":
      t = 26e5;
      break;
    case "S":
      t = 35e5;
      break;
    case "T":
      t = 44e5;
      break;
    case "U":
      t = 53e5;
      break;
    case "V":
      t = 62e5;
      break;
    case "W":
      t = 7e6;
      break;
    case "X":
      t = 79e5;
      break;
    default:
      t = -1;
  }
  if (t >= 0)
    return t;
  throw "Invalid zone letter: " + e;
}
function tu(e, t, n) {
  if (!(this instanceof tu))
    return new tu(e, t, n);
  if (Array.isArray(e))
    this.x = e[0], this.y = e[1], this.z = e[2] || 0;
  else if (typeof e == "object")
    this.x = e.x, this.y = e.y, this.z = e.z || 0;
  else if (typeof e == "string" && typeof t > "u") {
    var s = e.split(",");
    this.x = parseFloat(s[0], 10), this.y = parseFloat(s[1], 10), this.z = parseFloat(s[2], 10) || 0;
  } else
    this.x = e, this.y = t, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
tu.fromMGRS = function(e) {
  return new tu(d1(e));
};
tu.prototype.toMGRS = function(e) {
  return h1([this.x, this.y], e);
};
var Zw = 1, Jw = 0.25, PC = 0.046875, MC = 0.01953125, SC = 0.01068115234375, Qw = 0.75, qw = 0.46875, t2 = 0.013020833333333334, e2 = 0.007120768229166667, n2 = 0.3645833333333333, i2 = 0.005696614583333333, r2 = 0.3076171875;
function m1(e) {
  var t = [];
  t[0] = Zw - e * (Jw + e * (PC + e * (MC + e * SC))), t[1] = e * (Qw - e * (PC + e * (MC + e * SC)));
  var n = e * e;
  return t[2] = n * (qw - e * (t2 + e * e2)), n *= e, t[3] = n * (n2 - e * i2), t[4] = n * e * r2, t;
}
function Lf(e, t, n, s) {
  return n *= t, t *= t, s[0] * e - n * (s[1] + t * (s[2] + t * (s[3] + t * s[4])));
}
var s2 = 20;
function g1(e, t, n) {
  for (var s = 1 / (1 - t), r = e, i = s2; i; --i) {
    var a = Math.sin(r), o = 1 - t * a * a;
    if (o = (Lf(r, a, Math.cos(r), n) - e) * (o * Math.sqrt(o)) * s, r -= o, Math.abs(o) < Dt)
      return r;
  }
  return r;
}
function a2() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = m1(this.es), this.ml0 = Lf(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function o2(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r, i, a, o = Math.sin(n), l = Math.cos(n);
  if (this.es) {
    var d = l * s, u = Math.pow(d, 2), c = this.ep2 * Math.pow(l, 2), h = Math.pow(c, 2), p = Math.abs(l) > Dt ? Math.tan(n) : 0, g = Math.pow(p, 2), m = Math.pow(g, 2);
    r = 1 - this.es * Math.pow(o, 2), d = d / Math.sqrt(r);
    var v = Lf(n, o, l, this.en);
    i = this.a * (this.k0 * d * (1 + u / 6 * (1 - g + c + u / 20 * (5 - 18 * g + m + 14 * c - 58 * g * c + u / 42 * (61 + 179 * m - m * g - 479 * g))))) + this.x0, a = this.a * (this.k0 * (v - this.ml0 + o * s * d / 2 * (1 + u / 12 * (5 - g + 9 * c + 4 * h + u / 30 * (61 + m - 58 * g + 270 * c - 330 * g * c + u / 56 * (1385 + 543 * m - m * g - 3111 * g)))))) + this.y0;
  } else {
    var f = l * Math.sin(s);
    if (Math.abs(Math.abs(f) - 1) < Dt)
      return 93;
    if (i = 0.5 * this.a * this.k0 * Math.log((1 + f) / (1 - f)) + this.x0, a = l * Math.cos(s) / Math.sqrt(1 - Math.pow(f, 2)), f = Math.abs(a), f >= 1) {
      if (f - 1 > Dt)
        return 93;
      a = 0;
    } else
      a = Math.acos(a);
    n < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
  }
  return e.x = i, e.y = a, e;
}
function l2(e) {
  var t, n, s, r, i = (e.x - this.x0) * (1 / this.a), a = (e.y - this.y0) * (1 / this.a);
  if (this.es)
    if (t = this.ml0 + a / this.k0, n = g1(t, this.es, this.en), Math.abs(n) < xt) {
      var u = Math.sin(n), c = Math.cos(n), h = Math.abs(c) > Dt ? Math.tan(n) : 0, p = this.ep2 * Math.pow(c, 2), g = Math.pow(p, 2), m = Math.pow(h, 2), v = Math.pow(m, 2);
      t = 1 - this.es * Math.pow(u, 2);
      var y = i * Math.sqrt(t) / this.k0, E = Math.pow(y, 2);
      t = t * h, s = n - t * E / (1 - this.es) * 0.5 * (1 - E / 12 * (5 + 3 * m - 9 * p * m + p - 4 * g - E / 30 * (61 + 90 * m - 252 * p * m + 45 * v + 46 * p - E / 56 * (1385 + 3633 * m + 4095 * v + 1574 * v * m)))), r = Bt(this.long0 + y * (1 - E / 6 * (1 + 2 * m + p - E / 20 * (5 + 28 * m + 24 * v + 8 * p * m + 6 * p - E / 42 * (61 + 662 * m + 1320 * v + 720 * v * m)))) / c);
    } else
      s = xt * Wc(a), r = 0;
  else {
    var o = Math.exp(i / this.k0), l = 0.5 * (o - 1 / o), f = this.lat0 + a / this.k0, d = Math.cos(f);
    t = Math.sqrt((1 - Math.pow(d, 2)) / (1 + Math.pow(l, 2))), s = Math.asin(t), a < 0 && (s = -s), l === 0 && d === 0 ? r = 0 : r = Bt(Math.atan2(l, d) + this.long0);
  }
  return e.x = r, e.y = s, e;
}
var u2 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const sd = {
  init: a2,
  forward: o2,
  inverse: l2,
  names: u2
};
function v1(e) {
  var t = Math.exp(e);
  return t = (t - 1 / t) / 2, t;
}
function Dr(e, t) {
  e = Math.abs(e), t = Math.abs(t);
  var n = Math.max(e, t), s = Math.min(e, t) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(s, 2));
}
function c2(e) {
  var t = 1 + e, n = t - 1;
  return n === 0 ? e : e * Math.log(t) / n;
}
function h2(e) {
  var t = Math.abs(e);
  return t = c2(t * (1 + t / (Dr(1, t) + 1))), e < 0 ? -t : t;
}
function Uy(e, t) {
  for (var n = 2 * Math.cos(2 * t), s = e.length - 1, r = e[s], i = 0, a; --s >= 0; )
    a = -i + n * r + e[s], i = r, r = a;
  return t + a * Math.sin(2 * t);
}
function d2(e, t) {
  for (var n = 2 * Math.cos(t), s = e.length - 1, r = e[s], i = 0, a; --s >= 0; )
    a = -i + n * r + e[s], i = r, r = a;
  return Math.sin(t) * a;
}
function f2(e) {
  var t = Math.exp(e);
  return t = (t + 1 / t) / 2, t;
}
function y1(e, t, n) {
  for (var s = Math.sin(t), r = Math.cos(t), i = v1(n), a = f2(n), o = 2 * r * a, l = -2 * s * i, f = e.length - 1, d = e[f], u = 0, c = 0, h = 0, p, g; --f >= 0; )
    p = c, g = u, c = d, u = h, d = -p + o * c - l * u + e[f], h = -g + l * c + o * u;
  return o = s * a, l = r * i, [o * d - l * h, o * h + l * d];
}
function p2() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (sd.init.apply(this), this.forward = sd.forward, this.inverse = sd.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var e = this.es / (1 + Math.sqrt(1 - this.es)), t = e / (2 - e), n = t;
  this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), n = n * t, this.cgb[1] = n * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), n = n * t, this.cgb[2] = n * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), n = n * t, this.cgb[3] = n * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), n = n * t, this.cgb[4] = n * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + t * (109598 / 31185)), n = n * t, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), n = n * t, this.utg[2] = n * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), n = n * t, this.utg[3] = n * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), n = n * t, this.utg[4] = n * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + t * (-3418889 / 1995840)), n = n * t, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var s = Uy(this.cbg, this.lat0);
  this.Zb = -this.Qn * (s + d2(this.gtu, 2 * s));
}
function m2(e) {
  var t = Bt(e.x - this.long0), n = e.y;
  n = Uy(this.cbg, n);
  var s = Math.sin(n), r = Math.cos(n), i = Math.sin(t), a = Math.cos(t);
  n = Math.atan2(s, a * r), t = Math.atan2(i * r, Dr(s, r * a)), t = h2(Math.tan(t));
  var o = y1(this.gtu, 2 * n, 2 * t);
  n = n + o[0], t = t + o[1];
  var l, f;
  return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, f = this.a * (this.Qn * n + this.Zb) + this.y0) : (l = 1 / 0, f = 1 / 0), e.x = l, e.y = f, e;
}
function g2(e) {
  var t = (e.x - this.x0) * (1 / this.a), n = (e.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, t = t / this.Qn;
  var s, r;
  if (Math.abs(t) <= 2.623395162778) {
    var i = y1(this.utg, 2 * n, 2 * t);
    n = n + i[0], t = t + i[1], t = Math.atan(v1(t));
    var a = Math.sin(n), o = Math.cos(n), l = Math.sin(t), f = Math.cos(t);
    n = Math.atan2(a * f, Dr(l, f * o)), t = Math.atan2(l, f * o), s = Bt(t + this.long0), r = Uy(this.cgb, n);
  } else
    s = 1 / 0, r = 1 / 0;
  return e.x = s, e.y = r, e;
}
var v2 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const ad = {
  init: p2,
  forward: m2,
  inverse: g2,
  names: v2
};
function y2(e, t) {
  if (e === void 0) {
    if (e = Math.floor((Bt(t) + Math.PI) * 30 / Math.PI) + 1, e < 0)
      return 0;
    if (e > 60)
      return 60;
  }
  return e;
}
var E2 = "etmerc";
function C2() {
  var e = y2(this.zone, this.long0);
  if (e === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(e) - 183) * Qn, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, ad.init.apply(this), this.forward = ad.forward, this.inverse = ad.inverse;
}
var x2 = ["Universal Transverse Mercator System", "utm"];
const b2 = {
  init: C2,
  names: x2,
  dependsOn: E2
};
function Wy(e, t) {
  return Math.pow((1 - e) / (1 + e), t);
}
var O2 = 20;
function T2() {
  var e = Math.sin(this.lat0), t = Math.cos(this.lat0);
  t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * e * e), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(e / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + _e) / (Math.pow(Math.tan(0.5 * this.lat0 + _e), this.C) * Wy(this.e * e, this.ratexp));
}
function P2(e) {
  var t = e.x, n = e.y;
  return e.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + _e), this.C) * Wy(this.e * Math.sin(n), this.ratexp)) - xt, e.x = this.C * t, e;
}
function M2(e) {
  for (var t = 1e-14, n = e.x / this.C, s = e.y, r = Math.pow(Math.tan(0.5 * s + _e) / this.K, 1 / this.C), i = O2; i > 0 && (s = 2 * Math.atan(r * Wy(this.e * Math.sin(e.y), -0.5 * this.e)) - xt, !(Math.abs(s - e.y) < t)); --i)
    e.y = s;
  return i ? (e.x = n, e.y = s, e) : null;
}
var S2 = ["gauss"];
const $y = {
  init: T2,
  forward: P2,
  inverse: M2,
  names: S2
};
function I2() {
  $y.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function _2(e) {
  var t, n, s, r;
  return e.x = Bt(e.x - this.long0), $y.forward.apply(this, [e]), t = Math.sin(e.y), n = Math.cos(e.y), s = Math.cos(e.x), r = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * n * s), e.x = r * n * Math.sin(e.x), e.y = r * (this.cosc0 * t - this.sinc0 * n * s), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function D2(e) {
  var t, n, s, r, i;
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, i = Math.sqrt(e.x * e.x + e.y * e.y)) {
    var a = 2 * Math.atan2(i, this.R2);
    t = Math.sin(a), n = Math.cos(a), r = Math.asin(n * this.sinc0 + e.y * t * this.cosc0 / i), s = Math.atan2(e.x * t, i * this.cosc0 * n - e.y * this.sinc0 * t);
  } else
    r = this.phic0, s = 0;
  return e.x = s, e.y = r, $y.inverse.apply(this, [e]), e.x = Bt(e.x + this.long0), e;
}
var A2 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const L2 = {
  init: I2,
  forward: _2,
  inverse: D2,
  names: A2
};
function R2(e, t, n) {
  return t *= n, Math.tan(0.5 * (xt + e)) * Math.pow((1 - t) / (1 + t), 0.5 * n);
}
function w2() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Dt && (this.k0 = 0.5 * (1 + Wc(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Dt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Dt && Math.abs(Math.cos(this.lat_ts)) > Dt && (this.k0 = 0.5 * this.cons * ps(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Vr(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ps(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - xt, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function V2(e) {
  var t = e.x, n = e.y, s = Math.sin(n), r = Math.cos(n), i, a, o, l, f, d, u = Bt(t - this.long0);
  return Math.abs(Math.abs(t - this.long0) - Math.PI) <= Dt && Math.abs(n + this.lat0) <= Dt ? (e.x = NaN, e.y = NaN, e) : this.sphere ? (i = 2 * this.k0 / (1 + this.sinlat0 * s + this.coslat0 * r * Math.cos(u)), e.x = this.a * i * r * Math.sin(u) + this.x0, e.y = this.a * i * (this.coslat0 * s - this.sinlat0 * r * Math.cos(u)) + this.y0, e) : (a = 2 * Math.atan(this.ssfn_(n, s, this.e)) - xt, l = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= Dt ? (f = Vr(this.e, n * this.con, this.con * s), d = 2 * this.a * this.k0 * f / this.cons, e.x = this.x0 + d * Math.sin(t - this.long0), e.y = this.y0 - this.con * d * Math.cos(t - this.long0), e) : (Math.abs(this.sinlat0) < Dt ? (i = 2 * this.a * this.k0 / (1 + l * Math.cos(u)), e.y = i * o) : (i = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * l * Math.cos(u))), e.y = i * (this.cosX0 * o - this.sinX0 * l * Math.cos(u)) + this.y0), e.x = i * l * Math.sin(u) + this.x0, e));
}
function B2(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n, s, r, i, a = Math.sqrt(e.x * e.x + e.y * e.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return t = this.long0, n = this.lat0, a <= Dt ? (e.x = t, e.y = n, e) : (n = Math.asin(Math.cos(o) * this.sinlat0 + e.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < Dt ? this.lat0 > 0 ? t = Bt(this.long0 + Math.atan2(e.x, -1 * e.y)) : t = Bt(this.long0 + Math.atan2(e.x, e.y)) : t = Bt(this.long0 + Math.atan2(e.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - e.y * this.sinlat0 * Math.sin(o))), e.x = t, e.y = n, e);
  } else if (Math.abs(this.coslat0) <= Dt) {
    if (a <= Dt)
      return n = this.lat0, t = this.long0, e.x = t, e.y = n, e;
    e.x *= this.con, e.y *= this.con, s = a * this.cons / (2 * this.a * this.k0), n = this.con * vc(this.e, s), t = this.con * Bt(this.con * this.long0 + Math.atan2(e.x, -1 * e.y));
  } else
    r = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, a <= Dt ? i = this.X0 : (i = Math.asin(Math.cos(r) * this.sinX0 + e.y * Math.sin(r) * this.cosX0 / a), t = Bt(this.long0 + Math.atan2(e.x * Math.sin(r), a * this.cosX0 * Math.cos(r) - e.y * this.sinX0 * Math.sin(r)))), n = -1 * vc(this.e, Math.tan(0.5 * (xt + i)));
  return e.x = t, e.y = n, e;
}
var N2 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
const F2 = {
  init: w2,
  forward: V2,
  inverse: B2,
  names: N2,
  ssfn_: R2
};
function j2() {
  var e = this.lat0;
  this.lambda0 = this.long0;
  var t = Math.sin(e), n = this.a, s = this.rf, r = 1 / s, i = 2 * r - Math.pow(r, 2), a = this.e = Math.sqrt(i);
  this.R = this.k0 * n * Math.sqrt(1 - i) / (1 - i * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + i / (1 - i) * Math.pow(Math.cos(e), 4)), this.b0 = Math.asin(t / this.alpha);
  var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + e / 2)), f = Math.log((1 + a * t) / (1 - a * t));
  this.K = o - this.alpha * l + this.alpha * a / 2 * f;
}
function U2(e) {
  var t = Math.log(Math.tan(Math.PI / 4 - e.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(e.y)) / (1 - this.e * Math.sin(e.y))), s = -this.alpha * (t + n) + this.K, r = 2 * (Math.atan(Math.exp(s)) - Math.PI / 4), i = this.alpha * (e.x - this.lambda0), a = Math.atan(Math.sin(i) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(i))), o = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(i));
  return e.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, e.x = this.R * a + this.x0, e;
}
function W2(e) {
  for (var t = e.x - this.x0, n = e.y - this.y0, s = t / this.R, r = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), i = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(s)), a = Math.atan(Math.sin(s) / (Math.cos(this.b0) * Math.cos(s) - Math.sin(this.b0) * Math.tan(r))), o = this.lambda0 + a / this.alpha, l = 0, f = i, d = -1e3, u = 0; Math.abs(f - d) > 1e-7; ) {
    if (++u > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + i / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(f)) / 2)), d = f, f = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return e.x = o, e.y = f, e;
}
var $2 = ["somerc"];
const z2 = {
  init: j2,
  forward: U2,
  inverse: W2,
  names: $2
};
var yl = 1e-7;
function K2(e) {
  var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof e.PROJECTION == "object" ? Object.keys(e.PROJECTION)[0] : e.PROJECTION;
  return "no_uoff" in e || "no_off" in e || t.indexOf(n) !== -1;
}
function G2() {
  var e, t, n, s, r, i, a, o, l, f, d = 0, u, c = 0, h = 0, p = 0, g = 0, m = 0, v = 0;
  this.no_off = K2(this), this.no_rot = "no_rot" in this;
  var y = !1;
  "alpha" in this && (y = !0);
  var E = !1;
  if ("rectified_grid_angle" in this && (E = !0), y && (v = this.alpha), E && (d = this.rectified_grid_angle * Qn), y || E)
    c = this.longc;
  else if (h = this.long1, g = this.lat1, p = this.long2, m = this.lat2, Math.abs(g - m) <= yl || (e = Math.abs(g)) <= yl || Math.abs(e - xt) <= yl || Math.abs(Math.abs(this.lat0) - xt) <= yl || Math.abs(Math.abs(m) - xt) <= yl)
    throw new Error();
  var C = 1 - this.es;
  t = Math.sqrt(C), Math.abs(this.lat0) > Dt ? (o = Math.sin(this.lat0), n = Math.cos(this.lat0), e = 1 - this.es * o * o, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / C), this.A = this.B * this.k0 * t / e, s = this.B * t / (n * Math.sqrt(e)), r = s * s - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += s, this.E *= Math.pow(Vr(this.e, this.lat0, o), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = s = r = 1), y || E ? (y ? (u = Math.asin(Math.sin(v) / s), E || (d = v)) : (u = d, v = Math.asin(s * Math.sin(u))), this.lam0 = c - Math.asin(0.5 * (r - 1 / r) * Math.tan(u)) / this.B) : (i = Math.pow(Vr(this.e, g, Math.sin(g)), this.B), a = Math.pow(Vr(this.e, m, Math.sin(m)), this.B), r = this.E / i, l = (a - i) / (a + i), f = this.E * this.E, f = (f - a * i) / (f + a * i), e = h - p, e < -Math.pi ? p -= mc : e > Math.pi && (p += mc), this.lam0 = Bt(0.5 * (h + p) - Math.atan(f * Math.tan(0.5 * this.B * (h - p)) / l) / this.B), u = Math.atan(2 * Math.sin(this.B * Bt(h - this.lam0)) / (r - 1 / r)), d = v = Math.asin(s * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(d), this.cosrot = Math.cos(d), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(s * s - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(_e - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(_e + r));
}
function k2(e) {
  var t = {}, n, s, r, i, a, o, l, f;
  if (e.x = e.x - this.lam0, Math.abs(Math.abs(e.y) - xt) > Dt) {
    if (a = this.E / Math.pow(Vr(this.e, e.y, Math.sin(e.y)), this.B), o = 1 / a, n = 0.5 * (a - o), s = 0.5 * (a + o), i = Math.sin(this.B * e.x), r = (n * this.singam - i * this.cosgam) / s, Math.abs(Math.abs(r) - 1) < Dt)
      throw new Error();
    f = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), o = Math.cos(this.B * e.x), Math.abs(o) < yl ? l = this.A * e.x : l = this.ArB * Math.atan2(n * this.cosgam + i * this.singam, o);
  } else
    f = e.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * e.y;
  return this.no_rot ? (t.x = l, t.y = f) : (l -= this.u_0, t.x = f * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - f * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function H2(e) {
  var t, n, s, r, i, a, o, l = {};
  if (e.x = (e.x - this.x0) * (1 / this.a), e.y = (e.y - this.y0) * (1 / this.a), this.no_rot ? (n = e.y, t = e.x) : (n = e.x * this.cosrot - e.y * this.sinrot, t = e.y * this.cosrot + e.x * this.sinrot + this.u_0), s = Math.exp(-this.BrA * n), r = 0.5 * (s - 1 / s), i = 0.5 * (s + 1 / s), a = Math.sin(this.BrA * t), o = (a * this.cosgam + r * this.singam) / i, Math.abs(Math.abs(o) - 1) < Dt)
    l.x = 0, l.y = o < 0 ? -xt : xt;
  else {
    if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = vc(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - a * this.singam, Math.cos(this.BrA * t));
  }
  return l.x += this.lam0, l;
}
var Y2 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const X2 = {
  init: G2,
  forward: k2,
  inverse: H2,
  names: Y2
};
function Z2() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Dt)) {
    var e = this.b / this.a;
    this.e = Math.sqrt(1 - e * e);
    var t = Math.sin(this.lat1), n = Math.cos(this.lat1), s = ps(this.e, t, n), r = Vr(this.e, this.lat1, t), i = Math.sin(this.lat2), a = Math.cos(this.lat2), o = ps(this.e, i, a), l = Vr(this.e, this.lat2, i), f = Vr(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Dt ? this.ns = Math.log(s / o) / Math.log(r / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = s / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(f, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function J2(e) {
  var t = e.x, n = e.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Dt && (n = Wc(n) * (xt - 2 * Dt));
  var s = Math.abs(Math.abs(n) - xt), r, i;
  if (s > Dt)
    r = Vr(this.e, n, Math.sin(n)), i = this.a * this.f0 * Math.pow(r, this.ns);
  else {
    if (s = n * this.ns, s <= 0)
      return null;
    i = 0;
  }
  var a = this.ns * Bt(t - this.long0);
  return e.x = this.k0 * (i * Math.sin(a)) + this.x0, e.y = this.k0 * (this.rh - i * Math.cos(a)) + this.y0, e;
}
function Q2(e) {
  var t, n, s, r, i, a = (e.x - this.x0) / this.k0, o = this.rh - (e.y - this.y0) / this.k0;
  this.ns > 0 ? (t = Math.sqrt(a * a + o * o), n = 1) : (t = -Math.sqrt(a * a + o * o), n = -1);
  var l = 0;
  if (t !== 0 && (l = Math.atan2(n * a, n * o)), t !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, s = Math.pow(t / (this.a * this.f0), n), r = vc(this.e, s), r === -9999)
      return null;
  } else
    r = -xt;
  return i = Bt(l / this.ns + this.long0), e.x = i, e.y = r, e;
}
var q2 = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const tV = {
  init: Z2,
  forward: J2,
  inverse: Q2,
  names: q2
};
function eV() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function nV(e) {
  var t, n, s, r, i, a, o, l = e.x, f = e.y, d = Bt(l - this.long0);
  return t = Math.pow((1 + this.e * Math.sin(f)) / (1 - this.e * Math.sin(f)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(f / 2 + this.s45), this.alfa) / t) - this.s45), s = -d * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(s)), i = Math.asin(Math.cos(n) * Math.sin(s) / Math.cos(r)), a = this.n * i, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), e.y = o * Math.cos(a) / 1, e.x = o * Math.sin(a) / 1, this.czech || (e.y *= -1, e.x *= -1), e;
}
function iV(e) {
  var t, n, s, r, i, a, o, l, f = e.x;
  e.x = e.y, e.y = f, this.czech || (e.y *= -1, e.x *= -1), a = Math.sqrt(e.x * e.x + e.y * e.y), i = Math.atan2(e.y, e.x), r = i / Math.sin(this.s0), s = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(r)), n = Math.asin(Math.cos(s) * Math.sin(r) / Math.cos(t)), e.x = this.long0 - n / this.alfa, o = t, l = 0;
  var d = 0;
  do
    e.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - e.y) < 1e-10 && (l = 1), o = e.y, d += 1;
  while (l === 0 && d < 15);
  return d >= 15 ? null : e;
}
var rV = ["Krovak", "krovak"];
const sV = {
  init: eV,
  forward: nV,
  inverse: iV,
  names: rV
};
function Pi(e, t, n, s, r) {
  return e * r - t * Math.sin(2 * r) + n * Math.sin(4 * r) - s * Math.sin(6 * r);
}
function $c(e) {
  return 1 - 0.25 * e * (1 + e / 16 * (3 + 1.25 * e));
}
function zc(e) {
  return 0.375 * e * (1 + 0.25 * e * (1 + 0.46875 * e));
}
function Kc(e) {
  return 0.05859375 * e * e * (1 + 0.75 * e);
}
function Gc(e) {
  return e * e * e * (35 / 3072);
}
function eu(e, t, n) {
  var s = t * n;
  return e / Math.sqrt(1 - s * s);
}
function hu(e) {
  return Math.abs(e) < xt ? e : e - Wc(e) * Math.PI;
}
function Vd(e, t, n, s, r) {
  var i, a;
  i = e / t;
  for (var o = 0; o < 15; o++)
    if (a = (e - (t * i - n * Math.sin(2 * i) + s * Math.sin(4 * i) - r * Math.sin(6 * i))) / (t - 2 * n * Math.cos(2 * i) + 4 * s * Math.cos(4 * i) - 6 * r * Math.cos(6 * i)), i += a, Math.abs(a) <= 1e-10)
      return i;
  return NaN;
}
function aV() {
  this.sphere || (this.e0 = $c(this.es), this.e1 = zc(this.es), this.e2 = Kc(this.es), this.e3 = Gc(this.es), this.ml0 = this.a * Pi(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function oV(e) {
  var t, n, s = e.x, r = e.y;
  if (s = Bt(s - this.long0), this.sphere)
    t = this.a * Math.asin(Math.cos(r) * Math.sin(s)), n = this.a * (Math.atan2(Math.tan(r), Math.cos(s)) - this.lat0);
  else {
    var i = Math.sin(r), a = Math.cos(r), o = eu(this.a, this.e, i), l = Math.tan(r) * Math.tan(r), f = s * Math.cos(r), d = f * f, u = this.es * a * a / (1 - this.es), c = this.a * Pi(this.e0, this.e1, this.e2, this.e3, r);
    t = o * f * (1 - d * l * (1 / 6 - (8 - l + 8 * u) * d / 120)), n = c - this.ml0 + o * i / a * d * (0.5 + (5 - l + 6 * u) * d / 24);
  }
  return e.x = t + this.x0, e.y = n + this.y0, e;
}
function lV(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = e.x / this.a, n = e.y / this.a, s, r;
  if (this.sphere) {
    var i = n + this.lat0;
    s = Math.asin(Math.sin(i) * Math.cos(t)), r = Math.atan2(Math.tan(t), Math.cos(i));
  } else {
    var a = this.ml0 / this.a + n, o = Vd(a, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(o) - xt) <= Dt)
      return e.x = this.long0, e.y = xt, n < 0 && (e.y *= -1), e;
    var l = eu(this.a, this.e, Math.sin(o)), f = l * l * l / this.a / this.a * (1 - this.es), d = Math.pow(Math.tan(o), 2), u = t * this.a / l, c = u * u;
    s = o - l * Math.tan(o) / f * u * u * (0.5 - (1 + 3 * d) * u * u / 24), r = u * (1 - c * (d / 3 + (1 + 3 * d) * d * c / 15)) / Math.cos(o);
  }
  return e.x = Bt(r + this.long0), e.y = hu(s), e;
}
var uV = ["Cassini", "Cassini_Soldner", "cass"];
const cV = {
  init: aV,
  forward: oV,
  inverse: lV,
  names: uV
};
function La(e, t) {
  var n;
  return e > 1e-7 ? (n = e * t, (1 - e * e) * (t / (1 - n * n) - 0.5 / e * Math.log((1 - n) / (1 + n)))) : 2 * t;
}
var hV = 1, dV = 2, fV = 3, pV = 4;
function mV() {
  var e = Math.abs(this.lat0);
  if (Math.abs(e - xt) < Dt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < Dt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var t;
    switch (this.qp = La(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = TV(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = La(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function gV(e) {
  var t, n, s, r, i, a, o, l, f, d, u = e.x, c = e.y;
  if (u = Bt(u - this.long0), this.sphere) {
    if (i = Math.sin(c), d = Math.cos(c), s = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + d * s : 1 + this.sinph0 * i + this.cosph0 * d * s, n <= Dt)
        return null;
      n = Math.sqrt(2 / n), t = n * d * Math.sin(u), n *= this.mode === this.EQUIT ? i : this.cosph0 * i - this.sinph0 * d * s;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (s = -s), Math.abs(c + this.lat0) < Dt)
        return null;
      n = _e - c * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), t = n * Math.sin(u), n *= s;
    }
  } else {
    switch (o = 0, l = 0, f = 0, s = Math.cos(u), r = Math.sin(u), i = Math.sin(c), a = La(this.e, i), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        f = 1 + this.sinb1 * o + this.cosb1 * l * s;
        break;
      case this.EQUIT:
        f = 1 + l * s;
        break;
      case this.N_POLE:
        f = xt + c, a = this.qp - a;
        break;
      case this.S_POLE:
        f = c - xt, a = this.qp + a;
        break;
    }
    if (Math.abs(f) < Dt)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        f = Math.sqrt(2 / f), this.mode === this.OBLIQ ? n = this.ymf * f * (this.cosb1 * o - this.sinb1 * l * s) : n = (f = Math.sqrt(2 / (1 + l * s))) * o * this.ymf, t = this.xmf * f * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (t = (f = Math.sqrt(a)) * r, n = s * (this.mode === this.S_POLE ? f : -f)) : t = n = 0;
        break;
    }
  }
  return e.x = this.a * t + this.x0, e.y = this.a * n + this.y0, e;
}
function vV(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = e.x / this.a, n = e.y / this.a, s, r, i, a, o, l, f;
  if (this.sphere) {
    var d = 0, u, c = 0;
    if (u = Math.sqrt(t * t + n * n), r = u * 0.5, r > 1)
      return null;
    switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (c = Math.sin(r), d = Math.cos(r)), this.mode) {
      case this.EQUIT:
        r = Math.abs(u) <= Dt ? 0 : Math.asin(n * c / u), t *= c, n = d * u;
        break;
      case this.OBLIQ:
        r = Math.abs(u) <= Dt ? this.lat0 : Math.asin(d * this.sinph0 + n * c * this.cosph0 / u), t *= c * this.cosph0, n = (d - Math.sin(r) * this.sinph0) * u;
        break;
      case this.N_POLE:
        n = -n, r = xt - r;
        break;
      case this.S_POLE:
        r -= xt;
        break;
    }
    s = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, n);
  } else {
    if (f = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t /= this.dd, n *= this.dd, l = Math.sqrt(t * t + n * n), l < Dt)
        return e.x = this.long0, e.y = this.lat0, e;
      a = 2 * Math.asin(0.5 * l / this.rq), i = Math.cos(a), t *= a = Math.sin(a), this.mode === this.OBLIQ ? (f = i * this.sinb1 + n * a * this.cosb1 / l, o = this.qp * f, n = l * this.cosb1 * i - n * this.sinb1 * a) : (f = n * a / l, o = this.qp * f, n = l * i);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), o = t * t + n * n, !o)
        return e.x = this.long0, e.y = this.lat0, e;
      f = 1 - o / this.qp, this.mode === this.S_POLE && (f = -f);
    }
    s = Math.atan2(t, n), r = PV(Math.asin(f), this.apa);
  }
  return e.x = Bt(this.long0 + s), e.y = r, e;
}
var yV = 0.3333333333333333, EV = 0.17222222222222222, CV = 0.10257936507936508, xV = 0.06388888888888888, bV = 0.0664021164021164, OV = 0.016415012942191543;
function TV(e) {
  var t, n = [];
  return n[0] = e * yV, t = e * e, n[0] += t * EV, n[1] = t * xV, t *= e, n[0] += t * CV, n[1] += t * bV, n[2] = t * OV, n;
}
function PV(e, t) {
  var n = e + e;
  return e + t[0] * Math.sin(n) + t[1] * Math.sin(n + n) + t[2] * Math.sin(n + n + n);
}
var MV = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const SV = {
  init: mV,
  forward: gV,
  inverse: vV,
  names: MV,
  S_POLE: hV,
  N_POLE: dV,
  EQUIT: fV,
  OBLIQ: pV
};
function za(e) {
  return Math.abs(e) > 1 && (e = e > 1 ? 1 : -1), Math.asin(e);
}
function IV() {
  Math.abs(this.lat1 + this.lat2) < Dt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ps(this.e3, this.sin_po, this.cos_po), this.qs1 = La(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ps(this.e3, this.sin_po, this.cos_po), this.qs2 = La(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = La(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Dt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function _V(e) {
  var t = e.x, n = e.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var s = La(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * s) / this.ns0, i = this.ns0 * Bt(t - this.long0), a = r * Math.sin(i) + this.x0, o = this.rh - r * Math.cos(i) + this.y0;
  return e.x = a, e.y = o, e;
}
function DV(e) {
  var t, n, s, r, i, a;
  return e.x -= this.x0, e.y = this.rh - e.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(e.x * e.x + e.y * e.y), s = 1) : (t = -Math.sqrt(e.x * e.x + e.y * e.y), s = -1), r = 0, t !== 0 && (r = Math.atan2(s * e.x, s * e.y)), s = t * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - s * s) / (2 * this.ns0)) : (n = (this.c - s * s) / this.ns0, a = this.phi1z(this.e3, n)), i = Bt(r / this.ns0 + this.long0), e.x = i, e.y = a, e;
}
function AV(e, t) {
  var n, s, r, i, a, o = za(0.5 * t);
  if (e < Dt)
    return o;
  for (var l = e * e, f = 1; f <= 25; f++)
    if (n = Math.sin(o), s = Math.cos(o), r = e * n, i = 1 - r * r, a = 0.5 * i * i / s * (t / (1 - l) - n / i + 0.5 / e * Math.log((1 - r) / (1 + r))), o = o + a, Math.abs(a) <= 1e-7)
      return o;
  return null;
}
var LV = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const RV = {
  init: IV,
  forward: _V,
  inverse: DV,
  names: LV,
  phi1z: AV
};
function wV() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function VV(e) {
  var t, n, s, r, i, a, o, l, f = e.x, d = e.y;
  return s = Bt(f - this.long0), t = Math.sin(d), n = Math.cos(d), r = Math.cos(s), a = this.sin_p14 * t + this.cos_p14 * n * r, i = 1, a > 0 || Math.abs(a) <= Dt ? (o = this.x0 + this.a * i * n * Math.sin(s) / a, l = this.y0 + this.a * i * (this.cos_p14 * t - this.sin_p14 * n * r) / a) : (o = this.x0 + this.infinity_dist * n * Math.sin(s), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * n * r)), e.x = o, e.y = l, e;
}
function BV(e) {
  var t, n, s, r, i, a;
  return e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, (t = Math.sqrt(e.x * e.x + e.y * e.y)) ? (r = Math.atan2(t, this.rc), n = Math.sin(r), s = Math.cos(r), a = za(s * this.sin_p14 + e.y * n * this.cos_p14 / t), i = Math.atan2(e.x * n, t * this.cos_p14 * s - e.y * this.sin_p14 * n), i = Bt(this.long0 + i)) : (a = this.phic0, i = 0), e.x = i, e.y = a, e;
}
var NV = ["gnom"];
const FV = {
  init: wV,
  forward: VV,
  inverse: BV,
  names: NV
};
function jV(e, t) {
  var n = 1 - (1 - e * e) / (2 * e) * Math.log((1 - e) / (1 + e));
  if (Math.abs(Math.abs(t) - n) < 1e-6)
    return t < 0 ? -1 * xt : xt;
  for (var s = Math.asin(0.5 * t), r, i, a, o, l = 0; l < 30; l++)
    if (i = Math.sin(s), a = Math.cos(s), o = e * i, r = Math.pow(1 - o * o, 2) / (2 * a) * (t / (1 - e * e) - i / (1 - o * o) + 0.5 / e * Math.log((1 - o) / (1 + o))), s += r, Math.abs(r) <= 1e-10)
      return s;
  return NaN;
}
function UV() {
  this.sphere || (this.k0 = ps(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function WV(e) {
  var t = e.x, n = e.y, s, r, i = Bt(t - this.long0);
  if (this.sphere)
    s = this.x0 + this.a * i * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var a = La(this.e, Math.sin(n));
    s = this.x0 + this.a * this.k0 * i, r = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return e.x = s, e.y = r, e;
}
function $V(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n;
  return this.sphere ? (t = Bt(this.long0 + e.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(e.y / this.a * Math.cos(this.lat_ts))) : (n = jV(this.e, 2 * e.y * this.k0 / this.a), t = Bt(this.long0 + e.x / (this.a * this.k0))), e.x = t, e.y = n, e;
}
var zV = ["cea"];
const KV = {
  init: UV,
  forward: WV,
  inverse: $V,
  names: zV
};
function GV() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function kV(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r = hu(n - this.lat0);
  return e.x = this.x0 + this.a * s * this.rc, e.y = this.y0 + this.a * r, e;
}
function HV(e) {
  var t = e.x, n = e.y;
  return e.x = Bt(this.long0 + (t - this.x0) / (this.a * this.rc)), e.y = hu(this.lat0 + (n - this.y0) / this.a), e;
}
var YV = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const XV = {
  init: GV,
  forward: kV,
  inverse: HV,
  names: YV
};
var IC = 20;
function ZV() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = $c(this.es), this.e1 = zc(this.es), this.e2 = Kc(this.es), this.e3 = Gc(this.es), this.ml0 = this.a * Pi(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function JV(e) {
  var t = e.x, n = e.y, s, r, i, a = Bt(t - this.long0);
  if (i = a * Math.sin(n), this.sphere)
    Math.abs(n) <= Dt ? (s = this.a * a, r = -1 * this.a * this.lat0) : (s = this.a * Math.sin(i) / Math.tan(n), r = this.a * (hu(n - this.lat0) + (1 - Math.cos(i)) / Math.tan(n)));
  else if (Math.abs(n) <= Dt)
    s = this.a * a, r = -1 * this.ml0;
  else {
    var o = eu(this.a, this.e, Math.sin(n)) / Math.tan(n);
    s = o * Math.sin(i), r = this.a * Pi(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + o * (1 - Math.cos(i));
  }
  return e.x = s + this.x0, e.y = r + this.y0, e;
}
function QV(e) {
  var t, n, s, r, i, a, o, l, f;
  if (s = e.x - this.x0, r = e.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= Dt)
      t = Bt(s / this.a + this.long0), n = 0;
    else {
      a = this.lat0 + r / this.a, o = s * s / this.a / this.a + a * a, l = a;
      var d;
      for (i = IC; i; --i)
        if (d = Math.tan(l), f = -1 * (a * (l * d + 1) - l - 0.5 * (l * l + o) * d) / ((l - a) / d - 1), l += f, Math.abs(f) <= Dt) {
          n = l;
          break;
        }
      t = Bt(this.long0 + Math.asin(s * Math.tan(l) / this.a) / Math.sin(n));
    }
  else if (Math.abs(r + this.ml0) <= Dt)
    n = 0, t = Bt(this.long0 + s / this.a);
  else {
    a = (this.ml0 + r) / this.a, o = s * s / this.a / this.a + a * a, l = a;
    var u, c, h, p, g;
    for (i = IC; i; --i)
      if (g = this.e * Math.sin(l), u = Math.sqrt(1 - g * g) * Math.tan(l), c = this.a * Pi(this.e0, this.e1, this.e2, this.e3, l), h = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), p = c / this.a, f = (a * (u * p + 1) - p - 0.5 * u * (p * p + o)) / (this.es * Math.sin(2 * l) * (p * p + o - 2 * a * p) / (4 * u) + (a - p) * (u * h - 2 / Math.sin(2 * l)) - h), l -= f, Math.abs(f) <= Dt) {
        n = l;
        break;
      }
    u = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), t = Bt(this.long0 + Math.asin(s * u / this.a) / Math.sin(n));
  }
  return e.x = t, e.y = n, e;
}
var qV = ["Polyconic", "poly"];
const tB = {
  init: ZV,
  forward: JV,
  inverse: QV,
  names: qV
};
function eB() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function nB(e) {
  var t, n = e.x, s = e.y, r = s - this.lat0, i = n - this.long0, a = r / tc * 1e-5, o = i, l = 1, f = 0;
  for (t = 1; t <= 10; t++)
    l = l * a, f = f + this.A[t] * l;
  var d = f, u = o, c = 1, h = 0, p, g, m = 0, v = 0;
  for (t = 1; t <= 6; t++)
    p = c * d - h * u, g = h * d + c * u, c = p, h = g, m = m + this.B_re[t] * c - this.B_im[t] * h, v = v + this.B_im[t] * c + this.B_re[t] * h;
  return e.x = v * this.a + this.x0, e.y = m * this.a + this.y0, e;
}
function iB(e) {
  var t, n = e.x, s = e.y, r = n - this.x0, i = s - this.y0, a = i / this.a, o = r / this.a, l = 1, f = 0, d, u, c = 0, h = 0;
  for (t = 1; t <= 6; t++)
    d = l * a - f * o, u = f * a + l * o, l = d, f = u, c = c + this.C_re[t] * l - this.C_im[t] * f, h = h + this.C_im[t] * l + this.C_re[t] * f;
  for (var p = 0; p < this.iterations; p++) {
    var g = c, m = h, v, y, E = a, C = o;
    for (t = 2; t <= 6; t++)
      v = g * c - m * h, y = m * c + g * h, g = v, m = y, E = E + (t - 1) * (this.B_re[t] * g - this.B_im[t] * m), C = C + (t - 1) * (this.B_im[t] * g + this.B_re[t] * m);
    g = 1, m = 0;
    var x = this.B_re[1], b = this.B_im[1];
    for (t = 2; t <= 6; t++)
      v = g * c - m * h, y = m * c + g * h, g = v, m = y, x = x + t * (this.B_re[t] * g - this.B_im[t] * m), b = b + t * (this.B_im[t] * g + this.B_re[t] * m);
    var P = x * x + b * b;
    c = (E * x + C * b) / P, h = (C * x - E * b) / P;
  }
  var T = c, O = h, S = 1, L = 0;
  for (t = 1; t <= 9; t++)
    S = S * T, L = L + this.D[t] * S;
  var A = this.lat0 + L * tc * 1e5, D = this.long0 + O;
  return e.x = D, e.y = A, e;
}
var rB = ["New_Zealand_Map_Grid", "nzmg"];
const sB = {
  init: eB,
  forward: nB,
  inverse: iB,
  names: rB
};
function aB() {
}
function oB(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r = this.x0 + this.a * s, i = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return e.x = r, e.y = i, e;
}
function lB(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = Bt(this.long0 + e.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * e.y / this.a)) - Math.PI / 4);
  return e.x = t, e.y = n, e;
}
var uB = ["Miller_Cylindrical", "mill"];
const cB = {
  init: aB,
  forward: oB,
  inverse: lB,
  names: uB
};
var hB = 20;
function dB() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = m1(this.es);
}
function fB(e) {
  var t, n, s = e.x, r = e.y;
  if (s = Bt(s - this.long0), this.sphere) {
    if (!this.m)
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    else
      for (var i = this.n * Math.sin(r), a = hB; a; --a) {
        var o = (this.m * r + Math.sin(r) - i) / (this.m + Math.cos(r));
        if (r -= o, Math.abs(o) < Dt)
          break;
      }
    t = this.a * this.C_x * s * (this.m + Math.cos(r)), n = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), f = Math.cos(r);
    n = this.a * Lf(r, l, f, this.en), t = this.a * s * f / Math.sqrt(1 - this.es * l * l);
  }
  return e.x = t, e.y = n, e;
}
function pB(e) {
  var t, n, s, r;
  return e.x -= this.x0, s = e.x / this.a, e.y -= this.y0, t = e.y / this.a, this.sphere ? (t /= this.C_y, s = s / (this.C_x * (this.m + Math.cos(t))), this.m ? t = za((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = za(Math.sin(t) / this.n)), s = Bt(s + this.long0), t = hu(t)) : (t = g1(e.y / this.a, this.es, this.en), r = Math.abs(t), r < xt ? (r = Math.sin(t), n = this.long0 + e.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), s = Bt(n)) : r - Dt < xt && (s = this.long0)), e.x = s, e.y = t, e;
}
var mB = ["Sinusoidal", "sinu"];
const gB = {
  init: dB,
  forward: fB,
  inverse: pB,
  names: mB
};
function vB() {
}
function yB(e) {
  for (var t = e.x, n = e.y, s = Bt(t - this.long0), r = n, i = Math.PI * Math.sin(n); ; ) {
    var a = -(r + Math.sin(r) - i) / (1 + Math.cos(r));
    if (r += a, Math.abs(a) < Dt)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(n) < Dt && (s = 0);
  var o = 0.900316316158 * this.a * s * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return e.x = o, e.y = l, e;
}
function EB(e) {
  var t, n;
  e.x -= this.x0, e.y -= this.y0, n = e.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), t = Math.asin(n);
  var s = Bt(this.long0 + e.x / (0.900316316158 * this.a * Math.cos(t)));
  s < -Math.PI && (s = -Math.PI), s > Math.PI && (s = Math.PI), n = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var r = Math.asin(n);
  return e.x = s, e.y = r, e;
}
var CB = ["Mollweide", "moll"];
const xB = {
  init: vB,
  forward: yB,
  inverse: EB,
  names: CB
};
function bB() {
  Math.abs(this.lat1 + this.lat2) < Dt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = $c(this.es), this.e1 = zc(this.es), this.e2 = Kc(this.es), this.e3 = Gc(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ps(this.e, this.sinphi, this.cosphi), this.ml1 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Dt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ps(this.e, this.sinphi, this.cosphi), this.ml2 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Pi(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function OB(e) {
  var t = e.x, n = e.y, s;
  if (this.sphere)
    s = this.a * (this.g - n);
  else {
    var r = Pi(this.e0, this.e1, this.e2, this.e3, n);
    s = this.a * (this.g - r);
  }
  var i = this.ns * Bt(t - this.long0), a = this.x0 + s * Math.sin(i), o = this.y0 + this.rh - s * Math.cos(i);
  return e.x = a, e.y = o, e;
}
function TB(e) {
  e.x -= this.x0, e.y = this.rh - e.y + this.y0;
  var t, n, s, r;
  this.ns >= 0 ? (n = Math.sqrt(e.x * e.x + e.y * e.y), t = 1) : (n = -Math.sqrt(e.x * e.x + e.y * e.y), t = -1);
  var i = 0;
  if (n !== 0 && (i = Math.atan2(t * e.x, t * e.y)), this.sphere)
    return r = Bt(this.long0 + i / this.ns), s = hu(this.g - n / this.a), e.x = r, e.y = s, e;
  var a = this.g - n / this.a;
  return s = Vd(a, this.e0, this.e1, this.e2, this.e3), r = Bt(this.long0 + i / this.ns), e.x = r, e.y = s, e;
}
var PB = ["Equidistant_Conic", "eqdc"];
const MB = {
  init: bB,
  forward: OB,
  inverse: TB,
  names: PB
};
function SB() {
  this.R = this.a;
}
function IB(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r, i;
  Math.abs(n) <= Dt && (r = this.x0 + this.R * s, i = this.y0);
  var a = za(2 * Math.abs(n / Math.PI));
  (Math.abs(s) <= Dt || Math.abs(Math.abs(n) - xt) <= Dt) && (r = this.x0, n >= 0 ? i = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : i = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / s - s / Math.PI), l = o * o, f = Math.sin(a), d = Math.cos(a), u = d / (f + d - 1), c = u * u, h = u * (2 / f - 1), p = h * h, g = Math.PI * this.R * (o * (u - p) + Math.sqrt(l * (u - p) * (u - p) - (p + l) * (c - p))) / (p + l);
  s < 0 && (g = -g), r = this.x0 + g;
  var m = l + u;
  return g = Math.PI * this.R * (h * m - o * Math.sqrt((p + l) * (l + 1) - m * m)) / (p + l), n >= 0 ? i = this.y0 + g : i = this.y0 - g, e.x = r, e.y = i, e;
}
function _B(e) {
  var t, n, s, r, i, a, o, l, f, d, u, c, h;
  return e.x -= this.x0, e.y -= this.y0, u = Math.PI * this.R, s = e.x / u, r = e.y / u, i = s * s + r * r, a = -Math.abs(r) * (1 + i), o = a - 2 * r * r + s * s, l = -2 * a + 1 + 2 * r * r + i * i, h = r * r / l + (2 * o * o * o / l / l / l - 9 * a * o / l / l) / 27, f = (a - o * o / 3 / l) / l, d = 2 * Math.sqrt(-f / 3), u = 3 * h / f / d, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), c = Math.acos(u) / 3, e.y >= 0 ? n = (-d * Math.cos(c + Math.PI / 3) - o / 3 / l) * Math.PI : n = -(-d * Math.cos(c + Math.PI / 3) - o / 3 / l) * Math.PI, Math.abs(s) < Dt ? t = this.long0 : t = Bt(this.long0 + Math.PI * (i - 1 + Math.sqrt(1 + 2 * (s * s - r * r) + i * i)) / 2 / s), e.x = t, e.y = n, e;
}
var DB = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const AB = {
  init: SB,
  forward: IB,
  inverse: _B,
  names: DB
};
function LB() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function RB(e) {
  var t = e.x, n = e.y, s = Math.sin(e.y), r = Math.cos(e.y), i = Bt(t - this.long0), a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P, T, O, S, L, A;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Dt ? (e.x = this.x0 + this.a * (xt - n) * Math.sin(i), e.y = this.y0 - this.a * (xt - n) * Math.cos(i), e) : Math.abs(this.sin_p12 + 1) <= Dt ? (e.x = this.x0 + this.a * (xt + n) * Math.sin(i), e.y = this.y0 + this.a * (xt + n) * Math.cos(i), e) : (P = this.sin_p12 * s + this.cos_p12 * r * Math.cos(i), x = Math.acos(P), b = x ? x / Math.sin(x) : 1, e.x = this.x0 + this.a * b * r * Math.sin(i), e.y = this.y0 + this.a * b * (this.cos_p12 * s - this.sin_p12 * r * Math.cos(i)), e) : (a = $c(this.es), o = zc(this.es), l = Kc(this.es), f = Gc(this.es), Math.abs(this.sin_p12 - 1) <= Dt ? (d = this.a * Pi(a, o, l, f, xt), u = this.a * Pi(a, o, l, f, n), e.x = this.x0 + (d - u) * Math.sin(i), e.y = this.y0 - (d - u) * Math.cos(i), e) : Math.abs(this.sin_p12 + 1) <= Dt ? (d = this.a * Pi(a, o, l, f, xt), u = this.a * Pi(a, o, l, f, n), e.x = this.x0 + (d + u) * Math.sin(i), e.y = this.y0 + (d + u) * Math.cos(i), e) : (c = s / r, h = eu(this.a, this.e, this.sin_p12), p = eu(this.a, this.e, s), g = Math.atan((1 - this.es) * c + this.es * h * this.sin_p12 / (p * r)), m = Math.atan2(Math.sin(i), this.cos_p12 * Math.tan(g) - this.sin_p12 * Math.cos(i)), m === 0 ? T = Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : Math.abs(Math.abs(m) - Math.PI) <= Dt ? T = -Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : T = Math.asin(Math.sin(i) * Math.cos(g) / Math.sin(m)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = this.e * this.cos_p12 * Math.cos(m) / Math.sqrt(1 - this.es), E = v * y, C = y * y, O = T * T, S = O * T, L = S * T, A = L * T, x = h * T * (1 - O * C * (1 - C) / 6 + S / 8 * E * (1 - 2 * C) + L / 120 * (C * (4 - 7 * C) - 3 * v * v * (1 - 7 * C)) - A / 48 * E), e.x = this.x0 + x * Math.sin(m), e.y = this.y0 + x * Math.cos(m), e));
}
function wB(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P, T;
  return this.sphere ? (t = Math.sqrt(e.x * e.x + e.y * e.y), t > 2 * xt * this.a ? void 0 : (n = t / this.a, s = Math.sin(n), r = Math.cos(n), i = this.long0, Math.abs(t) <= Dt ? a = this.lat0 : (a = za(r * this.sin_p12 + e.y * s * this.cos_p12 / t), o = Math.abs(this.lat0) - xt, Math.abs(o) <= Dt ? this.lat0 >= 0 ? i = Bt(this.long0 + Math.atan2(e.x, -e.y)) : i = Bt(this.long0 - Math.atan2(-e.x, e.y)) : i = Bt(this.long0 + Math.atan2(e.x * s, t * this.cos_p12 * r - e.y * this.sin_p12 * s))), e.x = i, e.y = a, e)) : (l = $c(this.es), f = zc(this.es), d = Kc(this.es), u = Gc(this.es), Math.abs(this.sin_p12 - 1) <= Dt ? (c = this.a * Pi(l, f, d, u, xt), t = Math.sqrt(e.x * e.x + e.y * e.y), h = c - t, a = Vd(h / this.a, l, f, d, u), i = Bt(this.long0 + Math.atan2(e.x, -1 * e.y)), e.x = i, e.y = a, e) : Math.abs(this.sin_p12 + 1) <= Dt ? (c = this.a * Pi(l, f, d, u, xt), t = Math.sqrt(e.x * e.x + e.y * e.y), h = t - c, a = Vd(h / this.a, l, f, d, u), i = Bt(this.long0 + Math.atan2(e.x, e.y)), e.x = i, e.y = a, e) : (t = Math.sqrt(e.x * e.x + e.y * e.y), m = Math.atan2(e.x, e.y), p = eu(this.a, this.e, this.sin_p12), v = Math.cos(m), y = this.e * this.cos_p12 * v, E = -y * y / (1 - this.es), C = 3 * this.es * (1 - E) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), x = t / p, b = x - E * (1 + E) * Math.pow(x, 3) / 6 - C * (1 + 3 * E) * Math.pow(x, 4) / 24, P = 1 - E * b * b / 2 - x * b * b * b / 6, g = Math.asin(this.sin_p12 * Math.cos(b) + this.cos_p12 * Math.sin(b) * v), i = Bt(this.long0 + Math.asin(Math.sin(m) * Math.sin(b) / Math.cos(g))), T = Math.sin(g), a = Math.atan2((T - this.es * P * this.sin_p12) * Math.tan(g), T * (1 - this.es)), e.x = i, e.y = a, e));
}
var VB = ["Azimuthal_Equidistant", "aeqd"];
const BB = {
  init: LB,
  forward: RB,
  inverse: wB,
  names: VB
};
function NB() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function FB(e) {
  var t, n, s, r, i, a, o, l, f = e.x, d = e.y;
  return s = Bt(f - this.long0), t = Math.sin(d), n = Math.cos(d), r = Math.cos(s), a = this.sin_p14 * t + this.cos_p14 * n * r, i = 1, (a > 0 || Math.abs(a) <= Dt) && (o = this.a * i * n * Math.sin(s), l = this.y0 + this.a * i * (this.cos_p14 * t - this.sin_p14 * n * r)), e.x = o, e.y = l, e;
}
function jB(e) {
  var t, n, s, r, i, a, o;
  return e.x -= this.x0, e.y -= this.y0, t = Math.sqrt(e.x * e.x + e.y * e.y), n = za(t / this.a), s = Math.sin(n), r = Math.cos(n), a = this.long0, Math.abs(t) <= Dt ? (o = this.lat0, e.x = a, e.y = o, e) : (o = za(r * this.sin_p14 + e.y * s * this.cos_p14 / t), i = Math.abs(this.lat0) - xt, Math.abs(i) <= Dt ? (this.lat0 >= 0 ? a = Bt(this.long0 + Math.atan2(e.x, -e.y)) : a = Bt(this.long0 - Math.atan2(-e.x, e.y)), e.x = a, e.y = o, e) : (a = Bt(this.long0 + Math.atan2(e.x * s, t * this.cos_p14 * r - e.y * this.sin_p14 * s)), e.x = a, e.y = o, e));
}
var UB = ["ortho"];
const WB = {
  init: NB,
  forward: FB,
  inverse: jB,
  names: UB
};
var un = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, De = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function $B() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= xt - _e / 2 ? this.face = un.TOP : this.lat0 <= -(xt - _e / 2) ? this.face = un.BOTTOM : Math.abs(this.long0) <= _e ? this.face = un.FRONT : Math.abs(this.long0) <= xt + _e ? this.face = this.long0 > 0 ? un.RIGHT : un.LEFT : this.face = un.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function zB(e) {
  var t = { x: 0, y: 0 }, n, s, r, i, a, o, l = { value: 0 };
  if (e.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(e.y)) : n = e.y, s = e.x, this.face === un.TOP)
    i = xt - n, s >= _e && s <= xt + _e ? (l.value = De.AREA_0, r = s - xt) : s > xt + _e || s <= -(xt + _e) ? (l.value = De.AREA_1, r = s > 0 ? s - Mn : s + Mn) : s > -(xt + _e) && s <= -_e ? (l.value = De.AREA_2, r = s + xt) : (l.value = De.AREA_3, r = s);
  else if (this.face === un.BOTTOM)
    i = xt + n, s >= _e && s <= xt + _e ? (l.value = De.AREA_0, r = -s + xt) : s < _e && s >= -_e ? (l.value = De.AREA_1, r = -s) : s < -_e && s >= -(xt + _e) ? (l.value = De.AREA_2, r = -s - xt) : (l.value = De.AREA_3, r = s > 0 ? -s + Mn : -s - Mn);
  else {
    var f, d, u, c, h, p, g;
    this.face === un.RIGHT ? s = Ul(s, +xt) : this.face === un.BACK ? s = Ul(s, +Mn) : this.face === un.LEFT && (s = Ul(s, -xt)), c = Math.sin(n), h = Math.cos(n), p = Math.sin(s), g = Math.cos(s), f = h * g, d = h * p, u = c, this.face === un.FRONT ? (i = Math.acos(f), r = Ch(i, u, d, l)) : this.face === un.RIGHT ? (i = Math.acos(d), r = Ch(i, u, -f, l)) : this.face === un.BACK ? (i = Math.acos(-f), r = Ch(i, u, -d, l)) : this.face === un.LEFT ? (i = Math.acos(-d), r = Ch(i, u, f, l)) : (i = r = 0, l.value = De.AREA_0);
  }
  return o = Math.atan(12 / Mn * (r + Math.acos(Math.sin(r) * Math.cos(_e)) - xt)), a = Math.sqrt((1 - Math.cos(i)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === De.AREA_1 ? o += xt : l.value === De.AREA_2 ? o += Mn : l.value === De.AREA_3 && (o += 1.5 * Mn), t.x = a * Math.cos(o), t.y = a * Math.sin(o), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, e.x = t.x, e.y = t.y, e;
}
function KB(e) {
  var t = { lam: 0, phi: 0 }, n, s, r, i, a, o, l, f, d, u = { value: 0 };
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, s = Math.atan(Math.sqrt(e.x * e.x + e.y * e.y)), n = Math.atan2(e.y, e.x), e.x >= 0 && e.x >= Math.abs(e.y) ? u.value = De.AREA_0 : e.y >= 0 && e.y >= Math.abs(e.x) ? (u.value = De.AREA_1, n -= xt) : e.x < 0 && -e.x >= Math.abs(e.y) ? (u.value = De.AREA_2, n = n < 0 ? n + Mn : n - Mn) : (u.value = De.AREA_3, n += xt), d = Mn / 12 * Math.tan(n), a = Math.sin(d) / (Math.cos(d) - 1 / Math.sqrt(2)), o = Math.atan(a), r = Math.cos(n), i = Math.tan(s), l = 1 - r * r * i * i * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === un.TOP)
    f = Math.acos(l), t.phi = xt - f, u.value === De.AREA_0 ? t.lam = o + xt : u.value === De.AREA_1 ? t.lam = o < 0 ? o + Mn : o - Mn : u.value === De.AREA_2 ? t.lam = o - xt : t.lam = o;
  else if (this.face === un.BOTTOM)
    f = Math.acos(l), t.phi = f - xt, u.value === De.AREA_0 ? t.lam = -o + xt : u.value === De.AREA_1 ? t.lam = -o : u.value === De.AREA_2 ? t.lam = -o - xt : t.lam = o < 0 ? -o - Mn : -o + Mn;
  else {
    var c, h, p;
    c = l, d = c * c, d >= 1 ? p = 0 : p = Math.sqrt(1 - d) * Math.sin(o), d += p * p, d >= 1 ? h = 0 : h = Math.sqrt(1 - d), u.value === De.AREA_1 ? (d = h, h = -p, p = d) : u.value === De.AREA_2 ? (h = -h, p = -p) : u.value === De.AREA_3 && (d = h, h = p, p = -d), this.face === un.RIGHT ? (d = c, c = -h, h = d) : this.face === un.BACK ? (c = -c, h = -h) : this.face === un.LEFT && (d = c, c = h, h = -d), t.phi = Math.acos(-p) - xt, t.lam = Math.atan2(h, c), this.face === un.RIGHT ? t.lam = Ul(t.lam, -xt) : this.face === un.BACK ? t.lam = Ul(t.lam, -Mn) : this.face === un.LEFT && (t.lam = Ul(t.lam, +xt));
  }
  if (this.es !== 0) {
    var g, m, v;
    g = t.phi < 0 ? 1 : 0, m = Math.tan(t.phi), v = this.b / Math.sqrt(m * m + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), g && (t.phi = -t.phi);
  }
  return t.lam += this.long0, e.x = t.lam, e.y = t.phi, e;
}
function Ch(e, t, n, s) {
  var r;
  return e < Dt ? (s.value = De.AREA_0, r = 0) : (r = Math.atan2(t, n), Math.abs(r) <= _e ? s.value = De.AREA_0 : r > _e && r <= xt + _e ? (s.value = De.AREA_1, r -= xt) : r > xt + _e || r <= -(xt + _e) ? (s.value = De.AREA_2, r = r >= 0 ? r - Mn : r + Mn) : (s.value = De.AREA_3, r += xt)), r;
}
function Ul(e, t) {
  var n = e + t;
  return n < -Mn ? n += mc : n > +Mn && (n -= mc), n;
}
var GB = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const kB = {
  init: $B,
  forward: zB,
  inverse: KB,
  names: GB
};
var Kg = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], Xu = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], E1 = 0.8487, C1 = 1.3523, x1 = ls / 5, HB = 1 / x1, Il = 18, Bd = function(e, t) {
  return e[0] + t * (e[1] + t * (e[2] + t * e[3]));
}, YB = function(e, t) {
  return e[1] + t * (2 * e[2] + t * 3 * e[3]);
};
function XB(e, t, n, s) {
  for (var r = t; s; --s) {
    var i = e(r);
    if (r -= i, Math.abs(i) < n)
      break;
  }
  return r;
}
function ZB() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function JB(e) {
  var t = Bt(e.x - this.long0), n = Math.abs(e.y), s = Math.floor(n * x1);
  s < 0 ? s = 0 : s >= Il && (s = Il - 1), n = ls * (n - HB * s);
  var r = {
    x: Bd(Kg[s], n) * t,
    y: Bd(Xu[s], n)
  };
  return e.y < 0 && (r.y = -r.y), r.x = r.x * this.a * E1 + this.x0, r.y = r.y * this.a * C1 + this.y0, r;
}
function QB(e) {
  var t = {
    x: (e.x - this.x0) / (this.a * E1),
    y: Math.abs(e.y - this.y0) / (this.a * C1)
  };
  if (t.y >= 1)
    t.x /= Kg[Il][0], t.y = e.y < 0 ? -xt : xt;
  else {
    var n = Math.floor(t.y * Il);
    for (n < 0 ? n = 0 : n >= Il && (n = Il - 1); ; )
      if (Xu[n][0] > t.y)
        --n;
      else if (Xu[n + 1][0] <= t.y)
        ++n;
      else
        break;
    var s = Xu[n], r = 5 * (t.y - s[0]) / (Xu[n + 1][0] - s[0]);
    r = XB(function(i) {
      return (Bd(s, i) - t.y) / YB(s, i);
    }, r, Dt, 100), t.x /= Bd(Kg[n], r), t.y = (5 * n + r) * Qn, e.y < 0 && (t.y = -t.y);
  }
  return t.x = Bt(t.x + this.long0), t;
}
var qB = ["Robinson", "robin"];
const tN = {
  init: ZB,
  forward: JB,
  inverse: QB,
  names: qB
};
function eN() {
  this.name = "geocent";
}
function nN(e) {
  var t = a1(e, this.es, this.a);
  return t;
}
function iN(e) {
  var t = o1(e, this.es, this.a, this.b);
  return t;
}
var rN = ["Geocentric", "geocentric", "geocent", "Geocent"];
const sN = {
  init: eN,
  forward: nN,
  inverse: iN,
  names: rN
};
var ui = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Vu = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function aN() {
  if (Object.keys(Vu).forEach((function(n) {
    if (typeof this[n] > "u")
      this[n] = Vu[n].def;
    else {
      if (Vu[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      Vu[n].num && (this[n] = parseFloat(this[n]));
    }
    Vu[n].degrees && (this[n] = this[n] * Qn);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - xt) < Dt ? this.mode = this.lat0 < 0 ? ui.S_POLE : ui.N_POLE : Math.abs(this.lat0) < Dt ? this.mode = ui.EQUIT : (this.mode = ui.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var e = this.tilt, t = this.azi;
  this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(e), this.sw = Math.sin(e);
}
function oN(e) {
  e.x -= this.long0;
  var t = Math.sin(e.y), n = Math.cos(e.y), s = Math.cos(e.x), r, i;
  switch (this.mode) {
    case ui.OBLIQ:
      i = this.sinph0 * t + this.cosph0 * n * s;
      break;
    case ui.EQUIT:
      i = n * s;
      break;
    case ui.S_POLE:
      i = -t;
      break;
    case ui.N_POLE:
      i = t;
      break;
  }
  switch (i = this.pn1 / (this.p - i), r = i * n * Math.sin(e.x), this.mode) {
    case ui.OBLIQ:
      i *= this.cosph0 * t - this.sinph0 * n * s;
      break;
    case ui.EQUIT:
      i *= t;
      break;
    case ui.N_POLE:
      i *= -(n * s);
      break;
    case ui.S_POLE:
      i *= n * s;
      break;
  }
  var a, o;
  return a = i * this.cg + r * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), r = (r * this.cg - i * this.sg) * this.cw * o, i = a * o, e.x = r * this.a, e.y = i * this.a, e;
}
function lN(e) {
  e.x /= this.a, e.y /= this.a;
  var t = { x: e.x, y: e.y }, n, s, r;
  r = 1 / (this.pn1 - e.y * this.sw), n = this.pn1 * e.x * r, s = this.pn1 * e.y * this.cw * r, e.x = n * this.cg + s * this.sg, e.y = s * this.cg - n * this.sg;
  var i = Dr(e.x, e.y);
  if (Math.abs(i) < Dt)
    t.x = 0, t.y = e.y;
  else {
    var a, o;
    switch (o = 1 - i * i * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / i + i / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case ui.OBLIQ:
        t.y = Math.asin(a * this.sinph0 + e.y * o * this.cosph0 / i), e.y = (a - this.sinph0 * Math.sin(t.y)) * i, e.x *= o * this.cosph0;
        break;
      case ui.EQUIT:
        t.y = Math.asin(e.y * o / i), e.y = a * i, e.x *= o;
        break;
      case ui.N_POLE:
        t.y = Math.asin(a), e.y = -e.y;
        break;
      case ui.S_POLE:
        t.y = -Math.asin(a);
        break;
    }
    t.x = Math.atan2(e.x, e.y);
  }
  return e.x = t.x + this.long0, e.y = t.y, e;
}
var uN = ["Tilted_Perspective", "tpers"];
const cN = {
  init: aN,
  forward: oN,
  inverse: lN,
  names: uN
};
function hN() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var e = 1 - this.es, t = 1 / e;
    this.radius_p = Math.sqrt(e), this.radius_p2 = e, this.radius_p_inv2 = t, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function dN(e) {
  var t = e.x, n = e.y, s, r, i, a;
  if (t = t - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var o = this.radius_p / Dr(this.radius_p * Math.cos(n), Math.sin(n));
    if (r = o * Math.cos(t) * Math.cos(n), i = o * Math.sin(t) * Math.cos(n), a = o * Math.sin(n), (this.radius_g - r) * r - i * i - a * a * this.radius_p_inv2 < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    s = this.radius_g - r, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(i / Dr(a, s)), e.y = this.radius_g_1 * Math.atan(a / s)) : (e.x = this.radius_g_1 * Math.atan(i / s), e.y = this.radius_g_1 * Math.atan(a / Dr(i, s)));
  } else
    this.shape === "sphere" && (s = Math.cos(n), r = Math.cos(t) * s, i = Math.sin(t) * s, a = Math.sin(n), s = this.radius_g - r, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(i / Dr(a, s)), e.y = this.radius_g_1 * Math.atan(a / s)) : (e.x = this.radius_g_1 * Math.atan(i / s), e.y = this.radius_g_1 * Math.atan(a / Dr(i, s))));
  return e.x = e.x * this.a, e.y = e.y * this.a, e;
}
function fN(e) {
  var t = -1, n = 0, s = 0, r, i, a, o;
  if (e.x = e.x / this.a, e.y = e.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (s = Math.tan(e.y / this.radius_g_1), n = Math.tan(e.x / this.radius_g_1) * Dr(1, s)) : (n = Math.tan(e.x / this.radius_g_1), s = Math.tan(e.y / this.radius_g_1) * Dr(1, n));
    var l = s / this.radius_p;
    if (r = n * n + l * l + t * t, i = 2 * this.radius_g * t, a = i * i - 4 * r * this.C, a < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    o = (-i - Math.sqrt(a)) / (2 * r), t = this.radius_g + o * t, n *= o, s *= o, e.x = Math.atan2(n, t), e.y = Math.atan(s * Math.cos(e.x) / t), e.y = Math.atan(this.radius_p_inv2 * Math.tan(e.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (s = Math.tan(e.y / this.radius_g_1), n = Math.tan(e.x / this.radius_g_1) * Math.sqrt(1 + s * s)) : (n = Math.tan(e.x / this.radius_g_1), s = Math.tan(e.y / this.radius_g_1) * Math.sqrt(1 + n * n)), r = n * n + s * s + t * t, i = 2 * this.radius_g * t, a = i * i - 4 * r * this.C, a < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    o = (-i - Math.sqrt(a)) / (2 * r), t = this.radius_g + o * t, n *= o, s *= o, e.x = Math.atan2(n, t), e.y = Math.atan(s * Math.cos(e.x) / t);
  }
  return e.x = e.x + this.long0, e;
}
var pN = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const mN = {
  init: hN,
  forward: dN,
  inverse: fN,
  names: pN
};
function gN(e) {
  e.Proj.projections.add(sd), e.Proj.projections.add(ad), e.Proj.projections.add(b2), e.Proj.projections.add(L2), e.Proj.projections.add(F2), e.Proj.projections.add(z2), e.Proj.projections.add(X2), e.Proj.projections.add(tV), e.Proj.projections.add(sV), e.Proj.projections.add(cV), e.Proj.projections.add(SV), e.Proj.projections.add(RV), e.Proj.projections.add(FV), e.Proj.projections.add(KV), e.Proj.projections.add(XV), e.Proj.projections.add(tB), e.Proj.projections.add(sB), e.Proj.projections.add(cB), e.Proj.projections.add(gB), e.Proj.projections.add(xB), e.Proj.projections.add(MB), e.Proj.projections.add(AB), e.Proj.projections.add(BB), e.Proj.projections.add(WB), e.Proj.projections.add(kB), e.Proj.projections.add(tN), e.Proj.projections.add(sN), e.Proj.projections.add(cN), e.Proj.projections.add(mN);
}
dn.defaultDatum = "WGS84";
dn.Proj = hs;
dn.WGS84 = new dn.Proj("WGS84");
dn.Point = tu;
dn.toPoint = l1;
dn.defs = Oi;
dn.nadgrid = Tw;
dn.transform = wd;
dn.mgrs = Uw;
dn.version = "__VERSION__";
gN(dn);
function b1(e) {
  const t = Object.keys(e.defs), n = t.length;
  let s, r;
  for (s = 0; s < n; ++s) {
    const i = t[s];
    if (!Wt(i)) {
      const a = e.defs(i);
      let o = a.units;
      !o && a.projName === "longlat" && (o = "degrees"), ey(
        new Of({
          code: i,
          axisOrientation: a.axis,
          metersPerUnit: a.to_meter,
          units: o
        })
      );
    }
  }
  for (s = 0; s < n; ++s) {
    const i = t[s], a = Wt(i);
    for (r = 0; r < n; ++r) {
      const o = t[r], l = Wt(o);
      if (!zT(i, o))
        if (e.defs[i] === e.defs[o])
          Mg([a, l]);
        else {
          const f = e(i, o);
          gD(
            a,
            l,
            VE(a, l, f.forward),
            VE(l, a, f.inverse)
          );
        }
    }
  }
}
function vN(e) {
  const t = e.split(":")[1];
  dn.defs("http://www.opengis.net/gml/srs/epsg.xml#" + t, dn.defs(e)), b1(dn);
}
function zy(e) {
  return dn.defs(e);
}
function O1(e = fi.namedProjections) {
  dn.defs(e), b1(dn), e.forEach((t) => {
    ey(Wt(t[0])), vN(t[0]), zy(t[0]).masterportal = !0;
  });
}
function yN() {
  return Object.keys(dn.defs).map((t) => Object.assign(dn.defs(t), { name: t })).filter(function(t, n, s) {
    return n === s.indexOf(t) && t.masterportal === !0;
  });
}
function Ky(e) {
  return e.getView().getProjection().getCode();
}
function _C(e) {
  return typeof e == "string" ? zy(e) : e;
}
function Gy(e, t, n) {
  const s = _C(e), r = _C(t);
  if (s && r && n)
    return dn(s, r, n);
  console.error(`Cancelled coordinate transformation with invalid parameters: ${e}; ${t}; ${n}`);
}
function EN(e, t, n) {
  return Gy(t, Ky(e), n);
}
function CN(e, t, n) {
  return Gy(Ky(e), t, n);
}
const xN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getMapProjection: Ky,
  getProjection: zy,
  getProjections: yN,
  registerProjections: O1,
  transform: Gy,
  transformFromMapProjection: CN,
  transformToMapProjection: EN
}, Symbol.toStringTag, { value: "Module" }));
let _l = [];
function T1(e = fi.layerConf, t) {
  if (Array.isArray(e)) {
    if (_l = e, typeof t == "function") {
      t(_l);
      return;
    }
    return;
  }
  const n = new XMLHttpRequest();
  n.open("GET", e), n.timeout = 1e4, n.send(), n.onload = function() {
    try {
      _l = JSON.parse(n.responseText);
    } catch (s) {
      return console.error("An error occured when parsing the response after loading '" + e + "':", s), t(!1, s);
    }
    return typeof t == "function" ? t(_l) : !0;
  }, n.onerror = function(s) {
    console.error("An error occured when trying to fetch services from '" + e + "':", s), t(!1, s);
  };
}
function Ka(e) {
  const t = Object.keys(e);
  return _l.find((n) => t.every((s) => n[s] === e[s])) || null;
}
function bN() {
  return _l;
}
function ON(e, t) {
  const n = Ka({ id: e });
  if (n && typeof t == "string") {
    const s = n.gfiAttributes && n.gfiAttributes[t];
    return typeof s == "string" ? s : null;
  } else if (n)
    return n.gfiAttributes || null;
  return null;
}
const TN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDisplayNamesOfFeatureAttributes: ON,
  getLayerList: bN,
  getLayerWhere: Ka,
  initializeLayerList: T1
}, Symbol.toStringTag, { value: "Module" })), Pa = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class PN extends lu {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    t = t || {};
    const n = Object.assign({}, t);
    delete n.preload, delete n.useInterimTilesOnError, super(n), this.on, this.once, this.un, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Pa.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set(Pa.PRELOAD, t);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Pa.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set(Pa.USE_INTERIM_TILES_ON_ERROR, t);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(t) {
    return super.getData(t);
  }
}
const MN = PN, P1 = 0.5, SN = 10, DC = 0.25;
class IN {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(t, n, s, r, i, a) {
    this.sourceProj_ = t, this.targetProj_ = n;
    let o = {};
    const l = ja(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(y) {
      const E = y[0] + "/" + y[1];
      return o[E] || (o[E] = l(y)), o[E];
    }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = i * i, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && ye(r) == ye(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ye(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? ye(this.targetProj_.getExtent()) : null;
    const f = fs(s), d = To(s), u = Xl(s), c = Oo(s), h = this.transformInv_(f), p = this.transformInv_(d), g = this.transformInv_(u), m = this.transformInv_(c), v = SN + (a ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          bg(s) / (a * a * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      f,
      d,
      u,
      c,
      h,
      p,
      g,
      m,
      v
    ), this.wrapsXInSource_) {
      let y = 1 / 0;
      this.triangles_.forEach(function(E, C, x) {
        y = Math.min(
          y,
          E.source[0][0],
          E.source[1][0],
          E.source[2][0]
        );
      }), this.triangles_.forEach(
        (function(E) {
          if (Math.max(
            E.source[0][0],
            E.source[1][0],
            E.source[2][0]
          ) - y > this.sourceWorldWidth_ / 2) {
            const C = [
              [E.source[0][0], E.source[0][1]],
              [E.source[1][0], E.source[1][1]],
              [E.source[2][0], E.source[2][1]]
            ];
            C[0][0] - y > this.sourceWorldWidth_ / 2 && (C[0][0] -= this.sourceWorldWidth_), C[1][0] - y > this.sourceWorldWidth_ / 2 && (C[1][0] -= this.sourceWorldWidth_), C[2][0] - y > this.sourceWorldWidth_ / 2 && (C[2][0] -= this.sourceWorldWidth_);
            const x = Math.min(
              C[0][0],
              C[1][0],
              C[2][0]
            );
            Math.max(
              C[0][0],
              C[1][0],
              C[2][0]
            ) - x < this.sourceWorldWidth_ / 2 && (E.source = C);
          }
        }).bind(this)
      );
    }
    o = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(t, n, s, r, i, a) {
    this.triangles_.push({
      source: [r, i, a],
      target: [t, n, s]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(t, n, s, r, i, a, o, l, f) {
    const d = Yl([i, a, o, l]), u = this.sourceWorldWidth_ ? ye(d) / this.sourceWorldWidth_ : null, c = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), h = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
    let p = !1;
    if (f > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = Yl([t, n, s, r]);
        p = ye(m) / this.targetWorldWidth_ > DC || p;
      }
      !h && this.sourceProj_.isGlobal() && u && (p = u > DC || p);
    }
    if (!p && this.maxSourceExtent_ && isFinite(d[0]) && isFinite(d[1]) && isFinite(d[2]) && isFinite(d[3]) && !cn(d, this.maxSourceExtent_))
      return;
    let g = 0;
    if (!p && (!isFinite(i[0]) || !isFinite(i[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (f > 0)
        p = !0;
      else if (g = (!isFinite(i[0]) || !isFinite(i[1]) ? 8 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 4 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), g != 1 && g != 2 && g != 4 && g != 8)
        return;
    }
    if (f > 0) {
      if (!p) {
        const m = [(t[0] + s[0]) / 2, (t[1] + s[1]) / 2], v = this.transformInv_(m);
        let y;
        h ? y = (_a(i[0], c) + _a(o[0], c)) / 2 - _a(v[0], c) : y = (i[0] + o[0]) / 2 - v[0];
        const E = (i[1] + o[1]) / 2 - v[1];
        p = y * y + E * E > this.errorThresholdSquared_;
      }
      if (p) {
        if (Math.abs(t[0] - s[0]) <= Math.abs(t[1] - s[1])) {
          const m = [(n[0] + s[0]) / 2, (n[1] + s[1]) / 2], v = this.transformInv_(m), y = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], E = this.transformInv_(y);
          this.addQuad_(
            t,
            n,
            m,
            y,
            i,
            a,
            v,
            E,
            f - 1
          ), this.addQuad_(
            y,
            m,
            s,
            r,
            E,
            v,
            o,
            l,
            f - 1
          );
        } else {
          const m = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], v = this.transformInv_(m), y = [(s[0] + r[0]) / 2, (s[1] + r[1]) / 2], E = this.transformInv_(y);
          this.addQuad_(
            t,
            m,
            y,
            r,
            i,
            v,
            E,
            l,
            f - 1
          ), this.addQuad_(
            m,
            n,
            s,
            y,
            v,
            a,
            o,
            E,
            f - 1
          );
        }
        return;
      }
    }
    if (h) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    g & 11 || this.addTriangle_(t, s, r, i, o, l), g & 14 || this.addTriangle_(t, s, n, i, o, a), g && (g & 13 || this.addTriangle_(n, r, t, a, l, i), g & 7 || this.addTriangle_(n, r, s, a, l, o));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const t = Ni();
    return this.triangles_.forEach(function(n, s, r) {
      const i = n.source;
      Qu(t, i[0]), Qu(t, i[1]), Qu(t, i[2]);
    }), t;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const M1 = IN;
let Cp;
const S1 = [];
function AC(e, t, n, s, r) {
  e.beginPath(), e.moveTo(0, 0), e.lineTo(t, n), e.lineTo(s, r), e.closePath(), e.save(), e.clip(), e.fillRect(0, 0, Math.max(t, s) + 1, Math.max(n, r)), e.restore();
}
function xp(e, t) {
  return Math.abs(e[t * 4] - 210) > 2 || Math.abs(e[t * 4 + 3] - 0.75 * 255) > 2;
}
function _N() {
  if (Cp === void 0) {
    const e = document.createElement("canvas").getContext("2d");
    e.globalCompositeOperation = "lighter", e.fillStyle = "rgba(210, 0, 0, 0.75)", AC(e, 4, 5, 4, 0), AC(e, 4, 5, 0, 5);
    const t = e.getImageData(0, 0, 3, 3).data;
    Cp = xp(t, 0) || xp(t, 4) || xp(t, 8);
  }
  return Cp;
}
function yc(e, t, n, s) {
  const r = ji(n, t, e);
  let i = RE(
    t,
    s,
    n
  );
  const a = t.getMetersPerUnit();
  a !== void 0 && (i *= a);
  const o = e.getMetersPerUnit();
  o !== void 0 && (i /= o);
  const l = e.getExtent();
  if (!l || Vc(l, r)) {
    const f = RE(e, i, r) / i;
    isFinite(f) && f > 0 && (i /= f);
  }
  return i;
}
function DN(e, t, n, s) {
  const r = Fi(n);
  let i = yc(
    e,
    t,
    r,
    s
  );
  return (!isFinite(i) || i <= 0) && Zv(n, function(a) {
    return i = yc(
      e,
      t,
      a,
      s
    ), isFinite(i) && i > 0;
  }), i;
}
function I1(e, t, n, s, r, i, a, o, l, f, d, u) {
  const c = Ii(
    Math.round(n * e),
    Math.round(n * t),
    S1
  );
  if (u || (c.imageSmoothingEnabled = !1), l.length === 0)
    return c.canvas;
  c.scale(n, n);
  function h(C) {
    return Math.round(C * n) / n;
  }
  c.globalCompositeOperation = "lighter";
  const p = Ni();
  l.forEach(function(C, x, b) {
    UT(p, C.extent);
  });
  const g = ye(p), m = In(p), v = Ii(
    Math.round(n * g / s),
    Math.round(n * m / s)
  );
  u || (v.imageSmoothingEnabled = !1);
  const y = n / s;
  l.forEach(function(C, x, b) {
    const P = C.extent[0] - p[0], T = -(C.extent[3] - p[3]), O = ye(C.extent), S = In(C.extent);
    C.image.width > 0 && C.image.height > 0 && v.drawImage(
      C.image,
      f,
      f,
      C.image.width - 2 * f,
      C.image.height - 2 * f,
      P * y,
      T * y,
      O * y,
      S * y
    );
  });
  const E = fs(a);
  return o.getTriangles().forEach(function(C, x, b) {
    const P = C.source, T = C.target;
    let O = P[0][0], S = P[0][1], L = P[1][0], A = P[1][1], D = P[2][0], _ = P[2][1];
    const w = h((T[0][0] - E[0]) / i), B = h(
      -(T[0][1] - E[1]) / i
    ), j = h((T[1][0] - E[0]) / i), k = h(
      -(T[1][1] - E[1]) / i
    ), X = h((T[2][0] - E[0]) / i), rt = h(
      -(T[2][1] - E[1]) / i
    ), et = O, Z = S;
    O = 0, S = 0, L -= et, A -= Z, D -= et, _ -= Z;
    const dt = [
      [L, A, 0, 0, j - w],
      [D, _, 0, 0, X - w],
      [0, 0, L, A, k - B],
      [0, 0, D, _, rt - B]
    ], vt = hD(dt);
    if (vt) {
      if (c.save(), c.beginPath(), _N() || !u) {
        c.moveTo(j, k);
        const bt = 4, it = w - j, R = B - k;
        for (let V = 0; V < bt; V++)
          c.lineTo(
            j + h((V + 1) * it / bt),
            k + h(V * R / (bt - 1))
          ), V != bt - 1 && c.lineTo(
            j + h((V + 1) * it / bt),
            k + h((V + 1) * R / (bt - 1))
          );
        c.lineTo(X, rt);
      } else
        c.moveTo(j, k), c.lineTo(w, B), c.lineTo(X, rt);
      c.clip(), c.transform(
        vt[0],
        vt[2],
        vt[1],
        vt[3],
        w,
        B
      ), c.translate(
        p[0] - et,
        p[3] - Z
      ), c.scale(
        s / n,
        -s / n
      ), c.drawImage(v.canvas, 0, 0), c.restore();
    }
  }), d && (c.save(), c.globalCompositeOperation = "source-over", c.strokeStyle = "black", c.lineWidth = 1, o.getTriangles().forEach(function(C, x, b) {
    const P = C.target, T = (P[0][0] - E[0]) / i, O = -(P[0][1] - E[1]) / i, S = (P[1][0] - E[0]) / i, L = -(P[1][1] - E[1]) / i, A = (P[2][0] - E[0]) / i, D = -(P[2][1] - E[1]) / i;
    c.beginPath(), c.moveTo(S, L), c.lineTo(T, O), c.lineTo(A, D), c.closePath(), c.stroke();
  }), c.restore()), c.canvas;
}
class AN extends Df {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(t, n, s, r, i, a, o, l, f, d, u, c) {
    super(i, It.IDLE, { interpolate: !!c }), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = o, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = n, this.targetTileGrid_ = r, this.wrappedTileCoord_ = a || i, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const h = r.getTileCoordExtent(
      this.wrappedTileCoord_
    ), p = this.targetTileGrid_.getExtent();
    let g = this.sourceTileGrid_.getExtent();
    const m = p ? zs(h, p) : h;
    if (bg(m) === 0) {
      this.state = It.EMPTY;
      return;
    }
    const v = t.getExtent();
    v && (g ? g = zs(g, v) : g = v);
    const y = r.getResolution(
      this.wrappedTileCoord_[0]
    ), E = DN(
      t,
      s,
      m,
      y
    );
    if (!isFinite(E) || E <= 0) {
      this.state = It.EMPTY;
      return;
    }
    const C = d !== void 0 ? d : P1;
    if (this.triangulation_ = new M1(
      t,
      s,
      m,
      g,
      E * C,
      y
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = It.EMPTY;
      return;
    }
    this.sourceZ_ = n.getZForResolution(E);
    let x = this.triangulation_.calculateSourceExtent();
    if (g && (t.canWrapX() ? (x[1] = hn(
      x[1],
      g[1],
      g[3]
    ), x[3] = hn(
      x[3],
      g[1],
      g[3]
    )) : x = zs(x, g)), !bg(x))
      this.state = It.EMPTY;
    else {
      const b = n.getTileRangeForExtentAndZ(
        x,
        this.sourceZ_
      );
      for (let P = b.minX; P <= b.maxX; P++)
        for (let T = b.minY; T <= b.maxY; T++) {
          const O = f(this.sourceZ_, P, T, o);
          O && this.sourceTiles_.push(O);
        }
      this.sourceTiles_.length === 0 && (this.state = It.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = [];
    if (this.sourceTiles_.forEach(
      (function(n, s, r) {
        n && n.getState() == It.LOADED && t.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(n.tileCoord),
          image: n.getImage()
        });
      }).bind(this)
    ), this.sourceTiles_.length = 0, t.length === 0)
      this.state = It.ERROR;
    else {
      const n = this.wrappedTileCoord_[0], s = this.targetTileGrid_.getTileSize(n), r = typeof s == "number" ? s : s[0], i = typeof s == "number" ? s : s[1], a = this.targetTileGrid_.getResolution(n), o = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = I1(
        r,
        i,
        this.pixelRatio_,
        o,
        this.sourceTileGrid_.getExtent(),
        a,
        l,
        this.triangulation_,
        t,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = It.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == It.IDLE) {
      this.state = It.LOADING, this.changed();
      let t = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(
        (function(n, s, r) {
          const i = n.getState();
          if (i == It.IDLE || i == It.LOADING) {
            t++;
            const a = ge(
              n,
              Kt.CHANGE,
              function(o) {
                const l = n.getState();
                (l == It.LOADED || l == It.ERROR || l == It.EMPTY) && (We(a), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
              },
              this
            );
            this.sourcesListenerKeys_.push(a);
          }
        }).bind(this)
      ), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(n, s, r) {
        n.getState() == It.IDLE && n.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(We), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (gy(this.canvas_.getContext("2d")), S1.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const Gg = AN;
class LN extends Ty {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(t) {
    super(t), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = Ni(), this.tmpTileRange_ = new JP(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(t) {
    const n = this.getLayer(), s = t.getState(), r = n.getUseInterimTilesOnError();
    return s == It.LOADED || s == It.EMPTY || s == It.ERROR && !r;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(t, n, s, r) {
    const i = r.pixelRatio, a = r.viewState.projection, o = this.getLayer();
    let f = o.getSource().getTile(t, n, s, i, a);
    return f.getState() == It.ERROR && o.getUseInterimTilesOnError() && o.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(f) || (f = f.getInterimTile()), f;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(t) {
    const n = this.frameState;
    if (!n)
      return null;
    const s = this.getLayer(), r = An(
      n.pixelToCoordinateTransform,
      t.slice()
    ), i = s.getExtent();
    if (i && !Vc(i, r))
      return null;
    const a = n.pixelRatio, o = n.viewState.projection, l = n.viewState, f = s.getRenderSource(), d = f.getTileGridForProjection(l.projection), u = f.getTilePixelRatio(n.pixelRatio);
    for (let c = d.getZForResolution(l.resolution); c >= d.getMinZoom(); --c) {
      const h = d.getTileCoordForCoordAndZ(r, c), p = f.getTile(
        c,
        h[1],
        h[2],
        a,
        o
      );
      if (!(p instanceof jP || p instanceof Gg) || p instanceof Gg && p.getState() === It.EMPTY)
        return null;
      if (p.getState() !== It.LOADED)
        continue;
      const g = d.getOrigin(c), m = ti(d.getTileSize(c)), v = d.getResolution(c), y = Math.floor(
        u * ((r[0] - g[0]) / v - h[1] * m[0])
      ), E = Math.floor(
        u * ((g[1] - r[1]) / v - h[2] * m[1])
      ), C = Math.round(
        u * f.getGutterForProjection(l.projection)
      );
      return this.getImageData(p.getImage(), y + C, E + C);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, n, s) {
    return this.isDrawableTile(s) ? super.loadedTileCallback(t, n, s) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = t.layerStatesArray[t.layerIndex], r = t.viewState, i = r.projection, a = r.resolution, o = r.center, l = r.rotation, f = t.pixelRatio, d = this.getLayer(), u = d.getSource(), c = u.getRevision(), h = u.getTileGridForProjection(i), p = h.getZForResolution(a, u.zDirection), g = h.getResolution(p);
    let m = t.extent;
    const v = t.viewState.resolution, y = u.getTilePixelRatio(f), E = Math.round(ye(m) / v * f), C = Math.round(In(m) / v * f), x = s.extent && js(s.extent);
    x && (m = zs(
      m,
      js(s.extent)
    ));
    const b = g * E / 2 / y, P = g * C / 2 / y, T = [
      o[0] - b,
      o[1] - P,
      o[0] + b,
      o[1] + P
    ], O = h.getTileRangeForExtentAndZ(m, p), S = {};
    S[p] = {};
    const L = this.createLoadedTileFinder(
      u,
      i,
      S
    ), A = this.tmpExtent, D = this.tmpTileRange_;
    this.newTiles_ = !1;
    const _ = l ? Og(
      r.center,
      v,
      l,
      t.size
    ) : void 0;
    for (let dt = O.minX; dt <= O.maxX; ++dt)
      for (let vt = O.minY; vt <= O.maxY; ++vt) {
        if (l && !h.tileCoordIntersectsViewport([p, dt, vt], _))
          continue;
        const bt = this.getTile(p, dt, vt, t);
        if (this.isDrawableTile(bt)) {
          const V = Xt(this);
          if (bt.getState() == It.LOADED) {
            S[p][bt.tileCoord.toString()] = bt;
            let tt = bt.inTransition(V);
            tt && s.opacity !== 1 && (bt.endTransition(V), tt = !1), !this.newTiles_ && (tt || !this.renderedTiles.includes(bt)) && (this.newTiles_ = !0);
          }
          if (bt.getAlpha(V, t.time) === 1)
            continue;
        }
        const it = h.getTileCoordChildTileRange(
          bt.tileCoord,
          D,
          A
        );
        let R = !1;
        it && (R = L(p + 1, it)), R || h.forEachTileCoordParentTileRange(
          bt.tileCoord,
          L,
          D,
          A
        );
      }
    const w = g / a * f / y;
    Fr(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / f,
      1 / f,
      l,
      -E / 2,
      -C / 2
    );
    const B = kv(this.pixelTransform);
    this.useContainer(n, B, this.getBackground(t));
    const j = this.context, k = j.canvas;
    xf(this.inversePixelTransform, this.pixelTransform), Fr(
      this.tempTransform,
      E / 2,
      C / 2,
      w,
      w,
      0,
      -E / 2,
      -C / 2
    ), k.width != E || k.height != C ? (k.width = E, k.height = C) : this.containerReused || j.clearRect(0, 0, E, C), x && this.clipUnrotated(j, t, x), u.getInterpolate() || (j.imageSmoothingEnabled = !1), this.preRender(j, t), this.renderedTiles.length = 0;
    let X = Object.keys(S).map(Number);
    X.sort(Ao);
    let rt, et, Z;
    s.opacity === 1 && (!this.containerReused || u.getOpaque(t.viewState.projection)) ? X = X.reverse() : (rt = [], et = []);
    for (let dt = X.length - 1; dt >= 0; --dt) {
      const vt = X[dt], bt = u.getTilePixelSize(
        vt,
        f,
        i
      ), R = h.getResolution(vt) / g, V = bt[0] * R * w, tt = bt[1] * R * w, Y = h.getTileCoordForCoordAndZ(
        fs(T),
        vt
      ), $ = h.getTileCoordExtent(Y), z = An(this.tempTransform, [
        y * ($[0] - T[0]) / g,
        y * (T[3] - $[3]) / g
      ]), at = y * u.getGutterForProjection(i), ct = S[vt];
      for (const St in ct) {
        const F = (
          /** @type {import("../../ImageTile.js").default} */
          ct[St]
        ), M = F.tileCoord, I = Y[1] - M[1], N = Math.round(z[0] - (I - 1) * V), G = Y[2] - M[2], nt = Math.round(z[1] - (G - 1) * tt), lt = Math.round(z[0] - I * V), yt = Math.round(z[1] - G * tt), Lt = N - lt, Nt = nt - yt, Jt = p === vt, J = Jt && F.getAlpha(Xt(this), t.time) !== 1;
        let ft = !1;
        if (!J)
          if (rt) {
            Z = [lt, yt, lt + Lt, yt, lt + Lt, yt + Nt, lt, yt + Nt];
            for (let Ct = 0, Mt = rt.length; Ct < Mt; ++Ct)
              if (p !== vt && vt < et[Ct]) {
                const Ot = rt[Ct];
                cn(
                  [lt, yt, lt + Lt, yt + Nt],
                  [Ot[0], Ot[3], Ot[4], Ot[7]]
                ) && (ft || (j.save(), ft = !0), j.beginPath(), j.moveTo(Z[0], Z[1]), j.lineTo(Z[2], Z[3]), j.lineTo(Z[4], Z[5]), j.lineTo(Z[6], Z[7]), j.moveTo(Ot[6], Ot[7]), j.lineTo(Ot[4], Ot[5]), j.lineTo(Ot[2], Ot[3]), j.lineTo(Ot[0], Ot[1]), j.clip());
              }
            rt.push(Z), et.push(vt);
          } else
            j.clearRect(lt, yt, Lt, Nt);
        this.drawTileImage(
          F,
          t,
          lt,
          yt,
          Lt,
          Nt,
          at,
          Jt
        ), rt && !J ? (ft && j.restore(), this.renderedTiles.unshift(F)) : this.renderedTiles.push(F), this.updateUsedTiles(t.usedTiles, u, F);
      }
    }
    return this.renderedRevision = c, this.renderedResolution = g, this.extentChanged = !this.renderedExtent_ || !wo(this.renderedExtent_, T), this.renderedExtent_ = T, this.renderedPixelRatio = f, this.renderedProjection = i, this.manageTilePyramid(
      t,
      u,
      h,
      f,
      i,
      m,
      p,
      d.getPreload()
    ), this.scheduleExpireCache(t, u), this.postRender(j, t), s.extent && j.restore(), j.imageSmoothingEnabled = !0, B !== k.style.transform && (k.style.transform = B), this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(t, n, s, r, i, a, o, l) {
    const f = this.getTileImage(t);
    if (!f)
      return;
    const d = Xt(this), u = n.layerStatesArray[n.layerIndex], c = u.opacity * (l ? t.getAlpha(d, n.time) : 1), h = c !== this.context.globalAlpha;
    h && (this.context.save(), this.context.globalAlpha = c), this.context.drawImage(
      f,
      o,
      o,
      f.width - 2 * o,
      f.height - 2 * o,
      s,
      r,
      i,
      a
    ), h && this.context.restore(), c !== u.opacity ? n.animate = !0 : l && t.endTransition(d);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const t = this.context;
    return t ? t.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(t) {
    return t.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(t, n) {
    if (n.canExpireCache()) {
      const s = (function(r, i, a) {
        const o = Xt(r);
        o in a.usedTiles && r.expireCache(
          a.viewState.projection,
          a.usedTiles[o]
        );
      }).bind(null, n);
      t.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        s
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(t, n, s) {
    const r = Xt(n);
    r in t || (t[r] = {}), t[r][s.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(t, n, s, r, i, a, o, l, f) {
    const d = Xt(n);
    d in t.wantedTiles || (t.wantedTiles[d] = {});
    const u = t.wantedTiles[d], c = t.tileQueue, h = s.getMinZoom(), p = t.viewState.rotation, g = p ? Og(
      t.viewState.center,
      t.viewState.resolution,
      p,
      t.size
    ) : void 0;
    let m = 0, v, y, E, C, x, b;
    for (b = h; b <= o; ++b)
      for (y = s.getTileRangeForExtentAndZ(a, b, y), E = s.getResolution(b), C = y.minX; C <= y.maxX; ++C)
        for (x = y.minY; x <= y.maxY; ++x)
          p && !s.tileCoordIntersectsViewport([b, C, x], g) || (o - b <= l ? (++m, v = n.getTile(b, C, x, r, i), v.getState() == It.IDLE && (u[v.getKey()] = !0, c.isKeyQueued(v.getKey()) || c.enqueue([
            v,
            d,
            s.getTileCoordCenter(v.tileCoord),
            E
          ])), f !== void 0 && f(v)) : n.useTile(b, C, x, i));
    n.updateCacheSize(m, i);
  }
}
const _1 = LN;
class RN extends MN {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new _1(this);
  }
}
const kc = RN;
class wN extends lu {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    t = t || {}, super(t);
  }
}
const VN = wN;
class BN extends Ty {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(t) {
    super(t), this.image_ = null;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = t.layerStatesArray[t.layerIndex], s = t.pixelRatio, r = t.viewState, i = r.resolution, a = this.getLayer().getSource(), o = t.viewHints;
    let l = t.extent;
    if (n.extent !== void 0 && (l = zs(
      l,
      js(n.extent, r.projection)
    )), !o[tn.ANIMATING] && !o[tn.INTERACTING] && !bf(l))
      if (a) {
        const f = r.projection, d = a.getImage(
          l,
          i,
          s,
          f
        );
        d && (this.loadImage(d) ? this.image_ = d : d.getState() === ce.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(t) {
    const n = this.frameState;
    if (!n)
      return null;
    const s = this.getLayer(), r = An(
      n.pixelToCoordinateTransform,
      t.slice()
    ), i = s.getExtent();
    if (i && !Vc(i, r))
      return null;
    const a = this.image_.getExtent(), o = this.image_.getImage(), l = ye(a), f = Math.floor(
      o.width * ((r[0] - a[0]) / l)
    );
    if (f < 0 || f >= o.width)
      return null;
    const d = In(a), u = Math.floor(
      o.height * ((a[3] - r[1]) / d)
    );
    return u < 0 || u >= o.height ? null : this.getImageData(o, f, u);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = this.image_, r = s.getExtent(), i = s.getResolution(), a = s.getPixelRatio(), o = t.layerStatesArray[t.layerIndex], l = t.pixelRatio, f = t.viewState, d = f.center, u = f.resolution, c = l * i / (u * a), h = t.extent, p = f.resolution, g = f.rotation, m = Math.round(ye(h) / p * l), v = Math.round(In(h) / p * l);
    Fr(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / l,
      1 / l,
      g,
      -m / 2,
      -v / 2
    ), xf(this.inversePixelTransform, this.pixelTransform);
    const y = kv(this.pixelTransform);
    this.useContainer(n, y, this.getBackground(t));
    const E = this.context, C = E.canvas;
    C.width != m || C.height != v ? (C.width = m, C.height = v) : this.containerReused || E.clearRect(0, 0, m, v);
    let x = !1, b = !0;
    if (o.extent) {
      const L = js(
        o.extent,
        f.projection
      );
      b = cn(L, t.extent), x = b && !Ar(L, t.extent), x && this.clipUnrotated(E, t, L);
    }
    const P = s.getImage(), T = Fr(
      this.tempTransform,
      m / 2,
      v / 2,
      c,
      c,
      0,
      a * (r[0] - d[0]) / i,
      a * (d[1] - r[3]) / i
    );
    this.renderedResolution = i * l / a;
    const O = P.width * T[0], S = P.height * T[3];
    if (this.getLayer().getSource().getInterpolate() || (E.imageSmoothingEnabled = !1), this.preRender(E, t), b && O >= 0.5 && S >= 0.5) {
      const L = T[4], A = T[5], D = o.opacity;
      let _;
      D !== 1 && (_ = E.globalAlpha, E.globalAlpha = D), E.drawImage(P, 0, 0, +P.width, +P.height, L, A, O, S), D !== 1 && (E.globalAlpha = _);
    }
    return this.postRender(E, t), x && E.restore(), E.imageSmoothingEnabled = !0, y !== C.style.transform && (C.style.transform = y), this.container;
  }
}
const NN = BN;
class FN extends VN {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new NN(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(t) {
    return super.getData(t);
  }
}
const Rf = FN, bp = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
}, jN = [0, 0, 0], fa = 5;
class UN {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(t) {
    this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, Zt(
      R_(
        this.resolutions_,
        function(r, i) {
          return i - r;
        },
        !0
      ),
      17
    );
    let n;
    if (!t.origins) {
      for (let r = 0, i = this.resolutions_.length - 1; r < i; ++r)
        if (!n)
          n = this.resolutions_[r] / this.resolutions_[r + 1];
        else if (this.resolutions_[r] / this.resolutions_[r + 1] !== n) {
          n = void 0;
          break;
        }
    }
    this.zoomFactor_ = n, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, Zt(this.origins_.length == this.resolutions_.length, 20));
    const s = t.extent;
    s !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = fs(s)), Zt(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, Zt(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : Sy, Zt(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    ), this.extent_ = s !== void 0 ? s : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map(function(r, i) {
      const a = new JP(
        Math.min(0, r[0]),
        Math.max(r[0] - 1, -1),
        Math.min(0, r[1]),
        Math.max(r[1] - 1, -1)
      );
      if (s) {
        const o = this.getTileRangeForExtentAndZ(s, i);
        a.minX = Math.max(o.minX, a.minX), a.maxX = Math.min(o.maxX, a.maxX), a.minY = Math.max(o.minY, a.minY), a.maxY = Math.min(o.maxY, a.maxY);
      }
      return a;
    }, this) : s && this.calculateTileRanges_(s);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(t, n, s) {
    const r = this.getTileRangeForExtentAndZ(t, n);
    for (let i = r.minX, a = r.maxX; i <= a; ++i)
      for (let o = r.minY, l = r.maxY; o <= l; ++o)
        s([n, i, o]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(t, n, s, r) {
    let i, a, o, l = null, f = t[0] - 1;
    for (this.zoomFactor_ === 2 ? (a = t[1], o = t[2]) : l = this.getTileCoordExtent(t, r); f >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (a = Math.floor(a / 2), o = Math.floor(o / 2), i = ol(a, a, o, o, s)) : i = this.getTileRangeForExtentAndZ(
        l,
        f,
        s
      ), n(f, i))
        return !0;
      --f;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(t) {
    return this.origin_ ? this.origin_ : this.origins_[t];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(t) {
    return this.resolutions_[t];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(t, n, s) {
    if (t[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const i = t[1] * 2, a = t[2] * 2;
        return ol(
          i,
          i + 1,
          a,
          a + 1,
          n
        );
      }
      const r = this.getTileCoordExtent(
        t,
        s || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        r,
        t[0] + 1,
        n
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(t, n, s) {
    if (n > this.maxZoom || n < this.minZoom)
      return null;
    const r = t[0], i = t[1], a = t[2];
    if (n === r)
      return ol(
        i,
        a,
        i,
        a,
        s
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, n - r), f = Math.floor(i * l), d = Math.floor(a * l);
      if (n < r)
        return ol(f, f, d, d, s);
      const u = Math.floor(l * (i + 1)) - 1, c = Math.floor(l * (a + 1)) - 1;
      return ol(f, u, d, c, s);
    }
    const o = this.getTileCoordExtent(t, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(o, n, s);
  }
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */
  getTileRangeExtent(t, n, s) {
    const r = this.getOrigin(t), i = this.getResolution(t), a = ti(this.getTileSize(t), this.tmpSize_), o = r[0] + n.minX * a[0] * i, l = r[0] + (n.maxX + 1) * a[0] * i, f = r[1] + n.minY * a[1] * i, d = r[1] + (n.maxY + 1) * a[1] * i;
    return er(o, f, l, d, s);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(t, n, s) {
    const r = jN;
    this.getTileCoordForXYAndZ_(t[0], t[3], n, !1, r);
    const i = r[1], a = r[2];
    return this.getTileCoordForXYAndZ_(t[2], t[1], n, !0, r), ol(
      i,
      r[1],
      a,
      r[2],
      s
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(t) {
    const n = this.getOrigin(t[0]), s = this.getResolution(t[0]), r = ti(this.getTileSize(t[0]), this.tmpSize_);
    return [
      n[0] + (t[1] + 0.5) * r[0] * s,
      n[1] - (t[2] + 0.5) * r[1] * s
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(t, n) {
    const s = this.getOrigin(t[0]), r = this.getResolution(t[0]), i = ti(this.getTileSize(t[0]), this.tmpSize_), a = s[0] + t[1] * i[0] * r, o = s[1] - (t[2] + 1) * i[1] * r, l = a + i[0] * r, f = o + i[1] * r;
    return er(a, o, l, f, n);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(t, n, s) {
    return this.getTileCoordForXYAndResolution_(
      t[0],
      t[1],
      n,
      !1,
      s
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(t, n, s, r, i) {
    const a = this.getZForResolution(s), o = s / this.getResolution(a), l = this.getOrigin(a), f = ti(this.getTileSize(a), this.tmpSize_);
    let d = o * (t - l[0]) / s / f[0], u = o * (l[1] - n) / s / f[1];
    return r ? (d = xa(d, fa) - 1, u = xa(u, fa) - 1) : (d = Tl(d, fa), u = Tl(u, fa)), uC(a, d, u, i);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(t, n, s, r, i) {
    const a = this.getOrigin(s), o = this.getResolution(s), l = ti(this.getTileSize(s), this.tmpSize_);
    let f = (t - a[0]) / o / l[0], d = (a[1] - n) / o / l[1];
    return r ? (f = xa(f, fa) - 1, d = xa(d, fa) - 1) : (f = Tl(f, fa), d = Tl(d, fa)), uC(s, f, d, i);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(t, n, s) {
    return this.getTileCoordForXYAndZ_(
      t[0],
      t[1],
      n,
      !1,
      s
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(t) {
    return this.resolutions_[t[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(t) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(t) {
    return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(t, n) {
    const s = vf(
      this.resolutions_,
      t,
      n || 0
    );
    return hn(s, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(t, n) {
    return aP(
      n,
      0,
      n.length,
      2,
      this.getTileCoordExtent(t)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(t) {
    const n = this.resolutions_.length, s = new Array(n);
    for (let r = this.minZoom; r < n; ++r)
      s[r] = this.getTileRangeForExtentAndZ(t, r);
    this.fullTileRanges_ = s;
  }
}
const du = UN;
function ky(e) {
  let t = e.getDefaultTileGrid();
  return t || (t = KN(e), e.setDefaultTileGrid(t)), t;
}
function WN(e, t, n) {
  const s = t[0], r = e.getTileCoordCenter(t), i = wf(n);
  if (Vc(i, r))
    return t;
  {
    const a = ye(i), o = Math.ceil(
      (i[0] - r[0]) / a
    );
    return r[0] += a * o, e.getTileCoordForCoordAndZ(r, s);
  }
}
function $N(e, t, n, s) {
  s = s !== void 0 ? s : "top-left";
  const r = D1(e, t, n);
  return new du({
    extent: e,
    origin: Z_(e, s),
    resolutions: r,
    tileSize: n
  });
}
function zN(e) {
  const t = e || {}, n = t.extent || Wt("EPSG:3857").getExtent(), s = {
    extent: n,
    minZoom: t.minZoom,
    tileSize: t.tileSize,
    resolutions: D1(
      n,
      t.maxZoom,
      t.tileSize,
      t.maxResolution
    )
  };
  return new du(s);
}
function D1(e, t, n, s) {
  t = t !== void 0 ? t : UP, n = ti(n !== void 0 ? n : Sy);
  const r = In(e), i = ye(e);
  s = s > 0 ? s : Math.max(i / n[0], r / n[1]);
  const a = t + 1, o = new Array(a);
  for (let l = 0; l < a; ++l)
    o[l] = s / Math.pow(2, l);
  return o;
}
function KN(e, t, n, s) {
  const r = wf(e);
  return $N(r, t, n, s);
}
function wf(e) {
  e = Wt(e);
  let t = e.getExtent();
  if (!t) {
    const n = 180 * Zl.degrees / e.getMetersPerUnit();
    t = er(-n, -n, n, n);
  }
  return t;
}
class GN extends Py {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      projection: t.projection,
      state: t.state,
      wrapX: t.wrapX,
      interpolate: t.interpolate
    }), this.on, this.once, this.un, this.opaque_ = t.opaque !== void 0 ? t.opaque : !1, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
    const n = [256, 256];
    this.tileGrid && ti(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), n), this.tileCache = new Ny(t.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = t.key || "", this.tileOptions = {
      transition: t.transition,
      interpolate: t.interpolate
    }, this.zDirection = t.zDirection ? t.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t);
    s && s.expireCache(n);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(t, n, s, r) {
    const i = this.getTileCacheForProjection(t);
    if (!i)
      return !1;
    let a = !0, o, l, f;
    for (let d = s.minX; d <= s.maxX; ++d)
      for (let u = s.minY; u <= s.maxY; ++u)
        l = cu(n, d, u), f = !1, i.containsKey(l) && (o = /** @type {!import("../Tile.js").default} */
        i.get(l), f = o.getState() === It.LOADED, f && (f = r(o) !== !1)), f || (a = !1);
    return a;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(t) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(t) {
    this.key_ !== t && (this.key_ = t, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(t) {
    return this.opaque_;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.tileGrid ? this.tileGrid.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(t, n, s, r, i) {
    return Gt();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    return this.tileGrid ? this.tileGrid : ky(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(t) {
    const n = this.getProjection();
    return Zt(
      n === null || dr(n, t),
      68
      // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(t, n, s) {
    const r = this.getTileGridForProjection(s), i = this.getTilePixelRatio(n), a = ti(r.getTileSize(t), this.tmpSize);
    return i == 1 ? a : hP(a, i, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(t, n) {
    n = n !== void 0 ? n : this.getProjection();
    const s = this.getTileGridForProjection(n);
    return this.getWrapX() && n.isGlobal() && (t = WN(s, t, n)), LR(t, s) ? t : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(t, n) {
    const s = this.getTileCacheForProjection(n);
    t > s.highWaterMark && (s.highWaterMark = t);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(t, n, s, r) {
  }
}
class kN extends Ui {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(t, n) {
    super(t), this.tile = n;
  }
}
const A1 = GN;
function HN(e, t) {
  const n = /\{z\}/g, s = /\{x\}/g, r = /\{y\}/g, i = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(a, o, l) {
      if (a)
        return e.replace(n, a[0].toString()).replace(s, a[1].toString()).replace(r, a[2].toString()).replace(i, function() {
          const f = a[0], d = t.getFullTileRange(f);
          return Zt(d, 55), (d.getHeight() - a[2] - 1).toString();
        });
    }
  );
}
function L1(e, t) {
  const n = e.length, s = new Array(n);
  for (let r = 0; r < n; ++r)
    s[r] = HN(e[r], t);
  return kg(s);
}
function kg(e) {
  return e.length === 1 ? e[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(t, n, s) {
      if (t) {
        const r = XP(t), i = _a(r, e.length);
        return e[i](t, n, s);
      } else
        return;
    }
  );
}
function R1(e) {
  const t = [];
  let n = /\{([a-z])-([a-z])\}/.exec(e);
  if (n) {
    const s = n[1].charCodeAt(0), r = n[2].charCodeAt(0);
    let i;
    for (i = s; i <= r; ++i)
      t.push(e.replace(n[0], String.fromCharCode(i)));
    return t;
  }
  if (n = /\{(\d+)-(\d+)\}/.exec(e), n) {
    const s = parseInt(n[2], 10);
    for (let r = parseInt(n[1], 10); r <= s; r++)
      t.push(e.replace(n[0], r.toString()));
    return t;
  }
  return t.push(e), t;
}
class Hy extends A1 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      opaque: t.opaque,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tilePixelRatio: t.tilePixelRatio,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === Hy.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const n = (
      /** @type {import("../Tile.js").default} */
      t.target
    ), s = Xt(n), r = n.getState();
    let i;
    r == It.LOADING ? (this.tileLoadingKeys_[s] = !0, i = bp.TILELOADSTART) : s in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[s], i = r == It.ERROR ? bp.TILELOADERROR : r == It.LOADED ? bp.TILELOADEND : void 0), i != null && this.dispatchEvent(new kN(i, n));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(t) {
    this.tileCache.clear(), this.tileLoadFunction = t, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(t, n) {
    this.tileUrlFunction = t, this.tileCache.pruneExceptNewestZ(), typeof n < "u" ? this.setKey(n) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(t) {
    const n = R1(t);
    this.urls = n, this.setUrls(n);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(t) {
    this.urls = t;
    const n = t.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(L1(t, this.tileGrid), n) : this.setKey(n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(t, n, s) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(t, n, s) {
    const r = cu(t, n, s);
    this.tileCache.containsKey(r) && this.tileCache.get(r);
  }
}
const w1 = Hy;
class YN extends w1 {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      opaque: t.opaque,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : XN,
      tilePixelRatio: t.tilePixelRatio,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : jP, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const t in this.tileCacheForProjection)
      if (this.tileCacheForProjection[t].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t);
    this.tileCache.expireCache(
      this.tileCache == s ? n : {}
    );
    for (const r in this.tileCacheForProjection) {
      const i = this.tileCacheForProjection[r];
      i.expireCache(i == s ? n : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(t) {
    return this.getProjection() && t && !dr(this.getProjection(), t) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let t = super.getKey();
    return this.getInterpolate() || (t += ":disable-interpolation"), t;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(t) {
    return this.getProjection() && t && !dr(this.getProjection(), t) ? !1 : super.getOpaque(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    const n = this.getProjection();
    if (this.tileGrid && (!n || dr(n, t)))
      return this.tileGrid;
    {
      const s = Xt(t);
      return s in this.tileGridForProjection || (this.tileGridForProjection[s] = ky(t)), this.tileGridForProjection[s];
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(t) {
    const n = this.getProjection();
    if (!n || dr(n, t))
      return this.tileCache;
    {
      const s = Xt(t);
      return s in this.tileCacheForProjection || (this.tileCacheForProjection[s] = new Ny(
        this.tileCache.highWaterMark
      )), this.tileCacheForProjection[s];
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(t, n, s, r, i, a) {
    const o = [t, n, s], l = this.getTileCoordForTileUrlFunction(
      o,
      i
    ), f = l ? this.tileUrlFunction(l, r, i) : void 0, d = new this.tileClass(
      o,
      f !== void 0 ? It.IDLE : It.EMPTY,
      f !== void 0 ? f : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return d.key = a, d.addEventListener(Kt.CHANGE, this.handleTileChange.bind(this)), d;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(t, n, s, r, i) {
    const a = this.getProjection();
    if (!a || !i || dr(a, i))
      return this.getTileInternal(
        t,
        n,
        s,
        r,
        a || i
      );
    {
      const o = this.getTileCacheForProjection(i), l = [t, n, s];
      let f;
      const d = HP(l);
      o.containsKey(d) && (f = o.get(d));
      const u = this.getKey();
      if (f && f.key == u)
        return f;
      {
        const c = this.getTileGridForProjection(a), h = this.getTileGridForProjection(i), p = this.getTileCoordForTileUrlFunction(
          l,
          i
        ), g = new Gg(
          a,
          c,
          i,
          h,
          l,
          p,
          this.getTilePixelRatio(r),
          this.getGutter(),
          (function(m, v, y, E) {
            return this.getTileInternal(m, v, y, E, a);
          }).bind(this),
          this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_,
          this.getInterpolate()
        );
        return g.key = u, f ? (g.interimTile = f, g.refreshInterimChain(), o.replace(d, g)) : o.set(d, g), g;
      }
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @protected
   */
  getTileInternal(t, n, s, r, i) {
    let a = null;
    const o = cu(t, n, s), l = this.getKey();
    if (!this.tileCache.containsKey(o))
      a = this.createTile_(t, n, s, r, i, l), this.tileCache.set(o, a);
    else if (a = this.tileCache.get(o), a.key != l) {
      const f = a;
      a = this.createTile_(t, n, s, r, i, l), f.getState() == It.IDLE ? a.interimTile = f.interimTile : a.interimTile = f, a.refreshInterimChain(), this.tileCache.replace(o, a);
    }
    return a;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(t) {
    if (this.renderReprojectionEdges_ != t) {
      this.renderReprojectionEdges_ = t;
      for (const n in this.tileCacheForProjection)
        this.tileCacheForProjection[n].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(t, n) {
    const s = Wt(t);
    if (s) {
      const r = Xt(s);
      r in this.tileGridForProjection || (this.tileGridForProjection[r] = n);
    }
  }
  clear() {
    super.clear();
    for (const t in this.tileCacheForProjection)
      this.tileCacheForProjection[t].clear();
  }
}
function XN(e, t) {
  e.getImage().src = t;
}
const Yy = YN, Ma = "1.3.0";
function nu(e, t) {
  const n = [];
  Object.keys(t).forEach(function(r) {
    t[r] !== null && t[r] !== void 0 && n.push(r + "=" + encodeURIComponent(t[r]));
  });
  const s = n.join("&");
  return e = e.replace(/[?&]$/, ""), e += e.includes("?") ? "&" : "?", e + s;
}
class ZN extends Yy {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(t) {
    t = t || /** @type {Options} */
    {};
    const n = Object.assign({}, t.params), s = "TRANSPARENT" in n ? n.TRANSPARENT : !0;
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      opaque: !s,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.params_ = n, this.v13_ = !0, this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.tmpExtent_ = Ni(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, n, s, r) {
    const i = Wt(s), a = this.getProjection();
    let o = this.getTileGrid();
    o || (o = this.getTileGridForProjection(i));
    const l = o.getZForResolution(n, this.zDirection), f = o.getTileCoordForCoordAndZ(t, l);
    if (o.getResolutions().length <= f[0])
      return;
    let d = o.getResolution(f[0]), u = o.getTileCoordExtent(f, this.tmpExtent_), c = ti(o.getTileSize(f[0]), this.tmpSize);
    const h = this.gutter_;
    h !== 0 && (c = UE(c, h, this.tmpSize), u = wr(u, d * h, u)), a && a !== i && (d = yc(
      a,
      i,
      t,
      d
    ), u = Fc(
      u,
      i,
      a
    ), t = ji(t, i, a));
    const p = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(p, this.params_, r);
    const g = Math.floor((t[0] - u[0]) / d), m = Math.floor((u[3] - t[1]) / d);
    return p[this.v13_ ? "I" : "X"] = g, p[this.v13_ ? "J" : "Y"] = m, this.getRequestUrl_(
      f,
      c,
      u,
      1,
      a || i,
      p
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, n) {
    if (this.urls[0] === void 0)
      return;
    const s = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (n === void 0 || n.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      s.LAYER = r;
    }
    if (t !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, i = 28e-5;
      s.SCALE = t * r / i;
    }
    return Object.assign(s, n), nu(
      /** @type {string} */
      this.urls[0],
      s
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(t, n, s, r, i, a) {
    const o = this.urls;
    if (!o)
      return;
    if (a.WIDTH = n[0], a.HEIGHT = n[1], a[this.v13_ ? "CRS" : "SRS"] = i.getCode(), "STYLES" in this.params_ || (a.STYLES = ""), r != 1)
      switch (this.serverType_) {
        case "geoserver":
          const u = 90 * r + 0.5 | 0;
          "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + u : a.FORMAT_OPTIONS = "dpi:" + u;
          break;
        case "mapserver":
          a.MAP_RESOLUTION = 90 * r;
          break;
        case "carmentaserver":
        case "qgis":
          a.DPI = 90 * r;
          break;
        default:
          Zt(!1, 52);
          break;
      }
    const l = i.getAxisOrientation(), f = s;
    if (this.v13_ && l.substr(0, 2) == "ne") {
      let u;
      u = s[0], f[0] = s[1], f[1] = u, u = s[2], f[2] = s[3], f[3] = u;
    }
    a.BBOX = f.join(",");
    let d;
    if (o.length == 1)
      d = o[0];
    else {
      const u = _a(XP(t), o.length);
      d = o[u];
    }
    return nu(d, a);
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : t;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let t = 0;
    const n = [];
    for (const s in this.params_)
      n[t++] = s + "-" + this.params_[s];
    return n.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(t) {
    Object.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const t = this.params_.VERSION || Ma;
    this.v13_ = KT(t, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(t, n, s) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(s)), r.getResolutions().length <= t[0])
      return;
    n != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (n = 1);
    const i = r.getResolution(t[0]);
    let a = r.getTileCoordExtent(t, this.tmpExtent_), o = ti(r.getTileSize(t[0]), this.tmpSize);
    const l = this.gutter_;
    l !== 0 && (o = UE(o, l, this.tmpSize), a = wr(a, i * l, a)), n != 1 && (o = hP(o, n, this.tmpSize));
    const f = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    return Object.assign(f, this.params_), this.getRequestUrl_(
      t,
      o,
      a,
      n,
      s,
      f
    );
  }
}
const Xy = ZN;
class JN extends PP {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(t, n, s, r, i, a, o) {
    const l = t.getExtent(), f = n.getExtent(), d = f ? zs(s, f) : s, u = Fi(d), c = yc(
      t,
      n,
      u,
      r
    ), h = P1, p = new M1(
      t,
      n,
      d,
      l,
      c * h,
      r
    ), g = p.calculateSourceExtent(), m = a(
      g,
      c,
      i
    ), v = m ? ce.IDLE : ce.EMPTY, y = m ? m.getPixelRatio() : 1;
    super(s, r, y, v), this.targetProj_ = n, this.maxSourceExtent_ = l, this.triangulation_ = p, this.targetResolution_ = r, this.targetExtent_ = s, this.sourceImage_ = m, this.sourcePixelRatio_ = y, this.interpolate_ = o, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == ce.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = this.sourceImage_.getState();
    if (t == ce.LOADED) {
      const n = ye(this.targetExtent_) / this.targetResolution_, s = In(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = I1(
        n,
        s,
        this.sourcePixelRatio_,
        this.sourceImage_.getResolution(),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_
      );
    }
    this.state = t, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == ce.IDLE) {
      this.state = ce.LOADING, this.changed();
      const t = this.sourceImage_.getState();
      t == ce.LOADED || t == ce.ERROR ? this.reproject_() : (this.sourceListenerKey_ = ge(
        this.sourceImage_,
        Kt.CHANGE,
        function(n) {
          const s = this.sourceImage_.getState();
          (s == ce.LOADED || s == ce.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    We(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const QN = JN, Op = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class qN extends Ui {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(t, n) {
    super(t), this.image = n;
  }
}
class tF extends Py {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      projection: t.projection,
      state: t.state,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0
    }), this.on, this.once, this.un, this.resolutions_ = t.resolutions !== void 0 ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(t) {
    if (this.resolutions_) {
      const n = vf(this.resolutions_, t, 0);
      t = this.resolutions_[n];
    }
    return t;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */
  getImage(t, n, s, r) {
    const i = this.getProjection();
    if (!i || !r || dr(i, r))
      return i && (r = i), this.getImageInternal(t, n, s, r);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && dr(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == n && wo(this.reprojectedImage_.getExtent(), t))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new QN(
      i,
      r,
      t,
      n,
      s,
      (function(a, o, l) {
        return this.getImageInternal(
          a,
          o,
          l,
          i
        );
      }).bind(this),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */
  getImageInternal(t, n, s, r) {
    return Gt();
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(t) {
    const n = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    let s;
    switch (n.getState()) {
      case ce.LOADING:
        this.loading = !0, s = Op.IMAGELOADSTART;
        break;
      case ce.LOADED:
        this.loading = !1, s = Op.IMAGELOADEND;
        break;
      case ce.ERROR:
        this.loading = !1, s = Op.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(s) && this.dispatchEvent(new qN(s, n));
  }
}
function Zy(e, t) {
  e.getImage().src = t;
}
const V1 = tF, pa = 4, LC = [101, 101];
class eF extends V1 {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: t.interpolate,
      projection: t.projection,
      resolutions: t.resolutions
    }), this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : Zy, this.params_ = Object.assign({}, t.params), this.v13_ = !0, this.updateV13_(), this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = t.ratio !== void 0 ? t.ratio : 1.5;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, n, s, r) {
    if (this.url_ === void 0)
      return;
    const i = Wt(s), a = this.getProjection();
    a && a !== i && (n = yc(
      a,
      i,
      t,
      n
    ), t = ji(t, i, a));
    const o = Nl(
      t,
      n,
      0,
      LC
    ), l = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(l, this.params_, r);
    const f = Tl((t[0] - o[0]) / n, pa), d = Tl((o[3] - t[1]) / n, pa);
    return l[this.v13_ ? "I" : "X"] = f, l[this.v13_ ? "J" : "Y"] = d, this.getRequestUrl_(
      o,
      LC,
      1,
      a || i,
      l
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, n) {
    if (this.url_ === void 0)
      return;
    const s = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (n === void 0 || n.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      s.LAYER = r;
    }
    if (t !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, i = 28e-5;
      s.SCALE = t * r / i;
    }
    return Object.assign(s, n), nu(
      /** @type {string} */
      this.url_,
      s
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(t, n, s, r) {
    if (this.url_ === void 0)
      return null;
    n = this.findNearestResolution(n), s != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (s = 1);
    const i = n / s, a = Fi(t), o = xa(ye(t) / i, pa), l = xa(In(t) / i, pa), f = Nl(a, i, 0, [
      o,
      l
    ]), d = xa(
      this.ratio_ * ye(t) / i,
      pa
    ), u = xa(
      this.ratio_ * In(t) / i,
      pa
    ), c = Nl(a, i, 0, [
      d,
      u
    ]), h = this.image_;
    if (h && this.renderedRevision_ == this.getRevision() && h.getResolution() == n && h.getPixelRatio() == s && Ar(h.getExtent(), f))
      return h;
    const p = {
      SERVICE: "WMS",
      VERSION: Ma,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    Object.assign(p, this.params_), this.imageSize_[0] = AE(
      ye(c) / i,
      pa
    ), this.imageSize_[1] = AE(
      In(c) / i,
      pa
    );
    const g = this.getRequestUrl_(
      c,
      this.imageSize_,
      s,
      r,
      p
    );
    return this.image_ = new MP(
      c,
      n,
      s,
      g,
      this.crossOrigin_,
      this.imageLoadFunction_
    ), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(
      Kt.CHANGE,
      this.handleImageChange.bind(this)
    ), this.image_;
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */
  getRequestUrl_(t, n, s, r, i) {
    if (Zt(this.url_ !== void 0, 9), i[this.v13_ ? "CRS" : "SRS"] = r.getCode(), "STYLES" in this.params_ || (i.STYLES = ""), s != 1)
      switch (this.serverType_) {
        case "geoserver":
          const l = 90 * s + 0.5 | 0;
          "FORMAT_OPTIONS" in i ? i.FORMAT_OPTIONS += ";dpi:" + l : i.FORMAT_OPTIONS = "dpi:" + l;
          break;
        case "mapserver":
          i.MAP_RESOLUTION = 90 * s;
          break;
        case "carmentaserver":
        case "qgis":
          i.DPI = 90 * s;
          break;
        default:
          Zt(!1, 8);
          break;
      }
    i.WIDTH = n[0], i.HEIGHT = n[1];
    const a = r.getAxisOrientation();
    let o;
    return this.v13_ && a.substr(0, 2) == "ne" ? o = [t[1], t[0], t[3], t[2]] : o = t, i.BBOX = o.join(","), nu(
      /** @type {string} */
      this.url_,
      i
    );
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(t) {
    this.image_ = null, this.imageLoadFunction_ = t, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(t) {
    t != this.url_ && (this.url_ = t, this.image_ = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(t) {
    Object.assign(this.params_, t), this.updateV13_(), this.image_ = null, this.changed();
  }
  /**
   * @private
   */
  updateV13_() {
    const t = this.params_.VERSION || Ma;
    this.v13_ = KT(t, "1.3") >= 0;
  }
}
const Jy = eF, nF = "EPSG:3857";
function Qy() {
  return Math.floor(Math.random() * 9999999);
}
function B1(e, t) {
  const n = { ...e }, s = {}, r = [
    "STYLES",
    "TIME",
    "CRS"
  ];
  return Object.keys(t).forEach((i) => {
    s[i.toUpperCase()] = t[i];
  }), r.forEach((i) => {
    t[i] && (n[i] = t[i]);
  }), n;
}
function N1(e) {
  let t = {};
  return t = Object.assign({
    CACHEID: Qy(),
    FORMAT: e.format || "image/png",
    LAYERS: e.layers,
    VERSION: e.version,
    TRANSPARENT: e.transparent,
    SINGLETILE: e.singleTile
  }, e.singleTile ? {} : { WIDTH: e.tilesize, HEIGHT: e.tilesize }), t = B1(t, e), t;
}
function F1(e, t) {
  const n = N1(e), s = e.crs ? Wt(e.crs) : void 0;
  let r = null;
  return e.singleTile ? new Jy({
    url: e.url,
    params: n,
    serverType: e.serverType,
    projection: s,
    attributions: e.olAttribution
  }) : (t && t.resolutions && (r = new du({
    resolutions: t.resolutions,
    origin: t.origin ? t.origin : void 0,
    tileSize: parseInt(e.tilesize, 10)
  })), new Xy({
    url: e.url,
    params: n,
    gutter: e.gutter || 0,
    tileGrid: r,
    projection: s,
    attributions: e.olAttribution
  }));
}
function iF(e, t = {}, n) {
  const s = F1(e, n), r = e.singleTile ? Rf : kc;
  return s.set("olcs.projection", Wt(nF)), new r(Object.assign({
    source: s,
    minResolution: e.minScale,
    maxResolution: e.maxScale,
    id: e.id
  }, t));
}
function rF(e) {
  const t = e.getSource().getParams().SESSIONID;
  let n = t;
  for (; t === n; )
    n = Qy();
  return e.getSource().updateParams({ SESSIONID: n }), n;
}
function sF(e, t, n) {
  const s = Ka({ Id: e.get("id") }), r = t.getView().getResolution(), i = t.getView().getProjection(), a = Object.assign({
    INFO_FORMAT: s && s.infoFormat || "text/xml"
  }, s && typeof s.featureCount < "u" ? { FEATURE_COUNT: s.featureCount } : {});
  return e.getSource().getFeatureInfoUrl(n, r, i, a);
}
const j1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addOptionalParams: B1,
  createLayer: iF,
  createLayerSource: F1,
  generateSessionId: Qy,
  getGfiURL: sF,
  makeParams: N1,
  updateSource: rF
}, Symbol.toStringTag, { value: "Module" }));
class U1 extends du {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    super({
      extent: t.extent,
      origin: t.origin,
      origins: t.origins,
      resolutions: t.resolutions,
      tileSize: t.tileSize,
      tileSizes: t.tileSizes,
      sizes: t.sizes
    }), this.matrixIds_ = t.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(t) {
    return this.matrixIds_[t];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
const aF = U1;
function oF(e, t, n) {
  const s = [], r = [], i = [], a = [], o = [];
  n = n !== void 0 ? n : [];
  const l = "SupportedCRS", f = "TileMatrix", d = "Identifier", u = "ScaleDenominator", c = "TopLeftCorner", h = "TileWidth", p = "TileHeight", g = e[l], m = Wt(g), v = m.getMetersPerUnit(), y = m.getAxisOrientation().substr(0, 2) == "ne";
  return e[f].sort(function(E, C) {
    return C[u] - E[u];
  }), e[f].forEach(function(E) {
    let C;
    if (n.length > 0 ? C = n.find(function(x) {
      return E[d] == x[f] ? !0 : E[d].includes(":") ? !1 : e[d] + ":" + E[d] === x[f];
    }) : C = !0, C) {
      r.push(E[d]);
      const x = E[u] * 28e-5 / v, b = E[h], P = E[p];
      y ? i.push([
        E[c][1],
        E[c][0]
      ]) : i.push(E[c]), s.push(x), a.push(
        b == P ? b : [b, P]
      ), o.push([E.MatrixWidth, E.MatrixHeight]);
    }
  }), new U1({
    extent: t,
    origins: i,
    resolutions: s,
    matrixIds: r,
    tileSizes: a,
    sizes: o
  });
}
class lF extends Yy {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    const n = t.requestEncoding !== void 0 ? t.requestEncoding : "KVP", s = t.tileGrid;
    let r = t.urls;
    r === void 0 && t.url !== void 0 && (r = R1(t.url)), super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: s,
      tileLoadFunction: t.tileLoadFunction,
      tilePixelRatio: t.tilePixelRatio,
      urls: r,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !1,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.version_ = t.version !== void 0 ? t.version : "1.0.0", this.format_ = t.format !== void 0 ? t.format : "image/jpeg", this.dimensions_ = t.dimensions !== void 0 ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = n, this.setKey(this.getKeyForDimensions_()), r && r.length > 0 && (this.tileUrlFunction = kg(
      r.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(t) {
    this.urls = t;
    const n = t.join(`
`);
    this.setTileUrlFunction(
      kg(
        t.map(this.createFromWMTSTemplate.bind(this))
      ),
      n
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    let t = 0;
    const n = [];
    for (const s in this.dimensions_)
      n[t++] = s + "-" + this.dimensions_[s];
    return n.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(t) {
    Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(t) {
    const n = this.requestEncoding_, s = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    n == "KVP" && Object.assign(s, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), t = n == "KVP" ? nu(t, s) : t.replace(/\{(\w+?)\}/g, function(a, o) {
      return o.toLowerCase() in s ? s[o.toLowerCase()] : a;
    });
    const r = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), i = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(a, o, l) {
        if (a) {
          const f = {
            TileMatrix: r.getMatrixId(a[0]),
            TileCol: a[1],
            TileRow: a[2]
          };
          Object.assign(f, i);
          let d = t;
          return n == "KVP" ? d = nu(d, f) : d = d.replace(/\{(\w+?)\}/g, function(u, c) {
            return f[c];
          }), d;
        } else
          return;
      }
    );
  }
}
const Vf = lF;
function uF(e, t) {
  const s = e.Contents.Layer.find(function(A) {
    return A.Identifier == t.layer;
  });
  if (!s)
    return null;
  const r = e.Contents.TileMatrixSet;
  let i;
  s.TileMatrixSetLink.length > 1 ? "projection" in t ? i = s.TileMatrixSetLink.findIndex(function(A) {
    const _ = r.find(function(j) {
      return j.Identifier == A.TileMatrixSet;
    }).SupportedCRS, w = Wt(_), B = Wt(t.projection);
    return w && B ? dr(w, B) : _ == t.projection;
  }) : i = s.TileMatrixSetLink.findIndex(function(A) {
    return A.TileMatrixSet == t.matrixSet;
  }) : i = 0, i < 0 && (i = 0);
  const a = (
    /** @type {string} */
    s.TileMatrixSetLink[i].TileMatrixSet
  ), o = (
    /** @type {Array<Object>} */
    s.TileMatrixSetLink[i].TileMatrixSetLimits
  );
  let l = (
    /** @type {string} */
    s.Format[0]
  );
  "format" in t && (l = t.format), i = s.Style.findIndex(function(A) {
    return "style" in t ? A.Title == t.style : A.isDefault;
  }), i < 0 && (i = 0);
  const f = (
    /** @type {string} */
    s.Style[i].Identifier
  ), d = {};
  "Dimension" in s && s.Dimension.forEach(function(A, D, _) {
    const w = A.Identifier;
    let B = A.Default;
    B === void 0 && (B = A.Value[0]), d[w] = B;
  });
  const c = e.Contents.TileMatrixSet.find(function(A) {
    return A.Identifier == a;
  });
  let h;
  const p = c.SupportedCRS;
  if (p && (h = Wt(p)), "projection" in t) {
    const A = Wt(t.projection);
    A && (!h || dr(A, h)) && (h = A);
  }
  let g = !1;
  const m = h.getAxisOrientation().substr(0, 2) == "ne";
  let v = c.TileMatrix[0], y = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: v.MatrixWidth - 1,
    MaxTileRow: v.MatrixHeight - 1
  };
  if (o) {
    y = o[o.length - 1];
    const A = c.TileMatrix.find(
      (D) => D.Identifier === y.TileMatrix || c.Identifier + ":" + D.Identifier === y.TileMatrix
    );
    A && (v = A);
  }
  const E = v.ScaleDenominator * 28e-5 / h.getMetersPerUnit(), C = m ? [v.TopLeftCorner[1], v.TopLeftCorner[0]] : v.TopLeftCorner, x = v.TileWidth * E, b = v.TileHeight * E;
  let P = c.BoundingBox;
  P && m && (P = [
    P[1],
    P[0],
    P[3],
    P[2]
  ]);
  let T = [
    C[0] + x * y.MinTileCol,
    // add one to get proper bottom/right coordinate
    C[1] - b * (1 + y.MaxTileRow),
    C[0] + x * (1 + y.MaxTileCol),
    C[1] - b * y.MinTileRow
  ];
  if (P !== void 0 && !Ar(P, T)) {
    const A = s.WGS84BoundingBox, D = Wt("EPSG:4326").getExtent();
    if (T = P, A)
      g = A[0] === D[0] && A[2] === D[2];
    else {
      const _ = Fc(
        P,
        c.SupportedCRS,
        "EPSG:4326"
      );
      g = _[0] - 1e-10 <= D[0] && _[2] + 1e-10 >= D[2];
    }
  }
  const O = oF(
    c,
    T,
    o
  ), S = [];
  let L = t.requestEncoding;
  if (L = L !== void 0 ? L : "", "OperationsMetadata" in e && "GetTile" in e.OperationsMetadata) {
    const A = e.OperationsMetadata.GetTile.DCP.HTTP.Get;
    for (let D = 0, _ = A.length; D < _; ++D)
      if (A[D].Constraint) {
        const B = A[D].Constraint.find(function(j) {
          return j.name == "GetEncoding";
        }).AllowedValues.Value;
        if (L === "" && (L = B[0]), L === "KVP")
          B.includes("KVP") && S.push(
            /** @type {string} */
            A[D].href
          );
        else
          break;
      } else
        A[D].href && (L = "KVP", S.push(
          /** @type {string} */
          A[D].href
        ));
  }
  return S.length === 0 && (L = "REST", s.ResourceURL.forEach(function(A) {
    A.resourceType === "tile" && (l = A.format, S.push(
      /** @type {string} */
      A.template
    ));
  })), {
    urls: S,
    layer: t.layer,
    matrixSet: a,
    format: l,
    projection: h,
    requestEncoding: L,
    tileGrid: O,
    style: f,
    dimensions: d,
    wrapX: g,
    crossOrigin: t.crossOrigin
  };
}
const Hg = "http://www.w3.org/2001/XMLSchema-instance";
function le(e, t) {
  return K1().createElementNS(e, t);
}
function No(e, t) {
  return W1(e, t, []).join("");
}
function W1(e, t, n) {
  if (e.nodeType == Node.CDATA_SECTION_NODE || e.nodeType == Node.TEXT_NODE)
    t ? n.push(String(e.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : n.push(e.nodeValue);
  else {
    let s;
    for (s = e.firstChild; s; s = s.nextSibling)
      W1(s, t, n);
  }
  return n;
}
function Co(e) {
  return "documentElement" in e;
}
function cF(e, t, n) {
  return e.getAttributeNS(t, n) || "";
}
function xo(e) {
  return new DOMParser().parseFromString(e, "application/xml");
}
function $1(e, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      if (r !== void 0) {
        const i = (
          /** @type {Array<*>} */
          s[s.length - 1]
        );
        Kn(i, r);
      }
    }
  );
}
function Ht(e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      r !== void 0 && /** @type {Array<*>} */
      s[s.length - 1].push(r);
    }
  );
}
function zt(e, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      r !== void 0 && (s[s.length - 1] = r);
    }
  );
}
function ke(e, t, n) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(s, r) {
      const i = e.call(
        n !== void 0 ? n : this,
        s,
        r
      );
      if (i !== void 0) {
        const a = (
          /** @type {!Object} */
          r[r.length - 1]
        ), o = t !== void 0 ? t : s.localName;
        let l;
        o in a ? l = a[o] : (l = [], a[o] = l), l.push(i);
      }
    }
  );
}
function mt(e, t, n) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(s, r) {
      const i = e.call(
        n !== void 0 ? n : this,
        s,
        r
      );
      if (i !== void 0) {
        const a = (
          /** @type {!Object} */
          r[r.length - 1]
        ), o = t !== void 0 ? t : s.localName;
        a[o] = i;
      }
    }
  );
}
function gt(e, t) {
  return function(n, s, r) {
    e.call(
      t !== void 0 ? t : this,
      n,
      s,
      r
    ), /** @type {NodeStackItem} */
    r[r.length - 1].node.appendChild(n);
  };
}
function tr(e, t) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(n, s, r) {
      const a = /** @type {NodeStackItem} */ s[s.length - 1].node;
      let o = e;
      o === void 0 && (o = r);
      const l = t !== void 0 ? t : a.namespaceURI;
      return le(
        l,
        /** @type {string} */
        o
      );
    }
  );
}
const z1 = tr();
function qt(e, t, n) {
  n = n !== void 0 ? n : {};
  let s, r;
  for (s = 0, r = e.length; s < r; ++s)
    n[e[s]] = t;
  return n;
}
function Mo(e, t, n, s) {
  let r;
  for (r = t.firstElementChild; r; r = r.nextElementSibling) {
    const i = e[r.namespaceURI];
    if (i !== void 0) {
      const a = i[r.localName];
      a !== void 0 && a.call(s, r, n);
    }
  }
}
function At(e, t, n, s, r) {
  return s.push(e), Mo(t, n, s, r), /** @type {T} */
  s.pop();
}
function hF(e, t, n, s, r, i) {
  const a = (r !== void 0 ? r : n).length;
  let o, l;
  for (let f = 0; f < a; ++f)
    o = n[f], o !== void 0 && (l = t.call(
      i !== void 0 ? i : this,
      o,
      s,
      r !== void 0 ? r[f] : void 0
    ), l !== void 0 && e[l.namespaceURI][l.localName].call(
      i,
      l,
      o,
      s
    ));
}
function En(e, t, n, s, r, i, a) {
  return r.push(e), hF(t, n, s, r, i, a), /** @type {O|undefined} */
  r.pop();
}
let Tp;
function dF() {
  return Tp === void 0 && typeof XMLSerializer < "u" && (Tp = new XMLSerializer()), Tp;
}
let Pp;
function K1() {
  return Pp === void 0 && typeof document < "u" && (Pp = document.implementation.createDocument("", "", null)), Pp;
}
class fF {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object} An object representing the source.
   * @api
   */
  read(t) {
    if (t)
      if (typeof t == "string") {
        const n = xo(t);
        return this.readFromDocument(n);
      } else
        return Co(t) ? this.readFromDocument(
          /** @type {Document} */
          t
        ) : this.readFromNode(
          /** @type {Element} */
          t
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @return {Object} Object
   */
  readFromDocument(t) {
    for (let n = t.firstChild; n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          n
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
  }
}
const qy = fF, pF = "http://www.w3.org/1999/xlink";
function fu(e) {
  return e.getAttributeNS(pF, "href");
}
function Wl(e) {
  const t = /^\s*(true|1)|(false|0)\s*$/.exec(e);
  if (t)
    return t[1] !== void 0 || !1;
}
function bo(e) {
  const t = No(e, !1);
  return Ns(t);
}
function Ns(e) {
  const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(e);
  if (t)
    return parseFloat(t[1]);
}
function qn(e) {
  const t = No(e, !1);
  return Us(t);
}
function Us(e) {
  const t = /^\s*(\d+)\s*$/.exec(e);
  if (t)
    return parseInt(t[1], 10);
}
function Ft(e) {
  return No(e, !1).trim();
}
function Ln(e, t) {
  e.appendChild(K1().createTextNode(t));
}
const $i = [null, "http://www.opengis.net/ows/1.1"], mF = qt($i, {
  ServiceIdentification: mt(UF),
  ServiceProvider: mt($F),
  OperationsMetadata: mt(FF)
});
class gF extends qy {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    const n = At({}, mF, t, []);
    return n || null;
  }
}
const vF = qt($i, {
  DeliveryPoint: mt(Ft),
  City: mt(Ft),
  AdministrativeArea: mt(Ft),
  PostalCode: mt(Ft),
  Country: mt(Ft),
  ElectronicMailAddress: mt(Ft)
}), yF = qt($i, {
  Value: ke(zF)
}), EF = qt($i, {
  AllowedValues: mt(AF)
}), CF = qt($i, {
  Phone: mt(jF),
  Address: mt(DF)
}), xF = qt($i, {
  HTTP: mt(BF)
}), bF = qt($i, {
  Get: ke(VF),
  Post: void 0
  // TODO
}), OF = qt($i, {
  DCP: mt(wF)
}), TF = qt($i, {
  Operation: NF
}), PF = qt($i, {
  Voice: mt(Ft),
  Facsimile: mt(Ft)
}), MF = qt($i, {
  Constraint: ke(LF)
}), SF = qt($i, {
  IndividualName: mt(Ft),
  PositionName: mt(Ft),
  ContactInfo: mt(RF)
}), IF = qt($i, {
  Abstract: mt(Ft),
  AccessConstraints: mt(Ft),
  Fees: mt(Ft),
  Title: mt(Ft),
  ServiceTypeVersion: mt(Ft),
  ServiceType: mt(Ft)
}), _F = qt($i, {
  ProviderName: mt(Ft),
  ProviderSite: mt(fu),
  ServiceContact: mt(WF)
});
function DF(e, t) {
  return At({}, vF, e, t);
}
function AF(e, t) {
  return At({}, yF, e, t);
}
function LF(e, t) {
  const n = e.getAttribute("name");
  if (n)
    return At({ name: n }, EF, e, t);
}
function RF(e, t) {
  return At({}, CF, e, t);
}
function wF(e, t) {
  return At({}, xF, e, t);
}
function VF(e, t) {
  const n = fu(e);
  if (n)
    return At(
      { href: n },
      MF,
      e,
      t
    );
}
function BF(e, t) {
  return At({}, bF, e, t);
}
function NF(e, t) {
  const n = e.getAttribute("name"), s = At({}, OF, e, t);
  if (!s)
    return;
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  );
  r[n] = s;
}
function FF(e, t) {
  return At({}, TF, e, t);
}
function jF(e, t) {
  return At({}, PF, e, t);
}
function UF(e, t) {
  return At({}, IF, e, t);
}
function WF(e, t) {
  return At({}, SF, e, t);
}
function $F(e, t) {
  return At({}, _F, e, t);
}
function zF(e, t) {
  return Ft(e);
}
const KF = gF, Es = [null, "http://www.opengis.net/wmts/1.0"], pu = [null, "http://www.opengis.net/ows/1.1"], GF = qt(Es, {
  Contents: mt(ij)
});
class kF extends qy {
  constructor() {
    super(), this.owsParser_ = new KF();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    let n = t.getAttribute("version");
    n && (n = n.trim());
    let s = this.owsParser_.readFromNode(t);
    return s ? (s.version = n, s = At(
      s,
      GF,
      t,
      []
    ), s || null) : null;
  }
}
const HF = qt(Es, {
  Layer: ke(rj),
  TileMatrixSet: ke(sj)
}), YF = qt(
  Es,
  {
    Style: ke(aj),
    Format: ke(Ft),
    TileMatrixSetLink: ke(oj),
    Dimension: ke(lj),
    ResourceURL: ke(uj)
  },
  qt(pu, {
    Title: mt(Ft),
    Abstract: mt(Ft),
    WGS84BoundingBox: mt(G1),
    Identifier: mt(Ft)
  })
), XF = qt(
  Es,
  {
    LegendURL: ke(cj)
  },
  qt(pu, {
    Title: mt(Ft),
    Identifier: mt(Ft)
  })
), ZF = qt(Es, {
  TileMatrixSet: mt(Ft),
  TileMatrixSetLimits: mt(dj)
}), JF = qt(Es, {
  TileMatrixLimits: Ht(fj)
}), QF = qt(Es, {
  TileMatrix: mt(Ft),
  MinTileRow: mt(qn),
  MaxTileRow: mt(qn),
  MinTileCol: mt(qn),
  MaxTileCol: mt(qn)
}), qF = qt(
  Es,
  {
    Default: mt(Ft),
    Value: ke(Ft)
  },
  qt(pu, {
    Identifier: mt(Ft)
  })
), tj = qt(pu, {
  LowerCorner: Ht(Yg),
  UpperCorner: Ht(Yg)
}), ej = qt(
  Es,
  {
    WellKnownScaleSet: mt(Ft),
    TileMatrix: ke(hj)
  },
  qt(pu, {
    SupportedCRS: mt(Ft),
    Identifier: mt(Ft),
    BoundingBox: mt(G1)
  })
), nj = qt(
  Es,
  {
    TopLeftCorner: mt(Yg),
    ScaleDenominator: mt(bo),
    TileWidth: mt(qn),
    TileHeight: mt(qn),
    MatrixWidth: mt(qn),
    MatrixHeight: mt(qn)
  },
  qt(pu, {
    Identifier: mt(Ft)
  })
);
function ij(e, t) {
  return At({}, HF, e, t);
}
function rj(e, t) {
  return At({}, YF, e, t);
}
function sj(e, t) {
  return At({}, ej, e, t);
}
function aj(e, t) {
  const n = At({}, XF, e, t);
  if (!n)
    return;
  const s = e.getAttribute("isDefault") === "true";
  return n.isDefault = s, n;
}
function oj(e, t) {
  return At({}, ZF, e, t);
}
function lj(e, t) {
  return At({}, qF, e, t);
}
function uj(e, t) {
  const n = e.getAttribute("format"), s = e.getAttribute("template"), r = e.getAttribute("resourceType"), i = {};
  return n && (i.format = n), s && (i.template = s), r && (i.resourceType = r), i;
}
function G1(e, t) {
  const n = At(
    [],
    tj,
    e,
    t
  );
  if (n.length == 2)
    return Yl(n);
}
function cj(e, t) {
  const n = {};
  return n.format = e.getAttribute("format"), n.href = fu(e), n;
}
function Yg(e, t) {
  const n = Ft(e).split(/\s+/);
  if (!n || n.length != 2)
    return;
  const s = +n[0], r = +n[1];
  if (!(isNaN(s) || isNaN(r)))
    return [s, r];
}
function hj(e, t) {
  return At({}, nj, e, t);
}
function dj(e, t) {
  return At([], JF, e, t);
}
function fj(e, t) {
  return At({}, QF, e, t);
}
const pj = kF;
function Nd(e, t) {
  console.error("content: Layer " + t + ": " + e);
}
function k1(e, t, n, s) {
  for (let r = 0; r < n; ++r)
    e[r] = s / Math.pow(2, r), t[r] = r;
}
function H1(e) {
  return fetch(e).then((t) => {
    if (t && t.status === 200)
      return t.text();
    throw console.error(t), new Error(`Failing WMTS request to ${e}. Status: ${t == null ? void 0 : t.status}`);
  }).then((t) => new pj().read(t));
}
function Y1(e, t) {
  const n = Wt(e.coordinateSystem), s = n.getExtent(), r = e.style, i = e.format, a = e.wrapX ? e.wrapX : !1, o = e.urls, l = s ? ye(s) / parseInt(e.tileSize, 10) : null, f = parseInt(e.resLength, 10), d = new Array(f), u = new Array(f), c = new Vf({
    projection: n,
    attributions: e.olAttribution,
    tileGrid: new aF({
      origin: e.origin,
      resolutions: d,
      matrixIds: u,
      tileSize: e.tileSize
    }),
    tilePixelRatio: Ef,
    urls: o,
    matrixSet: e.tileMatrixSet,
    matrixSizes: e.matrixSizes,
    layer: e.layers,
    format: i,
    style: r,
    version: e.version,
    transparent: e.transparent.toString(),
    wrapX: a,
    requestEncoding: e.requestEncoding,
    scales: e.scales
  });
  l ? k1(d, u, f, l) : Nd(e.name, `${n.getCode()} has been given as projection to wmts.js for layer with id ${e.id}, but only "EPSG:4326" and "EPSG:3857" are supported. Please use the "capabilitiesUrl" and "optionsFromCapabilities" configuration parameters on this layer.`), c.matrixSizes = e.matrixSizes, c.scales = e.scales, t.setSource(c), t.getSource().refresh();
}
function X1(e, t) {
  const n = e.layers, s = e.capabilitiesUrl, r = e.tileMatrixSet, i = {
    layer: n
  };
  r && r.length > 0 ? i.matrixSet = r : i.projection = "EPSG:3857", H1(s).then((a) => {
    const o = uF(a, i), l = a.Contents.TileMatrixSet.filter((u) => u.Identifier === o.matrixSet)[0], f = [], d = [];
    if (l.TileMatrix.forEach(({ MatrixHeight: u, MatrixWidth: c, ScaleDenominator: h }) => {
      f.push([c, u]), d.push(h);
    }), o !== null) {
      const u = new Vf(o);
      u.matrixSizes = f, u.scales = d, t.set("options", o), t.setSource(u), t.getSource().refresh();
    } else {
      const u = "Cannot get options from WMTS-Capabilities";
      throw Nd(u, e.name || e.id), new Error(u);
    }
  }).catch((a) => {
    a !== "Fetch error" && Nd(a, e.name || e.id);
  });
}
function mj(e) {
  const t = new kc({
    id: e.id,
    source: new Vf({}),
    name: e.name,
    minResolution: e.minScale,
    maxResolution: e.maxScale,
    supported: ["2D", "3D"],
    showSettings: !0,
    extent: null,
    typ: e.typ,
    legendURL: e.legendURL,
    infoFormat: e.infoFormat
  });
  return e.optionsFromCapabilities === void 0 ? Y1(e, t) : X1(e, t), t;
}
const Z1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: mj,
  createLayerSourceByCapabilities: X1,
  createLayerSourceByDefinitions: Y1,
  generateArrays: k1,
  getWMTSCapabilities: H1,
  showErrorMessage: Nd
}, Symbol.toStringTag, { value: "Module" }));
class gj {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(t, n) {
    if (n) {
      let s = n.dataProjection ? Wt(n.dataProjection) : this.readProjection(t);
      n.extent && s && s.getUnits() === "tile-pixels" && (s = Wt(s), s.setWorldExtent(n.extent)), n = {
        dataProjection: s,
        featureProjection: n.featureProjection
      };
    }
    return this.adaptOptions(n);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(t) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection
      },
      t
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return Gt();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */
  readFeature(t, n) {
    return Gt();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  readFeatures(t, n) {
    return Gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(t, n) {
    return Gt();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(t) {
    return Gt();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(t, n) {
    return Gt();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(t, n) {
    return Gt();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(t, n) {
    return Gt();
  }
}
const t0 = gj;
function mu(e, t, n) {
  const s = n ? Wt(n.featureProjection) : null, r = n ? Wt(n.dataProjection) : null;
  let i;
  if (s && r && !dr(s, r) ? i = (t ? e.clone() : e).transform(
    t ? s : r,
    t ? r : s
  ) : i = e, t && n && /** @type {WriteOptions} */
  n.decimals !== void 0) {
    const a = Math.pow(
      10,
      /** @type {WriteOptions} */
      n.decimals
    ), o = function(l) {
      for (let f = 0, d = l.length; f < d; ++f)
        l[f] = Math.round(l[f] * a) / a;
      return l;
    };
    i === e && (i = e.clone()), i.applyTransform(o);
  }
  return i;
}
function e0(e, t) {
  const n = t ? Wt(t.featureProjection) : null, s = t ? Wt(t.dataProjection) : null;
  return n && s && !dr(n, s) ? Fc(e, s, n) : e;
}
class vj extends t0 {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(t, n) {
    return this.readFeatureFromObject(
      xh(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(t, n) {
    return this.readFeaturesFromObject(
      xh(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(t, n) {
    return Gt();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(t, n) {
    return Gt();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(t, n) {
    return this.readGeometryFromObject(
      xh(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(t, n) {
    return Gt();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    return this.readProjectionFromObject(xh(t));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(t) {
    return Gt();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(t, n) {
    return JSON.stringify(this.writeFeatureObject(t, n));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(t, n) {
    return Gt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(t, n) {
    return JSON.stringify(this.writeFeaturesObject(t, n));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(t, n) {
    return Gt();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(t, n) {
    return JSON.stringify(this.writeGeometryObject(t, n));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(t, n) {
    return Gt();
  }
}
function xh(e) {
  if (typeof e == "string") {
    const t = JSON.parse(e);
    return t || null;
  } else
    return e !== null ? e : null;
}
const yj = vj;
class Fd extends na {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(t, n, s) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        n
      );
    else if (n !== void 0 && s)
      this.setFlatCoordinates(
        n,
        /** @type {Array<number>} */
        t
      ), this.ends_ = s;
    else {
      let r = this.getLayout();
      const i = (
        /** @type {Array<LineString>} */
        t
      ), a = [], o = [];
      for (let l = 0, f = i.length; l < f; ++l) {
        const d = i[l];
        l === 0 && (r = d.getLayout()), Kn(a, d.getFlatCoordinates()), o.push(a.length);
      }
      this.setFlatCoordinates(r, a), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const t = new Fd(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Xo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      sy(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), oy(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, n, s) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (n = n !== void 0 ? n : !1, s = s !== void 0 ? s : !1, $D(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      n,
      s
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return ac(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(t) {
    return t < 0 || this.ends_.length <= t ? null : new qi(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const t = this.flatCoordinates, n = this.ends_, s = this.layout, r = [];
    let i = 0;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a], f = new qi(
        t.slice(i, l),
        s
      );
      r.push(f), i = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const t = [], n = this.flatCoordinates;
    let s = 0;
    const r = this.ends_, i = this.stride;
    for (let a = 0, o = r.length; a < o; ++a) {
      const l = r[a], f = yd(
        n,
        s,
        l,
        i,
        0.5
      );
      Kn(t, f), s = l;
    }
    return t;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = SD(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      n,
      0,
      s
    ), new Fd(n, "XY", s);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return wD(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const s = ly(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1], this.changed();
  }
}
const Zs = Fd;
class n0 extends na {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), n && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const t = new n0(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    if (r < Xo(this.getExtent(), t, n))
      return r;
    const i = this.flatCoordinates, a = this.stride;
    for (let o = 0, l = i.length; o < l; o += a) {
      const f = Ks(
        t,
        n,
        i[o],
        i[o + 1]
      );
      if (f < r) {
        r = f;
        for (let d = 0; d < a; ++d)
          s[d] = i[o + d];
        s.length = a;
      }
    }
    return r;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return ba(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(t) {
    const n = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
    return t < 0 || n <= t ? null : new hi(
      this.flatCoordinates.slice(
        t * this.stride,
        (t + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const t = this.flatCoordinates, n = this.layout, s = this.stride, r = [];
    for (let i = 0, a = t.length; i < a; i += s) {
      const o = new hi(t.slice(i, i + s), n);
      r.push(o);
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.flatCoordinates, s = this.stride;
    for (let r = 0, i = n.length; r < i; r += s) {
      const a = n[r], o = n[r + 1];
      if (Hv(t, a, o))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Mf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const gu = n0;
function J1(e, t, n, s) {
  const r = [];
  let i = Ni();
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    i = Xv(
      e,
      t,
      l[0],
      s
    ), r.push((i[0] + i[2]) / 2, (i[1] + i[3]) / 2), t = l[l.length - 1];
  }
  return r;
}
class jd extends na {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(t, n, s) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !s && !Array.isArray(t[0])) {
      let r = this.getLayout();
      const i = (
        /** @type {Array<Polygon>} */
        t
      ), a = [], o = [];
      for (let l = 0, f = i.length; l < f; ++l) {
        const d = i[l];
        l === 0 && (r = d.getLayout());
        const u = a.length, c = d.getEnds();
        for (let h = 0, p = c.length; h < p; ++h)
          c[h] += u;
        Kn(a, d.getFlatCoordinates()), o.push(c);
      }
      n = r, t = a, s = o;
    }
    n !== void 0 && s ? (this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ), this.endss_ = s) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      t,
      n
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(t) {
    let n;
    if (!this.flatCoordinates)
      this.flatCoordinates = t.getFlatCoordinates().slice(), n = t.getEnds().slice(), this.endss_.push();
    else {
      const s = this.flatCoordinates.length;
      Kn(this.flatCoordinates, t.getFlatCoordinates()), n = t.getEnds().slice();
      for (let r = 0, i = n.length; r < i; ++r)
        n[r] += s;
    }
    this.endss_.push(n), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const t = this.endss_.length, n = new Array(t);
    for (let r = 0; r < t; ++r)
      n[r] = this.endss_[r].slice();
    const s = new jd(
      this.flatCoordinates.slice(),
      this.layout,
      n
    );
    return s.applyProperties(this), s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Xo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      TD(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), PD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    return RD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t,
      n
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return DD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let n;
    return t !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), FE(
      n,
      0,
      this.endss_,
      this.stride,
      t
    )) : n = this.flatCoordinates, Ig(
      n,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const t = J1(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = rP(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new gu(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      ND(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = FE(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = _D(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(t),
      n,
      0,
      s
    ), new jd(n, "XY", s);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(t) {
    if (t < 0 || this.endss_.length <= t)
      return null;
    let n;
    if (t === 0)
      n = 0;
    else {
      const i = this.endss_[t - 1];
      n = i[i.length - 1];
    }
    const s = this.endss_[t].slice(), r = s[s.length - 1];
    if (n !== 0)
      for (let i = 0, a = s.length; i < a; ++i)
        s[i] -= n;
    return new nr(
      this.flatCoordinates.slice(n, r),
      this.layout,
      s
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const t = this.layout, n = this.flatCoordinates, s = this.endss_, r = [];
    let i = 0;
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a].slice(), f = l[l.length - 1];
      if (i !== 0)
        for (let u = 0, c = l.length; u < c; ++u)
          l[u] -= i;
      const d = new nr(
        n.slice(i, f),
        t,
        l
      );
      r.push(d), i = f;
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return VD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const s = MD(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.endss_
    );
    if (s.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const r = s[s.length - 1];
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
    }
    this.changed();
  }
}
const Js = jd;
class Ud extends pd {
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  constructor(t) {
    super(), this.geometries_ = t || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(We), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    if (this.geometries_)
      for (let t = 0, n = this.geometries_.length; t < n; ++t)
        this.changeEventsKeys_.push(
          ge(this.geometries_[t], Kt.CHANGE, this.changed, this)
        );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const t = new Ud(null);
    return t.setGeometries(this.geometries_), t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    if (r < Xo(this.getExtent(), t, n))
      return r;
    const i = this.geometries_;
    for (let a = 0, o = i.length; a < o; ++a)
      r = i[a].closestPointXY(
        t,
        n,
        s,
        r
      );
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      if (s[r].containsXY(t, n))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    Bc(t);
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      UT(t, n[s].getExtent());
    return t;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return RC(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let t = [];
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      n[s].getType() === this.getType() ? t = t.concat(
        /** @type {GeometryCollection} */
        n[s].getGeometriesArrayRecursive()
      ) : t.push(n[s]);
    return t;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const n = [], s = this.geometries_;
    let r = !1;
    for (let i = 0, a = s.length; i < a; ++i) {
      const o = s[i], l = o.getSimplifiedGeometry(t);
      n.push(l), l !== o && (r = !0);
    }
    if (r) {
      const i = new Ud(null);
      return i.setGeometriesArray(n), i;
    } else
      return this.simplifiedGeometryMaxMinSquaredTolerance = t, this;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      if (n[s].intersectsExtent(t))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r].rotate(t, n);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    s || (s = Fi(this.getExtent()));
    const r = this.geometries_;
    for (let i = 0, a = r.length; i < a; ++i)
      r[i].scale(t, n, s);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(t) {
    this.setGeometriesArray(RC(t));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(t) {
    this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      n[s].applyTransform(t);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r].translate(t, n);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function RC(e) {
  const t = [];
  for (let n = 0, s = e.length; n < s; ++n)
    t.push(e[n].clone());
  return t;
}
const Q1 = Ud;
class Ej extends yj {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(), this.dataProjection = Wt(
      t.dataProjection ? t.dataProjection : "EPSG:4326"
    ), t.featureProjection && (this.defaultFeatureProjection = Wt(t.featureProjection)), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(t, n) {
    let s = null;
    t.type === "Feature" ? s = /** @type {GeoJSONFeature} */
    t : s = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        t
      ),
      properties: null
    };
    const r = Xg(s.geometry, n), i = new Xi();
    return this.geometryName_ ? i.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in s !== void 0 && i.setGeometryName(s.geometry_name), i.setGeometry(r), "id" in s && i.setId(s.id), s.properties && i.setProperties(s.properties, !0), i;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(t, n) {
    const s = (
      /** @type {GeoJSONObject} */
      t
    );
    let r = null;
    if (s.type === "FeatureCollection") {
      const i = (
        /** @type {GeoJSONFeatureCollection} */
        t
      );
      r = [];
      const a = i.features;
      for (let o = 0, l = a.length; o < l; ++o)
        r.push(this.readFeatureFromObject(a[o], n));
    } else
      r = [this.readFeatureFromObject(t, n)];
    return r;
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(t, n) {
    return Xg(t, n);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(t) {
    const n = t.crs;
    let s;
    return n ? n.type == "name" ? s = Wt(n.properties.name) : n.type === "EPSG" ? s = Wt("EPSG:" + n.properties.code) : Zt(!1, 36) : s = this.dataProjection, /** @type {import("../proj/Projection.js").default} */
    s;
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(t, n) {
    n = this.adaptOptions(n);
    const s = {
      type: "Feature",
      geometry: null,
      properties: null
    }, r = t.getId();
    if (r !== void 0 && (s.id = r), !t.hasProperties())
      return s;
    const i = t.getProperties(), a = t.getGeometry();
    return a && (s.geometry = Zg(a, n), delete i[t.getGeometryName()]), Ro(i) || (s.properties = i), s;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(t, n) {
    n = this.adaptOptions(n);
    const s = [];
    for (let r = 0, i = t.length; r < i; ++r)
      s.push(this.writeFeatureObject(t[r], n));
    return {
      type: "FeatureCollection",
      features: s
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(t, n) {
    return Zg(t, this.adaptOptions(n));
  }
}
function Xg(e, t) {
  if (!e)
    return null;
  let n;
  switch (e.type) {
    case "Point": {
      n = xj(
        /** @type {GeoJSONPoint} */
        e
      );
      break;
    }
    case "LineString": {
      n = bj(
        /** @type {GeoJSONLineString} */
        e
      );
      break;
    }
    case "Polygon": {
      n = Mj(
        /** @type {GeoJSONPolygon} */
        e
      );
      break;
    }
    case "MultiPoint": {
      n = Tj(
        /** @type {GeoJSONMultiPoint} */
        e
      );
      break;
    }
    case "MultiLineString": {
      n = Oj(
        /** @type {GeoJSONMultiLineString} */
        e
      );
      break;
    }
    case "MultiPolygon": {
      n = Pj(
        /** @type {GeoJSONMultiPolygon} */
        e
      );
      break;
    }
    case "GeometryCollection": {
      n = Cj(
        /** @type {GeoJSONGeometryCollection} */
        e
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + e.type);
  }
  return mu(n, !1, t);
}
function Cj(e, t) {
  const n = e.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function(s) {
      return Xg(s, t);
    }
  );
  return new Q1(n);
}
function xj(e) {
  return new hi(e.coordinates);
}
function bj(e) {
  return new qi(e.coordinates);
}
function Oj(e) {
  return new Zs(e.coordinates);
}
function Tj(e) {
  return new gu(e.coordinates);
}
function Pj(e) {
  return new Js(e.coordinates);
}
function Mj(e) {
  return new nr(e.coordinates);
}
function Zg(e, t) {
  e = mu(e, !0, t);
  const n = e.getType();
  let s;
  switch (n) {
    case "Point": {
      s = Lj(
        /** @type {Point} */
        e
      );
      break;
    }
    case "LineString": {
      s = Ij(
        /** @type {LineString} */
        e
      );
      break;
    }
    case "Polygon": {
      s = Rj(
        /** @type {Polygon} */
        e,
        t
      );
      break;
    }
    case "MultiPoint": {
      s = Dj(
        /** @type {MultiPoint} */
        e
      );
      break;
    }
    case "MultiLineString": {
      s = _j(
        /** @type {MultiLineString} */
        e
      );
      break;
    }
    case "MultiPolygon": {
      s = Aj(
        /** @type {MultiPolygon} */
        e,
        t
      );
      break;
    }
    case "GeometryCollection": {
      s = Sj(
        /** @type {GeometryCollection} */
        e,
        t
      );
      break;
    }
    case "Circle": {
      s = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + n);
  }
  return s;
}
function Sj(e, t) {
  return t = Object.assign({}, t), delete t.featureProjection, {
    type: "GeometryCollection",
    geometries: e.getGeometriesArray().map(function(s) {
      return Zg(s, t);
    })
  };
}
function Ij(e, t) {
  return {
    type: "LineString",
    coordinates: e.getCoordinates()
  };
}
function _j(e, t) {
  return {
    type: "MultiLineString",
    coordinates: e.getCoordinates()
  };
}
function Dj(e, t) {
  return {
    type: "MultiPoint",
    coordinates: e.getCoordinates()
  };
}
function Aj(e, t) {
  let n;
  return t && (n = t.rightHanded), {
    type: "MultiPolygon",
    coordinates: e.getCoordinates(n)
  };
}
function Lj(e, t) {
  return {
    type: "Point",
    coordinates: e.getCoordinates()
  };
}
function Rj(e, t) {
  let n;
  return t && (n = t.rightHanded), {
    type: "Polygon",
    coordinates: e.getCoordinates(n)
  };
}
const Qs = Ej;
class wj extends t0 {
  constructor() {
    super(), this.xmlSerializer_ = dF();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = xo(t);
        return this.readFeatureFromDocument(s, n);
      } else
        return Co(t) ? this.readFeatureFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readFeatureFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(t, n) {
    const s = this.readFeaturesFromDocument(t, n);
    return s.length > 0 ? s[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(t, n) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = xo(t);
        return this.readFeaturesFromDocument(s, n);
      } else
        return Co(t) ? this.readFeaturesFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readFeaturesFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return [];
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(t, n) {
    const s = [];
    for (let r = t.firstChild; r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && Kn(
        s,
        this.readFeaturesFromNode(
          /** @type {Element} */
          r,
          n
        )
      );
    return s;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    return Gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = xo(t);
        return this.readGeometryFromDocument(s, n);
      } else
        return Co(t) ? this.readGeometryFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readGeometryFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(t, n) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(t, n) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    if (t)
      if (typeof t == "string") {
        const n = xo(t);
        return this.readProjectionFromDocument(n);
      } else
        return Co(t) ? this.readProjectionFromDocument(
          /** @type {Document} */
          t
        ) : this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(t) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(t, n) {
    const s = this.writeFeatureNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(t, n) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(t, n) {
    const s = this.writeFeaturesNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(t, n) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(t, n) {
    const s = this.writeGeometryNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(t, n) {
    return null;
  }
}
const q1 = wj, ks = "http://www.opengis.net/gml", Vj = /^\s*$/;
class Cn extends q1 {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(t) {
    super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: Ht(this.readFeaturesInternal),
      featureMembers: zt(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(t, n) {
    const s = t.localName;
    let r = null;
    if (s == "FeatureCollection")
      r = At(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        t,
        n,
        this
      );
    else if (s == "featureMembers" || s == "featureMember" || s == "member") {
      const i = n[0];
      let a = i.featureType, o = i.featureNS;
      const l = "p", f = "p0";
      if (!a && t.childNodes) {
        a = [], o = {};
        for (let c = 0, h = t.childNodes.length; c < h; ++c) {
          const p = (
            /** @type {Element} */
            t.childNodes[c]
          );
          if (p.nodeType === 1) {
            const g = p.nodeName.split(":").pop();
            if (!a.includes(g)) {
              let m = "", v = 0;
              const y = p.namespaceURI;
              for (const E in o) {
                if (o[E] === y) {
                  m = E;
                  break;
                }
                ++v;
              }
              m || (m = l + v, o[m] = y), a.push(m + ":" + g);
            }
          }
        }
        s != "featureMember" && (i.featureType = a, i.featureNS = o);
      }
      if (typeof o == "string") {
        const c = o;
        o = {}, o[f] = c;
      }
      const d = {}, u = Array.isArray(a) ? a : [a];
      for (const c in o) {
        const h = {};
        for (let p = 0, g = u.length; p < g; ++p)
          (u[p].includes(":") ? u[p].split(":")[0] : f) === c && (h[u[p].split(":").pop()] = s == "featureMembers" ? Ht(this.readFeatureElement, this) : zt(this.readFeatureElement, this));
        d[o[c]] = h;
      }
      s == "featureMember" || s == "member" ? r = At(void 0, d, t, n) : r = At([], d, t, n);
    }
    return r === null && (r = []), r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    );
    return s.srsName = t.firstElementChild.getAttribute("srsName"), s.srsDimension = t.firstElementChild.getAttribute("srsDimension"), At(
      null,
      this.GEOMETRY_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    ), r = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(t, n)
    );
    return r ? e0(r, s) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    ), r = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(t, n)
    );
    return r ? mu(r, !1, s) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(t, n, s) {
    let r;
    const i = {};
    for (let a = t.firstElementChild; a; a = a.nextElementSibling) {
      let o;
      const l = a.localName;
      a.childNodes.length === 0 || a.childNodes.length === 1 && (a.firstChild.nodeType === 3 || a.firstChild.nodeType === 4) ? (o = No(a, !1), Vj.test(o) && (o = void 0)) : (s && (o = l === "boundedBy" ? this.readExtentElement(a, n) : this.readGeometryElement(a, n)), o ? l !== "boundedBy" && (r = l) : o = this.readFeatureElementInternal(a, n, !1));
      const f = a.attributes.length;
      if (f > 0) {
        o = { _content_: o };
        for (let d = 0; d < f; d++) {
          const u = a.attributes[d].name;
          o[u] = a.attributes[d].value;
        }
      }
      i[l] ? (i[l] instanceof Array || (i[l] = [i[l]]), i[l].push(o)) : i[l] = o;
    }
    if (s) {
      const a = new Xi(i);
      r && a.setGeometryName(r);
      const o = t.getAttribute("fid") || cF(t, this.namespace, "id");
      return o && a.setId(o), a;
    } else
      return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(t, n) {
    return this.readFeatureElementInternal(t, n, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new hi(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(t, n) {
    const s = At(
      [],
      this.MULTIPOINT_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new gu(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(t, n) {
    const s = At(
      [],
      this.MULTILINESTRING_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new Zs(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(t, n) {
    const s = At(
      [],
      this.MULTIPOLYGON_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new Js(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(t, n) {
    Mo(this.POINTMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(t, n) {
    Mo(this.LINESTRINGMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(t, n) {
    Mo(this.POLYGONMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new qi(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(t, n) {
    const s = At(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new vd(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(t, n) {
    const s = At(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      t,
      n,
      this
    );
    if (s && s[0]) {
      const r = s[0], i = [r.length];
      let a, o;
      for (a = 1, o = s.length; a < o; ++a)
        Kn(r, s[a]), i.push(r.length);
      return new nr(r, "XYZ", i);
    } else
      return;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(t, n) {
    return At(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(t, n) {
    const s = this.readGeometryElement(t, [
      this.getReadOptions(t, n || {})
    ]);
    return s || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    const s = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return s && Object.assign(s, this.getReadOptions(t, n)), this.readFeaturesInternal(t, [s]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    return Wt(
      this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")
    );
  }
}
Cn.prototype.namespace = ks;
Cn.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Cn.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Cn.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Cn.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: Ht(Cn.prototype.pointMemberParser),
    pointMembers: Ht(Cn.prototype.pointMemberParser)
  }
};
Cn.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: Ht(
      Cn.prototype.lineStringMemberParser
    ),
    lineStringMembers: Ht(
      Cn.prototype.lineStringMemberParser
    )
  }
};
Cn.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: Ht(Cn.prototype.polygonMemberParser),
    polygonMembers: Ht(Cn.prototype.polygonMemberParser)
  }
};
Cn.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: Ht(Cn.prototype.readFlatCoordinatesFromNode)
  }
};
Cn.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: Ht(Cn.prototype.readLineString)
  }
};
Cn.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: Ht(Cn.prototype.readPolygon)
  }
};
Cn.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: zt(Cn.prototype.readFlatLinearRing)
  }
};
const he = Cn, Bj = ks + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", Nj = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class ve extends he {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[ks].featureMember = Ht(
      this.readFeaturesInternal
    ), this.schemaLocation = t.schemaLocation ? t.schemaLocation : Bj;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(t, n) {
    const s = No(t, !1).replace(/^\s*|\s*$/g, ""), i = /** @type {import("../xml.js").NodeStackItem} */ n[0].srsName;
    let a = "enu";
    if (i) {
      const f = Wt(i);
      f && (a = f.getAxisOrientation());
    }
    const o = s.trim().split(/\s+/), l = [];
    for (let f = 0, d = o.length; f < d; f++) {
      const u = o[f].split(/,+/), c = parseFloat(u[0]), h = parseFloat(u[1]), p = u.length === 3 ? parseFloat(u[2]) : 0;
      a.substr(0, 2) === "en" ? l.push(c, h, p) : l.push(h, c, p);
    }
    return l;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(t, n) {
    const s = At(
      [null],
      this.BOX_PARSERS_,
      t,
      n,
      this
    );
    return er(
      s[1][0],
      s[1][1],
      s[1][3],
      s[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    s && /** @type {Array<Array<number>>} */
    n[n.length - 1].push(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    if (s) {
      const r = (
        /** @type {Array<Array<number>>} */
        n[n.length - 1]
      );
      r[0] = s;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.multiSurface, a = r.surface, o = r.multiCurve;
    return Array.isArray(t) ? s = "Envelope" : (s = /** @type {import("../geom/Geometry.js").default} */
    t.getType(), s === "MultiPolygon" && i === !0 ? s = "MultiSurface" : s === "Polygon" && a === !0 ? s = "Surface" : s === "MultiLineString" && o === !0 && (s = "MultiCurve")), le("http://www.opengis.net/gml", s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(t, n, s) {
    const r = n.getId();
    r && t.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const i = (
      /** @type {Object} */
      s[s.length - 1]
    ), a = i.featureNS, o = n.getGeometryName();
    i.serializers || (i.serializers = {}, i.serializers[a] = {});
    const l = [], f = [];
    if (n.hasProperties()) {
      const u = n.getProperties();
      for (const c in u) {
        const h = u[c];
        h !== null && (l.push(c), f.push(h), c == o || typeof /** @type {?} */
        h.getSimplifiedGeometry == "function" ? c in i.serializers[a] || (i.serializers[a][c] = gt(
          this.writeGeometryElement,
          this
        )) : c in i.serializers[a] || (i.serializers[a][c] = gt(Ln)));
      }
    }
    const d = Object.assign({}, i);
    d.node = t, En(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      i.serializers,
      tr(void 0, a),
      f,
      s,
      l
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(t, n, s) {
    const i = s[s.length - 1].srsName;
    if (t.nodeName !== "LineStringSegment" && i && t.setAttribute("srsName", i), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
      const a = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(a), this.writeCoordinates_(a, n, s);
    } else if (t.nodeName === "Curve") {
      const a = le(t.namespaceURI, "segments");
      t.appendChild(a), this.writeCurveSegments_(a, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeCurveOrLineString(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.curve;
    a && t.setAttribute("srsName", a);
    const l = n.getLineStrings();
    En(
      { node: t, hasZ: i, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(t, n, s) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      s[s.length - 1]
    ), i = Object.assign({}, r);
    i.node = t;
    let a;
    Array.isArray(n) ? a = e0(
      /** @type {import("../extent.js").Extent} */
      n,
      r
    ) : a = mu(
      /** @type {import("../geom/Geometry.js").default} */
      n,
      !0,
      r
    ), En(
      /** @type {import("../xml.js").NodeStackItem} */
      i,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      s,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(t) {
    const n = le(t, "coordinates");
    return n.setAttribute("decimal", "."), n.setAttribute("cs", ","), n.setAttribute("ts", " "), n;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = n.getCoordinates(), l = o.length, f = new Array(l);
    for (let d = 0; d < l; ++d) {
      const u = o[d];
      f[d] = this.getCoords_(u, a, i);
    }
    Ln(t, f.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(t, n, s) {
    const r = le(t.namespaceURI, "LineStringSegment");
    t.appendChild(r), this.writeCurveOrLineString(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
      const o = n.getLinearRings();
      En(
        { node: t, hasZ: i, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        s,
        void 0,
        this
      );
    } else if (t.nodeName === "Surface") {
      const o = le(t.namespaceURI, "patches");
      t.appendChild(o), this.writeSurfacePatches_(o, n, s);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.node, a = r.exteriorWritten;
    return a === void 0 && (r.exteriorWritten = !0), le(
      i.namespaceURI,
      a !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(t, n, s) {
    const r = le(t.namespaceURI, "PolygonPatch");
    t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(t, n, s) {
    const r = le(t.namespaceURI, "LinearRing");
    t.appendChild(r), this.writeLinearRing(r, n, s);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(t, n, s) {
    let r = "enu";
    n && (r = Wt(n).getAxisOrientation());
    let i = r.substr(0, 2) === "en" ? t[0] + "," + t[1] : t[1] + "," + t[0];
    if (s) {
      const a = t[2] || 0;
      i += "," + a;
    }
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    a && t.setAttribute("srsName", a);
    const o = this.createCoordinatesNode_(t.namespaceURI);
    t.appendChild(o);
    const l = n.getCoordinates(), f = this.getCoords_(l, a, i);
    Ln(o, f);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    a && t.setAttribute("srsName", a);
    const o = n.getPoints();
    En(
      { node: t, hasZ: i, srsName: a },
      this.POINTMEMBER_SERIALIZERS,
      tr("pointMember"),
      o,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(t, n, s) {
    const r = le(t.namespaceURI, "Point");
    t.appendChild(r), this.writePoint(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = this.createCoordinatesNode_(t.namespaceURI);
    t.appendChild(a), this.writeCoordinates_(a, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.surface;
    a && t.setAttribute("srsName", a);
    const l = n.getPolygons();
    En(
      { node: t, hasZ: i, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ["lowerCorner", "upperCorner"], o = [n[0] + " " + n[1], n[2] + " " + n[3]];
    En(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: t },
      this.ENVELOPE_SERIALIZERS,
      z1,
      o,
      s,
      a,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1].node;
    return le(
      "http://www.opengis.net/gml",
      Nj[r.nodeName]
    );
  }
}
ve.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: zt(ve.prototype.readFlatCoordinates)
  }
};
ve.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: ve.prototype.innerBoundaryIsParser,
    outerBoundaryIs: ve.prototype.outerBoundaryIsParser
  }
};
ve.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: Ht(ve.prototype.readFlatCoordinates)
  }
};
ve.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: zt(he.prototype.readPoint),
    MultiPoint: zt(he.prototype.readMultiPoint),
    LineString: zt(he.prototype.readLineString),
    MultiLineString: zt(he.prototype.readMultiLineString),
    LinearRing: zt(he.prototype.readLinearRing),
    Polygon: zt(he.prototype.readPolygon),
    MultiPolygon: zt(he.prototype.readMultiPolygon),
    Box: zt(ve.prototype.readBox)
  }
};
ve.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: gt(ve.prototype.writeCurveOrLineString),
    MultiCurve: gt(ve.prototype.writeMultiCurveOrLineString),
    Point: gt(ve.prototype.writePoint),
    MultiPoint: gt(ve.prototype.writeMultiPoint),
    LineString: gt(ve.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      ve.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(ve.prototype.writeLinearRing),
    Polygon: gt(ve.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      ve.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(ve.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      ve.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(ve.prototype.writeEnvelope)
  }
};
ve.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: gt(
      ve.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      ve.prototype.writeLineStringOrCurveMember
    )
  }
};
ve.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: gt(ve.prototype.writeRing),
    innerBoundaryIs: gt(ve.prototype.writeRing)
  }
};
ve.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: gt(ve.prototype.writePointMember)
  }
};
ve.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: gt(
      ve.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      ve.prototype.writeSurfaceOrPolygonMember
    )
  }
};
ve.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: gt(Ln),
    upperCorner: gt(Ln)
  }
};
const Qo = ve, Fj = ks + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", jj = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class jt extends he {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : !1, this.curve_ = t.curve !== void 0 ? t.curve : !1, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : !0, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : !0, this.schemaLocation = t.schemaLocation ? t.schemaLocation : Fj, this.hasZ = t.hasZ !== void 0 ? t.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(t, n) {
    const s = At(
      [],
      this.MULTICURVE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new Zs(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(t, n) {
    const s = At(
      [],
      this.MULTICURVE_PARSERS,
      t,
      n,
      this
    ), r = [];
    for (let i = 0, a = s.length; i < a; ++i)
      Kn(r, s[i].getFlatCoordinates());
    return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(t, n) {
    const s = At(
      [],
      this.MULTISURFACE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new Js(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(t, n) {
    Mo(this.CURVEMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(t, n) {
    Mo(this.SURFACEMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(t, n) {
    return At(
      [null],
      this.PATCHES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(t, n) {
    return At([], this.SEGMENTS_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(t, n) {
    return At(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(t, n) {
    return At(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    s && /** @type {Array<Array<number>>} */
    n[n.length - 1].push(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    if (s) {
      const r = (
        /** @type {Array<Array<number>>} */
        n[n.length - 1]
      );
      r[0] = s;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(t, n) {
    const s = At(
      [null],
      this.SURFACE_PARSERS,
      t,
      n,
      this
    );
    if (s && s[0]) {
      const r = s[0], i = [r.length];
      let a, o;
      for (a = 1, o = s.length; a < o; ++a)
        Kn(r, s[a]), i.push(r.length);
      return new nr(r, "XYZ", i);
    } else
      return;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(t, n) {
    const s = At(
      [null],
      this.CURVE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new qi(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(t, n) {
    const s = At(
      [null],
      this.ENVELOPE_PARSERS,
      t,
      n,
      this
    );
    return er(
      s[1][0],
      s[1][1],
      s[2][0],
      s[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(t, n) {
    let s = No(t, !1);
    const r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, i = [];
    let a;
    for (; a = r.exec(s); )
      i.push(parseFloat(a[1])), s = s.substr(a[0].length);
    if (s !== "")
      return;
    const l = n[0].srsName;
    let f = "enu";
    if (l && (f = Wt(l).getAxisOrientation()), f === "neu") {
      let u, c;
      for (u = 0, c = i.length; u < c; u += 3) {
        const h = i[u], p = i[u + 1];
        i[u] = p, i[u + 1] = h;
      }
    }
    const d = i.length;
    if (d == 2 && i.push(0), d !== 0)
      return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(t, n) {
    const s = No(t, !1).replace(/^\s*|\s*$/g, ""), r = n[0], i = r.srsName, a = r.srsDimension;
    let o = "enu";
    i && (o = Wt(i).getAxisOrientation());
    const l = s.split(/\s+/);
    let f = 2;
    t.getAttribute("srsDimension") ? f = Us(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? f = Us(t.getAttribute("dimension")) : /** @type {Element} */ t.parentNode.getAttribute("srsDimension") ? f = Us(
      /** @type {Element} */
      t.parentNode.getAttribute("srsDimension")
    ) : a && (f = Us(a));
    let d, u, c;
    const h = [];
    for (let p = 0, g = l.length; p < g; p += f)
      d = parseFloat(l[p]), u = parseFloat(l[p + 1]), c = f === 3 ? parseFloat(l[p + 2]) : 0, o.substr(0, 2) === "en" ? h.push(d, u, c) : h.push(u, d, c);
    return h;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = i ? "3" : "2";
    t.setAttribute("srsDimension", a);
    const o = r.srsName;
    let l = "enu";
    o && (l = Wt(o).getAxisOrientation());
    const f = n.getCoordinates();
    let d;
    if (l.substr(0, 2) === "en" ? d = f[0] + " " + f[1] : d = f[1] + " " + f[0], i) {
      const u = f[2] || 0;
      d += " " + u;
    }
    Ln(t, d);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(t, n, s) {
    let r = "enu";
    n && (r = Wt(n).getAxisOrientation());
    let i = r.substr(0, 2) === "en" ? t[0] + " " + t[1] : t[1] + " " + t[0];
    if (s) {
      const a = t[2] || 0;
      i += " " + a;
    }
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = i ? "3" : "2";
    t.setAttribute("srsDimension", a);
    const o = r.srsName, l = n.getCoordinates(), f = l.length, d = new Array(f);
    let u;
    for (let c = 0; c < f; ++c)
      u = l[c], d[c] = this.getCoords_(u, o, i);
    Ln(t, d.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = le(t.namespaceURI, "pos");
    t.appendChild(a), this.writePos_(a, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ["lowerCorner", "upperCorner"], o = [n[0] + " " + n[1], n[2] + " " + n[3]];
    En(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: t },
      this.ENVELOPE_SERIALIZERS,
      z1,
      o,
      s,
      a,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = le(t.namespaceURI, "posList");
    t.appendChild(a), this.writePosList_(a, n, s);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.node, a = r.exteriorWritten;
    return a === void 0 && (r.exteriorWritten = !0), le(
      i.namespaceURI,
      a !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
      const o = n.getLinearRings();
      En(
        { node: t, hasZ: i, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        s,
        void 0,
        this
      );
    } else if (t.nodeName === "Surface") {
      const o = le(t.namespaceURI, "patches");
      t.appendChild(o), this.writeSurfacePatches_(o, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(t, n, s) {
    const i = s[s.length - 1].srsName;
    if (t.nodeName !== "LineStringSegment" && i && t.setAttribute("srsName", i), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
      const a = le(t.namespaceURI, "posList");
      t.appendChild(a), this.writePosList_(a, n, s);
    } else if (t.nodeName === "Curve") {
      const a = le(t.namespaceURI, "segments");
      t.appendChild(a), this.writeCurveSegments_(a, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.surface;
    a && t.setAttribute("srsName", a);
    const l = n.getPolygons();
    En(
      { node: t, hasZ: i, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(t, n, s) {
    const r = s[s.length - 1], i = r.srsName, a = r.hasZ;
    i && t.setAttribute("srsName", i);
    const o = n.getPoints();
    En(
      { node: t, hasZ: a, srsName: i },
      this.POINTMEMBER_SERIALIZERS,
      tr("pointMember"),
      o,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.curve;
    a && t.setAttribute("srsName", a);
    const l = n.getLineStrings();
    En(
      { node: t, hasZ: i, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(t, n, s) {
    const r = le(t.namespaceURI, "LinearRing");
    t.appendChild(r), this.writeLinearRing(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(t, n, s) {
    const r = le(t.namespaceURI, "Point");
    t.appendChild(r), this.writePoint(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeCurveOrLineString(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(t, n, s) {
    const r = le(t.namespaceURI, "PolygonPatch");
    t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(t, n, s) {
    const r = le(t.namespaceURI, "LineStringSegment");
    t.appendChild(r), this.writeCurveOrLineString(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(t, n, s) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      s[s.length - 1]
    ), i = Object.assign({}, r);
    i.node = t;
    let a;
    Array.isArray(n) ? a = e0(
      /** @type {import("../extent.js").Extent} */
      n,
      r
    ) : a = mu(
      /** @type {import("../geom/Geometry.js").default} */
      n,
      !0,
      r
    ), En(
      /** @type {import("../xml.js").NodeStackItem} */
      i,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(t, n, s) {
    const r = n.getId();
    r && t.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const i = (
      /** @type {Object} */
      s[s.length - 1]
    ), a = i.featureNS, o = n.getGeometryName();
    i.serializers || (i.serializers = {}, i.serializers[a] = {});
    const l = [], f = [];
    if (n.hasProperties()) {
      const u = n.getProperties();
      for (const c in u) {
        const h = u[c];
        h !== null && (l.push(c), f.push(h), c == o || typeof /** @type {?} */
        h.getSimplifiedGeometry == "function" ? c in i.serializers[a] || (i.serializers[a][c] = gt(
          this.writeGeometryElement,
          this
        )) : c in i.serializers[a] || (i.serializers[a][c] = gt(Ln)));
      }
    }
    const d = Object.assign({}, i);
    d.node = t, En(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      i.serializers,
      tr(void 0, a),
      f,
      s,
      l
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(t, n, s) {
    const r = (
      /** @type {Object} */
      s[s.length - 1]
    ), i = r.featureType, a = r.featureNS, o = {};
    o[a] = {}, o[a][i] = gt(
      this.writeFeatureElement,
      this
    );
    const l = Object.assign({}, r);
    l.node = t, En(
      /** @type {import("../xml.js").NodeStackItem} */
      l,
      o,
      tr(i, a),
      n,
      s
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1].node;
    return le(
      this.namespace,
      jj[r.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.multiSurface, a = r.surface, o = r.curve, l = r.multiCurve;
    return Array.isArray(t) ? s = "Envelope" : (s = /** @type {import("../geom/Geometry.js").default} */
    t.getType(), s === "MultiPolygon" && i === !0 ? s = "MultiSurface" : s === "Polygon" && a === !0 ? s = "Surface" : s === "LineString" && o === !0 ? s = "Curve" : s === "MultiLineString" && l === !0 && (s = "MultiCurve")), le(this.namespace, s);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(t, n) {
    n = this.adaptOptions(n);
    const s = le(this.namespace, "geom"), r = {
      node: s,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return n && Object.assign(r, n), this.writeGeometryElement(s, t, [r]), s;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(t, n) {
    n = this.adaptOptions(n);
    const s = le(this.namespace, "featureMembers");
    s.setAttributeNS(
      Hg,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const r = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return n && Object.assign(r, n), this.writeFeatureMembers_(s, t, [r]), s;
  }
}
jt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: zt(jt.prototype.readFlatPos),
    posList: zt(jt.prototype.readFlatPosList),
    coordinates: zt(Qo.prototype.readFlatCoordinates)
  }
};
jt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: jt.prototype.interiorParser,
    exterior: jt.prototype.exteriorParser
  }
};
jt.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: zt(he.prototype.readPoint),
    MultiPoint: zt(he.prototype.readMultiPoint),
    LineString: zt(he.prototype.readLineString),
    MultiLineString: zt(he.prototype.readMultiLineString),
    LinearRing: zt(he.prototype.readLinearRing),
    Polygon: zt(he.prototype.readPolygon),
    MultiPolygon: zt(he.prototype.readMultiPolygon),
    Surface: zt(jt.prototype.readSurface),
    MultiSurface: zt(jt.prototype.readMultiSurface),
    Curve: zt(jt.prototype.readCurve),
    MultiCurve: zt(jt.prototype.readMultiCurve),
    Envelope: zt(jt.prototype.readEnvelope)
  }
};
jt.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: Ht(jt.prototype.curveMemberParser),
    curveMembers: Ht(jt.prototype.curveMemberParser)
  }
};
jt.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: Ht(jt.prototype.surfaceMemberParser),
    surfaceMembers: Ht(jt.prototype.surfaceMemberParser)
  }
};
jt.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: Ht(he.prototype.readLineString),
    Curve: Ht(jt.prototype.readCurve)
  }
};
jt.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: Ht(he.prototype.readPolygon),
    Surface: Ht(jt.prototype.readSurface)
  }
};
jt.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: zt(jt.prototype.readPatch)
  }
};
jt.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: zt(jt.prototype.readSegment)
  }
};
jt.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: Ht(jt.prototype.readFlatPosList),
    upperCorner: Ht(jt.prototype.readFlatPosList)
  }
};
jt.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: zt(jt.prototype.readPolygonPatch)
  }
};
jt.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: $1(
      jt.prototype.readLineStringSegment
    )
  }
};
he.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: zt(he.prototype.readFlatLinearRing),
    Ring: zt(jt.prototype.readFlatCurveRing)
  }
};
jt.prototype.writeFeatures;
jt.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: gt(jt.prototype.writeRing),
    interior: gt(jt.prototype.writeRing)
  }
};
jt.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: gt(Ln),
    upperCorner: gt(Ln)
  }
};
jt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: gt(
      jt.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      jt.prototype.writeSurfaceOrPolygonMember
    )
  }
};
jt.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: gt(jt.prototype.writePointMember)
  }
};
jt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: gt(
      jt.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      jt.prototype.writeLineStringOrCurveMember
    )
  }
};
jt.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: gt(jt.prototype.writeCurveOrLineString),
    MultiCurve: gt(jt.prototype.writeMultiCurveOrLineString),
    Point: gt(jt.prototype.writePoint),
    MultiPoint: gt(jt.prototype.writeMultiPoint),
    LineString: gt(jt.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      jt.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(jt.prototype.writeLinearRing),
    Polygon: gt(jt.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      jt.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(jt.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      jt.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(jt.prototype.writeEnvelope)
  }
};
const re = jt, i0 = re;
i0.prototype.writeFeatures;
i0.prototype.writeFeaturesNode;
const tM = i0;
var _t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qo(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function eM(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function s() {
      return this instanceof s ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(s) {
    var r = Object.getOwnPropertyDescriptor(e, s);
    Object.defineProperty(n, s, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[s];
      }
    });
  }), n;
}
var Bf = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Bf.read = function(e, t, n, s, r) {
  var i, a, o = r * 8 - s - 1, l = (1 << o) - 1, f = l >> 1, d = -7, u = n ? r - 1 : 0, c = n ? -1 : 1, h = e[t + u];
  for (u += c, i = h & (1 << -d) - 1, h >>= -d, d += o; d > 0; i = i * 256 + e[t + u], u += c, d -= 8)
    ;
  for (a = i & (1 << -d) - 1, i >>= -d, d += s; d > 0; a = a * 256 + e[t + u], u += c, d -= 8)
    ;
  if (i === 0)
    i = 1 - f;
  else {
    if (i === l)
      return a ? NaN : (h ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, s), i = i - f;
  }
  return (h ? -1 : 1) * a * Math.pow(2, i - s);
};
Bf.write = function(e, t, n, s, r, i) {
  var a, o, l, f = i * 8 - r - 1, d = (1 << f) - 1, u = d >> 1, c = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = s ? 0 : i - 1, p = s ? 1 : -1, g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = d) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + u >= 1 ? t += c / l : t += c * Math.pow(2, 1 - u), t * l >= 2 && (a++, l /= 2), a + u >= d ? (o = 0, a = d) : a + u >= 1 ? (o = (t * l - 1) * Math.pow(2, r), a = a + u) : (o = t * Math.pow(2, u - 1) * Math.pow(2, r), a = 0)); r >= 8; e[n + h] = o & 255, h += p, o /= 256, r -= 8)
    ;
  for (a = a << r | o, f += r; f > 0; e[n + h] = a & 255, h += p, a /= 256, f -= 8)
    ;
  e[n + h - p] |= g * 128;
};
var Uj = Oe, bh = Bf;
function Oe(e) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
}
Oe.Varint = 0;
Oe.Fixed64 = 1;
Oe.Bytes = 2;
Oe.Fixed32 = 5;
var Jg = 65536 * 65536, wC = 1 / Jg, Wj = 12, nM = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
Oe.prototype = {
  destroy: function() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function(e, t, n) {
    for (n = n || this.length; this.pos < n; ) {
      var s = this.readVarint(), r = s >> 3, i = this.pos;
      this.type = s & 7, e(r, t, this), this.pos === i && this.skip(s);
    }
    return t;
  },
  readMessage: function(e, t) {
    return this.readFields(e, t, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var e = Oh(this.buf, this.pos);
    return this.pos += 4, e;
  },
  readSFixed32: function() {
    var e = BC(this.buf, this.pos);
    return this.pos += 4, e;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function() {
    var e = Oh(this.buf, this.pos) + Oh(this.buf, this.pos + 4) * Jg;
    return this.pos += 8, e;
  },
  readSFixed64: function() {
    var e = Oh(this.buf, this.pos) + BC(this.buf, this.pos + 4) * Jg;
    return this.pos += 8, e;
  },
  readFloat: function() {
    var e = bh.read(this.buf, this.pos, !0, 23, 4);
    return this.pos += 4, e;
  },
  readDouble: function() {
    var e = bh.read(this.buf, this.pos, !0, 52, 8);
    return this.pos += 8, e;
  },
  readVarint: function(e) {
    var t = this.buf, n, s;
    return s = t[this.pos++], n = s & 127, s < 128 || (s = t[this.pos++], n |= (s & 127) << 7, s < 128) || (s = t[this.pos++], n |= (s & 127) << 14, s < 128) || (s = t[this.pos++], n |= (s & 127) << 21, s < 128) ? n : (s = t[this.pos], n |= (s & 15) << 28, $j(n, e, this));
  },
  readVarint64: function() {
    return this.readVarint(!0);
  },
  readSVarint: function() {
    var e = this.readVarint();
    return e % 2 === 1 ? (e + 1) / -2 : e / 2;
  },
  readBoolean: function() {
    return !!this.readVarint();
  },
  readString: function() {
    var e = this.readVarint() + this.pos, t = this.pos;
    return this.pos = e, e - t >= Wj && nM ? nU(this.buf, t, e) : eU(this.buf, t, e);
  },
  readBytes: function() {
    var e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e);
    return this.pos = e, t;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function(e, t) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readVarint(t));
    var n = _s(this);
    for (e = e || []; this.pos < n; )
      e.push(this.readVarint(t));
    return e;
  },
  readPackedSVarint: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSVarint());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSVarint());
    return e;
  },
  readPackedBoolean: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readBoolean());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readBoolean());
    return e;
  },
  readPackedFloat: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFloat());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFloat());
    return e;
  },
  readPackedDouble: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readDouble());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readDouble());
    return e;
  },
  readPackedFixed32: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFixed32());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFixed32());
    return e;
  },
  readPackedSFixed32: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSFixed32());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSFixed32());
    return e;
  },
  readPackedFixed64: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFixed64());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFixed64());
    return e;
  },
  readPackedSFixed64: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSFixed64());
    var t = _s(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSFixed64());
    return e;
  },
  skip: function(e) {
    var t = e & 7;
    if (t === Oe.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (t === Oe.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (t === Oe.Fixed32)
      this.pos += 4;
    else if (t === Oe.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + t);
  },
  // === WRITING =================================================================
  writeTag: function(e, t) {
    this.writeVarint(e << 3 | t);
  },
  realloc: function(e) {
    for (var t = this.length || 16; t < this.pos + e; )
      t *= 2;
    if (t !== this.length) {
      var n = new Uint8Array(t);
      n.set(this.buf), this.buf = n, this.length = t;
    }
  },
  finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  },
  writeFixed32: function(e) {
    this.realloc(4), ul(this.buf, e, this.pos), this.pos += 4;
  },
  writeSFixed32: function(e) {
    this.realloc(4), ul(this.buf, e, this.pos), this.pos += 4;
  },
  writeFixed64: function(e) {
    this.realloc(8), ul(this.buf, e & -1, this.pos), ul(this.buf, Math.floor(e * wC), this.pos + 4), this.pos += 8;
  },
  writeSFixed64: function(e) {
    this.realloc(8), ul(this.buf, e & -1, this.pos), ul(this.buf, Math.floor(e * wC), this.pos + 4), this.pos += 8;
  },
  writeVarint: function(e) {
    if (e = +e || 0, e > 268435455 || e < 0) {
      zj(e, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = e & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = e >>> 7 & 127)));
  },
  writeSVarint: function(e) {
    this.writeVarint(e < 0 ? -e * 2 - 1 : e * 2);
  },
  writeBoolean: function(e) {
    this.writeVarint(!!e);
  },
  writeString: function(e) {
    e = String(e), this.realloc(e.length * 4), this.pos++;
    var t = this.pos;
    this.pos = iU(this.buf, e, this.pos);
    var n = this.pos - t;
    n >= 128 && VC(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
  },
  writeFloat: function(e) {
    this.realloc(4), bh.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4;
  },
  writeDouble: function(e) {
    this.realloc(8), bh.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8;
  },
  writeBytes: function(e) {
    var t = e.length;
    this.writeVarint(t), this.realloc(t);
    for (var n = 0; n < t; n++)
      this.buf[this.pos++] = e[n];
  },
  writeRawMessage: function(e, t) {
    this.pos++;
    var n = this.pos;
    e(t, this);
    var s = this.pos - n;
    s >= 128 && VC(n, s, this), this.pos = n - 1, this.writeVarint(s), this.pos += s;
  },
  writeMessage: function(e, t, n) {
    this.writeTag(e, Oe.Bytes), this.writeRawMessage(t, n);
  },
  writePackedVarint: function(e, t) {
    t.length && this.writeMessage(e, kj, t);
  },
  writePackedSVarint: function(e, t) {
    t.length && this.writeMessage(e, Hj, t);
  },
  writePackedBoolean: function(e, t) {
    t.length && this.writeMessage(e, Zj, t);
  },
  writePackedFloat: function(e, t) {
    t.length && this.writeMessage(e, Yj, t);
  },
  writePackedDouble: function(e, t) {
    t.length && this.writeMessage(e, Xj, t);
  },
  writePackedFixed32: function(e, t) {
    t.length && this.writeMessage(e, Jj, t);
  },
  writePackedSFixed32: function(e, t) {
    t.length && this.writeMessage(e, Qj, t);
  },
  writePackedFixed64: function(e, t) {
    t.length && this.writeMessage(e, qj, t);
  },
  writePackedSFixed64: function(e, t) {
    t.length && this.writeMessage(e, tU, t);
  },
  writeBytesField: function(e, t) {
    this.writeTag(e, Oe.Bytes), this.writeBytes(t);
  },
  writeFixed32Field: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeFixed32(t);
  },
  writeSFixed32Field: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeSFixed32(t);
  },
  writeFixed64Field: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeFixed64(t);
  },
  writeSFixed64Field: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeSFixed64(t);
  },
  writeVarintField: function(e, t) {
    this.writeTag(e, Oe.Varint), this.writeVarint(t);
  },
  writeSVarintField: function(e, t) {
    this.writeTag(e, Oe.Varint), this.writeSVarint(t);
  },
  writeStringField: function(e, t) {
    this.writeTag(e, Oe.Bytes), this.writeString(t);
  },
  writeFloatField: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeFloat(t);
  },
  writeDoubleField: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeDouble(t);
  },
  writeBooleanField: function(e, t) {
    this.writeVarintField(e, !!t);
  }
};
function $j(e, t, n) {
  var s = n.buf, r, i;
  if (i = s[n.pos++], r = (i & 112) >> 4, i < 128 || (i = s[n.pos++], r |= (i & 127) << 3, i < 128) || (i = s[n.pos++], r |= (i & 127) << 10, i < 128) || (i = s[n.pos++], r |= (i & 127) << 17, i < 128) || (i = s[n.pos++], r |= (i & 127) << 24, i < 128) || (i = s[n.pos++], r |= (i & 1) << 31, i < 128))
    return ll(e, r, t);
  throw new Error("Expected varint not more than 10 bytes");
}
function _s(e) {
  return e.type === Oe.Bytes ? e.readVarint() + e.pos : e.pos + 1;
}
function ll(e, t, n) {
  return n ? t * 4294967296 + (e >>> 0) : (t >>> 0) * 4294967296 + (e >>> 0);
}
function zj(e, t) {
  var n, s;
  if (e >= 0 ? (n = e % 4294967296 | 0, s = e / 4294967296 | 0) : (n = ~(-e % 4294967296), s = ~(-e / 4294967296), n ^ 4294967295 ? n = n + 1 | 0 : (n = 0, s = s + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  t.realloc(10), Kj(n, s, t), Gj(s, t);
}
function Kj(e, t, n) {
  n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos] = e & 127;
}
function Gj(e, t) {
  var n = (e & 7) << 4;
  t.buf[t.pos++] |= n | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127)))));
}
function VC(e, t, n) {
  var s = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (Math.LN2 * 7));
  n.realloc(s);
  for (var r = n.pos - 1; r >= e; r--)
    n.buf[r + s] = n.buf[r];
}
function kj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeVarint(e[n]);
}
function Hj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSVarint(e[n]);
}
function Yj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFloat(e[n]);
}
function Xj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeDouble(e[n]);
}
function Zj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeBoolean(e[n]);
}
function Jj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFixed32(e[n]);
}
function Qj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSFixed32(e[n]);
}
function qj(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFixed64(e[n]);
}
function tU(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSFixed64(e[n]);
}
function Oh(e, t) {
  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + e[t + 3] * 16777216;
}
function ul(e, t, n) {
  e[n] = t, e[n + 1] = t >>> 8, e[n + 2] = t >>> 16, e[n + 3] = t >>> 24;
}
function BC(e, t) {
  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24);
}
function eU(e, t, n) {
  for (var s = "", r = t; r < n; ) {
    var i = e[r], a = null, o = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
    if (r + o > n)
      break;
    var l, f, d;
    o === 1 ? i < 128 && (a = i) : o === 2 ? (l = e[r + 1], (l & 192) === 128 && (a = (i & 31) << 6 | l & 63, a <= 127 && (a = null))) : o === 3 ? (l = e[r + 1], f = e[r + 2], (l & 192) === 128 && (f & 192) === 128 && (a = (i & 15) << 12 | (l & 63) << 6 | f & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : o === 4 && (l = e[r + 1], f = e[r + 2], d = e[r + 3], (l & 192) === 128 && (f & 192) === 128 && (d & 192) === 128 && (a = (i & 15) << 18 | (l & 63) << 12 | (f & 63) << 6 | d & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, o = 1) : a > 65535 && (a -= 65536, s += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), s += String.fromCharCode(a), r += o;
  }
  return s;
}
function nU(e, t, n) {
  return nM.decode(e.subarray(t, n));
}
function iU(e, t, n) {
  for (var s = 0, r, i; s < t.length; s++) {
    if (r = t.charCodeAt(s), r > 55295 && r < 57344)
      if (i)
        if (r < 56320) {
          e[n++] = 239, e[n++] = 191, e[n++] = 189, i = r;
          continue;
        } else
          r = i - 55296 << 10 | r - 56320 | 65536, i = null;
      else {
        r > 56319 || s + 1 === t.length ? (e[n++] = 239, e[n++] = 191, e[n++] = 189) : i = r;
        continue;
      }
    else
      i && (e[n++] = 239, e[n++] = 191, e[n++] = 189, i = null);
    r < 128 ? e[n++] = r : (r < 2048 ? e[n++] = r >> 6 | 192 : (r < 65536 ? e[n++] = r >> 12 | 224 : (e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128), e[n++] = r >> 6 & 63 | 128), e[n++] = r & 63 | 128);
  }
  return n;
}
const rU = /* @__PURE__ */ qo(Uj);
class Nf extends na {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n, s) {
    super(), s !== void 0 && n === void 0 ? this.setFlatCoordinates(s, t) : (n = n || 0, this.setCenterAndRadius(t, n, s));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const t = new Nf(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    const i = this.flatCoordinates, a = t - i[0], o = n - i[1], l = a * a + o * o;
    if (l < r) {
      if (l === 0)
        for (let f = 0; f < this.stride; ++f)
          s[f] = i[f];
      else {
        const f = this.getRadius() / Math.sqrt(l);
        s[0] = i[0] + f * a, s[1] = i[1] + f * o;
        for (let d = 2; d < this.stride; ++d)
          s[d] = i[d];
      }
      return s.length = this.stride, l;
    } else
      return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.flatCoordinates, r = t - s[0], i = n - s[1];
    return r * r + i * i <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    const n = this.flatCoordinates, s = n[this.stride] - n[0];
    return er(
      n[0] - s,
      n[1] - s,
      n[0] + s,
      n[1] + s,
      t
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], n = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return t * t + n * n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.getExtent();
    if (cn(t, n)) {
      const s = this.getCenter();
      return t[0] <= s[0] && t[2] >= s[0] || t[1] <= s[1] && t[3] >= s[1] ? !0 : Zv(t, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(t) {
    const n = this.stride, s = this.flatCoordinates[n] - this.flatCoordinates[0], r = t.slice();
    r[n] = r[0] + s;
    for (let i = 1; i < n; ++i)
      r[n + i] = t[i];
    this.setFlatCoordinates(this.layout, r), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(t, n, s) {
    this.setLayout(s, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const r = this.flatCoordinates;
    let i = qT(r, 0, t, this.stride);
    r[i++] = r[0] + n;
    for (let a = 1, o = this.stride; a < o; ++a)
      r[i++] = r[a];
    r.length = i, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(t, n) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(t) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.getCenter(), r = this.getStride();
    this.setCenter(
      iy(s, 0, s.length, r, t, n, s)
    ), this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.getCenter(), r = this.getStride();
    this.setCenter(
      QT(s, 0, s.length, r, t, n, s)
    ), this.changed();
  }
}
Nf.prototype.transform;
const iM = Nf, NC = Qi();
class Ec {
  /**
   * @param {import("../geom/Geometry.js").Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(t, n, s, r, i) {
    this.styleFunction, this.extent_, this.id_ = i, this.type_ = t, this.flatCoordinates_ = n, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = s, this.properties_ = r;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(t) {
    return this.properties_[t];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Yv(this.flatCoordinates_) : Xv(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const t = Fi(this.getExtent());
      this.flatInteriorPoints_ = hy(
        this.flatCoordinates_,
        0,
        /** @type {Array<number>} */
        this.ends_,
        2,
        t,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const t = J1(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2
      );
      this.flatInteriorPoints_ = rP(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = yd(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const t = this.flatCoordinates_;
      let n = 0;
      const s = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let r = 0, i = s.length; r < i; ++r) {
        const a = s[r], o = yd(t, n, a, 2, 0.5);
        Kn(this.flatMidpoints_, o), n = a;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(t, n) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return 2;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(t) {
    t = Wt(t);
    const n = t.getExtent(), s = t.getWorldExtent();
    if (n && s) {
      const r = In(s) / In(n);
      Fr(
        NC,
        s[0],
        s[3],
        r,
        -r,
        0,
        0,
        0
      ), Da(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        NC,
        this.flatCoordinates_
      );
    }
  }
  /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */
  getEnds() {
    return this.ends_;
  }
}
Ec.prototype.getEndss = Ec.prototype.getEnds;
Ec.prototype.getFlatCoordinates = Ec.prototype.getOrientedFlatCoordinates;
const Qg = Ec;
class sU extends t0 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.dataProjection = new Of({
      code: "",
      units: "tile-pixels"
    }), this.featureClass_ = t.featureClass ? t.featureClass : Qg, this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(t, n, s, r) {
    t.pos = n.geometry;
    const i = t.readVarint() + t.pos;
    let a = 1, o = 0, l = 0, f = 0, d = 0, u = 0;
    for (; t.pos < i; ) {
      if (!o) {
        const c = t.readVarint();
        a = c & 7, o = c >> 3;
      }
      o--, a === 1 || a === 2 ? (l += t.readSVarint(), f += t.readSVarint(), a === 1 && d > u && (r.push(d), u = d), s.push(l, f), d += 2) : a === 7 ? d > u && (s.push(
        s[u],
        s[u + 1]
      ), d += 2) : Zt(!1, 59);
    }
    d > u && (r.push(d), u = d);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(t, n, s) {
    const r = n.type;
    if (r === 0)
      return null;
    let i;
    const a = n.properties;
    let o;
    this.idProperty_ ? (o = a[this.idProperty_], delete a[this.idProperty_]) : o = n.id, a[this.layerName_] = n.layer.name;
    const l = (
      /** @type {Array<number>} */
      []
    ), f = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(t, n, l, f);
    const d = cU(r, f.length);
    if (this.featureClass_ === Qg)
      i = new this.featureClass_(
        d,
        l,
        f,
        a,
        o
      ), i.transform(s.dataProjection);
    else {
      let u;
      if (d == "Polygon") {
        const p = FD(l, f);
        u = p.length > 1 ? new Js(l, "XY", p) : new nr(l, "XY", f);
      } else
        u = d === "Point" ? new hi(l, "XY") : d === "LineString" ? new qi(l, "XY") : d === "MultiPoint" ? new gu(l, "XY") : d === "MultiLineString" ? new Zs(l, "XY", f) : null;
      const c = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass_
      );
      i = new c(), this.geometryName_ && i.setGeometryName(this.geometryName_);
      const h = mu(u, !1, s);
      i.setGeometry(h), o !== void 0 && i.setId(o), i.setProperties(a, !0);
    }
    return i;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  readFeatures(t, n) {
    const s = this.layers_;
    n = this.adaptOptions(n);
    const r = Wt(n.dataProjection);
    r.setWorldExtent(n.extent), n.dataProjection = r;
    const i = new rU(
      /** @type {ArrayBuffer} */
      t
    ), a = i.readFields(aU, {}), o = [];
    for (const l in a) {
      if (s && !s.includes(l))
        continue;
      const f = a[l], d = f ? [0, 0, f.extent, f.extent] : null;
      r.setExtent(d);
      for (let u = 0, c = f.length; u < c; ++u) {
        const h = uU(i, f, u), p = this.createFeature_(i, h, n);
        p !== null && o.push(p);
      }
    }
    return o;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(t) {
    this.layers_ = t;
  }
}
function aU(e, t, n) {
  if (e === 3) {
    const s = {
      keys: [],
      values: [],
      features: []
    }, r = n.readVarint() + n.pos;
    n.readFields(oU, s, r), s.length = s.features.length, s.length && (t[s.name] = s);
  }
}
function oU(e, t, n) {
  if (e === 15)
    t.version = n.readVarint();
  else if (e === 1)
    t.name = n.readString();
  else if (e === 5)
    t.extent = n.readVarint();
  else if (e === 2)
    t.features.push(n.pos);
  else if (e === 3)
    t.keys.push(n.readString());
  else if (e === 4) {
    let s = null;
    const r = n.readVarint() + n.pos;
    for (; n.pos < r; )
      e = n.readVarint() >> 3, s = e === 1 ? n.readString() : e === 2 ? n.readFloat() : e === 3 ? n.readDouble() : e === 4 ? n.readVarint64() : e === 5 ? n.readVarint() : e === 6 ? n.readSVarint() : e === 7 ? n.readBoolean() : null;
    t.values.push(s);
  }
}
function lU(e, t, n) {
  if (e == 1)
    t.id = n.readVarint();
  else if (e == 2) {
    const s = n.readVarint() + n.pos;
    for (; n.pos < s; ) {
      const r = t.layer.keys[n.readVarint()], i = t.layer.values[n.readVarint()];
      t.properties[r] = i;
    }
  } else
    e == 3 ? t.type = n.readVarint() : e == 4 && (t.geometry = n.pos);
}
function uU(e, t, n) {
  e.pos = t.features[n];
  const s = e.readVarint() + e.pos, r = {
    layer: t,
    type: 0,
    properties: {}
  };
  return e.readFields(lU, r, s), r;
}
function cU(e, t) {
  let n;
  return e === 1 ? n = t === 1 ? "Point" : "MultiPoint" : e === 2 ? n = t === 1 ? "LineString" : "MultiLineString" : e === 3 && (n = "Polygon"), n;
}
const rM = sU;
class be extends re {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
}
be.prototype.namespace = "http://www.opengis.net/gml/3.2";
be.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: zt(re.prototype.readFlatPos),
    posList: zt(re.prototype.readFlatPosList),
    coordinates: zt(Qo.prototype.readFlatCoordinates)
  }
};
be.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: re.prototype.interiorParser,
    exterior: re.prototype.exteriorParser
  }
};
be.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: zt(he.prototype.readPoint),
    MultiPoint: zt(he.prototype.readMultiPoint),
    LineString: zt(he.prototype.readLineString),
    MultiLineString: zt(he.prototype.readMultiLineString),
    LinearRing: zt(he.prototype.readLinearRing),
    Polygon: zt(he.prototype.readPolygon),
    MultiPolygon: zt(he.prototype.readMultiPolygon),
    Surface: zt(be.prototype.readSurface),
    MultiSurface: zt(re.prototype.readMultiSurface),
    Curve: zt(be.prototype.readCurve),
    MultiCurve: zt(re.prototype.readMultiCurve),
    Envelope: zt(be.prototype.readEnvelope)
  }
};
be.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: Ht(re.prototype.curveMemberParser),
    curveMembers: Ht(re.prototype.curveMemberParser)
  }
};
be.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: Ht(re.prototype.surfaceMemberParser),
    surfaceMembers: Ht(re.prototype.surfaceMemberParser)
  }
};
be.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: Ht(he.prototype.readLineString),
    Curve: Ht(re.prototype.readCurve)
  }
};
be.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: Ht(he.prototype.readPolygon),
    Surface: Ht(re.prototype.readSurface)
  }
};
be.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: zt(re.prototype.readPatch)
  }
};
be.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: zt(re.prototype.readSegment)
  }
};
be.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: Ht(re.prototype.readFlatPosList),
    upperCorner: Ht(re.prototype.readFlatPosList)
  }
};
be.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: zt(re.prototype.readPolygonPatch)
  }
};
be.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: $1(
      re.prototype.readLineStringSegment
    )
  }
};
be.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: Ht(he.prototype.pointMemberParser),
    pointMembers: Ht(he.prototype.pointMemberParser)
  }
};
be.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: Ht(
      he.prototype.lineStringMemberParser
    ),
    lineStringMembers: Ht(
      he.prototype.lineStringMemberParser
    )
  }
};
be.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: Ht(he.prototype.polygonMemberParser),
    polygonMembers: Ht(he.prototype.polygonMemberParser)
  }
};
be.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: Ht(he.prototype.readFlatCoordinatesFromNode)
  }
};
be.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: Ht(he.prototype.readLineString)
  }
};
be.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: Ht(he.prototype.readPolygon)
  }
};
be.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: zt(he.prototype.readFlatLinearRing),
    Ring: zt(be.prototype.readFlatCurveRing)
  }
};
be.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: gt(re.prototype.writeRing),
    interior: gt(re.prototype.writeRing)
  }
};
be.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: gt(Ln),
    upperCorner: gt(Ln)
  }
};
be.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: gt(
      re.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      re.prototype.writeSurfaceOrPolygonMember
    )
  }
};
be.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: gt(re.prototype.writePointMember)
  }
};
be.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: gt(
      re.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      re.prototype.writeLineStringOrCurveMember
    )
  }
};
be.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: gt(re.prototype.writeCurveOrLineString),
    MultiCurve: gt(re.prototype.writeMultiCurveOrLineString),
    Point: gt(be.prototype.writePoint),
    MultiPoint: gt(re.prototype.writeMultiPoint),
    LineString: gt(re.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      re.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(re.prototype.writeLinearRing),
    Polygon: gt(re.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      re.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(re.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      re.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(re.prototype.writeEnvelope)
  }
};
const Hc = be;
class hU {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(t) {
    this.tagName_ = t;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}
const sM = hU;
class dU extends sM {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(t, n) {
    super(t), this.conditions = n, Zt(this.conditions.length >= 2, 57);
  }
}
const fU = dU;
class pU extends fU {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(t) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
const mU = pU;
class gU extends sM {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(t, n, s) {
    if (super("BBOX"), this.geometryName = t, this.extent = n, n.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = s;
  }
}
const vU = gU;
function yU(e) {
  const t = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(mU, t))();
}
function EU(e, t, n) {
  return new vU(e, t, n);
}
const FC = {
  "http://www.opengis.net/gml": {
    boundedBy: mt(
      he.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: Ht(he.prototype.readFeaturesInternal)
  }
}, CU = {
  "http://www.opengis.net/wfs": {
    totalInserted: mt(qn),
    totalUpdated: mt(qn),
    totalDeleted: mt(qn)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: mt(qn),
    totalUpdated: mt(qn),
    totalDeleted: mt(qn)
  }
}, xU = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: mt(
      UC,
      "transactionSummary"
    ),
    InsertResults: mt($C, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: mt(
      UC,
      "transactionSummary"
    ),
    InsertResults: mt($C, "insertIds")
  }
}, bU = {
  "http://www.opengis.net/wfs": {
    PropertyName: gt(Ln)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: gt(Ln)
  }
}, aM = {
  "http://www.opengis.net/wfs": {
    Insert: gt(zC),
    Update: gt(GC),
    Delete: gt(KC),
    Property: gt(kC),
    Native: gt(HC)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: gt(zC),
    Update: gt(GC),
    Delete: gt(KC),
    Property: gt(kC),
    Native: gt(HC)
  }
}, oM = "feature", r0 = "http://www.w3.org/2000/xmlns/", s0 = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, qg = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, a0 = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, jC = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, o0 = {
  "2.0.0": Hc,
  "1.1.0": re,
  "1.0.0": Qo
}, OU = "1.1.0";
class TU extends q1 {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(t) {
    super(), t = t || {}, this.version_ = t.version ? t.version : OU, this.featureType_ = t.featureType, this.featureNS_ = t.featureNS, this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new o0[this.version_](), this.schemaLocation_ = t.schemaLocation ? t.schemaLocation : jC[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(t) {
    this.featureType_ = t;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    const s = {
      node: t
    };
    Object.assign(s, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(s, this.getReadOptions(t, n || {}));
    const r = [s];
    let i;
    this.version_ === "2.0.0" ? i = FC : i = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let a = At(
      [],
      i,
      t,
      r,
      this.gmlFormat_
    );
    return a || (a = []), a;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(t) {
    if (t)
      if (typeof t == "string") {
        const n = xo(t);
        return this.readTransactionResponseFromDocument(n);
      } else
        return Co(t) ? this.readTransactionResponseFromDocument(
          /** @type {Document} */
          t
        ) : this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
    else
      return;
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(t) {
    if (t)
      if (typeof t == "string") {
        const n = xo(t);
        return this.readFeatureCollectionMetadataFromDocument(n);
      } else
        return Co(t) ? this.readFeatureCollectionMetadataFromDocument(
          /** @type {Document} */
          t
        ) : this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
    else
      return;
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(t) {
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          n
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(t) {
    const n = {}, s = Us(
      t.getAttribute("numberOfFeatures")
    );
    return n.numberOfFeatures = s, At(
      /** @type {FeatureCollectionMetadata} */
      n,
      FC,
      t,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(t) {
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          n
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(t) {
    return At(
      /** @type {TransactionResponse} */
      {},
      xU,
      t,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(t) {
    const n = le(qg[this.version_], "GetFeature");
    n.setAttribute("service", "WFS"), n.setAttribute("version", this.version_), t.handle && n.setAttribute("handle", t.handle), t.outputFormat && n.setAttribute("outputFormat", t.outputFormat), t.maxFeatures !== void 0 && n.setAttribute("maxFeatures", String(t.maxFeatures)), t.resultType && n.setAttribute("resultType", t.resultType), t.startIndex !== void 0 && n.setAttribute("startIndex", String(t.startIndex)), t.count !== void 0 && n.setAttribute("count", String(t.count)), t.viewParams !== void 0 && n.setAttribute("viewParams", t.viewParams), n.setAttributeNS(
      Hg,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const s = {
      node: n
    };
    if (Object.assign(s, {
      version: this.version_,
      srsName: t.srsName,
      featureNS: t.featureNS ? t.featureNS : this.featureNS_,
      featurePrefix: t.featurePrefix,
      propertyNames: t.propertyNames ? t.propertyNames : []
    }), Zt(Array.isArray(t.featureTypes), 11), typeof t.featureTypes[0] == "string") {
      let r = t.filter;
      t.bbox && (Zt(t.geometryName, 12), r = this.combineBboxAndFilter(
        t.geometryName,
        t.bbox,
        t.srsName,
        r
      )), Object.assign(s, {
        geometryName: t.geometryName,
        filter: r
      }), ix(
        n,
        /** @type {!Array<string>} */
        t.featureTypes,
        [s]
      );
    } else
      t.featureTypes.forEach((r) => {
        const i = this.combineBboxAndFilter(
          r.geometryName,
          r.bbox,
          t.srsName,
          t.filter
        );
        Object.assign(s, {
          geometryName: r.geometryName,
          filter: i
        }), ix(n, [r.name], [s]);
      });
    return n;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(t, n, s, r) {
    const i = EU(t, n, s);
    return r ? yU(r, i) : i;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(t, n, s, r) {
    const i = [], a = r.version ? r.version : this.version_, o = le(qg[a], "Transaction");
    o.setAttribute("service", "WFS"), o.setAttribute("version", a);
    let l;
    r && (l = r.gmlOptions ? r.gmlOptions : {}, r.handle && o.setAttribute("handle", r.handle)), o.setAttributeNS(
      Hg,
      "xsi:schemaLocation",
      jC[a]
    );
    const f = PU(o, l, a, r);
    return t && Th("Insert", t, i, f), n && Th("Update", n, i, f), s && Th("Delete", s, i, f), r.nativeElements && Th(
      "Native",
      r.nativeElements,
      i,
      f
    ), o;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(t) {
    for (let n = t.firstChild; n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          n
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    if (t.firstElementChild && t.firstElementChild.firstElementChild) {
      t = t.firstElementChild.firstElementChild;
      for (let n = t.firstElementChild; n; n = n.nextElementSibling)
        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
          const s = [{}];
          return this.gmlFormat_.readGeometryElement(n, s), Wt(s.pop().srsName);
        }
    }
    return null;
  }
}
function PU(e, t, n, s) {
  const r = s.featurePrefix ? s.featurePrefix : oM;
  let i;
  return n === "1.0.0" ? i = 2 : n === "1.1.0" ? i = 3 : n === "2.0.0" && (i = 3.2), Object.assign(
    { node: e },
    {
      version: n,
      featureNS: s.featureNS,
      featureType: s.featureType,
      featurePrefix: r,
      gmlVersion: i,
      hasZ: s.hasZ,
      srsName: s.srsName
    },
    t
  );
}
function Th(e, t, n, s) {
  En(
    s,
    aM,
    tr(e),
    t,
    n
  );
}
function UC(e, t) {
  return At({}, CU, e, t);
}
const MU = {
  "http://www.opengis.net/ogc": {
    FeatureId: Ht(function(e, t) {
      return e.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: Ht(function(e, t) {
      return e.getAttribute("fid");
    })
  }
};
function WC(e, t) {
  Mo(MU, e, t);
}
const SU = {
  "http://www.opengis.net/wfs": {
    Feature: WC
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: WC
  }
};
function $C(e, t) {
  return At([], SU, e, t);
}
function zC(e, t, n) {
  const s = n[n.length - 1], r = s.featureType, i = s.featureNS, a = s.gmlVersion, o = le(i, r);
  e.appendChild(o), a === 2 ? Qo.prototype.writeFeatureElement(o, t, n) : a === 3 ? re.prototype.writeFeatureElement(o, t, n) : Hc.prototype.writeFeatureElement(o, t, n);
}
function lM(e, t, n) {
  const r = n[n.length - 1].version, i = s0[r], a = le(i, "Filter"), o = le(i, "FeatureId");
  a.appendChild(o), o.setAttribute(
    "fid",
    /** @type {string} */
    t
  ), e.appendChild(a);
}
function l0(e, t) {
  e = e || oM;
  const n = e + ":";
  return t.startsWith(n) ? t : n + t;
}
function KC(e, t, n) {
  const s = n[n.length - 1];
  Zt(t.getId() !== void 0, 26);
  const r = s.featureType, i = s.featurePrefix, a = s.featureNS, o = l0(i, r);
  e.setAttribute("typeName", o), e.setAttributeNS(r0, "xmlns:" + i, a);
  const l = t.getId();
  l !== void 0 && lM(e, l, n);
}
function GC(e, t, n) {
  const s = n[n.length - 1];
  Zt(t.getId() !== void 0, 27);
  const r = s.version, i = s.featureType, a = s.featurePrefix, o = s.featureNS, l = l0(a, i), f = t.getGeometryName();
  e.setAttribute("typeName", l), e.setAttributeNS(r0, "xmlns:" + a, o);
  const d = t.getId();
  if (d !== void 0) {
    const u = t.getKeys(), c = [];
    for (let h = 0, p = u.length; h < p; h++) {
      const g = t.get(u[h]);
      if (g !== void 0) {
        let m = u[h];
        g && typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" && (m = f), c.push({ name: m, value: g });
      }
    }
    En(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: r,
        gmlVersion: s.gmlVersion,
        node: e,
        hasZ: s.hasZ,
        srsName: s.srsName
      },
      aM,
      tr("Property"),
      c,
      n
    ), lM(e, d, n);
  }
}
function kC(e, t, n) {
  const s = n[n.length - 1], r = s.version, i = qg[r], a = le(i, "Name"), o = s.gmlVersion;
  if (e.appendChild(a), Ln(a, t.name), t.value !== void 0 && t.value !== null) {
    const l = le(i, "Value");
    e.appendChild(l), t.value && typeof /** @type {?} */
    t.value.getSimplifiedGeometry == "function" ? o === 2 ? Qo.prototype.writeGeometryElement(l, t.value, n) : o === 3 ? re.prototype.writeGeometryElement(l, t.value, n) : Hc.prototype.writeGeometryElement(l, t.value, n) : Ln(l, t.value);
  }
}
function HC(e, t, n) {
  t.vendorId && e.setAttribute("vendorId", t.vendorId), t.safeToIgnore !== void 0 && e.setAttribute("safeToIgnore", String(t.safeToIgnore)), t.value !== void 0 && Ln(e, t.value);
}
const Ff = {
  "http://www.opengis.net/wfs": {
    Query: gt(YC)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: gt(YC)
  },
  "http://www.opengis.net/ogc": {
    During: gt(JC),
    And: gt(Ph),
    Or: gt(Ph),
    Not: gt(QC),
    BBOX: gt(XC),
    Contains: gt(ga),
    Intersects: gt(ga),
    Within: gt(ga),
    DWithin: gt(ZC),
    PropertyIsEqualTo: gt(ur),
    PropertyIsNotEqualTo: gt(ur),
    PropertyIsLessThan: gt(ur),
    PropertyIsLessThanOrEqualTo: gt(ur),
    PropertyIsGreaterThan: gt(ur),
    PropertyIsGreaterThanOrEqualTo: gt(ur),
    PropertyIsNull: gt(qC),
    PropertyIsBetween: gt(tx),
    PropertyIsLike: gt(ex)
  },
  "http://www.opengis.net/fes/2.0": {
    During: gt(JC),
    And: gt(Ph),
    Or: gt(Ph),
    Not: gt(QC),
    BBOX: gt(XC),
    Contains: gt(ga),
    Disjoint: gt(ga),
    Intersects: gt(ga),
    ResourceId: gt(_U),
    Within: gt(ga),
    DWithin: gt(ZC),
    PropertyIsEqualTo: gt(ur),
    PropertyIsNotEqualTo: gt(ur),
    PropertyIsLessThan: gt(ur),
    PropertyIsLessThanOrEqualTo: gt(ur),
    PropertyIsGreaterThan: gt(ur),
    PropertyIsGreaterThanOrEqualTo: gt(ur),
    PropertyIsNull: gt(qC),
    PropertyIsBetween: gt(tx),
    PropertyIsLike: gt(ex)
  }
};
function YC(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = s.version, i = s.featurePrefix, a = s.featureNS, o = s.propertyNames, l = s.srsName;
  let f;
  i ? f = l0(i, t) : f = t;
  let d;
  r === "2.0.0" ? d = "typeNames" : d = "typeName", e.setAttribute(d, f), l && e.setAttribute("srsName", l), a && e.setAttributeNS(r0, "xmlns:" + i, a);
  const u = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, s)
  );
  u.node = e, En(
    u,
    bU,
    tr("PropertyName"),
    o,
    n
  );
  const c = s.filter;
  if (c) {
    const h = le(jf(r), "Filter");
    e.appendChild(h), IU(h, c, n);
  }
}
function IU(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = { node: e };
  Object.assign(r, { context: s }), En(
    r,
    Ff,
    tr(t.getTagName()),
    [t],
    n
  );
}
function XC(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), i = s.context.version;
  s.srsName = t.srsName;
  const a = o0[i];
  vu(i, e, t.geometryName), a.prototype.writeGeometryElement(e, t.extent, n);
}
function _U(e, t, n) {
  e.setAttribute(
    "rid",
    /** @type {string} */
    t.rid
  );
}
function ga(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), i = s.context.version;
  s.srsName = t.srsName;
  const a = o0[i];
  vu(i, e, t.geometryName), a.prototype.writeGeometryElement(e, t.geometry, n);
}
function ZC(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  ga(e, t, n);
  const a = le(jf(i), "Distance");
  Ln(a, t.distance.toString()), i === "2.0.0" ? a.setAttribute("uom", t.unit) : a.setAttribute("units", t.unit), e.appendChild(a);
}
function JC(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  Wd(a0[i], "ValueReference", e, t.propertyName);
  const a = le(ks, "TimePeriod");
  e.appendChild(a);
  const o = le(ks, "begin");
  a.appendChild(o), nx(o, t.begin);
  const l = le(ks, "end");
  a.appendChild(l), nx(l, t.end);
}
function Ph(e, t, n) {
  const r = /** @type {Object} */ n[n.length - 1].context, i = { node: e };
  Object.assign(i, { context: r });
  const a = t.conditions;
  for (let o = 0, l = a.length; o < l; ++o) {
    const f = a[o];
    En(
      i,
      Ff,
      tr(f.getTagName()),
      [f],
      n
    );
  }
}
function QC(e, t, n) {
  const r = /** @type {Object} */ n[n.length - 1].context, i = { node: e };
  Object.assign(i, { context: r });
  const a = t.condition;
  En(
    i,
    Ff,
    tr(a.getTagName()),
    [a],
    n
  );
}
function ur(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  t.matchCase !== void 0 && e.setAttribute("matchCase", t.matchCase.toString()), vu(i, e, t.propertyName), $d(i, e, "" + t.expression);
}
function qC(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  vu(i, e, t.propertyName);
}
function tx(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version, a = jf(i);
  vu(i, e, t.propertyName);
  const o = le(a, "LowerBoundary");
  e.appendChild(o), $d(i, o, "" + t.lowerBoundary);
  const l = le(a, "UpperBoundary");
  e.appendChild(l), $d(i, l, "" + t.upperBoundary);
}
function ex(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  e.setAttribute("wildCard", t.wildCard), e.setAttribute("singleChar", t.singleChar), e.setAttribute("escapeChar", t.escapeChar), t.matchCase !== void 0 && e.setAttribute("matchCase", t.matchCase.toString()), vu(i, e, t.propertyName), $d(i, e, "" + t.pattern);
}
function Wd(e, t, n, s) {
  const r = le(e, t);
  Ln(r, s), n.appendChild(r);
}
function $d(e, t, n) {
  Wd(jf(e), "Literal", t, n);
}
function vu(e, t, n) {
  e === "2.0.0" ? Wd(a0[e], "ValueReference", t, n) : Wd(s0[e], "PropertyName", t, n);
}
function nx(e, t) {
  const n = le(ks, "TimeInstant");
  e.appendChild(n);
  const s = le(ks, "timePosition");
  n.appendChild(s), Ln(s, t);
}
function ix(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, s)
  );
  r.node = e, En(
    r,
    Ff,
    tr("Query"),
    t,
    n
  );
}
function jf(e) {
  let t;
  return e === "2.0.0" ? t = a0[e] : t = s0[e], t;
}
const Yc = TU, ni = [null, "http://www.opengis.net/wms"], DU = qt(ni, {
  Service: mt(JU),
  Capability: mt(ZU)
}), AU = qt(ni, {
  Request: mt(rW),
  Exception: mt(eW),
  Layer: mt(nW)
});
class LU extends qy {
  constructor() {
    super(), this.version = void 0;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    this.version = t.getAttribute("version").trim();
    const n = At(
      {
        version: this.version
      },
      DU,
      t,
      []
    );
    return n || null;
  }
}
const RU = qt(ni, {
  Name: mt(Ft),
  Title: mt(Ft),
  Abstract: mt(Ft),
  KeywordList: mt(dM),
  OnlineResource: mt(fu),
  ContactInformation: mt(QU),
  Fees: mt(Ft),
  AccessConstraints: mt(Ft),
  LayerLimit: mt(qn),
  MaxWidth: mt(qn),
  MaxHeight: mt(qn)
}), wU = qt(ni, {
  ContactPersonPrimary: mt(qU),
  ContactPosition: mt(Ft),
  ContactAddress: mt(tW),
  ContactVoiceTelephone: mt(Ft),
  ContactFacsimileTelephone: mt(Ft),
  ContactElectronicMailAddress: mt(Ft)
}), VU = qt(ni, {
  ContactPerson: mt(Ft),
  ContactOrganization: mt(Ft)
}), BU = qt(ni, {
  AddressType: mt(Ft),
  Address: mt(Ft),
  City: mt(Ft),
  StateOrProvince: mt(Ft),
  PostCode: mt(Ft),
  Country: mt(Ft)
}), NU = qt(ni, {
  Format: Ht(Ft)
}), uM = qt(ni, {
  Name: mt(Ft),
  Title: mt(Ft),
  Abstract: mt(Ft),
  KeywordList: mt(dM),
  CRS: ke(Ft),
  EX_GeographicBoundingBox: mt(
    XU
  ),
  BoundingBox: ke(YU),
  Dimension: ke(iW),
  Attribution: mt(HU),
  AuthorityURL: ke(oW),
  Identifier: ke(Ft),
  MetadataURL: ke(lW),
  DataURL: ke(qs),
  FeatureListURL: ke(qs),
  Style: ke(uW),
  MinScaleDenominator: mt(bo),
  MaxScaleDenominator: mt(bo),
  Layer: ke(cM)
}), FU = qt(ni, {
  Title: mt(Ft),
  OnlineResource: mt(fu),
  LogoURL: mt(hM)
}), jU = qt(ni, {
  westBoundLongitude: mt(bo),
  eastBoundLongitude: mt(bo),
  southBoundLatitude: mt(bo),
  northBoundLatitude: mt(bo)
}), UU = qt(ni, {
  GetCapabilities: mt(Mp),
  GetMap: mt(Mp),
  GetFeatureInfo: mt(Mp)
}), WU = qt(ni, {
  Format: ke(Ft),
  DCPType: ke(sW)
}), $U = qt(ni, {
  HTTP: mt(aW)
}), zU = qt(ni, {
  Get: mt(qs),
  Post: mt(qs)
}), KU = qt(ni, {
  Name: mt(Ft),
  Title: mt(Ft),
  Abstract: mt(Ft),
  LegendURL: ke(hM),
  StyleSheetURL: mt(qs),
  StyleURL: mt(qs)
}), GU = qt(ni, {
  Format: mt(Ft),
  OnlineResource: mt(fu)
}), kU = qt(ni, {
  Keyword: Ht(Ft)
});
function HU(e, t) {
  return At({}, FU, e, t);
}
function YU(e, t) {
  const n = [
    Ns(e.getAttribute("minx")),
    Ns(e.getAttribute("miny")),
    Ns(e.getAttribute("maxx")),
    Ns(e.getAttribute("maxy"))
  ], s = [
    Ns(e.getAttribute("resx")),
    Ns(e.getAttribute("resy"))
  ];
  return {
    crs: e.getAttribute("CRS"),
    extent: n,
    res: s
  };
}
function XU(e, t) {
  const n = At(
    {},
    jU,
    e,
    t
  );
  if (!n)
    return;
  const s = (
    /** @type {number|undefined} */
    n.westBoundLongitude
  ), r = (
    /** @type {number|undefined} */
    n.southBoundLatitude
  ), i = (
    /** @type {number|undefined} */
    n.eastBoundLongitude
  ), a = (
    /** @type {number|undefined} */
    n.northBoundLatitude
  );
  if (!(s === void 0 || r === void 0 || i === void 0 || a === void 0))
    return [
      s,
      r,
      i,
      a
    ];
}
function ZU(e, t) {
  return At({}, AU, e, t);
}
function JU(e, t) {
  return At({}, RU, e, t);
}
function QU(e, t) {
  return At({}, wU, e, t);
}
function qU(e, t) {
  return At({}, VU, e, t);
}
function tW(e, t) {
  return At({}, BU, e, t);
}
function eW(e, t) {
  return At([], NU, e, t);
}
function nW(e, t) {
  const n = At({}, uM, e, t);
  return n.Layer === void 0 ? Object.assign(n, cM(e, t)) : n;
}
function cM(e, t) {
  const n = (
    /**  @type {!Object<string,*>} */
    t[t.length - 1]
  ), s = At({}, uM, e, t);
  if (!s)
    return;
  let r = Wl(e.getAttribute("queryable"));
  r === void 0 && (r = n.queryable), s.queryable = r !== void 0 ? r : !1;
  let i = Us(e.getAttribute("cascaded"));
  i === void 0 && (i = n.cascaded), s.cascaded = i;
  let a = Wl(e.getAttribute("opaque"));
  a === void 0 && (a = n.opaque), s.opaque = a !== void 0 ? a : !1;
  let o = Wl(e.getAttribute("noSubsets"));
  o === void 0 && (o = n.noSubsets), s.noSubsets = o !== void 0 ? o : !1;
  let l = Ns(e.getAttribute("fixedWidth"));
  l || (l = n.fixedWidth), s.fixedWidth = l;
  let f = Ns(e.getAttribute("fixedHeight"));
  return f || (f = n.fixedHeight), s.fixedHeight = f, ["Style", "CRS", "AuthorityURL"].forEach(function(c) {
    if (c in n) {
      const h = s[c] || [];
      s[c] = h.concat(n[c]);
    }
  }), [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ].forEach(function(c) {
    if (!(c in s)) {
      const h = n[c];
      s[c] = h;
    }
  }), s;
}
function iW(e, t) {
  return {
    name: e.getAttribute("name"),
    units: e.getAttribute("units"),
    unitSymbol: e.getAttribute("unitSymbol"),
    default: e.getAttribute("default"),
    multipleValues: Wl(e.getAttribute("multipleValues")),
    nearestValue: Wl(e.getAttribute("nearestValue")),
    current: Wl(e.getAttribute("current")),
    values: Ft(e)
  };
}
function qs(e, t) {
  return At({}, GU, e, t);
}
function rW(e, t) {
  return At({}, UU, e, t);
}
function sW(e, t) {
  return At({}, $U, e, t);
}
function aW(e, t) {
  return At({}, zU, e, t);
}
function Mp(e, t) {
  return At({}, WU, e, t);
}
function hM(e, t) {
  const n = qs(e, t);
  if (n) {
    const s = [
      Us(e.getAttribute("width")),
      Us(e.getAttribute("height"))
    ];
    return n.size = s, n;
  }
}
function oW(e, t) {
  const n = qs(e, t);
  if (n)
    return n.name = e.getAttribute("name"), n;
}
function lW(e, t) {
  const n = qs(e, t);
  if (n)
    return n.type = e.getAttribute("type"), n;
}
function uW(e, t) {
  return At({}, KU, e, t);
}
function dM(e, t) {
  return At([], kU, e, t);
}
const cW = LU;
class hW extends jr {
  /**
   * @param {Options} options Cluster options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      wrapX: t.wrapX
    }), this.resolution = void 0, this.distance = t.distance !== void 0 ? t.distance : 20, this.minDistance = t.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t.geometryFunction || function(n) {
      const s = (
        /** @type {Point} */
        n.getGeometry()
      );
      return Zt(s.getType() == "Point", 10), s;
    }, this.createCustomCluster_ = t.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(t) {
    this.features.length = 0, super.clear(t);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, n, s) {
    this.source.loadFeatures(t, n, s), n !== this.resolution && (this.resolution = n, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(t) {
    this.updateDistance(t, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(t) {
    this.updateDistance(this.distance, t);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource|null} source The new source for this instance.
   * @api
   */
  setSource(t) {
    this.source && this.source.removeEventListener(Kt.CHANGE, this.boundRefresh_), this.source = t, t && t.addEventListener(Kt.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(t, n) {
    const s = t === 0 ? 0 : Math.min(n, t) / t, r = t !== this.distance || this.interpolationRatio !== s;
    this.distance = t, this.minDistance = n, this.interpolationRatio = s, r && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const t = Ni(), n = this.distance * this.resolution, s = this.source.getFeatures(), r = {};
    for (let i = 0, a = s.length; i < a; i++) {
      const o = s[i];
      if (!(Xt(o) in r)) {
        const l = this.geometryFunction(o);
        if (l) {
          const f = l.getCoordinates();
          Yv(f, t), wr(t, n, t);
          const d = this.source.getFeaturesInExtent(t).filter(function(u) {
            const c = Xt(u);
            return c in r ? !1 : (r[c] = !0, !0);
          });
          this.features.push(this.createCluster(d, t));
        }
      }
    }
  }
  /**
   * @param {Array<Feature>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(t, n) {
    const s = [0, 0];
    for (let o = t.length - 1; o >= 0; --o) {
      const l = this.geometryFunction(t[o]);
      l ? GT(s, l.getCoordinates()) : t.splice(o, 1);
    }
    kT(s, 1 / t.length);
    const r = Fi(n), i = this.interpolationRatio, a = new hi([
      s[0] * (1 - i) + r[0] * i,
      s[1] * (1 - i) + r[1] * i
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(a, t) : new Xi({
      geometry: a,
      features: t
    });
  }
}
const u0 = hW;
function c0(e, t, n) {
  let s, r, i;
  return typeof e == "string" ? r = e : typeof e == "function" ? s = e : typeof e == "object" && (i = n.readFeatures(e, {
    dataProjection: "EPSG:4326",
    featureProjection: "EPSG:25832"
  })), new jr({
    loader: s,
    features: i,
    url: r,
    strategy: t,
    format: n
  });
}
function h0(e, t, n) {
  return new u0({
    source: e,
    distance: t,
    geometryFunction: n
  });
}
function dW(e, t) {
  const n = ["1.0.0", "1.1.0", "2.0.0"];
  let s = t.version || e.version;
  return n.includes(s) || (s = n[1], console.warn(`The "${e.typ}" layer with the id: "${e.id}" is configured in version: ${s}. OpenLayers accepts "${e.typ}" only in the versions: ${n}, It tries to load the layer with the id: "${e.id}" in version ${n[1]}!`)), s;
}
function ec(e, t = {}, n) {
  throw t.onLoadingError && t.onLoadingError(e), n(e), Error(e);
}
function d0(e, t, n, s, r, i = {}) {
  let a = t;
  try {
    i.featuresFilter && (a = i.featuresFilter(t)), e.addFeatures(a), i.afterLoading && i.afterLoading(a), s(a);
  } catch (o) {
    console.error(o), n(o, i, r);
  }
}
function fM(e, t, n, s) {
  return e.ok ? e : t(`Request to wfs-filter failed. Response status is ${e.status}`, n, s);
}
function fW(e) {
  return {
    method: "POST",
    headers: {
      "Content-Type": "text/xml"
    },
    body: e
  };
}
function pM(e, t, n, { onErrorFn: s, success: r, failure: i }, a) {
  fetch(e, t).then((o) => fM(o, s, a, i)).then((o) => o.text()).then((o) => n.getFormat().readFeatures(o)).then((o) => d0(n, o, s, r, i, a)).catch((o) => {
    console.error(o);
  });
}
function pW(e, t, n, { onErrorFn: s, success: r, failure: i }, a) {
  fetch(e).then((o) => fM(o, s, a, i)).then((o) => o.text()).then((o) => pM(t, fW(o), n, { onErrorFn: s, success: r, failure: i }, a)).catch((o) => {
    console.error(o);
  });
}
function mW(e, t, n, s) {
  let r = `${e.url}?service=WFS&version=${t}&request=GetFeature&srsName=${n.getCode()}${s}`;
  return t === "1.0.0" || t === "1.1.0" ? r = `${r}&typeName=${e.featureType}` : t === "2.0.0" && (r = `${r}&typeNames=${e.featureType}`), r;
}
function mM(e, t = {}) {
  t.loadingStrategy || (t.loadingStrategy = wg);
  const n = dW(e, t), s = new Yc({
    featureNS: e.featureNS,
    version: n
  });
  let r = null;
  function i(a, o, l, f, d) {
    if (t.doNotLoadInitially)
      d0(r, [], ec, f, d, t);
    else if (t.wfsFilter)
      pW(t.wfsFilter, e.url, r, { onErrorFn: ec, success: f, failure: d }, t);
    else {
      const u = t.loadingStrategy === wg ? `&bbox=${a.join(",")},${l.getCode()}` : "";
      let c = mW(e, n, l, u);
      if (t.loadingParams)
        for (const h in t.loadingParams) {
          const p = Array.isArray(t.loadingParams[h]) ? t.loadingParams[h].join(",") : t.loadingParams[h];
          p !== void 0 && h === "bbox" ? c += `&${h}=${p},${l.getCode()}` : p !== void 0 && (c += `&${h}=${p}`);
        }
      pM(c, {}, r, { onErrorFn: ec, success: f, failure: d }, t);
    }
  }
  return s.featureType = e.featureType, r = c0(i, t.loadingStrategy, s), t.beforeLoading && r.once("featuresloadstart", () => t.beforeLoading()), e.clusterDistance ? h0(r, e.clusterDistance, t.clusterGeometryFunction) : r;
}
function gW(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = mM(e, n), r = new vr(Object.assign({
    source: s,
    id: e.id
  }, t));
  return n.style ? r.setStyle(n.style) : e.style && r.setStyle(e.style), r;
}
const gM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: gW,
  createLayerSource: mM
}, Symbol.toStringTag, { value: "Module" })), vW = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMCA0MyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+REI2QzQ5NEUtODhFOC00OUYxLTg5Q0UtOTdDQkVDM0E1MjQwPC90aXRsZT48cGF0aCBkPSJNMTQuNTg0IDFDNy4xMDEgMSAxIDcuMTAxIDEgMTQuNTg0YzAgOC4xMDMgNy44NjUgMjAuNDQ4IDExLjYzIDI1LjkzYTIuMzYgMi4zNiAwIDAgMCAzLjkwOCAwYzMuNzY2LTUuNDgyIDExLjYzLTE3LjkyMiAxMS42My0yNS45M0MyOC4xNjggNy4wNTQgMjIuMDY4IDEgMTQuNTg0IDF6IiBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0iIzAwNUNBOSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9zdmc+DQo=";
let vM = {};
function yW(e) {
  vM = e;
}
const yM = new Ua({
  crossOrigin: "anonymous",
  src: vW,
  // center bottom of marker 📍 is intended to show the spot
  anchor: [0.5, 1]
}), Uf = new pr({
  width: 2,
  color: "#005CA9"
}), f0 = new Lr({
  color: "#005CA915"
}), rx = new zn({ image: yM }), sx = new zn({ stroke: Uf }), ax = new zn({ stroke: Uf, fill: f0 }), EW = new zn({ stroke: Uf, fill: f0 }), CW = new zn({ stroke: Uf, fill: f0, image: yM }), xW = {
  Point: rx,
  LineString: sx,
  MultiLineString: sx,
  MultiPoint: rx,
  MultiPolygon: ax,
  Polygon: ax,
  GeometryCollection: CW,
  Circle: EW
};
function bW(e) {
  const t = e.getGeometry().getType();
  return vM[t] || xW[t];
}
function EM({ url: e, features: t, clusterDistance: n }, s) {
  const r = new Qs();
  let i = null;
  return i = c0(e || t, s.loadingStrategy, r), n ? h0(i, n, s.clusterGeometryFunction) : (i.once("featuresloadend", (a) => {
    typeof s.afterLoading == "function" && s.afterLoading(a == null ? void 0 : a.features);
  }), i);
}
function OW(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = new vr(Object.assign({
    id: e.id,
    source: EM(e, n)
  }, t));
  return n.style ? s.setStyle(n.style) : e.style ? s.setStyle(e.style) : s.setStyle(bW), s;
}
function TW(e) {
  e.getSource().refresh();
}
function Wf(e, t) {
  e.forEach((n) => n.setStyle(t));
}
function CM(e) {
  Wf(e.getSource().getFeatures(), () => null);
}
function PW(e) {
  Wf(e.getSource().getFeatures(), void 0);
}
function MW(e, t) {
  const n = e.getSource().getFeatures().filter((s) => t.indexOf(s.getId()) >= 0);
  CM(e), Wf(n, void 0);
}
const xM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: OW,
  createLayerSource: EM,
  hideAllFeatures: CM,
  setCustomStyles: yW,
  setFeatureStyle: Wf,
  showAllFeatures: PW,
  showFeaturesById: MW,
  updateSource: TW
}, Symbol.toStringTag, { value: "Module" }));
function SW(e) {
  return new jr({
    features: e.features
  });
}
function IW(e, t) {
  e.getSource().clear(!0), e.getSource().addFeatures(t);
}
function _W(e) {
  const t = this.createLayerSource(e);
  return new vr({
    source: t,
    name: e.name,
    typ: e.typ,
    gfiAttributes: e.gfiAttributes,
    id: e.id
  });
}
const bM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: _W,
  createLayerSource: SW,
  updateSource: IW
}, Symbol.toStringTag, { value: "Module" })), DW = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, AW = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class LW extends _1 {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.tmpTransform_ = Qi();
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(t, n, s) {
    let r;
    const i = t.getState();
    return (i === It.LOADED || i === It.ERROR) && (this.updateExecutorGroup_(t, n, s), this.tileImageNeedsRender_(t) && (r = !0)), r;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(t, n, s, r) {
    const i = r.pixelRatio, a = r.viewState, o = a.resolution, l = a.projection, f = this.getLayer(), d = f.getSource().getTile(t, n, s, i, l), u = r.viewHints, c = !(u[tn.ANIMATING] || u[tn.INTERACTING]);
    return (c || !d.wantedResolution) && (d.wantedResolution = o), this.prepareTile(d, i, l) && (c || Date.now() - r.time < 8) && f.getRenderMode() !== "vector" && this.renderTileImage_(d, r), super.getTile(t, n, s, r);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(t) {
    const n = this.getLayer();
    return super.isDrawableTile(t) && (n.getRenderMode() === "vector" ? Xt(n) in t.executorGroups : t.hasContext(n));
  }
  /**
   * @inheritDoc
   */
  getTileImage(t) {
    return t.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== n && (this.renderedLayerRevision_ = n, this.renderedTiles.length = 0), super.prepareFrame(t);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(t, n, s) {
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), i = r.getRevision(), a = r.getRenderOrder() || null, o = t.wantedResolution, l = t.getReplayState(r);
    if (!l.dirty && l.renderedResolution === o && l.renderedRevision == i && l.renderedRenderOrder == a)
      return;
    const f = r.getSource(), d = r.getDeclutter(), u = f.getTileGrid(), h = f.getTileGridForProjection(s).getTileCoordExtent(t.wrappedTileCoord), p = f.getSourceTiles(n, s, t), g = Xt(r);
    delete t.hitDetectionImageData[g], t.executorGroups[g] = [], d && (t.declutterExecutorGroups[g] = []), l.dirty = !1;
    for (let m = 0, v = p.length; m < v; ++m) {
      const y = p[m];
      if (y.getState() != It.LOADED)
        continue;
      const E = y.tileCoord, C = u.getTileCoordExtent(E), x = zs(h, C), b = wr(
        x,
        r.getRenderBuffer() * o,
        this.tmpExtent
      ), P = wo(C, x) ? null : b, T = new Md(
        0,
        b,
        o,
        n
      ), O = d ? new Md(0, x, o, n) : void 0, S = wP(
        o,
        n
      ), L = function(B) {
        let j;
        const k = B.getStyleFunction() || r.getStyleFunction();
        if (k && (j = k(B, o)), j) {
          const X = this.renderFeature(
            B,
            S,
            j,
            T,
            O
          );
          l.dirty = l.dirty || X;
        }
      }, A = y.getFeatures();
      a && a !== l.renderedRenderOrder && A.sort(a);
      for (let B = 0, j = A.length; B < j; ++B) {
        const k = A[B];
        (!P || cn(P, k.getGeometry().getExtent())) && L.call(this, k);
      }
      const D = T.finish(), _ = r.getRenderMode() !== "vector" && d && p.length === 1 ? null : x, w = new Sd(
        _,
        o,
        n,
        f.getOverlaps(),
        D,
        r.getRenderBuffer()
      );
      if (t.executorGroups[g].push(w), O) {
        const B = new Sd(
          null,
          o,
          n,
          f.getOverlaps(),
          O.finish(),
          r.getRenderBuffer()
        );
        t.declutterExecutorGroups[g].push(B);
      }
    }
    l.renderedRevision = i, l.renderedRenderOrder = a, l.renderedResolution = o;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
    const a = n.viewState.resolution, o = n.viewState.rotation;
    s = s ?? 0;
    const l = this.getLayer(), d = l.getSource().getTileGridForProjection(
      n.viewState.projection
    ), u = Yl([t]);
    wr(u, a * s, u);
    const c = {}, h = function(m, v, y) {
      let E = m.getId();
      E === void 0 && (E = Xt(m));
      const C = c[E];
      if (C) {
        if (C !== !0 && y < C.distanceSq) {
          if (y === 0)
            return c[E] = !0, i.splice(i.lastIndexOf(C), 1), r(m, l, v);
          C.geometry = v, C.distanceSq = y;
        }
      } else {
        if (y === 0)
          return c[E] = !0, r(m, l, v);
        i.push(
          c[E] = {
            feature: m,
            layer: l,
            geometry: v,
            distanceSq: y,
            callback: r
          }
        );
      }
    }, p = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let g;
    for (let m = 0, v = p.length; !g && m < v; ++m) {
      const y = p[m], E = d.getTileCoordExtent(y.wrappedTileCoord);
      if (!cn(E, u))
        continue;
      const C = Xt(l), x = [y.executorGroups[C]], b = y.declutterExecutorGroups[C];
      b && x.push(b), x.some((P) => {
        const T = P === b ? n.declutterTree.all().map((O) => O.value) : null;
        for (let O = 0, S = P.length; O < S; ++O)
          if (g = P[O].forEachFeatureAtCoordinate(
            t,
            a,
            o,
            s,
            h,
            T
          ), g)
            return !0;
      });
    }
    return g;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise(
      (function(n, s) {
        const r = (
          /** @type {import("../../layer/VectorTile.js").default} */
          this.getLayer()
        ), i = Xt(r), a = r.getSource(), o = this.renderedProjection, l = o.getExtent(), f = this.renderedResolution, d = a.getTileGridForProjection(o), u = An(
          this.renderedPixelToCoordinateTransform_,
          t.slice()
        ), c = d.getTileCoordForCoordAndResolution(
          u,
          f
        );
        let h;
        for (let E = 0, C = this.renderedTiles.length; E < C; ++E)
          if (c.toString() === this.renderedTiles[E].tileCoord.toString()) {
            if (h = this.renderedTiles[E], h.getState() === It.LOADED) {
              const x = d.getTileCoordExtent(h.tileCoord);
              a.getWrapX() && o.canWrapX() && !Ar(l, x) && Qv(u, o);
              break;
            }
            h = void 0;
          }
        if (!h || h.loadingSourceTiles > 0) {
          n([]);
          return;
        }
        const p = d.getTileCoordExtent(h.wrappedTileCoord), g = fs(p), m = [
          (u[0] - g[0]) / f,
          (g[1] - u[1]) / f
        ], v = h.getSourceTiles().reduce(function(E, C) {
          return E.concat(C.getFeatures());
        }, []);
        let y = h.hitDetectionImageData[i];
        if (!y && !this.animatingOrInteracting_) {
          const E = ti(
            d.getTileSize(
              d.getZForResolution(f, a.zDirection)
            )
          ), C = this.renderedRotation_, x = [
            this.getRenderTransform(
              d.getTileCoordCenter(h.wrappedTileCoord),
              f,
              0,
              Zi,
              E[0] * Zi,
              E[1] * Zi,
              0
            )
          ];
          y = AP(
            E,
            x,
            v,
            r.getStyleFunction(),
            d.getTileCoordExtent(h.wrappedTileCoord),
            h.getReplayState(r).renderedResolution,
            C
          ), h.hitDetectionImageData[i] = y;
        }
        n(LP(m, v, y));
      }).bind(this)
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.renderedLayerRevision_ !== void 0 && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    const n = this.context, s = n.globalAlpha;
    n.globalAlpha = this.getLayer().getOpacity();
    const r = t.viewHints, i = !(r[tn.ANIMATING] || r[tn.INTERACTING]), a = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let o = 0, l = a.length; o < l; ++o) {
      const f = a[o], d = f.declutterExecutorGroups[Xt(this.getLayer())];
      if (d)
        for (let u = d.length - 1; u >= 0; --u)
          d[u].execute(
            this.context,
            1,
            this.getTileRenderTransform(f, t),
            t.viewState.rotation,
            i,
            void 0,
            t.declutterTree
          );
    }
    n.globalAlpha = s;
  }
  getTileRenderTransform(t, n) {
    const s = n.pixelRatio, r = n.viewState, i = r.center, a = r.resolution, o = r.rotation, l = n.size, f = Math.round(l[0] * s), d = Math.round(l[1] * s), c = this.getLayer().getSource().getTileGridForProjection(
      n.viewState.projection
    ), h = t.tileCoord, p = c.getTileCoordExtent(t.wrappedTileCoord), g = c.getTileCoordExtent(h, this.tmpExtent)[0] - p[0];
    return Gv(
      id(this.inversePixelTransform.slice(), 1 / s, 1 / s),
      this.getRenderTransform(
        i,
        a,
        o,
        s,
        f,
        d,
        g
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(t, n) {
    const s = n.viewHints, r = !(s[tn.ANIMATING] || s[tn.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = n.pixelToCoordinateTransform.slice(), this.renderedRotation_ = n.viewState.rotation;
    const i = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), a = i.getRenderMode(), o = t.globalAlpha;
    t.globalAlpha = i.getOpacity();
    const l = AW[a], f = n.viewState, d = f.rotation, u = i.getSource(), h = u.getTileGridForProjection(f.projection).getZForResolution(
      f.resolution,
      u.zDirection
    ), p = this.renderedTiles, g = [], m = [];
    let v = !0;
    for (let y = p.length - 1; y >= 0; --y) {
      const E = (
        /** @type {import("../../VectorRenderTile.js").default} */
        p[y]
      );
      v = v && !E.getReplayState(i).dirty;
      const C = E.executorGroups[Xt(i)].filter(
        (O) => O.hasExecutors(l)
      );
      if (C.length === 0)
        continue;
      const x = this.getTileRenderTransform(E, n), b = E.tileCoord[0];
      let P = !1;
      const T = C[0].getClipCoords(x);
      if (T) {
        for (let O = 0, S = g.length; O < S; ++O)
          if (h !== b && b < m[O]) {
            const L = g[O];
            cn(
              [
                T[0],
                T[3],
                T[4],
                T[7]
              ],
              [L[0], L[3], L[4], L[7]]
            ) && (P || (t.save(), P = !0), t.beginPath(), t.moveTo(T[0], T[1]), t.lineTo(T[2], T[3]), t.lineTo(T[4], T[5]), t.lineTo(T[6], T[7]), t.moveTo(L[6], L[7]), t.lineTo(L[4], L[5]), t.lineTo(L[2], L[3]), t.lineTo(L[0], L[1]), t.clip());
          }
        g.push(T), m.push(b);
      }
      for (let O = 0, S = C.length; O < S; ++O)
        C[O].execute(
          t,
          1,
          x,
          d,
          r,
          l
        );
      P && t.restore();
    }
    t.globalAlpha = o, this.ready = v, super.postRender(t, n);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, n, s, r, i) {
    if (!s)
      return !1;
    let a = !1;
    if (Array.isArray(s))
      for (let o = 0, l = s.length; o < l; ++o)
        a = Id(
          r,
          t,
          s[o],
          n,
          this.boundHandleStyleImageChange_,
          void 0,
          i
        ) || a;
    else
      a = Id(
        r,
        t,
        s,
        n,
        this.boundHandleStyleImageChange_,
        void 0,
        i
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(t) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (n.getRenderMode() === "vector")
      return !1;
    const s = t.getReplayState(n), r = n.getRevision(), i = t.wantedResolution;
    return s.renderedTileResolution !== i || s.renderedTileRevision !== r;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(t, n) {
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), r = t.getReplayState(s), i = s.getRevision(), a = t.executorGroups[Xt(s)];
    r.renderedTileRevision = i;
    const o = t.wrappedTileCoord, l = o[0], f = s.getSource();
    let d = n.pixelRatio;
    const c = n.viewState.projection, h = f.getTileGridForProjection(c), p = h.getResolution(t.tileCoord[0]), g = n.pixelRatio / t.wantedResolution * p, m = h.getResolution(l), v = t.getContext(s);
    d = Math.round(
      Math.max(d, g / d)
    );
    const y = f.getTilePixelSize(l, d, c);
    v.canvas.width = y[0], v.canvas.height = y[1];
    const E = d / g;
    if (E !== 1) {
      const P = PE(this.tmpTransform_);
      id(P, E, E), v.setTransform.apply(v, P);
    }
    const C = h.getTileCoordExtent(o, this.tmpExtent), x = g / m, b = PE(this.tmpTransform_);
    id(b, x, -x), k_(b, -C[0], -C[3]);
    for (let P = 0, T = a.length; P < T; ++P)
      a[P].execute(
        v,
        E,
        b,
        0,
        !0,
        DW[s.getRenderMode()]
      );
    r.renderedTileResolution = t.wantedResolution;
  }
}
const RW = LW;
class wW extends SP {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {Object} */
      Object.assign({}, t)
    );
    delete n.preload, delete n.useInterimTilesOnError, super(
      /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
      n
    ), this.on, this.once, this.un;
    const s = t.renderMode || "hybrid";
    Zt(s == "hybrid" || s == "vector", 28), this.renderMode_ = s, this.setPreload(t.preload ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new RW(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Pa.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Pa.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set(Pa.PRELOAD, t);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set(Pa.USE_INTERIM_TILES_ON_ERROR, t);
  }
}
const p0 = wW;
class VW extends w1 {
  /**
   * @param {!Options} options Vector tile options.
   */
  constructor(t) {
    const n = t.projection || "EPSG:3857", s = t.extent || wf(n), r = t.tileGrid || zN({
      extent: s,
      maxResolution: t.maxResolution,
      maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 22,
      minZoom: t.minZoom,
      tileSize: t.tileSize || 512
    });
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      interpolate: !0,
      opaque: !1,
      projection: n,
      state: t.state,
      tileGrid: r,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : BW,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX === void 0 ? !0 : t.wrapX,
      transition: t.transition,
      zDirection: t.zDirection === void 0 ? 1 : t.zDirection
    }), this.format_ = t.format ? t.format : null, this.sourceTileCache = new Ny(this.tileCache.highWaterMark), this.overlaps_ = t.overlaps == null ? !0 : t.overlaps, this.tileClass = t.tileClass ? t.tileClass : NR, this.tileGrids_ = {};
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeaturesInExtent(t) {
    const n = [], s = this.tileCache;
    if (s.getCount() === 0)
      return n;
    const r = YP(s.peekFirstKey())[0], i = this.tileGrid;
    return s.forEach(function(a) {
      if (a.tileCoord[0] !== r || a.getState() !== It.LOADED)
        return;
      const o = a.getSourceTiles();
      for (let l = 0, f = o.length; l < f; ++l) {
        const d = o[l], u = d.tileCoord;
        if (cn(t, i.getTileCoordExtent(u))) {
          const c = d.getFeatures();
          if (c)
            for (let h = 0, p = c.length; h < p; ++h) {
              const g = c[h], m = g.getGeometry();
              cn(t, m.getExtent()) && n.push(g);
            }
        }
      }
    }), n;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  clear() {
    this.tileCache.clear(), this.sourceTileCache.clear();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t), r = Object.keys(n).reduce((i, a) => {
      const o = AR(a), l = s.peek(o);
      if (l) {
        const f = l.sourceTiles;
        for (let d = 0, u = f.length; d < u; ++d)
          i[f[d].getKey()] = !0;
      }
      return i;
    }, {});
    super.expireCache(t, n), this.sourceTileCache.expireCache(r);
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(t, n, s) {
    if (s.getState() === It.IDLE) {
      s.setState(It.LOADING);
      const r = s.wrappedTileCoord, i = this.getTileGridForProjection(n), a = i.getTileCoordExtent(r), o = r[0], l = i.getResolution(o);
      wr(a, -l, a);
      const f = this.tileGrid, d = f.getExtent();
      d && zs(a, d, a);
      const u = f.getZForResolution(
        l,
        this.zDirection
      );
      f.forEachTileCoord(a, u, (c) => {
        const h = this.tileUrlFunction(
          c,
          t,
          n
        ), p = this.sourceTileCache.containsKey(h) ? this.sourceTileCache.get(h) : new this.tileClass(
          c,
          h ? It.IDLE : It.EMPTY,
          h,
          this.format_,
          this.tileLoadFunction
        );
        s.sourceTiles.push(p);
        const g = p.getState();
        if (g < It.LOADED) {
          const m = (v) => {
            this.handleTileChange(v);
            const y = p.getState();
            if (y === It.LOADED || y === It.ERROR) {
              const E = p.getKey();
              E in s.errorTileKeys ? p.getState() === It.LOADED && delete s.errorTileKeys[E] : s.loadingSourceTiles--, y === It.ERROR ? s.errorTileKeys[E] = !0 : p.removeEventListener(Kt.CHANGE, m), s.loadingSourceTiles === 0 && s.setState(
                Ro(s.errorTileKeys) ? It.LOADED : It.ERROR
              );
            }
          };
          p.addEventListener(Kt.CHANGE, m), s.loadingSourceTiles++;
        }
        g === It.IDLE && (p.extent = f.getTileCoordExtent(c), p.projection = n, p.resolution = f.getResolution(
          c[0]
        ), this.sourceTileCache.set(h, p), p.load());
      }), s.loadingSourceTiles || s.setState(
        s.sourceTiles.some(
          (c) => c.getState() === It.ERROR
        ) ? It.ERROR : It.LOADED
      );
    }
    return s.sourceTiles;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */
  getTile(t, n, s, r, i) {
    const a = cu(t, n, s), o = this.getKey();
    let l;
    if (this.tileCache.containsKey(a) && (l = this.tileCache.get(a), l.key === o))
      return l;
    const f = [t, n, s];
    let d = this.getTileCoordForTileUrlFunction(
      f,
      i
    );
    const u = this.getTileGrid().getExtent(), c = this.getTileGridForProjection(i);
    if (d && u) {
      const g = c.getTileCoordExtent(d);
      wr(g, -c.getResolution(t), g), cn(u, g) || (d = null);
    }
    let h = !0;
    if (d !== null) {
      const g = this.tileGrid, m = c.getResolution(t), v = g.getZForResolution(m, 1), y = c.getTileCoordExtent(d);
      wr(y, -m, y), g.forEachTileCoord(
        y,
        v,
        (function(E) {
          h = h && !this.tileUrlFunction(E, r, i);
        }).bind(this)
      );
    }
    const p = new VR(
      f,
      h ? It.EMPTY : It.IDLE,
      d,
      this.getSourceTiles.bind(this, r, i)
    );
    return p.key = o, l ? (p.interimTile = l, p.refreshInterimChain(), this.tileCache.replace(a, p)) : this.tileCache.set(a, p), p;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    const n = t.getCode();
    let s = this.tileGrids_[n];
    if (!s) {
      const r = this.tileGrid, i = r.getResolutions().slice(), a = i.map(function(f, d) {
        return r.getOrigin(d);
      }), o = i.map(function(f, d) {
        return r.getTileSize(d);
      }), l = UP + 1;
      for (let f = i.length; f < l; ++f)
        i.push(i[f - 1] / 2), a.push(a[f - 1]), o.push(o[f - 1]);
      s = new du({
        extent: r.getExtent(),
        origins: a,
        resolutions: i,
        tileSizes: o
      }), this.tileGrids_[n] = s;
    }
    return s;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return t;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(t, n, s) {
    const r = this.getTileGridForProjection(s), i = ti(r.getTileSize(t), this.tmpSize);
    return [
      Math.round(i[0] * n),
      Math.round(i[1] * n)
    ];
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(t, n) {
    super.updateCacheSize(t * 2, n), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(n).highWaterMark;
  }
}
const OM = VW;
function BW(e, t) {
  e.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(n, s, r) {
      BP(
        t,
        e.getFormat(),
        n,
        s,
        r,
        e.onLoad.bind(e),
        e.onError.bind(e)
      );
    }
  );
}
var NW = {}, TM, ox = {
  transparent: [
    0,
    0,
    0,
    0
  ],
  aliceblue: [
    240,
    248,
    255,
    1
  ],
  antiquewhite: [
    250,
    235,
    215,
    1
  ],
  aqua: [
    0,
    255,
    255,
    1
  ],
  aquamarine: [
    127,
    255,
    212,
    1
  ],
  azure: [
    240,
    255,
    255,
    1
  ],
  beige: [
    245,
    245,
    220,
    1
  ],
  bisque: [
    255,
    228,
    196,
    1
  ],
  black: [
    0,
    0,
    0,
    1
  ],
  blanchedalmond: [
    255,
    235,
    205,
    1
  ],
  blue: [
    0,
    0,
    255,
    1
  ],
  blueviolet: [
    138,
    43,
    226,
    1
  ],
  brown: [
    165,
    42,
    42,
    1
  ],
  burlywood: [
    222,
    184,
    135,
    1
  ],
  cadetblue: [
    95,
    158,
    160,
    1
  ],
  chartreuse: [
    127,
    255,
    0,
    1
  ],
  chocolate: [
    210,
    105,
    30,
    1
  ],
  coral: [
    255,
    127,
    80,
    1
  ],
  cornflowerblue: [
    100,
    149,
    237,
    1
  ],
  cornsilk: [
    255,
    248,
    220,
    1
  ],
  crimson: [
    220,
    20,
    60,
    1
  ],
  cyan: [
    0,
    255,
    255,
    1
  ],
  darkblue: [
    0,
    0,
    139,
    1
  ],
  darkcyan: [
    0,
    139,
    139,
    1
  ],
  darkgoldenrod: [
    184,
    134,
    11,
    1
  ],
  darkgray: [
    169,
    169,
    169,
    1
  ],
  darkgreen: [
    0,
    100,
    0,
    1
  ],
  darkgrey: [
    169,
    169,
    169,
    1
  ],
  darkkhaki: [
    189,
    183,
    107,
    1
  ],
  darkmagenta: [
    139,
    0,
    139,
    1
  ],
  darkolivegreen: [
    85,
    107,
    47,
    1
  ],
  darkorange: [
    255,
    140,
    0,
    1
  ],
  darkorchid: [
    153,
    50,
    204,
    1
  ],
  darkred: [
    139,
    0,
    0,
    1
  ],
  darksalmon: [
    233,
    150,
    122,
    1
  ],
  darkseagreen: [
    143,
    188,
    143,
    1
  ],
  darkslateblue: [
    72,
    61,
    139,
    1
  ],
  darkslategray: [
    47,
    79,
    79,
    1
  ],
  darkslategrey: [
    47,
    79,
    79,
    1
  ],
  darkturquoise: [
    0,
    206,
    209,
    1
  ],
  darkviolet: [
    148,
    0,
    211,
    1
  ],
  deeppink: [
    255,
    20,
    147,
    1
  ],
  deepskyblue: [
    0,
    191,
    255,
    1
  ],
  dimgray: [
    105,
    105,
    105,
    1
  ],
  dimgrey: [
    105,
    105,
    105,
    1
  ],
  dodgerblue: [
    30,
    144,
    255,
    1
  ],
  firebrick: [
    178,
    34,
    34,
    1
  ],
  floralwhite: [
    255,
    250,
    240,
    1
  ],
  forestgreen: [
    34,
    139,
    34,
    1
  ],
  fuchsia: [
    255,
    0,
    255,
    1
  ],
  gainsboro: [
    220,
    220,
    220,
    1
  ],
  ghostwhite: [
    248,
    248,
    255,
    1
  ],
  gold: [
    255,
    215,
    0,
    1
  ],
  goldenrod: [
    218,
    165,
    32,
    1
  ],
  gray: [
    128,
    128,
    128,
    1
  ],
  green: [
    0,
    128,
    0,
    1
  ],
  greenyellow: [
    173,
    255,
    47,
    1
  ],
  grey: [
    128,
    128,
    128,
    1
  ],
  honeydew: [
    240,
    255,
    240,
    1
  ],
  hotpink: [
    255,
    105,
    180,
    1
  ],
  indianred: [
    205,
    92,
    92,
    1
  ],
  indigo: [
    75,
    0,
    130,
    1
  ],
  ivory: [
    255,
    255,
    240,
    1
  ],
  khaki: [
    240,
    230,
    140,
    1
  ],
  lavender: [
    230,
    230,
    250,
    1
  ],
  lavenderblush: [
    255,
    240,
    245,
    1
  ],
  lawngreen: [
    124,
    252,
    0,
    1
  ],
  lemonchiffon: [
    255,
    250,
    205,
    1
  ],
  lightblue: [
    173,
    216,
    230,
    1
  ],
  lightcoral: [
    240,
    128,
    128,
    1
  ],
  lightcyan: [
    224,
    255,
    255,
    1
  ],
  lightgoldenrodyellow: [
    250,
    250,
    210,
    1
  ],
  lightgray: [
    211,
    211,
    211,
    1
  ],
  lightgreen: [
    144,
    238,
    144,
    1
  ],
  lightgrey: [
    211,
    211,
    211,
    1
  ],
  lightpink: [
    255,
    182,
    193,
    1
  ],
  lightsalmon: [
    255,
    160,
    122,
    1
  ],
  lightseagreen: [
    32,
    178,
    170,
    1
  ],
  lightskyblue: [
    135,
    206,
    250,
    1
  ],
  lightslategray: [
    119,
    136,
    153,
    1
  ],
  lightslategrey: [
    119,
    136,
    153,
    1
  ],
  lightsteelblue: [
    176,
    196,
    222,
    1
  ],
  lightyellow: [
    255,
    255,
    224,
    1
  ],
  lime: [
    0,
    255,
    0,
    1
  ],
  limegreen: [
    50,
    205,
    50,
    1
  ],
  linen: [
    250,
    240,
    230,
    1
  ],
  magenta: [
    255,
    0,
    255,
    1
  ],
  maroon: [
    128,
    0,
    0,
    1
  ],
  mediumaquamarine: [
    102,
    205,
    170,
    1
  ],
  mediumblue: [
    0,
    0,
    205,
    1
  ],
  mediumorchid: [
    186,
    85,
    211,
    1
  ],
  mediumpurple: [
    147,
    112,
    219,
    1
  ],
  mediumseagreen: [
    60,
    179,
    113,
    1
  ],
  mediumslateblue: [
    123,
    104,
    238,
    1
  ],
  mediumspringgreen: [
    0,
    250,
    154,
    1
  ],
  mediumturquoise: [
    72,
    209,
    204,
    1
  ],
  mediumvioletred: [
    199,
    21,
    133,
    1
  ],
  midnightblue: [
    25,
    25,
    112,
    1
  ],
  mintcream: [
    245,
    255,
    250,
    1
  ],
  mistyrose: [
    255,
    228,
    225,
    1
  ],
  moccasin: [
    255,
    228,
    181,
    1
  ],
  navajowhite: [
    255,
    222,
    173,
    1
  ],
  navy: [
    0,
    0,
    128,
    1
  ],
  oldlace: [
    253,
    245,
    230,
    1
  ],
  olive: [
    128,
    128,
    0,
    1
  ],
  olivedrab: [
    107,
    142,
    35,
    1
  ],
  orange: [
    255,
    165,
    0,
    1
  ],
  orangered: [
    255,
    69,
    0,
    1
  ],
  orchid: [
    218,
    112,
    214,
    1
  ],
  palegoldenrod: [
    238,
    232,
    170,
    1
  ],
  palegreen: [
    152,
    251,
    152,
    1
  ],
  paleturquoise: [
    175,
    238,
    238,
    1
  ],
  palevioletred: [
    219,
    112,
    147,
    1
  ],
  papayawhip: [
    255,
    239,
    213,
    1
  ],
  peachpuff: [
    255,
    218,
    185,
    1
  ],
  peru: [
    205,
    133,
    63,
    1
  ],
  pink: [
    255,
    192,
    203,
    1
  ],
  plum: [
    221,
    160,
    221,
    1
  ],
  powderblue: [
    176,
    224,
    230,
    1
  ],
  purple: [
    128,
    0,
    128,
    1
  ],
  rebeccapurple: [
    102,
    51,
    153,
    1
  ],
  red: [
    255,
    0,
    0,
    1
  ],
  rosybrown: [
    188,
    143,
    143,
    1
  ],
  royalblue: [
    65,
    105,
    225,
    1
  ],
  saddlebrown: [
    139,
    69,
    19,
    1
  ],
  salmon: [
    250,
    128,
    114,
    1
  ],
  sandybrown: [
    244,
    164,
    96,
    1
  ],
  seagreen: [
    46,
    139,
    87,
    1
  ],
  seashell: [
    255,
    245,
    238,
    1
  ],
  sienna: [
    160,
    82,
    45,
    1
  ],
  silver: [
    192,
    192,
    192,
    1
  ],
  skyblue: [
    135,
    206,
    235,
    1
  ],
  slateblue: [
    106,
    90,
    205,
    1
  ],
  slategray: [
    112,
    128,
    144,
    1
  ],
  slategrey: [
    112,
    128,
    144,
    1
  ],
  snow: [
    255,
    250,
    250,
    1
  ],
  springgreen: [
    0,
    255,
    127,
    1
  ],
  steelblue: [
    70,
    130,
    180,
    1
  ],
  tan: [
    210,
    180,
    140,
    1
  ],
  teal: [
    0,
    128,
    128,
    1
  ],
  thistle: [
    216,
    191,
    216,
    1
  ],
  tomato: [
    255,
    99,
    71,
    1
  ],
  turquoise: [
    64,
    224,
    208,
    1
  ],
  violet: [
    238,
    130,
    238,
    1
  ],
  wheat: [
    245,
    222,
    179,
    1
  ],
  white: [
    255,
    255,
    255,
    1
  ],
  whitesmoke: [
    245,
    245,
    245,
    1
  ],
  yellow: [
    255,
    255,
    0,
    1
  ],
  yellowgreen: [
    154,
    205,
    50,
    1
  ]
};
function nc(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function lx(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function Sp(e) {
  return e[e.length - 1] === "%" ? nc(parseFloat(e) / 100 * 255) : nc(parseInt(e));
}
function Mh(e) {
  return e[e.length - 1] === "%" ? lx(parseFloat(e) / 100) : lx(parseFloat(e));
}
function Ip(e, t, n) {
  return n < 0 ? n += 1 : n > 1 && (n -= 1), n * 6 < 1 ? e + (t - e) * n * 6 : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function FW(e) {
  var t = e.replace(/ /g, "").toLowerCase();
  if (t in ox)
    return ox[t].slice();
  if (t[0] === "#") {
    if (t.length === 4) {
      var n = parseInt(t.substr(1), 16);
      return n >= 0 && n <= 4095 ? [
        (n & 3840) >> 4 | (n & 3840) >> 8,
        n & 240 | (n & 240) >> 4,
        n & 15 | (n & 15) << 4,
        1
      ] : null;
    } else if (t.length === 7) {
      var n = parseInt(t.substr(1), 16);
      return n >= 0 && n <= 16777215 ? [
        (n & 16711680) >> 16,
        (n & 65280) >> 8,
        n & 255,
        1
      ] : null;
    }
    return null;
  }
  var s = t.indexOf("("), r = t.indexOf(")");
  if (s !== -1 && r + 1 === t.length) {
    var i = t.substr(0, s), a = t.substr(s + 1, r - (s + 1)).split(","), o = 1;
    switch (i) {
      case "rgba":
        if (a.length !== 4)
          return null;
        o = Mh(a.pop());
      case "rgb":
        return a.length !== 3 ? null : [
          Sp(a[0]),
          Sp(a[1]),
          Sp(a[2]),
          o
        ];
      case "hsla":
        if (a.length !== 4)
          return null;
        o = Mh(a.pop());
      case "hsl":
        if (a.length !== 3)
          return null;
        var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360, f = Mh(a[1]), d = Mh(a[2]), u = d <= 0.5 ? d * (f + 1) : d + f - d * f, c = d * 2 - u;
        return [
          nc(Ip(c, u, l + 1 / 3) * 255),
          nc(Ip(c, u, l) * 255),
          nc(Ip(c, u, l - 1 / 3) * 255),
          o
        ];
      default:
        return null;
    }
  }
  return null;
}
try {
  TM = NW.parseCSSColor = FW;
} catch {
}
var Le = function(t, n, s, r) {
  r === void 0 && (r = 1), this.r = t, this.g = n, this.b = s, this.a = r;
};
Le.parse = function(t) {
  if (t) {
    if (t instanceof Le)
      return t;
    if (typeof t == "string") {
      var n = TM(t);
      if (n)
        return new Le(n[0] / 255 * n[3], n[1] / 255 * n[3], n[2] / 255 * n[3], n[3]);
    }
  }
};
Le.prototype.toString = function() {
  var t = this.toArray(), n = t[0], s = t[1], r = t[2], i = t[3];
  return "rgba(" + Math.round(n) + "," + Math.round(s) + "," + Math.round(r) + "," + i + ")";
};
Le.prototype.toArray = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return i === 0 ? [
    0,
    0,
    0,
    0
  ] : [
    n * 255 / i,
    s * 255 / i,
    r * 255 / i,
    i
  ];
};
Le.prototype.toArray01 = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return i === 0 ? [
    0,
    0,
    0,
    0
  ] : [
    n / i,
    s / i,
    r / i,
    i
  ];
};
Le.prototype.toArray01PremultipliedAlpha = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return [
    n,
    s,
    r,
    i
  ];
};
Le.black = new Le(0, 0, 0, 1);
Le.white = new Le(1, 1, 1, 1);
Le.transparent = new Le(0, 0, 0, 0);
Le.red = new Le(1, 0, 0, 1);
Le.blue = new Le(0, 0, 1, 1);
function Cc(e) {
  return typeof e == "object" ? [
    "literal",
    e
  ] : e;
}
function jW(e, t) {
  var n = e.stops;
  if (!n)
    return UW(e, t);
  var s = n && typeof n[0][0] == "object", r = s || e.property !== void 0, i = s || !r;
  return n = n.map(function(a) {
    return !r && t.tokens && typeof a[1] == "string" ? [
      a[0],
      KW(a[1])
    ] : [
      a[0],
      Cc(a[1])
    ];
  }), s ? WW(e, t, n) : i ? zW(e, t, n) : tv(e, t, n);
}
function UW(e, t) {
  var n = [
    "get",
    e.property
  ];
  if (e.default === void 0)
    return t.type === "string" ? [
      "string",
      n
    ] : n;
  if (t.type === "enum")
    return [
      "match",
      n,
      Object.keys(t.values),
      n,
      e.default
    ];
  var s = [
    t.type === "color" ? "to-color" : t.type,
    n,
    Cc(e.default)
  ];
  return t.type === "array" && s.splice(1, 0, t.value, t.length || null), s;
}
function m0(e) {
  switch (e.colorSpace) {
    case "hcl":
      return "interpolate-hcl";
    case "lab":
      return "interpolate-lab";
    default:
      return "interpolate";
  }
}
function WW(e, t, n) {
  for (var s = {}, r = {}, i = [], a = 0; a < n.length; a++) {
    var o = n[a], l = o[0].zoom;
    s[l] === void 0 && (s[l] = {
      zoom: l,
      type: e.type,
      property: e.property,
      default: e.default
    }, r[l] = [], i.push(l)), r[l].push([
      o[0].value,
      o[1]
    ]);
  }
  var f = v0({}, t);
  if (f === "exponential") {
    for (var d = [
      m0(e),
      ["linear"],
      ["zoom"]
    ], u = 0, c = i; u < c.length; u += 1) {
      var h = c[u], p = tv(s[h], t, r[h]);
      $l(d, h, p, !1);
    }
    return d;
  } else {
    for (var g = [
      "step",
      ["zoom"]
    ], m = 0, v = i; m < v.length; m += 1) {
      var y = v[m], E = tv(s[y], t, r[y]);
      $l(g, y, E, !0);
    }
    return g0(g), g;
  }
}
function $W(e, t) {
  if (e !== void 0)
    return e;
  if (t !== void 0)
    return t;
}
function ux(e, t) {
  var n = Cc($W(e.default, t.default));
  return n === void 0 && t.type === "resolvedImage" ? "" : n;
}
function tv(e, t, n) {
  var s = v0(e, t), r = [
    "get",
    e.property
  ];
  if (s === "categorical" && typeof n[0][0] == "boolean") {
    for (var i = ["case"], a = 0, o = n; a < o.length; a += 1) {
      var l = o[a];
      i.push([
        "==",
        r,
        l[0]
      ], l[1]);
    }
    return i.push(ux(e, t)), i;
  } else if (s === "categorical") {
    for (var f = [
      "match",
      r
    ], d = 0, u = n; d < u.length; d += 1) {
      var c = u[d];
      $l(f, c[0], c[1], !1);
    }
    return f.push(ux(e, t)), f;
  } else if (s === "interval") {
    for (var h = [
      "step",
      [
        "number",
        r
      ]
    ], p = 0, g = n; p < g.length; p += 1) {
      var m = g[p];
      $l(h, m[0], m[1], !0);
    }
    return g0(h), e.default === void 0 ? h : [
      "case",
      [
        "==",
        [
          "typeof",
          r
        ],
        "number"
      ],
      h,
      Cc(e.default)
    ];
  } else if (s === "exponential") {
    for (var v = e.base !== void 0 ? e.base : 1, y = [
      m0(e),
      v === 1 ? ["linear"] : [
        "exponential",
        v
      ],
      [
        "number",
        r
      ]
    ], E = 0, C = n; E < C.length; E += 1) {
      var x = C[E];
      $l(y, x[0], x[1], !1);
    }
    return e.default === void 0 ? y : [
      "case",
      [
        "==",
        [
          "typeof",
          r
        ],
        "number"
      ],
      y,
      Cc(e.default)
    ];
  } else
    throw new Error("Unknown property function type " + s);
}
function zW(e, t, n, s) {
  s === void 0 && (s = ["zoom"]);
  var r = v0(e, t), i, a = !1;
  if (r === "interval")
    i = [
      "step",
      s
    ], a = !0;
  else if (r === "exponential") {
    var o = e.base !== void 0 ? e.base : 1;
    i = [
      m0(e),
      o === 1 ? ["linear"] : [
        "exponential",
        o
      ],
      s
    ];
  } else
    throw new Error('Unknown zoom function type "' + r + '"');
  for (var l = 0, f = n; l < f.length; l += 1) {
    var d = f[l];
    $l(i, d[0], d[1], a);
  }
  return g0(i), i;
}
function g0(e) {
  e[0] === "step" && e.length === 3 && (e.push(0), e.push(e[3]));
}
function $l(e, t, n, s) {
  e.length > 3 && t === e[e.length - 2] || (s && e.length === 2 || e.push(t), e.push(n));
}
function v0(e, t) {
  return e.type ? e.type : t.expression.interpolated ? "exponential" : "interval";
}
function KW(e) {
  for (var t = ["concat"], n = /{([^{}]+)}/g, s = 0, r = n.exec(e); r !== null; r = n.exec(e)) {
    var i = e.slice(s, n.lastIndex - r[0].length);
    s = n.lastIndex, i.length > 0 && t.push(i), t.push([
      "get",
      r[1]
    ]);
  }
  if (t.length === 1)
    return e;
  if (s < e.length)
    t.push(e.slice(s));
  else if (t.length === 2)
    return [
      "to-string",
      t[1]
    ];
  return t;
}
var as = /* @__PURE__ */ function(e) {
  function t(n, s) {
    e.call(this, s), this.message = s, this.key = n;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t;
}(Error), xc = function(t, n) {
  n === void 0 && (n = []), this.parent = t, this.bindings = {};
  for (var s = 0, r = n; s < r.length; s += 1) {
    var i = r[s], a = i[0], o = i[1];
    this.bindings[a] = o;
  }
};
xc.prototype.concat = function(t) {
  return new xc(this, t);
};
xc.prototype.get = function(t) {
  if (this.bindings[t])
    return this.bindings[t];
  if (this.parent)
    return this.parent.get(t);
  throw new Error(t + " not found in scope.");
};
xc.prototype.has = function(t) {
  return this.bindings[t] ? !0 : this.parent ? this.parent.has(t) : !1;
};
var $f = { kind: "null" }, Pt = { kind: "number" }, pe = { kind: "string" }, ae = { kind: "boolean" }, Hs = { kind: "color" }, zl = { kind: "object" }, oe = { kind: "value" }, GW = { kind: "error" }, zf = { kind: "collator" }, Kf = { kind: "formatted" }, Xc = { kind: "resolvedImage" };
function fr(e, t) {
  return {
    kind: "array",
    itemType: e,
    N: t
  };
}
function nn(e) {
  if (e.kind === "array") {
    var t = nn(e.itemType);
    return typeof e.N == "number" ? "array<" + t + ", " + e.N + ">" : e.itemType.kind === "value" ? "array" : "array<" + t + ">";
  } else
    return e.kind;
}
var kW = [
  $f,
  Pt,
  pe,
  ae,
  Hs,
  Kf,
  zl,
  fr(oe),
  Xc
];
function bc(e, t) {
  if (t.kind === "error")
    return null;
  if (e.kind === "array") {
    if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !bc(e.itemType, t.itemType)) && (typeof e.N != "number" || e.N === t.N))
      return null;
  } else {
    if (e.kind === t.kind)
      return null;
    if (e.kind === "value")
      for (var n = 0, s = kW; n < s.length; n += 1) {
        var r = s[n];
        if (!bc(r, t))
          return null;
      }
  }
  return "Expected " + nn(e) + " but found " + nn(t) + " instead.";
}
function y0(e, t) {
  return t.some(function(n) {
    return n.kind === e.kind;
  });
}
function Oc(e, t) {
  return t.some(function(n) {
    return n === "null" ? e === null : n === "array" ? Array.isArray(e) : n === "object" ? e && !Array.isArray(e) && typeof e == "object" : n === typeof e;
  });
}
var Zc = function(t, n, s) {
  t ? this.sensitivity = n ? "variant" : "case" : this.sensitivity = n ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
    sensitivity: this.sensitivity,
    usage: "search"
  });
};
Zc.prototype.compare = function(t, n) {
  return this.collator.compare(t, n);
};
Zc.prototype.resolvedLocale = function() {
  return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};
var ev = function(t, n, s, r, i) {
  this.text = t.normalize ? t.normalize() : t, this.image = n, this.scale = s, this.fontStack = r, this.textColor = i;
}, Bi = function(t) {
  this.sections = t;
};
Bi.fromString = function(t) {
  return new Bi([new ev(t, null, null, null, null)]);
};
Bi.prototype.isEmpty = function() {
  return this.sections.length === 0 ? !0 : !this.sections.some(function(t) {
    return t.text.length !== 0 || t.image && t.image.name.length !== 0;
  });
};
Bi.factory = function(t) {
  return t instanceof Bi ? t : Bi.fromString(t);
};
Bi.prototype.toString = function() {
  return this.sections.length === 0 ? "" : this.sections.map(function(t) {
    return t.text;
  }).join("");
};
Bi.prototype.serialize = function() {
  for (var t = ["format"], n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    if (r.image) {
      t.push([
        "image",
        r.image.name
      ]);
      continue;
    }
    t.push(r.text);
    var i = {};
    r.fontStack && (i["text-font"] = [
      "literal",
      r.fontStack.split(",")
    ]), r.scale && (i["font-scale"] = r.scale), r.textColor && (i["text-color"] = ["rgba"].concat(r.textColor.toArray())), t.push(i);
  }
  return t;
};
var ms = function(t) {
  this.name = t.name, this.available = t.available;
};
ms.prototype.toString = function() {
  return this.name;
};
ms.fromString = function(t) {
  return t ? new ms({
    name: t,
    available: !1
  }) : null;
};
ms.prototype.serialize = function() {
  return [
    "image",
    this.name
  ];
};
function PM(e, t, n, s) {
  if (!(typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255)) {
    var r = typeof s == "number" ? [
      e,
      t,
      n,
      s
    ] : [
      e,
      t,
      n
    ];
    return "Invalid rgba value [" + r.join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
  }
  return typeof s > "u" || typeof s == "number" && s >= 0 && s <= 1 ? null : "Invalid rgba value [" + [
    e,
    t,
    n,
    s
  ].join(", ") + "]: 'a' must be between 0 and 1.";
}
function zd(e) {
  if (e === null)
    return !0;
  if (typeof e == "string")
    return !0;
  if (typeof e == "boolean")
    return !0;
  if (typeof e == "number")
    return !0;
  if (e instanceof Le)
    return !0;
  if (e instanceof Zc)
    return !0;
  if (e instanceof Bi)
    return !0;
  if (e instanceof ms)
    return !0;
  if (Array.isArray(e)) {
    for (var t = 0, n = e; t < n.length; t += 1) {
      var s = n[t];
      if (!zd(s))
        return !1;
    }
    return !0;
  } else if (typeof e == "object") {
    for (var r in e)
      if (!zd(e[r]))
        return !1;
    return !0;
  } else
    return !1;
}
function Vn(e) {
  if (e === null)
    return $f;
  if (typeof e == "string")
    return pe;
  if (typeof e == "boolean")
    return ae;
  if (typeof e == "number")
    return Pt;
  if (e instanceof Le)
    return Hs;
  if (e instanceof Zc)
    return zf;
  if (e instanceof Bi)
    return Kf;
  if (e instanceof ms)
    return Xc;
  if (Array.isArray(e)) {
    for (var t = e.length, n, s = 0, r = e; s < r.length; s += 1) {
      var i = r[s], a = Vn(i);
      if (!n)
        n = a;
      else {
        if (n === a)
          continue;
        n = oe;
        break;
      }
    }
    return fr(n || oe, t);
  } else
    return zl;
}
function ic(e) {
  var t = typeof e;
  return e === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(e) : e instanceof Le || e instanceof Bi || e instanceof ms ? e.toString() : JSON.stringify(e);
}
var gs = function(t, n) {
  this.type = t, this.value = n;
};
gs.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("'literal' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");
  if (!zd(t[1]))
    return n.error("invalid value");
  var s = t[1], r = Vn(s), i = n.expectedType;
  return r.kind === "array" && r.N === 0 && i && i.kind === "array" && (typeof i.N != "number" || i.N === 0) && (r = i), new gs(r, s);
};
gs.prototype.evaluate = function() {
  return this.value;
};
gs.prototype.eachChild = function() {
};
gs.prototype.outputDefined = function() {
  return !0;
};
gs.prototype.serialize = function() {
  return this.type.kind === "array" || this.type.kind === "object" ? [
    "literal",
    this.value
  ] : this.value instanceof Le ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Bi ? this.value.serialize() : this.value;
};
var Gn = function(t) {
  this.name = "ExpressionEvaluationError", this.message = t;
};
Gn.prototype.toJSON = function() {
  return this.message;
};
var _p = {
  string: pe,
  number: Pt,
  boolean: ae,
  object: zl
}, Ti = function(t, n) {
  this.type = t, this.args = n;
};
Ti.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = 1, r, i = t[0];
  if (i === "array") {
    var a;
    if (t.length > 2) {
      var o = t[1];
      if (typeof o != "string" || !(o in _p) || o === "object")
        return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
      a = _p[o], s++;
    } else
      a = oe;
    var l;
    if (t.length > 3) {
      if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2])))
        return n.error('The length argument to "array" must be a positive integer literal', 2);
      l = t[2], s++;
    }
    r = fr(a, l);
  } else
    r = _p[i];
  for (var f = []; s < t.length; s++) {
    var d = n.parse(t[s], s, oe);
    if (!d)
      return null;
    f.push(d);
  }
  return new Ti(r, f);
};
Ti.prototype.evaluate = function(t) {
  for (var n = 0; n < this.args.length; n++) {
    var s = this.args[n].evaluate(t), r = bc(this.type, Vn(s));
    if (r) {
      if (n === this.args.length - 1)
        throw new Gn("Expected value to be of type " + nn(this.type) + ", but found " + nn(Vn(s)) + " instead.");
    } else
      return s;
  }
  return null;
};
Ti.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
Ti.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
Ti.prototype.serialize = function() {
  var t = this.type, n = [t.kind];
  if (t.kind === "array") {
    var s = t.itemType;
    if (s.kind === "string" || s.kind === "number" || s.kind === "boolean") {
      n.push(s.kind);
      var r = t.N;
      (typeof r == "number" || this.args.length > 1) && n.push(r);
    }
  }
  return n.concat(this.args.map(function(i) {
    return i.serialize();
  }));
};
var Ga = function(t) {
  this.type = Kf, this.sections = t;
};
Ga.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = t[1];
  if (!Array.isArray(s) && typeof s == "object")
    return n.error("First argument must be an image or text section.");
  for (var r = [], i = !1, a = 1; a <= t.length - 1; ++a) {
    var o = t[a];
    if (i && typeof o == "object" && !Array.isArray(o)) {
      i = !1;
      var l = null;
      if (o["font-scale"] && (l = n.parse(o["font-scale"], 1, Pt), !l))
        return null;
      var f = null;
      if (o["text-font"] && (f = n.parse(o["text-font"], 1, fr(pe)), !f))
        return null;
      var d = null;
      if (o["text-color"] && (d = n.parse(o["text-color"], 1, Hs), !d))
        return null;
      var u = r[r.length - 1];
      u.scale = l, u.font = f, u.textColor = d;
    } else {
      var c = n.parse(t[a], 1, oe);
      if (!c)
        return null;
      var h = c.type.kind;
      if (h !== "string" && h !== "value" && h !== "null" && h !== "resolvedImage")
        return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
      i = !0, r.push({
        content: c,
        scale: null,
        font: null,
        textColor: null
      });
    }
  }
  return new Ga(r);
};
Ga.prototype.evaluate = function(t) {
  var n = function(s) {
    var r = s.content.evaluate(t);
    return Vn(r) === Xc ? new ev("", r, null, null, null) : new ev(ic(r), null, s.scale ? s.scale.evaluate(t) : null, s.font ? s.font.evaluate(t).join(",") : null, s.textColor ? s.textColor.evaluate(t) : null);
  };
  return new Bi(this.sections.map(n));
};
Ga.prototype.eachChild = function(t) {
  for (var n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor);
  }
};
Ga.prototype.outputDefined = function() {
  return !1;
};
Ga.prototype.serialize = function() {
  for (var t = ["format"], n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    t.push(r.content.serialize());
    var i = {};
    r.scale && (i["font-scale"] = r.scale.serialize()), r.font && (i["text-font"] = r.font.serialize()), r.textColor && (i["text-color"] = r.textColor.serialize()), t.push(i);
  }
  return t;
};
var ka = function(t) {
  this.type = Xc, this.input = t;
};
ka.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected two arguments.");
  var s = n.parse(t[1], 1, pe);
  return s ? new ka(s) : n.error("No image name provided.");
};
ka.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = ms.fromString(n);
  return s && t.availableImages && (s.available = t.availableImages.indexOf(n) > -1), s;
};
ka.prototype.eachChild = function(t) {
  t(this.input);
};
ka.prototype.outputDefined = function() {
  return !1;
};
ka.prototype.serialize = function() {
  return [
    "image",
    this.input.serialize()
  ];
};
var HW = {
  "to-boolean": ae,
  "to-color": Hs,
  "to-number": Pt,
  "to-string": pe
}, mr = function(t, n) {
  this.type = t, this.args = n;
};
mr.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = t[0];
  if ((s === "to-boolean" || s === "to-string") && t.length !== 2)
    return n.error("Expected one argument.");
  for (var r = HW[s], i = [], a = 1; a < t.length; a++) {
    var o = n.parse(t[a], a, oe);
    if (!o)
      return null;
    i.push(o);
  }
  return new mr(r, i);
};
mr.prototype.evaluate = function(t) {
  if (this.type.kind === "boolean")
    return !!this.args[0].evaluate(t);
  if (this.type.kind === "color") {
    for (var n, s, r = 0, i = this.args; r < i.length; r += 1) {
      var a = i[r];
      if (n = a.evaluate(t), s = null, n instanceof Le)
        return n;
      if (typeof n == "string") {
        var o = t.parseColor(n);
        if (o)
          return o;
      } else if (Array.isArray(n) && (n.length < 3 || n.length > 4 ? s = "Invalid rbga value " + JSON.stringify(n) + ": expected an array containing either three or four numeric values." : s = PM(n[0], n[1], n[2], n[3]), !s))
        return new Le(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
    }
    throw new Gn(s || "Could not parse color from value '" + (typeof n == "string" ? n : String(JSON.stringify(n))) + "'");
  } else if (this.type.kind === "number") {
    for (var l = null, f = 0, d = this.args; f < d.length; f += 1) {
      var u = d[f];
      if (l = u.evaluate(t), l === null)
        return 0;
      var c = Number(l);
      if (!isNaN(c))
        return c;
    }
    throw new Gn("Could not convert " + JSON.stringify(l) + " to number.");
  } else
    return this.type.kind === "formatted" ? Bi.fromString(ic(this.args[0].evaluate(t))) : this.type.kind === "resolvedImage" ? ms.fromString(ic(this.args[0].evaluate(t))) : ic(this.args[0].evaluate(t));
};
mr.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
mr.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
mr.prototype.serialize = function() {
  if (this.type.kind === "formatted")
    return new Ga([{
      content: this.args[0],
      scale: null,
      font: null,
      textColor: null
    }]).serialize();
  if (this.type.kind === "resolvedImage")
    return new ka(this.args[0]).serialize();
  var t = ["to-" + this.type.kind];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var YW = [
  "Unknown",
  "Point",
  "LineString",
  "Polygon"
], ra = function() {
  this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
};
ra.prototype.id = function() {
  return this.feature && "id" in this.feature && this.feature.id ? this.feature.id : null;
};
ra.prototype.geometryType = function() {
  return this.feature ? typeof this.feature.type == "number" ? YW[this.feature.type] : this.feature.type : null;
};
ra.prototype.geometry = function() {
  return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
};
ra.prototype.canonicalID = function() {
  return this.canonical;
};
ra.prototype.properties = function() {
  return this.feature && this.feature.properties || {};
};
ra.prototype.distanceFromCenter = function() {
  if (this.featureTileCoord && this.featureDistanceData) {
    var t = this.featureDistanceData.center, n = this.featureDistanceData.scale, s = this.featureTileCoord, r = s.x, i = s.y, a = r * n - t[0], o = i * n - t[1], l = this.featureDistanceData.bearing[0], f = this.featureDistanceData.bearing[1], d = l * a + f * o;
    return d;
  }
  return 0;
};
ra.prototype.parseColor = function(t) {
  var n = this._parseColorCache[t];
  return n || (n = this._parseColorCache[t] = Le.parse(t)), n;
};
var di = function(t, n, s, r) {
  this.name = t, this.type = n, this._evaluate = s, this.args = r;
};
di.prototype.evaluate = function(t) {
  return this._evaluate(t, this.args);
};
di.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
di.prototype.outputDefined = function() {
  return !1;
};
di.prototype.serialize = function() {
  return [this.name].concat(this.args.map(function(t) {
    return t.serialize();
  }));
};
di.parse = function(t, n) {
  var s, r = t[0], i = di.definitions[r];
  if (!i)
    return n.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0);
  for (var a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[
    i[1],
    i[2]
  ]] : i.overloads, l = o.filter(
    function(D) {
      var _ = D[0];
      return !Array.isArray(_) || // varags
      _.length === t.length - 1;
    }
    // correct param count
  ), f = null, d = 0, u = l; d < u.length; d += 1) {
    var c = u[d], h = c[0], p = c[1];
    f = new Xa(n.registry, n.path, null, n.scope);
    for (var g = [], m = !1, v = 1; v < t.length; v++) {
      var y = t[v], E = Array.isArray(h) ? h[v - 1] : h.type, C = f.parse(y, 1 + g.length, E);
      if (!C) {
        m = !0;
        break;
      }
      g.push(C);
    }
    if (!m) {
      if (Array.isArray(h) && h.length !== g.length) {
        f.error("Expected " + h.length + " arguments, but found " + g.length + " instead.");
        continue;
      }
      for (var x = 0; x < g.length; x++) {
        var b = Array.isArray(h) ? h[x] : h.type, P = g[x];
        f.concat(x + 1).checkSubtype(b, P.type);
      }
      if (f.errors.length === 0)
        return new di(r, a, p, g);
    }
  }
  if (l.length === 1)
    (s = n.errors).push.apply(s, f.errors);
  else {
    for (var T = l.length ? l : o, O = T.map(function(D) {
      var _ = D[0];
      return XW(_);
    }).join(" | "), S = [], L = 1; L < t.length; L++) {
      var A = n.parse(t[L], 1 + S.length);
      if (!A)
        return null;
      S.push(nn(A.type));
    }
    n.error("Expected arguments of type " + O + ", but found (" + S.join(", ") + ") instead.");
  }
  return null;
};
di.register = function(t, n) {
  di.definitions = n;
  for (var s in n)
    t[s] = di;
};
function XW(e) {
  return Array.isArray(e) ? "(" + e.map(nn).join(", ") + ")" : "(" + nn(e.type) + "...)";
}
var Ha = function(t, n, s) {
  this.type = zf, this.locale = s, this.caseSensitive = t, this.diacriticSensitive = n;
};
Ha.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected one argument.");
  var s = t[1];
  if (typeof s != "object" || Array.isArray(s))
    return n.error("Collator options argument must be an object.");
  var r = n.parse(s["case-sensitive"] === void 0 ? !1 : s["case-sensitive"], 1, ae);
  if (!r)
    return null;
  var i = n.parse(s["diacritic-sensitive"] === void 0 ? !1 : s["diacritic-sensitive"], 1, ae);
  if (!i)
    return null;
  var a = null;
  return s.locale && (a = n.parse(s.locale, 1, pe), !a) ? null : new Ha(r, i, a);
};
Ha.prototype.evaluate = function(t) {
  return new Zc(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
};
Ha.prototype.eachChild = function(t) {
  t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
};
Ha.prototype.outputDefined = function() {
  return !1;
};
Ha.prototype.serialize = function() {
  var t = {};
  return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [
    "collator",
    t
  ];
};
var Ra = 8192;
function E0(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1]);
}
function ZW(e) {
  return (180 + e) / 360;
}
function JW(e) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360;
}
function Kd(e, t) {
  return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
}
function QW(e, t) {
  var n = ZW(e[0]), s = JW(e[1]), r = Math.pow(2, t.z);
  return [
    Math.round(n * r * Ra),
    Math.round(s * r * Ra)
  ];
}
function qW(e, t, n) {
  var s = e[0] - t[0], r = e[1] - t[1], i = e[0] - n[0], a = e[1] - n[1];
  return s * a - i * r === 0 && s * i <= 0 && r * a <= 0;
}
function t$(e, t, n) {
  return t[1] > e[1] != n[1] > e[1] && e[0] < (n[0] - t[0]) * (e[1] - t[1]) / (n[1] - t[1]) + t[0];
}
function C0(e, t) {
  for (var n = !1, s = 0, r = t.length; s < r; s++)
    for (var i = t[s], a = 0, o = i.length; a < o - 1; a++) {
      if (qW(e, i[a], i[a + 1]))
        return !1;
      t$(e, i[a], i[a + 1]) && (n = !n);
    }
  return n;
}
function e$(e, t) {
  for (var n = 0; n < t.length; n++)
    if (C0(e, t[n]))
      return !0;
  return !1;
}
function n$(e, t) {
  return e[0] * t[1] - e[1] * t[0];
}
function cx(e, t, n, s) {
  var r = e[0] - n[0], i = e[1] - n[1], a = t[0] - n[0], o = t[1] - n[1], l = s[0] - n[0], f = s[1] - n[1], d = r * f - l * i, u = a * f - l * o;
  return d > 0 && u < 0 || d < 0 && u > 0;
}
function i$(e, t, n, s) {
  var r = [
    t[0] - e[0],
    t[1] - e[1]
  ], i = [
    s[0] - n[0],
    s[1] - n[1]
  ];
  return n$(i, r) === 0 ? !1 : !!(cx(e, t, n, s) && cx(n, s, e, t));
}
function r$(e, t, n) {
  for (var s = 0, r = n; s < r.length; s += 1)
    for (var i = r[s], a = 0; a < i.length - 1; ++a)
      if (i$(e, t, i[a], i[a + 1]))
        return !0;
  return !1;
}
function MM(e, t) {
  for (var n = 0; n < e.length; ++n)
    if (!C0(e[n], t))
      return !1;
  for (var s = 0; s < e.length - 1; ++s)
    if (r$(e[s], e[s + 1], t))
      return !1;
  return !0;
}
function s$(e, t) {
  for (var n = 0; n < t.length; n++)
    if (MM(e, t[n]))
      return !0;
  return !1;
}
function x0(e, t, n) {
  for (var s = [], r = 0; r < e.length; r++) {
    for (var i = [], a = 0; a < e[r].length; a++) {
      var o = QW(e[r][a], n);
      E0(t, o), i.push(o);
    }
    s.push(i);
  }
  return s;
}
function SM(e, t, n) {
  for (var s = [], r = 0; r < e.length; r++) {
    var i = x0(e[r], t, n);
    s.push(i);
  }
  return s;
}
function IM(e, t, n, s) {
  if (e[0] < n[0] || e[0] > n[2]) {
    var r = s * 0.5, i = e[0] - n[0] > r ? -s : n[0] - e[0] > r ? s : 0;
    i === 0 && (i = e[0] - n[2] > r ? -s : n[2] - e[0] > r ? s : 0), e[0] += i;
  }
  E0(t, e);
}
function a$(e) {
  e[0] = e[1] = 1 / 0, e[2] = e[3] = -1 / 0;
}
function hx(e, t, n, s) {
  var r = Math.pow(2, s.z) * Ra, i = [
    s.x * Ra,
    s.y * Ra
  ], a = [];
  if (!e)
    return a;
  for (var o = 0, l = e; o < l.length; o += 1)
    for (var f = l[o], d = 0, u = f; d < u.length; d += 1) {
      var c = u[d], h = [
        c.x + i[0],
        c.y + i[1]
      ];
      IM(h, t, n, r), a.push(h);
    }
  return a;
}
function dx(e, t, n, s) {
  var r = Math.pow(2, s.z) * Ra, i = [
    s.x * Ra,
    s.y * Ra
  ], a = [];
  if (!e)
    return a;
  for (var o = 0, l = e; o < l.length; o += 1) {
    for (var f = l[o], d = [], u = 0, c = f; u < c.length; u += 1) {
      var h = c[u], p = [
        h.x + i[0],
        h.y + i[1]
      ];
      E0(t, p), d.push(p);
    }
    a.push(d);
  }
  if (t[2] - t[0] <= r / 2) {
    a$(t);
    for (var g = 0, m = a; g < m.length; g += 1)
      for (var v = m[g], y = 0, E = v; y < E.length; y += 1) {
        var C = E[y];
        IM(C, t, n, r);
      }
  }
  return a;
}
function o$(e, t) {
  var n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], s = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], r = e.canonicalID();
  if (!r)
    return !1;
  if (t.type === "Polygon") {
    var i = x0(t.coordinates, s, r), a = hx(e.geometry(), n, s, r);
    if (!Kd(n, s))
      return !1;
    for (var o = 0, l = a; o < l.length; o += 1) {
      var f = l[o];
      if (!C0(f, i))
        return !1;
    }
  }
  if (t.type === "MultiPolygon") {
    var d = SM(t.coordinates, s, r), u = hx(e.geometry(), n, s, r);
    if (!Kd(n, s))
      return !1;
    for (var c = 0, h = u; c < h.length; c += 1) {
      var p = h[c];
      if (!e$(p, d))
        return !1;
    }
  }
  return !0;
}
function l$(e, t) {
  var n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], s = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], r = e.canonicalID();
  if (!r)
    return !1;
  if (t.type === "Polygon") {
    var i = x0(t.coordinates, s, r), a = dx(e.geometry(), n, s, r);
    if (!Kd(n, s))
      return !1;
    for (var o = 0, l = a; o < l.length; o += 1) {
      var f = l[o];
      if (!MM(f, i))
        return !1;
    }
  }
  if (t.type === "MultiPolygon") {
    var d = SM(t.coordinates, s, r), u = dx(e.geometry(), n, s, r);
    if (!Kd(n, s))
      return !1;
    for (var c = 0, h = u; c < h.length; c += 1) {
      var p = h[c];
      if (!s$(p, d))
        return !1;
    }
  }
  return !0;
}
var Rr = function(t, n) {
  this.type = ae, this.geojson = t, this.geometries = n;
};
Rr.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("'within' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");
  if (zd(t[1])) {
    var s = t[1];
    if (s.type === "FeatureCollection")
      for (var r = 0; r < s.features.length; ++r) {
        var i = s.features[r].geometry.type;
        if (i === "Polygon" || i === "MultiPolygon")
          return new Rr(s, s.features[r].geometry);
      }
    else if (s.type === "Feature") {
      var a = s.geometry.type;
      if (a === "Polygon" || a === "MultiPolygon")
        return new Rr(s, s.geometry);
    } else if (s.type === "Polygon" || s.type === "MultiPolygon")
      return new Rr(s, s);
  }
  return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
};
Rr.prototype.evaluate = function(t) {
  if (t.geometry() != null && t.canonicalID() != null) {
    if (t.geometryType() === "Point")
      return o$(t, this.geometries);
    if (t.geometryType() === "LineString")
      return l$(t, this.geometries);
  }
  return !1;
};
Rr.prototype.eachChild = function() {
};
Rr.prototype.outputDefined = function() {
  return !0;
};
Rr.prototype.serialize = function() {
  return [
    "within",
    this.geojson
  ];
};
function Gf(e) {
  if (e instanceof di) {
    if (e.name === "get" && e.args.length === 1)
      return !1;
    if (e.name === "feature-state")
      return !1;
    if (e.name === "has" && e.args.length === 1)
      return !1;
    if (e.name === "properties" || e.name === "geometry-type" || e.name === "id")
      return !1;
    if (/^filter-/.test(e.name))
      return !1;
  }
  if (e instanceof Rr)
    return !1;
  var t = !0;
  return e.eachChild(function(n) {
    t && !Gf(n) && (t = !1);
  }), t;
}
function b0(e) {
  if (e instanceof di && e.name === "feature-state")
    return !1;
  var t = !0;
  return e.eachChild(function(n) {
    t && !b0(n) && (t = !1);
  }), t;
}
function O0(e, t) {
  if (e instanceof di && t.indexOf(e.name) >= 0)
    return !1;
  var n = !0;
  return e.eachChild(function(s) {
    n && !O0(s, t) && (n = !1);
  }), n;
}
var Ya = function(t, n) {
  this.type = n.type, this.name = t, this.boundExpression = n;
};
Ya.parse = function(t, n) {
  if (t.length !== 2 || typeof t[1] != "string")
    return n.error("'var' expression requires exactly one string literal argument.");
  var s = t[1];
  return n.scope.has(s) ? new Ya(s, n.scope.get(s)) : n.error('Unknown variable "' + s + '". Make sure "' + s + '" has been bound in an enclosing "let" expression before using it.', 1);
};
Ya.prototype.evaluate = function(t) {
  return this.boundExpression.evaluate(t);
};
Ya.prototype.eachChild = function() {
};
Ya.prototype.outputDefined = function() {
  return !1;
};
Ya.prototype.serialize = function() {
  return [
    "var",
    this.name
  ];
};
var Xa = function(t, n, s, r, i) {
  n === void 0 && (n = []), r === void 0 && (r = new xc()), i === void 0 && (i = []), this.registry = t, this.path = n, this.key = n.map(function(a) {
    return "[" + a + "]";
  }).join(""), this.scope = r, this.errors = i, this.expectedType = s;
};
Xa.prototype.parse = function(t, n, s, r, i) {
  return i === void 0 && (i = {}), n ? this.concat(n, s, r)._parse(t, i) : this._parse(t, i);
};
Xa.prototype._parse = function(t, n) {
  (t === null || typeof t == "string" || typeof t == "boolean" || typeof t == "number") && (t = [
    "literal",
    t
  ]);
  function s(d, u, c) {
    return c === "assert" ? new Ti(u, [d]) : c === "coerce" ? new mr(u, [d]) : d;
  }
  if (Array.isArray(t)) {
    if (t.length === 0)
      return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
    var r = t[0];
    if (typeof r != "string")
      return this.error("Expression name must be a string, but found " + typeof r + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
    var i = this.registry[r];
    if (i) {
      var a = i.parse(t, this);
      if (!a)
        return null;
      if (this.expectedType) {
        var o = this.expectedType, l = a.type;
        if ((o.kind === "string" || o.kind === "number" || o.kind === "boolean" || o.kind === "object" || o.kind === "array") && l.kind === "value")
          a = s(a, o, n.typeAnnotation || "assert");
        else if ((o.kind === "color" || o.kind === "formatted" || o.kind === "resolvedImage") && (l.kind === "value" || l.kind === "string"))
          a = s(a, o, n.typeAnnotation || "coerce");
        else if (this.checkSubtype(o, l))
          return null;
      }
      if (!(a instanceof gs) && a.type.kind !== "resolvedImage" && nv(a)) {
        var f = new ra();
        try {
          a = new gs(a.type, a.evaluate(f));
        } catch (d) {
          return this.error(d.message), null;
        }
      }
      return a;
    }
    return this.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0);
  } else
    return typeof t > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof t == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found " + typeof t + " instead.");
};
Xa.prototype.concat = function(t, n, s) {
  var r = typeof t == "number" ? this.path.concat(t) : this.path, i = s ? this.scope.concat(s) : this.scope;
  return new Xa(this.registry, r, n || null, i, this.errors);
};
Xa.prototype.error = function(t) {
  for (var n = [], s = arguments.length - 1; s-- > 0; )
    n[s] = arguments[s + 1];
  var r = "" + this.key + n.map(function(i) {
    return "[" + i + "]";
  }).join("");
  this.errors.push(new as(r, t));
};
Xa.prototype.checkSubtype = function(t, n) {
  var s = bc(t, n);
  return s && this.error(s), s;
};
function nv(e) {
  if (e instanceof Ya)
    return nv(e.boundExpression);
  if (e instanceof di && e.name === "error")
    return !1;
  if (e instanceof Ha)
    return !1;
  if (e instanceof Rr)
    return !1;
  var t = e instanceof mr || e instanceof Ti, n = !0;
  return e.eachChild(function(s) {
    t ? n = n && nv(s) : n = n && s instanceof gs;
  }), n ? Gf(e) && O0(e, [
    "zoom",
    "heatmap-density",
    "line-progress",
    "sky-radial-progress",
    "accumulated",
    "is-supported-script",
    "pitch",
    "distance-from-center"
  ]) : !1;
}
function _M(e, t) {
  for (var n = e.length - 1, s = 0, r = n, i = 0, a, o; s <= r; )
    if (i = Math.floor((s + r) / 2), a = e[i], o = e[i + 1], a <= t) {
      if (i === n || t < o)
        return i;
      s = i + 1;
    } else if (a > t)
      r = i - 1;
    else
      throw new Gn("Input is not a number.");
  return 0;
}
var Za = function(t, n, s) {
  this.type = t, this.input = n, this.labels = [], this.outputs = [];
  for (var r = 0, i = s; r < i.length; r += 1) {
    var a = i[r], o = a[0], l = a[1];
    this.labels.push(o), this.outputs.push(l);
  }
};
Za.parse = function(t, n) {
  if (t.length - 1 < 4)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if ((t.length - 1) % 2 !== 0)
    return n.error("Expected an even number of arguments.");
  var s = n.parse(t[1], 1, Pt);
  if (!s)
    return null;
  var r = [], i = null;
  n.expectedType && n.expectedType.kind !== "value" && (i = n.expectedType);
  for (var a = 1; a < t.length; a += 2) {
    var o = a === 1 ? -1 / 0 : t[a], l = t[a + 1], f = a, d = a + 1;
    if (typeof o != "number")
      return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
    if (r.length && r[r.length - 1][0] >= o)
      return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', f);
    var u = n.parse(l, d, i);
    if (!u)
      return null;
    i = i || u.type, r.push([
      o,
      u
    ]);
  }
  return new Za(i, s, r);
};
Za.prototype.evaluate = function(t) {
  var n = this.labels, s = this.outputs;
  if (n.length === 1)
    return s[0].evaluate(t);
  var r = this.input.evaluate(t);
  if (r <= n[0])
    return s[0].evaluate(t);
  var i = n.length;
  if (r >= n[i - 1])
    return s[i - 1].evaluate(t);
  var a = _M(n, r);
  return s[a].evaluate(t);
};
Za.prototype.eachChild = function(t) {
  t(this.input);
  for (var n = 0, s = this.outputs; n < s.length; n += 1) {
    var r = s[n];
    t(r);
  }
};
Za.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  });
};
Za.prototype.serialize = function() {
  for (var t = [
    "step",
    this.input.serialize()
  ], n = 0; n < this.labels.length; n++)
    n > 0 && t.push(this.labels[n]), t.push(this.outputs[n].serialize());
  return t;
};
var u$ = yu;
function yu(e, t, n, s) {
  this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (s - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = s, this.p2x = n, this.p2y = s;
}
yu.prototype.sampleCurveX = function(e) {
  return ((this.ax * e + this.bx) * e + this.cx) * e;
};
yu.prototype.sampleCurveY = function(e) {
  return ((this.ay * e + this.by) * e + this.cy) * e;
};
yu.prototype.sampleCurveDerivativeX = function(e) {
  return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
};
yu.prototype.solveCurveX = function(e, t) {
  typeof t > "u" && (t = 1e-6);
  var n, s, r, i, a;
  for (r = e, a = 0; a < 8; a++) {
    if (i = this.sampleCurveX(r) - e, Math.abs(i) < t)
      return r;
    var o = this.sampleCurveDerivativeX(r);
    if (Math.abs(o) < 1e-6)
      break;
    r = r - i / o;
  }
  if (n = 0, s = 1, r = e, r < n)
    return n;
  if (r > s)
    return s;
  for (; n < s; ) {
    if (i = this.sampleCurveX(r), Math.abs(i - e) < t)
      return r;
    e > i ? n = r : s = r, r = (s - n) * 0.5 + n;
  }
  return r;
};
yu.prototype.solve = function(e, t) {
  return this.sampleCurveY(this.solveCurveX(e, t));
};
function Ji(e, t, n) {
  return e * (1 - n) + t * n;
}
function c$(e, t, n) {
  return new Le(Ji(e.r, t.r, n), Ji(e.g, t.g, n), Ji(e.b, t.b, n), Ji(e.a, t.a, n));
}
function h$(e, t, n) {
  return e.map(function(s, r) {
    return Ji(s, t[r], n);
  });
}
var d$ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  number: Ji,
  color: c$,
  array: h$
}), DM = 0.95047, AM = 1, LM = 1.08883, RM = 4 / 29, Kl = 6 / 29, wM = 3 * Kl * Kl, f$ = Kl * Kl * Kl, p$ = Math.PI / 180, m$ = 180 / Math.PI;
function Dp(e) {
  return e > f$ ? Math.pow(e, 1 / 3) : e / wM + RM;
}
function Ap(e) {
  return e > Kl ? e * e * e : wM * (e - RM);
}
function Lp(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function Rp(e) {
  return e /= 255, e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function VM(e) {
  var t = Rp(e.r), n = Rp(e.g), s = Rp(e.b), r = Dp((0.4124564 * t + 0.3575761 * n + 0.1804375 * s) / DM), i = Dp((0.2126729 * t + 0.7151522 * n + 0.072175 * s) / AM), a = Dp((0.0193339 * t + 0.119192 * n + 0.9503041 * s) / LM);
  return {
    l: 116 * i - 16,
    a: 500 * (r - i),
    b: 200 * (i - a),
    alpha: e.a
  };
}
function BM(e) {
  var t = (e.l + 16) / 116, n = isNaN(e.a) ? t : t + e.a / 500, s = isNaN(e.b) ? t : t - e.b / 200;
  return t = AM * Ap(t), n = DM * Ap(n), s = LM * Ap(s), new Le(
    Lp(3.2404542 * n - 1.5371385 * t - 0.4985314 * s),
    // D65 -> sRGB
    Lp(-0.969266 * n + 1.8760108 * t + 0.041556 * s),
    Lp(0.0556434 * n - 0.2040259 * t + 1.0572252 * s),
    e.alpha
  );
}
function g$(e, t, n) {
  return {
    l: Ji(e.l, t.l, n),
    a: Ji(e.a, t.a, n),
    b: Ji(e.b, t.b, n),
    alpha: Ji(e.alpha, t.alpha, n)
  };
}
function v$(e) {
  var t = VM(e), n = t.l, s = t.a, r = t.b, i = Math.atan2(r, s) * m$;
  return {
    h: i < 0 ? i + 360 : i,
    c: Math.sqrt(s * s + r * r),
    l: n,
    alpha: e.a
  };
}
function y$(e) {
  var t = e.h * p$, n = e.c, s = e.l;
  return BM({
    l: s,
    a: Math.cos(t) * n,
    b: Math.sin(t) * n,
    alpha: e.alpha
  });
}
function E$(e, t, n) {
  var s = t - e;
  return e + n * (s > 180 || s < -180 ? s - 360 * Math.round(s / 360) : s);
}
function C$(e, t, n) {
  return {
    h: E$(e.h, t.h, n),
    c: Ji(e.c, t.c, n),
    l: Ji(e.l, t.l, n),
    alpha: Ji(e.alpha, t.alpha, n)
  };
}
var Sh = {
  forward: VM,
  reverse: BM,
  interpolate: g$
}, Ih = {
  forward: v$,
  reverse: y$,
  interpolate: C$
}, Mi = function(t, n, s, r, i) {
  this.type = t, this.operator = n, this.interpolation = s, this.input = r, this.labels = [], this.outputs = [];
  for (var a = 0, o = i; a < o.length; a += 1) {
    var l = o[a], f = l[0], d = l[1];
    this.labels.push(f), this.outputs.push(d);
  }
};
Mi.interpolationFactor = function(t, n, s, r) {
  var i = 0;
  if (t.name === "exponential")
    i = wp(n, t.base, s, r);
  else if (t.name === "linear")
    i = wp(n, 1, s, r);
  else if (t.name === "cubic-bezier") {
    var a = t.controlPoints, o = new u$(a[0], a[1], a[2], a[3]);
    i = o.solve(wp(n, 1, s, r));
  }
  return i;
};
Mi.parse = function(t, n) {
  var s = t[0], r = t[1], i = t[2], a = t.slice(3);
  if (!Array.isArray(r) || r.length === 0)
    return n.error("Expected an interpolation type expression.", 1);
  if (r[0] === "linear")
    r = { name: "linear" };
  else if (r[0] === "exponential") {
    var o = r[1];
    if (typeof o != "number")
      return n.error("Exponential interpolation requires a numeric base.", 1, 1);
    r = {
      name: "exponential",
      base: o
    };
  } else if (r[0] === "cubic-bezier") {
    var l = r.slice(1);
    if (l.length !== 4 || l.some(function(v) {
      return typeof v != "number" || v < 0 || v > 1;
    }))
      return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
    r = {
      name: "cubic-bezier",
      controlPoints: l
    };
  } else
    return n.error("Unknown interpolation type " + String(r[0]), 1, 0);
  if (t.length - 1 < 4)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if ((t.length - 1) % 2 !== 0)
    return n.error("Expected an even number of arguments.");
  if (i = n.parse(i, 2, Pt), !i)
    return null;
  var f = [], d = null;
  s === "interpolate-hcl" || s === "interpolate-lab" ? d = Hs : n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType);
  for (var u = 0; u < a.length; u += 2) {
    var c = a[u], h = a[u + 1], p = u + 3, g = u + 4;
    if (typeof c != "number")
      return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', p);
    if (f.length && f[f.length - 1][0] >= c)
      return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', p);
    var m = n.parse(h, g, d);
    if (!m)
      return null;
    d = d || m.type, f.push([
      c,
      m
    ]);
  }
  return d.kind !== "number" && d.kind !== "color" && !(d.kind === "array" && d.itemType.kind === "number" && typeof d.N == "number") ? n.error("Type " + nn(d) + " is not interpolatable.") : new Mi(d, s, r, i, f);
};
Mi.prototype.evaluate = function(t) {
  var n = this.labels, s = this.outputs;
  if (n.length === 1)
    return s[0].evaluate(t);
  var r = this.input.evaluate(t);
  if (r <= n[0])
    return s[0].evaluate(t);
  var i = n.length;
  if (r >= n[i - 1])
    return s[i - 1].evaluate(t);
  var a = _M(n, r), o = n[a], l = n[a + 1], f = Mi.interpolationFactor(this.interpolation, r, o, l), d = s[a].evaluate(t), u = s[a + 1].evaluate(t);
  return this.operator === "interpolate" ? d$[this.type.kind.toLowerCase()](d, u, f) : this.operator === "interpolate-hcl" ? Ih.reverse(Ih.interpolate(Ih.forward(d), Ih.forward(u), f)) : Sh.reverse(Sh.interpolate(Sh.forward(d), Sh.forward(u), f));
};
Mi.prototype.eachChild = function(t) {
  t(this.input);
  for (var n = 0, s = this.outputs; n < s.length; n += 1) {
    var r = s[n];
    t(r);
  }
};
Mi.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  });
};
Mi.prototype.serialize = function() {
  var t;
  this.interpolation.name === "linear" ? t = ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? t = ["linear"] : t = [
    "exponential",
    this.interpolation.base
  ] : t = ["cubic-bezier"].concat(this.interpolation.controlPoints);
  for (var n = [
    this.operator,
    t,
    this.input.serialize()
  ], s = 0; s < this.labels.length; s++)
    n.push(this.labels[s], this.outputs[s].serialize());
  return n;
};
function wp(e, t, n, s) {
  var r = s - n, i = e - n;
  return r === 0 ? 0 : t === 1 ? i / r : (Math.pow(t, i) - 1) / (Math.pow(t, r) - 1);
}
var Ys = function(t, n) {
  this.type = t, this.args = n;
};
Ys.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expectected at least one argument.");
  var s = null, r = n.expectedType;
  r && r.kind !== "value" && (s = r);
  for (var i = [], a = 0, o = t.slice(1); a < o.length; a += 1) {
    var l = o[a], f = n.parse(l, 1 + i.length, s, void 0, { typeAnnotation: "omit" });
    if (!f)
      return null;
    s = s || f.type, i.push(f);
  }
  var d = r && i.some(function(u) {
    return bc(r, u.type);
  });
  return d ? new Ys(oe, i) : new Ys(s, i);
};
Ys.prototype.evaluate = function(t) {
  for (var n = null, s = 0, r, i = 0, a = this.args; i < a.length; i += 1) {
    var o = a[i];
    if (s++, n = o.evaluate(t), n && n instanceof ms && !n.available && (r || (r = n), n = null, s === this.args.length))
      return r;
    if (n !== null)
      break;
  }
  return n;
};
Ys.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
Ys.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
Ys.prototype.serialize = function() {
  var t = ["coalesce"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var Ja = function(t, n) {
  this.type = n.type, this.bindings = [].concat(t), this.result = n;
};
Ja.prototype.evaluate = function(t) {
  return this.result.evaluate(t);
};
Ja.prototype.eachChild = function(t) {
  for (var n = 0, s = this.bindings; n < s.length; n += 1) {
    var r = s[n];
    t(r[1]);
  }
  t(this.result);
};
Ja.parse = function(t, n) {
  if (t.length < 4)
    return n.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead.");
  for (var s = [], r = 1; r < t.length - 1; r += 2) {
    var i = t[r];
    if (typeof i != "string")
      return n.error("Expected string, but found " + typeof i + " instead.", r);
    if (/[^a-zA-Z0-9_]/.test(i))
      return n.error("Variable names must contain only alphanumeric characters or '_'.", r);
    var a = n.parse(t[r + 1], r + 1);
    if (!a)
      return null;
    s.push([
      i,
      a
    ]);
  }
  var o = n.parse(t[t.length - 1], t.length - 1, n.expectedType, s);
  return o ? new Ja(s, o) : null;
};
Ja.prototype.outputDefined = function() {
  return this.result.outputDefined();
};
Ja.prototype.serialize = function() {
  for (var t = ["let"], n = 0, s = this.bindings; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    t.push(i, a.serialize());
  }
  return t.push(this.result.serialize()), t;
};
var Fo = function(t, n, s) {
  this.type = t, this.index = n, this.input = s;
};
Fo.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, Pt), r = n.parse(t[2], 2, fr(n.expectedType || oe));
  if (!s || !r)
    return null;
  var i = r.type;
  return new Fo(i.itemType, s, r);
};
Fo.prototype.evaluate = function(t) {
  var n = this.index.evaluate(t), s = this.input.evaluate(t);
  if (n < 0)
    throw new Gn("Array index out of bounds: " + n + " < 0.");
  if (n >= s.length)
    throw new Gn("Array index out of bounds: " + n + " > " + (s.length - 1) + ".");
  if (n !== Math.floor(n))
    throw new Gn("Array index must be an integer, but found " + n + " instead.");
  return s[n];
};
Fo.prototype.eachChild = function(t) {
  t(this.index), t(this.input);
};
Fo.prototype.outputDefined = function() {
  return !1;
};
Fo.prototype.serialize = function() {
  return [
    "at",
    this.index.serialize(),
    this.input.serialize()
  ];
};
var jo = function(t, n) {
  this.type = ae, this.needle = t, this.haystack = n;
};
jo.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, oe), r = n.parse(t[2], 2, oe);
  return !s || !r ? null : y0(s.type, [
    ae,
    pe,
    Pt,
    $f,
    oe
  ]) ? new jo(s, r) : n.error("Expected first argument to be of type boolean, string, number or null, but found " + nn(s.type) + " instead");
};
jo.prototype.evaluate = function(t) {
  var n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
  if (s == null)
    return !1;
  if (!Oc(n, [
    "boolean",
    "string",
    "number",
    "null"
  ]))
    throw new Gn("Expected first argument to be of type boolean, string, number or null, but found " + nn(Vn(n)) + " instead.");
  if (!Oc(s, [
    "string",
    "array"
  ]))
    throw new Gn("Expected second argument to be of type array or string, but found " + nn(Vn(s)) + " instead.");
  return s.indexOf(n) >= 0;
};
jo.prototype.eachChild = function(t) {
  t(this.needle), t(this.haystack);
};
jo.prototype.outputDefined = function() {
  return !0;
};
jo.prototype.serialize = function() {
  return [
    "in",
    this.needle.serialize(),
    this.haystack.serialize()
  ];
};
var wa = function(t, n, s) {
  this.type = Pt, this.needle = t, this.haystack = n, this.fromIndex = s;
};
wa.parse = function(t, n) {
  if (t.length <= 2 || t.length >= 5)
    return n.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, oe), r = n.parse(t[2], 2, oe);
  if (!s || !r)
    return null;
  if (!y0(s.type, [
    ae,
    pe,
    Pt,
    $f,
    oe
  ]))
    return n.error("Expected first argument to be of type boolean, string, number or null, but found " + nn(s.type) + " instead");
  if (t.length === 4) {
    var i = n.parse(t[3], 3, Pt);
    return i ? new wa(s, r, i) : null;
  } else
    return new wa(s, r);
};
wa.prototype.evaluate = function(t) {
  var n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
  if (!Oc(n, [
    "boolean",
    "string",
    "number",
    "null"
  ]))
    throw new Gn("Expected first argument to be of type boolean, string, number or null, but found " + nn(Vn(n)) + " instead.");
  if (!Oc(s, [
    "string",
    "array"
  ]))
    throw new Gn("Expected second argument to be of type array or string, but found " + nn(Vn(s)) + " instead.");
  if (this.fromIndex) {
    var r = this.fromIndex.evaluate(t);
    return s.indexOf(n, r);
  }
  return s.indexOf(n);
};
wa.prototype.eachChild = function(t) {
  t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
};
wa.prototype.outputDefined = function() {
  return !1;
};
wa.prototype.serialize = function() {
  if (this.fromIndex != null && this.fromIndex !== void 0) {
    var t = this.fromIndex.serialize();
    return [
      "index-of",
      this.needle.serialize(),
      this.haystack.serialize(),
      t
    ];
  }
  return [
    "index-of",
    this.needle.serialize(),
    this.haystack.serialize()
  ];
};
var Uo = function(t, n, s, r, i, a) {
  this.inputType = t, this.type = n, this.input = s, this.cases = r, this.outputs = i, this.otherwise = a;
};
Uo.parse = function(t, n) {
  if (t.length < 5)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if (t.length % 2 !== 1)
    return n.error("Expected an even number of arguments.");
  var s, r;
  n.expectedType && n.expectedType.kind !== "value" && (r = n.expectedType);
  for (var i = {}, a = [], o = 2; o < t.length - 1; o += 2) {
    var l = t[o], f = t[o + 1];
    Array.isArray(l) || (l = [l]);
    var d = n.concat(o);
    if (l.length === 0)
      return d.error("Expected at least one branch label.");
    for (var u = 0, c = l; u < c.length; u += 1) {
      var h = c[u];
      if (typeof h != "number" && typeof h != "string")
        return d.error("Branch labels must be numbers or strings.");
      if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER)
        return d.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
      if (typeof h == "number" && Math.floor(h) !== h)
        return d.error("Numeric branch labels must be integer values.");
      if (!s)
        s = Vn(h);
      else if (d.checkSubtype(s, Vn(h)))
        return null;
      if (typeof i[String(h)] < "u")
        return d.error("Branch labels must be unique.");
      i[String(h)] = a.length;
    }
    var p = n.parse(f, o, r);
    if (!p)
      return null;
    r = r || p.type, a.push(p);
  }
  var g = n.parse(t[1], 1, oe);
  if (!g)
    return null;
  var m = n.parse(t[t.length - 1], t.length - 1, r);
  return !m || g.type.kind !== "value" && n.concat(1).checkSubtype(s, g.type) ? null : new Uo(s, r, g, i, a, m);
};
Uo.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = Vn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise;
  return s.evaluate(t);
};
Uo.prototype.eachChild = function(t) {
  t(this.input), this.outputs.forEach(t), t(this.otherwise);
};
Uo.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  }) && this.otherwise.outputDefined();
};
Uo.prototype.serialize = function() {
  for (var t = this, n = [
    "match",
    this.input.serialize()
  ], s = Object.keys(this.cases).sort(), r = [], i = {}, a = 0, o = s; a < o.length; a += 1) {
    var l = o[a], f = i[this.cases[l]];
    f === void 0 ? (i[this.cases[l]] = r.length, r.push([
      this.cases[l],
      [l]
    ])) : r[f][1].push(l);
  }
  for (var d = function(g) {
    return t.inputType.kind === "number" ? Number(g) : g;
  }, u = 0, c = r; u < c.length; u += 1) {
    var h = c[u], f = h[0], p = h[1];
    p.length === 1 ? n.push(d(p[0])) : n.push(p.map(d)), n.push(this.outputs[outputIndex$1].serialize());
  }
  return n.push(this.otherwise.serialize()), n;
};
var Wo = function(t, n, s) {
  this.type = t, this.branches = n, this.otherwise = s;
};
Wo.parse = function(t, n) {
  if (t.length < 4)
    return n.error("Expected at least 3 arguments, but found only " + (t.length - 1) + ".");
  if (t.length % 2 !== 0)
    return n.error("Expected an odd number of arguments.");
  var s;
  n.expectedType && n.expectedType.kind !== "value" && (s = n.expectedType);
  for (var r = [], i = 1; i < t.length - 1; i += 2) {
    var a = n.parse(t[i], i, ae);
    if (!a)
      return null;
    var o = n.parse(t[i + 1], i + 1, s);
    if (!o)
      return null;
    r.push([
      a,
      o
    ]), s = s || o.type;
  }
  var l = n.parse(t[t.length - 1], t.length - 1, s);
  return l ? new Wo(s, r, l) : null;
};
Wo.prototype.evaluate = function(t) {
  for (var n = 0, s = this.branches; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    if (i.evaluate(t))
      return a.evaluate(t);
  }
  return this.otherwise.evaluate(t);
};
Wo.prototype.eachChild = function(t) {
  for (var n = 0, s = this.branches; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    t(i), t(a);
  }
  t(this.otherwise);
};
Wo.prototype.outputDefined = function() {
  return this.branches.every(function(t) {
    t[0];
    var n = t[1];
    return n.outputDefined();
  }) && this.otherwise.outputDefined();
};
Wo.prototype.serialize = function() {
  var t = ["case"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var Va = function(t, n, s, r) {
  this.type = t, this.input = n, this.beginIndex = s, this.endIndex = r;
};
Va.parse = function(t, n) {
  if (t.length <= 2 || t.length >= 5)
    return n.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, oe), r = n.parse(t[2], 2, Pt);
  if (!s || !r)
    return null;
  if (!y0(s.type, [
    fr(oe),
    pe,
    oe
  ]))
    return n.error("Expected first argument to be of type array or string, but found " + nn(s.type) + " instead");
  if (t.length === 4) {
    var i = n.parse(t[3], 3, Pt);
    return i ? new Va(s.type, s, r, i) : null;
  } else
    return new Va(s.type, s, r);
};
Va.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = this.beginIndex.evaluate(t);
  if (!Oc(n, [
    "string",
    "array"
  ]))
    throw new Gn("Expected first argument to be of type array or string, but found " + nn(Vn(n)) + " instead.");
  if (this.endIndex) {
    var r = this.endIndex.evaluate(t);
    return n.slice(s, r);
  }
  return n.slice(s);
};
Va.prototype.eachChild = function(t) {
  t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
};
Va.prototype.outputDefined = function() {
  return !1;
};
Va.prototype.serialize = function() {
  if (this.endIndex != null && this.endIndex !== void 0) {
    var t = this.endIndex.serialize();
    return [
      "slice",
      this.input.serialize(),
      this.beginIndex.serialize(),
      t
    ];
  }
  return [
    "slice",
    this.input.serialize(),
    this.beginIndex.serialize()
  ];
};
function fx(e, t) {
  return e === "==" || e === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
}
function x$(e, t, n) {
  return t === n;
}
function b$(e, t, n) {
  return t !== n;
}
function O$(e, t, n) {
  return t < n;
}
function T$(e, t, n) {
  return t > n;
}
function P$(e, t, n) {
  return t <= n;
}
function M$(e, t, n) {
  return t >= n;
}
function NM(e, t, n, s) {
  return s.compare(t, n) === 0;
}
function S$(e, t, n, s) {
  return !NM(e, t, n, s);
}
function I$(e, t, n, s) {
  return s.compare(t, n) < 0;
}
function _$(e, t, n, s) {
  return s.compare(t, n) > 0;
}
function D$(e, t, n, s) {
  return s.compare(t, n) <= 0;
}
function A$(e, t, n, s) {
  return s.compare(t, n) >= 0;
}
function Eu(e, t, n) {
  var s = e !== "==" && e !== "!=";
  return /* @__PURE__ */ function() {
    function r(i, a, o) {
      this.type = ae, this.lhs = i, this.rhs = a, this.collator = o, this.hasUntypedArgument = i.type.kind === "value" || a.type.kind === "value";
    }
    return r.parse = function(a, o) {
      if (a.length !== 3 && a.length !== 4)
        return o.error("Expected two or three arguments.");
      var l = a[0], f = o.parse(a[1], 1, oe);
      if (!f)
        return null;
      if (!fx(l, f.type))
        return o.concat(1).error('"' + l + `" comparisons are not supported for type '` + nn(f.type) + "'.");
      var d = o.parse(a[2], 2, oe);
      if (!d)
        return null;
      if (!fx(l, d.type))
        return o.concat(2).error('"' + l + `" comparisons are not supported for type '` + nn(d.type) + "'.");
      if (f.type.kind !== d.type.kind && f.type.kind !== "value" && d.type.kind !== "value")
        return o.error("Cannot compare types '" + nn(f.type) + "' and '" + nn(d.type) + "'.");
      s && (f.type.kind === "value" && d.type.kind !== "value" ? f = new Ti(d.type, [f]) : f.type.kind !== "value" && d.type.kind === "value" && (d = new Ti(f.type, [d])));
      var u = null;
      if (a.length === 4) {
        if (f.type.kind !== "string" && d.type.kind !== "string" && f.type.kind !== "value" && d.type.kind !== "value")
          return o.error("Cannot use collator to compare non-string types.");
        if (u = o.parse(a[3], 3, zf), !u)
          return null;
      }
      return new r(f, d, u);
    }, r.prototype.evaluate = function(a) {
      var o = this.lhs.evaluate(a), l = this.rhs.evaluate(a);
      if (s && this.hasUntypedArgument) {
        var f = Vn(o), d = Vn(l);
        if (f.kind !== d.kind || !(f.kind === "string" || f.kind === "number"))
          throw new Gn('Expected arguments for "' + e + '" to be (string, string) or (number, number), but found (' + f.kind + ", " + d.kind + ") instead.");
      }
      if (this.collator && !s && this.hasUntypedArgument) {
        var u = Vn(o), c = Vn(l);
        if (u.kind !== "string" || c.kind !== "string")
          return t(a, o, l);
      }
      return this.collator ? n(a, o, l, this.collator.evaluate(a)) : t(a, o, l);
    }, r.prototype.eachChild = function(a) {
      a(this.lhs), a(this.rhs), this.collator && a(this.collator);
    }, r.prototype.outputDefined = function() {
      return !0;
    }, r.prototype.serialize = function() {
      var a = [e];
      return this.eachChild(function(o) {
        a.push(o.serialize());
      }), a;
    }, r;
  }();
}
var L$ = Eu("==", x$, NM), R$ = Eu("!=", b$, S$), w$ = Eu("<", O$, I$), V$ = Eu(">", T$, _$), B$ = Eu("<=", P$, D$), N$ = Eu(">=", M$, A$), $o = function(t, n, s, r, i) {
  this.type = pe, this.number = t, this.locale = n, this.currency = s, this.minFractionDigits = r, this.maxFractionDigits = i;
};
$o.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected two arguments.");
  var s = n.parse(t[1], 1, Pt);
  if (!s)
    return null;
  var r = t[2];
  if (typeof r != "object" || Array.isArray(r))
    return n.error("NumberFormat options argument must be an object.");
  var i = null;
  if (r.locale && (i = n.parse(r.locale, 1, pe), !i))
    return null;
  var a = null;
  if (r.currency && (a = n.parse(r.currency, 1, pe), !a))
    return null;
  var o = null;
  if (r["min-fraction-digits"] && (o = n.parse(r["min-fraction-digits"], 1, Pt), !o))
    return null;
  var l = null;
  return r["max-fraction-digits"] && (l = n.parse(r["max-fraction-digits"], 1, Pt), !l) ? null : new $o(s, i, a, o, l);
};
$o.prototype.evaluate = function(t) {
  return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
    style: this.currency ? "currency" : "decimal",
    currency: this.currency ? this.currency.evaluate(t) : void 0,
    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
  }).format(this.number.evaluate(t));
};
$o.prototype.eachChild = function(t) {
  t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
};
$o.prototype.outputDefined = function() {
  return !1;
};
$o.prototype.serialize = function() {
  var t = {};
  return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
    "number-format",
    this.number.serialize(),
    t
  ];
};
var zo = function(t) {
  this.type = Pt, this.input = t;
};
zo.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected 1 argument, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1);
  return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? n.error("Expected argument of type string or array, but found " + nn(s.type) + " instead.") : new zo(s) : null;
};
zo.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t);
  if (typeof n == "string")
    return n.length;
  if (Array.isArray(n))
    return n.length;
  throw new Gn("Expected value to be of type string or array, but found " + nn(Vn(n)) + " instead.");
};
zo.prototype.eachChild = function(t) {
  t(this.input);
};
zo.prototype.outputDefined = function() {
  return !1;
};
zo.prototype.serialize = function() {
  var t = ["length"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var T0 = {
  // special forms
  "==": L$,
  "!=": R$,
  ">": V$,
  "<": w$,
  ">=": N$,
  "<=": B$,
  array: Ti,
  at: Fo,
  boolean: Ti,
  case: Wo,
  coalesce: Ys,
  collator: Ha,
  format: Ga,
  image: ka,
  in: jo,
  "index-of": wa,
  interpolate: Mi,
  "interpolate-hcl": Mi,
  "interpolate-lab": Mi,
  length: zo,
  let: Ja,
  literal: gs,
  match: Uo,
  number: Ti,
  "number-format": $o,
  object: Ti,
  slice: Va,
  step: Za,
  string: Ti,
  "to-boolean": mr,
  "to-color": mr,
  "to-number": mr,
  "to-string": mr,
  var: Ya,
  within: Rr
};
function px(e, t) {
  var n = t[0], s = t[1], r = t[2], i = t[3];
  n = n.evaluate(e), s = s.evaluate(e), r = r.evaluate(e);
  var a = i ? i.evaluate(e) : 1, o = PM(n, s, r, a);
  if (o)
    throw new Gn(o);
  return new Le(n / 255 * a, s / 255 * a, r / 255 * a, a);
}
function mx(e, t) {
  return e in t;
}
function Vp(e, t) {
  var n = t[e];
  return typeof n > "u" ? null : n;
}
function F$(e, t, n, s) {
  for (; n <= s; ) {
    var r = n + s >> 1;
    if (t[r] === e)
      return !0;
    t[r] > e ? s = r - 1 : n = r + 1;
  }
  return !1;
}
function uo(e) {
  return { type: e };
}
di.register(T0, {
  error: [
    GW,
    [pe],
    function(e, t) {
      var n = t[0];
      throw new Gn(n.evaluate(e));
    }
  ],
  typeof: [
    pe,
    [oe],
    function(e, t) {
      var n = t[0];
      return nn(Vn(n.evaluate(e)));
    }
  ],
  "to-rgba": [
    fr(Pt, 4),
    [Hs],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toArray();
    }
  ],
  rgb: [
    Hs,
    [
      Pt,
      Pt,
      Pt
    ],
    px
  ],
  rgba: [
    Hs,
    [
      Pt,
      Pt,
      Pt,
      Pt
    ],
    px
  ],
  has: {
    type: ae,
    overloads: [
      [
        [pe],
        function(e, t) {
          var n = t[0];
          return mx(n.evaluate(e), e.properties());
        }
      ],
      [
        [
          pe,
          zl
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return mx(n.evaluate(e), s.evaluate(e));
        }
      ]
    ]
  },
  get: {
    type: oe,
    overloads: [
      [
        [pe],
        function(e, t) {
          var n = t[0];
          return Vp(n.evaluate(e), e.properties());
        }
      ],
      [
        [
          pe,
          zl
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return Vp(n.evaluate(e), s.evaluate(e));
        }
      ]
    ]
  },
  "feature-state": [
    oe,
    [pe],
    function(e, t) {
      var n = t[0];
      return Vp(n.evaluate(e), e.featureState || {});
    }
  ],
  properties: [
    zl,
    [],
    function(e) {
      return e.properties();
    }
  ],
  "geometry-type": [
    pe,
    [],
    function(e) {
      return e.geometryType();
    }
  ],
  id: [
    oe,
    [],
    function(e) {
      return e.id();
    }
  ],
  zoom: [
    Pt,
    [],
    function(e) {
      return e.globals.zoom;
    }
  ],
  pitch: [
    Pt,
    [],
    function(e) {
      return e.globals.pitch || 0;
    }
  ],
  "distance-from-center": [
    Pt,
    [],
    function(e) {
      return e.distanceFromCenter();
    }
  ],
  "heatmap-density": [
    Pt,
    [],
    function(e) {
      return e.globals.heatmapDensity || 0;
    }
  ],
  "line-progress": [
    Pt,
    [],
    function(e) {
      return e.globals.lineProgress || 0;
    }
  ],
  "sky-radial-progress": [
    Pt,
    [],
    function(e) {
      return e.globals.skyRadialProgress || 0;
    }
  ],
  accumulated: [
    oe,
    [],
    function(e) {
      return e.globals.accumulated === void 0 ? null : e.globals.accumulated;
    }
  ],
  "+": [
    Pt,
    uo(Pt),
    function(e, t) {
      for (var n = 0, s = 0, r = t; s < r.length; s += 1) {
        var i = r[s];
        n += i.evaluate(e);
      }
      return n;
    }
  ],
  "*": [
    Pt,
    uo(Pt),
    function(e, t) {
      for (var n = 1, s = 0, r = t; s < r.length; s += 1) {
        var i = r[s];
        n *= i.evaluate(e);
      }
      return n;
    }
  ],
  "-": {
    type: Pt,
    overloads: [
      [
        [
          Pt,
          Pt
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) - s.evaluate(e);
        }
      ],
      [
        [Pt],
        function(e, t) {
          var n = t[0];
          return -n.evaluate(e);
        }
      ]
    ]
  },
  "/": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return n.evaluate(e) / s.evaluate(e);
    }
  ],
  "%": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return n.evaluate(e) % s.evaluate(e);
    }
  ],
  ln2: [
    Pt,
    [],
    function() {
      return Math.LN2;
    }
  ],
  pi: [
    Pt,
    [],
    function() {
      return Math.PI;
    }
  ],
  e: [
    Pt,
    [],
    function() {
      return Math.E;
    }
  ],
  "^": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return Math.pow(n.evaluate(e), s.evaluate(e));
    }
  ],
  sqrt: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.sqrt(n.evaluate(e));
    }
  ],
  log10: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e)) / Math.LN10;
    }
  ],
  ln: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e));
    }
  ],
  log2: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e)) / Math.LN2;
    }
  ],
  sin: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.sin(n.evaluate(e));
    }
  ],
  cos: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.cos(n.evaluate(e));
    }
  ],
  tan: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.tan(n.evaluate(e));
    }
  ],
  asin: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.asin(n.evaluate(e));
    }
  ],
  acos: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.acos(n.evaluate(e));
    }
  ],
  atan: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.atan(n.evaluate(e));
    }
  ],
  min: [
    Pt,
    uo(Pt),
    function(e, t) {
      return Math.min.apply(Math, t.map(function(n) {
        return n.evaluate(e);
      }));
    }
  ],
  max: [
    Pt,
    uo(Pt),
    function(e, t) {
      return Math.max.apply(Math, t.map(function(n) {
        return n.evaluate(e);
      }));
    }
  ],
  abs: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.abs(n.evaluate(e));
    }
  ],
  round: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0], s = n.evaluate(e);
      return s < 0 ? -Math.round(-s) : Math.round(s);
    }
  ],
  floor: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.floor(n.evaluate(e));
    }
  ],
  ceil: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.ceil(n.evaluate(e));
    }
  ],
  "filter-==": [
    ae,
    [
      pe,
      oe
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return e.properties()[n.value] === s.value;
    }
  ],
  "filter-id-==": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0];
      return e.id() === n.value;
    }
  ],
  "filter-type-==": [
    ae,
    [pe],
    function(e, t) {
      var n = t[0];
      return e.geometryType() === n.value;
    }
  ],
  "filter-<": [
    ae,
    [
      pe,
      oe
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r < i;
    }
  ],
  "filter-id-<": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s < r;
    }
  ],
  "filter->": [
    ae,
    [
      pe,
      oe
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r > i;
    }
  ],
  "filter-id->": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s > r;
    }
  ],
  "filter-<=": [
    ae,
    [
      pe,
      oe
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r <= i;
    }
  ],
  "filter-id-<=": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s <= r;
    }
  ],
  "filter->=": [
    ae,
    [
      pe,
      oe
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r >= i;
    }
  ],
  "filter-id->=": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s >= r;
    }
  ],
  "filter-has": [
    ae,
    [oe],
    function(e, t) {
      var n = t[0];
      return n.value in e.properties();
    }
  ],
  "filter-has-id": [
    ae,
    [],
    function(e) {
      return e.id() !== null && e.id() !== void 0;
    }
  ],
  "filter-type-in": [
    ae,
    [fr(pe)],
    function(e, t) {
      var n = t[0];
      return n.value.indexOf(e.geometryType()) >= 0;
    }
  ],
  "filter-id-in": [
    ae,
    [fr(oe)],
    function(e, t) {
      var n = t[0];
      return n.value.indexOf(e.id()) >= 0;
    }
  ],
  "filter-in-small": [
    ae,
    [
      pe,
      fr(oe)
    ],
    // assumes v is an array literal
    function(e, t) {
      var n = t[0], s = t[1];
      return s.value.indexOf(e.properties()[n.value]) >= 0;
    }
  ],
  "filter-in-large": [
    ae,
    [
      pe,
      fr(oe)
    ],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    function(e, t) {
      var n = t[0], s = t[1];
      return F$(e.properties()[n.value], s.value, 0, s.value.length - 1);
    }
  ],
  all: {
    type: ae,
    overloads: [
      [
        [
          ae,
          ae
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) && s.evaluate(e);
        }
      ],
      [
        uo(ae),
        function(e, t) {
          for (var n = 0, s = t; n < s.length; n += 1) {
            var r = s[n];
            if (!r.evaluate(e))
              return !1;
          }
          return !0;
        }
      ]
    ]
  },
  any: {
    type: ae,
    overloads: [
      [
        [
          ae,
          ae
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) || s.evaluate(e);
        }
      ],
      [
        uo(ae),
        function(e, t) {
          for (var n = 0, s = t; n < s.length; n += 1) {
            var r = s[n];
            if (r.evaluate(e))
              return !0;
          }
          return !1;
        }
      ]
    ]
  },
  "!": [
    ae,
    [ae],
    function(e, t) {
      var n = t[0];
      return !n.evaluate(e);
    }
  ],
  "is-supported-script": [
    ae,
    [pe],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    function(e, t) {
      var n = t[0], s = e.globals && e.globals.isSupportedScript;
      return s ? s(n.evaluate(e)) : !0;
    }
  ],
  upcase: [
    pe,
    [pe],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toUpperCase();
    }
  ],
  downcase: [
    pe,
    [pe],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toLowerCase();
    }
  ],
  concat: [
    pe,
    uo(oe),
    function(e, t) {
      return t.map(function(n) {
        return ic(n.evaluate(e));
      }).join("");
    }
  ],
  "resolved-locale": [
    pe,
    [zf],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).resolvedLocale();
    }
  ]
});
function iv(e) {
  return {
    result: "success",
    value: e
  };
}
function El(e) {
  return {
    result: "error",
    value: e
  };
}
function j$(e) {
  return e["property-type"] === "data-driven" || e["property-type"] === "cross-faded-data-driven";
}
function U$(e) {
  return !!e.expression && e.expression.parameters.indexOf("zoom") > -1;
}
function W$(e) {
  return !!e.expression && e.expression.interpolated;
}
function FM(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var P0 = function(t, n) {
  this.expression = t, this._warningHistory = {}, this._evaluator = new ra(), this._defaultValue = n ? G$(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null;
};
P0.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a, o, l) {
  return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = s, this._evaluator.canonical = r || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = l || null, this.expression.evaluate(this._evaluator);
};
P0.prototype.evaluate = function(t, n, s, r, i, a, o, l) {
  this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = s || null, this._evaluator.canonical = r || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = l || null;
  try {
    var f = this.expression.evaluate(this._evaluator);
    if (f == null || typeof f == "number" && f !== f)
      return this._defaultValue;
    if (this._enumValues && !(f in this._enumValues))
      throw new Gn("Expected value to be one of " + Object.keys(this._enumValues).map(function(d) {
        return JSON.stringify(d);
      }).join(", ") + ", but found " + JSON.stringify(f) + " instead.");
    return f;
  } catch (d) {
    return this._warningHistory[d.message] || (this._warningHistory[d.message] = !0, typeof console < "u" && console.warn(d.message)), this._defaultValue;
  }
};
function $$(e) {
  return Array.isArray(e) && e.length > 0 && typeof e[0] == "string" && e[0] in T0;
}
function rv(e, t) {
  var n = new Xa(T0, [], t ? K$(t) : void 0), s = n.parse(e, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return s ? iv(new P0(s, t)) : El(n.errors);
}
var Gd = function(t, n) {
  this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !b0(n.expression);
};
Gd.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, r, i, a);
};
Gd.prototype.evaluate = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluate(t, n, s, r, i, a);
};
var Tc = function(t, n, s, r) {
  this.kind = t, this.zoomStops = s, this._styleExpression = n, this.isStateDependent = t !== "camera" && !b0(n.expression), this.interpolationType = r;
};
Tc.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, r, i, a);
};
Tc.prototype.evaluate = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluate(t, n, s, r, i, a);
};
Tc.prototype.interpolationFactor = function(t, n, s) {
  return this.interpolationType ? Mi.interpolationFactor(this.interpolationType, t, n, s) : 0;
};
function z$(e, t) {
  if (e = rv(e, t), e.result === "error")
    return e;
  var n = e.value.expression, s = Gf(n);
  if (!s && !j$(t))
    return El([new as("", "data expressions not supported")]);
  var r = O0(n, [
    "zoom",
    "pitch",
    "distance-from-center"
  ]);
  if (!r && !U$(t))
    return El([new as("", "zoom expressions not supported")]);
  var i = od(n);
  if (!i && !r)
    return El([new as("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (i instanceof as)
    return El([i]);
  if (i instanceof Mi && !W$(t))
    return El([new as("", '"interpolate" expressions cannot be used with this property')]);
  if (!i)
    return iv(s ? new Gd("constant", e.value) : new Gd("source", e.value));
  var a = i instanceof Mi ? i.interpolation : void 0;
  return iv(s ? new Tc("camera", e.value, i.labels, a) : new Tc("composite", e.value, i.labels, a));
}
function od(e) {
  var t = null;
  if (e instanceof Ja)
    t = od(e.result);
  else if (e instanceof Ys)
    for (var n = 0, s = e.args; n < s.length; n += 1) {
      var r = s[n];
      if (t = od(r), t)
        break;
    }
  else
    (e instanceof Za || e instanceof Mi) && e.input instanceof di && e.input.name === "zoom" && (t = e);
  return t instanceof as || e.eachChild(function(i) {
    var a = od(i);
    a instanceof as ? t = a : !t && a ? t = new as("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new as("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), t;
}
function K$(e) {
  var t = {
    color: Hs,
    string: pe,
    number: Pt,
    enum: pe,
    boolean: ae,
    formatted: Kf,
    resolvedImage: Xc
  };
  return e.type === "array" ? fr(t[e.value] || oe, e.length) : t[e.type];
}
function G$(e) {
  return e.type === "color" && (FM(e.default) || Array.isArray(e.default)) ? new Le(0, 0, 0, 0) : e.type === "color" ? Le.parse(e.default) || null : e.default === void 0 ? null : e.default;
}
function k$(e) {
  return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
}
function sv(e) {
  if (Array.isArray(e))
    return e.map(sv);
  if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
    var t = {};
    for (var n in e)
      t[n] = sv(e[n]);
    return t;
  }
  return k$(e);
}
var jM = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, fog: { type: "fog" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, projection: { type: "projection" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {}, sky: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_sky: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_symbol: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature", "pitch", "distance-from-center"] } }, filter_fill: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_line: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_circle: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, "filter_fill-extrusion": { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_heatmap: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, expression_name: { type: "enum", values: { let: { group: "Variable binding" }, var: { group: "Variable binding" }, literal: { group: "Types" }, array: { group: "Types" }, at: { group: "Lookup" }, in: { group: "Lookup" }, "index-of": { group: "Lookup" }, slice: { group: "Lookup" }, case: { group: "Decision" }, match: { group: "Decision" }, coalesce: { group: "Decision" }, step: { group: "Ramps, scales, curves" }, interpolate: { group: "Ramps, scales, curves" }, "interpolate-hcl": { group: "Ramps, scales, curves" }, "interpolate-lab": { group: "Ramps, scales, curves" }, ln2: { group: "Math" }, pi: { group: "Math" }, e: { group: "Math" }, typeof: { group: "Types" }, string: { group: "Types" }, number: { group: "Types" }, boolean: { group: "Types" }, object: { group: "Types" }, collator: { group: "Types" }, format: { group: "Types" }, image: { group: "Types" }, "number-format": { group: "Types" }, "to-string": { group: "Types" }, "to-number": { group: "Types" }, "to-boolean": { group: "Types" }, "to-rgba": { group: "Color" }, "to-color": { group: "Types" }, rgb: { group: "Color" }, rgba: { group: "Color" }, get: { group: "Lookup" }, has: { group: "Lookup" }, length: { group: "Lookup" }, properties: { group: "Feature data" }, "feature-state": { group: "Feature data" }, "geometry-type": { group: "Feature data" }, id: { group: "Feature data" }, zoom: { group: "Camera" }, pitch: { group: "Camera" }, "distance-from-center": { group: "Camera" }, "heatmap-density": { group: "Heatmap" }, "line-progress": { group: "Feature data" }, "sky-radial-progress": { group: "sky" }, accumulated: { group: "Feature data" }, "+": { group: "Math" }, "*": { group: "Math" }, "-": { group: "Math" }, "/": { group: "Math" }, "%": { group: "Math" }, "^": { group: "Math" }, sqrt: { group: "Math" }, log10: { group: "Math" }, ln: { group: "Math" }, log2: { group: "Math" }, sin: { group: "Math" }, cos: { group: "Math" }, tan: { group: "Math" }, asin: { group: "Math" }, acos: { group: "Math" }, atan: { group: "Math" }, min: { group: "Math" }, max: { group: "Math" }, round: { group: "Math" }, abs: { group: "Math" }, ceil: { group: "Math" }, floor: { group: "Math" }, distance: { group: "Math" }, "==": { group: "Decision" }, "!=": { group: "Decision" }, ">": { group: "Decision" }, "<": { group: "Decision" }, ">=": { group: "Decision" }, "<=": { group: "Decision" }, all: { group: "Decision" }, any: { group: "Decision" }, "!": { group: "Decision" }, within: { group: "Decision" }, "is-supported-script": { group: "String" }, upcase: { group: "String" }, downcase: { group: "String" }, concat: { group: "String" }, "resolved-locale": { group: "String" } } }, fog: { range: { type: "array", default: [0.5, 10], minimum: -20, maximum: 20, length: 2, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "high-color": { type: "color", "property-type": "data-constant", default: "#245cdf", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "space-color": { type: "color", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 4, "#010b19", 7, "#367ab9"], expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-blend": { type: "number", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 4, 0.2, 7, 0.1], minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "star-intensity": { type: "number", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 5, 0.35, 6, 0], minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, projection: { name: { type: "enum", values: { albers: {}, equalEarth: {}, equirectangular: {}, lambertConformalConic: {}, mercator: {}, naturalEarth: {}, winkelTripel: {}, globe: {} }, default: "mercator", required: !0 }, center: { type: "array", length: 2, value: "number", "property-type": "data-constant", minimum: [-180, -90], maximum: [180, 90], transition: !1, requires: [{ name: ["albers", "lambertConformalConic"] }] }, parallels: { type: "array", length: 2, value: "number", "property-type": "data-constant", minimum: [-90, -90], maximum: [90, 90], transition: !1, requires: [{ name: ["albers", "lambertConformalConic"] }] } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", "property-type": "data-constant", default: 1, minimum: 0, maximum: 1e3, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0, requires: ["source"] } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" }, "line-trim-offset": { type: "array", value: "number", length: 2, default: [0, 0], minimum: [0, 0], maximum: [1, 1], transition: !1, requires: [{ source: "geojson", has: { lineMetrics: !0 } }], "property-type": "constant" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_sky: { "sky-type": { type: "enum", values: { gradient: {}, atmosphere: {} }, default: "atmosphere", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun": { type: "array", value: "number", length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: !1, requires: [{ "sky-type": "atmosphere" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun-intensity": { type: "number", requires: [{ "sky-type": "atmosphere" }], default: 10, minimum: 0, maximum: 100, transition: !1, "property-type": "data-constant" }, "sky-gradient-center": { type: "array", requires: [{ "sky-type": "gradient" }], value: "number", default: [0, 0], length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient-radius": { type: "number", requires: [{ "sky-type": "gradient" }], default: 90, minimum: 0, maximum: 180, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient": { type: "color", default: ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"], transition: !1, requires: [{ "sky-type": "gradient" }], expression: { interpolated: !0, parameters: ["sky-radial-progress"] }, "property-type": "color-ramp" }, "sky-atmosphere-halo-color": { type: "color", default: "white", transition: !1, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-atmosphere-color": { type: "color", default: "white", transition: !1, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
function UM(e) {
  if (e === !0 || e === !1)
    return !0;
  if (!Array.isArray(e) || e.length === 0)
    return !1;
  switch (e[0]) {
    case "has":
      return e.length >= 2 && e[1] !== "$id" && e[1] !== "$type";
    case "in":
      return e.length >= 3 && (typeof e[1] != "string" || Array.isArray(e[2]));
    case "!in":
    case "!has":
    case "none":
      return !1;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return e.length !== 3 || Array.isArray(e[1]) || Array.isArray(e[2]);
    case "any":
    case "all":
      for (var t = 0, n = e.slice(1); t < n.length; t += 1) {
        var s = n[t];
        if (!UM(s) && typeof s != "boolean")
          return !1;
      }
      return !0;
    default:
      return !0;
  }
}
function H$(e, t) {
  if (t === void 0 && (t = "fill"), e == null)
    return {
      filter: function() {
        return !0;
      },
      needGeometry: !1,
      needFeature: !1
    };
  UM(e) || (e = kd(e));
  var n = e, s = !0;
  try {
    s = Y$(n);
  } catch {
    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
` + JSON.stringify(n, null, 2) + `
        `);
  }
  var r = jM["filter_" + t], i = rv(s, r), a = null;
  if (i.result === "error")
    throw new Error(i.value.map(function(u) {
      return u.key + ": " + u.message;
    }).join(", "));
  a = function(u, c, h) {
    return i.value.evaluate(u, c, {}, h);
  };
  var o = null, l = null;
  if (s !== n) {
    var f = rv(n, r);
    if (f.result === "error")
      throw new Error(f.value.map(function(u) {
        return u.key + ": " + u.message;
      }).join(", "));
    o = function(u, c, h, p, g) {
      return f.value.evaluate(u, c, {}, h, void 0, void 0, p, g);
    }, l = !Gf(f.value.expression);
  }
  a = a;
  var d = zM(s);
  return {
    filter: a,
    dynamicFilter: o || void 0,
    needGeometry: d,
    needFeature: !!l
  };
}
function Y$(e) {
  if (!Gl(e))
    return e;
  var t = sv(e);
  return $M(t), t = WM(t), t;
}
function WM(e) {
  if (!Array.isArray(e))
    return e;
  var t = J$(e);
  return t === !0 ? t : t.map(function(n) {
    return WM(n);
  });
}
function $M(e) {
  var t = !1, n = [];
  if (e[0] === "case") {
    for (var s = 1; s < e.length - 1; s += 2)
      t = t || Gl(e[s]), n.push(e[s + 1]);
    n.push(e[e.length - 1]);
  } else if (e[0] === "match") {
    t = t || Gl(e[1]);
    for (var r = 2; r < e.length - 1; r += 2)
      n.push(e[r + 1]);
    n.push(e[e.length - 1]);
  } else if (e[0] === "step") {
    t = t || Gl(e[1]);
    for (var i = 1; i < e.length - 1; i += 2)
      n.push(e[i + 1]);
  }
  t && (e.length = 0, e.push.apply(e, ["any"].concat(n)));
  for (var a = 1; a < e.length; a++)
    $M(e[a]);
}
function Gl(e) {
  if (!Array.isArray(e))
    return !1;
  if (X$(e[0]))
    return !0;
  for (var t = 1; t < e.length; t++) {
    var n = e[t];
    if (Gl(n))
      return !0;
  }
  return !1;
}
function X$(e) {
  return e === "pitch" || e === "distance-from-center";
}
var Z$ = /* @__PURE__ */ new Set([
  "in",
  "==",
  "!=",
  ">",
  ">=",
  "<",
  "<=",
  "to-boolean"
]);
function J$(e) {
  if (Z$.has(e[0]))
    for (var t = 1; t < e.length; t++) {
      var n = e[t];
      if (Gl(n))
        return !0;
    }
  return e;
}
function Q$(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function zM(e) {
  if (!Array.isArray(e))
    return !1;
  if (e[0] === "within")
    return !0;
  for (var t = 1; t < e.length; t++)
    if (zM(e[t]))
      return !0;
  return !1;
}
function kd(e) {
  if (!e)
    return !0;
  var t = e[0];
  if (e.length <= 1)
    return t !== "any";
  var n = t === "==" ? Bp(e[1], e[2], "==") : t === "!=" ? _h(Bp(e[1], e[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Bp(e[1], e[2], t) : t === "any" ? q$(e.slice(1)) : t === "all" ? ["all"].concat(e.slice(1).map(kd)) : t === "none" ? ["all"].concat(e.slice(1).map(kd).map(_h)) : t === "in" ? gx(e[1], e.slice(2)) : t === "!in" ? _h(gx(e[1], e.slice(2))) : t === "has" ? vx(e[1]) : t === "!has" ? _h(vx(e[1])) : t === "within" ? e : !0;
  return n;
}
function Bp(e, t, n) {
  switch (e) {
    case "$type":
      return [
        "filter-type-" + n,
        t
      ];
    case "$id":
      return [
        "filter-id-" + n,
        t
      ];
    default:
      return [
        "filter-" + n,
        e,
        t
      ];
  }
}
function q$(e) {
  return ["any"].concat(e.map(kd));
}
function gx(e, t) {
  if (t.length === 0)
    return !1;
  switch (e) {
    case "$type":
      return [
        "filter-type-in",
        [
          "literal",
          t
        ]
      ];
    case "$id":
      return [
        "filter-id-in",
        [
          "literal",
          t
        ]
      ];
    default:
      return t.length > 200 && !t.some(function(n) {
        return typeof n != typeof t[0];
      }) ? [
        "filter-in-large",
        e,
        [
          "literal",
          t.sort(Q$)
        ]
      ] : [
        "filter-in-small",
        e,
        [
          "literal",
          t
        ]
      ];
  }
}
function vx(e) {
  switch (e) {
    case "$type":
      return !0;
    case "$id":
      return ["filter-has-id"];
    default:
      return [
        "filter-has",
        e
      ];
  }
}
function _h(e) {
  return [
    "!",
    e
  ];
}
var t3 = [
  "type",
  "source",
  "source-layer",
  "minzoom",
  "maxzoom",
  "filter",
  "layout"
];
function e3(e, t) {
  var n = {};
  for (var s in e)
    s !== "ref" && (n[s] = e[s]);
  return t3.forEach(function(r) {
    r in t && (n[r] = t[r]);
  }), n;
}
function n3(e) {
  e = e.slice();
  for (var t = /* @__PURE__ */ Object.create(null), n = 0; n < e.length; n++)
    t[e[n].id] = e[n];
  for (var s = 0; s < e.length; s++)
    "ref" in e[s] && (e[s] = e3(e[s], t[e[s].ref]));
  return e;
}
var yx = {
  thin: 100,
  hairline: 100,
  "ultra-light": 100,
  "extra-light": 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  "semi-bold": 600,
  "demi-bold": 600,
  bold: 700,
  heavy: 800,
  black: 800,
  "extra-bold": 800,
  "ultra-black": 900,
  "extra-black": 900,
  "ultra-bold": 900,
  "heavy-black": 900,
  fat: 900,
  poster: 900
}, Bu = " ", Ex = /(italic|oblique)$/i, Cx = {}, xx = function(e, t, n) {
  var s = Cx[e];
  if (!s) {
    Array.isArray(e) || (e = [e]);
    for (var r = 400, i = "normal", a = [], o, l, f = 0, d = e.length; f < d; ++f) {
      var u = e[f], c = u.split(" "), h = c[c.length - 1].toLowerCase();
      h == "normal" || h == "italic" || h == "oblique" ? (i = l ? i : h, c.pop(), h = c[c.length - 1].toLowerCase()) : Ex.test(h) && (h = h.replace(Ex, ""), i = l ? i : c[c.length - 1].replace(h, ""));
      for (var p in yx) {
        var g = c.length > 1 ? c[c.length - 2].toLowerCase() : "";
        if (h == p || h == p.replace("-", "") || g + "-" + h == p) {
          r = o ? r : yx[p], c.pop(), g && p.startsWith(g) && c.pop();
          break;
        }
      }
      !o && typeof h == "number" && (r = h);
      var m = c.join(Bu).replace("Klokantech Noto Sans", "Noto Sans");
      m.indexOf(Bu) !== -1 && (m = '"' + m + '"'), a.push(m);
    }
    s = Cx[e] = [
      i,
      r,
      a
    ];
  }
  return s[0] + Bu + s[1] + Bu + t + "px" + (n ? "/" + n : "") + Bu + s[2];
};
function Np(e) {
  return e * Math.PI / 180;
}
var i3 = function() {
  for (var e = [], t = 78271.51696402048; e.length <= 24; t /= 2)
    e.push(t);
  return e;
}();
function KM(e, t) {
  if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas < "u")
    return new OffscreenCanvas(e, t);
  var n = document.createElement("canvas");
  return n.width = e, n.height = t, n;
}
function r3(e, t) {
  for (var n = 0, s = t.length; n < s; ++n) {
    var r = t[n];
    if (r < e && n + 1 < s) {
      var i = t[n] / t[n + 1];
      return n + Math.log(t[n] / e) / Math.log(i);
    }
  }
  return s - 1;
}
var s3 = Array(256).join(" ");
function av(e, t) {
  if (t >= 0.05) {
    for (var n = "", s = e.split(`
`), r = s3.slice(0, Math.round(t / 0.1)), i = 0, a = s.length; i < a; ++i)
      i > 0 && (n += `
`), n += s[i].split("").join(r);
    return n;
  }
  return e;
}
var Fp;
function GM() {
  return Fp || (Fp = KM(1, 1).getContext("2d")), Fp;
}
function co(e, t) {
  return GM().measureText(e).width + (e.length - 1) * t;
}
var bx = {};
function ov(e, t, n, s) {
  if (e.indexOf(`
`) !== -1) {
    for (var r = e.split(`
`), i = [], a = 0, o = r.length; a < o; ++a)
      i.push(ov(r[a], t, n, s));
    return i.join(`
`);
  }
  var l = n + "," + t + "," + e + "," + s, f = bx[l];
  if (!f) {
    var d = e.split(" ");
    if (d.length > 1) {
      var u = GM();
      u.font = t;
      for (var c = u.measureText("M").width, h = c * n, p = "", g = [], m = 0, v = d.length; m < v; ++m) {
        var y = d[m], E = p + (p ? " " : "") + y;
        co(E, s) <= h ? p = E : (p && g.push(p), p = y);
      }
      p && g.push(p);
      for (var C = 0, x = g.length; C < x && x > 1; ++C) {
        var b = g[C];
        if (co(b, s) < h * 0.35) {
          var P = C > 0 ? co(g[C - 1], s) : 1 / 0, T = C < x - 1 ? co(g[C + 1], s) : 1 / 0;
          g.splice(C, 1), x -= 1, P < T ? (g[C - 1] += " " + b, C -= 1) : g[C] = b + " " + g[C];
        }
      }
      for (var O = 0, S = g.length - 1; O < S; ++O) {
        var L = g[O], A = g[O + 1];
        if (co(L, s) > h * 0.7 && co(A, s) < h * 0.6) {
          var D = L.split(" "), _ = D.pop();
          co(_, s) < h * 0.2 && (g[O] = D.join(" "), g[O + 1] = _ + " " + A), S -= 1;
        }
      }
      f = g.join(`
`);
    } else
      f = e;
    f = av(f, s), bx[l] = f;
  }
  return f;
}
var a3 = {
  Point: 1,
  MultiPoint: 1,
  LineString: 2,
  MultiLineString: 2,
  Polygon: 3,
  MultiPolygon: 3
}, o3 = {
  center: [
    0.5,
    0.5
  ],
  left: [
    0,
    0.5
  ],
  right: [
    1,
    0.5
  ],
  top: [
    0.5,
    0
  ],
  bottom: [
    0.5,
    1
  ],
  "top-left": [
    0,
    0
  ],
  "top-right": [
    1,
    0
  ],
  "bottom-left": [
    0,
    1
  ],
  "bottom-right": [
    1,
    1
  ]
}, l3 = function(e, t) {
  var n = z$(e, t);
  if (n.result === "error")
    throw new Error(n.value.map(function(s) {
      return s.key + ": " + s.message;
    }).join(", "));
  return n.value;
}, lv = {}, Hd = { zoom: 0 }, Dh, jp;
function Qt(e, t, n, s, r, i, a) {
  var o = e.id;
  i || (i = {}, console.warn("No functionCache provided to getValue()")), i[o] || (i[o] = {});
  var l = i[o];
  if (!l[n]) {
    var f = (e[t] || lv)[n], d = jM[t + "_" + e.type][n];
    f === void 0 && (f = d.default);
    var u = $$(f);
    if (!u && FM(f) && (f = jW(f, d), u = !0), u) {
      var c = l3(f, d);
      l[n] = c.evaluate.bind(c);
    } else
      d.type == "color" && (f = Le.parse(f)), l[n] = function() {
        return f;
      };
  }
  return Hd.zoom = s, l[n](Hd, r, a);
}
function u3(e, t, n, s) {
  var r = Qt(e, "layout", "icon-allow-overlap", t, n, s);
  if (!r)
    return "declutter";
  var i = Qt(e, "layout", "icon-ignore-placement", t, n, s);
  return i ? "none" : "obstacle";
}
function c3(e, t, n, s, r) {
  return r || console.warn("No filterCache provided to evaluateFilter()"), e in r || (r[e] = H$(t).filter), Hd.zoom = s, r[e](Hd, n);
}
function ho(e, t) {
  if (e) {
    if (e.a === 0 || t === 0)
      return;
    var n = e.a;
    return t = t === void 0 ? 1 : t, n === 0 ? "transparent" : "rgba(" + Math.round(e.r * 255 / n) + "," + Math.round(e.g * 255 / n) + "," + Math.round(e.b * 255 / n) + "," + n * t + ")";
  }
  return e;
}
var h3 = /\{[^{}}]*\}/g;
function Up(e, t) {
  return e.replace(h3, function(n) {
    return t[n.slice(1, -1)] || "";
  });
}
function d3(e, t, n, s, r, i, a) {
  if (s === void 0 && (s = i3), r === void 0 && (r = void 0), i === void 0 && (i = void 0), a === void 0 && (a = void 0), typeof t == "string" && (t = JSON.parse(t)), t.version != 8)
    throw new Error("glStyle version 8 required.");
  var o, l;
  if (i) {
    if (typeof Image < "u") {
      var f = new Image();
      f.crossOrigin = "anonymous", f.onload = function() {
        o = f, l = [
          f.width,
          f.height
        ], e.changed(), f.onload = null;
      }, f.src = i;
    } else if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope) {
      var d = self;
      d.postMessage({
        action: "loadImage",
        src: i
      }), d.addEventListener("message", function(B) {
        B.data.action === "imageLoaded" && B.data.src === i && (o = B.data.image, l = [
          o.width,
          o.height
        ]);
      });
    }
  }
  for (var u = n3(t.layers), c = {}, h = [], p = {}, g = {}, m = {}, v = {}, y, E = 0, C = u.length; E < C; ++E) {
    var x = u[E], b = x.id;
    if (typeof n == "string" && x.source == n || n.indexOf(b) !== -1) {
      var P = x["source-layer"];
      if (y) {
        if (x.source !== y)
          throw new Error('Layer "' + b + '" does not use source "' + y);
      } else {
        y = x.source;
        var T = t.sources[y];
        if (!T)
          throw new Error('Source "' + y + '" is not defined');
        var O = T.type;
        if (O !== "vector" && O !== "geojson")
          throw new Error('Source "' + y + '" is not of type "vector" or "geojson", but "' + O + '"');
      }
      var S = c[P];
      S || (S = [], c[P] = S), S.push({
        layer: x,
        index: E
      }), h.push(b);
    }
  }
  var L = new pr(), A = new Lr(), D = [], _ = function(w, B) {
    var j = w.getProperties(), k = c[j.layer];
    if (k) {
      var X = s.indexOf(B);
      X == -1 && (X = r3(B, s));
      for (var rt = a3[w.getGeometry().getType()], et = {
        properties: j,
        type: rt
      }, Z = e.get("mapbox-featurestate")[w.getId()], dt = -1, vt = 0, bt = k.length; vt < bt; ++vt) {
        var it = k[vt], R = it.layer, V = R.id, tt = R.layout || lv, Y = R.paint || lv;
        if (!(tt.visibility === "none" || "minzoom" in R && X < R.minzoom || "maxzoom" in R && X >= R.maxzoom)) {
          var $ = R.filter;
          if (!$ || c3(V, $, et, X, v)) {
            var z = void 0, at = void 0, ct = void 0, St = void 0, F = void 0, M = void 0, I = it.index;
            if (rt == 3 && (R.type == "fill" || R.type == "fill-extrusion"))
              if (at = Qt(R, "paint", R.type + "-opacity", X, et, m, Z), R.type + "-pattern" in Y) {
                var N = Qt(R, "paint", R.type + "-pattern", X, et, m, Z);
                if (N) {
                  var G = typeof N == "string" ? Up(N, j) : N.toString();
                  if (o && r && r[G]) {
                    ++dt, M = D[dt], (!M || !M.getFill() || M.getStroke() || M.getText()) && (M = new zn({ fill: new Lr() }), D[dt] = M), ct = M.getFill(), M.setZIndex(I);
                    var nt = G + "." + at, lt = g[nt];
                    if (!lt) {
                      var yt = r[G], Lt = KM(yt.width, yt.height), Nt = Lt.getContext("2d");
                      Nt.globalAlpha = at, Nt.drawImage(o, yt.x, yt.y, yt.width, yt.height, 0, 0, yt.width, yt.height), lt = Nt.createPattern(Lt, "repeat"), g[nt] = lt;
                    }
                    ct.setColor(lt);
                  }
                }
              } else
                z = ho(Qt(R, "paint", R.type + "-color", X, et, m, Z), at), R.type + "-outline-color" in Y && (F = ho(Qt(R, "paint", R.type + "-outline-color", X, et, m, Z), at)), F || (F = z), (z || F) && (++dt, M = D[dt], (!M || z && !M.getFill() || !z && M.getFill() || F && !M.getStroke() || !F && M.getStroke() || M.getText()) && (M = new zn({
                  fill: z ? new Lr() : void 0,
                  stroke: F ? new pr() : void 0
                }), D[dt] = M), z && (ct = M.getFill(), ct.setColor(z)), F && (St = M.getStroke(), St.setColor(F), St.setWidth(0.5)), M.setZIndex(I));
            if (rt != 1 && R.type == "line") {
              z = !("line-pattern" in Y) && "line-color" in Y ? ho(Qt(R, "paint", "line-color", X, et, m, Z), Qt(R, "paint", "line-opacity", X, et, m, Z)) : void 0;
              var Jt = Qt(R, "paint", "line-width", X, et, m, Z);
              z && Jt > 0 && (++dt, M = D[dt], (!M || !M.getStroke() || M.getFill() || M.getText()) && (M = new zn({ stroke: new pr() }), D[dt] = M), St = M.getStroke(), St.setLineCap(Qt(R, "layout", "line-cap", X, et, m, Z)), St.setLineJoin(Qt(R, "layout", "line-join", X, et, m, Z)), St.setMiterLimit(Qt(R, "layout", "line-miter-limit", X, et, m, Z)), St.setColor(z), St.setWidth(Jt), St.setLineDash(Y["line-dasharray"] ? Qt(R, "paint", "line-dasharray", X, et, m, Z).map(function(Se) {
                return Se * Jt;
              }) : null), M.setZIndex(I));
            }
            var J = !1, ft = null, Ct = 0, Mt = void 0, Ot = void 0, kt = void 0;
            if ((rt == 1 || rt == 2) && "icon-image" in tt) {
              var de = Qt(R, "layout", "icon-image", X, et, m, Z);
              if (de) {
                Mt = typeof de == "string" ? Up(de, j) : de.toString();
                var Pe = void 0;
                if (o && r && r[Mt]) {
                  var Me = Qt(R, "layout", "icon-rotation-alignment", X, et, m, Z);
                  if (rt == 2) {
                    var Ce = w.getGeometry();
                    if (Ce.getFlatMidpoint || Ce.getFlatMidpoints) {
                      var $e = Ce.getExtent(), bn = Math.sqrt(Math.max(Math.pow(($e[2] - $e[0]) / B, 2), Math.pow(($e[3] - $e[1]) / B, 2)));
                      if (bn > 150) {
                        var Ye = Ce.getType() === "MultiLineString" ? Ce.getFlatMidpoints() : Ce.getFlatMidpoint();
                        jp || (Dh = [
                          NaN,
                          NaN
                        ], jp = new Qg("Point", Dh, [], {}, null)), Pe = jp, Dh[0] = Ye[0], Dh[1] = Ye[1];
                        var Hn = Qt(R, "layout", "symbol-placement", X, et, m, Z);
                        if (Hn === "line" && Me === "map")
                          for (var fn = Ce.getStride(), Fe = Ce.getFlatCoordinates(), pn = 0, mn = Fe.length - fn; pn < mn; pn += fn) {
                            var we = Fe[pn], gn = Fe[pn + 1], ze = Fe[pn + fn], On = Fe[pn + fn + 1], qe = Math.min(we, ze), se = Math.min(gn, On), mi = Math.max(we, ze), Xe = Math.max(gn, On);
                            if (Ye[0] >= qe && Ye[0] <= mi && Ye[1] >= se && Ye[1] <= Xe) {
                              Ct = Math.atan2(gn - On, ze - we);
                              break;
                            }
                          }
                      }
                    }
                  }
                  if (rt !== 2 || Pe) {
                    var sn = Qt(R, "layout", "icon-size", X, et, m, Z), Ue = Y["icon-color"] !== void 0 ? Qt(R, "paint", "icon-color", X, et, m, Z) : null;
                    if (!Ue || Ue.a !== 0) {
                      var wn = Mt + "." + sn;
                      if (Ue !== null && (wn += "." + Ue), Ot = p[wn], !Ot) {
                        var ii = r[Mt], oa = u3(R, X, et, m), Cs = void 0;
                        "icon-offset" in tt && (Cs = Qt(R, "layout", "icon-offset", X, et, m, Z), Cs[1] *= -1), Ot = new Ua({
                          color: Ue ? [
                            Ue.r * 255,
                            Ue.g * 255,
                            Ue.b * 255,
                            Ue.a
                          ] : void 0,
                          img: o,
                          imgSize: l,
                          size: [
                            ii.width,
                            ii.height
                          ],
                          offset: [
                            ii.x,
                            ii.y
                          ],
                          rotateWithView: Me === "map",
                          scale: sn / ii.pixelRatio,
                          displacement: Cs,
                          declutterMode: oa
                        }), p[wn] = Ot;
                      }
                    }
                    Ot && (++dt, M = D[dt], (!M || !M.getImage() || M.getFill() || M.getStroke()) && (M = new zn(), D[dt] = M), M.setGeometry(Pe), Ot.setRotation(Ct + Np(Qt(R, "layout", "icon-rotate", X, et, m, Z))), Ot.setOpacity(Qt(R, "paint", "icon-opacity", X, et, m, Z)), Ot.setAnchor(o3[Qt(R, "layout", "icon-anchor", X, et, m, Z)]), M.setImage(Ot), ft = M.getText(), M.setText(void 0), M.setZIndex(I), J = !0, kt = !1);
                  } else
                    kt = !0;
                }
              }
            }
            if (rt == 1 && R.type === "circle") {
              ++dt, M = D[dt], (!M || !M.getImage() || M.getFill() || M.getStroke()) && (M = new zn(), D[dt] = M);
              var xs = "circle-radius" in Y ? Qt(R, "paint", "circle-radius", X, et, m, Z) : 5, kr = ho(Qt(R, "paint", "circle-stroke-color", X, et, m, Z), Qt(R, "paint", "circle-stroke-opacity", X, et, m, Z)), Bn = ho(Qt(R, "paint", "circle-color", X, et, m, Z), Qt(R, "paint", "circle-opacity", X, et, m, Z)), gi = Qt(R, "paint", "circle-stroke-width", X, et, m, Z), Hr = xs + "." + kr + "." + Bn + "." + gi;
              Ot = p[Hr], Ot || (Ot = new _f({
                radius: xs,
                stroke: kr && gi > 0 ? new pr({
                  width: gi,
                  color: kr
                }) : void 0,
                fill: Bn ? new Lr({ color: Bn }) : void 0,
                declutterMode: "none"
              }), p[Hr] = Ot), M.setImage(Ot), ft = M.getText(), M.setText(void 0), M.setGeometry(void 0), M.setZIndex(I), J = !0;
            }
            var Ve = void 0, vi = void 0, yi = void 0, Ze = void 0, Gi = void 0, Or = void 0;
            if ("text-field" in tt) {
              Ze = Math.round(Qt(R, "layout", "text-size", X, et, m, Z));
              var bs = Qt(R, "layout", "text-font", X, et, m, Z);
              yi = Qt(R, "layout", "text-line-height", X, et, m, Z), vi = xx(a ? a(bs) : bs, Ze, yi), vi.includes("sans-serif") || (vi += ",sans-serif"), Gi = Qt(R, "layout", "text-letter-spacing", X, et, m, Z), Or = Qt(R, "layout", "text-max-width", X, et, m, Z);
              var Nn = Qt(R, "layout", "text-field", X, et, m, Z);
              typeof Nn == "object" && Nn.sections ? Nn.sections.length === 1 ? Ve = Nn.toString() : Ve = Nn.sections.reduce(function(Se, Zn, Os) {
                var Jr = Zn.fontStack ? Zn.fontStack.split(",") : bs, Qr = xx(a ? a(Jr) : Jr, Ze * (Zn.scale || 1), yi), Hi = Zn.text;
                if (Hi === `
`)
                  return Se.push(`
`, ""), Se;
                if (rt == 2) {
                  Se.push(av(Hi, Gi), Qr);
                  return;
                }
                Hi = ov(Hi, Qr, Or, Gi).split(`
`);
                for (var qr = 0, U = Hi.length; qr < U; ++qr)
                  qr > 0 && Se.push(`
`, ""), Se.push(Hi[qr], Qr);
                return Se;
              }, []) : Ve = Up(Nn, j).trim(), at = Qt(R, "paint", "text-opacity", X, et, m, Z);
            }
            if (Ve && at && !kt) {
              J || (++dt, M = D[dt], (!M || !M.getText() || M.getFill() || M.getStroke()) && (M = new zn(), D[dt] = M), M.setImage(void 0), M.setGeometry(void 0)), M.getText() || M.setText(ft || new xP({
                padding: [
                  2,
                  2,
                  2,
                  2
                ]
              })), ft = M.getText();
              var Tn = tt["text-transform"];
              Tn == "uppercase" ? Ve = Array.isArray(Ve) ? Ve.map(function(Se, Zn) {
                return Zn % 2 ? Se : Se.toUpperCase();
              }) : Ve.toUpperCase() : Tn == "lowercase" && (Ve = Array.isArray(Ve) ? Ve.map(function(Se, Zn) {
                return Zn % 2 ? Se : Se.toLowerCase();
              }) : Ve.toLowerCase());
              var ri = Array.isArray(Ve) ? Ve : rt == 2 ? av(Ve, Gi) : ov(Ve, vi, Or, Gi);
              ft.setText(ri), ft.setFont(vi), ft.setRotation(Np(Qt(R, "layout", "text-rotate", X, et, m, Z)));
              var Dn = Qt(R, "layout", "text-anchor", X, et, m, Z), Fn = J || rt == 1 ? "point" : Qt(R, "layout", "symbol-placement", X, et, m, Z);
              ft.setPlacement(Fn), ft.setOverflow(Fn === "point");
              var Je = Qt(R, "paint", "text-halo-width", X, et, m, Z), Yn = Qt(R, "layout", "text-offset", X, et, m, Z), si = Qt(R, "paint", "text-translate", X, et, m, Z), Tr = 0, Yr = 0;
              if (Fn == "point") {
                var sr = "center";
                Dn.indexOf("left") !== -1 ? (sr = "left", Yr = Je) : Dn.indexOf("right") !== -1 && (sr = "right", Yr = -Je), ft.setTextAlign(sr);
                var Xn = Qt(R, "layout", "text-rotation-alignment", X, et, m, Z);
                ft.setRotateWithView(Xn == "map");
              } else
                ft.setMaxAngle(Np(Qt(R, "layout", "text-max-angle", X, et, m, Z)) * Ve.length / ri.length), ft.setTextAlign(), ft.setRotateWithView(!1);
              var Ei = "middle";
              Dn.indexOf("bottom") == 0 ? (Ei = "bottom", Tr = -Je - 0.5 * (yi - 1) * Ze) : Dn.indexOf("top") == 0 && (Ei = "top", Tr = Je + 0.5 * (yi - 1) * Ze), ft.setTextBaseline(Ei);
              var Xr = Qt(R, "layout", "text-justify", X, et, m, Z);
              ft.setJustify(Xr === "auto" ? void 0 : Xr), ft.setOffsetX(Yn[0] * Ze + Yr + si[0]), ft.setOffsetY(Yn[1] * Ze + Tr + si[1]), A.setColor(ho(Qt(R, "paint", "text-color", X, et, m, Z), at)), ft.setFill(A);
              var Zr = ho(Qt(R, "paint", "text-halo-color", X, et, m, Z), at);
              if (Zr) {
                L.setColor(Zr), Je *= 2;
                var Pr = 0.5 * Ze;
                L.setWidth(Je <= Pr ? Je : Pr), ft.setStroke(L);
              } else
                ft.setStroke(void 0);
              var ki = Qt(R, "layout", "text-padding", X, et, m, Z), Di = ft.getPadding();
              ki !== Di[0] && (Di[0] = ki, Di[1] = ki, Di[2] = ki, Di[3] = ki), M.setZIndex(I);
            }
          }
        }
      }
      if (dt > -1)
        return D.length = dt + 1, D;
    }
  };
  return e.setStyle(_), e.set("mapbox-source", y), e.set("mapbox-layers", h), e.set("mapbox-featurestate", {}), _;
}
new Qs();
const f3 = "EPSG:3857";
function kM(e = {}) {
  const t = e.epsg ? e.epsg : fi.epsg, n = e.extent ? e.extent : wf(t), s = e.tileSize ? e.tileSize : 512, r = e.resolutions ? e.resolutions : fi.options.map((a) => a.resolution), i = {
    extent: n,
    resolutions: r,
    minZoom: e.minZoom,
    tileSize: new Array(2).fill(s)
  };
  return e.origins ? i.origins = e.origins : i.origin = e.origin ? e.origin : [i.extent[0], i.extent[3]], new du(i);
}
function p3(e = {}) {
  const t = [e.extent, e.tileSize, e.resolutions, e.origin, e.origins, e.minZoom], n = e.epsg ? e.epsg.toUpperCase() : e.epsg;
  return !t.every((s) => typeof s > "u") || n !== f3;
}
function HM(e, t = {}) {
  t.epsg = t.epsg ? t.epsg : fi.epsg;
  const n = {
    projection: t.epsg,
    format: new rM(),
    url: e,
    tileSize: t.tileSize,
    zDirection: t.zDirection,
    minZoom: t.minZoom,
    maxZoom: t.maxZoom
  };
  return p3(t) && (n.tileGrid = kM(t)), new OM(n);
}
function m3(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  if ([e.id, e.name, e.url].some((i) => typeof i > "u")) {
    console.error(`Cancelled creation of layer "${e.id}"(${e.name}) because of missing required parameters`);
    return;
  }
  const s = HM(e.url, e), r = new p0(Object.assign({
    id: e.id,
    name: e.name,
    attribution: e.olAttribution,
    extent: s.getTileGrid().getExtent(),
    minZoom: e.minZoom,
    maxZoom: e.maxZoom,
    source: s,
    declutter: !0
  }, t));
  return n.style && r.setStyle(n.style), r;
}
function g3(e, t, { options: n = {} } = {}) {
  d3(
    e,
    t,
    n.sourceId ? n.sourceId : Object.keys(t.sources)[0],
    n.resolutions,
    n.spriteData,
    n.spriteImageUrl,
    n.getFonts
  );
}
const YM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: m3,
  createLayerSource: HM,
  createTileGrid: kM,
  setStyle: g3
}, Symbol.toStringTag, { value: "Module" }));
function v3(e) {
  if (!e || typeof e != "object" || e.constructor !== Object || !Object.keys(e).length)
    return "";
  let t = "";
  return Object.entries(e).forEach(([n, s]) => {
    t += "&" + n + "=" + s;
  }), t;
}
function y3(e, t, n, s) {
  return e.ok ? e : t(`Request to wfs-filter failed. Response status is ${e.statusText}`, n, s);
}
function E3(e) {
  if (typeof e != "object" || e === null || !Array.isArray(e.links))
    return !1;
  for (let t = 0; t < e.links.length; t++)
    if (typeof e.links[t] == "object" && e.links[t] !== null && typeof e.links[t].href == "string" && e.links[t].rel === "next" && e.links[t].type === "application/geo+json")
      return e.links[t].href;
  return !1;
}
function XM(e, t, { onErrorFn: n, success: s, failure: r }, i, a = []) {
  fetch(e, {
    headers: {
      Accept: "application/geo+json"
    },
    method: "GET"
  }).then((l) => y3(l, n, i, r)).then((l) => l.json()).then((l) => {
    const f = E3(l);
    if (l.features.forEach((d) => a.push(d)), typeof f == "string") {
      XM(f, t, { onErrorFn: ec, success: s, failure: r }, i, a);
      return;
    }
    l.features = a, l.numberReturned = l.numberMatched, d0(t, t.getFormat().readFeatures(l), n, s, r, i);
  }).catch((l) => {
    n(l, i, r);
  });
}
function C3(e, t, n) {
  const s = new Qs();
  let r = null;
  function i(a, o, l, f, d) {
    XM(n, r, { onErrorFn: ec, success: f, failure: d }, t);
  }
  return r = c0(i, t.loadingStrategy, s), t.beforeLoading && r.once("featuresloadstart", () => t.beforeLoading()), e.clusterDistance ? h0(r, e.clusterDistance, t.clusterGeometryFunction) : r;
}
function x3(e) {
  let t = e.url, n;
  const s = "";
  return t += typeof e.collection == "string" ? "/collections/" + e.collection + "/items?" : "", t += typeof e.limit == "number" ? "limit=" + e.limit + "&" : "", Array.isArray(e.bbox) && e.bbox.length === 4 && (n = "", e.bbox.forEach((r, i) => {
    n += i !== e.bbox.length - 1 ? r + "," : r;
  }), t += "bbox=" + n + "&"), t += typeof e.bboxCrs == "string" && e.bboxCrs !== "" ? "bbox-crs=" + encodeURIComponent(e.bboxCrs) + "&" : "", e.crs !== !1 && (t += "crs=" + encodeURIComponent(typeof e.crs == "string" && e.crs !== "" ? e.crs : s) + "&"), t += typeof e.datetime == "string" && e.datetime !== "" ? "datetime=" + e.datetime + "&" : "", t += v3(e.params), t;
}
function ZM(e, t = {}) {
  t.loadingStrategy || (t.loadingStrategy = wg);
  const n = x3(e);
  return C3(e, t, n);
}
function b3(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = ZM(e, n), r = new vr(Object.assign({
    source: s,
    id: e.id
  }, t));
  return n.style ? r.setStyle(n.style) : e.style && r.setStyle(e.style), r;
}
const JM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: b3,
  createLayerSource: ZM
}, Symbol.toStringTag, { value: "Module" }));
function O3(e) {
  const t = {};
  return e.cesiumTerrainProviderOptions && Object.assign(t, e.cesiumTerrainProviderOptions), t.url = e.url, new Cesium.CesiumTerrainProvider(t);
}
function T3(e, t, n) {
  n && typeof n.getCesiumScene == "function" && (e ? n.getCesiumScene().terrainProvider = O3(t) : n.getCesiumScene().terrainProvider = new Cesium.EllipsoidTerrainProvider({}));
}
function P3(e) {
  return this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, this;
}
function M3(e) {
  if (this.values)
    return this.values[e];
}
const S3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: P3,
  get: M3,
  setVisible: T3
}, Symbol.toStringTag, { value: "Module" }));
function I3(e, t, n) {
  if (n && typeof n.getDataSources == "function") {
    const s = n.getDataSources(), r = s.getByName(t == null ? void 0 : t.id);
    r.length === 0 ? console.warn("Cannot change visibility of 3D entity for layer with id ", t.id, ". Datasource is not available.") : r[0].show = typeof e == "boolean" ? e : !1;
  }
}
function _3(e, t, n) {
  if (typeof e.url != "string")
    return console.warn("Url of entity must be a string, but is:", e.url), null;
  if (![e.longitude, e.latitude, e.height].every((p) => typeof p == "number"))
    return console.warn("longitude, latitude and height of entity must be a number."), null;
  const s = Cesium.Cartesian3.fromDegrees(e.longitude, e.latitude, e.height), r = typeof e.allowPicking == "boolean" ? e.allowPicking : !0, i = e.attributes ? e.attributes : {};
  let a = "", o = "", l = "", f = null, d = "", u = 0, c = 0, h = 0;
  return typeof e.heading == "number" && (u = e.heading / 180 * Math.PI), typeof e.pitch == "number" && (c = e.pitch / 180 * Math.PI), typeof e.roll == "number" && (h = e.roll / 180 * Math.PI), a = new Cesium.HeadingPitchRoll(u, c, h), o = Cesium.Transforms.headingPitchRollQuaternion(s, a), l = Object.assign(e.modelOptions || {}, {
    uri: e.url,
    scale: typeof e.scale == "number" ? e.scale : 1,
    show: typeof e.show == "boolean" ? e.show : !1
  }), f = {
    name: e.url,
    position: s,
    orientation: o,
    show: typeof e.show == "boolean" ? e.show : !1,
    model: l
  }, d = t.entities.add(f), d.attributes = i, d.allowPicking = r, d.layerReferenceId = n.id, d;
}
function Ox(e, t) {
  e.entities && e.entities.forEach((n) => {
    _3(n, Array.isArray(t) ? t[0] : t, e);
  });
}
function QM(e, t, n) {
  if (!e)
    console.warn("Cannot add entities to rawLayer which is null!");
  else if (t && typeof t.getDataSources == "function") {
    const s = t.getDataSources();
    let r = s.getByName(e.id);
    if (r.length === 0)
      r = new Cesium.CustomDataSource(e.id), s.add(r).then(function(i) {
        return Ox(e, i), n ? n() : null;
      });
    else if (Ox(e, r), n)
      return n();
  }
  return null;
}
function D3(e, t) {
  return QM(e, t), this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, this;
}
function A3(e) {
  if (this.values)
    return this.values[e];
}
const L3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDataSource: QM,
  createLayer: D3,
  get: A3,
  setVisible: I3
}, Symbol.toStringTag, { value: "Module" }));
function R3(e) {
  const t = e.url.split("?")[0] + "/tileset.json", n = {};
  return e.cesium3DTilesetOptions && Object.assign(n, e.cesium3DTilesetOptions), n.url = t, new Cesium.Cesium3DTileset(n);
}
function M0(e) {
  this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, Cesium && (this.tileset = R3(e), this.tileset.layerReferenceId = e.id);
}
M0.prototype.setVisible = function(e, t) {
  t && typeof t.getCesiumScene == "function" && (e ? (t.getCesiumScene().primitives.contains(this.tileset) || t.getCesiumScene().primitives.add(this.tileset), this.tileset.show = !0) : this.tileset.show = !1);
};
M0.prototype.get = function(e) {
  if (this.values)
    return this.values[e];
};
function w3(e, { resolution: t, map: n }) {
  const s = typeof t > "u" ? n.getView().getResolution() : t;
  return e.getMaxResolution() >= s && s >= e.getMinResolution();
}
function V3({ legendURL: e, layers: t = "", url: n, typ: s, format: r, version: i }) {
  return e ? e === "ignore" ? [] : [e] : t.split(",").filter(
    (a) => a
    /* filters empty string since it's falsy */
  ).map((a) => `${n}?SERVICE=${s}&REQUEST=GetLegendGraphic&FORMAT=${r || "image/png"}&VERSION=${i}&LAYER=${a}`);
}
const B3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getLegendURLs: V3,
  isLayerVisibleInResolution: w3
}, Symbol.toStringTag, { value: "Module" }));
function N3(e) {
  const t = e.map(parseFloat), n = [];
  for (; t.length; )
    n.push(t.splice(0, 2));
  return n;
}
function F3(e, t, n = {}) {
  e.getView().fit(t, n);
}
function j3(e, t, n = {}) {
  let s;
  switch (t.geometry.type) {
    case "Polygon":
      s = new nr([N3(t.geometry.coordinates)]);
      break;
    case "Point":
      s = new hi(t.geometry.coordinates.map(parseFloat));
      break;
    default:
      console.warn(`ZoomTo for type ${t.geometry.type} not implemented.`);
      return;
  }
  F3(e, s, n);
}
var ss = {}, Wp = {}, Tx;
function S0() {
  return Tx || (Tx = 1, (function() {
    Wp.defaults = {
      "0.1": {
        explicitCharkey: !1,
        trim: !0,
        normalize: !0,
        normalizeTags: !1,
        attrkey: "@",
        charkey: "#",
        explicitArray: !1,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !1,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        childkey: "@@",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: !1,
        trim: !1,
        normalize: !1,
        normalizeTags: !1,
        attrkey: "$",
        charkey: "_",
        explicitArray: !0,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !0,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        preserveChildrenOrder: !1,
        childkey: "$$",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: !0
        },
        doctype: null,
        renderOpts: {
          pretty: !0,
          indent: "  ",
          newline: `
`
        },
        headless: !1,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: !1
      }
    };
  }).call(_t)), Wp;
}
var $p = {}, Ds = {}, As = {}, Px;
function sa() {
  return Px || (Px = 1, (function() {
    var e, t, n, s, r, i, a, o = [].slice, l = {}.hasOwnProperty;
    e = function() {
      var f, d, u, c, h, p;
      if (p = arguments[0], h = 2 <= arguments.length ? o.call(arguments, 1) : [], r(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (f = 0, u = h.length; f < u; f++)
          if (c = h[f], c != null)
            for (d in c)
              l.call(c, d) && (p[d] = c[d]);
      return p;
    }, r = function(f) {
      return !!f && Object.prototype.toString.call(f) === "[object Function]";
    }, i = function(f) {
      var d;
      return !!f && ((d = typeof f) == "function" || d === "object");
    }, n = function(f) {
      return r(Array.isArray) ? Array.isArray(f) : Object.prototype.toString.call(f) === "[object Array]";
    }, s = function(f) {
      var d;
      if (n(f))
        return !f.length;
      for (d in f)
        if (l.call(f, d))
          return !1;
      return !0;
    }, a = function(f) {
      var d, u;
      return i(f) && (u = Object.getPrototypeOf(f)) && (d = u.constructor) && typeof d == "function" && d instanceof d && Function.prototype.toString.call(d) === Function.prototype.toString.call(Object);
    }, t = function(f) {
      return r(f.valueOf) ? f.valueOf() : f;
    }, As.assign = e, As.isFunction = r, As.isObject = i, As.isArray = n, As.isEmpty = s, As.isPlainObject = a, As.getValue = t;
  }).call(_t)), As;
}
var zp = { exports: {} }, Mx;
function qM() {
  return Mx || (Mx = 1, (function() {
    zp.exports = function() {
      function e() {
      }
      return e.prototype.hasFeature = function(t, n) {
        return !0;
      }, e.prototype.createDocumentType = function(t, n, s) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.createDocument = function(t, n, s) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.createHTMLDocument = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.getFeature = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e;
    }();
  }).call(_t)), zp.exports;
}
var Kp = { exports: {} }, Gp = { exports: {} }, kp = { exports: {} }, Sx;
function U3() {
  return Sx || (Sx = 1, (function() {
    kp.exports = function() {
      function e() {
      }
      return e.prototype.handleError = function(t) {
        throw new Error(t);
      }, e;
    }();
  }).call(_t)), kp.exports;
}
var Hp = { exports: {} }, Ix;
function W3() {
  return Ix || (Ix = 1, (function() {
    Hp.exports = function() {
      function e(t) {
        this.arr = t || [];
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      }), e.prototype.item = function(t) {
        return this.arr[t] || null;
      }, e.prototype.contains = function(t) {
        return this.arr.indexOf(t) !== -1;
      }, e;
    }();
  }).call(_t)), Hp.exports;
}
var _x;
function $3() {
  return _x || (_x = 1, (function() {
    var e, t;
    e = U3(), t = W3(), Gp.exports = function() {
      function n() {
        this.defaultParams = {
          "canonical-form": !1,
          "cdata-sections": !1,
          comments: !1,
          "datatype-normalization": !1,
          "element-content-whitespace": !0,
          entities: !0,
          "error-handler": new e(),
          infoset: !0,
          "validate-if-schema": !1,
          namespaces: !0,
          "namespace-declarations": !0,
          "normalize-characters": !1,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": !0,
          validate: !1,
          "well-formed": !0
        }, this.params = Object.create(this.defaultParams);
      }
      return Object.defineProperty(n.prototype, "parameterNames", {
        get: function() {
          return new t(Object.keys(this.defaultParams));
        }
      }), n.prototype.getParameter = function(s) {
        return this.params.hasOwnProperty(s) ? this.params[s] : null;
      }, n.prototype.canSetParameter = function(s, r) {
        return !0;
      }, n.prototype.setParameter = function(s, r) {
        return r != null ? this.params[s] = r : delete this.params[s];
      }, n;
    }();
  }).call(_t)), Gp.exports;
}
var Yp = { exports: {} }, Xp = { exports: {} }, Zp = { exports: {} }, Dx;
function Rn() {
  return Dx || (Dx = 1, (function() {
    Zp.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(_t)), Zp.exports;
}
var Jp = { exports: {} }, Ax;
function tS() {
  return Ax || (Ax = 1, (function() {
    var e;
    e = Rn(), Cr(), Jp.exports = function() {
      function t(n, s, r) {
        if (this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), s == null)
          throw new Error("Missing attribute name. " + this.debugInfo(s));
        this.name = this.stringify.name(s), this.value = this.stringify.attValue(r), this.type = e.Attribute, this.isId = !1, this.schemaTypeInfo = null;
      }
      return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(t.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(t.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(n) {
          return this.value = n || "";
        }
      }), Object.defineProperty(t.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(t.prototype, "specified", {
        get: function() {
          return !0;
        }
      }), t.prototype.clone = function() {
        return Object.create(this);
      }, t.prototype.toString = function(n) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(n));
      }, t.prototype.debugInfo = function(n) {
        return n = n || this.name, n == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + n + "}, parent: <" + this.parent.name + ">";
      }, t.prototype.isEqualNode = function(n) {
        return !(n.namespaceURI !== this.namespaceURI || n.prefix !== this.prefix || n.localName !== this.localName || n.value !== this.value);
      }, t;
    }();
  }).call(_t)), Jp.exports;
}
var Qp = { exports: {} }, Lx;
function I0() {
  return Lx || (Lx = 1, (function() {
    Qp.exports = function() {
      function e(t) {
        this.nodes = t;
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      }), e.prototype.clone = function() {
        return this.nodes = null;
      }, e.prototype.getNamedItem = function(t) {
        return this.nodes[t];
      }, e.prototype.setNamedItem = function(t) {
        var n;
        return n = this.nodes[t.nodeName], this.nodes[t.nodeName] = t, n || null;
      }, e.prototype.removeNamedItem = function(t) {
        var n;
        return n = this.nodes[t], delete this.nodes[t], n || null;
      }, e.prototype.item = function(t) {
        return this.nodes[Object.keys(this.nodes)[t]] || null;
      }, e.prototype.getNamedItemNS = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.setNamedItemNS = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.removeNamedItemNS = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e;
    }();
  }).call(_t)), Qp.exports;
}
var Rx;
function _0() {
  return Rx || (Rx = 1, (function() {
    var e, t, n, s, r, i, a, o, l = function(d, u) {
      for (var c in u)
        f.call(u, c) && (d[c] = u[c]);
      function h() {
        this.constructor = d;
      }
      return h.prototype = u.prototype, d.prototype = new h(), d.__super__ = u.prototype, d;
    }, f = {}.hasOwnProperty;
    o = sa(), a = o.isObject, i = o.isFunction, r = o.getValue, s = Cr(), e = Rn(), t = tS(), n = I0(), Xp.exports = function(d) {
      l(u, d);
      function u(c, h, p) {
        var g, m, v, y;
        if (u.__super__.constructor.call(this, c), h == null)
          throw new Error("Missing element name. " + this.debugInfo());
        if (this.name = this.stringify.name(h), this.type = e.Element, this.attribs = {}, this.schemaTypeInfo = null, p != null && this.attribute(p), c.type === e.Document && (this.isRoot = !0, this.documentObject = c, c.rootObject = this, c.children)) {
          for (y = c.children, m = 0, v = y.length; m < v; m++)
            if (g = y[m], g.type === e.DocType) {
              g.name = this.name;
              break;
            }
        }
      }
      return Object.defineProperty(u.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(u.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(u.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(u.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(u.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "attributes", {
        get: function() {
          return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new n(this.attribs)), this.attributeMap;
        }
      }), u.prototype.clone = function() {
        var c, h, p, g;
        p = Object.create(this), p.isRoot && (p.documentObject = null), p.attribs = {}, g = this.attribs;
        for (h in g)
          f.call(g, h) && (c = g[h], p.attribs[h] = c.clone());
        return p.children = [], this.children.forEach(function(m) {
          var v;
          return v = m.clone(), v.parent = p, p.children.push(v);
        }), p;
      }, u.prototype.attribute = function(c, h) {
        var p, g;
        if (c != null && (c = r(c)), a(c))
          for (p in c)
            f.call(c, p) && (g = c[p], this.attribute(p, g));
        else
          i(h) && (h = h.apply()), this.options.keepNullAttributes && h == null ? this.attribs[c] = new t(this, c, "") : h != null && (this.attribs[c] = new t(this, c, h));
        return this;
      }, u.prototype.removeAttribute = function(c) {
        var h, p, g;
        if (c == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (c = r(c), Array.isArray(c))
          for (p = 0, g = c.length; p < g; p++)
            h = c[p], delete this.attribs[h];
        else
          delete this.attribs[c];
        return this;
      }, u.prototype.toString = function(c) {
        return this.options.writer.element(this, this.options.writer.filterOptions(c));
      }, u.prototype.att = function(c, h) {
        return this.attribute(c, h);
      }, u.prototype.a = function(c, h) {
        return this.attribute(c, h);
      }, u.prototype.getAttribute = function(c) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c].value : null;
      }, u.prototype.setAttribute = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNode = function(c) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c] : null;
      }, u.prototype.setAttributeNode = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.removeAttributeNode = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setAttributeNS = function(c, h, p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.removeAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNodeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setAttributeNodeNS = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagNameNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.hasAttribute = function(c) {
        return this.attribs.hasOwnProperty(c);
      }, u.prototype.hasAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setIdAttribute = function(c, h) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c].isId : h;
      }, u.prototype.setIdAttributeNS = function(c, h, p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setIdAttributeNode = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagNameNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByClassName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.isEqualNode = function(c) {
        var h, p, g;
        if (!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(c) || c.namespaceURI !== this.namespaceURI || c.prefix !== this.prefix || c.localName !== this.localName || c.attribs.length !== this.attribs.length)
          return !1;
        for (h = p = 0, g = this.attribs.length - 1; 0 <= g ? p <= g : p >= g; h = 0 <= g ? ++p : --p)
          if (!this.attribs[h].isEqualNode(c.attribs[h]))
            return !1;
        return !0;
      }, u;
    }(s);
  }).call(_t)), Xp.exports;
}
var qp = { exports: {} }, tm = { exports: {} }, wx;
function kf() {
  return wx || (wx = 1, (function() {
    var e, t = function(s, r) {
      for (var i in r)
        n.call(r, i) && (s[i] = r[i]);
      function a() {
        this.constructor = s;
      }
      return a.prototype = r.prototype, s.prototype = new a(), s.__super__ = r.prototype, s;
    }, n = {}.hasOwnProperty;
    e = Cr(), tm.exports = function(s) {
      t(r, s);
      function r(i) {
        r.__super__.constructor.call(this, i), this.value = "";
      }
      return Object.defineProperty(r.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), Object.defineProperty(r.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      }), Object.defineProperty(r.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.substringData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.appendData = function(i) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.insertData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.deleteData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.replaceData = function(i, a, o) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.isEqualNode = function(i) {
        return !(!r.__super__.isEqualNode.apply(this, arguments).isEqualNode(i) || i.data !== this.data);
      }, r;
    }(e);
  }).call(_t)), tm.exports;
}
var Vx;
function D0() {
  return Vx || (Vx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = Rn(), t = kf(), qp.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.name = "#cdata-section", this.type = e.CData, this.value = this.stringify.cdata(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), qp.exports;
}
var em = { exports: {} }, Bx;
function A0() {
  return Bx || (Bx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = Rn(), t = kf(), em.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.name = "#comment", this.type = e.Comment, this.value = this.stringify.comment(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), em.exports;
}
var nm = { exports: {} }, Nx;
function L0() {
  return Nx || (Nx = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    n = sa().isObject, t = Cr(), e = Rn(), nm.exports = function(i) {
      s(a, i);
      function a(o, l, f, d) {
        var u;
        a.__super__.constructor.call(this, o), n(l) && (u = l, l = u.version, f = u.encoding, d = u.standalone), l || (l = "1.0"), this.type = e.Declaration, this.version = this.stringify.xmlVersion(l), f != null && (this.encoding = this.stringify.xmlEncoding(f)), d != null && (this.standalone = this.stringify.xmlStandalone(d));
      }
      return a.prototype.toString = function(o) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(o));
      }, a;
    }(t);
  }).call(_t)), nm.exports;
}
var im = { exports: {} }, rm = { exports: {} }, Fx;
function R0() {
  return Fx || (Fx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = Cr(), e = Rn(), rm.exports = function(r) {
      n(i, r);
      function i(a, o, l, f, d, u) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (l == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(o));
        if (!f)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(o));
        if (!d)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(o));
        if (d.indexOf("#") !== 0 && (d = "#" + d), !d.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(o));
        if (u && !d.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(o));
        this.elementName = this.stringify.name(o), this.type = e.AttributeDeclaration, this.attributeName = this.stringify.name(l), this.attributeType = this.stringify.dtdAttType(f), u && (this.defaultValue = this.stringify.dtdAttDefault(u)), this.defaultValueType = d;
      }
      return i.prototype.toString = function(a) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), rm.exports;
}
var sm = { exports: {} }, jx;
function w0() {
  return jx || (jx = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    n = sa().isObject, t = Cr(), e = Rn(), sm.exports = function(i) {
      s(a, i);
      function a(o, l, f, d) {
        if (a.__super__.constructor.call(this, o), f == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(f));
        if (d == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(f));
        if (this.pe = !!l, this.name = this.stringify.name(f), this.type = e.EntityDeclaration, !n(d))
          this.value = this.stringify.dtdEntityValue(d), this.internal = !0;
        else {
          if (!d.pubID && !d.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(f));
          if (d.pubID && !d.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(f));
          if (this.internal = !1, d.pubID != null && (this.pubID = this.stringify.dtdPubID(d.pubID)), d.sysID != null && (this.sysID = this.stringify.dtdSysID(d.sysID)), d.nData != null && (this.nData = this.stringify.dtdNData(d.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(f));
        }
      }
      return Object.defineProperty(a.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(a.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(a.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      }), Object.defineProperty(a.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(a.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(a.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      }), a.prototype.toString = function(o) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(o));
      }, a;
    }(t);
  }).call(_t)), sm.exports;
}
var am = { exports: {} }, Ux;
function V0() {
  return Ux || (Ux = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = Cr(), e = Rn(), am.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        l || (l = "(#PCDATA)"), Array.isArray(l) && (l = "(" + l.join(",") + ")"), this.name = this.stringify.name(o), this.type = e.ElementDeclaration, this.value = this.stringify.dtdElementValue(l);
      }
      return i.prototype.toString = function(a) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), am.exports;
}
var om = { exports: {} }, Wx;
function B0() {
  return Wx || (Wx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = Cr(), e = Rn(), om.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(o));
        if (!l.pubID && !l.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(o));
        this.name = this.stringify.name(o), this.type = e.NotationDeclaration, l.pubID != null && (this.pubID = this.stringify.dtdPubID(l.pubID)), l.sysID != null && (this.sysID = this.stringify.dtdSysID(l.sysID));
      }
      return Object.defineProperty(i.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(i.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), i.prototype.toString = function(a) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), om.exports;
}
var $x;
function N0() {
  return $x || ($x = 1, (function() {
    var e, t, n, s, r, i, a, o, l = function(d, u) {
      for (var c in u)
        f.call(u, c) && (d[c] = u[c]);
      function h() {
        this.constructor = d;
      }
      return h.prototype = u.prototype, d.prototype = new h(), d.__super__ = u.prototype, d;
    }, f = {}.hasOwnProperty;
    o = sa().isObject, a = Cr(), e = Rn(), t = R0(), s = w0(), n = V0(), r = B0(), i = I0(), im.exports = function(d) {
      l(u, d);
      function u(c, h, p) {
        var g, m, v, y, E, C;
        if (u.__super__.constructor.call(this, c), this.type = e.DocType, c.children) {
          for (y = c.children, m = 0, v = y.length; m < v; m++)
            if (g = y[m], g.type === e.Element) {
              this.name = g.name;
              break;
            }
        }
        this.documentObject = c, o(h) && (E = h, h = E.pubID, p = E.sysID), p == null && (C = [h, p], p = C[0], h = C[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), p != null && (this.sysID = this.stringify.dtdSysID(p));
      }
      return Object.defineProperty(u.prototype, "entities", {
        get: function() {
          var c, h, p, g, m;
          for (g = {}, m = this.children, h = 0, p = m.length; h < p; h++)
            c = m[h], c.type === e.EntityDeclaration && !c.pe && (g[c.name] = c);
          return new i(g);
        }
      }), Object.defineProperty(u.prototype, "notations", {
        get: function() {
          var c, h, p, g, m;
          for (g = {}, m = this.children, h = 0, p = m.length; h < p; h++)
            c = m[h], c.type === e.NotationDeclaration && (g[c.name] = c);
          return new i(g);
        }
      }), Object.defineProperty(u.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(u.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(u.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), u.prototype.element = function(c, h) {
        var p;
        return p = new n(this, c, h), this.children.push(p), this;
      }, u.prototype.attList = function(c, h, p, g, m) {
        var v;
        return v = new t(this, c, h, p, g, m), this.children.push(v), this;
      }, u.prototype.entity = function(c, h) {
        var p;
        return p = new s(this, !1, c, h), this.children.push(p), this;
      }, u.prototype.pEntity = function(c, h) {
        var p;
        return p = new s(this, !0, c, h), this.children.push(p), this;
      }, u.prototype.notation = function(c, h) {
        var p;
        return p = new r(this, c, h), this.children.push(p), this;
      }, u.prototype.toString = function(c) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(c));
      }, u.prototype.ele = function(c, h) {
        return this.element(c, h);
      }, u.prototype.att = function(c, h, p, g, m) {
        return this.attList(c, h, p, g, m);
      }, u.prototype.ent = function(c, h) {
        return this.entity(c, h);
      }, u.prototype.pent = function(c, h) {
        return this.pEntity(c, h);
      }, u.prototype.not = function(c, h) {
        return this.notation(c, h);
      }, u.prototype.up = function() {
        return this.root() || this.documentObject;
      }, u.prototype.isEqualNode = function(c) {
        return !(!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(c) || c.name !== this.name || c.publicId !== this.publicId || c.systemId !== this.systemId);
      }, u;
    }(a);
  }).call(_t)), im.exports;
}
var lm = { exports: {} }, zx;
function F0() {
  return zx || (zx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = Rn(), t = Cr(), lm.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.type = e.Raw, this.value = this.stringify.raw(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(_t)), lm.exports;
}
var um = { exports: {} }, Kx;
function j0() {
  return Kx || (Kx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = Rn(), t = kf(), um.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.name = "#text", this.type = e.Text, this.value = this.stringify.text(o);
      }
      return Object.defineProperty(i.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(i.prototype, "wholeText", {
        get: function() {
          var a, o, l;
          for (l = "", o = this.previousSibling; o; )
            l = o.data + l, o = o.previousSibling;
          for (l += this.data, a = this.nextSibling; a; )
            l = l + a.data, a = a.nextSibling;
          return l;
        }
      }), i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.text(this, this.options.writer.filterOptions(a));
      }, i.prototype.splitText = function(a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i.prototype.replaceWholeText = function(a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i;
    }(t);
  }).call(_t)), um.exports;
}
var cm = { exports: {} }, Gx;
function U0() {
  return Gx || (Gx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = Rn(), t = kf(), cm.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.type = e.ProcessingInstruction, this.target = this.stringify.insTarget(o), this.name = this.target, l && (this.value = this.stringify.insValue(l));
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(a));
      }, i.prototype.isEqualNode = function(a) {
        return !(!i.__super__.isEqualNode.apply(this, arguments).isEqualNode(a) || a.target !== this.target);
      }, i;
    }(t);
  }).call(_t)), cm.exports;
}
var hm = { exports: {} }, kx;
function eS() {
  return kx || (kx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = Cr(), e = Rn(), hm.exports = function(r) {
      n(i, r);
      function i(a) {
        i.__super__.constructor.call(this, a), this.type = e.Dummy;
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return "";
      }, i;
    }(t);
  }).call(_t)), hm.exports;
}
var dm = { exports: {} }, Hx;
function z3() {
  return Hx || (Hx = 1, (function() {
    dm.exports = function() {
      function e(t) {
        this.nodes = t;
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      }), e.prototype.clone = function() {
        return this.nodes = null;
      }, e.prototype.item = function(t) {
        return this.nodes[t] || null;
      }, e;
    }();
  }).call(_t)), dm.exports;
}
var fm = { exports: {} }, Yx;
function K3() {
  return Yx || (Yx = 1, (function() {
    fm.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(_t)), fm.exports;
}
var Xx;
function Cr() {
  return Xx || (Xx = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v = {}.hasOwnProperty;
    m = sa(), g = m.isObject, p = m.isFunction, h = m.isEmpty, c = m.getValue, o = null, n = null, s = null, r = null, i = null, d = null, u = null, f = null, a = null, t = null, l = null, e = null, Yp.exports = function() {
      function y(E) {
        this.parent = E, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, o || (o = _0(), n = D0(), s = A0(), r = L0(), i = N0(), d = F0(), u = j0(), f = U0(), a = eS(), t = Rn(), l = z3(), I0(), e = K3());
      }
      return Object.defineProperty(y.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(y.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(y.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      }), Object.defineProperty(y.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(y.prototype, "childNodes", {
        get: function() {
          return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new l(this.children)), this.childNodeList;
        }
      }), Object.defineProperty(y.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      }), Object.defineProperty(y.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "previousSibling", {
        get: function() {
          var E;
          return E = this.parent.children.indexOf(this), this.parent.children[E - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "nextSibling", {
        get: function() {
          var E;
          return E = this.parent.children.indexOf(this), this.parent.children[E + 1] || null;
        }
      }), Object.defineProperty(y.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      }), Object.defineProperty(y.prototype, "textContent", {
        get: function() {
          var E, C, x, b, P;
          if (this.nodeType === t.Element || this.nodeType === t.DocumentFragment) {
            for (P = "", b = this.children, C = 0, x = b.length; C < x; C++)
              E = b[C], E.textContent && (P += E.textContent);
            return P;
          } else
            return null;
        },
        set: function(E) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), y.prototype.setParent = function(E) {
        var C, x, b, P, T;
        for (this.parent = E, E && (this.options = E.options, this.stringify = E.stringify), P = this.children, T = [], x = 0, b = P.length; x < b; x++)
          C = P[x], T.push(C.setParent(this));
        return T;
      }, y.prototype.element = function(E, C, x) {
        var b, P, T, O, S, L, A, D, _, w, B;
        if (L = null, C === null && x == null && (_ = [{}, null], C = _[0], x = _[1]), C == null && (C = {}), C = c(C), g(C) || (w = [C, x], x = w[0], C = w[1]), E != null && (E = c(E)), Array.isArray(E))
          for (T = 0, A = E.length; T < A; T++)
            P = E[T], L = this.element(P);
        else if (p(E))
          L = this.element(E.apply());
        else if (g(E)) {
          for (S in E)
            if (v.call(E, S))
              if (B = E[S], p(B) && (B = B.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && S.indexOf(this.stringify.convertAttKey) === 0)
                L = this.attribute(S.substr(this.stringify.convertAttKey.length), B);
              else if (!this.options.separateArrayItems && Array.isArray(B) && h(B))
                L = this.dummy();
              else if (g(B) && h(B))
                L = this.element(S);
              else if (!this.options.keepNullNodes && B == null)
                L = this.dummy();
              else if (!this.options.separateArrayItems && Array.isArray(B))
                for (O = 0, D = B.length; O < D; O++)
                  P = B[O], b = {}, b[S] = P, L = this.element(b);
              else
                g(B) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && S.indexOf(this.stringify.convertTextKey) === 0 ? L = this.element(B) : (L = this.element(S), L.element(B)) : L = this.element(S, B);
        } else
          !this.options.keepNullNodes && x === null ? L = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && E.indexOf(this.stringify.convertTextKey) === 0 ? L = this.text(x) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && E.indexOf(this.stringify.convertCDataKey) === 0 ? L = this.cdata(x) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && E.indexOf(this.stringify.convertCommentKey) === 0 ? L = this.comment(x) : !this.options.ignoreDecorators && this.stringify.convertRawKey && E.indexOf(this.stringify.convertRawKey) === 0 ? L = this.raw(x) : !this.options.ignoreDecorators && this.stringify.convertPIKey && E.indexOf(this.stringify.convertPIKey) === 0 ? L = this.instruction(E.substr(this.stringify.convertPIKey.length), x) : L = this.node(E, C, x);
        if (L == null)
          throw new Error("Could not create any elements with: " + E + ". " + this.debugInfo());
        return L;
      }, y.prototype.insertBefore = function(E, C, x) {
        var b, P, T, O, S;
        if (E != null && E.type)
          return T = E, O = C, T.setParent(this), O ? (P = children.indexOf(O), S = children.splice(P), children.push(T), Array.prototype.push.apply(children, S)) : children.push(T), T;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(E));
        return P = this.parent.children.indexOf(this), S = this.parent.children.splice(P), b = this.parent.element(E, C, x), Array.prototype.push.apply(this.parent.children, S), b;
      }, y.prototype.insertAfter = function(E, C, x) {
        var b, P, T;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(E));
        return P = this.parent.children.indexOf(this), T = this.parent.children.splice(P + 1), b = this.parent.element(E, C, x), Array.prototype.push.apply(this.parent.children, T), b;
      }, y.prototype.remove = function() {
        var E;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return E = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [E, E - E + 1].concat([])), this.parent;
      }, y.prototype.node = function(E, C, x) {
        var b, P;
        return E != null && (E = c(E)), C || (C = {}), C = c(C), g(C) || (P = [C, x], x = P[0], C = P[1]), b = new o(this, E, C), x != null && b.text(x), this.children.push(b), b;
      }, y.prototype.text = function(E) {
        var C;
        return g(E) && this.element(E), C = new u(this, E), this.children.push(C), this;
      }, y.prototype.cdata = function(E) {
        var C;
        return C = new n(this, E), this.children.push(C), this;
      }, y.prototype.comment = function(E) {
        var C;
        return C = new s(this, E), this.children.push(C), this;
      }, y.prototype.commentBefore = function(E) {
        var C, x;
        return C = this.parent.children.indexOf(this), x = this.parent.children.splice(C), this.parent.comment(E), Array.prototype.push.apply(this.parent.children, x), this;
      }, y.prototype.commentAfter = function(E) {
        var C, x;
        return C = this.parent.children.indexOf(this), x = this.parent.children.splice(C + 1), this.parent.comment(E), Array.prototype.push.apply(this.parent.children, x), this;
      }, y.prototype.raw = function(E) {
        var C;
        return C = new d(this, E), this.children.push(C), this;
      }, y.prototype.dummy = function() {
        var E;
        return E = new a(this), E;
      }, y.prototype.instruction = function(E, C) {
        var x, b, P, T, O;
        if (E != null && (E = c(E)), C != null && (C = c(C)), Array.isArray(E))
          for (T = 0, O = E.length; T < O; T++)
            x = E[T], this.instruction(x);
        else if (g(E))
          for (x in E)
            v.call(E, x) && (b = E[x], this.instruction(x, b));
        else
          p(C) && (C = C.apply()), P = new f(this, E, C), this.children.push(P);
        return this;
      }, y.prototype.instructionBefore = function(E, C) {
        var x, b;
        return x = this.parent.children.indexOf(this), b = this.parent.children.splice(x), this.parent.instruction(E, C), Array.prototype.push.apply(this.parent.children, b), this;
      }, y.prototype.instructionAfter = function(E, C) {
        var x, b;
        return x = this.parent.children.indexOf(this), b = this.parent.children.splice(x + 1), this.parent.instruction(E, C), Array.prototype.push.apply(this.parent.children, b), this;
      }, y.prototype.declaration = function(E, C, x) {
        var b, P;
        return b = this.document(), P = new r(b, E, C, x), b.children.length === 0 ? b.children.unshift(P) : b.children[0].type === t.Declaration ? b.children[0] = P : b.children.unshift(P), b.root() || b;
      }, y.prototype.dtd = function(E, C) {
        var x, b, P, T, O, S, L, A, D, _;
        for (b = this.document(), P = new i(b, E, C), D = b.children, T = O = 0, L = D.length; O < L; T = ++O)
          if (x = D[T], x.type === t.DocType)
            return b.children[T] = P, P;
        for (_ = b.children, T = S = 0, A = _.length; S < A; T = ++S)
          if (x = _[T], x.isRoot)
            return b.children.splice(T, 0, P), P;
        return b.children.push(P), P;
      }, y.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, y.prototype.root = function() {
        var E;
        for (E = this; E; ) {
          if (E.type === t.Document)
            return E.rootObject;
          if (E.isRoot)
            return E;
          E = E.parent;
        }
      }, y.prototype.document = function() {
        var E;
        for (E = this; E; ) {
          if (E.type === t.Document)
            return E;
          E = E.parent;
        }
      }, y.prototype.end = function(E) {
        return this.document().end(E);
      }, y.prototype.prev = function() {
        var E;
        if (E = this.parent.children.indexOf(this), E < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[E - 1];
      }, y.prototype.next = function() {
        var E;
        if (E = this.parent.children.indexOf(this), E === -1 || E === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[E + 1];
      }, y.prototype.importDocument = function(E) {
        var C;
        return C = E.root().clone(), C.parent = this, C.isRoot = !1, this.children.push(C), this;
      }, y.prototype.debugInfo = function(E) {
        var C, x;
        return E = E || this.name, E == null && !((C = this.parent) != null && C.name) ? "" : E == null ? "parent: <" + this.parent.name + ">" : (x = this.parent) != null && x.name ? "node: <" + E + ">, parent: <" + this.parent.name + ">" : "node: <" + E + ">";
      }, y.prototype.ele = function(E, C, x) {
        return this.element(E, C, x);
      }, y.prototype.nod = function(E, C, x) {
        return this.node(E, C, x);
      }, y.prototype.txt = function(E) {
        return this.text(E);
      }, y.prototype.dat = function(E) {
        return this.cdata(E);
      }, y.prototype.com = function(E) {
        return this.comment(E);
      }, y.prototype.ins = function(E, C) {
        return this.instruction(E, C);
      }, y.prototype.doc = function() {
        return this.document();
      }, y.prototype.dec = function(E, C, x) {
        return this.declaration(E, C, x);
      }, y.prototype.e = function(E, C, x) {
        return this.element(E, C, x);
      }, y.prototype.n = function(E, C, x) {
        return this.node(E, C, x);
      }, y.prototype.t = function(E) {
        return this.text(E);
      }, y.prototype.d = function(E) {
        return this.cdata(E);
      }, y.prototype.c = function(E) {
        return this.comment(E);
      }, y.prototype.r = function(E) {
        return this.raw(E);
      }, y.prototype.i = function(E, C) {
        return this.instruction(E, C);
      }, y.prototype.u = function() {
        return this.up();
      }, y.prototype.importXMLBuilder = function(E) {
        return this.importDocument(E);
      }, y.prototype.replaceChild = function(E, C) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.removeChild = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.appendChild = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      }, y.prototype.cloneNode = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isSupported = function(E, C) {
        return !0;
      }, y.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      }, y.prototype.compareDocumentPosition = function(E) {
        var C, x;
        return C = this, C === E ? 0 : this.document() !== E.document() ? (x = e.Disconnected | e.ImplementationSpecific, Math.random() < 0.5 ? x |= e.Preceding : x |= e.Following, x) : C.isAncestor(E) ? e.Contains | e.Preceding : C.isDescendant(E) ? e.Contains | e.Following : C.isPreceding(E) ? e.Preceding : e.Following;
      }, y.prototype.isSameNode = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.lookupPrefix = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isDefaultNamespace = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.lookupNamespaceURI = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isEqualNode = function(E) {
        var C, x, b;
        if (E.nodeType !== this.nodeType || E.children.length !== this.children.length)
          return !1;
        for (C = x = 0, b = this.children.length - 1; 0 <= b ? x <= b : x >= b; C = 0 <= b ? ++x : --x)
          if (!this.children[C].isEqualNode(E.children[C]))
            return !1;
        return !0;
      }, y.prototype.getFeature = function(E, C) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.setUserData = function(E, C, x) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.getUserData = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.contains = function(E) {
        return E ? E === this || this.isDescendant(E) : !1;
      }, y.prototype.isDescendant = function(E) {
        var C, x, b, P, T;
        for (T = this.children, b = 0, P = T.length; b < P; b++)
          if (C = T[b], E === C || (x = C.isDescendant(E), x))
            return !0;
        return !1;
      }, y.prototype.isAncestor = function(E) {
        return E.isDescendant(this);
      }, y.prototype.isPreceding = function(E) {
        var C, x;
        return C = this.treePosition(E), x = this.treePosition(this), C === -1 || x === -1 ? !1 : C < x;
      }, y.prototype.isFollowing = function(E) {
        var C, x;
        return C = this.treePosition(E), x = this.treePosition(this), C === -1 || x === -1 ? !1 : C > x;
      }, y.prototype.treePosition = function(E) {
        var C, x;
        return x = 0, C = !1, this.foreachTreeNode(this.document(), function(b) {
          if (x++, !C && b === E)
            return C = !0;
        }), C ? x : -1;
      }, y.prototype.foreachTreeNode = function(E, C) {
        var x, b, P, T, O;
        for (E || (E = this.document()), T = E.children, b = 0, P = T.length; b < P; b++) {
          if (x = T[b], O = C(x))
            return O;
          if (O = this.foreachTreeNode(x, C), O)
            return O;
        }
      }, y;
    }();
  }).call(_t)), Yp.exports;
}
var pm = { exports: {} }, Zx;
function nS() {
  return Zx || (Zx = 1, (function() {
    var e = function(n, s) {
      return function() {
        return n.apply(s, arguments);
      };
    }, t = {}.hasOwnProperty;
    pm.exports = function() {
      function n(s) {
        this.assertLegalName = e(this.assertLegalName, this), this.assertLegalChar = e(this.assertLegalChar, this);
        var r, i, a;
        s || (s = {}), this.options = s, this.options.version || (this.options.version = "1.0"), i = s.stringify || {};
        for (r in i)
          t.call(i, r) && (a = i[r], this[r] = a);
      }
      return n.prototype.name = function(s) {
        return this.options.noValidation ? s : this.assertLegalName("" + s || "");
      }, n.prototype.text = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar(this.textEscape("" + s || ""));
      }, n.prototype.cdata = function(s) {
        return this.options.noValidation ? s : (s = "" + s || "", s = s.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(s));
      }, n.prototype.comment = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", s.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.raw = function(s) {
        return this.options.noValidation ? s : "" + s || "";
      }, n.prototype.attValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar(this.attEscape(s = "" + s || ""));
      }, n.prototype.insTarget = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.insValue = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", s.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.xmlVersion = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", !s.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + s);
        return s;
      }, n.prototype.xmlEncoding = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", !s.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.xmlStandalone = function(s) {
        return this.options.noValidation ? s : s ? "yes" : "no";
      }, n.prototype.dtdPubID = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdSysID = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdElementValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdAttType = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdAttDefault = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdEntityValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdNData = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.convertAttKey = "@", n.prototype.convertPIKey = "?", n.prototype.convertTextKey = "#text", n.prototype.convertCDataKey = "#cdata", n.prototype.convertCommentKey = "#comment", n.prototype.convertRawKey = "#raw", n.prototype.assertLegalChar = function(s) {
        var r, i;
        if (this.options.noValidation)
          return s;
        if (r = "", this.options.version === "1.0") {
          if (r = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = s.match(r))
            throw new Error("Invalid character in string: " + s + " at index " + i.index);
        } else if (this.options.version === "1.1" && (r = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = s.match(r)))
          throw new Error("Invalid character in string: " + s + " at index " + i.index);
        return s;
      }, n.prototype.assertLegalName = function(s) {
        var r;
        if (this.options.noValidation)
          return s;
        if (this.assertLegalChar(s), r = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !s.match(r))
          throw new Error("Invalid character in name");
        return s;
      }, n.prototype.textEscape = function(s) {
        var r;
        return this.options.noValidation ? s : (r = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, s.replace(r, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
      }, n.prototype.attEscape = function(s) {
        var r;
        return this.options.noValidation ? s : (r = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, s.replace(r, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
      }, n;
    }();
  }).call(_t)), pm.exports;
}
var mm = { exports: {} }, gm = { exports: {} }, vm = { exports: {} }, Jx;
function Hf() {
  return Jx || (Jx = 1, (function() {
    vm.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(_t)), vm.exports;
}
var Qx;
function iS() {
  return Qx || (Qx = 1, (function() {
    var e, t, n, s = {}.hasOwnProperty;
    n = sa().assign, e = Rn(), L0(), N0(), D0(), A0(), _0(), F0(), j0(), U0(), eS(), R0(), V0(), w0(), B0(), t = Hf(), gm.exports = function() {
      function r(i) {
        var a, o, l;
        i || (i = {}), this.options = i, o = i.writer || {};
        for (a in o)
          s.call(o, a) && (l = o[a], this["_" + a] = this[a], this[a] = l);
      }
      return r.prototype.filterOptions = function(i) {
        var a, o, l, f, d, u, c, h;
        return i || (i = {}), i = n({}, this.options, i), a = {
          writer: this
        }, a.pretty = i.pretty || !1, a.allowEmpty = i.allowEmpty || !1, a.indent = (o = i.indent) != null ? o : "  ", a.newline = (l = i.newline) != null ? l : `
`, a.offset = (f = i.offset) != null ? f : 0, a.dontPrettyTextNodes = (d = (u = i.dontPrettyTextNodes) != null ? u : i.dontprettytextnodes) != null ? d : 0, a.spaceBeforeSlash = (c = (h = i.spaceBeforeSlash) != null ? h : i.spacebeforeslash) != null ? c : "", a.spaceBeforeSlash === !0 && (a.spaceBeforeSlash = " "), a.suppressPrettyCount = 0, a.user = {}, a.state = t.None, a;
      }, r.prototype.indent = function(i, a, o) {
        var l;
        return !a.pretty || a.suppressPrettyCount ? "" : a.pretty && (l = (o || 0) + a.offset + 1, l > 0) ? new Array(l).join(a.indent) : "";
      }, r.prototype.endline = function(i, a, o) {
        return !a.pretty || a.suppressPrettyCount ? "" : a.newline;
      }, r.prototype.attribute = function(i, a, o) {
        var l;
        return this.openAttribute(i, a, o), l = " " + i.name + '="' + i.value + '"', this.closeAttribute(i, a, o), l;
      }, r.prototype.cdata = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<![CDATA[", a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += "]]>" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.comment = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!-- ", a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += " -->" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.declaration = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<?xml", a.state = t.InsideTag, l += ' version="' + i.version + '"', i.encoding != null && (l += ' encoding="' + i.encoding + '"'), i.standalone != null && (l += ' standalone="' + i.standalone + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + "?>", l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.docType = function(i, a, o) {
        var l, f, d, u, c;
        if (o || (o = 0), this.openNode(i, a, o), a.state = t.OpenTag, u = this.indent(i, a, o), u += "<!DOCTYPE " + i.root().name, i.pubID && i.sysID ? u += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (u += ' SYSTEM "' + i.sysID + '"'), i.children.length > 0) {
          for (u += " [", u += this.endline(i, a, o), a.state = t.InsideTag, c = i.children, f = 0, d = c.length; f < d; f++)
            l = c[f], u += this.writeChildNode(l, a, o + 1);
          a.state = t.CloseTag, u += "]";
        }
        return a.state = t.CloseTag, u += a.spaceBeforeSlash + ">", u += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), u;
      }, r.prototype.element = function(i, a, o) {
        var l, f, d, u, c, h, p, g, m, v, y, E, C, x;
        o || (o = 0), v = !1, y = "", this.openNode(i, a, o), a.state = t.OpenTag, y += this.indent(i, a, o) + "<" + i.name, E = i.attribs;
        for (m in E)
          s.call(E, m) && (l = E[m], y += this.attribute(l, a, o));
        if (d = i.children.length, u = d === 0 ? null : i.children[0], d === 0 || i.children.every(function(b) {
          return (b.type === e.Text || b.type === e.Raw) && b.value === "";
        }))
          a.allowEmpty ? (y += ">", a.state = t.CloseTag, y += "</" + i.name + ">" + this.endline(i, a, o)) : (a.state = t.CloseTag, y += a.spaceBeforeSlash + "/>" + this.endline(i, a, o));
        else if (a.pretty && d === 1 && (u.type === e.Text || u.type === e.Raw) && u.value != null)
          y += ">", a.state = t.InsideTag, a.suppressPrettyCount++, v = !0, y += this.writeChildNode(u, a, o + 1), a.suppressPrettyCount--, v = !1, a.state = t.CloseTag, y += "</" + i.name + ">" + this.endline(i, a, o);
        else {
          if (a.dontPrettyTextNodes) {
            for (C = i.children, c = 0, p = C.length; c < p; c++)
              if (f = C[c], (f.type === e.Text || f.type === e.Raw) && f.value != null) {
                a.suppressPrettyCount++, v = !0;
                break;
              }
          }
          for (y += ">" + this.endline(i, a, o), a.state = t.InsideTag, x = i.children, h = 0, g = x.length; h < g; h++)
            f = x[h], y += this.writeChildNode(f, a, o + 1);
          a.state = t.CloseTag, y += this.indent(i, a, o) + "</" + i.name + ">", v && a.suppressPrettyCount--, y += this.endline(i, a, o), a.state = t.None;
        }
        return this.closeNode(i, a, o), y;
      }, r.prototype.writeChildNode = function(i, a, o) {
        switch (i.type) {
          case e.CData:
            return this.cdata(i, a, o);
          case e.Comment:
            return this.comment(i, a, o);
          case e.Element:
            return this.element(i, a, o);
          case e.Raw:
            return this.raw(i, a, o);
          case e.Text:
            return this.text(i, a, o);
          case e.ProcessingInstruction:
            return this.processingInstruction(i, a, o);
          case e.Dummy:
            return "";
          case e.Declaration:
            return this.declaration(i, a, o);
          case e.DocType:
            return this.docType(i, a, o);
          case e.AttributeDeclaration:
            return this.dtdAttList(i, a, o);
          case e.ElementDeclaration:
            return this.dtdElement(i, a, o);
          case e.EntityDeclaration:
            return this.dtdEntity(i, a, o);
          case e.NotationDeclaration:
            return this.dtdNotation(i, a, o);
          default:
            throw new Error("Unknown XML node type: " + i.constructor.name);
        }
      }, r.prototype.processingInstruction = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<?", a.state = t.InsideTag, l += i.target, i.value && (l += " " + i.value), a.state = t.CloseTag, l += a.spaceBeforeSlash + "?>", l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.raw = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o), a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.text = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o), a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdAttList = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ATTLIST", a.state = t.InsideTag, l += " " + i.elementName + " " + i.attributeName + " " + i.attributeType, i.defaultValueType !== "#DEFAULT" && (l += " " + i.defaultValueType), i.defaultValue && (l += ' "' + i.defaultValue + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdElement = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ELEMENT", a.state = t.InsideTag, l += " " + i.name + " " + i.value, a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdEntity = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ENTITY", a.state = t.InsideTag, i.pe && (l += " %"), l += " " + i.name, i.value ? l += ' "' + i.value + '"' : (i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), i.nData && (l += " NDATA " + i.nData)), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdNotation = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!NOTATION", a.state = t.InsideTag, l += " " + i.name, i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.pubID ? l += ' PUBLIC "' + i.pubID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.openNode = function(i, a, o) {
      }, r.prototype.closeNode = function(i, a, o) {
      }, r.prototype.openAttribute = function(i, a, o) {
      }, r.prototype.closeAttribute = function(i, a, o) {
      }, r;
    }();
  }).call(_t)), gm.exports;
}
var qx;
function W0() {
  return qx || (qx = 1, (function() {
    var e, t = function(s, r) {
      for (var i in r)
        n.call(r, i) && (s[i] = r[i]);
      function a() {
        this.constructor = s;
      }
      return a.prototype = r.prototype, s.prototype = new a(), s.__super__ = r.prototype, s;
    }, n = {}.hasOwnProperty;
    e = iS(), mm.exports = function(s) {
      t(r, s);
      function r(i) {
        r.__super__.constructor.call(this, i);
      }
      return r.prototype.document = function(i, a) {
        var o, l, f, d, u;
        for (a = this.filterOptions(a), d = "", u = i.children, l = 0, f = u.length; l < f; l++)
          o = u[l], d += this.writeChildNode(o, a, 0);
        return a.pretty && d.slice(-a.newline.length) === a.newline && (d = d.slice(0, -a.newline.length)), d;
      }, r;
    }(e);
  }).call(_t)), mm.exports;
}
var tb;
function rS() {
  return tb || (tb = 1, (function() {
    var e, t, n, s, r, i, a, o = function(f, d) {
      for (var u in d)
        l.call(d, u) && (f[u] = d[u]);
      function c() {
        this.constructor = f;
      }
      return c.prototype = d.prototype, f.prototype = new c(), f.__super__ = d.prototype, f;
    }, l = {}.hasOwnProperty;
    a = sa().isPlainObject, n = qM(), t = $3(), s = Cr(), e = Rn(), i = nS(), r = W0(), Kp.exports = function(f) {
      o(d, f);
      function d(u) {
        d.__super__.constructor.call(this, null), this.name = "#document", this.type = e.Document, this.documentURI = null, this.domConfig = new t(), u || (u = {}), u.writer || (u.writer = new r()), this.options = u, this.stringify = new i(u);
      }
      return Object.defineProperty(d.prototype, "implementation", {
        value: new n()
      }), Object.defineProperty(d.prototype, "doctype", {
        get: function() {
          var u, c, h, p;
          for (p = this.children, c = 0, h = p.length; c < h; c++)
            if (u = p[c], u.type === e.DocType)
              return u;
          return null;
        }
      }), Object.defineProperty(d.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      }), Object.defineProperty(d.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "strictErrorChecking", {
        get: function() {
          return !1;
        }
      }), Object.defineProperty(d.prototype, "xmlEncoding", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].encoding : null;
        }
      }), Object.defineProperty(d.prototype, "xmlStandalone", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].standalone === "yes" : !1;
        }
      }), Object.defineProperty(d.prototype, "xmlVersion", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].version : "1.0";
        }
      }), Object.defineProperty(d.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      }), Object.defineProperty(d.prototype, "origin", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "compatMode", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "characterSet", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "contentType", {
        get: function() {
          return null;
        }
      }), d.prototype.end = function(u) {
        var c;
        return c = {}, u ? a(u) && (c = u, u = this.options.writer) : u = this.options.writer, u.document(this, u.filterOptions(c));
      }, d.prototype.toString = function(u) {
        return this.options.writer.document(this, this.options.writer.filterOptions(u));
      }, d.prototype.createElement = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createTextNode = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createComment = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createCDATASection = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createProcessingInstruction = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createAttribute = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createEntityReference = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByTagName = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.importNode = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createElementNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createAttributeNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByTagNameNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementById = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.adoptNode = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.renameNode = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByClassName = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createEvent = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createNodeIterator = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createTreeWalker = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d;
    }(s);
  }).call(_t)), Kp.exports;
}
var ym = { exports: {} }, eb;
function G3() {
  return eb || (eb = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P = {}.hasOwnProperty;
    b = sa(), C = b.isObject, E = b.isFunction, x = b.isPlainObject, y = b.getValue, e = Rn(), u = rS(), c = _0(), s = D0(), r = A0(), p = F0(), v = j0(), h = U0(), f = L0(), d = N0(), i = R0(), o = w0(), a = V0(), l = B0(), n = tS(), m = nS(), g = W0(), t = Hf(), ym.exports = function() {
      function T(O, S, L) {
        var A;
        this.name = "?xml", this.type = e.Document, O || (O = {}), A = {}, O.writer ? x(O.writer) && (A = O.writer, O.writer = new g()) : O.writer = new g(), this.options = O, this.writer = O.writer, this.writerOptions = this.writer.filterOptions(A), this.stringify = new m(O), this.onDataCallback = S || function() {
        }, this.onEndCallback = L || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return T.prototype.createChildNode = function(O) {
        var S, L, A, D, _, w, B, j;
        switch (O.type) {
          case e.CData:
            this.cdata(O.value);
            break;
          case e.Comment:
            this.comment(O.value);
            break;
          case e.Element:
            A = {}, B = O.attribs;
            for (L in B)
              P.call(B, L) && (S = B[L], A[L] = S.value);
            this.node(O.name, A);
            break;
          case e.Dummy:
            this.dummy();
            break;
          case e.Raw:
            this.raw(O.value);
            break;
          case e.Text:
            this.text(O.value);
            break;
          case e.ProcessingInstruction:
            this.instruction(O.target, O.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + O.constructor.name);
        }
        for (j = O.children, _ = 0, w = j.length; _ < w; _++)
          D = j[_], this.createChildNode(D), D.type === e.Element && this.up();
        return this;
      }, T.prototype.dummy = function() {
        return this;
      }, T.prototype.node = function(O, S, L) {
        var A;
        if (O == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(O));
        return this.openCurrent(), O = y(O), S == null && (S = {}), S = y(S), C(S) || (A = [S, L], L = A[0], S = A[1]), this.currentNode = new c(this, O, S), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, L != null && this.text(L), this;
      }, T.prototype.element = function(O, S, L) {
        var A, D, _, w, B, j;
        if (this.currentNode && this.currentNode.type === e.DocType)
          this.dtdElement.apply(this, arguments);
        else if (Array.isArray(O) || C(O) || E(O))
          for (w = this.options.noValidation, this.options.noValidation = !0, j = new u(this.options).element("TEMP_ROOT"), j.element(O), this.options.noValidation = w, B = j.children, D = 0, _ = B.length; D < _; D++)
            A = B[D], this.createChildNode(A), A.type === e.Element && this.up();
        else
          this.node(O, S, L);
        return this;
      }, T.prototype.attribute = function(O, S) {
        var L, A;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(O));
        if (O != null && (O = y(O)), C(O))
          for (L in O)
            P.call(O, L) && (A = O[L], this.attribute(L, A));
        else
          E(S) && (S = S.apply()), this.options.keepNullAttributes && S == null ? this.currentNode.attribs[O] = new n(this, O, "") : S != null && (this.currentNode.attribs[O] = new n(this, O, S));
        return this;
      }, T.prototype.text = function(O) {
        var S;
        return this.openCurrent(), S = new v(this, O), this.onData(this.writer.text(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.cdata = function(O) {
        var S;
        return this.openCurrent(), S = new s(this, O), this.onData(this.writer.cdata(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.comment = function(O) {
        var S;
        return this.openCurrent(), S = new r(this, O), this.onData(this.writer.comment(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.raw = function(O) {
        var S;
        return this.openCurrent(), S = new p(this, O), this.onData(this.writer.raw(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.instruction = function(O, S) {
        var L, A, D, _, w;
        if (this.openCurrent(), O != null && (O = y(O)), S != null && (S = y(S)), Array.isArray(O))
          for (L = 0, _ = O.length; L < _; L++)
            A = O[L], this.instruction(A);
        else if (C(O))
          for (A in O)
            P.call(O, A) && (D = O[A], this.instruction(A, D));
        else
          E(S) && (S = S.apply()), w = new h(this, O, S), this.onData(this.writer.processingInstruction(w, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, T.prototype.declaration = function(O, S, L) {
        var A;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return A = new f(this, O, S, L), this.onData(this.writer.declaration(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.doctype = function(O, S, L) {
        if (this.openCurrent(), O == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new d(this, S, L), this.currentNode.rootNodeName = O, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, T.prototype.dtdElement = function(O, S) {
        var L;
        return this.openCurrent(), L = new a(this, O, S), this.onData(this.writer.dtdElement(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.attList = function(O, S, L, A, D) {
        var _;
        return this.openCurrent(), _ = new i(this, O, S, L, A, D), this.onData(this.writer.dtdAttList(_, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.entity = function(O, S) {
        var L;
        return this.openCurrent(), L = new o(this, !1, O, S), this.onData(this.writer.dtdEntity(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.pEntity = function(O, S) {
        var L;
        return this.openCurrent(), L = new o(this, !0, O, S), this.onData(this.writer.dtdEntity(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.notation = function(O, S) {
        var L;
        return this.openCurrent(), L = new l(this, O, S), this.onData(this.writer.dtdNotation(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, T.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, T.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, T.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, T.prototype.openNode = function(O) {
        var S, L, A, D;
        if (!O.isOpen) {
          if (!this.root && this.currentLevel === 0 && O.type === e.Element && (this.root = O), L = "", O.type === e.Element) {
            this.writerOptions.state = t.OpenTag, L = this.writer.indent(O, this.writerOptions, this.currentLevel) + "<" + O.name, D = O.attribs;
            for (A in D)
              P.call(D, A) && (S = D[A], L += this.writer.attribute(S, this.writerOptions, this.currentLevel));
            L += (O.children ? ">" : "/>") + this.writer.endline(O, this.writerOptions, this.currentLevel), this.writerOptions.state = t.InsideTag;
          } else
            this.writerOptions.state = t.OpenTag, L = this.writer.indent(O, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + O.rootNodeName, O.pubID && O.sysID ? L += ' PUBLIC "' + O.pubID + '" "' + O.sysID + '"' : O.sysID && (L += ' SYSTEM "' + O.sysID + '"'), O.children ? (L += " [", this.writerOptions.state = t.InsideTag) : (this.writerOptions.state = t.CloseTag, L += ">"), L += this.writer.endline(O, this.writerOptions, this.currentLevel);
          return this.onData(L, this.currentLevel), O.isOpen = !0;
        }
      }, T.prototype.closeNode = function(O) {
        var S;
        if (!O.isClosed)
          return S = "", this.writerOptions.state = t.CloseTag, O.type === e.Element ? S = this.writer.indent(O, this.writerOptions, this.currentLevel) + "</" + O.name + ">" + this.writer.endline(O, this.writerOptions, this.currentLevel) : S = this.writer.indent(O, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(O, this.writerOptions, this.currentLevel), this.writerOptions.state = t.None, this.onData(S, this.currentLevel), O.isClosed = !0;
      }, T.prototype.onData = function(O, S) {
        return this.documentStarted = !0, this.onDataCallback(O, S + 1);
      }, T.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, T.prototype.debugInfo = function(O) {
        return O == null ? "" : "node: <" + O + ">";
      }, T.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, T.prototype.nod = function(O, S, L) {
        return this.node(O, S, L);
      }, T.prototype.txt = function(O) {
        return this.text(O);
      }, T.prototype.dat = function(O) {
        return this.cdata(O);
      }, T.prototype.com = function(O) {
        return this.comment(O);
      }, T.prototype.ins = function(O, S) {
        return this.instruction(O, S);
      }, T.prototype.dec = function(O, S, L) {
        return this.declaration(O, S, L);
      }, T.prototype.dtd = function(O, S, L) {
        return this.doctype(O, S, L);
      }, T.prototype.e = function(O, S, L) {
        return this.element(O, S, L);
      }, T.prototype.n = function(O, S, L) {
        return this.node(O, S, L);
      }, T.prototype.t = function(O) {
        return this.text(O);
      }, T.prototype.d = function(O) {
        return this.cdata(O);
      }, T.prototype.c = function(O) {
        return this.comment(O);
      }, T.prototype.r = function(O) {
        return this.raw(O);
      }, T.prototype.i = function(O, S) {
        return this.instruction(O, S);
      }, T.prototype.att = function() {
        return this.currentNode && this.currentNode.type === e.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, T.prototype.a = function() {
        return this.currentNode && this.currentNode.type === e.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, T.prototype.ent = function(O, S) {
        return this.entity(O, S);
      }, T.prototype.pent = function(O, S) {
        return this.pEntity(O, S);
      }, T.prototype.not = function(O, S) {
        return this.notation(O, S);
      }, T;
    }();
  }).call(_t)), ym.exports;
}
var Em = { exports: {} }, nb;
function k3() {
  return nb || (nb = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    e = Rn(), n = iS(), t = Hf(), Em.exports = function(i) {
      s(a, i);
      function a(o, l) {
        this.stream = o, a.__super__.constructor.call(this, l);
      }
      return a.prototype.endline = function(o, l, f) {
        return o.isLastRootNode && l.state === t.CloseTag ? "" : a.__super__.endline.call(this, o, l, f);
      }, a.prototype.document = function(o, l) {
        var f, d, u, c, h, p, g, m, v;
        for (g = o.children, d = u = 0, h = g.length; u < h; d = ++u)
          f = g[d], f.isLastRootNode = d === o.children.length - 1;
        for (l = this.filterOptions(l), m = o.children, v = [], c = 0, p = m.length; c < p; c++)
          f = m[c], v.push(this.writeChildNode(f, l, 0));
        return v;
      }, a.prototype.attribute = function(o, l, f) {
        return this.stream.write(a.__super__.attribute.call(this, o, l, f));
      }, a.prototype.cdata = function(o, l, f) {
        return this.stream.write(a.__super__.cdata.call(this, o, l, f));
      }, a.prototype.comment = function(o, l, f) {
        return this.stream.write(a.__super__.comment.call(this, o, l, f));
      }, a.prototype.declaration = function(o, l, f) {
        return this.stream.write(a.__super__.declaration.call(this, o, l, f));
      }, a.prototype.docType = function(o, l, f) {
        var d, u, c, h;
        if (f || (f = 0), this.openNode(o, l, f), l.state = t.OpenTag, this.stream.write(this.indent(o, l, f)), this.stream.write("<!DOCTYPE " + o.root().name), o.pubID && o.sysID ? this.stream.write(' PUBLIC "' + o.pubID + '" "' + o.sysID + '"') : o.sysID && this.stream.write(' SYSTEM "' + o.sysID + '"'), o.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(o, l, f)), l.state = t.InsideTag, h = o.children, u = 0, c = h.length; u < c; u++)
            d = h[u], this.writeChildNode(d, l, f + 1);
          l.state = t.CloseTag, this.stream.write("]");
        }
        return l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + ">"), this.stream.write(this.endline(o, l, f)), l.state = t.None, this.closeNode(o, l, f);
      }, a.prototype.element = function(o, l, f) {
        var d, u, c, h, p, g, m, v, y;
        f || (f = 0), this.openNode(o, l, f), l.state = t.OpenTag, this.stream.write(this.indent(o, l, f) + "<" + o.name), v = o.attribs;
        for (m in v)
          r.call(v, m) && (d = v[m], this.attribute(d, l, f));
        if (c = o.children.length, h = c === 0 ? null : o.children[0], c === 0 || o.children.every(function(E) {
          return (E.type === e.Text || E.type === e.Raw) && E.value === "";
        }))
          l.allowEmpty ? (this.stream.write(">"), l.state = t.CloseTag, this.stream.write("</" + o.name + ">")) : (l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + "/>"));
        else if (l.pretty && c === 1 && (h.type === e.Text || h.type === e.Raw) && h.value != null)
          this.stream.write(">"), l.state = t.InsideTag, l.suppressPrettyCount++, this.writeChildNode(h, l, f + 1), l.suppressPrettyCount--, l.state = t.CloseTag, this.stream.write("</" + o.name + ">");
        else {
          for (this.stream.write(">" + this.endline(o, l, f)), l.state = t.InsideTag, y = o.children, p = 0, g = y.length; p < g; p++)
            u = y[p], this.writeChildNode(u, l, f + 1);
          l.state = t.CloseTag, this.stream.write(this.indent(o, l, f) + "</" + o.name + ">");
        }
        return this.stream.write(this.endline(o, l, f)), l.state = t.None, this.closeNode(o, l, f);
      }, a.prototype.processingInstruction = function(o, l, f) {
        return this.stream.write(a.__super__.processingInstruction.call(this, o, l, f));
      }, a.prototype.raw = function(o, l, f) {
        return this.stream.write(a.__super__.raw.call(this, o, l, f));
      }, a.prototype.text = function(o, l, f) {
        return this.stream.write(a.__super__.text.call(this, o, l, f));
      }, a.prototype.dtdAttList = function(o, l, f) {
        return this.stream.write(a.__super__.dtdAttList.call(this, o, l, f));
      }, a.prototype.dtdElement = function(o, l, f) {
        return this.stream.write(a.__super__.dtdElement.call(this, o, l, f));
      }, a.prototype.dtdEntity = function(o, l, f) {
        return this.stream.write(a.__super__.dtdEntity.call(this, o, l, f));
      }, a.prototype.dtdNotation = function(o, l, f) {
        return this.stream.write(a.__super__.dtdNotation.call(this, o, l, f));
      }, a;
    }(n);
  }).call(_t)), Em.exports;
}
var ib;
function H3() {
  return ib || (ib = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f;
    f = sa(), o = f.assign, l = f.isFunction, n = qM(), s = rS(), r = G3(), a = W0(), i = k3(), e = Rn(), t = Hf(), Ds.create = function(d, u, c, h) {
      var p, g;
      if (d == null)
        throw new Error("Root element needs a name.");
      return h = o({}, u, c, h), p = new s(h), g = p.element(d), h.headless || (p.declaration(h), (h.pubID != null || h.sysID != null) && p.dtd(h)), g;
    }, Ds.begin = function(d, u, c) {
      var h;
      return l(d) && (h = [d, u], u = h[0], c = h[1], d = {}), u ? new r(d, u, c) : new s(d);
    }, Ds.stringWriter = function(d) {
      return new a(d);
    }, Ds.streamWriter = function(d, u) {
      return new i(d, u);
    }, Ds.implementation = new n(), Ds.nodeType = e, Ds.writerState = t;
  }).call(_t)), Ds;
}
var rb;
function Y3() {
  return rb || (rb = 1, (function() {
    var e, t, n, s, r, i = {}.hasOwnProperty;
    e = H3(), t = S0().defaults, s = function(a) {
      return typeof a == "string" && (a.indexOf("&") >= 0 || a.indexOf(">") >= 0 || a.indexOf("<") >= 0);
    }, r = function(a) {
      return "<![CDATA[" + n(a) + "]]>";
    }, n = function(a) {
      return a.replace("]]>", "]]]]><![CDATA[>");
    }, $p.Builder = function() {
      function a(o) {
        var l, f, d;
        this.options = {}, f = t["0.2"];
        for (l in f)
          i.call(f, l) && (d = f[l], this.options[l] = d);
        for (l in o)
          i.call(o, l) && (d = o[l], this.options[l] = d);
      }
      return a.prototype.buildObject = function(o) {
        var l, f, d, u, c;
        return l = this.options.attrkey, f = this.options.charkey, Object.keys(o).length === 1 && this.options.rootName === t["0.2"].rootName ? (c = Object.keys(o)[0], o = o[c]) : c = this.options.rootName, d = function(h) {
          return function(p, g) {
            var m, v, y, E, C, x;
            if (typeof g != "object")
              h.options.cdata && s(g) ? p.raw(r(g)) : p.txt(g);
            else if (Array.isArray(g)) {
              for (E in g)
                if (i.call(g, E)) {
                  v = g[E];
                  for (C in v)
                    y = v[C], p = d(p.ele(C), y).up();
                }
            } else
              for (C in g)
                if (i.call(g, C))
                  if (v = g[C], C === l) {
                    if (typeof v == "object")
                      for (m in v)
                        x = v[m], p = p.att(m, x);
                  } else if (C === f)
                    h.options.cdata && s(v) ? p = p.raw(r(v)) : p = p.txt(v);
                  else if (Array.isArray(v))
                    for (E in v)
                      i.call(v, E) && (y = v[E], typeof y == "string" ? h.options.cdata && s(y) ? p = p.ele(C).raw(r(y)).up() : p = p.ele(C, y).up() : p = d(p.ele(C), y).up());
                  else
                    typeof v == "object" ? p = d(p.ele(C), v).up() : typeof v == "string" && h.options.cdata && s(v) ? p = p.ele(C).raw(r(v)).up() : (v == null && (v = ""), p = p.ele(C, v.toString()).up());
            return p;
          };
        }(this), u = e.create(c, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        }), d(u, o).end(this.options.renderOpts);
      }, a;
    }();
  }).call(_t)), $p;
}
var Cm = {}, xm = {}, Ah = { exports: {} }, sb;
function Yf() {
  if (sb)
    return Ah.exports;
  sb = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(x, b, P) {
    return Function.prototype.apply.call(x, b, P);
  }, n;
  e && typeof e.ownKeys == "function" ? n = e.ownKeys : Object.getOwnPropertySymbols ? n = function(x) {
    return Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));
  } : n = function(x) {
    return Object.getOwnPropertyNames(x);
  };
  function s(C) {
    console && console.warn && console.warn(C);
  }
  var r = Number.isNaN || function(x) {
    return x !== x;
  };
  function i() {
    i.init.call(this);
  }
  Ah.exports = i, Ah.exports.once = v, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var a = 10;
  function o(C) {
    if (typeof C != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof C);
  }
  Object.defineProperty(i, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(C) {
      if (typeof C != "number" || C < 0 || r(C))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + C + ".");
      a = C;
    }
  }), i.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(x) {
    if (typeof x != "number" || x < 0 || r(x))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + x + ".");
    return this._maxListeners = x, this;
  };
  function l(C) {
    return C._maxListeners === void 0 ? i.defaultMaxListeners : C._maxListeners;
  }
  i.prototype.getMaxListeners = function() {
    return l(this);
  }, i.prototype.emit = function(x) {
    for (var b = [], P = 1; P < arguments.length; P++)
      b.push(arguments[P]);
    var T = x === "error", O = this._events;
    if (O !== void 0)
      T = T && O.error === void 0;
    else if (!T)
      return !1;
    if (T) {
      var S;
      if (b.length > 0 && (S = b[0]), S instanceof Error)
        throw S;
      var L = new Error("Unhandled error." + (S ? " (" + S.message + ")" : ""));
      throw L.context = S, L;
    }
    var A = O[x];
    if (A === void 0)
      return !1;
    if (typeof A == "function")
      t(A, this, b);
    else
      for (var D = A.length, _ = p(A, D), P = 0; P < D; ++P)
        t(_[P], this, b);
    return !0;
  };
  function f(C, x, b, P) {
    var T, O, S;
    if (o(b), O = C._events, O === void 0 ? (O = C._events = /* @__PURE__ */ Object.create(null), C._eventsCount = 0) : (O.newListener !== void 0 && (C.emit(
      "newListener",
      x,
      b.listener ? b.listener : b
    ), O = C._events), S = O[x]), S === void 0)
      S = O[x] = b, ++C._eventsCount;
    else if (typeof S == "function" ? S = O[x] = P ? [b, S] : [S, b] : P ? S.unshift(b) : S.push(b), T = l(C), T > 0 && S.length > T && !S.warned) {
      S.warned = !0;
      var L = new Error("Possible EventEmitter memory leak detected. " + S.length + " " + String(x) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      L.name = "MaxListenersExceededWarning", L.emitter = C, L.type = x, L.count = S.length, s(L);
    }
    return C;
  }
  i.prototype.addListener = function(x, b) {
    return f(this, x, b, !1);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(x, b) {
    return f(this, x, b, !0);
  };
  function d() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function u(C, x, b) {
    var P = { fired: !1, wrapFn: void 0, target: C, type: x, listener: b }, T = d.bind(P);
    return T.listener = b, P.wrapFn = T, T;
  }
  i.prototype.once = function(x, b) {
    return o(b), this.on(x, u(this, x, b)), this;
  }, i.prototype.prependOnceListener = function(x, b) {
    return o(b), this.prependListener(x, u(this, x, b)), this;
  }, i.prototype.removeListener = function(x, b) {
    var P, T, O, S, L;
    if (o(b), T = this._events, T === void 0)
      return this;
    if (P = T[x], P === void 0)
      return this;
    if (P === b || P.listener === b)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete T[x], T.removeListener && this.emit("removeListener", x, P.listener || b));
    else if (typeof P != "function") {
      for (O = -1, S = P.length - 1; S >= 0; S--)
        if (P[S] === b || P[S].listener === b) {
          L = P[S].listener, O = S;
          break;
        }
      if (O < 0)
        return this;
      O === 0 ? P.shift() : g(P, O), P.length === 1 && (T[x] = P[0]), T.removeListener !== void 0 && this.emit("removeListener", x, L || b);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(x) {
    var b, P, T;
    if (P = this._events, P === void 0)
      return this;
    if (P.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : P[x] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete P[x]), this;
    if (arguments.length === 0) {
      var O = Object.keys(P), S;
      for (T = 0; T < O.length; ++T)
        S = O[T], S !== "removeListener" && this.removeAllListeners(S);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (b = P[x], typeof b == "function")
      this.removeListener(x, b);
    else if (b !== void 0)
      for (T = b.length - 1; T >= 0; T--)
        this.removeListener(x, b[T]);
    return this;
  };
  function c(C, x, b) {
    var P = C._events;
    if (P === void 0)
      return [];
    var T = P[x];
    return T === void 0 ? [] : typeof T == "function" ? b ? [T.listener || T] : [T] : b ? m(T) : p(T, T.length);
  }
  i.prototype.listeners = function(x) {
    return c(this, x, !0);
  }, i.prototype.rawListeners = function(x) {
    return c(this, x, !1);
  }, i.listenerCount = function(C, x) {
    return typeof C.listenerCount == "function" ? C.listenerCount(x) : h.call(C, x);
  }, i.prototype.listenerCount = h;
  function h(C) {
    var x = this._events;
    if (x !== void 0) {
      var b = x[C];
      if (typeof b == "function")
        return 1;
      if (b !== void 0)
        return b.length;
    }
    return 0;
  }
  i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? n(this._events) : [];
  };
  function p(C, x) {
    for (var b = new Array(x), P = 0; P < x; ++P)
      b[P] = C[P];
    return b;
  }
  function g(C, x) {
    for (; x + 1 < C.length; x++)
      C[x] = C[x + 1];
    C.pop();
  }
  function m(C) {
    for (var x = new Array(C.length), b = 0; b < x.length; ++b)
      x[b] = C[b].listener || C[b];
    return x;
  }
  function v(C, x) {
    return new Promise(function(b, P) {
      function T(S) {
        C.removeListener(x, O), P(S);
      }
      function O() {
        typeof C.removeListener == "function" && C.removeListener("error", T), b([].slice.call(arguments));
      }
      E(C, x, O, { once: !0 }), x !== "error" && y(C, T, { once: !0 });
    });
  }
  function y(C, x, b) {
    typeof C.on == "function" && E(C, "error", x, b);
  }
  function E(C, x, b, P) {
    if (typeof C.on == "function")
      P.once ? C.once(x, b) : C.on(x, b);
    else if (typeof C.addEventListener == "function")
      C.addEventListener(x, function T(O) {
        P.once && C.removeEventListener(x, T), b(O);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof C);
  }
  return Ah.exports;
}
var Lh = { exports: {} }, ab;
function Cu() {
  return ab || (ab = 1, typeof Object.create == "function" ? Lh.exports = function(t, n) {
    n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Lh.exports = function(t, n) {
    if (n) {
      t.super_ = n;
      var s = function() {
      };
      s.prototype = n.prototype, t.prototype = new s(), t.prototype.constructor = t;
    }
  }), Lh.exports;
}
var bm, ob;
function sS() {
  return ob || (ob = 1, bm = Yf().EventEmitter), bm;
}
var Om = {}, Nu = {}, lb;
function X3() {
  if (lb)
    return Nu;
  lb = 1, Nu.byteLength = o, Nu.toByteArray = f, Nu.fromByteArray = c;
  for (var e = [], t = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, i = s.length; r < i; ++r)
    e[r] = s[r], t[s.charCodeAt(r)] = r;
  t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
  function a(h) {
    var p = h.length;
    if (p % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var g = h.indexOf("=");
    g === -1 && (g = p);
    var m = g === p ? 0 : 4 - g % 4;
    return [g, m];
  }
  function o(h) {
    var p = a(h), g = p[0], m = p[1];
    return (g + m) * 3 / 4 - m;
  }
  function l(h, p, g) {
    return (p + g) * 3 / 4 - g;
  }
  function f(h) {
    var p, g = a(h), m = g[0], v = g[1], y = new n(l(h, m, v)), E = 0, C = v > 0 ? m - 4 : m, x;
    for (x = 0; x < C; x += 4)
      p = t[h.charCodeAt(x)] << 18 | t[h.charCodeAt(x + 1)] << 12 | t[h.charCodeAt(x + 2)] << 6 | t[h.charCodeAt(x + 3)], y[E++] = p >> 16 & 255, y[E++] = p >> 8 & 255, y[E++] = p & 255;
    return v === 2 && (p = t[h.charCodeAt(x)] << 2 | t[h.charCodeAt(x + 1)] >> 4, y[E++] = p & 255), v === 1 && (p = t[h.charCodeAt(x)] << 10 | t[h.charCodeAt(x + 1)] << 4 | t[h.charCodeAt(x + 2)] >> 2, y[E++] = p >> 8 & 255, y[E++] = p & 255), y;
  }
  function d(h) {
    return e[h >> 18 & 63] + e[h >> 12 & 63] + e[h >> 6 & 63] + e[h & 63];
  }
  function u(h, p, g) {
    for (var m, v = [], y = p; y < g; y += 3)
      m = (h[y] << 16 & 16711680) + (h[y + 1] << 8 & 65280) + (h[y + 2] & 255), v.push(d(m));
    return v.join("");
  }
  function c(h) {
    for (var p, g = h.length, m = g % 3, v = [], y = 16383, E = 0, C = g - m; E < C; E += y)
      v.push(u(h, E, E + y > C ? C : E + y));
    return m === 1 ? (p = h[g - 1], v.push(
      e[p >> 2] + e[p << 4 & 63] + "=="
    )) : m === 2 && (p = (h[g - 2] << 8) + h[g - 1], v.push(
      e[p >> 10] + e[p >> 4 & 63] + e[p << 2 & 63] + "="
    )), v.join("");
  }
  return Nu;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var ub;
function Xf() {
  return ub || (ub = 1, function(e) {
    var t = X3(), n = Bf, s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = o, e.SlowBuffer = y, e.INSPECT_MAX_BYTES = 50;
    var r = 2147483647;
    e.kMaxLength = r, o.TYPED_ARRAY_SUPPORT = i(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function i() {
      try {
        var F = new Uint8Array(1), M = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(M, Uint8Array.prototype), Object.setPrototypeOf(F, M), F.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function a(F) {
      if (F > r)
        throw new RangeError('The value "' + F + '" is invalid for option "size"');
      var M = new Uint8Array(F);
      return Object.setPrototypeOf(M, o.prototype), M;
    }
    function o(F, M, I) {
      if (typeof F == "number") {
        if (typeof M == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return u(F);
      }
      return l(F, M, I);
    }
    o.poolSize = 8192;
    function l(F, M, I) {
      if (typeof F == "string")
        return c(F, M);
      if (ArrayBuffer.isView(F))
        return p(F);
      if (F == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof F
        );
      if (at(F, ArrayBuffer) || F && at(F.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (at(F, SharedArrayBuffer) || F && at(F.buffer, SharedArrayBuffer)))
        return g(F, M, I);
      if (typeof F == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var N = F.valueOf && F.valueOf();
      if (N != null && N !== F)
        return o.from(N, M, I);
      var G = m(F);
      if (G)
        return G;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof F[Symbol.toPrimitive] == "function")
        return o.from(
          F[Symbol.toPrimitive]("string"),
          M,
          I
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof F
      );
    }
    o.from = function(F, M, I) {
      return l(F, M, I);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function f(F) {
      if (typeof F != "number")
        throw new TypeError('"size" argument must be of type number');
      if (F < 0)
        throw new RangeError('The value "' + F + '" is invalid for option "size"');
    }
    function d(F, M, I) {
      return f(F), F <= 0 ? a(F) : M !== void 0 ? typeof I == "string" ? a(F).fill(M, I) : a(F).fill(M) : a(F);
    }
    o.alloc = function(F, M, I) {
      return d(F, M, I);
    };
    function u(F) {
      return f(F), a(F < 0 ? 0 : v(F) | 0);
    }
    o.allocUnsafe = function(F) {
      return u(F);
    }, o.allocUnsafeSlow = function(F) {
      return u(F);
    };
    function c(F, M) {
      if ((typeof M != "string" || M === "") && (M = "utf8"), !o.isEncoding(M))
        throw new TypeError("Unknown encoding: " + M);
      var I = E(F, M) | 0, N = a(I), G = N.write(F, M);
      return G !== I && (N = N.slice(0, G)), N;
    }
    function h(F) {
      for (var M = F.length < 0 ? 0 : v(F.length) | 0, I = a(M), N = 0; N < M; N += 1)
        I[N] = F[N] & 255;
      return I;
    }
    function p(F) {
      if (at(F, Uint8Array)) {
        var M = new Uint8Array(F);
        return g(M.buffer, M.byteOffset, M.byteLength);
      }
      return h(F);
    }
    function g(F, M, I) {
      if (M < 0 || F.byteLength < M)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (F.byteLength < M + (I || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var N;
      return M === void 0 && I === void 0 ? N = new Uint8Array(F) : I === void 0 ? N = new Uint8Array(F, M) : N = new Uint8Array(F, M, I), Object.setPrototypeOf(N, o.prototype), N;
    }
    function m(F) {
      if (o.isBuffer(F)) {
        var M = v(F.length) | 0, I = a(M);
        return I.length === 0 || F.copy(I, 0, 0, M), I;
      }
      if (F.length !== void 0)
        return typeof F.length != "number" || ct(F.length) ? a(0) : h(F);
      if (F.type === "Buffer" && Array.isArray(F.data))
        return h(F.data);
    }
    function v(F) {
      if (F >= r)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
      return F | 0;
    }
    function y(F) {
      return +F != F && (F = 0), o.alloc(+F);
    }
    o.isBuffer = function(M) {
      return M != null && M._isBuffer === !0 && M !== o.prototype;
    }, o.compare = function(M, I) {
      if (at(M, Uint8Array) && (M = o.from(M, M.offset, M.byteLength)), at(I, Uint8Array) && (I = o.from(I, I.offset, I.byteLength)), !o.isBuffer(M) || !o.isBuffer(I))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (M === I)
        return 0;
      for (var N = M.length, G = I.length, nt = 0, lt = Math.min(N, G); nt < lt; ++nt)
        if (M[nt] !== I[nt]) {
          N = M[nt], G = I[nt];
          break;
        }
      return N < G ? -1 : G < N ? 1 : 0;
    }, o.isEncoding = function(M) {
      switch (String(M).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(M, I) {
      if (!Array.isArray(M))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (M.length === 0)
        return o.alloc(0);
      var N;
      if (I === void 0)
        for (I = 0, N = 0; N < M.length; ++N)
          I += M[N].length;
      var G = o.allocUnsafe(I), nt = 0;
      for (N = 0; N < M.length; ++N) {
        var lt = M[N];
        if (at(lt, Uint8Array))
          nt + lt.length > G.length ? o.from(lt).copy(G, nt) : Uint8Array.prototype.set.call(
            G,
            lt,
            nt
          );
        else if (o.isBuffer(lt))
          lt.copy(G, nt);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        nt += lt.length;
      }
      return G;
    };
    function E(F, M) {
      if (o.isBuffer(F))
        return F.length;
      if (ArrayBuffer.isView(F) || at(F, ArrayBuffer))
        return F.byteLength;
      if (typeof F != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof F
        );
      var I = F.length, N = arguments.length > 2 && arguments[2] === !0;
      if (!N && I === 0)
        return 0;
      for (var G = !1; ; )
        switch (M) {
          case "ascii":
          case "latin1":
          case "binary":
            return I;
          case "utf8":
          case "utf-8":
            return V(F).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return I * 2;
          case "hex":
            return I >>> 1;
          case "base64":
            return $(F).length;
          default:
            if (G)
              return N ? -1 : V(F).length;
            M = ("" + M).toLowerCase(), G = !0;
        }
    }
    o.byteLength = E;
    function C(F, M, I) {
      var N = !1;
      if ((M === void 0 || M < 0) && (M = 0), M > this.length || ((I === void 0 || I > this.length) && (I = this.length), I <= 0) || (I >>>= 0, M >>>= 0, I <= M))
        return "";
      for (F || (F = "utf8"); ; )
        switch (F) {
          case "hex":
            return X(this, M, I);
          case "utf8":
          case "utf-8":
            return _(this, M, I);
          case "ascii":
            return j(this, M, I);
          case "latin1":
          case "binary":
            return k(this, M, I);
          case "base64":
            return D(this, M, I);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return rt(this, M, I);
          default:
            if (N)
              throw new TypeError("Unknown encoding: " + F);
            F = (F + "").toLowerCase(), N = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function x(F, M, I) {
      var N = F[M];
      F[M] = F[I], F[I] = N;
    }
    o.prototype.swap16 = function() {
      var M = this.length;
      if (M % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var I = 0; I < M; I += 2)
        x(this, I, I + 1);
      return this;
    }, o.prototype.swap32 = function() {
      var M = this.length;
      if (M % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var I = 0; I < M; I += 4)
        x(this, I, I + 3), x(this, I + 1, I + 2);
      return this;
    }, o.prototype.swap64 = function() {
      var M = this.length;
      if (M % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var I = 0; I < M; I += 8)
        x(this, I, I + 7), x(this, I + 1, I + 6), x(this, I + 2, I + 5), x(this, I + 3, I + 4);
      return this;
    }, o.prototype.toString = function() {
      var M = this.length;
      return M === 0 ? "" : arguments.length === 0 ? _(this, 0, M) : C.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(M) {
      if (!o.isBuffer(M))
        throw new TypeError("Argument must be a Buffer");
      return this === M ? !0 : o.compare(this, M) === 0;
    }, o.prototype.inspect = function() {
      var M = "", I = e.INSPECT_MAX_BYTES;
      return M = this.toString("hex", 0, I).replace(/(.{2})/g, "$1 ").trim(), this.length > I && (M += " ... "), "<Buffer " + M + ">";
    }, s && (o.prototype[s] = o.prototype.inspect), o.prototype.compare = function(M, I, N, G, nt) {
      if (at(M, Uint8Array) && (M = o.from(M, M.offset, M.byteLength)), !o.isBuffer(M))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof M
        );
      if (I === void 0 && (I = 0), N === void 0 && (N = M ? M.length : 0), G === void 0 && (G = 0), nt === void 0 && (nt = this.length), I < 0 || N > M.length || G < 0 || nt > this.length)
        throw new RangeError("out of range index");
      if (G >= nt && I >= N)
        return 0;
      if (G >= nt)
        return -1;
      if (I >= N)
        return 1;
      if (I >>>= 0, N >>>= 0, G >>>= 0, nt >>>= 0, this === M)
        return 0;
      for (var lt = nt - G, yt = N - I, Lt = Math.min(lt, yt), Nt = this.slice(G, nt), Jt = M.slice(I, N), J = 0; J < Lt; ++J)
        if (Nt[J] !== Jt[J]) {
          lt = Nt[J], yt = Jt[J];
          break;
        }
      return lt < yt ? -1 : yt < lt ? 1 : 0;
    };
    function b(F, M, I, N, G) {
      if (F.length === 0)
        return -1;
      if (typeof I == "string" ? (N = I, I = 0) : I > 2147483647 ? I = 2147483647 : I < -2147483648 && (I = -2147483648), I = +I, ct(I) && (I = G ? 0 : F.length - 1), I < 0 && (I = F.length + I), I >= F.length) {
        if (G)
          return -1;
        I = F.length - 1;
      } else if (I < 0)
        if (G)
          I = 0;
        else
          return -1;
      if (typeof M == "string" && (M = o.from(M, N)), o.isBuffer(M))
        return M.length === 0 ? -1 : P(F, M, I, N, G);
      if (typeof M == "number")
        return M = M & 255, typeof Uint8Array.prototype.indexOf == "function" ? G ? Uint8Array.prototype.indexOf.call(F, M, I) : Uint8Array.prototype.lastIndexOf.call(F, M, I) : P(F, [M], I, N, G);
      throw new TypeError("val must be string, number or Buffer");
    }
    function P(F, M, I, N, G) {
      var nt = 1, lt = F.length, yt = M.length;
      if (N !== void 0 && (N = String(N).toLowerCase(), N === "ucs2" || N === "ucs-2" || N === "utf16le" || N === "utf-16le")) {
        if (F.length < 2 || M.length < 2)
          return -1;
        nt = 2, lt /= 2, yt /= 2, I /= 2;
      }
      function Lt(Ct, Mt) {
        return nt === 1 ? Ct[Mt] : Ct.readUInt16BE(Mt * nt);
      }
      var Nt;
      if (G) {
        var Jt = -1;
        for (Nt = I; Nt < lt; Nt++)
          if (Lt(F, Nt) === Lt(M, Jt === -1 ? 0 : Nt - Jt)) {
            if (Jt === -1 && (Jt = Nt), Nt - Jt + 1 === yt)
              return Jt * nt;
          } else
            Jt !== -1 && (Nt -= Nt - Jt), Jt = -1;
      } else
        for (I + yt > lt && (I = lt - yt), Nt = I; Nt >= 0; Nt--) {
          for (var J = !0, ft = 0; ft < yt; ft++)
            if (Lt(F, Nt + ft) !== Lt(M, ft)) {
              J = !1;
              break;
            }
          if (J)
            return Nt;
        }
      return -1;
    }
    o.prototype.includes = function(M, I, N) {
      return this.indexOf(M, I, N) !== -1;
    }, o.prototype.indexOf = function(M, I, N) {
      return b(this, M, I, N, !0);
    }, o.prototype.lastIndexOf = function(M, I, N) {
      return b(this, M, I, N, !1);
    };
    function T(F, M, I, N) {
      I = Number(I) || 0;
      var G = F.length - I;
      N ? (N = Number(N), N > G && (N = G)) : N = G;
      var nt = M.length;
      N > nt / 2 && (N = nt / 2);
      for (var lt = 0; lt < N; ++lt) {
        var yt = parseInt(M.substr(lt * 2, 2), 16);
        if (ct(yt))
          return lt;
        F[I + lt] = yt;
      }
      return lt;
    }
    function O(F, M, I, N) {
      return z(V(M, F.length - I), F, I, N);
    }
    function S(F, M, I, N) {
      return z(tt(M), F, I, N);
    }
    function L(F, M, I, N) {
      return z($(M), F, I, N);
    }
    function A(F, M, I, N) {
      return z(Y(M, F.length - I), F, I, N);
    }
    o.prototype.write = function(M, I, N, G) {
      if (I === void 0)
        G = "utf8", N = this.length, I = 0;
      else if (N === void 0 && typeof I == "string")
        G = I, N = this.length, I = 0;
      else if (isFinite(I))
        I = I >>> 0, isFinite(N) ? (N = N >>> 0, G === void 0 && (G = "utf8")) : (G = N, N = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var nt = this.length - I;
      if ((N === void 0 || N > nt) && (N = nt), M.length > 0 && (N < 0 || I < 0) || I > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      G || (G = "utf8");
      for (var lt = !1; ; )
        switch (G) {
          case "hex":
            return T(this, M, I, N);
          case "utf8":
          case "utf-8":
            return O(this, M, I, N);
          case "ascii":
          case "latin1":
          case "binary":
            return S(this, M, I, N);
          case "base64":
            return L(this, M, I, N);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return A(this, M, I, N);
          default:
            if (lt)
              throw new TypeError("Unknown encoding: " + G);
            G = ("" + G).toLowerCase(), lt = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function D(F, M, I) {
      return M === 0 && I === F.length ? t.fromByteArray(F) : t.fromByteArray(F.slice(M, I));
    }
    function _(F, M, I) {
      I = Math.min(F.length, I);
      for (var N = [], G = M; G < I; ) {
        var nt = F[G], lt = null, yt = nt > 239 ? 4 : nt > 223 ? 3 : nt > 191 ? 2 : 1;
        if (G + yt <= I) {
          var Lt, Nt, Jt, J;
          switch (yt) {
            case 1:
              nt < 128 && (lt = nt);
              break;
            case 2:
              Lt = F[G + 1], (Lt & 192) === 128 && (J = (nt & 31) << 6 | Lt & 63, J > 127 && (lt = J));
              break;
            case 3:
              Lt = F[G + 1], Nt = F[G + 2], (Lt & 192) === 128 && (Nt & 192) === 128 && (J = (nt & 15) << 12 | (Lt & 63) << 6 | Nt & 63, J > 2047 && (J < 55296 || J > 57343) && (lt = J));
              break;
            case 4:
              Lt = F[G + 1], Nt = F[G + 2], Jt = F[G + 3], (Lt & 192) === 128 && (Nt & 192) === 128 && (Jt & 192) === 128 && (J = (nt & 15) << 18 | (Lt & 63) << 12 | (Nt & 63) << 6 | Jt & 63, J > 65535 && J < 1114112 && (lt = J));
          }
        }
        lt === null ? (lt = 65533, yt = 1) : lt > 65535 && (lt -= 65536, N.push(lt >>> 10 & 1023 | 55296), lt = 56320 | lt & 1023), N.push(lt), G += yt;
      }
      return B(N);
    }
    var w = 4096;
    function B(F) {
      var M = F.length;
      if (M <= w)
        return String.fromCharCode.apply(String, F);
      for (var I = "", N = 0; N < M; )
        I += String.fromCharCode.apply(
          String,
          F.slice(N, N += w)
        );
      return I;
    }
    function j(F, M, I) {
      var N = "";
      I = Math.min(F.length, I);
      for (var G = M; G < I; ++G)
        N += String.fromCharCode(F[G] & 127);
      return N;
    }
    function k(F, M, I) {
      var N = "";
      I = Math.min(F.length, I);
      for (var G = M; G < I; ++G)
        N += String.fromCharCode(F[G]);
      return N;
    }
    function X(F, M, I) {
      var N = F.length;
      (!M || M < 0) && (M = 0), (!I || I < 0 || I > N) && (I = N);
      for (var G = "", nt = M; nt < I; ++nt)
        G += St[F[nt]];
      return G;
    }
    function rt(F, M, I) {
      for (var N = F.slice(M, I), G = "", nt = 0; nt < N.length - 1; nt += 2)
        G += String.fromCharCode(N[nt] + N[nt + 1] * 256);
      return G;
    }
    o.prototype.slice = function(M, I) {
      var N = this.length;
      M = ~~M, I = I === void 0 ? N : ~~I, M < 0 ? (M += N, M < 0 && (M = 0)) : M > N && (M = N), I < 0 ? (I += N, I < 0 && (I = 0)) : I > N && (I = N), I < M && (I = M);
      var G = this.subarray(M, I);
      return Object.setPrototypeOf(G, o.prototype), G;
    };
    function et(F, M, I) {
      if (F % 1 !== 0 || F < 0)
        throw new RangeError("offset is not uint");
      if (F + M > I)
        throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(M, I, N) {
      M = M >>> 0, I = I >>> 0, N || et(M, I, this.length);
      for (var G = this[M], nt = 1, lt = 0; ++lt < I && (nt *= 256); )
        G += this[M + lt] * nt;
      return G;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(M, I, N) {
      M = M >>> 0, I = I >>> 0, N || et(M, I, this.length);
      for (var G = this[M + --I], nt = 1; I > 0 && (nt *= 256); )
        G += this[M + --I] * nt;
      return G;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(M, I) {
      return M = M >>> 0, I || et(M, 1, this.length), this[M];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(M, I) {
      return M = M >>> 0, I || et(M, 2, this.length), this[M] | this[M + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(M, I) {
      return M = M >>> 0, I || et(M, 2, this.length), this[M] << 8 | this[M + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), (this[M] | this[M + 1] << 8 | this[M + 2] << 16) + this[M + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), this[M] * 16777216 + (this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3]);
    }, o.prototype.readIntLE = function(M, I, N) {
      M = M >>> 0, I = I >>> 0, N || et(M, I, this.length);
      for (var G = this[M], nt = 1, lt = 0; ++lt < I && (nt *= 256); )
        G += this[M + lt] * nt;
      return nt *= 128, G >= nt && (G -= Math.pow(2, 8 * I)), G;
    }, o.prototype.readIntBE = function(M, I, N) {
      M = M >>> 0, I = I >>> 0, N || et(M, I, this.length);
      for (var G = I, nt = 1, lt = this[M + --G]; G > 0 && (nt *= 256); )
        lt += this[M + --G] * nt;
      return nt *= 128, lt >= nt && (lt -= Math.pow(2, 8 * I)), lt;
    }, o.prototype.readInt8 = function(M, I) {
      return M = M >>> 0, I || et(M, 1, this.length), this[M] & 128 ? (255 - this[M] + 1) * -1 : this[M];
    }, o.prototype.readInt16LE = function(M, I) {
      M = M >>> 0, I || et(M, 2, this.length);
      var N = this[M] | this[M + 1] << 8;
      return N & 32768 ? N | 4294901760 : N;
    }, o.prototype.readInt16BE = function(M, I) {
      M = M >>> 0, I || et(M, 2, this.length);
      var N = this[M + 1] | this[M] << 8;
      return N & 32768 ? N | 4294901760 : N;
    }, o.prototype.readInt32LE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), this[M] | this[M + 1] << 8 | this[M + 2] << 16 | this[M + 3] << 24;
    }, o.prototype.readInt32BE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), this[M] << 24 | this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3];
    }, o.prototype.readFloatLE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), n.read(this, M, !0, 23, 4);
    }, o.prototype.readFloatBE = function(M, I) {
      return M = M >>> 0, I || et(M, 4, this.length), n.read(this, M, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(M, I) {
      return M = M >>> 0, I || et(M, 8, this.length), n.read(this, M, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(M, I) {
      return M = M >>> 0, I || et(M, 8, this.length), n.read(this, M, !1, 52, 8);
    };
    function Z(F, M, I, N, G, nt) {
      if (!o.isBuffer(F))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (M > G || M < nt)
        throw new RangeError('"value" argument is out of bounds');
      if (I + N > F.length)
        throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(M, I, N, G) {
      if (M = +M, I = I >>> 0, N = N >>> 0, !G) {
        var nt = Math.pow(2, 8 * N) - 1;
        Z(this, M, I, N, nt, 0);
      }
      var lt = 1, yt = 0;
      for (this[I] = M & 255; ++yt < N && (lt *= 256); )
        this[I + yt] = M / lt & 255;
      return I + N;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(M, I, N, G) {
      if (M = +M, I = I >>> 0, N = N >>> 0, !G) {
        var nt = Math.pow(2, 8 * N) - 1;
        Z(this, M, I, N, nt, 0);
      }
      var lt = N - 1, yt = 1;
      for (this[I + lt] = M & 255; --lt >= 0 && (yt *= 256); )
        this[I + lt] = M / yt & 255;
      return I + N;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 1, 255, 0), this[I] = M & 255, I + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 2, 65535, 0), this[I] = M & 255, this[I + 1] = M >>> 8, I + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 2, 65535, 0), this[I] = M >>> 8, this[I + 1] = M & 255, I + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 4, 4294967295, 0), this[I + 3] = M >>> 24, this[I + 2] = M >>> 16, this[I + 1] = M >>> 8, this[I] = M & 255, I + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 4, 4294967295, 0), this[I] = M >>> 24, this[I + 1] = M >>> 16, this[I + 2] = M >>> 8, this[I + 3] = M & 255, I + 4;
    }, o.prototype.writeIntLE = function(M, I, N, G) {
      if (M = +M, I = I >>> 0, !G) {
        var nt = Math.pow(2, 8 * N - 1);
        Z(this, M, I, N, nt - 1, -nt);
      }
      var lt = 0, yt = 1, Lt = 0;
      for (this[I] = M & 255; ++lt < N && (yt *= 256); )
        M < 0 && Lt === 0 && this[I + lt - 1] !== 0 && (Lt = 1), this[I + lt] = (M / yt >> 0) - Lt & 255;
      return I + N;
    }, o.prototype.writeIntBE = function(M, I, N, G) {
      if (M = +M, I = I >>> 0, !G) {
        var nt = Math.pow(2, 8 * N - 1);
        Z(this, M, I, N, nt - 1, -nt);
      }
      var lt = N - 1, yt = 1, Lt = 0;
      for (this[I + lt] = M & 255; --lt >= 0 && (yt *= 256); )
        M < 0 && Lt === 0 && this[I + lt + 1] !== 0 && (Lt = 1), this[I + lt] = (M / yt >> 0) - Lt & 255;
      return I + N;
    }, o.prototype.writeInt8 = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 1, 127, -128), M < 0 && (M = 255 + M + 1), this[I] = M & 255, I + 1;
    }, o.prototype.writeInt16LE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 2, 32767, -32768), this[I] = M & 255, this[I + 1] = M >>> 8, I + 2;
    }, o.prototype.writeInt16BE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 2, 32767, -32768), this[I] = M >>> 8, this[I + 1] = M & 255, I + 2;
    }, o.prototype.writeInt32LE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 4, 2147483647, -2147483648), this[I] = M & 255, this[I + 1] = M >>> 8, this[I + 2] = M >>> 16, this[I + 3] = M >>> 24, I + 4;
    }, o.prototype.writeInt32BE = function(M, I, N) {
      return M = +M, I = I >>> 0, N || Z(this, M, I, 4, 2147483647, -2147483648), M < 0 && (M = 4294967295 + M + 1), this[I] = M >>> 24, this[I + 1] = M >>> 16, this[I + 2] = M >>> 8, this[I + 3] = M & 255, I + 4;
    };
    function dt(F, M, I, N, G, nt) {
      if (I + N > F.length)
        throw new RangeError("Index out of range");
      if (I < 0)
        throw new RangeError("Index out of range");
    }
    function vt(F, M, I, N, G) {
      return M = +M, I = I >>> 0, G || dt(F, M, I, 4), n.write(F, M, I, N, 23, 4), I + 4;
    }
    o.prototype.writeFloatLE = function(M, I, N) {
      return vt(this, M, I, !0, N);
    }, o.prototype.writeFloatBE = function(M, I, N) {
      return vt(this, M, I, !1, N);
    };
    function bt(F, M, I, N, G) {
      return M = +M, I = I >>> 0, G || dt(F, M, I, 8), n.write(F, M, I, N, 52, 8), I + 8;
    }
    o.prototype.writeDoubleLE = function(M, I, N) {
      return bt(this, M, I, !0, N);
    }, o.prototype.writeDoubleBE = function(M, I, N) {
      return bt(this, M, I, !1, N);
    }, o.prototype.copy = function(M, I, N, G) {
      if (!o.isBuffer(M))
        throw new TypeError("argument should be a Buffer");
      if (N || (N = 0), !G && G !== 0 && (G = this.length), I >= M.length && (I = M.length), I || (I = 0), G > 0 && G < N && (G = N), G === N || M.length === 0 || this.length === 0)
        return 0;
      if (I < 0)
        throw new RangeError("targetStart out of bounds");
      if (N < 0 || N >= this.length)
        throw new RangeError("Index out of range");
      if (G < 0)
        throw new RangeError("sourceEnd out of bounds");
      G > this.length && (G = this.length), M.length - I < G - N && (G = M.length - I + N);
      var nt = G - N;
      return this === M && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(I, N, G) : Uint8Array.prototype.set.call(
        M,
        this.subarray(N, G),
        I
      ), nt;
    }, o.prototype.fill = function(M, I, N, G) {
      if (typeof M == "string") {
        if (typeof I == "string" ? (G = I, I = 0, N = this.length) : typeof N == "string" && (G = N, N = this.length), G !== void 0 && typeof G != "string")
          throw new TypeError("encoding must be a string");
        if (typeof G == "string" && !o.isEncoding(G))
          throw new TypeError("Unknown encoding: " + G);
        if (M.length === 1) {
          var nt = M.charCodeAt(0);
          (G === "utf8" && nt < 128 || G === "latin1") && (M = nt);
        }
      } else
        typeof M == "number" ? M = M & 255 : typeof M == "boolean" && (M = Number(M));
      if (I < 0 || this.length < I || this.length < N)
        throw new RangeError("Out of range index");
      if (N <= I)
        return this;
      I = I >>> 0, N = N === void 0 ? this.length : N >>> 0, M || (M = 0);
      var lt;
      if (typeof M == "number")
        for (lt = I; lt < N; ++lt)
          this[lt] = M;
      else {
        var yt = o.isBuffer(M) ? M : o.from(M, G), Lt = yt.length;
        if (Lt === 0)
          throw new TypeError('The value "' + M + '" is invalid for argument "value"');
        for (lt = 0; lt < N - I; ++lt)
          this[lt + I] = yt[lt % Lt];
      }
      return this;
    };
    var it = /[^+/0-9A-Za-z-_]/g;
    function R(F) {
      if (F = F.split("=")[0], F = F.trim().replace(it, ""), F.length < 2)
        return "";
      for (; F.length % 4 !== 0; )
        F = F + "=";
      return F;
    }
    function V(F, M) {
      M = M || 1 / 0;
      for (var I, N = F.length, G = null, nt = [], lt = 0; lt < N; ++lt) {
        if (I = F.charCodeAt(lt), I > 55295 && I < 57344) {
          if (!G) {
            if (I > 56319) {
              (M -= 3) > -1 && nt.push(239, 191, 189);
              continue;
            } else if (lt + 1 === N) {
              (M -= 3) > -1 && nt.push(239, 191, 189);
              continue;
            }
            G = I;
            continue;
          }
          if (I < 56320) {
            (M -= 3) > -1 && nt.push(239, 191, 189), G = I;
            continue;
          }
          I = (G - 55296 << 10 | I - 56320) + 65536;
        } else
          G && (M -= 3) > -1 && nt.push(239, 191, 189);
        if (G = null, I < 128) {
          if ((M -= 1) < 0)
            break;
          nt.push(I);
        } else if (I < 2048) {
          if ((M -= 2) < 0)
            break;
          nt.push(
            I >> 6 | 192,
            I & 63 | 128
          );
        } else if (I < 65536) {
          if ((M -= 3) < 0)
            break;
          nt.push(
            I >> 12 | 224,
            I >> 6 & 63 | 128,
            I & 63 | 128
          );
        } else if (I < 1114112) {
          if ((M -= 4) < 0)
            break;
          nt.push(
            I >> 18 | 240,
            I >> 12 & 63 | 128,
            I >> 6 & 63 | 128,
            I & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return nt;
    }
    function tt(F) {
      for (var M = [], I = 0; I < F.length; ++I)
        M.push(F.charCodeAt(I) & 255);
      return M;
    }
    function Y(F, M) {
      for (var I, N, G, nt = [], lt = 0; lt < F.length && !((M -= 2) < 0); ++lt)
        I = F.charCodeAt(lt), N = I >> 8, G = I % 256, nt.push(G), nt.push(N);
      return nt;
    }
    function $(F) {
      return t.toByteArray(R(F));
    }
    function z(F, M, I, N) {
      for (var G = 0; G < N && !(G + I >= M.length || G >= F.length); ++G)
        M[G + I] = F[G];
      return G;
    }
    function at(F, M) {
      return F instanceof M || F != null && F.constructor != null && F.constructor.name != null && F.constructor.name === M.name;
    }
    function ct(F) {
      return F !== F;
    }
    var St = function() {
      for (var F = "0123456789abcdef", M = new Array(256), I = 0; I < 16; ++I)
        for (var N = I * 16, G = 0; G < 16; ++G)
          M[N + G] = F[I] + F[G];
      return M;
    }();
  }(Om)), Om;
}
const Z3 = {}, J3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Z3
}, Symbol.toStringTag, { value: "Module" })), aS = /* @__PURE__ */ eM(J3);
var Tm, cb;
function Q3() {
  if (cb)
    return Tm;
  cb = 1;
  function e(p, g) {
    var m = Object.keys(p);
    if (Object.getOwnPropertySymbols) {
      var v = Object.getOwnPropertySymbols(p);
      g && (v = v.filter(function(y) {
        return Object.getOwnPropertyDescriptor(p, y).enumerable;
      })), m.push.apply(m, v);
    }
    return m;
  }
  function t(p) {
    for (var g = 1; g < arguments.length; g++) {
      var m = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(m), !0).forEach(function(v) {
        n(p, v, m[v]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(p, Object.getOwnPropertyDescriptors(m)) : e(Object(m)).forEach(function(v) {
        Object.defineProperty(p, v, Object.getOwnPropertyDescriptor(m, v));
      });
    }
    return p;
  }
  function n(p, g, m) {
    return g = a(g), g in p ? Object.defineProperty(p, g, { value: m, enumerable: !0, configurable: !0, writable: !0 }) : p[g] = m, p;
  }
  function s(p, g) {
    if (!(p instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(p, g) {
    for (var m = 0; m < g.length; m++) {
      var v = g[m];
      v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(p, a(v.key), v);
    }
  }
  function i(p, g, m) {
    return g && r(p.prototype, g), m && r(p, m), Object.defineProperty(p, "prototype", { writable: !1 }), p;
  }
  function a(p) {
    var g = o(p, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function o(p, g) {
    if (typeof p != "object" || p === null)
      return p;
    var m = p[Symbol.toPrimitive];
    if (m !== void 0) {
      var v = m.call(p, g || "default");
      if (typeof v != "object")
        return v;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(p);
  }
  var l = Xf(), f = l.Buffer, d = aS, u = d.inspect, c = u && u.custom || "inspect";
  function h(p, g, m) {
    f.prototype.copy.call(p, g, m);
  }
  return Tm = /* @__PURE__ */ function() {
    function p() {
      s(this, p), this.head = null, this.tail = null, this.length = 0;
    }
    return i(p, [{
      key: "push",
      value: function(m) {
        var v = {
          data: m,
          next: null
        };
        this.length > 0 ? this.tail.next = v : this.head = v, this.tail = v, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(m) {
        var v = {
          data: m,
          next: this.head
        };
        this.length === 0 && (this.tail = v), this.head = v, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var m = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, m;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(m) {
        if (this.length === 0)
          return "";
        for (var v = this.head, y = "" + v.data; v = v.next; )
          y += m + v.data;
        return y;
      }
    }, {
      key: "concat",
      value: function(m) {
        if (this.length === 0)
          return f.alloc(0);
        for (var v = f.allocUnsafe(m >>> 0), y = this.head, E = 0; y; )
          h(y.data, v, E), E += y.data.length, y = y.next;
        return v;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(m, v) {
        var y;
        return m < this.head.data.length ? (y = this.head.data.slice(0, m), this.head.data = this.head.data.slice(m)) : m === this.head.data.length ? y = this.shift() : y = v ? this._getString(m) : this._getBuffer(m), y;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(m) {
        var v = this.head, y = 1, E = v.data;
        for (m -= E.length; v = v.next; ) {
          var C = v.data, x = m > C.length ? C.length : m;
          if (x === C.length ? E += C : E += C.slice(0, m), m -= x, m === 0) {
            x === C.length ? (++y, v.next ? this.head = v.next : this.head = this.tail = null) : (this.head = v, v.data = C.slice(x));
            break;
          }
          ++y;
        }
        return this.length -= y, E;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(m) {
        var v = f.allocUnsafe(m), y = this.head, E = 1;
        for (y.data.copy(v), m -= y.data.length; y = y.next; ) {
          var C = y.data, x = m > C.length ? C.length : m;
          if (C.copy(v, v.length - m, 0, x), m -= x, m === 0) {
            x === C.length ? (++E, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = C.slice(x));
            break;
          }
          ++E;
        }
        return this.length -= E, v;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: c,
      value: function(m, v) {
        return u(this, t(t({}, v), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), p;
  }(), Tm;
}
var Pm, hb;
function oS() {
  if (hb)
    return Pm;
  hb = 1;
  function e(a, o) {
    var l = this, f = this._readableState && this._readableState.destroyed, d = this._writableState && this._writableState.destroyed;
    return f || d ? (o ? o(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(r, this, a)) : process.nextTick(r, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(u) {
      !o && u ? l._writableState ? l._writableState.errorEmitted ? process.nextTick(n, l) : (l._writableState.errorEmitted = !0, process.nextTick(t, l, u)) : process.nextTick(t, l, u) : o ? (process.nextTick(n, l), o(u)) : process.nextTick(n, l);
    }), this);
  }
  function t(a, o) {
    r(a, o), n(a);
  }
  function n(a) {
    a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
  }
  function s() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(a, o) {
    a.emit("error", o);
  }
  function i(a, o) {
    var l = a._readableState, f = a._writableState;
    l && l.autoDestroy || f && f.autoDestroy ? a.destroy(o) : a.emit("error", o);
  }
  return Pm = {
    destroy: e,
    undestroy: s,
    errorOrDestroy: i
  }, Pm;
}
var Mm = {}, db;
function xu() {
  if (db)
    return Mm;
  db = 1;
  function e(o, l) {
    o.prototype = Object.create(l.prototype), o.prototype.constructor = o, o.__proto__ = l;
  }
  var t = {};
  function n(o, l, f) {
    f || (f = Error);
    function d(c, h, p) {
      return typeof l == "string" ? l : l(c, h, p);
    }
    var u = /* @__PURE__ */ function(c) {
      e(h, c);
      function h(p, g, m) {
        return c.call(this, d(p, g, m)) || this;
      }
      return h;
    }(f);
    u.prototype.name = f.name, u.prototype.code = o, t[o] = u;
  }
  function s(o, l) {
    if (Array.isArray(o)) {
      var f = o.length;
      return o = o.map(function(d) {
        return String(d);
      }), f > 2 ? "one of ".concat(l, " ").concat(o.slice(0, f - 1).join(", "), ", or ") + o[f - 1] : f === 2 ? "one of ".concat(l, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(l, " ").concat(o[0]);
    } else
      return "of ".concat(l, " ").concat(String(o));
  }
  function r(o, l, f) {
    return o.substr(!f || f < 0 ? 0 : +f, l.length) === l;
  }
  function i(o, l, f) {
    return (f === void 0 || f > o.length) && (f = o.length), o.substring(f - l.length, f) === l;
  }
  function a(o, l, f) {
    return typeof f != "number" && (f = 0), f + l.length > o.length ? !1 : o.indexOf(l, f) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(o, l) {
    return 'The value "' + l + '" is invalid for option "' + o + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(o, l, f) {
    var d;
    typeof l == "string" && r(l, "not ") ? (d = "must not be", l = l.replace(/^not /, "")) : d = "must be";
    var u;
    if (i(o, " argument"))
      u = "The ".concat(o, " ").concat(d, " ").concat(s(l, "type"));
    else {
      var c = a(o, ".") ? "property" : "argument";
      u = 'The "'.concat(o, '" ').concat(c, " ").concat(d, " ").concat(s(l, "type"));
    }
    return u += ". Received type ".concat(typeof f), u;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Mm.codes = t, Mm;
}
var Sm, fb;
function lS() {
  if (fb)
    return Sm;
  fb = 1;
  var e = xu().codes.ERR_INVALID_OPT_VALUE;
  function t(s, r, i) {
    return s.highWaterMark != null ? s.highWaterMark : r ? s[i] : null;
  }
  function n(s, r, i, a) {
    var o = t(r, a, i);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var l = a ? i : "highWaterMark";
        throw new e(l, o);
      }
      return Math.floor(o);
    }
    return s.objectMode ? 16 : 16 * 1024;
  }
  return Sm = {
    getHighWaterMark: n
  }, Sm;
}
var Im, pb;
function q3() {
  if (pb)
    return Im;
  pb = 1, Im = e;
  function e(n, s) {
    if (t("noDeprecation"))
      return n;
    var r = !1;
    function i() {
      if (!r) {
        if (t("throwDeprecation"))
          throw new Error(s);
        t("traceDeprecation") ? console.trace(s) : console.warn(s), r = !0;
      }
      return n.apply(this, arguments);
    }
    return i;
  }
  function t(n) {
    try {
      if (!_t.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var s = _t.localStorage[n];
    return s == null ? !1 : String(s).toLowerCase() === "true";
  }
  return Im;
}
var _m, mb;
function uS() {
  if (mb)
    return _m;
  mb = 1, _m = T;
  function e(it) {
    var R = this;
    this.next = null, this.entry = null, this.finish = function() {
      bt(R, it);
    };
  }
  var t;
  T.WritableState = b;
  var n = {
    deprecate: q3()
  }, s = sS(), r = Xf().Buffer, i = (typeof _t < "u" ? _t : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(it) {
    return r.from(it);
  }
  function o(it) {
    return r.isBuffer(it) || it instanceof i;
  }
  var l = oS(), f = lS(), d = f.getHighWaterMark, u = xu().codes, c = u.ERR_INVALID_ARG_TYPE, h = u.ERR_METHOD_NOT_IMPLEMENTED, p = u.ERR_MULTIPLE_CALLBACK, g = u.ERR_STREAM_CANNOT_PIPE, m = u.ERR_STREAM_DESTROYED, v = u.ERR_STREAM_NULL_VALUES, y = u.ERR_STREAM_WRITE_AFTER_END, E = u.ERR_UNKNOWN_ENCODING, C = l.errorOrDestroy;
  Cu()(T, s);
  function x() {
  }
  function b(it, R, V) {
    t = t || iu(), it = it || {}, typeof V != "boolean" && (V = R instanceof t), this.objectMode = !!it.objectMode, V && (this.objectMode = this.objectMode || !!it.writableObjectMode), this.highWaterMark = d(this, it, "writableHighWaterMark", V), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var tt = it.decodeStrings === !1;
    this.decodeStrings = !tt, this.defaultEncoding = it.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Y) {
      B(R, Y);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = it.emitClose !== !1, this.autoDestroy = !!it.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  b.prototype.getBuffer = function() {
    for (var R = this.bufferedRequest, V = []; R; )
      V.push(R), R = R.next;
    return V;
  }, function() {
    try {
      Object.defineProperty(b.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var P;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (P = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, {
    value: function(R) {
      return P.call(this, R) ? !0 : this !== T ? !1 : R && R._writableState instanceof b;
    }
  })) : P = function(R) {
    return R instanceof this;
  };
  function T(it) {
    t = t || iu();
    var R = this instanceof t;
    if (!R && !P.call(T, this))
      return new T(it);
    this._writableState = new b(it, this, R), this.writable = !0, it && (typeof it.write == "function" && (this._write = it.write), typeof it.writev == "function" && (this._writev = it.writev), typeof it.destroy == "function" && (this._destroy = it.destroy), typeof it.final == "function" && (this._final = it.final)), s.call(this);
  }
  T.prototype.pipe = function() {
    C(this, new g());
  };
  function O(it, R) {
    var V = new y();
    C(it, V), process.nextTick(R, V);
  }
  function S(it, R, V, tt) {
    var Y;
    return V === null ? Y = new v() : typeof V != "string" && !R.objectMode && (Y = new c("chunk", ["string", "Buffer"], V)), Y ? (C(it, Y), process.nextTick(tt, Y), !1) : !0;
  }
  T.prototype.write = function(it, R, V) {
    var tt = this._writableState, Y = !1, $ = !tt.objectMode && o(it);
    return $ && !r.isBuffer(it) && (it = a(it)), typeof R == "function" && (V = R, R = null), $ ? R = "buffer" : R || (R = tt.defaultEncoding), typeof V != "function" && (V = x), tt.ending ? O(this, V) : ($ || S(this, tt, it, V)) && (tt.pendingcb++, Y = A(this, tt, $, it, R, V)), Y;
  }, T.prototype.cork = function() {
    this._writableState.corked++;
  }, T.prototype.uncork = function() {
    var it = this._writableState;
    it.corked && (it.corked--, !it.writing && !it.corked && !it.bufferProcessing && it.bufferedRequest && X(this, it));
  }, T.prototype.setDefaultEncoding = function(R) {
    if (typeof R == "string" && (R = R.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((R + "").toLowerCase()) > -1))
      throw new E(R);
    return this._writableState.defaultEncoding = R, this;
  }, Object.defineProperty(T.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function L(it, R, V) {
    return !it.objectMode && it.decodeStrings !== !1 && typeof R == "string" && (R = r.from(R, V)), R;
  }
  Object.defineProperty(T.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function A(it, R, V, tt, Y, $) {
    if (!V) {
      var z = L(R, tt, Y);
      tt !== z && (V = !0, Y = "buffer", tt = z);
    }
    var at = R.objectMode ? 1 : tt.length;
    R.length += at;
    var ct = R.length < R.highWaterMark;
    if (ct || (R.needDrain = !0), R.writing || R.corked) {
      var St = R.lastBufferedRequest;
      R.lastBufferedRequest = {
        chunk: tt,
        encoding: Y,
        isBuf: V,
        callback: $,
        next: null
      }, St ? St.next = R.lastBufferedRequest : R.bufferedRequest = R.lastBufferedRequest, R.bufferedRequestCount += 1;
    } else
      D(it, R, !1, at, tt, Y, $);
    return ct;
  }
  function D(it, R, V, tt, Y, $, z) {
    R.writelen = tt, R.writecb = z, R.writing = !0, R.sync = !0, R.destroyed ? R.onwrite(new m("write")) : V ? it._writev(Y, R.onwrite) : it._write(Y, $, R.onwrite), R.sync = !1;
  }
  function _(it, R, V, tt, Y) {
    --R.pendingcb, V ? (process.nextTick(Y, tt), process.nextTick(dt, it, R), it._writableState.errorEmitted = !0, C(it, tt)) : (Y(tt), it._writableState.errorEmitted = !0, C(it, tt), dt(it, R));
  }
  function w(it) {
    it.writing = !1, it.writecb = null, it.length -= it.writelen, it.writelen = 0;
  }
  function B(it, R) {
    var V = it._writableState, tt = V.sync, Y = V.writecb;
    if (typeof Y != "function")
      throw new p();
    if (w(V), R)
      _(it, V, tt, R, Y);
    else {
      var $ = rt(V) || it.destroyed;
      !$ && !V.corked && !V.bufferProcessing && V.bufferedRequest && X(it, V), tt ? process.nextTick(j, it, V, $, Y) : j(it, V, $, Y);
    }
  }
  function j(it, R, V, tt) {
    V || k(it, R), R.pendingcb--, tt(), dt(it, R);
  }
  function k(it, R) {
    R.length === 0 && R.needDrain && (R.needDrain = !1, it.emit("drain"));
  }
  function X(it, R) {
    R.bufferProcessing = !0;
    var V = R.bufferedRequest;
    if (it._writev && V && V.next) {
      var tt = R.bufferedRequestCount, Y = new Array(tt), $ = R.corkedRequestsFree;
      $.entry = V;
      for (var z = 0, at = !0; V; )
        Y[z] = V, V.isBuf || (at = !1), V = V.next, z += 1;
      Y.allBuffers = at, D(it, R, !0, R.length, Y, "", $.finish), R.pendingcb++, R.lastBufferedRequest = null, $.next ? (R.corkedRequestsFree = $.next, $.next = null) : R.corkedRequestsFree = new e(R), R.bufferedRequestCount = 0;
    } else {
      for (; V; ) {
        var ct = V.chunk, St = V.encoding, F = V.callback, M = R.objectMode ? 1 : ct.length;
        if (D(it, R, !1, M, ct, St, F), V = V.next, R.bufferedRequestCount--, R.writing)
          break;
      }
      V === null && (R.lastBufferedRequest = null);
    }
    R.bufferedRequest = V, R.bufferProcessing = !1;
  }
  T.prototype._write = function(it, R, V) {
    V(new h("_write()"));
  }, T.prototype._writev = null, T.prototype.end = function(it, R, V) {
    var tt = this._writableState;
    return typeof it == "function" ? (V = it, it = null, R = null) : typeof R == "function" && (V = R, R = null), it != null && this.write(it, R), tt.corked && (tt.corked = 1, this.uncork()), tt.ending || vt(this, tt, V), this;
  }, Object.defineProperty(T.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function rt(it) {
    return it.ending && it.length === 0 && it.bufferedRequest === null && !it.finished && !it.writing;
  }
  function et(it, R) {
    it._final(function(V) {
      R.pendingcb--, V && C(it, V), R.prefinished = !0, it.emit("prefinish"), dt(it, R);
    });
  }
  function Z(it, R) {
    !R.prefinished && !R.finalCalled && (typeof it._final == "function" && !R.destroyed ? (R.pendingcb++, R.finalCalled = !0, process.nextTick(et, it, R)) : (R.prefinished = !0, it.emit("prefinish")));
  }
  function dt(it, R) {
    var V = rt(R);
    if (V && (Z(it, R), R.pendingcb === 0 && (R.finished = !0, it.emit("finish"), R.autoDestroy))) {
      var tt = it._readableState;
      (!tt || tt.autoDestroy && tt.endEmitted) && it.destroy();
    }
    return V;
  }
  function vt(it, R, V) {
    R.ending = !0, dt(it, R), V && (R.finished ? process.nextTick(V) : it.once("finish", V)), R.ended = !0, it.writable = !1;
  }
  function bt(it, R, V) {
    var tt = it.entry;
    for (it.entry = null; tt; ) {
      var Y = tt.callback;
      R.pendingcb--, Y(V), tt = tt.next;
    }
    R.corkedRequestsFree.next = it;
  }
  return Object.defineProperty(T.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(R) {
      this._writableState && (this._writableState.destroyed = R);
    }
  }), T.prototype.destroy = l.destroy, T.prototype._undestroy = l.undestroy, T.prototype._destroy = function(it, R) {
    R(it);
  }, _m;
}
var Dm, gb;
function iu() {
  if (gb)
    return Dm;
  gb = 1;
  var e = Object.keys || function(f) {
    var d = [];
    for (var u in f)
      d.push(u);
    return d;
  };
  Dm = a;
  var t = cS(), n = uS();
  Cu()(a, t);
  for (var s = e(n.prototype), r = 0; r < s.length; r++) {
    var i = s[r];
    a.prototype[i] || (a.prototype[i] = n.prototype[i]);
  }
  function a(f) {
    if (!(this instanceof a))
      return new a(f);
    t.call(this, f), n.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(f) {
    f.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), Dm;
}
var Am = {}, Rh = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var vb;
function t5() {
  return vb || (vb = 1, function(e, t) {
    var n = Xf(), s = n.Buffer;
    function r(a, o) {
      for (var l in a)
        o[l] = a[l];
    }
    s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e.exports = n : (r(n, t), t.Buffer = i);
    function i(a, o, l) {
      return s(a, o, l);
    }
    i.prototype = Object.create(s.prototype), r(s, i), i.from = function(a, o, l) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return s(a, o, l);
    }, i.alloc = function(a, o, l) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var f = s(a);
      return o !== void 0 ? typeof l == "string" ? f.fill(o, l) : f.fill(o) : f.fill(0), f;
    }, i.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return s(a);
    }, i.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(a);
    };
  }(Rh, Rh.exports)), Rh.exports;
}
var yb;
function uv() {
  if (yb)
    return Am;
  yb = 1;
  var e = t5().Buffer, t = e.isEncoding || function(v) {
    switch (v = "" + v, v && v.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(v) {
    if (!v)
      return "utf8";
    for (var y; ; )
      switch (v) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return v;
        default:
          if (y)
            return;
          v = ("" + v).toLowerCase(), y = !0;
      }
  }
  function s(v) {
    var y = n(v);
    if (typeof y != "string" && (e.isEncoding === t || !t(v)))
      throw new Error("Unknown encoding: " + v);
    return y || v;
  }
  Am.StringDecoder = r;
  function r(v) {
    this.encoding = s(v);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = u, this.end = c, y = 4;
        break;
      case "utf8":
        this.fillLast = l, y = 4;
        break;
      case "base64":
        this.text = h, this.end = p, y = 3;
        break;
      default:
        this.write = g, this.end = m;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(y);
  }
  r.prototype.write = function(v) {
    if (v.length === 0)
      return "";
    var y, E;
    if (this.lastNeed) {
      if (y = this.fillLast(v), y === void 0)
        return "";
      E = this.lastNeed, this.lastNeed = 0;
    } else
      E = 0;
    return E < v.length ? y ? y + this.text(v, E) : this.text(v, E) : y || "";
  }, r.prototype.end = d, r.prototype.text = f, r.prototype.fillLast = function(v) {
    if (this.lastNeed <= v.length)
      return v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, v.length), this.lastNeed -= v.length;
  };
  function i(v) {
    return v <= 127 ? 0 : v >> 5 === 6 ? 2 : v >> 4 === 14 ? 3 : v >> 3 === 30 ? 4 : v >> 6 === 2 ? -1 : -2;
  }
  function a(v, y, E) {
    var C = y.length - 1;
    if (C < E)
      return 0;
    var x = i(y[C]);
    return x >= 0 ? (x > 0 && (v.lastNeed = x - 1), x) : --C < E || x === -2 ? 0 : (x = i(y[C]), x >= 0 ? (x > 0 && (v.lastNeed = x - 2), x) : --C < E || x === -2 ? 0 : (x = i(y[C]), x >= 0 ? (x > 0 && (x === 2 ? x = 0 : v.lastNeed = x - 3), x) : 0));
  }
  function o(v, y, E) {
    if ((y[0] & 192) !== 128)
      return v.lastNeed = 0, "�";
    if (v.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return v.lastNeed = 1, "�";
      if (v.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return v.lastNeed = 2, "�";
    }
  }
  function l(v) {
    var y = this.lastTotal - this.lastNeed, E = o(this, v);
    if (E !== void 0)
      return E;
    if (this.lastNeed <= v.length)
      return v.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    v.copy(this.lastChar, y, 0, v.length), this.lastNeed -= v.length;
  }
  function f(v, y) {
    var E = a(this, v, y);
    if (!this.lastNeed)
      return v.toString("utf8", y);
    this.lastTotal = E;
    var C = v.length - (E - this.lastNeed);
    return v.copy(this.lastChar, 0, C), v.toString("utf8", y, C);
  }
  function d(v) {
    var y = v && v.length ? this.write(v) : "";
    return this.lastNeed ? y + "�" : y;
  }
  function u(v, y) {
    if ((v.length - y) % 2 === 0) {
      var E = v.toString("utf16le", y);
      if (E) {
        var C = E.charCodeAt(E.length - 1);
        if (C >= 55296 && C <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1], E.slice(0, -1);
      }
      return E;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = v[v.length - 1], v.toString("utf16le", y, v.length - 1);
  }
  function c(v) {
    var y = v && v.length ? this.write(v) : "";
    if (this.lastNeed) {
      var E = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, E);
    }
    return y;
  }
  function h(v, y) {
    var E = (v.length - y) % 3;
    return E === 0 ? v.toString("base64", y) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = v[v.length - 1] : (this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1]), v.toString("base64", y, v.length - E));
  }
  function p(v) {
    var y = v && v.length ? this.write(v) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function g(v) {
    return v.toString(this.encoding);
  }
  function m(v) {
    return v && v.length ? this.write(v) : "";
  }
  return Am;
}
var Lm, Eb;
function $0() {
  if (Eb)
    return Lm;
  Eb = 1;
  var e = xu().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(i) {
    var a = !1;
    return function() {
      if (!a) {
        a = !0;
        for (var o = arguments.length, l = new Array(o), f = 0; f < o; f++)
          l[f] = arguments[f];
        i.apply(this, l);
      }
    };
  }
  function n() {
  }
  function s(i) {
    return i.setHeader && typeof i.abort == "function";
  }
  function r(i, a, o) {
    if (typeof a == "function")
      return r(i, null, a);
    a || (a = {}), o = t(o || n);
    var l = a.readable || a.readable !== !1 && i.readable, f = a.writable || a.writable !== !1 && i.writable, d = function() {
      i.writable || c();
    }, u = i._writableState && i._writableState.finished, c = function() {
      f = !1, u = !0, l || o.call(i);
    }, h = i._readableState && i._readableState.endEmitted, p = function() {
      l = !1, h = !0, f || o.call(i);
    }, g = function(E) {
      o.call(i, E);
    }, m = function() {
      var E;
      if (l && !h)
        return (!i._readableState || !i._readableState.ended) && (E = new e()), o.call(i, E);
      if (f && !u)
        return (!i._writableState || !i._writableState.ended) && (E = new e()), o.call(i, E);
    }, v = function() {
      i.req.on("finish", c);
    };
    return s(i) ? (i.on("complete", c), i.on("abort", m), i.req ? v() : i.on("request", v)) : f && !i._writableState && (i.on("end", d), i.on("close", d)), i.on("end", p), i.on("finish", c), a.error !== !1 && i.on("error", g), i.on("close", m), function() {
      i.removeListener("complete", c), i.removeListener("abort", m), i.removeListener("request", v), i.req && i.req.removeListener("finish", c), i.removeListener("end", d), i.removeListener("close", d), i.removeListener("finish", c), i.removeListener("end", p), i.removeListener("error", g), i.removeListener("close", m);
    };
  }
  return Lm = r, Lm;
}
var Rm, Cb;
function e5() {
  if (Cb)
    return Rm;
  Cb = 1;
  var e;
  function t(E, C, x) {
    return C = n(C), C in E ? Object.defineProperty(E, C, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : E[C] = x, E;
  }
  function n(E) {
    var C = s(E, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function s(E, C) {
    if (typeof E != "object" || E === null)
      return E;
    var x = E[Symbol.toPrimitive];
    if (x !== void 0) {
      var b = x.call(E, C || "default");
      if (typeof b != "object")
        return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (C === "string" ? String : Number)(E);
  }
  var r = $0(), i = Symbol("lastResolve"), a = Symbol("lastReject"), o = Symbol("error"), l = Symbol("ended"), f = Symbol("lastPromise"), d = Symbol("handlePromise"), u = Symbol("stream");
  function c(E, C) {
    return {
      value: E,
      done: C
    };
  }
  function h(E) {
    var C = E[i];
    if (C !== null) {
      var x = E[u].read();
      x !== null && (E[f] = null, E[i] = null, E[a] = null, C(c(x, !1)));
    }
  }
  function p(E) {
    process.nextTick(h, E);
  }
  function g(E, C) {
    return function(x, b) {
      E.then(function() {
        if (C[l]) {
          x(c(void 0, !0));
          return;
        }
        C[d](x, b);
      }, b);
    };
  }
  var m = Object.getPrototypeOf(function() {
  }), v = Object.setPrototypeOf((e = {
    get stream() {
      return this[u];
    },
    next: function() {
      var C = this, x = this[o];
      if (x !== null)
        return Promise.reject(x);
      if (this[l])
        return Promise.resolve(c(void 0, !0));
      if (this[u].destroyed)
        return new Promise(function(O, S) {
          process.nextTick(function() {
            C[o] ? S(C[o]) : O(c(void 0, !0));
          });
        });
      var b = this[f], P;
      if (b)
        P = new Promise(g(b, this));
      else {
        var T = this[u].read();
        if (T !== null)
          return Promise.resolve(c(T, !1));
        P = new Promise(this[d]);
      }
      return this[f] = P, P;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var C = this;
    return new Promise(function(x, b) {
      C[u].destroy(null, function(P) {
        if (P) {
          b(P);
          return;
        }
        x(c(void 0, !0));
      });
    });
  }), e), m), y = function(C) {
    var x, b = Object.create(v, (x = {}, t(x, u, {
      value: C,
      writable: !0
    }), t(x, i, {
      value: null,
      writable: !0
    }), t(x, a, {
      value: null,
      writable: !0
    }), t(x, o, {
      value: null,
      writable: !0
    }), t(x, l, {
      value: C._readableState.endEmitted,
      writable: !0
    }), t(x, d, {
      value: function(T, O) {
        var S = b[u].read();
        S ? (b[f] = null, b[i] = null, b[a] = null, T(c(S, !1))) : (b[i] = T, b[a] = O);
      },
      writable: !0
    }), x));
    return b[f] = null, r(C, function(P) {
      if (P && P.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var T = b[a];
        T !== null && (b[f] = null, b[i] = null, b[a] = null, T(P)), b[o] = P;
        return;
      }
      var O = b[i];
      O !== null && (b[f] = null, b[i] = null, b[a] = null, O(c(void 0, !0))), b[l] = !0;
    }), C.on("readable", p.bind(null, b)), b;
  };
  return Rm = y, Rm;
}
var wm, xb;
function n5() {
  return xb || (xb = 1, wm = function() {
    throw new Error("Readable.from is not available in the browser");
  }), wm;
}
var Vm, bb;
function cS() {
  if (bb)
    return Vm;
  bb = 1, Vm = O;
  var e;
  O.ReadableState = T, Yf().EventEmitter;
  var t = function(z, at) {
    return z.listeners(at).length;
  }, n = sS(), s = Xf().Buffer, r = (typeof _t < "u" ? _t : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function i($) {
    return s.from($);
  }
  function a($) {
    return s.isBuffer($) || $ instanceof r;
  }
  var o = aS, l;
  o && o.debuglog ? l = o.debuglog("stream") : l = function() {
  };
  var f = Q3(), d = oS(), u = lS(), c = u.getHighWaterMark, h = xu().codes, p = h.ERR_INVALID_ARG_TYPE, g = h.ERR_STREAM_PUSH_AFTER_EOF, m = h.ERR_METHOD_NOT_IMPLEMENTED, v = h.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, y, E, C;
  Cu()(O, n);
  var x = d.errorOrDestroy, b = ["error", "close", "destroy", "pause", "resume"];
  function P($, z, at) {
    if (typeof $.prependListener == "function")
      return $.prependListener(z, at);
    !$._events || !$._events[z] ? $.on(z, at) : Array.isArray($._events[z]) ? $._events[z].unshift(at) : $._events[z] = [at, $._events[z]];
  }
  function T($, z, at) {
    e = e || iu(), $ = $ || {}, typeof at != "boolean" && (at = z instanceof e), this.objectMode = !!$.objectMode, at && (this.objectMode = this.objectMode || !!$.readableObjectMode), this.highWaterMark = c(this, $, "readableHighWaterMark", at), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = $.emitClose !== !1, this.autoDestroy = !!$.autoDestroy, this.destroyed = !1, this.defaultEncoding = $.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, $.encoding && (y || (y = uv().StringDecoder), this.decoder = new y($.encoding), this.encoding = $.encoding);
  }
  function O($) {
    if (e = e || iu(), !(this instanceof O))
      return new O($);
    var z = this instanceof e;
    this._readableState = new T($, this, z), this.readable = !0, $ && (typeof $.read == "function" && (this._read = $.read), typeof $.destroy == "function" && (this._destroy = $.destroy)), n.call(this);
  }
  Object.defineProperty(O.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(z) {
      this._readableState && (this._readableState.destroyed = z);
    }
  }), O.prototype.destroy = d.destroy, O.prototype._undestroy = d.undestroy, O.prototype._destroy = function($, z) {
    z($);
  }, O.prototype.push = function($, z) {
    var at = this._readableState, ct;
    return at.objectMode ? ct = !0 : typeof $ == "string" && (z = z || at.defaultEncoding, z !== at.encoding && ($ = s.from($, z), z = ""), ct = !0), S(this, $, z, !1, ct);
  }, O.prototype.unshift = function($) {
    return S(this, $, null, !0, !1);
  };
  function S($, z, at, ct, St) {
    l("readableAddChunk", z);
    var F = $._readableState;
    if (z === null)
      F.reading = !1, B($, F);
    else {
      var M;
      if (St || (M = A(F, z)), M)
        x($, M);
      else if (F.objectMode || z && z.length > 0)
        if (typeof z != "string" && !F.objectMode && Object.getPrototypeOf(z) !== s.prototype && (z = i(z)), ct)
          F.endEmitted ? x($, new v()) : L($, F, z, !0);
        else if (F.ended)
          x($, new g());
        else {
          if (F.destroyed)
            return !1;
          F.reading = !1, F.decoder && !at ? (z = F.decoder.write(z), F.objectMode || z.length !== 0 ? L($, F, z, !1) : X($, F)) : L($, F, z, !1);
        }
      else
        ct || (F.reading = !1, X($, F));
    }
    return !F.ended && (F.length < F.highWaterMark || F.length === 0);
  }
  function L($, z, at, ct) {
    z.flowing && z.length === 0 && !z.sync ? (z.awaitDrain = 0, $.emit("data", at)) : (z.length += z.objectMode ? 1 : at.length, ct ? z.buffer.unshift(at) : z.buffer.push(at), z.needReadable && j($)), X($, z);
  }
  function A($, z) {
    var at;
    return !a(z) && typeof z != "string" && z !== void 0 && !$.objectMode && (at = new p("chunk", ["string", "Buffer", "Uint8Array"], z)), at;
  }
  O.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, O.prototype.setEncoding = function($) {
    y || (y = uv().StringDecoder);
    var z = new y($);
    this._readableState.decoder = z, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var at = this._readableState.buffer.head, ct = ""; at !== null; )
      ct += z.write(at.data), at = at.next;
    return this._readableState.buffer.clear(), ct !== "" && this._readableState.buffer.push(ct), this._readableState.length = ct.length, this;
  };
  var D = 1073741824;
  function _($) {
    return $ >= D ? $ = D : ($--, $ |= $ >>> 1, $ |= $ >>> 2, $ |= $ >>> 4, $ |= $ >>> 8, $ |= $ >>> 16, $++), $;
  }
  function w($, z) {
    return $ <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : $ !== $ ? z.flowing && z.length ? z.buffer.head.data.length : z.length : ($ > z.highWaterMark && (z.highWaterMark = _($)), $ <= z.length ? $ : z.ended ? z.length : (z.needReadable = !0, 0));
  }
  O.prototype.read = function($) {
    l("read", $), $ = parseInt($, 10);
    var z = this._readableState, at = $;
    if ($ !== 0 && (z.emittedReadable = !1), $ === 0 && z.needReadable && ((z.highWaterMark !== 0 ? z.length >= z.highWaterMark : z.length > 0) || z.ended))
      return l("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? V(this) : j(this), null;
    if ($ = w($, z), $ === 0 && z.ended)
      return z.length === 0 && V(this), null;
    var ct = z.needReadable;
    l("need readable", ct), (z.length === 0 || z.length - $ < z.highWaterMark) && (ct = !0, l("length less than watermark", ct)), z.ended || z.reading ? (ct = !1, l("reading or ended", ct)) : ct && (l("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || ($ = w(at, z)));
    var St;
    return $ > 0 ? St = R($, z) : St = null, St === null ? (z.needReadable = z.length <= z.highWaterMark, $ = 0) : (z.length -= $, z.awaitDrain = 0), z.length === 0 && (z.ended || (z.needReadable = !0), at !== $ && z.ended && V(this)), St !== null && this.emit("data", St), St;
  };
  function B($, z) {
    if (l("onEofChunk"), !z.ended) {
      if (z.decoder) {
        var at = z.decoder.end();
        at && at.length && (z.buffer.push(at), z.length += z.objectMode ? 1 : at.length);
      }
      z.ended = !0, z.sync ? j($) : (z.needReadable = !1, z.emittedReadable || (z.emittedReadable = !0, k($)));
    }
  }
  function j($) {
    var z = $._readableState;
    l("emitReadable", z.needReadable, z.emittedReadable), z.needReadable = !1, z.emittedReadable || (l("emitReadable", z.flowing), z.emittedReadable = !0, process.nextTick(k, $));
  }
  function k($) {
    var z = $._readableState;
    l("emitReadable_", z.destroyed, z.length, z.ended), !z.destroyed && (z.length || z.ended) && ($.emit("readable"), z.emittedReadable = !1), z.needReadable = !z.flowing && !z.ended && z.length <= z.highWaterMark, it($);
  }
  function X($, z) {
    z.readingMore || (z.readingMore = !0, process.nextTick(rt, $, z));
  }
  function rt($, z) {
    for (; !z.reading && !z.ended && (z.length < z.highWaterMark || z.flowing && z.length === 0); ) {
      var at = z.length;
      if (l("maybeReadMore read 0"), $.read(0), at === z.length)
        break;
    }
    z.readingMore = !1;
  }
  O.prototype._read = function($) {
    x(this, new m("_read()"));
  }, O.prototype.pipe = function($, z) {
    var at = this, ct = this._readableState;
    switch (ct.pipesCount) {
      case 0:
        ct.pipes = $;
        break;
      case 1:
        ct.pipes = [ct.pipes, $];
        break;
      default:
        ct.pipes.push($);
        break;
    }
    ct.pipesCount += 1, l("pipe count=%d opts=%j", ct.pipesCount, z);
    var St = (!z || z.end !== !1) && $ !== process.stdout && $ !== process.stderr, F = St ? I : Jt;
    ct.endEmitted ? process.nextTick(F) : at.once("end", F), $.on("unpipe", M);
    function M(J, ft) {
      l("onunpipe"), J === at && ft && ft.hasUnpiped === !1 && (ft.hasUnpiped = !0, nt());
    }
    function I() {
      l("onend"), $.end();
    }
    var N = et(at);
    $.on("drain", N);
    var G = !1;
    function nt() {
      l("cleanup"), $.removeListener("close", Lt), $.removeListener("finish", Nt), $.removeListener("drain", N), $.removeListener("error", yt), $.removeListener("unpipe", M), at.removeListener("end", I), at.removeListener("end", Jt), at.removeListener("data", lt), G = !0, ct.awaitDrain && (!$._writableState || $._writableState.needDrain) && N();
    }
    at.on("data", lt);
    function lt(J) {
      l("ondata");
      var ft = $.write(J);
      l("dest.write", ft), ft === !1 && ((ct.pipesCount === 1 && ct.pipes === $ || ct.pipesCount > 1 && Y(ct.pipes, $) !== -1) && !G && (l("false write response, pause", ct.awaitDrain), ct.awaitDrain++), at.pause());
    }
    function yt(J) {
      l("onerror", J), Jt(), $.removeListener("error", yt), t($, "error") === 0 && x($, J);
    }
    P($, "error", yt);
    function Lt() {
      $.removeListener("finish", Nt), Jt();
    }
    $.once("close", Lt);
    function Nt() {
      l("onfinish"), $.removeListener("close", Lt), Jt();
    }
    $.once("finish", Nt);
    function Jt() {
      l("unpipe"), at.unpipe($);
    }
    return $.emit("pipe", at), ct.flowing || (l("pipe resume"), at.resume()), $;
  };
  function et($) {
    return function() {
      var at = $._readableState;
      l("pipeOnDrain", at.awaitDrain), at.awaitDrain && at.awaitDrain--, at.awaitDrain === 0 && t($, "data") && (at.flowing = !0, it($));
    };
  }
  O.prototype.unpipe = function($) {
    var z = this._readableState, at = {
      hasUnpiped: !1
    };
    if (z.pipesCount === 0)
      return this;
    if (z.pipesCount === 1)
      return $ && $ !== z.pipes ? this : ($ || ($ = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, $ && $.emit("unpipe", this, at), this);
    if (!$) {
      var ct = z.pipes, St = z.pipesCount;
      z.pipes = null, z.pipesCount = 0, z.flowing = !1;
      for (var F = 0; F < St; F++)
        ct[F].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var M = Y(z.pipes, $);
    return M === -1 ? this : (z.pipes.splice(M, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), $.emit("unpipe", this, at), this);
  }, O.prototype.on = function($, z) {
    var at = n.prototype.on.call(this, $, z), ct = this._readableState;
    return $ === "data" ? (ct.readableListening = this.listenerCount("readable") > 0, ct.flowing !== !1 && this.resume()) : $ === "readable" && !ct.endEmitted && !ct.readableListening && (ct.readableListening = ct.needReadable = !0, ct.flowing = !1, ct.emittedReadable = !1, l("on readable", ct.length, ct.reading), ct.length ? j(this) : ct.reading || process.nextTick(dt, this)), at;
  }, O.prototype.addListener = O.prototype.on, O.prototype.removeListener = function($, z) {
    var at = n.prototype.removeListener.call(this, $, z);
    return $ === "readable" && process.nextTick(Z, this), at;
  }, O.prototype.removeAllListeners = function($) {
    var z = n.prototype.removeAllListeners.apply(this, arguments);
    return ($ === "readable" || $ === void 0) && process.nextTick(Z, this), z;
  };
  function Z($) {
    var z = $._readableState;
    z.readableListening = $.listenerCount("readable") > 0, z.resumeScheduled && !z.paused ? z.flowing = !0 : $.listenerCount("data") > 0 && $.resume();
  }
  function dt($) {
    l("readable nexttick read 0"), $.read(0);
  }
  O.prototype.resume = function() {
    var $ = this._readableState;
    return $.flowing || (l("resume"), $.flowing = !$.readableListening, vt(this, $)), $.paused = !1, this;
  };
  function vt($, z) {
    z.resumeScheduled || (z.resumeScheduled = !0, process.nextTick(bt, $, z));
  }
  function bt($, z) {
    l("resume", z.reading), z.reading || $.read(0), z.resumeScheduled = !1, $.emit("resume"), it($), z.flowing && !z.reading && $.read(0);
  }
  O.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function it($) {
    var z = $._readableState;
    for (l("flow", z.flowing); z.flowing && $.read() !== null; )
      ;
  }
  O.prototype.wrap = function($) {
    var z = this, at = this._readableState, ct = !1;
    $.on("end", function() {
      if (l("wrapped end"), at.decoder && !at.ended) {
        var M = at.decoder.end();
        M && M.length && z.push(M);
      }
      z.push(null);
    }), $.on("data", function(M) {
      if (l("wrapped data"), at.decoder && (M = at.decoder.write(M)), !(at.objectMode && M == null) && !(!at.objectMode && (!M || !M.length))) {
        var I = z.push(M);
        I || (ct = !0, $.pause());
      }
    });
    for (var St in $)
      this[St] === void 0 && typeof $[St] == "function" && (this[St] = function(I) {
        return function() {
          return $[I].apply($, arguments);
        };
      }(St));
    for (var F = 0; F < b.length; F++)
      $.on(b[F], this.emit.bind(this, b[F]));
    return this._read = function(M) {
      l("wrapped _read", M), ct && (ct = !1, $.resume());
    }, this;
  }, typeof Symbol == "function" && (O.prototype[Symbol.asyncIterator] = function() {
    return E === void 0 && (E = e5()), E(this);
  }), Object.defineProperty(O.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(O.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(O.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(z) {
      this._readableState && (this._readableState.flowing = z);
    }
  }), O._fromList = R, Object.defineProperty(O.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function R($, z) {
    if (z.length === 0)
      return null;
    var at;
    return z.objectMode ? at = z.buffer.shift() : !$ || $ >= z.length ? (z.decoder ? at = z.buffer.join("") : z.buffer.length === 1 ? at = z.buffer.first() : at = z.buffer.concat(z.length), z.buffer.clear()) : at = z.buffer.consume($, z.decoder), at;
  }
  function V($) {
    var z = $._readableState;
    l("endReadable", z.endEmitted), z.endEmitted || (z.ended = !0, process.nextTick(tt, z, $));
  }
  function tt($, z) {
    if (l("endReadableNT", $.endEmitted, $.length), !$.endEmitted && $.length === 0 && ($.endEmitted = !0, z.readable = !1, z.emit("end"), $.autoDestroy)) {
      var at = z._writableState;
      (!at || at.autoDestroy && at.finished) && z.destroy();
    }
  }
  typeof Symbol == "function" && (O.from = function($, z) {
    return C === void 0 && (C = n5()), C(O, $, z);
  });
  function Y($, z) {
    for (var at = 0, ct = $.length; at < ct; at++)
      if ($[at] === z)
        return at;
    return -1;
  }
  return Vm;
}
var Bm, Ob;
function hS() {
  if (Ob)
    return Bm;
  Ob = 1, Bm = o;
  var e = xu().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, n = e.ERR_MULTIPLE_CALLBACK, s = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, r = e.ERR_TRANSFORM_WITH_LENGTH_0, i = iu();
  Cu()(o, i);
  function a(d, u) {
    var c = this._transformState;
    c.transforming = !1;
    var h = c.writecb;
    if (h === null)
      return this.emit("error", new n());
    c.writechunk = null, c.writecb = null, u != null && this.push(u), h(d);
    var p = this._readableState;
    p.reading = !1, (p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
  }
  function o(d) {
    if (!(this instanceof o))
      return new o(d);
    i.call(this, d), this._transformState = {
      afterTransform: a.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, d && (typeof d.transform == "function" && (this._transform = d.transform), typeof d.flush == "function" && (this._flush = d.flush)), this.on("prefinish", l);
  }
  function l() {
    var d = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
      f(d, u, c);
    }) : f(this, null, null);
  }
  o.prototype.push = function(d, u) {
    return this._transformState.needTransform = !1, i.prototype.push.call(this, d, u);
  }, o.prototype._transform = function(d, u, c) {
    c(new t("_transform()"));
  }, o.prototype._write = function(d, u, c) {
    var h = this._transformState;
    if (h.writecb = c, h.writechunk = d, h.writeencoding = u, !h.transforming) {
      var p = this._readableState;
      (h.needTransform || p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
    }
  }, o.prototype._read = function(d) {
    var u = this._transformState;
    u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
  }, o.prototype._destroy = function(d, u) {
    i.prototype._destroy.call(this, d, function(c) {
      u(c);
    });
  };
  function f(d, u, c) {
    if (u)
      return d.emit("error", u);
    if (c != null && d.push(c), d._writableState.length)
      throw new r();
    if (d._transformState.transforming)
      throw new s();
    return d.push(null);
  }
  return Bm;
}
var Nm, Tb;
function i5() {
  if (Tb)
    return Nm;
  Tb = 1, Nm = t;
  var e = hS();
  Cu()(t, e);
  function t(n) {
    if (!(this instanceof t))
      return new t(n);
    e.call(this, n);
  }
  return t.prototype._transform = function(n, s, r) {
    r(null, n);
  }, Nm;
}
var Fm, Pb;
function r5() {
  if (Pb)
    return Fm;
  Pb = 1;
  var e;
  function t(c) {
    var h = !1;
    return function() {
      h || (h = !0, c.apply(void 0, arguments));
    };
  }
  var n = xu().codes, s = n.ERR_MISSING_ARGS, r = n.ERR_STREAM_DESTROYED;
  function i(c) {
    if (c)
      throw c;
  }
  function a(c) {
    return c.setHeader && typeof c.abort == "function";
  }
  function o(c, h, p, g) {
    g = t(g);
    var m = !1;
    c.on("close", function() {
      m = !0;
    }), e === void 0 && (e = $0()), e(c, {
      readable: h,
      writable: p
    }, function(y) {
      if (y)
        return g(y);
      m = !0, g();
    });
    var v = !1;
    return function(y) {
      if (!m && !v) {
        if (v = !0, a(c))
          return c.abort();
        if (typeof c.destroy == "function")
          return c.destroy();
        g(y || new r("pipe"));
      }
    };
  }
  function l(c) {
    c();
  }
  function f(c, h) {
    return c.pipe(h);
  }
  function d(c) {
    return !c.length || typeof c[c.length - 1] != "function" ? i : c.pop();
  }
  function u() {
    for (var c = arguments.length, h = new Array(c), p = 0; p < c; p++)
      h[p] = arguments[p];
    var g = d(h);
    if (Array.isArray(h[0]) && (h = h[0]), h.length < 2)
      throw new s("streams");
    var m, v = h.map(function(y, E) {
      var C = E < h.length - 1, x = E > 0;
      return o(y, C, x, function(b) {
        m || (m = b), b && v.forEach(l), !C && (v.forEach(l), g(m));
      });
    });
    return h.reduce(f);
  }
  return Fm = u, Fm;
}
var jm, Mb;
function s5() {
  if (Mb)
    return jm;
  Mb = 1, jm = n;
  var e = Yf().EventEmitter, t = Cu();
  t(n, e), n.Readable = cS(), n.Writable = uS(), n.Duplex = iu(), n.Transform = hS(), n.PassThrough = i5(), n.finished = $0(), n.pipeline = r5(), n.Stream = n;
  function n() {
    e.call(this);
  }
  return n.prototype.pipe = function(s, r) {
    var i = this;
    function a(h) {
      s.writable && s.write(h) === !1 && i.pause && i.pause();
    }
    i.on("data", a);
    function o() {
      i.readable && i.resume && i.resume();
    }
    s.on("drain", o), !s._isStdio && (!r || r.end !== !1) && (i.on("end", f), i.on("close", d));
    var l = !1;
    function f() {
      l || (l = !0, s.end());
    }
    function d() {
      l || (l = !0, typeof s.destroy == "function" && s.destroy());
    }
    function u(h) {
      if (c(), e.listenerCount(this, "error") === 0)
        throw h;
    }
    i.on("error", u), s.on("error", u);
    function c() {
      i.removeListener("data", a), s.removeListener("drain", o), i.removeListener("end", f), i.removeListener("close", d), i.removeListener("error", u), s.removeListener("error", u), i.removeListener("end", c), i.removeListener("close", c), s.removeListener("close", c);
    }
    return i.on("end", c), i.on("close", c), s.on("close", c), s.emit("pipe", i), s;
  }, jm;
}
var Sb;
function a5() {
  return Sb || (Sb = 1, function(e) {
    (function(t) {
      t.parser = function(R, V) {
        return new s(R, V);
      }, t.SAXParser = s, t.SAXStream = d, t.createStream = f, t.MAX_BUFFER_LENGTH = 64 * 1024;
      var n = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      t.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function s(R, V) {
        if (!(this instanceof s))
          return new s(R, V);
        var tt = this;
        i(tt), tt.q = tt.c = "", tt.bufferCheckPosition = t.MAX_BUFFER_LENGTH, tt.opt = V || {}, tt.opt.lowercase = tt.opt.lowercase || tt.opt.lowercasetags, tt.looseCase = tt.opt.lowercase ? "toLowerCase" : "toUpperCase", tt.tags = [], tt.closed = tt.closedRoot = tt.sawRoot = !1, tt.tag = tt.error = null, tt.strict = !!R, tt.noscript = !!(R || tt.opt.noscript), tt.state = O.BEGIN, tt.strictEntities = tt.opt.strictEntities, tt.ENTITIES = tt.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), tt.attribList = [], tt.opt.xmlns && (tt.ns = Object.create(g)), tt.trackPosition = tt.opt.position !== !1, tt.trackPosition && (tt.position = tt.line = tt.column = 0), L(tt, "onready");
      }
      Object.create || (Object.create = function(R) {
        function V() {
        }
        V.prototype = R;
        var tt = new V();
        return tt;
      }), Object.keys || (Object.keys = function(R) {
        var V = [];
        for (var tt in R)
          R.hasOwnProperty(tt) && V.push(tt);
        return V;
      });
      function r(R) {
        for (var V = Math.max(t.MAX_BUFFER_LENGTH, 10), tt = 0, Y = 0, $ = n.length; Y < $; Y++) {
          var z = R[n[Y]].length;
          if (z > V)
            switch (n[Y]) {
              case "textNode":
                D(R);
                break;
              case "cdata":
                A(R, "oncdata", R.cdata), R.cdata = "";
                break;
              case "script":
                A(R, "onscript", R.script), R.script = "";
                break;
              default:
                w(R, "Max buffer length exceeded: " + n[Y]);
            }
          tt = Math.max(tt, z);
        }
        var at = t.MAX_BUFFER_LENGTH - tt;
        R.bufferCheckPosition = at + R.position;
      }
      function i(R) {
        for (var V = 0, tt = n.length; V < tt; V++)
          R[n[V]] = "";
      }
      function a(R) {
        D(R), R.cdata !== "" && (A(R, "oncdata", R.cdata), R.cdata = ""), R.script !== "" && (A(R, "onscript", R.script), R.script = "");
      }
      s.prototype = {
        end: function() {
          B(this);
        },
        write: it,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          a(this);
        }
      };
      var o;
      try {
        o = s5().Stream;
      } catch {
        o = function() {
        };
      }
      o || (o = function() {
      });
      var l = t.EVENTS.filter(function(R) {
        return R !== "error" && R !== "end";
      });
      function f(R, V) {
        return new d(R, V);
      }
      function d(R, V) {
        if (!(this instanceof d))
          return new d(R, V);
        o.apply(this), this._parser = new s(R, V), this.writable = !0, this.readable = !0;
        var tt = this;
        this._parser.onend = function() {
          tt.emit("end");
        }, this._parser.onerror = function(Y) {
          tt.emit("error", Y), tt._parser.error = null;
        }, this._decoder = null, l.forEach(function(Y) {
          Object.defineProperty(tt, "on" + Y, {
            get: function() {
              return tt._parser["on" + Y];
            },
            set: function($) {
              if (!$)
                return tt.removeAllListeners(Y), tt._parser["on" + Y] = $, $;
              tt.on(Y, $);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      d.prototype = Object.create(o.prototype, {
        constructor: {
          value: d
        }
      }), d.prototype.write = function(R) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(R)) {
          if (!this._decoder) {
            var V = uv().StringDecoder;
            this._decoder = new V("utf8");
          }
          R = this._decoder.write(R);
        }
        return this._parser.write(R.toString()), this.emit("data", R), !0;
      }, d.prototype.end = function(R) {
        return R && R.length && this.write(R), this._parser.end(), !0;
      }, d.prototype.on = function(R, V) {
        var tt = this;
        return !tt._parser["on" + R] && l.indexOf(R) !== -1 && (tt._parser["on" + R] = function() {
          var Y = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          Y.splice(0, 0, R), tt.emit.apply(tt, Y);
        }), o.prototype.on.call(tt, R, V);
      };
      var u = "[CDATA[", c = "DOCTYPE", h = "http://www.w3.org/XML/1998/namespace", p = "http://www.w3.org/2000/xmlns/", g = { xml: h, xmlns: p }, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, v = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function C(R) {
        return R === " " || R === `
` || R === "\r" || R === "	";
      }
      function x(R) {
        return R === '"' || R === "'";
      }
      function b(R) {
        return R === ">" || C(R);
      }
      function P(R, V) {
        return R.test(V);
      }
      function T(R, V) {
        return !P(R, V);
      }
      var O = 0;
      t.STATE = {
        BEGIN: O++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: O++,
        // leading whitespace
        TEXT: O++,
        // general stuff
        TEXT_ENTITY: O++,
        // &amp and such.
        OPEN_WAKA: O++,
        // <
        SGML_DECL: O++,
        // <!BLARG
        SGML_DECL_QUOTED: O++,
        // <!BLARG foo "bar
        DOCTYPE: O++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: O++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: O++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: O++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: O++,
        // <!-
        COMMENT: O++,
        // <!--
        COMMENT_ENDING: O++,
        // <!-- blah -
        COMMENT_ENDED: O++,
        // <!-- blah --
        CDATA: O++,
        // <![CDATA[ something
        CDATA_ENDING: O++,
        // ]
        CDATA_ENDING_2: O++,
        // ]]
        PROC_INST: O++,
        // <?hi
        PROC_INST_BODY: O++,
        // <?hi there
        PROC_INST_ENDING: O++,
        // <?hi "there" ?
        OPEN_TAG: O++,
        // <strong
        OPEN_TAG_SLASH: O++,
        // <strong /
        ATTRIB: O++,
        // <a
        ATTRIB_NAME: O++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: O++,
        // <a foo _
        ATTRIB_VALUE: O++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: O++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: O++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: O++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: O++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: O++,
        // <foo bar=&quot
        CLOSE_TAG: O++,
        // </a
        CLOSE_TAG_SAW_WHITE: O++,
        // </a   >
        SCRIPT: O++,
        // <script> ...
        SCRIPT_ENDING: O++
        // <script> ... <
      }, t.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(t.ENTITIES).forEach(function(R) {
        var V = t.ENTITIES[R], tt = typeof V == "number" ? String.fromCharCode(V) : V;
        t.ENTITIES[R] = tt;
      });
      for (var S in t.STATE)
        t.STATE[t.STATE[S]] = S;
      O = t.STATE;
      function L(R, V, tt) {
        R[V] && R[V](tt);
      }
      function A(R, V, tt) {
        R.textNode && D(R), L(R, V, tt);
      }
      function D(R) {
        R.textNode = _(R.opt, R.textNode), R.textNode && L(R, "ontext", R.textNode), R.textNode = "";
      }
      function _(R, V) {
        return R.trim && (V = V.trim()), R.normalize && (V = V.replace(/\s+/g, " ")), V;
      }
      function w(R, V) {
        return D(R), R.trackPosition && (V += `
Line: ` + R.line + `
Column: ` + R.column + `
Char: ` + R.c), V = new Error(V), R.error = V, L(R, "onerror", V), R;
      }
      function B(R) {
        return R.sawRoot && !R.closedRoot && j(R, "Unclosed root tag"), R.state !== O.BEGIN && R.state !== O.BEGIN_WHITESPACE && R.state !== O.TEXT && w(R, "Unexpected end"), D(R), R.c = "", R.closed = !0, L(R, "onend"), s.call(R, R.strict, R.opt), R;
      }
      function j(R, V) {
        if (typeof R != "object" || !(R instanceof s))
          throw new Error("bad call to strictFail");
        R.strict && w(R, V);
      }
      function k(R) {
        R.strict || (R.tagName = R.tagName[R.looseCase]());
        var V = R.tags[R.tags.length - 1] || R, tt = R.tag = { name: R.tagName, attributes: {} };
        R.opt.xmlns && (tt.ns = V.ns), R.attribList.length = 0, A(R, "onopentagstart", tt);
      }
      function X(R, V) {
        var tt = R.indexOf(":"), Y = tt < 0 ? ["", R] : R.split(":"), $ = Y[0], z = Y[1];
        return V && R === "xmlns" && ($ = "xmlns", z = ""), { prefix: $, local: z };
      }
      function rt(R) {
        if (R.strict || (R.attribName = R.attribName[R.looseCase]()), R.attribList.indexOf(R.attribName) !== -1 || R.tag.attributes.hasOwnProperty(R.attribName)) {
          R.attribName = R.attribValue = "";
          return;
        }
        if (R.opt.xmlns) {
          var V = X(R.attribName, !0), tt = V.prefix, Y = V.local;
          if (tt === "xmlns")
            if (Y === "xml" && R.attribValue !== h)
              j(
                R,
                "xml: prefix must be bound to " + h + `
Actual: ` + R.attribValue
              );
            else if (Y === "xmlns" && R.attribValue !== p)
              j(
                R,
                "xmlns: prefix must be bound to " + p + `
Actual: ` + R.attribValue
              );
            else {
              var $ = R.tag, z = R.tags[R.tags.length - 1] || R;
              $.ns === z.ns && ($.ns = Object.create(z.ns)), $.ns[Y] = R.attribValue;
            }
          R.attribList.push([R.attribName, R.attribValue]);
        } else
          R.tag.attributes[R.attribName] = R.attribValue, A(R, "onattribute", {
            name: R.attribName,
            value: R.attribValue
          });
        R.attribName = R.attribValue = "";
      }
      function et(R, V) {
        if (R.opt.xmlns) {
          var tt = R.tag, Y = X(R.tagName);
          tt.prefix = Y.prefix, tt.local = Y.local, tt.uri = tt.ns[Y.prefix] || "", tt.prefix && !tt.uri && (j(R, "Unbound namespace prefix: " + JSON.stringify(R.tagName)), tt.uri = Y.prefix);
          var $ = R.tags[R.tags.length - 1] || R;
          tt.ns && $.ns !== tt.ns && Object.keys(tt.ns).forEach(function(lt) {
            A(R, "onopennamespace", {
              prefix: lt,
              uri: tt.ns[lt]
            });
          });
          for (var z = 0, at = R.attribList.length; z < at; z++) {
            var ct = R.attribList[z], St = ct[0], F = ct[1], M = X(St, !0), I = M.prefix, N = M.local, G = I === "" ? "" : tt.ns[I] || "", nt = {
              name: St,
              value: F,
              prefix: I,
              local: N,
              uri: G
            };
            I && I !== "xmlns" && !G && (j(R, "Unbound namespace prefix: " + JSON.stringify(I)), nt.uri = I), R.tag.attributes[St] = nt, A(R, "onattribute", nt);
          }
          R.attribList.length = 0;
        }
        R.tag.isSelfClosing = !!V, R.sawRoot = !0, R.tags.push(R.tag), A(R, "onopentag", R.tag), V || (!R.noscript && R.tagName.toLowerCase() === "script" ? R.state = O.SCRIPT : R.state = O.TEXT, R.tag = null, R.tagName = ""), R.attribName = R.attribValue = "", R.attribList.length = 0;
      }
      function Z(R) {
        if (!R.tagName) {
          j(R, "Weird empty close tag."), R.textNode += "</>", R.state = O.TEXT;
          return;
        }
        if (R.script) {
          if (R.tagName !== "script") {
            R.script += "</" + R.tagName + ">", R.tagName = "", R.state = O.SCRIPT;
            return;
          }
          A(R, "onscript", R.script), R.script = "";
        }
        var V = R.tags.length, tt = R.tagName;
        R.strict || (tt = tt[R.looseCase]());
        for (var Y = tt; V--; ) {
          var $ = R.tags[V];
          if ($.name !== Y)
            j(R, "Unexpected close tag");
          else
            break;
        }
        if (V < 0) {
          j(R, "Unmatched closing tag: " + R.tagName), R.textNode += "</" + R.tagName + ">", R.state = O.TEXT;
          return;
        }
        R.tagName = tt;
        for (var z = R.tags.length; z-- > V; ) {
          var at = R.tag = R.tags.pop();
          R.tagName = R.tag.name, A(R, "onclosetag", R.tagName);
          var ct = {};
          for (var St in at.ns)
            ct[St] = at.ns[St];
          var F = R.tags[R.tags.length - 1] || R;
          R.opt.xmlns && at.ns !== F.ns && Object.keys(at.ns).forEach(function(M) {
            var I = at.ns[M];
            A(R, "onclosenamespace", { prefix: M, uri: I });
          });
        }
        V === 0 && (R.closedRoot = !0), R.tagName = R.attribValue = R.attribName = "", R.attribList.length = 0, R.state = O.TEXT;
      }
      function dt(R) {
        var V = R.entity, tt = V.toLowerCase(), Y, $ = "";
        return R.ENTITIES[V] ? R.ENTITIES[V] : R.ENTITIES[tt] ? R.ENTITIES[tt] : (V = tt, V.charAt(0) === "#" && (V.charAt(1) === "x" ? (V = V.slice(2), Y = parseInt(V, 16), $ = Y.toString(16)) : (V = V.slice(1), Y = parseInt(V, 10), $ = Y.toString(10))), V = V.replace(/^0+/, ""), isNaN(Y) || $.toLowerCase() !== V ? (j(R, "Invalid character entity"), "&" + R.entity + ";") : String.fromCodePoint(Y));
      }
      function vt(R, V) {
        V === "<" ? (R.state = O.OPEN_WAKA, R.startTagPosition = R.position) : C(V) || (j(R, "Non-whitespace before first tag."), R.textNode = V, R.state = O.TEXT);
      }
      function bt(R, V) {
        var tt = "";
        return V < R.length && (tt = R.charAt(V)), tt;
      }
      function it(R) {
        var V = this;
        if (this.error)
          throw this.error;
        if (V.closed)
          return w(
            V,
            "Cannot write after close. Assign an onready handler."
          );
        if (R === null)
          return B(V);
        typeof R == "object" && (R = R.toString());
        for (var tt = 0, Y = ""; Y = bt(R, tt++), V.c = Y, !!Y; )
          switch (V.trackPosition && (V.position++, Y === `
` ? (V.line++, V.column = 0) : V.column++), V.state) {
            case O.BEGIN:
              if (V.state = O.BEGIN_WHITESPACE, Y === "\uFEFF")
                continue;
              vt(V, Y);
              continue;
            case O.BEGIN_WHITESPACE:
              vt(V, Y);
              continue;
            case O.TEXT:
              if (V.sawRoot && !V.closedRoot) {
                for (var $ = tt - 1; Y && Y !== "<" && Y !== "&"; )
                  Y = bt(R, tt++), Y && V.trackPosition && (V.position++, Y === `
` ? (V.line++, V.column = 0) : V.column++);
                V.textNode += R.substring($, tt - 1);
              }
              Y === "<" && !(V.sawRoot && V.closedRoot && !V.strict) ? (V.state = O.OPEN_WAKA, V.startTagPosition = V.position) : (!C(Y) && (!V.sawRoot || V.closedRoot) && j(V, "Text data outside of root node."), Y === "&" ? V.state = O.TEXT_ENTITY : V.textNode += Y);
              continue;
            case O.SCRIPT:
              Y === "<" ? V.state = O.SCRIPT_ENDING : V.script += Y;
              continue;
            case O.SCRIPT_ENDING:
              Y === "/" ? V.state = O.CLOSE_TAG : (V.script += "<" + Y, V.state = O.SCRIPT);
              continue;
            case O.OPEN_WAKA:
              if (Y === "!")
                V.state = O.SGML_DECL, V.sgmlDecl = "";
              else if (!C(Y))
                if (P(m, Y))
                  V.state = O.OPEN_TAG, V.tagName = Y;
                else if (Y === "/")
                  V.state = O.CLOSE_TAG, V.tagName = "";
                else if (Y === "?")
                  V.state = O.PROC_INST, V.procInstName = V.procInstBody = "";
                else {
                  if (j(V, "Unencoded <"), V.startTagPosition + 1 < V.position) {
                    var z = V.position - V.startTagPosition;
                    Y = new Array(z).join(" ") + Y;
                  }
                  V.textNode += "<" + Y, V.state = O.TEXT;
                }
              continue;
            case O.SGML_DECL:
              (V.sgmlDecl + Y).toUpperCase() === u ? (A(V, "onopencdata"), V.state = O.CDATA, V.sgmlDecl = "", V.cdata = "") : V.sgmlDecl + Y === "--" ? (V.state = O.COMMENT, V.comment = "", V.sgmlDecl = "") : (V.sgmlDecl + Y).toUpperCase() === c ? (V.state = O.DOCTYPE, (V.doctype || V.sawRoot) && j(
                V,
                "Inappropriately located doctype declaration"
              ), V.doctype = "", V.sgmlDecl = "") : Y === ">" ? (A(V, "onsgmldeclaration", V.sgmlDecl), V.sgmlDecl = "", V.state = O.TEXT) : (x(Y) && (V.state = O.SGML_DECL_QUOTED), V.sgmlDecl += Y);
              continue;
            case O.SGML_DECL_QUOTED:
              Y === V.q && (V.state = O.SGML_DECL, V.q = ""), V.sgmlDecl += Y;
              continue;
            case O.DOCTYPE:
              Y === ">" ? (V.state = O.TEXT, A(V, "ondoctype", V.doctype), V.doctype = !0) : (V.doctype += Y, Y === "[" ? V.state = O.DOCTYPE_DTD : x(Y) && (V.state = O.DOCTYPE_QUOTED, V.q = Y));
              continue;
            case O.DOCTYPE_QUOTED:
              V.doctype += Y, Y === V.q && (V.q = "", V.state = O.DOCTYPE);
              continue;
            case O.DOCTYPE_DTD:
              V.doctype += Y, Y === "]" ? V.state = O.DOCTYPE : x(Y) && (V.state = O.DOCTYPE_DTD_QUOTED, V.q = Y);
              continue;
            case O.DOCTYPE_DTD_QUOTED:
              V.doctype += Y, Y === V.q && (V.state = O.DOCTYPE_DTD, V.q = "");
              continue;
            case O.COMMENT:
              Y === "-" ? V.state = O.COMMENT_ENDING : V.comment += Y;
              continue;
            case O.COMMENT_ENDING:
              Y === "-" ? (V.state = O.COMMENT_ENDED, V.comment = _(V.opt, V.comment), V.comment && A(V, "oncomment", V.comment), V.comment = "") : (V.comment += "-" + Y, V.state = O.COMMENT);
              continue;
            case O.COMMENT_ENDED:
              Y !== ">" ? (j(V, "Malformed comment"), V.comment += "--" + Y, V.state = O.COMMENT) : V.state = O.TEXT;
              continue;
            case O.CDATA:
              Y === "]" ? V.state = O.CDATA_ENDING : V.cdata += Y;
              continue;
            case O.CDATA_ENDING:
              Y === "]" ? V.state = O.CDATA_ENDING_2 : (V.cdata += "]" + Y, V.state = O.CDATA);
              continue;
            case O.CDATA_ENDING_2:
              Y === ">" ? (V.cdata && A(V, "oncdata", V.cdata), A(V, "onclosecdata"), V.cdata = "", V.state = O.TEXT) : Y === "]" ? V.cdata += "]" : (V.cdata += "]]" + Y, V.state = O.CDATA);
              continue;
            case O.PROC_INST:
              Y === "?" ? V.state = O.PROC_INST_ENDING : C(Y) ? V.state = O.PROC_INST_BODY : V.procInstName += Y;
              continue;
            case O.PROC_INST_BODY:
              if (!V.procInstBody && C(Y))
                continue;
              Y === "?" ? V.state = O.PROC_INST_ENDING : V.procInstBody += Y;
              continue;
            case O.PROC_INST_ENDING:
              Y === ">" ? (A(V, "onprocessinginstruction", {
                name: V.procInstName,
                body: V.procInstBody
              }), V.procInstName = V.procInstBody = "", V.state = O.TEXT) : (V.procInstBody += "?" + Y, V.state = O.PROC_INST_BODY);
              continue;
            case O.OPEN_TAG:
              P(v, Y) ? V.tagName += Y : (k(V), Y === ">" ? et(V) : Y === "/" ? V.state = O.OPEN_TAG_SLASH : (C(Y) || j(V, "Invalid character in tag name"), V.state = O.ATTRIB));
              continue;
            case O.OPEN_TAG_SLASH:
              Y === ">" ? (et(V, !0), Z(V)) : (j(V, "Forward-slash in opening tag not followed by >"), V.state = O.ATTRIB);
              continue;
            case O.ATTRIB:
              if (C(Y))
                continue;
              Y === ">" ? et(V) : Y === "/" ? V.state = O.OPEN_TAG_SLASH : P(m, Y) ? (V.attribName = Y, V.attribValue = "", V.state = O.ATTRIB_NAME) : j(V, "Invalid attribute name");
              continue;
            case O.ATTRIB_NAME:
              Y === "=" ? V.state = O.ATTRIB_VALUE : Y === ">" ? (j(V, "Attribute without value"), V.attribValue = V.attribName, rt(V), et(V)) : C(Y) ? V.state = O.ATTRIB_NAME_SAW_WHITE : P(v, Y) ? V.attribName += Y : j(V, "Invalid attribute name");
              continue;
            case O.ATTRIB_NAME_SAW_WHITE:
              if (Y === "=")
                V.state = O.ATTRIB_VALUE;
              else {
                if (C(Y))
                  continue;
                j(V, "Attribute without value"), V.tag.attributes[V.attribName] = "", V.attribValue = "", A(V, "onattribute", {
                  name: V.attribName,
                  value: ""
                }), V.attribName = "", Y === ">" ? et(V) : P(m, Y) ? (V.attribName = Y, V.state = O.ATTRIB_NAME) : (j(V, "Invalid attribute name"), V.state = O.ATTRIB);
              }
              continue;
            case O.ATTRIB_VALUE:
              if (C(Y))
                continue;
              x(Y) ? (V.q = Y, V.state = O.ATTRIB_VALUE_QUOTED) : (j(V, "Unquoted attribute value"), V.state = O.ATTRIB_VALUE_UNQUOTED, V.attribValue = Y);
              continue;
            case O.ATTRIB_VALUE_QUOTED:
              if (Y !== V.q) {
                Y === "&" ? V.state = O.ATTRIB_VALUE_ENTITY_Q : V.attribValue += Y;
                continue;
              }
              rt(V), V.q = "", V.state = O.ATTRIB_VALUE_CLOSED;
              continue;
            case O.ATTRIB_VALUE_CLOSED:
              C(Y) ? V.state = O.ATTRIB : Y === ">" ? et(V) : Y === "/" ? V.state = O.OPEN_TAG_SLASH : P(m, Y) ? (j(V, "No whitespace between attributes"), V.attribName = Y, V.attribValue = "", V.state = O.ATTRIB_NAME) : j(V, "Invalid attribute name");
              continue;
            case O.ATTRIB_VALUE_UNQUOTED:
              if (!b(Y)) {
                Y === "&" ? V.state = O.ATTRIB_VALUE_ENTITY_U : V.attribValue += Y;
                continue;
              }
              rt(V), Y === ">" ? et(V) : V.state = O.ATTRIB;
              continue;
            case O.CLOSE_TAG:
              if (V.tagName)
                Y === ">" ? Z(V) : P(v, Y) ? V.tagName += Y : V.script ? (V.script += "</" + V.tagName, V.tagName = "", V.state = O.SCRIPT) : (C(Y) || j(V, "Invalid tagname in closing tag"), V.state = O.CLOSE_TAG_SAW_WHITE);
              else {
                if (C(Y))
                  continue;
                T(m, Y) ? V.script ? (V.script += "</" + Y, V.state = O.SCRIPT) : j(V, "Invalid tagname in closing tag.") : V.tagName = Y;
              }
              continue;
            case O.CLOSE_TAG_SAW_WHITE:
              if (C(Y))
                continue;
              Y === ">" ? Z(V) : j(V, "Invalid characters in closing tag");
              continue;
            case O.TEXT_ENTITY:
            case O.ATTRIB_VALUE_ENTITY_Q:
            case O.ATTRIB_VALUE_ENTITY_U:
              var at, ct;
              switch (V.state) {
                case O.TEXT_ENTITY:
                  at = O.TEXT, ct = "textNode";
                  break;
                case O.ATTRIB_VALUE_ENTITY_Q:
                  at = O.ATTRIB_VALUE_QUOTED, ct = "attribValue";
                  break;
                case O.ATTRIB_VALUE_ENTITY_U:
                  at = O.ATTRIB_VALUE_UNQUOTED, ct = "attribValue";
                  break;
              }
              if (Y === ";")
                if (V.opt.unparsedEntities) {
                  var St = dt(V);
                  V.entity = "", V.state = at, V.write(St);
                } else
                  V[ct] += dt(V), V.entity = "", V.state = at;
              else
                P(V.entity.length ? E : y, Y) ? V.entity += Y : (j(V, "Invalid character in entity name"), V[ct] += "&" + V.entity + Y, V.entity = "", V.state = at);
              continue;
            default:
              throw new Error(V, "Unknown state: " + V.state);
          }
        return V.position >= V.bufferCheckPosition && r(V), V;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var R = String.fromCharCode, V = Math.floor, tt = function() {
          var Y = 16384, $ = [], z, at, ct = -1, St = arguments.length;
          if (!St)
            return "";
          for (var F = ""; ++ct < St; ) {
            var M = Number(arguments[ct]);
            if (!isFinite(M) || // `NaN`, `+Infinity`, or `-Infinity`
            M < 0 || // not a valid Unicode code point
            M > 1114111 || // not a valid Unicode code point
            V(M) !== M)
              throw RangeError("Invalid code point: " + M);
            M <= 65535 ? $.push(M) : (M -= 65536, z = (M >> 10) + 55296, at = M % 1024 + 56320, $.push(z, at)), (ct + 1 === St || $.length > Y) && (F += R.apply(null, $), $.length = 0);
          }
          return F;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: tt,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = tt;
      }();
    })(e);
  }(xm)), xm;
}
var Um = {}, Ib;
function o5() {
  return Ib || (Ib = 1, (function() {
    Um.stripBOM = function(e) {
      return e[0] === "\uFEFF" ? e.substring(1) : e;
    };
  }).call(_t)), Um;
}
var fo = {}, _b;
function dS() {
  return _b || (_b = 1, (function() {
    var e;
    e = new RegExp(/(?!xmlns)^.*:/), fo.normalize = function(t) {
      return t.toLowerCase();
    }, fo.firstCharLowerCase = function(t) {
      return t.charAt(0).toLowerCase() + t.slice(1);
    }, fo.stripPrefix = function(t) {
      return t.replace(e, "");
    }, fo.parseNumbers = function(t) {
      return isNaN(t) || (t = t % 1 === 0 ? parseInt(t, 10) : parseFloat(t)), t;
    }, fo.parseBooleans = function(t) {
      return /^(?:true|false)$/i.test(t) && (t = t.toLowerCase() === "true"), t;
    };
  }).call(_t)), fo;
}
var cr = {}, Db = {}, Ab;
function l5() {
  return Ab || (Ab = 1, function(e, t) {
    if (e.setImmediate)
      return;
    var n = 1, s = {}, r = !1, i = e.document, a;
    function o(y) {
      typeof y != "function" && (y = new Function("" + y));
      for (var E = new Array(arguments.length - 1), C = 0; C < E.length; C++)
        E[C] = arguments[C + 1];
      var x = { callback: y, args: E };
      return s[n] = x, a(n), n++;
    }
    function l(y) {
      delete s[y];
    }
    function f(y) {
      var E = y.callback, C = y.args;
      switch (C.length) {
        case 0:
          E();
          break;
        case 1:
          E(C[0]);
          break;
        case 2:
          E(C[0], C[1]);
          break;
        case 3:
          E(C[0], C[1], C[2]);
          break;
        default:
          E.apply(t, C);
          break;
      }
    }
    function d(y) {
      if (r)
        setTimeout(d, 0, y);
      else {
        var E = s[y];
        if (E) {
          r = !0;
          try {
            f(E);
          } finally {
            l(y), r = !1;
          }
        }
      }
    }
    function u() {
      a = function(y) {
        process.nextTick(function() {
          d(y);
        });
      };
    }
    function c() {
      if (e.postMessage && !e.importScripts) {
        var y = !0, E = e.onmessage;
        return e.onmessage = function() {
          y = !1;
        }, e.postMessage("", "*"), e.onmessage = E, y;
      }
    }
    function h() {
      var y = "setImmediate$" + Math.random() + "$", E = function(C) {
        C.source === e && typeof C.data == "string" && C.data.indexOf(y) === 0 && d(+C.data.slice(y.length));
      };
      e.addEventListener ? e.addEventListener("message", E, !1) : e.attachEvent("onmessage", E), a = function(C) {
        e.postMessage(y + C, "*");
      };
    }
    function p() {
      var y = new MessageChannel();
      y.port1.onmessage = function(E) {
        var C = E.data;
        d(C);
      }, a = function(E) {
        y.port2.postMessage(E);
      };
    }
    function g() {
      var y = i.documentElement;
      a = function(E) {
        var C = i.createElement("script");
        C.onreadystatechange = function() {
          d(E), C.onreadystatechange = null, y.removeChild(C), C = null;
        }, y.appendChild(C);
      };
    }
    function m() {
      a = function(y) {
        setTimeout(d, 0, y);
      };
    }
    var v = Object.getPrototypeOf && Object.getPrototypeOf(e);
    v = v && v.setTimeout ? v : e, {}.toString.call(e.process) === "[object process]" ? u() : c() ? h() : e.MessageChannel ? p() : i && "onreadystatechange" in i.createElement("script") ? g() : m(), v.setImmediate = o, v.clearImmediate = l;
  }(typeof self > "u" ? _t : self)), Db;
}
var Lb;
function u5() {
  if (Lb)
    return cr;
  Lb = 1;
  var e = typeof _t < "u" && _t || typeof self < "u" && self || window, t = Function.prototype.apply;
  cr.setTimeout = function() {
    return new n(t.call(setTimeout, e, arguments), clearTimeout);
  }, cr.setInterval = function() {
    return new n(t.call(setInterval, e, arguments), clearInterval);
  }, cr.clearTimeout = cr.clearInterval = function(s) {
    s && s.close();
  };
  function n(s, r) {
    this._id = s, this._clearFn = r;
  }
  return n.prototype.unref = n.prototype.ref = function() {
  }, n.prototype.close = function() {
    this._clearFn.call(e, this._id);
  }, cr.enroll = function(s, r) {
    clearTimeout(s._idleTimeoutId), s._idleTimeout = r;
  }, cr.unenroll = function(s) {
    clearTimeout(s._idleTimeoutId), s._idleTimeout = -1;
  }, cr._unrefActive = cr.active = function(s) {
    clearTimeout(s._idleTimeoutId);
    var r = s._idleTimeout;
    r >= 0 && (s._idleTimeoutId = setTimeout(function() {
      s._onTimeout && s._onTimeout();
    }, r));
  }, l5(), cr.setImmediate = typeof self < "u" && self.setImmediate || typeof _t < "u" && _t.setImmediate || _t && _t.setImmediate, cr.clearImmediate = typeof self < "u" && self.clearImmediate || typeof _t < "u" && _t.clearImmediate || _t && _t.clearImmediate, cr;
}
var Rb;
function c5() {
  return Rb || (Rb = 1, function(e) {
    (function() {
      var t, n, s, r, i, a, o, l, f = function(c, h) {
        return function() {
          return c.apply(h, arguments);
        };
      }, d = function(c, h) {
        for (var p in h)
          u.call(h, p) && (c[p] = h[p]);
        function g() {
          this.constructor = c;
        }
        return g.prototype = h.prototype, c.prototype = new g(), c.__super__ = h.prototype, c;
      }, u = {}.hasOwnProperty;
      o = a5(), s = Yf(), t = o5(), a = dS(), l = u5().setImmediate, n = S0().defaults, r = function(c) {
        return typeof c == "object" && c != null && Object.keys(c).length === 0;
      }, i = function(c, h, p) {
        var g, m, v;
        for (g = 0, m = c.length; g < m; g++)
          v = c[g], h = v(h, p);
        return h;
      }, e.Parser = function(c) {
        d(h, c);
        function h(p) {
          this.parseStringPromise = f(this.parseStringPromise, this), this.parseString = f(this.parseString, this), this.reset = f(this.reset, this), this.assignOrPush = f(this.assignOrPush, this), this.processAsync = f(this.processAsync, this);
          var g, m, v;
          if (!(this instanceof e.Parser))
            return new e.Parser(p);
          this.options = {}, m = n["0.2"];
          for (g in m)
            u.call(m, g) && (v = m[g], this.options[g] = v);
          for (g in p)
            u.call(p, g) && (v = p[g], this.options[g] = v);
          this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), this.options.tagNameProcessors.unshift(a.normalize)), this.reset();
        }
        return h.prototype.processAsync = function() {
          var p, g;
          try {
            return this.remaining.length <= this.options.chunkSize ? (p = this.remaining, this.remaining = "", this.saxParser = this.saxParser.write(p), this.saxParser.close()) : (p = this.remaining.substr(0, this.options.chunkSize), this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), this.saxParser = this.saxParser.write(p), l(this.processAsync));
          } catch (m) {
            if (g = m, !this.saxParser.errThrown)
              return this.saxParser.errThrown = !0, this.emit(g);
          }
        }, h.prototype.assignOrPush = function(p, g, m) {
          return g in p ? (p[g] instanceof Array || (p[g] = [p[g]]), p[g].push(m)) : this.options.explicitArray ? p[g] = [m] : p[g] = m;
        }, h.prototype.reset = function() {
          var p, g, m, v;
          return this.removeAllListeners(), this.saxParser = o.parser(this.options.strict, {
            trim: !1,
            normalize: !1,
            xmlns: this.options.xmlns
          }), this.saxParser.errThrown = !1, this.saxParser.onerror = function(y) {
            return function(E) {
              if (y.saxParser.resume(), !y.saxParser.errThrown)
                return y.saxParser.errThrown = !0, y.emit("error", E);
            };
          }(this), this.saxParser.onend = function(y) {
            return function() {
              if (!y.saxParser.ended)
                return y.saxParser.ended = !0, y.emit("end", y.resultObject);
            };
          }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, this.resultObject = null, v = [], p = this.options.attrkey, g = this.options.charkey, this.saxParser.onopentag = function(y) {
            return function(E) {
              var C, x, b, P, T;
              if (b = {}, b[g] = "", !y.options.ignoreAttrs) {
                T = E.attributes;
                for (C in T)
                  u.call(T, C) && (!(p in b) && !y.options.mergeAttrs && (b[p] = {}), x = y.options.attrValueProcessors ? i(y.options.attrValueProcessors, E.attributes[C], C) : E.attributes[C], P = y.options.attrNameProcessors ? i(y.options.attrNameProcessors, C) : C, y.options.mergeAttrs ? y.assignOrPush(b, P, x) : b[p][P] = x);
              }
              return b["#name"] = y.options.tagNameProcessors ? i(y.options.tagNameProcessors, E.name) : E.name, y.options.xmlns && (b[y.options.xmlnskey] = {
                uri: E.uri,
                local: E.local
              }), v.push(b);
            };
          }(this), this.saxParser.onclosetag = function(y) {
            return function() {
              var E, C, x, b, P, T, O, S, L, A;
              if (T = v.pop(), P = T["#name"], (!y.options.explicitChildren || !y.options.preserveChildrenOrder) && delete T["#name"], T.cdata === !0 && (E = T.cdata, delete T.cdata), L = v[v.length - 1], T[g].match(/^\s*$/) && !E ? (C = T[g], delete T[g]) : (y.options.trim && (T[g] = T[g].trim()), y.options.normalize && (T[g] = T[g].replace(/\s{2,}/g, " ").trim()), T[g] = y.options.valueProcessors ? i(y.options.valueProcessors, T[g], P) : T[g], Object.keys(T).length === 1 && g in T && !y.EXPLICIT_CHARKEY && (T = T[g])), r(T) && (T = y.options.emptyTag !== "" ? y.options.emptyTag : C), y.options.validator != null && (A = "/" + function() {
                var D, _, w;
                for (w = [], D = 0, _ = v.length; D < _; D++)
                  b = v[D], w.push(b["#name"]);
                return w;
              }().concat(P).join("/"), function() {
                var D;
                try {
                  return T = y.options.validator(A, L && L[P], T);
                } catch (_) {
                  return D = _, y.emit("error", D);
                }
              }()), y.options.explicitChildren && !y.options.mergeAttrs && typeof T == "object") {
                if (!y.options.preserveChildrenOrder)
                  b = {}, y.options.attrkey in T && (b[y.options.attrkey] = T[y.options.attrkey], delete T[y.options.attrkey]), !y.options.charsAsChildren && y.options.charkey in T && (b[y.options.charkey] = T[y.options.charkey], delete T[y.options.charkey]), Object.getOwnPropertyNames(T).length > 0 && (b[y.options.childkey] = T), T = b;
                else if (L) {
                  L[y.options.childkey] = L[y.options.childkey] || [], O = {};
                  for (x in T)
                    u.call(T, x) && (O[x] = T[x]);
                  L[y.options.childkey].push(O), delete T["#name"], Object.keys(T).length === 1 && g in T && !y.EXPLICIT_CHARKEY && (T = T[g]);
                }
              }
              return v.length > 0 ? y.assignOrPush(L, P, T) : (y.options.explicitRoot && (S = T, T = {}, T[P] = S), y.resultObject = T, y.saxParser.ended = !0, y.emit("end", y.resultObject));
            };
          }(this), m = function(y) {
            return function(E) {
              var C, x;
              if (x = v[v.length - 1], x)
                return x[g] += E, y.options.explicitChildren && y.options.preserveChildrenOrder && y.options.charsAsChildren && (y.options.includeWhiteChars || E.replace(/\\n/g, "").trim() !== "") && (x[y.options.childkey] = x[y.options.childkey] || [], C = {
                  "#name": "__text__"
                }, C[g] = E, y.options.normalize && (C[g] = C[g].replace(/\s{2,}/g, " ").trim()), x[y.options.childkey].push(C)), x;
            };
          }(this), this.saxParser.ontext = m, this.saxParser.oncdata = function(y) {
            return function(E) {
              var C;
              if (C = m(E), C)
                return C.cdata = !0;
            };
          }();
        }, h.prototype.parseString = function(p, g) {
          var m;
          g != null && typeof g == "function" && (this.on("end", function(v) {
            return this.reset(), g(null, v);
          }), this.on("error", function(v) {
            return this.reset(), g(v);
          }));
          try {
            return p = p.toString(), p.trim() === "" ? (this.emit("end", null), !0) : (p = t.stripBOM(p), this.options.async ? (this.remaining = p, l(this.processAsync), this.saxParser) : this.saxParser.write(p).close());
          } catch (v) {
            if (m = v, this.saxParser.errThrown || this.saxParser.ended) {
              if (this.saxParser.ended)
                throw m;
            } else
              return this.emit("error", m), this.saxParser.errThrown = !0;
          }
        }, h.prototype.parseStringPromise = function(p) {
          return new Promise(function(g) {
            return function(m, v) {
              return g.parseString(p, function(y, E) {
                return y ? v(y) : m(E);
              });
            };
          }(this));
        }, h;
      }(s), e.parseString = function(c, h, p) {
        var g, m, v;
        return p != null ? (typeof p == "function" && (g = p), typeof h == "object" && (m = h)) : (typeof h == "function" && (g = h), m = {}), v = new e.Parser(m), v.parseString(c, g);
      }, e.parseStringPromise = function(c, h) {
        var p, g;
        return typeof h == "object" && (p = h), g = new e.Parser(p), g.parseStringPromise(c);
      };
    }).call(_t);
  }(Cm)), Cm;
}
(function() {
  var e, t, n, s, r = function(a, o) {
    for (var l in o)
      i.call(o, l) && (a[l] = o[l]);
    function f() {
      this.constructor = a;
    }
    return f.prototype = o.prototype, a.prototype = new f(), a.__super__ = o.prototype, a;
  }, i = {}.hasOwnProperty;
  t = S0(), e = Y3(), n = c5(), s = dS(), ss.defaults = t.defaults, ss.processors = s, ss.ValidationError = function(a) {
    r(o, a);
    function o(l) {
      this.message = l;
    }
    return o;
  }(Error), ss.Builder = e.Builder, ss.Parser = n.Parser, ss.parseString = n.parseString, ss.parseStringPromise = n.parseStringPromise;
}).call(_t);
const Ne = {
  STREET: "street",
  DISTRICT: "district",
  PARCEL: "parcel",
  STREET_KEY: "streetKey",
  ADDRESS_AFFIXED: "addressAffixed",
  ADDRESS_UNAFFIXED: "addressUnaffixed",
  HOUSE_NUMBERS_FOR_STREET: "houseNumbersForStreet"
};
let h5 = fi.showGeographicIdentifier;
function wh() {
  return h5;
}
function fS(e) {
  return Array.isArray(e) && e.length === 1 ? fS(e[0]) : e;
}
function Yd(e, t) {
  return Array.isArray(e) ? e.map((n) => Yd(n, t)).filter((n) => n)[0] : typeof e != "object" ? null : typeof e[t] < "u" ? e[t] : Object.keys(e).map((n) => Yd(e[n], t)).filter((n) => n)[0];
}
function d5(e) {
  const t = {
    objectType: Object.keys(e)[0]
  };
  return Object.keys(e[t.objectType][0]).forEach((n) => {
    t[n] = fS(e[t.objectType][0][n]);
  }), t;
}
function f5(e) {
  var n;
  let t = [];
  return e.startsWith("POINT") && (t = (n = e.split(")")[0]) == null ? void 0 : n.split("(")[1]), t;
}
function p5(e, t) {
  var o, l, f, d, u, c, h, p, g, m, v, y, E;
  const n = {
    type: t,
    properties: d5(e)
  };
  let s = (o = n.properties) != null && o.pos ? f5(n.properties.pos) : Yd(n.properties, "pos")[0], r = "", i = "", a = "";
  switch (t) {
    case Ne.DISTRICT:
      n.name = (l = n.properties.geographicIdentifier) != null && l._ ? n.properties.geographicIdentifier._ : n.properties.geographicIdentifier;
      break;
    case Ne.STREET_KEY:
    case Ne.STREET:
      (f = n.properties) != null && f.position_strassenachse && (s = Yd((d = n.properties) == null ? void 0 : d.position_strassenachse, "pos")[0]), n.name = wh() ? n.properties.geographicIdentifier._ : n.properties.strassenname;
      break;
    case Ne.PARCEL:
      n.name = `${n.properties.gemarkung}/${n.properties.flurstuecksnummer}`;
      break;
    case Ne.HOUSE_NUMBERS_FOR_STREET:
      r = (u = n.properties.hausnummer) != null && u._ ? n.properties.hausnummer._ : n.properties.hausnummer, n.properties.hausnummernzusatz && (i = (c = n.properties.hausnummernzusatz) != null && c._ ? n.properties.hausnummernzusatz._ : n.properties.hausnummernzusatz), n.properties.hausnummerkomplett = `${r}${i}`, n.name = wh() ? n.properties.geographicIdentifier._ : ((h = n.properties) != null && h.geographicIdentifier ? n.properties.geographicIdentifier._.split(n.properties.hausnummerkomplett)[0] : n.properties.strassenname + " ") + n.properties.hausnummerkomplett;
      break;
    case Ne.ADDRESS_AFFIXED:
      a = (p = n.properties.strassenname) != null && p._ ? n.properties.strassenname._ : n.properties.strassenname, r = (g = n.properties.hausnummer) != null && g._ ? n.properties.hausnummer._ : n.properties.hausnummer, i = (m = n.properties.hausnummernzusatz) != null && m._ ? n.properties.hausnummernzusatz._ : n.properties.hausnummernzusatz, n.name = wh() ? n.properties.geographicIdentifier._ : `${a} ${r}${i}`;
      break;
    case Ne.ADDRESS_UNAFFIXED:
      a = (v = n.properties.strassenname) != null && v._ ? n.properties.strassenname._ : n.properties.strassenname, r = (y = n.properties.hausnummer) != null && y._ ? n.properties.hausnummer._ : n.properties.hausnummer, n.name = wh() ? n.properties.geographicIdentifier._ : ((E = n.properties) != null && E.geographicIdentifier ? n.properties.geographicIdentifier._.split(r)[0] : a + " ") + r;
      break;
    default:
      n.name = null, console.error(`Unknown type in searchAddress.parse: '${t}'. Could not set name.`);
      break;
  }
  switch (t) {
    case Ne.DISTRICT:
    case Ne.STREET_KEY:
    case Ne.STREET:
    case Ne.PARCEL:
    case Ne.HOUSE_NUMBERS_FOR_STREET:
    case Ne.ADDRESS_AFFIXED:
    case Ne.ADDRESS_UNAFFIXED:
      n.geometry = {
        type: "Point",
        coordinates: s.split(" ")
      };
      break;
    default:
      n.geometry = null, console.error(`Unknown type in searchAddress.parse: '${t}'. Could not set geometry.`);
      break;
  }
  return n;
}
function pS(e, t) {
  return new Promise((n, s) => {
    ss.parseString(
      t,
      { tagNameProcessors: [ss.processors.stripPrefix] },
      (r, i) => {
        var a;
        if (r) {
          s(r);
          return;
        }
        try {
          const o = (a = i.FeatureCollection) != null && a.member ? i.FeatureCollection.member.map((l) => p5(l, e)).sort((l, f) => l.name.localeCompare(f.name)) : [];
          n(o);
        } catch (o) {
          s(o);
        }
      }
    );
  });
}
let mS = fi.gazetteerUrl;
function z0(e) {
  e && (mS = e);
}
function m5() {
  return mS;
}
function g5(e) {
  return Array.isArray(e) ? e.map(encodeURIComponent) : encodeURIComponent(e);
}
function v5(e, t) {
  return {
    [Ne.STREET]: (n) => `&StoredQuery_ID=findeStrasse&strassenname=*${n}`,
    [Ne.DISTRICT]: (n) => `&StoredQuery_ID=findeStadtteil&stadtteilname=${n}`,
    [Ne.PARCEL]: (n) => `&StoredQuery_ID=Flurstueck&gemarkung=${n[0]}&flurstuecksnummer=${n[1]}`,
    [Ne.STREET_KEY]: (n) => `&StoredQuery_ID=findeStrassenSchluessel&strassenschluessel=${n}`,
    [Ne.ADDRESS_AFFIXED]: (n) => `&StoredQuery_ID=AdresseMitZusatz&strassenname=${n[0]}&hausnummer=${n[1]}&zusatz=${n[2]}`,
    [Ne.ADDRESS_UNAFFIXED]: (n) => `&StoredQuery_ID=AdresseOhneZusatz&strassenname=${n[0]}&hausnummer=${n[1]}`,
    [Ne.HOUSE_NUMBERS_FOR_STREET]: (n) => `&StoredQuery_ID=HausnummernZuStrasse&strassenname=${n}`
  }[e](g5(t));
}
function gS(e, t, n) {
  return new Promise((s, r) => {
    const i = m5() + v5(e, t);
    fetch(i, {
      signal: n == null ? void 0 : n.signal,
      timeout: 6e3
    }).then((a) => s(a.text())).catch((a) => r(a));
  });
}
let rc = null;
function Zu(e, t) {
  return new Promise((n, s) => {
    gS(e, t, rc).then((r) => {
      const i = pS(e, r);
      n(i);
    }).catch((r) => s(r));
  });
}
function y5(e, t) {
  return new Promise((n, s) => {
    gS(Ne.STREET, e, rc).then((r) => pS(Ne.STREET, r)).then((r) => {
      const i = [];
      for (let a = 0; a < r.length; a++)
        i.push([r[a]]), t && i.push(Zu(Ne.HOUSE_NUMBERS_FOR_STREET, r[a].name));
      return Promise.all(i);
    }).then((r) => n([].concat(...r))).catch((r) => s(r));
  });
}
function vS(e, t, n = !1) {
  return n && rc !== null && rc.abort(), rc = new AbortController(), new Promise((s, r) => {
    const {
      map: i,
      zoom: a = !1,
      zoomToParams: o,
      searchAddress: l = !1,
      searchStreets: f = !1,
      searchDistricts: d = !1,
      searchParcels: u = !1,
      searchStreetKey: c = !1,
      minCharacters: h = 3
    } = t, p = [];
    let {
      searchHouseNumbers: g = !1
    } = t;
    if (e.length < h) {
      r({ error: "Search string too short." });
      return;
    }
    if (a && !i && console.warn("Instructed to zoom, but required map object was not given. Zooming will be skipped."), !f && g && (console.warn(`Search for '${e}' supposed to retrieve house numbers, but not streets. Invalid search configuration. House numbers will not be searched for as a result.`), g = !1), !(l || f || g || d || u || c)) {
      r({ error: `Search for '${e}' received no indication what to search for. Search is canceled.` });
      return;
    }
    if (f && p.push(y5(e, g)), l) {
      const m = e.split(/(\d+)/).map((y) => y.trim()).filter((y) => y), v = [!1, !1, Ne.ADDRESS_UNAFFIXED, Ne.ADDRESS_AFFIXED][m.length];
      v && p.push(Zu(v, m));
    }
    if (d && /^[a-z-üäöß]+$/i.test(e) && p.push(Zu(Ne.DISTRICT, e)), c && /^[a-z]{1}[0-9]{1,5}$/i.test(e) && p.push(Zu(Ne.STREET_KEY, e)), u) {
      let m;
      /^[0-9]{4}[\s|/][0-9]*$/.test(e) ? m = e.split(/[\s|/]/) : /^[0-9]{5,}$/.test(e) && (m = [e.slice(0, 4), e.slice(4)]), m && p.push(Zu(Ne.PARCEL, m));
    }
    Promise.all(p).then((m) => {
      const v = [].concat(...m);
      if (a && i && v.length === 1)
        try {
          j3(i, v[0], o);
        } catch (y) {
          console.error("Zooming to element from gazetteer failed."), console.error(y);
        }
      s(v);
    }).catch((m) => r(m));
  });
}
function yS({ backgroundImage: e, target: t } = {}) {
  const n = document.getElementById(t || fi.target);
  if (n) {
    const s = `url(${// keep "" as explicit none
    typeof e == "string" ? e : fi.backgroundImage})`;
    n.style.backgroundImage = s;
  }
}
function ES({ url: e, typ: t, capabilitiesUrl: n, ...s }) {
  const r = [];
  if (n)
    r.push(n);
  else if (t === "OAF")
    r.push(e);
  else if (t === "Entities3D")
    s.entities.forEach((i) => i.url ? r.push(i.url) : null);
  else if (t === "TileSet3D" || t === "Terrain3D")
    r.push(e);
  else if (t === "GeoJSON") {
    if (!e && s.features)
      return Promise.resolve(200);
    e && r.push(e);
  } else if (t === "VectorTile")
    r.push(e.replaceAll(/\{[xyz]\}/ig, "0"));
  else if (t === "WMTS") {
    const i = (e ? [e] : s.urls).map((a) => a.replace(/\{Style\}/ig, s.style).replace(/\{TileMatrixSet\}/ig, s.tileMatrixSet).replaceAll(/\{(TileMatrix|TileRow|TileCol)\}/ig, "0"));
    r.push(...i);
  } else
    e && r.push(`${e}?service=${t}&request=GetCapabilities`);
  return r.length ? Promise.allSettled(r.map((i) => new Promise((a) => fetch(i, { method: "HEAD" }).then(({ status: o }) => a(o)).catch(() => a(900))))).then((i) => Math.max(...i.map(({ value: a }) => a))) : Promise.resolve(null);
}
const E5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tileset: M0,
  createMapView: QP,
  crs: xN,
  entities: L3,
  geojson: xM,
  layerLib: B3,
  oaf: JM,
  ping: ES,
  rawLayerList: TN,
  search: vS,
  setBackgroundImage: yS,
  setGazetteerUrl: z0,
  terrain: S3,
  vectorBase: bM,
  vectorTile: YM,
  wfs: gM,
  wms: j1,
  wmts: Z1
}, Symbol.toStringTag, { value: "Module" }));
function C5(e) {
  const t = this.createMap;
  this.createMap = async (n) => {
    try {
      const s = await t(n);
      return e.forEach((r) => r(s)), s;
    } catch (s) {
      console.error("Map creation failed."), console.error(s);
    }
  };
}
/*!
 * Vue.js v2.7.15
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var ci = Object.freeze({}), ue = Array.isArray;
function te(e) {
  return e == null;
}
function ht(e) {
  return e != null;
}
function ln(e) {
  return e === !0;
}
function x5(e) {
  return e === !1;
}
function Jc(e) {
  return typeof e == "string" || typeof e == "number" || // $flow-disable-line
  typeof e == "symbol" || typeof e == "boolean";
}
function Ae(e) {
  return typeof e == "function";
}
function pi(e) {
  return e !== null && typeof e == "object";
}
var K0 = Object.prototype.toString;
function _i(e) {
  return K0.call(e) === "[object Object]";
}
function b5(e) {
  return K0.call(e) === "[object RegExp]";
}
function CS(e) {
  var t = parseFloat(String(e));
  return t >= 0 && Math.floor(t) === t && isFinite(e);
}
function cv(e) {
  return ht(e) && typeof e.then == "function" && typeof e.catch == "function";
}
function O5(e) {
  return e == null ? "" : Array.isArray(e) || _i(e) && e.toString === K0 ? JSON.stringify(e, null, 2) : String(e);
}
function Pc(e) {
  var t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function Ur(e, t) {
  for (var n = /* @__PURE__ */ Object.create(null), s = e.split(","), r = 0; r < s.length; r++)
    n[s[r]] = !0;
  return t ? function(i) {
    return n[i.toLowerCase()];
  } : function(i) {
    return n[i];
  };
}
Ur("slot,component", !0);
var T5 = Ur("key,ref,slot,slot-scope,is");
function no(e, t) {
  var n = e.length;
  if (n) {
    if (t === e[n - 1]) {
      e.length = n - 1;
      return;
    }
    var s = e.indexOf(t);
    if (s > -1)
      return e.splice(s, 1);
  }
}
var P5 = Object.prototype.hasOwnProperty;
function Si(e, t) {
  return P5.call(e, t);
}
function tl(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(s) {
    var r = t[s];
    return r || (t[s] = e(s));
  };
}
var M5 = /-(\w)/g, Ko = tl(function(e) {
  return e.replace(M5, function(t, n) {
    return n ? n.toUpperCase() : "";
  });
}), S5 = tl(function(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}), I5 = /\B([A-Z])/g, Qc = tl(function(e) {
  return e.replace(I5, "-$1").toLowerCase();
});
function _5(e, t) {
  function n(s) {
    var r = arguments.length;
    return r ? r > 1 ? e.apply(t, arguments) : e.call(t, s) : e.call(t);
  }
  return n._length = e.length, n;
}
function D5(e, t) {
  return e.bind(t);
}
var xS = Function.prototype.bind ? D5 : _5;
function hv(e, t) {
  t = t || 0;
  for (var n = e.length - t, s = new Array(n); n--; )
    s[n] = e[n + t];
  return s;
}
function He(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function bS(e) {
  for (var t = {}, n = 0; n < e.length; n++)
    e[n] && He(t, e[n]);
  return t;
}
function rn(e, t, n) {
}
var Vh = function(e, t, n) {
  return !1;
}, OS = function(e) {
  return e;
};
function Go(e, t) {
  if (e === t)
    return !0;
  var n = pi(e), s = pi(t);
  if (n && s)
    try {
      var r = Array.isArray(e), i = Array.isArray(t);
      if (r && i)
        return e.length === t.length && e.every(function(l, f) {
          return Go(l, t[f]);
        });
      if (e instanceof Date && t instanceof Date)
        return e.getTime() === t.getTime();
      if (!r && !i) {
        var a = Object.keys(e), o = Object.keys(t);
        return a.length === o.length && a.every(function(l) {
          return Go(e[l], t[l]);
        });
      } else
        return !1;
    } catch {
      return !1;
    }
  else
    return !n && !s ? String(e) === String(t) : !1;
}
function TS(e, t) {
  for (var n = 0; n < e.length; n++)
    if (Go(e[n], t))
      return n;
  return -1;
}
function Xd(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(this, arguments));
  };
}
function dv(e, t) {
  return e === t ? e === 0 && 1 / e !== 1 / t : e === e || t === t;
}
var wb = "data-server-rendered", Zf = ["component", "directive", "filter"], PS = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch",
  "renderTracked",
  "renderTriggered"
], gr = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: /* @__PURE__ */ Object.create(null),
  /**
   * Whether to suppress warnings.
   */
  silent: !1,
  /**
   * Show production mode tip message on boot?
   */
  productionTip: !1,
  /**
   * Whether to enable devtools
   */
  devtools: !1,
  /**
   * Whether to record perf
   */
  performance: !1,
  /**
   * Error handler for watcher errors
   */
  errorHandler: null,
  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,
  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],
  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: /* @__PURE__ */ Object.create(null),
  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: Vh,
  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: Vh,
  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: Vh,
  /**
   * Get the namespace of an element
   */
  getTagNamespace: rn,
  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: OS,
  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: Vh,
  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: !0,
  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: PS
}, A5 = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function MS(e) {
  var t = (e + "").charCodeAt(0);
  return t === 36 || t === 95;
}
function Sn(e, t, n, s) {
  Object.defineProperty(e, t, {
    value: n,
    enumerable: !!s,
    writable: !0,
    configurable: !0
  });
}
var L5 = new RegExp("[^".concat(A5.source, ".$_\\d]"));
function R5(e) {
  if (!L5.test(e)) {
    var t = e.split(".");
    return function(n) {
      for (var s = 0; s < t.length; s++) {
        if (!n)
          return;
        n = n[t[s]];
      }
      return n;
    };
  }
}
var w5 = "__proto__" in {}, zi = typeof window < "u", yr = zi && window.navigator.userAgent.toLowerCase(), bu = yr && /msie|trident/.test(yr), Ou = yr && yr.indexOf("msie 9.0") > 0, SS = yr && yr.indexOf("edge/") > 0;
yr && yr.indexOf("android") > 0;
var V5 = yr && /iphone|ipad|ipod|ios/.test(yr), Vb = yr && yr.match(/firefox\/(\d+)/), fv = {}.watch, IS = !1;
if (zi)
  try {
    var Bb = {};
    Object.defineProperty(Bb, "passive", {
      get: function() {
        IS = !0;
      }
    }), window.addEventListener("test-passive", null, Bb);
  } catch {
  }
var Bh, io = function() {
  return Bh === void 0 && (!zi && typeof global < "u" ? Bh = global.process && global.process.env.VUE_ENV === "server" : Bh = !1), Bh;
}, Zd = zi && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function kl(e) {
  return typeof e == "function" && /native code/.test(e.toString());
}
var qc = typeof Symbol < "u" && kl(Symbol) && typeof Reflect < "u" && kl(Reflect.ownKeys), Mc;
typeof Set < "u" && kl(Set) ? Mc = Set : Mc = /** @class */
function() {
  function e() {
    this.set = /* @__PURE__ */ Object.create(null);
  }
  return e.prototype.has = function(t) {
    return this.set[t] === !0;
  }, e.prototype.add = function(t) {
    this.set[t] = !0;
  }, e.prototype.clear = function() {
    this.set = /* @__PURE__ */ Object.create(null);
  }, e;
}();
var _n = null;
function B5() {
  return _n && { proxy: _n };
}
function Qa(e) {
  e === void 0 && (e = null), e || _n && _n._scope.off(), _n = e, e && e._scope.on();
}
var ir = (
  /** @class */
  function() {
    function e(t, n, s, r, i, a, o, l) {
      this.tag = t, this.data = n, this.children = s, this.text = r, this.elm = i, this.ns = void 0, this.context = a, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = n && n.key, this.componentOptions = o, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = l, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
    }
    return Object.defineProperty(e.prototype, "child", {
      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      get: function() {
        return this.componentInstance;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
), So = function(e) {
  e === void 0 && (e = "");
  var t = new ir();
  return t.text = e, t.isComment = !0, t;
};
function Dl(e) {
  return new ir(void 0, void 0, void 0, String(e));
}
function pv(e) {
  var t = new ir(
    e.tag,
    e.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    e.children && e.children.slice(),
    e.text,
    e.elm,
    e.context,
    e.componentOptions,
    e.asyncFactory
  );
  return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned = !0, t;
}
var N5 = 0, ld = [], F5 = function() {
  for (var e = 0; e < ld.length; e++) {
    var t = ld[e];
    t.subs = t.subs.filter(function(n) {
      return n;
    }), t._pending = !1;
  }
  ld.length = 0;
}, vs = (
  /** @class */
  function() {
    function e() {
      this._pending = !1, this.id = N5++, this.subs = [];
    }
    return e.prototype.addSub = function(t) {
      this.subs.push(t);
    }, e.prototype.removeSub = function(t) {
      this.subs[this.subs.indexOf(t)] = null, this._pending || (this._pending = !0, ld.push(this));
    }, e.prototype.depend = function(t) {
      e.target && e.target.addDep(this);
    }, e.prototype.notify = function(t) {
      for (var n = this.subs.filter(function(a) {
        return a;
      }), s = 0, r = n.length; s < r; s++) {
        var i = n[s];
        i.update();
      }
    }, e;
  }()
);
vs.target = null;
var ud = [];
function Tu(e) {
  ud.push(e), vs.target = e;
}
function Pu() {
  ud.pop(), vs.target = ud[ud.length - 1];
}
var _S = Array.prototype, Jd = Object.create(_S), j5 = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
j5.forEach(function(e) {
  var t = _S[e];
  Sn(Jd, e, function() {
    for (var s = [], r = 0; r < arguments.length; r++)
      s[r] = arguments[r];
    var i = t.apply(this, s), a = this.__ob__, o;
    switch (e) {
      case "push":
      case "unshift":
        o = s;
        break;
      case "splice":
        o = s.slice(2);
        break;
    }
    return o && a.observeArray(o), a.dep.notify(), i;
  });
});
var Nb = Object.getOwnPropertyNames(Jd), DS = {}, G0 = !0;
function qa(e) {
  G0 = e;
}
var U5 = {
  notify: rn,
  depend: rn,
  addSub: rn,
  removeSub: rn
}, Fb = (
  /** @class */
  function() {
    function e(t, n, s) {
      if (n === void 0 && (n = !1), s === void 0 && (s = !1), this.value = t, this.shallow = n, this.mock = s, this.dep = s ? U5 : new vs(), this.vmCount = 0, Sn(t, "__ob__", this), ue(t)) {
        if (!s)
          if (w5)
            t.__proto__ = Jd;
          else
            for (var r = 0, i = Nb.length; r < i; r++) {
              var a = Nb[r];
              Sn(t, a, Jd[a]);
            }
        n || this.observeArray(t);
      } else
        for (var o = Object.keys(t), r = 0; r < o.length; r++) {
          var a = o[r];
          to(t, a, DS, void 0, n, s);
        }
    }
    return e.prototype.observeArray = function(t) {
      for (var n = 0, s = t.length; n < s; n++)
        ta(t[n], !1, this.mock);
    }, e;
  }()
);
function ta(e, t, n) {
  if (e && Si(e, "__ob__") && e.__ob__ instanceof Fb)
    return e.__ob__;
  if (G0 && (n || !io()) && (ue(e) || _i(e)) && Object.isExtensible(e) && !e.__v_skip && !ei(e) && !(e instanceof ir))
    return new Fb(e, t, n);
}
function to(e, t, n, s, r, i) {
  var a = new vs(), o = Object.getOwnPropertyDescriptor(e, t);
  if (!(o && o.configurable === !1)) {
    var l = o && o.get, f = o && o.set;
    (!l || f) && (n === DS || arguments.length === 2) && (n = e[t]);
    var d = !r && ta(n, !1, i);
    return Object.defineProperty(e, t, {
      enumerable: !0,
      configurable: !0,
      get: function() {
        var c = l ? l.call(e) : n;
        return vs.target && (a.depend(), d && (d.dep.depend(), ue(c) && AS(c))), ei(c) && !r ? c.value : c;
      },
      set: function(c) {
        var h = l ? l.call(e) : n;
        if (dv(h, c)) {
          if (f)
            f.call(e, c);
          else {
            if (l)
              return;
            if (!r && ei(h) && !ei(c)) {
              h.value = c;
              return;
            } else
              n = c;
          }
          d = !r && ta(c, !1, i), a.notify();
        }
      }
    }), a;
  }
}
function Jf(e, t, n) {
  if (!el(e)) {
    var s = e.__ob__;
    return ue(e) && CS(t) ? (e.length = Math.max(e.length, t), e.splice(t, 1, n), s && !s.shallow && s.mock && ta(n, !1, !0), n) : t in e && !(t in Object.prototype) ? (e[t] = n, n) : e._isVue || s && s.vmCount ? n : s ? (to(s.value, t, n, void 0, s.shallow, s.mock), s.dep.notify(), n) : (e[t] = n, n);
  }
}
function k0(e, t) {
  if (ue(e) && CS(t)) {
    e.splice(t, 1);
    return;
  }
  var n = e.__ob__;
  e._isVue || n && n.vmCount || el(e) || Si(e, t) && (delete e[t], n && n.dep.notify());
}
function AS(e) {
  for (var t = void 0, n = 0, s = e.length; n < s; n++)
    t = e[n], t && t.__ob__ && t.__ob__.dep.depend(), ue(t) && AS(t);
}
function W5(e) {
  return LS(e, !1), e;
}
function H0(e) {
  return LS(e, !0), Sn(e, "__v_isShallow", !0), e;
}
function LS(e, t) {
  el(e) || ta(
    e,
    t,
    io()
    /* ssr mock reactivity */
  );
}
function Io(e) {
  return el(e) ? Io(e.__v_raw) : !!(e && e.__ob__);
}
function Qd(e) {
  return !!(e && e.__v_isShallow);
}
function el(e) {
  return !!(e && e.__v_isReadonly);
}
function $5(e) {
  return Io(e) || el(e);
}
function RS(e) {
  var t = e && e.__v_raw;
  return t ? RS(t) : e;
}
function z5(e) {
  return Object.isExtensible(e) && Sn(e, "__v_skip", !0), e;
}
var th = "__v_isRef";
function ei(e) {
  return !!(e && e.__v_isRef === !0);
}
function K5(e) {
  return wS(e, !1);
}
function G5(e) {
  return wS(e, !0);
}
function wS(e, t) {
  if (ei(e))
    return e;
  var n = {};
  return Sn(n, th, !0), Sn(n, "__v_isShallow", t), Sn(n, "dep", to(n, "value", e, null, t, io())), n;
}
function k5(e) {
  e.dep && e.dep.notify();
}
function H5(e) {
  return ei(e) ? e.value : e;
}
function Y5(e) {
  if (Io(e))
    return e;
  for (var t = {}, n = Object.keys(e), s = 0; s < n.length; s++)
    qd(t, e, n[s]);
  return t;
}
function qd(e, t, n) {
  Object.defineProperty(e, n, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      var s = t[n];
      if (ei(s))
        return s.value;
      var r = s && s.__ob__;
      return r && r.dep.depend(), s;
    },
    set: function(s) {
      var r = t[n];
      ei(r) && !ei(s) ? r.value = s : t[n] = s;
    }
  });
}
function X5(e) {
  var t = new vs(), n = e(function() {
    t.depend();
  }, function() {
    t.notify();
  }), s = n.get, r = n.set, i = {
    get value() {
      return s();
    },
    set value(a) {
      r(a);
    }
  };
  return Sn(i, th, !0), i;
}
function Z5(e) {
  var t = ue(e) ? new Array(e.length) : {};
  for (var n in e)
    t[n] = VS(e, n);
  return t;
}
function VS(e, t, n) {
  var s = e[t];
  if (ei(s))
    return s;
  var r = {
    get value() {
      var i = e[t];
      return i === void 0 ? n : i;
    },
    set value(i) {
      e[t] = i;
    }
  };
  return Sn(r, th, !0), r;
}
var J5 = "__v_rawToReadonly", Q5 = "__v_rawToShallowReadonly";
function BS(e) {
  return NS(e, !1);
}
function NS(e, t) {
  if (!_i(e) || el(e))
    return e;
  var n = t ? Q5 : J5, s = e[n];
  if (s)
    return s;
  var r = Object.create(Object.getPrototypeOf(e));
  Sn(e, n, r), Sn(r, "__v_isReadonly", !0), Sn(r, "__v_raw", e), ei(e) && Sn(r, th, !0), (t || Qd(e)) && Sn(r, "__v_isShallow", !0);
  for (var i = Object.keys(e), a = 0; a < i.length; a++)
    q5(r, e, i[a], t);
  return r;
}
function q5(e, t, n, s) {
  Object.defineProperty(e, n, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      var r = t[n];
      return s || !_i(r) ? r : BS(r);
    },
    set: function() {
    }
  });
}
function tz(e) {
  return NS(e, !0);
}
function ez(e, t) {
  var n, s, r = Ae(e);
  r ? (n = e, s = rn) : (n = e.get, s = e.set);
  var i = io() ? null : new eh(_n, n, rn, { lazy: !0 }), a = {
    // some libs rely on the presence effect for checking computed refs
    // from normal refs, but the implementation doesn't matter
    effect: i,
    get value() {
      return i ? (i.dirty && i.evaluate(), vs.target && i.depend(), i.value) : n();
    },
    set value(o) {
      s(o);
    }
  };
  return Sn(a, th, !0), Sn(a, "__v_isReadonly", r), a;
}
var Qf = "watcher", jb = "".concat(Qf, " callback"), Ub = "".concat(Qf, " getter"), nz = "".concat(Qf, " cleanup");
function iz(e, t) {
  return qf(e, null, t);
}
function FS(e, t) {
  return qf(e, null, { flush: "post" });
}
function rz(e, t) {
  return qf(e, null, { flush: "sync" });
}
var Wb = {};
function sz(e, t, n) {
  return qf(e, t, n);
}
function qf(e, t, n) {
  var s = n === void 0 ? ci : n, r = s.immediate, i = s.deep, a = s.flush, o = a === void 0 ? "pre" : a;
  s.onTrack, s.onTrigger;
  var l = _n, f = function(y, E, C) {
    return C === void 0 && (C = null), ea(y, null, C, l, E);
  }, d, u = !1, c = !1;
  if (ei(e) ? (d = function() {
    return e.value;
  }, u = Qd(e)) : Io(e) ? (d = function() {
    return e.__ob__.dep.depend(), e;
  }, i = !0) : ue(e) ? (c = !0, u = e.some(function(y) {
    return Io(y) || Qd(y);
  }), d = function() {
    return e.map(function(y) {
      if (ei(y))
        return y.value;
      if (Io(y))
        return ru(y);
      if (Ae(y))
        return f(y, Ub);
    });
  }) : Ae(e) ? t ? d = function() {
    return f(e, Ub);
  } : d = function() {
    if (!(l && l._isDestroyed))
      return p && p(), f(e, Qf, [g]);
  } : d = rn, t && i) {
    var h = d;
    d = function() {
      return ru(h());
    };
  }
  var p, g = function(y) {
    p = m.onStop = function() {
      f(y, nz);
    };
  };
  if (io())
    return g = rn, t ? r && f(t, jb, [
      d(),
      c ? [] : void 0,
      g
    ]) : d(), rn;
  var m = new eh(_n, d, rn, {
    lazy: !0
  });
  m.noRecurse = !t;
  var v = c ? [] : Wb;
  return m.run = function() {
    if (m.active)
      if (t) {
        var y = m.get();
        (i || u || (c ? y.some(function(E, C) {
          return dv(E, v[C]);
        }) : dv(y, v))) && (p && p(), f(t, jb, [
          y,
          // pass undefined as the old value when it's changed for the first time
          v === Wb ? void 0 : v,
          g
        ]), v = y);
      } else
        m.get();
  }, o === "sync" ? m.update = m.run : o === "post" ? (m.post = !0, m.update = function() {
    return bv(m);
  }) : m.update = function() {
    if (l && l === _n && !l._isMounted) {
      var y = l._preWatchers || (l._preWatchers = []);
      y.indexOf(m) < 0 && y.push(m);
    } else
      bv(m);
  }, t ? r ? m.run() : v = m.get() : o === "post" && l ? l.$once("hook:mounted", function() {
    return m.get();
  }) : m.get(), function() {
    m.teardown();
  };
}
var li, Y0 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = !1), this.detached = t, this.active = !0, this.effects = [], this.cleanups = [], this.parent = li, !t && li && (this.index = (li.scopes || (li.scopes = [])).push(this) - 1);
    }
    return e.prototype.run = function(t) {
      if (this.active) {
        var n = li;
        try {
          return li = this, t();
        } finally {
          li = n;
        }
      }
    }, e.prototype.on = function() {
      li = this;
    }, e.prototype.off = function() {
      li = this.parent;
    }, e.prototype.stop = function(t) {
      if (this.active) {
        var n = void 0, s = void 0;
        for (n = 0, s = this.effects.length; n < s; n++)
          this.effects[n].teardown();
        for (n = 0, s = this.cleanups.length; n < s; n++)
          this.cleanups[n]();
        if (this.scopes)
          for (n = 0, s = this.scopes.length; n < s; n++)
            this.scopes[n].stop(!0);
        if (!this.detached && this.parent && !t) {
          var r = this.parent.scopes.pop();
          r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
        }
        this.parent = void 0, this.active = !1;
      }
    }, e;
  }()
);
function az(e) {
  return new Y0(e);
}
function oz(e, t) {
  t === void 0 && (t = li), t && t.active && t.effects.push(e);
}
function jS() {
  return li;
}
function lz(e) {
  li && li.cleanups.push(e);
}
function uz(e, t) {
  _n && (US(_n)[e] = t);
}
function US(e) {
  var t = e._provided, n = e.$parent && e.$parent._provided;
  return n === t ? e._provided = Object.create(n) : t;
}
function cz(e, t, n) {
  n === void 0 && (n = !1);
  var s = _n;
  if (s) {
    var r = s.$parent && s.$parent._provided;
    if (r && e in r)
      return r[e];
    if (arguments.length > 1)
      return n && Ae(t) ? t.call(s) : t;
  }
}
var $b = tl(function(e) {
  var t = e.charAt(0) === "&";
  e = t ? e.slice(1) : e;
  var n = e.charAt(0) === "~";
  e = n ? e.slice(1) : e;
  var s = e.charAt(0) === "!";
  return e = s ? e.slice(1) : e, {
    name: e,
    once: n,
    capture: s,
    passive: t
  };
});
function mv(e, t) {
  function n() {
    var s = n.fns;
    if (ue(s))
      for (var r = s.slice(), i = 0; i < r.length; i++)
        ea(r[i], null, arguments, t, "v-on handler");
    else
      return ea(s, null, arguments, t, "v-on handler");
  }
  return n.fns = e, n;
}
function WS(e, t, n, s, r, i) {
  var a, o, l, f;
  for (a in e)
    o = e[a], l = t[a], f = $b(a), te(o) || (te(l) ? (te(o.fns) && (o = e[a] = mv(o, i)), ln(f.once) && (o = e[a] = r(f.name, o, f.capture)), n(f.name, o, f.capture, f.passive, f.params)) : o !== l && (l.fns = o, e[a] = l));
  for (a in t)
    te(e[a]) && (f = $b(a), s(f.name, t[a], f.capture));
}
function Sa(e, t, n) {
  e instanceof ir && (e = e.data.hook || (e.data.hook = {}));
  var s, r = e[t];
  function i() {
    n.apply(this, arguments), no(s.fns, i);
  }
  te(r) ? s = mv([i]) : ht(r.fns) && ln(r.merged) ? (s = r, s.fns.push(i)) : s = mv([r, i]), s.merged = !0, e[t] = s;
}
function hz(e, t, n) {
  var s = t.options.props;
  if (!te(s)) {
    var r = {}, i = e.attrs, a = e.props;
    if (ht(i) || ht(a))
      for (var o in s) {
        var l = Qc(o);
        zb(r, a, o, l, !0) || zb(r, i, o, l, !1);
      }
    return r;
  }
}
function zb(e, t, n, s, r) {
  if (ht(t)) {
    if (Si(t, n))
      return e[n] = t[n], r || delete t[n], !0;
    if (Si(t, s))
      return e[n] = t[s], r || delete t[s], !0;
  }
  return !1;
}
function dz(e) {
  for (var t = 0; t < e.length; t++)
    if (ue(e[t]))
      return Array.prototype.concat.apply([], e);
  return e;
}
function X0(e) {
  return Jc(e) ? [Dl(e)] : ue(e) ? $S(e) : void 0;
}
function Fu(e) {
  return ht(e) && ht(e.text) && x5(e.isComment);
}
function $S(e, t) {
  var n = [], s, r, i, a;
  for (s = 0; s < e.length; s++)
    r = e[s], !(te(r) || typeof r == "boolean") && (i = n.length - 1, a = n[i], ue(r) ? r.length > 0 && (r = $S(r, "".concat(t || "", "_").concat(s)), Fu(r[0]) && Fu(a) && (n[i] = Dl(a.text + r[0].text), r.shift()), n.push.apply(n, r)) : Jc(r) ? Fu(a) ? n[i] = Dl(a.text + r) : r !== "" && n.push(Dl(r)) : Fu(r) && Fu(a) ? n[i] = Dl(a.text + r.text) : (ln(e._isVList) && ht(r.tag) && te(r.key) && ht(t) && (r.key = "__vlist".concat(t, "_").concat(s, "__")), n.push(r)));
  return n;
}
function fz(e, t) {
  var n = null, s, r, i, a;
  if (ue(e) || typeof e == "string")
    for (n = new Array(e.length), s = 0, r = e.length; s < r; s++)
      n[s] = t(e[s], s);
  else if (typeof e == "number")
    for (n = new Array(e), s = 0; s < e; s++)
      n[s] = t(s + 1, s);
  else if (pi(e))
    if (qc && e[Symbol.iterator]) {
      n = [];
      for (var o = e[Symbol.iterator](), l = o.next(); !l.done; )
        n.push(t(l.value, n.length)), l = o.next();
    } else
      for (i = Object.keys(e), n = new Array(i.length), s = 0, r = i.length; s < r; s++)
        a = i[s], n[s] = t(e[a], a, s);
  return ht(n) || (n = []), n._isVList = !0, n;
}
function pz(e, t, n, s) {
  var r = this.$scopedSlots[e], i;
  r ? (n = n || {}, s && (n = He(He({}, s), n)), i = r(n) || (Ae(t) ? t() : t)) : i = this.$slots[e] || (Ae(t) ? t() : t);
  var a = n && n.slot;
  return a ? this.$createElement("template", { slot: a }, i) : i;
}
function mz(e) {
  return rf(this.$options, "filters", e) || OS;
}
function Kb(e, t) {
  return ue(e) ? e.indexOf(t) === -1 : e !== t;
}
function gz(e, t, n, s, r) {
  var i = gr.keyCodes[t] || n;
  return r && s && !gr.keyCodes[t] ? Kb(r, s) : i ? Kb(i, e) : s ? Qc(s) !== t : e === void 0;
}
function vz(e, t, n, s, r) {
  if (n && pi(n)) {
    ue(n) && (n = bS(n));
    var i = void 0, a = function(l) {
      if (l === "class" || l === "style" || T5(l))
        i = e;
      else {
        var f = e.attrs && e.attrs.type;
        i = s || gr.mustUseProp(t, f, l) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {});
      }
      var d = Ko(l), u = Qc(l);
      if (!(d in i) && !(u in i) && (i[l] = n[l], r)) {
        var c = e.on || (e.on = {});
        c["update:".concat(l)] = function(h) {
          n[l] = h;
        };
      }
    };
    for (var o in n)
      a(o);
  }
  return e;
}
function yz(e, t) {
  var n = this._staticTrees || (this._staticTrees = []), s = n[e];
  return s && !t || (s = n[e] = this.$options.staticRenderFns[e].call(
    this._renderProxy,
    this._c,
    this
    // for render fns generated for functional component templates
  ), zS(s, "__static__".concat(e), !1)), s;
}
function Ez(e, t, n) {
  return zS(e, "__once__".concat(t).concat(n ? "_".concat(n) : ""), !0), e;
}
function zS(e, t, n) {
  if (ue(e))
    for (var s = 0; s < e.length; s++)
      e[s] && typeof e[s] != "string" && Gb(e[s], "".concat(t, "_").concat(s), n);
  else
    Gb(e, t, n);
}
function Gb(e, t, n) {
  e.isStatic = !0, e.key = t, e.isOnce = n;
}
function Cz(e, t) {
  if (t && _i(t)) {
    var n = e.on = e.on ? He({}, e.on) : {};
    for (var s in t) {
      var r = n[s], i = t[s];
      n[s] = r ? [].concat(r, i) : i;
    }
  }
  return e;
}
function KS(e, t, n, s) {
  t = t || { $stable: !n };
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    ue(i) ? KS(i, t, n) : i && (i.proxy && (i.fn.proxy = !0), t[i.key] = i.fn);
  }
  return s && (t.$key = s), t;
}
function xz(e, t) {
  for (var n = 0; n < t.length; n += 2) {
    var s = t[n];
    typeof s == "string" && s && (e[t[n]] = t[n + 1]);
  }
  return e;
}
function bz(e, t) {
  return typeof e == "string" ? t + e : e;
}
function GS(e) {
  e._o = Ez, e._n = Pc, e._s = O5, e._l = fz, e._t = pz, e._q = Go, e._i = TS, e._m = yz, e._f = mz, e._k = gz, e._b = vz, e._v = Dl, e._e = So, e._u = KS, e._g = Cz, e._d = xz, e._p = bz;
}
function Z0(e, t) {
  if (!e || !e.length)
    return {};
  for (var n = {}, s = 0, r = e.length; s < r; s++) {
    var i = e[s], a = i.data;
    if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, (i.context === t || i.fnContext === t) && a && a.slot != null) {
      var o = a.slot, l = n[o] || (n[o] = []);
      i.tag === "template" ? l.push.apply(l, i.children || []) : l.push(i);
    } else
      (n.default || (n.default = [])).push(i);
  }
  for (var f in n)
    n[f].every(Oz) && delete n[f];
  return n;
}
function Oz(e) {
  return e.isComment && !e.asyncFactory || e.text === " ";
}
function Sc(e) {
  return e.isComment && e.asyncFactory;
}
function sc(e, t, n, s) {
  var r, i = Object.keys(n).length > 0, a = t ? !!t.$stable : !i, o = t && t.$key;
  if (!t)
    r = {};
  else {
    if (t._normalized)
      return t._normalized;
    if (a && s && s !== ci && o === s.$key && !i && !s.$hasNormal)
      return s;
    r = {};
    for (var l in t)
      t[l] && l[0] !== "$" && (r[l] = Tz(e, n, l, t[l]));
  }
  for (var f in n)
    f in r || (r[f] = Pz(n, f));
  return t && Object.isExtensible(t) && (t._normalized = r), Sn(r, "$stable", a), Sn(r, "$key", o), Sn(r, "$hasNormal", i), r;
}
function Tz(e, t, n, s) {
  var r = function() {
    var i = _n;
    Qa(e);
    var a = arguments.length ? s.apply(null, arguments) : s({});
    a = a && typeof a == "object" && !ue(a) ? [a] : X0(a);
    var o = a && a[0];
    return Qa(i), a && (!o || a.length === 1 && o.isComment && !Sc(o)) ? void 0 : a;
  };
  return s.proxy && Object.defineProperty(t, n, {
    get: r,
    enumerable: !0,
    configurable: !0
  }), r;
}
function Pz(e, t) {
  return function() {
    return e[t];
  };
}
function Mz(e) {
  var t = e.$options, n = t.setup;
  if (n) {
    var s = e._setupContext = kS(e);
    Qa(e), Tu();
    var r = ea(n, null, [e._props || H0({}), s], e, "setup");
    if (Pu(), Qa(), Ae(r))
      t.render = r;
    else if (pi(r))
      if (e._setupState = r, r.__sfc) {
        var a = e._setupProxy = {};
        for (var i in r)
          i !== "__sfc" && qd(a, r, i);
      } else
        for (var i in r)
          MS(i) || qd(e, r, i);
  }
}
function kS(e) {
  return {
    get attrs() {
      if (!e._attrsProxy) {
        var t = e._attrsProxy = {};
        Sn(t, "_v_attr_proxy", !0), tf(t, e.$attrs, ci, e, "$attrs");
      }
      return e._attrsProxy;
    },
    get listeners() {
      if (!e._listenersProxy) {
        var t = e._listenersProxy = {};
        tf(t, e.$listeners, ci, e, "$listeners");
      }
      return e._listenersProxy;
    },
    get slots() {
      return Iz(e);
    },
    emit: xS(e.$emit, e),
    expose: function(t) {
      t && Object.keys(t).forEach(function(n) {
        return qd(e, t, n);
      });
    }
  };
}
function tf(e, t, n, s, r) {
  var i = !1;
  for (var a in t)
    a in e ? t[a] !== n[a] && (i = !0) : (i = !0, Sz(e, a, s, r));
  for (var a in e)
    a in t || (i = !0, delete e[a]);
  return i;
}
function Sz(e, t, n, s) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      return n[s][t];
    }
  });
}
function Iz(e) {
  return e._slotsProxy || HS(e._slotsProxy = {}, e.$scopedSlots), e._slotsProxy;
}
function HS(e, t) {
  for (var n in t)
    e[n] = t[n];
  for (var n in e)
    n in t || delete e[n];
}
function _z() {
  return J0().slots;
}
function Dz() {
  return J0().attrs;
}
function Az() {
  return J0().listeners;
}
function J0() {
  var e = _n;
  return e._setupContext || (e._setupContext = kS(e));
}
function Lz(e, t) {
  var n = ue(e) ? e.reduce(function(i, a) {
    return i[a] = {}, i;
  }, {}) : e;
  for (var s in t) {
    var r = n[s];
    r ? ue(r) || Ae(r) ? n[s] = { type: r, default: t[s] } : r.default = t[s] : r === null && (n[s] = { default: t[s] });
  }
  return n;
}
function Rz(e) {
  e._vnode = null, e._staticTrees = null;
  var t = e.$options, n = e.$vnode = t._parentVnode, s = n && n.context;
  e.$slots = Z0(t._renderChildren, s), e.$scopedSlots = n ? sc(e.$parent, n.data.scopedSlots, e.$slots) : ci, e._c = function(i, a, o, l) {
    return Ic(e, i, a, o, l, !1);
  }, e.$createElement = function(i, a, o, l) {
    return Ic(e, i, a, o, l, !0);
  };
  var r = n && n.data;
  to(e, "$attrs", r && r.attrs || ci, null, !0), to(e, "$listeners", t._parentListeners || ci, null, !0);
}
var gv = null;
function wz(e) {
  GS(e.prototype), e.prototype.$nextTick = function(t) {
    return tp(t, this);
  }, e.prototype._render = function() {
    var t = this, n = t.$options, s = n.render, r = n._parentVnode;
    r && t._isMounted && (t.$scopedSlots = sc(t.$parent, r.data.scopedSlots, t.$slots, t.$scopedSlots), t._slotsProxy && HS(t._slotsProxy, t.$scopedSlots)), t.$vnode = r;
    var i;
    try {
      Qa(t), gv = t, i = s.call(t._renderProxy, t.$createElement);
    } catch (a) {
      ko(a, t, "render"), i = t._vnode;
    } finally {
      gv = null, Qa();
    }
    return ue(i) && i.length === 1 && (i = i[0]), i instanceof ir || (i = So()), i.parent = r, i;
  };
}
function Wm(e, t) {
  return (e.__esModule || qc && e[Symbol.toStringTag] === "Module") && (e = e.default), pi(e) ? t.extend(e) : e;
}
function Vz(e, t, n, s, r) {
  var i = So();
  return i.asyncFactory = e, i.asyncMeta = { data: t, context: n, children: s, tag: r }, i;
}
function Bz(e, t) {
  if (ln(e.error) && ht(e.errorComp))
    return e.errorComp;
  if (ht(e.resolved))
    return e.resolved;
  var n = gv;
  if (n && ht(e.owners) && e.owners.indexOf(n) === -1 && e.owners.push(n), ln(e.loading) && ht(e.loadingComp))
    return e.loadingComp;
  if (n && !ht(e.owners)) {
    var s = e.owners = [n], r = !0, i = null, a = null;
    n.$on("hook:destroyed", function() {
      return no(s, n);
    });
    var o = function(u) {
      for (var c = 0, h = s.length; c < h; c++)
        s[c].$forceUpdate();
      u && (s.length = 0, i !== null && (clearTimeout(i), i = null), a !== null && (clearTimeout(a), a = null));
    }, l = Xd(function(u) {
      e.resolved = Wm(u, t), r ? s.length = 0 : o(!0);
    }), f = Xd(function(u) {
      ht(e.errorComp) && (e.error = !0, o(!0));
    }), d = e(l, f);
    return pi(d) && (cv(d) ? te(e.resolved) && d.then(l, f) : cv(d.component) && (d.component.then(l, f), ht(d.error) && (e.errorComp = Wm(d.error, t)), ht(d.loading) && (e.loadingComp = Wm(d.loading, t), d.delay === 0 ? e.loading = !0 : i = setTimeout(function() {
      i = null, te(e.resolved) && te(e.error) && (e.loading = !0, o(!1));
    }, d.delay || 200)), ht(d.timeout) && (a = setTimeout(function() {
      a = null, te(e.resolved) && f(null);
    }, d.timeout)))), r = !1, e.loading ? e.loadingComp : e.resolved;
  }
}
function YS(e) {
  if (ue(e))
    for (var t = 0; t < e.length; t++) {
      var n = e[t];
      if (ht(n) && (ht(n.componentOptions) || Sc(n)))
        return n;
    }
}
var Nz = 1, XS = 2;
function Ic(e, t, n, s, r, i) {
  return (ue(n) || Jc(n)) && (r = s, s = n, n = void 0), ln(i) && (r = XS), Fz(e, t, n, s, r);
}
function Fz(e, t, n, s, r) {
  if (ht(n) && ht(n.__ob__) || (ht(n) && ht(n.is) && (t = n.is), !t))
    return So();
  ue(s) && Ae(s[0]) && (n = n || {}, n.scopedSlots = { default: s[0] }, s.length = 0), r === XS ? s = X0(s) : r === Nz && (s = dz(s));
  var i, a;
  if (typeof t == "string") {
    var o = void 0;
    a = e.$vnode && e.$vnode.ns || gr.getTagNamespace(t), gr.isReservedTag(t) ? i = new ir(gr.parsePlatformTagName(t), n, s, void 0, void 0, e) : (!n || !n.pre) && ht(o = rf(e.$options, "components", t)) ? i = qb(o, n, e, s, t) : i = new ir(t, n, s, void 0, void 0, e);
  } else
    i = qb(t, n, e, s);
  return ue(i) ? i : ht(i) ? (ht(a) && ZS(i, a), ht(n) && jz(n), i) : So();
}
function ZS(e, t, n) {
  if (e.ns = t, e.tag === "foreignObject" && (t = void 0, n = !0), ht(e.children))
    for (var s = 0, r = e.children.length; s < r; s++) {
      var i = e.children[s];
      ht(i.tag) && (te(i.ns) || ln(n) && i.tag !== "svg") && ZS(i, t, n);
    }
}
function jz(e) {
  pi(e.style) && ru(e.style), pi(e.class) && ru(e.class);
}
function Uz(e, t, n) {
  return Ic(_n, e, t, n, 2, !0);
}
function ko(e, t, n) {
  Tu();
  try {
    if (t)
      for (var s = t; s = s.$parent; ) {
        var r = s.$options.errorCaptured;
        if (r)
          for (var i = 0; i < r.length; i++)
            try {
              var a = r[i].call(s, e, t, n) === !1;
              if (a)
                return;
            } catch (o) {
              kb(o, s, "errorCaptured hook");
            }
      }
    kb(e, t, n);
  } finally {
    Pu();
  }
}
function ea(e, t, n, s, r) {
  var i;
  try {
    i = n ? e.apply(t, n) : e.call(t), i && !i._isVue && cv(i) && !i._handled && (i.catch(function(a) {
      return ko(a, s, r + " (Promise/async)");
    }), i._handled = !0);
  } catch (a) {
    ko(a, s, r);
  }
  return i;
}
function kb(e, t, n) {
  if (gr.errorHandler)
    try {
      return gr.errorHandler.call(null, e, t, n);
    } catch (s) {
      s !== e && Hb(s);
    }
  Hb(e);
}
function Hb(e, t, n) {
  if (zi && typeof console < "u")
    console.error(e);
  else
    throw e;
}
var vv = !1, yv = [], Ev = !1;
function Nh() {
  Ev = !1;
  var e = yv.slice(0);
  yv.length = 0;
  for (var t = 0; t < e.length; t++)
    e[t]();
}
var Ju;
if (typeof Promise < "u" && kl(Promise)) {
  var Wz = Promise.resolve();
  Ju = function() {
    Wz.then(Nh), V5 && setTimeout(rn);
  }, vv = !0;
} else if (!bu && typeof MutationObserver < "u" && (kl(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  var Fh = 1, $z = new MutationObserver(Nh), Yb = document.createTextNode(String(Fh));
  $z.observe(Yb, {
    characterData: !0
  }), Ju = function() {
    Fh = (Fh + 1) % 2, Yb.data = String(Fh);
  }, vv = !0;
} else
  typeof setImmediate < "u" && kl(setImmediate) ? Ju = function() {
    setImmediate(Nh);
  } : Ju = function() {
    setTimeout(Nh, 0);
  };
function tp(e, t) {
  var n;
  if (yv.push(function() {
    if (e)
      try {
        e.call(t);
      } catch (s) {
        ko(s, t, "nextTick");
      }
    else
      n && n(t);
  }), Ev || (Ev = !0, Ju()), !e && typeof Promise < "u")
    return new Promise(function(s) {
      n = s;
    });
}
function zz(e) {
  e === void 0 && (e = "$style");
  {
    if (!_n)
      return ci;
    var t = _n[e];
    return t || ci;
  }
}
function Kz(e) {
  if (zi) {
    var t = _n;
    t && FS(function() {
      var n = t.$el, s = e(t, t._setupProxy);
      if (n && n.nodeType === 1) {
        var r = n.style;
        for (var i in s)
          r.setProperty("--".concat(i), s[i]);
      }
    });
  }
}
function Gz(e) {
  Ae(e) && (e = { loader: e });
  var t = e.loader, n = e.loadingComponent, s = e.errorComponent, r = e.delay, i = r === void 0 ? 200 : r, a = e.timeout;
  e.suspensible;
  var o = e.onError, l = null, f = 0, d = function() {
    return f++, l = null, u();
  }, u = function() {
    var c;
    return l || (c = l = t().catch(function(h) {
      if (h = h instanceof Error ? h : new Error(String(h)), o)
        return new Promise(function(p, g) {
          var m = function() {
            return p(d());
          }, v = function() {
            return g(h);
          };
          o(h, m, v, f + 1);
        });
      throw h;
    }).then(function(h) {
      return c !== l && l ? l : (h && (h.__esModule || h[Symbol.toStringTag] === "Module") && (h = h.default), h);
    }));
  };
  return function() {
    var c = u();
    return {
      component: c,
      delay: i,
      timeout: a,
      error: s,
      loading: n
    };
  };
}
function xr(e) {
  return function(t, n) {
    if (n === void 0 && (n = _n), !!n)
      return kz(n, e, t);
  };
}
function kz(e, t, n) {
  var s = e.$options;
  s[t] = rI(s[t], n);
}
var Hz = xr("beforeMount"), Yz = xr("mounted"), Xz = xr("beforeUpdate"), Zz = xr("updated"), Jz = xr("beforeDestroy"), Qz = xr("destroyed"), qz = xr("activated"), tK = xr("deactivated"), eK = xr("serverPrefetch"), nK = xr("renderTracked"), iK = xr("renderTriggered"), rK = xr("errorCaptured");
function sK(e, t) {
  t === void 0 && (t = _n), rK(e, t);
}
var JS = "2.7.15";
function aK(e) {
  return e;
}
var Xb = new Mc();
function ru(e) {
  return cd(e, Xb), Xb.clear(), e;
}
function cd(e, t) {
  var n, s, r = ue(e);
  if (!(!r && !pi(e) || e.__v_skip || Object.isFrozen(e) || e instanceof ir)) {
    if (e.__ob__) {
      var i = e.__ob__.dep.id;
      if (t.has(i))
        return;
      t.add(i);
    }
    if (r)
      for (n = e.length; n--; )
        cd(e[n], t);
    else if (ei(e))
      cd(e.value, t);
    else
      for (s = Object.keys(e), n = s.length; n--; )
        cd(e[s[n]], t);
  }
}
var oK = 0, eh = (
  /** @class */
  function() {
    function e(t, n, s, r, i) {
      oz(
        this,
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        li && !li._vm ? li : t ? t._scope : void 0
      ), (this.vm = t) && i && (t._watcher = this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = s, this.id = ++oK, this.active = !0, this.post = !1, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new Mc(), this.newDepIds = new Mc(), this.expression = "", Ae(n) ? this.getter = n : (this.getter = R5(n), this.getter || (this.getter = rn)), this.value = this.lazy ? void 0 : this.get();
    }
    return e.prototype.get = function() {
      Tu(this);
      var t, n = this.vm;
      try {
        t = this.getter.call(n, n);
      } catch (s) {
        if (this.user)
          ko(s, n, 'getter for watcher "'.concat(this.expression, '"'));
        else
          throw s;
      } finally {
        this.deep && ru(t), Pu(), this.cleanupDeps();
      }
      return t;
    }, e.prototype.addDep = function(t) {
      var n = t.id;
      this.newDepIds.has(n) || (this.newDepIds.add(n), this.newDeps.push(t), this.depIds.has(n) || t.addSub(this));
    }, e.prototype.cleanupDeps = function() {
      for (var t = this.deps.length; t--; ) {
        var n = this.deps[t];
        this.newDepIds.has(n.id) || n.removeSub(this);
      }
      var s = this.depIds;
      this.depIds = this.newDepIds, this.newDepIds = s, this.newDepIds.clear(), s = this.deps, this.deps = this.newDeps, this.newDeps = s, this.newDeps.length = 0;
    }, e.prototype.update = function() {
      this.lazy ? this.dirty = !0 : this.sync ? this.run() : bv(this);
    }, e.prototype.run = function() {
      if (this.active) {
        var t = this.get();
        if (t !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        pi(t) || this.deep) {
          var n = this.value;
          if (this.value = t, this.user) {
            var s = 'callback for watcher "'.concat(this.expression, '"');
            ea(this.cb, this.vm, [t, n], this.vm, s);
          } else
            this.cb.call(this.vm, t, n);
        }
      }
    }, e.prototype.evaluate = function() {
      this.value = this.get(), this.dirty = !1;
    }, e.prototype.depend = function() {
      for (var t = this.deps.length; t--; )
        this.deps[t].depend();
    }, e.prototype.teardown = function() {
      if (this.vm && !this.vm._isBeingDestroyed && no(this.vm._scope.effects, this), this.active) {
        for (var t = this.deps.length; t--; )
          this.deps[t].removeSub(this);
        this.active = !1, this.onStop && this.onStop();
      }
    }, e;
  }()
);
function lK(e) {
  e._events = /* @__PURE__ */ Object.create(null), e._hasHookEvent = !1;
  var t = e.$options._parentListeners;
  t && QS(e, t);
}
var _c;
function uK(e, t) {
  _c.$on(e, t);
}
function cK(e, t) {
  _c.$off(e, t);
}
function hK(e, t) {
  var n = _c;
  return function s() {
    var r = t.apply(null, arguments);
    r !== null && n.$off(e, s);
  };
}
function QS(e, t, n) {
  _c = e, WS(t, n || {}, uK, cK, hK, e), _c = void 0;
}
function dK(e) {
  var t = /^hook:/;
  e.prototype.$on = function(n, s) {
    var r = this;
    if (ue(n))
      for (var i = 0, a = n.length; i < a; i++)
        r.$on(n[i], s);
    else
      (r._events[n] || (r._events[n] = [])).push(s), t.test(n) && (r._hasHookEvent = !0);
    return r;
  }, e.prototype.$once = function(n, s) {
    var r = this;
    function i() {
      r.$off(n, i), s.apply(r, arguments);
    }
    return i.fn = s, r.$on(n, i), r;
  }, e.prototype.$off = function(n, s) {
    var r = this;
    if (!arguments.length)
      return r._events = /* @__PURE__ */ Object.create(null), r;
    if (ue(n)) {
      for (var i = 0, a = n.length; i < a; i++)
        r.$off(n[i], s);
      return r;
    }
    var o = r._events[n];
    if (!o)
      return r;
    if (!s)
      return r._events[n] = null, r;
    for (var l, f = o.length; f--; )
      if (l = o[f], l === s || l.fn === s) {
        o.splice(f, 1);
        break;
      }
    return r;
  }, e.prototype.$emit = function(n) {
    var s = this, r = s._events[n];
    if (r) {
      r = r.length > 1 ? hv(r) : r;
      for (var i = hv(arguments, 1), a = 'event handler for "'.concat(n, '"'), o = 0, l = r.length; o < l; o++)
        ea(r[o], s, i, s, a);
    }
    return s;
  };
}
var _o = null;
function qS(e) {
  var t = _o;
  return _o = e, function() {
    _o = t;
  };
}
function fK(e) {
  var t = e.$options, n = t.parent;
  if (n && !t.abstract) {
    for (; n.$options.abstract && n.$parent; )
      n = n.$parent;
    n.$children.push(e);
  }
  e.$parent = n, e.$root = n ? n.$root : e, e.$children = [], e.$refs = {}, e._provided = n ? n._provided : /* @__PURE__ */ Object.create(null), e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1;
}
function pK(e) {
  e.prototype._update = function(t, n) {
    var s = this, r = s.$el, i = s._vnode, a = qS(s);
    s._vnode = t, i ? s.$el = s.__patch__(i, t) : s.$el = s.__patch__(
      s.$el,
      t,
      n,
      !1
      /* removeOnly */
    ), a(), r && (r.__vue__ = null), s.$el && (s.$el.__vue__ = s);
    for (var o = s; o && o.$vnode && o.$parent && o.$vnode === o.$parent._vnode; )
      o.$parent.$el = o.$el, o = o.$parent;
  }, e.prototype.$forceUpdate = function() {
    var t = this;
    t._watcher && t._watcher.update();
  }, e.prototype.$destroy = function() {
    var t = this;
    if (!t._isBeingDestroyed) {
      Br(t, "beforeDestroy"), t._isBeingDestroyed = !0;
      var n = t.$parent;
      n && !n._isBeingDestroyed && !t.$options.abstract && no(n.$children, t), t._scope.stop(), t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), Br(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null);
    }
  };
}
function mK(e, t, n) {
  e.$el = t, e.$options.render || (e.$options.render = So), Br(e, "beforeMount");
  var s;
  s = function() {
    e._update(e._render(), n);
  };
  var r = {
    before: function() {
      e._isMounted && !e._isDestroyed && Br(e, "beforeUpdate");
    }
  };
  new eh(
    e,
    s,
    rn,
    r,
    !0
    /* isRenderWatcher */
  ), n = !1;
  var i = e._preWatchers;
  if (i)
    for (var a = 0; a < i.length; a++)
      i[a].run();
  return e.$vnode == null && (e._isMounted = !0, Br(e, "mounted")), e;
}
function gK(e, t, n, s, r) {
  var i = s.data.scopedSlots, a = e.$scopedSlots, o = !!(i && !i.$stable || a !== ci && !a.$stable || i && e.$scopedSlots.$key !== i.$key || !i && e.$scopedSlots.$key), l = !!(r || // has new static slots
  e.$options._renderChildren || // has old static slots
  o), f = e.$vnode;
  e.$options._parentVnode = s, e.$vnode = s, e._vnode && (e._vnode.parent = s), e.$options._renderChildren = r;
  var d = s.data.attrs || ci;
  e._attrsProxy && tf(e._attrsProxy, d, f.data && f.data.attrs || ci, e, "$attrs") && (l = !0), e.$attrs = d, n = n || ci;
  var u = e.$options._parentListeners;
  if (e._listenersProxy && tf(e._listenersProxy, n, u || ci, e, "$listeners"), e.$listeners = e.$options._parentListeners = n, QS(e, n, u), t && e.$options.props) {
    qa(!1);
    for (var c = e._props, h = e.$options._propKeys || [], p = 0; p < h.length; p++) {
      var g = h[p], m = e.$options.props;
      c[g] = iE(g, m, t, e);
    }
    qa(!0), e.$options.propsData = t;
  }
  l && (e.$slots = Z0(r, s.context), e.$forceUpdate());
}
function tI(e) {
  for (; e && (e = e.$parent); )
    if (e._inactive)
      return !0;
  return !1;
}
function Q0(e, t) {
  if (t) {
    if (e._directInactive = !1, tI(e))
      return;
  } else if (e._directInactive)
    return;
  if (e._inactive || e._inactive === null) {
    e._inactive = !1;
    for (var n = 0; n < e.$children.length; n++)
      Q0(e.$children[n]);
    Br(e, "activated");
  }
}
function eI(e, t) {
  if (!(t && (e._directInactive = !0, tI(e))) && !e._inactive) {
    e._inactive = !0;
    for (var n = 0; n < e.$children.length; n++)
      eI(e.$children[n]);
    Br(e, "deactivated");
  }
}
function Br(e, t, n, s) {
  s === void 0 && (s = !0), Tu();
  var r = _n, i = jS();
  s && Qa(e);
  var a = e.$options[t], o = "".concat(t, " hook");
  if (a)
    for (var l = 0, f = a.length; l < f; l++)
      ea(a[l], e, n || null, e, o);
  e._hasHookEvent && e.$emit("hook:" + t), s && (Qa(r), i && i.on()), Pu();
}
var Ws = [], q0 = [], ef = {}, Cv = !1, tE = !1, Al = 0;
function vK() {
  Al = Ws.length = q0.length = 0, ef = {}, Cv = tE = !1;
}
var nI = 0, xv = Date.now;
if (zi && !bu) {
  var $m = window.performance;
  $m && typeof $m.now == "function" && xv() > document.createEvent("Event").timeStamp && (xv = function() {
    return $m.now();
  });
}
var yK = function(e, t) {
  if (e.post) {
    if (!t.post)
      return 1;
  } else if (t.post)
    return -1;
  return e.id - t.id;
};
function EK() {
  nI = xv(), tE = !0;
  var e, t;
  for (Ws.sort(yK), Al = 0; Al < Ws.length; Al++)
    e = Ws[Al], e.before && e.before(), t = e.id, ef[t] = null, e.run();
  var n = q0.slice(), s = Ws.slice();
  vK(), bK(n), CK(s), F5(), Zd && gr.devtools && Zd.emit("flush");
}
function CK(e) {
  for (var t = e.length; t--; ) {
    var n = e[t], s = n.vm;
    s && s._watcher === n && s._isMounted && !s._isDestroyed && Br(s, "updated");
  }
}
function xK(e) {
  e._inactive = !1, q0.push(e);
}
function bK(e) {
  for (var t = 0; t < e.length; t++)
    e[t]._inactive = !0, Q0(
      e[t],
      !0
      /* true */
    );
}
function bv(e) {
  var t = e.id;
  if (ef[t] == null && !(e === vs.target && e.noRecurse)) {
    if (ef[t] = !0, !tE)
      Ws.push(e);
    else {
      for (var n = Ws.length - 1; n > Al && Ws[n].id > e.id; )
        n--;
      Ws.splice(n + 1, 0, e);
    }
    Cv || (Cv = !0, tp(EK));
  }
}
function OK(e) {
  var t = e.$options.provide;
  if (t) {
    var n = Ae(t) ? t.call(e) : t;
    if (!pi(n))
      return;
    for (var s = US(e), r = qc ? Reflect.ownKeys(n) : Object.keys(n), i = 0; i < r.length; i++) {
      var a = r[i];
      Object.defineProperty(s, a, Object.getOwnPropertyDescriptor(n, a));
    }
  }
}
function TK(e) {
  var t = iI(e.$options.inject, e);
  t && (qa(!1), Object.keys(t).forEach(function(n) {
    to(e, n, t[n]);
  }), qa(!0));
}
function iI(e, t) {
  if (e) {
    for (var n = /* @__PURE__ */ Object.create(null), s = qc ? Reflect.ownKeys(e) : Object.keys(e), r = 0; r < s.length; r++) {
      var i = s[r];
      if (i !== "__ob__") {
        var a = e[i].from;
        if (a in t._provided)
          n[i] = t._provided[a];
        else if ("default" in e[i]) {
          var o = e[i].default;
          n[i] = Ae(o) ? o.call(t) : o;
        }
      }
    }
    return n;
  }
}
function eE(e, t, n, s, r) {
  var i = this, a = r.options, o;
  Si(s, "_uid") ? (o = Object.create(s), o._original = s) : (o = s, s = s._original);
  var l = ln(a._compiled), f = !l;
  this.data = e, this.props = t, this.children = n, this.parent = s, this.listeners = e.on || ci, this.injections = iI(a.inject, s), this.slots = function() {
    return i.$slots || sc(s, e.scopedSlots, i.$slots = Z0(n, s)), i.$slots;
  }, Object.defineProperty(this, "scopedSlots", {
    enumerable: !0,
    get: function() {
      return sc(s, e.scopedSlots, this.slots());
    }
  }), l && (this.$options = a, this.$slots = this.slots(), this.$scopedSlots = sc(s, e.scopedSlots, this.$slots)), a._scopeId ? this._c = function(d, u, c, h) {
    var p = Ic(o, d, u, c, h, f);
    return p && !ue(p) && (p.fnScopeId = a._scopeId, p.fnContext = s), p;
  } : this._c = function(d, u, c, h) {
    return Ic(o, d, u, c, h, f);
  };
}
GS(eE.prototype);
function PK(e, t, n, s, r) {
  var i = e.options, a = {}, o = i.props;
  if (ht(o))
    for (var l in o)
      a[l] = iE(l, o, t || ci);
  else
    ht(n.attrs) && Jb(a, n.attrs), ht(n.props) && Jb(a, n.props);
  var f = new eE(n, a, r, s, e), d = i.render.call(null, f._c, f);
  if (d instanceof ir)
    return Zb(d, n, f.parent, i);
  if (ue(d)) {
    for (var u = X0(d) || [], c = new Array(u.length), h = 0; h < u.length; h++)
      c[h] = Zb(u[h], n, f.parent, i);
    return c;
  }
}
function Zb(e, t, n, s, r) {
  var i = pv(e);
  return i.fnContext = n, i.fnOptions = s, t.slot && ((i.data || (i.data = {})).slot = t.slot), i;
}
function Jb(e, t) {
  for (var n in t)
    e[Ko(n)] = t[n];
}
function nf(e) {
  return e.name || e.__name || e._componentTag;
}
var nE = {
  init: function(e, t) {
    if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) {
      var n = e;
      nE.prepatch(n, n);
    } else {
      var s = e.componentInstance = MK(e, _o);
      s.$mount(t ? e.elm : void 0, t);
    }
  },
  prepatch: function(e, t) {
    var n = t.componentOptions, s = t.componentInstance = e.componentInstance;
    gK(
      s,
      n.propsData,
      // updated props
      n.listeners,
      // updated listeners
      t,
      // new parent vnode
      n.children
      // new children
    );
  },
  insert: function(e) {
    var t = e.context, n = e.componentInstance;
    n._isMounted || (n._isMounted = !0, Br(n, "mounted")), e.data.keepAlive && (t._isMounted ? xK(n) : Q0(
      n,
      !0
      /* direct */
    ));
  },
  destroy: function(e) {
    var t = e.componentInstance;
    t._isDestroyed || (e.data.keepAlive ? eI(
      t,
      !0
      /* direct */
    ) : t.$destroy());
  }
}, Qb = Object.keys(nE);
function qb(e, t, n, s, r) {
  if (!te(e)) {
    var i = n.$options._base;
    if (pi(e) && (e = i.extend(e)), typeof e == "function") {
      var a;
      if (te(e.cid) && (a = e, e = Bz(a, i), e === void 0))
        return Vz(a, t, n, s, r);
      t = t || {}, sE(e), ht(t.model) && _K(e.options, t);
      var o = hz(t, e);
      if (ln(e.options.functional))
        return PK(e, o, t, n, s);
      var l = t.on;
      if (t.on = t.nativeOn, ln(e.options.abstract)) {
        var f = t.slot;
        t = {}, f && (t.slot = f);
      }
      SK(t);
      var d = nf(e.options) || r, u = new ir(
        // @ts-expect-error
        "vue-component-".concat(e.cid).concat(d ? "-".concat(d) : ""),
        t,
        void 0,
        void 0,
        void 0,
        n,
        // @ts-expect-error
        { Ctor: e, propsData: o, listeners: l, tag: r, children: s },
        a
      );
      return u;
    }
  }
}
function MK(e, t) {
  var n = {
    _isComponent: !0,
    _parentVnode: e,
    parent: t
  }, s = e.data.inlineTemplate;
  return ht(s) && (n.render = s.render, n.staticRenderFns = s.staticRenderFns), new e.componentOptions.Ctor(n);
}
function SK(e) {
  for (var t = e.hook || (e.hook = {}), n = 0; n < Qb.length; n++) {
    var s = Qb[n], r = t[s], i = nE[s];
    r !== i && !(r && r._merged) && (t[s] = r ? IK(i, r) : i);
  }
}
function IK(e, t) {
  var n = function(s, r) {
    e(s, r), t(s, r);
  };
  return n._merged = !0, n;
}
function _K(e, t) {
  var n = e.model && e.model.prop || "value", s = e.model && e.model.event || "input";
  (t.attrs || (t.attrs = {}))[n] = t.model.value;
  var r = t.on || (t.on = {}), i = r[s], a = t.model.callback;
  ht(i) ? (ue(i) ? i.indexOf(a) === -1 : i !== a) && (r[s] = [a].concat(i)) : r[s] = a;
}
var DK = rn, us = gr.optionMergeStrategies;
function Dc(e, t, n) {
  if (n === void 0 && (n = !0), !t)
    return e;
  for (var s, r, i, a = qc ? Reflect.ownKeys(t) : Object.keys(t), o = 0; o < a.length; o++)
    s = a[o], s !== "__ob__" && (r = e[s], i = t[s], !n || !Si(e, s) ? Jf(e, s, i) : r !== i && _i(r) && _i(i) && Dc(r, i));
  return e;
}
function tO(e, t, n) {
  return n ? function() {
    var r = Ae(t) ? t.call(n, n) : t, i = Ae(e) ? e.call(n, n) : e;
    return r ? Dc(r, i) : i;
  } : t ? e ? function() {
    return Dc(Ae(t) ? t.call(this, this) : t, Ae(e) ? e.call(this, this) : e);
  } : t : e;
}
us.data = function(e, t, n) {
  return n ? tO(e, t, n) : t && typeof t != "function" ? e : tO(e, t);
};
function rI(e, t) {
  var n = t ? e ? e.concat(t) : ue(t) ? t : [t] : e;
  return n && AK(n);
}
function AK(e) {
  for (var t = [], n = 0; n < e.length; n++)
    t.indexOf(e[n]) === -1 && t.push(e[n]);
  return t;
}
PS.forEach(function(e) {
  us[e] = rI;
});
function LK(e, t, n, s) {
  var r = Object.create(e || null);
  return t ? He(r, t) : r;
}
Zf.forEach(function(e) {
  us[e + "s"] = LK;
});
us.watch = function(e, t, n, s) {
  if (e === fv && (e = void 0), t === fv && (t = void 0), !t)
    return Object.create(e || null);
  if (!e)
    return t;
  var r = {};
  He(r, e);
  for (var i in t) {
    var a = r[i], o = t[i];
    a && !ue(a) && (a = [a]), r[i] = a ? a.concat(o) : ue(o) ? o : [o];
  }
  return r;
};
us.props = us.methods = us.inject = us.computed = function(e, t, n, s) {
  if (!e)
    return t;
  var r = /* @__PURE__ */ Object.create(null);
  return He(r, e), t && He(r, t), r;
};
us.provide = function(e, t) {
  return e ? function() {
    var n = /* @__PURE__ */ Object.create(null);
    return Dc(n, Ae(e) ? e.call(this) : e), t && Dc(
      n,
      Ae(t) ? t.call(this) : t,
      !1
      // non-recursive
    ), n;
  } : t;
};
var RK = function(e, t) {
  return t === void 0 ? e : t;
};
function wK(e, t) {
  var n = e.props;
  if (n) {
    var s = {}, r, i, a;
    if (ue(n))
      for (r = n.length; r--; )
        i = n[r], typeof i == "string" && (a = Ko(i), s[a] = { type: null });
    else if (_i(n))
      for (var o in n)
        i = n[o], a = Ko(o), s[a] = _i(i) ? i : { type: i };
    e.props = s;
  }
}
function VK(e, t) {
  var n = e.inject;
  if (n) {
    var s = e.inject = {};
    if (ue(n))
      for (var r = 0; r < n.length; r++)
        s[n[r]] = { from: n[r] };
    else if (_i(n))
      for (var i in n) {
        var a = n[i];
        s[i] = _i(a) ? He({ from: i }, a) : { from: a };
      }
  }
}
function BK(e) {
  var t = e.directives;
  if (t)
    for (var n in t) {
      var s = t[n];
      Ae(s) && (t[n] = { bind: s, update: s });
    }
}
function Ho(e, t, n) {
  if (Ae(t) && (t = t.options), wK(t), VK(t), BK(t), !t._base && (t.extends && (e = Ho(e, t.extends, n)), t.mixins))
    for (var s = 0, r = t.mixins.length; s < r; s++)
      e = Ho(e, t.mixins[s], n);
  var i = {}, a;
  for (a in e)
    o(a);
  for (a in t)
    Si(e, a) || o(a);
  function o(l) {
    var f = us[l] || RK;
    i[l] = f(e[l], t[l], n, l);
  }
  return i;
}
function rf(e, t, n, s) {
  if (typeof n == "string") {
    var r = e[t];
    if (Si(r, n))
      return r[n];
    var i = Ko(n);
    if (Si(r, i))
      return r[i];
    var a = S5(i);
    if (Si(r, a))
      return r[a];
    var o = r[n] || r[i] || r[a];
    return o;
  }
}
function iE(e, t, n, s) {
  var r = t[e], i = !Si(n, e), a = n[e], o = nO(Boolean, r.type);
  if (o > -1) {
    if (i && !Si(r, "default"))
      a = !1;
    else if (a === "" || a === Qc(e)) {
      var l = nO(String, r.type);
      (l < 0 || o < l) && (a = !0);
    }
  }
  if (a === void 0) {
    a = NK(s, r, e);
    var f = G0;
    qa(!0), ta(a), qa(f);
  }
  return a;
}
function NK(e, t, n) {
  if (Si(t, "default")) {
    var s = t.default;
    return e && e.$options.propsData && e.$options.propsData[n] === void 0 && e._props[n] !== void 0 ? e._props[n] : Ae(s) && Ov(t.type) !== "Function" ? s.call(e) : s;
  }
}
var FK = /^\s*function (\w+)/;
function Ov(e) {
  var t = e && e.toString().match(FK);
  return t ? t[1] : "";
}
function eO(e, t) {
  return Ov(e) === Ov(t);
}
function nO(e, t) {
  if (!ue(t))
    return eO(t, e) ? 0 : -1;
  for (var n = 0, s = t.length; n < s; n++)
    if (eO(t[n], e))
      return n;
  return -1;
}
var Ea = {
  enumerable: !0,
  configurable: !0,
  get: rn,
  set: rn
};
function rE(e, t, n) {
  Ea.get = function() {
    return this[t][n];
  }, Ea.set = function(r) {
    this[t][n] = r;
  }, Object.defineProperty(e, n, Ea);
}
function jK(e) {
  var t = e.$options;
  if (t.props && UK(e, t.props), Mz(e), t.methods && GK(e, t.methods), t.data)
    WK(e);
  else {
    var n = ta(e._data = {});
    n && n.vmCount++;
  }
  t.computed && KK(e, t.computed), t.watch && t.watch !== fv && kK(e, t.watch);
}
function UK(e, t) {
  var n = e.$options.propsData || {}, s = e._props = H0({}), r = e.$options._propKeys = [], i = !e.$parent;
  i || qa(!1);
  var a = function(l) {
    r.push(l);
    var f = iE(l, t, n, e);
    to(s, l, f), l in e || rE(e, "_props", l);
  };
  for (var o in t)
    a(o);
  qa(!0);
}
function WK(e) {
  var t = e.$options.data;
  t = e._data = Ae(t) ? $K(t, e) : t || {}, _i(t) || (t = {});
  var n = Object.keys(t), s = e.$options.props;
  e.$options.methods;
  for (var r = n.length; r--; ) {
    var i = n[r];
    s && Si(s, i) || MS(i) || rE(e, "_data", i);
  }
  var a = ta(t);
  a && a.vmCount++;
}
function $K(e, t) {
  Tu();
  try {
    return e.call(t, t);
  } catch (n) {
    return ko(n, t, "data()"), {};
  } finally {
    Pu();
  }
}
var zK = { lazy: !0 };
function KK(e, t) {
  var n = e._computedWatchers = /* @__PURE__ */ Object.create(null), s = io();
  for (var r in t) {
    var i = t[r], a = Ae(i) ? i : i.get;
    s || (n[r] = new eh(e, a || rn, rn, zK)), r in e || sI(e, r, i);
  }
}
function sI(e, t, n) {
  var s = !io();
  Ae(n) ? (Ea.get = s ? iO(t) : rO(n), Ea.set = rn) : (Ea.get = n.get ? s && n.cache !== !1 ? iO(t) : rO(n.get) : rn, Ea.set = n.set || rn), Object.defineProperty(e, t, Ea);
}
function iO(e) {
  return function() {
    var n = this._computedWatchers && this._computedWatchers[e];
    if (n)
      return n.dirty && n.evaluate(), vs.target && n.depend(), n.value;
  };
}
function rO(e) {
  return function() {
    return e.call(this, this);
  };
}
function GK(e, t) {
  e.$options.props;
  for (var n in t)
    e[n] = typeof t[n] != "function" ? rn : xS(t[n], e);
}
function kK(e, t) {
  for (var n in t) {
    var s = t[n];
    if (ue(s))
      for (var r = 0; r < s.length; r++)
        Tv(e, n, s[r]);
    else
      Tv(e, n, s);
  }
}
function Tv(e, t, n, s) {
  return _i(n) && (s = n, n = n.handler), typeof n == "string" && (n = e[n]), e.$watch(t, n, s);
}
function HK(e) {
  var t = {};
  t.get = function() {
    return this._data;
  };
  var n = {};
  n.get = function() {
    return this._props;
  }, Object.defineProperty(e.prototype, "$data", t), Object.defineProperty(e.prototype, "$props", n), e.prototype.$set = Jf, e.prototype.$delete = k0, e.prototype.$watch = function(s, r, i) {
    var a = this;
    if (_i(r))
      return Tv(a, s, r, i);
    i = i || {}, i.user = !0;
    var o = new eh(a, s, r, i);
    if (i.immediate) {
      var l = 'callback for immediate watcher "'.concat(o.expression, '"');
      Tu(), ea(r, a, [o.value], a, l), Pu();
    }
    return function() {
      o.teardown();
    };
  };
}
var YK = 0;
function XK(e) {
  e.prototype._init = function(t) {
    var n = this;
    n._uid = YK++, n._isVue = !0, n.__v_skip = !0, n._scope = new Y0(
      !0
      /* detached */
    ), n._scope._vm = !0, t && t._isComponent ? ZK(n, t) : n.$options = Ho(sE(n.constructor), t || {}, n), n._renderProxy = n, n._self = n, fK(n), lK(n), Rz(n), Br(
      n,
      "beforeCreate",
      void 0,
      !1
      /* setContext */
    ), TK(n), jK(n), OK(n), Br(n, "created"), n.$options.el && n.$mount(n.$options.el);
  };
}
function ZK(e, t) {
  var n = e.$options = Object.create(e.constructor.options), s = t._parentVnode;
  n.parent = t.parent, n._parentVnode = s;
  var r = s.componentOptions;
  n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, t.render && (n.render = t.render, n.staticRenderFns = t.staticRenderFns);
}
function sE(e) {
  var t = e.options;
  if (e.super) {
    var n = sE(e.super), s = e.superOptions;
    if (n !== s) {
      e.superOptions = n;
      var r = JK(e);
      r && He(e.extendOptions, r), t = e.options = Ho(n, e.extendOptions), t.name && (t.components[t.name] = e);
    }
  }
  return t;
}
function JK(e) {
  var t, n = e.options, s = e.sealedOptions;
  for (var r in n)
    n[r] !== s[r] && (t || (t = {}), t[r] = n[r]);
  return t;
}
function $t(e) {
  this._init(e);
}
XK($t);
HK($t);
dK($t);
pK($t);
wz($t);
function QK(e) {
  e.use = function(t) {
    var n = this._installedPlugins || (this._installedPlugins = []);
    if (n.indexOf(t) > -1)
      return this;
    var s = hv(arguments, 1);
    return s.unshift(this), Ae(t.install) ? t.install.apply(t, s) : Ae(t) && t.apply(null, s), n.push(t), this;
  };
}
function qK(e) {
  e.mixin = function(t) {
    return this.options = Ho(this.options, t), this;
  };
}
function t4(e) {
  e.cid = 0;
  var t = 1;
  e.extend = function(n) {
    n = n || {};
    var s = this, r = s.cid, i = n._Ctor || (n._Ctor = {});
    if (i[r])
      return i[r];
    var a = nf(n) || nf(s.options), o = function(f) {
      this._init(f);
    };
    return o.prototype = Object.create(s.prototype), o.prototype.constructor = o, o.cid = t++, o.options = Ho(s.options, n), o.super = s, o.options.props && e4(o), o.options.computed && n4(o), o.extend = s.extend, o.mixin = s.mixin, o.use = s.use, Zf.forEach(function(l) {
      o[l] = s[l];
    }), a && (o.options.components[a] = o), o.superOptions = s.options, o.extendOptions = n, o.sealedOptions = He({}, o.options), i[r] = o, o;
  };
}
function e4(e) {
  var t = e.options.props;
  for (var n in t)
    rE(e.prototype, "_props", n);
}
function n4(e) {
  var t = e.options.computed;
  for (var n in t)
    sI(e.prototype, n, t[n]);
}
function i4(e) {
  Zf.forEach(function(t) {
    e[t] = function(n, s) {
      return s ? (t === "component" && _i(s) && (s.name = s.name || n, s = this.options._base.extend(s)), t === "directive" && Ae(s) && (s = { bind: s, update: s }), this.options[t + "s"][n] = s, s) : this.options[t + "s"][n];
    };
  });
}
function sO(e) {
  return e && (nf(e.Ctor.options) || e.tag);
}
function jh(e, t) {
  return ue(e) ? e.indexOf(t) > -1 : typeof e == "string" ? e.split(",").indexOf(t) > -1 : b5(e) ? e.test(t) : !1;
}
function aO(e, t) {
  var n = e.cache, s = e.keys, r = e._vnode;
  for (var i in n) {
    var a = n[i];
    if (a) {
      var o = a.name;
      o && !t(o) && Pv(n, i, s, r);
    }
  }
}
function Pv(e, t, n, s) {
  var r = e[t];
  r && (!s || r.tag !== s.tag) && r.componentInstance.$destroy(), e[t] = null, no(n, t);
}
var oO = [String, RegExp, Array], r4 = {
  name: "keep-alive",
  abstract: !0,
  props: {
    include: oO,
    exclude: oO,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function() {
      var e = this, t = e.cache, n = e.keys, s = e.vnodeToCache, r = e.keyToCache;
      if (s) {
        var i = s.tag, a = s.componentInstance, o = s.componentOptions;
        t[r] = {
          name: sO(o),
          tag: i,
          componentInstance: a
        }, n.push(r), this.max && n.length > parseInt(this.max) && Pv(t, n[0], n, this._vnode), this.vnodeToCache = null;
      }
    }
  },
  created: function() {
    this.cache = /* @__PURE__ */ Object.create(null), this.keys = [];
  },
  destroyed: function() {
    for (var e in this.cache)
      Pv(this.cache, e, this.keys);
  },
  mounted: function() {
    var e = this;
    this.cacheVNode(), this.$watch("include", function(t) {
      aO(e, function(n) {
        return jh(t, n);
      });
    }), this.$watch("exclude", function(t) {
      aO(e, function(n) {
        return !jh(t, n);
      });
    });
  },
  updated: function() {
    this.cacheVNode();
  },
  render: function() {
    var e = this.$slots.default, t = YS(e), n = t && t.componentOptions;
    if (n) {
      var s = sO(n), r = this, i = r.include, a = r.exclude;
      if (
        // not included
        i && (!s || !jh(i, s)) || // excluded
        a && s && jh(a, s)
      )
        return t;
      var o = this, l = o.cache, f = o.keys, d = t.key == null ? (
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "")
      ) : t.key;
      l[d] ? (t.componentInstance = l[d].componentInstance, no(f, d), f.push(d)) : (this.vnodeToCache = t, this.keyToCache = d), t.data.keepAlive = !0;
    }
    return t || e && e[0];
  }
}, s4 = {
  KeepAlive: r4
};
function a4(e) {
  var t = {};
  t.get = function() {
    return gr;
  }, Object.defineProperty(e, "config", t), e.util = {
    warn: DK,
    extend: He,
    mergeOptions: Ho,
    defineReactive: to
  }, e.set = Jf, e.delete = k0, e.nextTick = tp, e.observable = function(n) {
    return ta(n), n;
  }, e.options = /* @__PURE__ */ Object.create(null), Zf.forEach(function(n) {
    e.options[n + "s"] = /* @__PURE__ */ Object.create(null);
  }), e.options._base = e, He(e.options.components, s4), QK(e), qK(e), t4(e), i4(e);
}
a4($t);
Object.defineProperty($t.prototype, "$isServer", {
  get: io
});
Object.defineProperty($t.prototype, "$ssrContext", {
  get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty($t, "FunctionalRenderContext", {
  value: eE
});
$t.version = JS;
var o4 = Ur("style,class"), l4 = Ur("input,textarea,option,select,progress"), u4 = function(e, t, n) {
  return n === "value" && l4(e) && t !== "button" || n === "selected" && e === "option" || n === "checked" && e === "input" || n === "muted" && e === "video";
}, aI = Ur("contenteditable,draggable,spellcheck"), c4 = Ur("events,caret,typing,plaintext-only"), h4 = function(e, t) {
  return sf(t) || t === "false" ? "false" : (
    // allow arbitrary string value for contenteditable
    e === "contenteditable" && c4(t) ? t : "true"
  );
}, d4 = Ur("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), Mv = "http://www.w3.org/1999/xlink", aE = function(e) {
  return e.charAt(5) === ":" && e.slice(0, 5) === "xlink";
}, oI = function(e) {
  return aE(e) ? e.slice(6, e.length) : "";
}, sf = function(e) {
  return e == null || e === !1;
};
function f4(e) {
  for (var t = e.data, n = e, s = e; ht(s.componentInstance); )
    s = s.componentInstance._vnode, s && s.data && (t = lO(s.data, t));
  for (; ht(n = n.parent); )
    n && n.data && (t = lO(t, n.data));
  return p4(t.staticClass, t.class);
}
function lO(e, t) {
  return {
    staticClass: oE(e.staticClass, t.staticClass),
    class: ht(e.class) ? [e.class, t.class] : t.class
  };
}
function p4(e, t) {
  return ht(e) || ht(t) ? oE(e, lE(t)) : "";
}
function oE(e, t) {
  return e ? t ? e + " " + t : e : t || "";
}
function lE(e) {
  return Array.isArray(e) ? m4(e) : pi(e) ? g4(e) : typeof e == "string" ? e : "";
}
function m4(e) {
  for (var t = "", n, s = 0, r = e.length; s < r; s++)
    ht(n = lE(e[s])) && n !== "" && (t && (t += " "), t += n);
  return t;
}
function g4(e) {
  var t = "";
  for (var n in e)
    e[n] && (t && (t += " "), t += n);
  return t;
}
var v4 = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
}, y4 = Ur("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), uE = Ur("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), lI = function(e) {
  return y4(e) || uE(e);
};
function E4(e) {
  if (uE(e))
    return "svg";
  if (e === "math")
    return "math";
}
var Uh = /* @__PURE__ */ Object.create(null);
function C4(e) {
  if (!zi)
    return !0;
  if (lI(e))
    return !1;
  if (e = e.toLowerCase(), Uh[e] != null)
    return Uh[e];
  var t = document.createElement(e);
  return e.indexOf("-") > -1 ? Uh[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : Uh[e] = /HTMLUnknownElement/.test(t.toString());
}
var Sv = Ur("text,number,password,search,email,tel,url");
function x4(e) {
  if (typeof e == "string") {
    var t = document.querySelector(e);
    return t || document.createElement("div");
  } else
    return e;
}
function b4(e, t) {
  var n = document.createElement(e);
  return e !== "select" || t.data && t.data.attrs && t.data.attrs.multiple !== void 0 && n.setAttribute("multiple", "multiple"), n;
}
function O4(e, t) {
  return document.createElementNS(v4[e], t);
}
function T4(e) {
  return document.createTextNode(e);
}
function P4(e) {
  return document.createComment(e);
}
function M4(e, t, n) {
  e.insertBefore(t, n);
}
function S4(e, t) {
  e.removeChild(t);
}
function I4(e, t) {
  e.appendChild(t);
}
function _4(e) {
  return e.parentNode;
}
function D4(e) {
  return e.nextSibling;
}
function A4(e) {
  return e.tagName;
}
function L4(e, t) {
  e.textContent = t;
}
function R4(e, t) {
  e.setAttribute(t, "");
}
var w4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createElement: b4,
  createElementNS: O4,
  createTextNode: T4,
  createComment: P4,
  insertBefore: M4,
  removeChild: S4,
  appendChild: I4,
  parentNode: _4,
  nextSibling: D4,
  tagName: A4,
  setTextContent: L4,
  setStyleScope: R4
}), V4 = {
  create: function(e, t) {
    Ll(t);
  },
  update: function(e, t) {
    e.data.ref !== t.data.ref && (Ll(e, !0), Ll(t));
  },
  destroy: function(e) {
    Ll(e, !0);
  }
};
function Ll(e, t) {
  var n = e.data.ref;
  if (ht(n)) {
    var s = e.context, r = e.componentInstance || e.elm, i = t ? null : r, a = t ? void 0 : r;
    if (Ae(n)) {
      ea(n, s, [i], s, "template ref function");
      return;
    }
    var o = e.data.refInFor, l = typeof n == "string" || typeof n == "number", f = ei(n), d = s.$refs;
    if (l || f) {
      if (o) {
        var u = l ? d[n] : n.value;
        t ? ue(u) && no(u, r) : ue(u) ? u.includes(r) || u.push(r) : l ? (d[n] = [r], uO(s, n, d[n])) : n.value = [r];
      } else if (l) {
        if (t && d[n] !== r)
          return;
        d[n] = a, uO(s, n, i);
      } else if (f) {
        if (t && n.value !== r)
          return;
        n.value = i;
      }
    }
  }
}
function uO(e, t, n) {
  var s = e._setupState;
  s && Si(s, t) && (ei(s[t]) ? s[t].value = n : s[t] = n);
}
var Ia = new ir("", {}, []), ju = ["create", "activate", "update", "remove", "destroy"];
function po(e, t) {
  return e.key === t.key && e.asyncFactory === t.asyncFactory && (e.tag === t.tag && e.isComment === t.isComment && ht(e.data) === ht(t.data) && B4(e, t) || ln(e.isAsyncPlaceholder) && te(t.asyncFactory.error));
}
function B4(e, t) {
  if (e.tag !== "input")
    return !0;
  var n, s = ht(n = e.data) && ht(n = n.attrs) && n.type, r = ht(n = t.data) && ht(n = n.attrs) && n.type;
  return s === r || Sv(s) && Sv(r);
}
function N4(e, t, n) {
  var s, r, i = {};
  for (s = t; s <= n; ++s)
    r = e[s].key, ht(r) && (i[r] = s);
  return i;
}
function F4(e) {
  var t, n, s = {}, r = e.modules, i = e.nodeOps;
  for (t = 0; t < ju.length; ++t)
    for (s[ju[t]] = [], n = 0; n < r.length; ++n)
      ht(r[n][ju[t]]) && s[ju[t]].push(r[n][ju[t]]);
  function a(A) {
    return new ir(i.tagName(A).toLowerCase(), {}, [], void 0, A);
  }
  function o(A, D) {
    function _() {
      --_.listeners === 0 && l(A);
    }
    return _.listeners = D, _;
  }
  function l(A) {
    var D = i.parentNode(A);
    ht(D) && i.removeChild(D, A);
  }
  function f(A, D, _, w, B, j, k) {
    if (ht(A.elm) && ht(j) && (A = j[k] = pv(A)), A.isRootInsert = !B, !d(A, D, _, w)) {
      var X = A.data, rt = A.children, et = A.tag;
      ht(et) ? (A.elm = A.ns ? i.createElementNS(A.ns, et) : i.createElement(et, A), v(A), p(A, rt, D), ht(X) && m(A, D), h(_, A.elm, w)) : ln(A.isComment) ? (A.elm = i.createComment(A.text), h(_, A.elm, w)) : (A.elm = i.createTextNode(A.text), h(_, A.elm, w));
    }
  }
  function d(A, D, _, w) {
    var B = A.data;
    if (ht(B)) {
      var j = ht(A.componentInstance) && B.keepAlive;
      if (ht(B = B.hook) && ht(B = B.init) && B(
        A,
        !1
        /* hydrating */
      ), ht(A.componentInstance))
        return u(A, D), h(_, A.elm, w), ln(j) && c(A, D, _, w), !0;
    }
  }
  function u(A, D) {
    ht(A.data.pendingInsert) && (D.push.apply(D, A.data.pendingInsert), A.data.pendingInsert = null), A.elm = A.componentInstance.$el, g(A) ? (m(A, D), v(A)) : (Ll(A), D.push(A));
  }
  function c(A, D, _, w) {
    for (var B, j = A; j.componentInstance; )
      if (j = j.componentInstance._vnode, ht(B = j.data) && ht(B = B.transition)) {
        for (B = 0; B < s.activate.length; ++B)
          s.activate[B](Ia, j);
        D.push(j);
        break;
      }
    h(_, A.elm, w);
  }
  function h(A, D, _) {
    ht(A) && (ht(_) ? i.parentNode(_) === A && i.insertBefore(A, D, _) : i.appendChild(A, D));
  }
  function p(A, D, _) {
    if (ue(D))
      for (var w = 0; w < D.length; ++w)
        f(D[w], _, A.elm, null, !0, D, w);
    else
      Jc(A.text) && i.appendChild(A.elm, i.createTextNode(String(A.text)));
  }
  function g(A) {
    for (; A.componentInstance; )
      A = A.componentInstance._vnode;
    return ht(A.tag);
  }
  function m(A, D) {
    for (var _ = 0; _ < s.create.length; ++_)
      s.create[_](Ia, A);
    t = A.data.hook, ht(t) && (ht(t.create) && t.create(Ia, A), ht(t.insert) && D.push(A));
  }
  function v(A) {
    var D;
    if (ht(D = A.fnScopeId))
      i.setStyleScope(A.elm, D);
    else
      for (var _ = A; _; )
        ht(D = _.context) && ht(D = D.$options._scopeId) && i.setStyleScope(A.elm, D), _ = _.parent;
    ht(D = _o) && D !== A.context && D !== A.fnContext && ht(D = D.$options._scopeId) && i.setStyleScope(A.elm, D);
  }
  function y(A, D, _, w, B, j) {
    for (; w <= B; ++w)
      f(_[w], j, A, D, !1, _, w);
  }
  function E(A) {
    var D, _, w = A.data;
    if (ht(w))
      for (ht(D = w.hook) && ht(D = D.destroy) && D(A), D = 0; D < s.destroy.length; ++D)
        s.destroy[D](A);
    if (ht(D = A.children))
      for (_ = 0; _ < A.children.length; ++_)
        E(A.children[_]);
  }
  function C(A, D, _) {
    for (; D <= _; ++D) {
      var w = A[D];
      ht(w) && (ht(w.tag) ? (x(w), E(w)) : l(w.elm));
    }
  }
  function x(A, D) {
    if (ht(D) || ht(A.data)) {
      var _, w = s.remove.length + 1;
      for (ht(D) ? D.listeners += w : D = o(A.elm, w), ht(_ = A.componentInstance) && ht(_ = _._vnode) && ht(_.data) && x(_, D), _ = 0; _ < s.remove.length; ++_)
        s.remove[_](A, D);
      ht(_ = A.data.hook) && ht(_ = _.remove) ? _(A, D) : D();
    } else
      l(A.elm);
  }
  function b(A, D, _, w, B) {
    for (var j = 0, k = 0, X = D.length - 1, rt = D[0], et = D[X], Z = _.length - 1, dt = _[0], vt = _[Z], bt, it, R, V, tt = !B; j <= X && k <= Z; )
      te(rt) ? rt = D[++j] : te(et) ? et = D[--X] : po(rt, dt) ? (T(rt, dt, w, _, k), rt = D[++j], dt = _[++k]) : po(et, vt) ? (T(et, vt, w, _, Z), et = D[--X], vt = _[--Z]) : po(rt, vt) ? (T(rt, vt, w, _, Z), tt && i.insertBefore(A, rt.elm, i.nextSibling(et.elm)), rt = D[++j], vt = _[--Z]) : po(et, dt) ? (T(et, dt, w, _, k), tt && i.insertBefore(A, et.elm, rt.elm), et = D[--X], dt = _[++k]) : (te(bt) && (bt = N4(D, j, X)), it = ht(dt.key) ? bt[dt.key] : P(dt, D, j, X), te(it) ? f(dt, w, A, rt.elm, !1, _, k) : (R = D[it], po(R, dt) ? (T(R, dt, w, _, k), D[it] = void 0, tt && i.insertBefore(A, R.elm, rt.elm)) : f(dt, w, A, rt.elm, !1, _, k)), dt = _[++k]);
    j > X ? (V = te(_[Z + 1]) ? null : _[Z + 1].elm, y(A, V, _, k, Z, w)) : k > Z && C(D, j, X);
  }
  function P(A, D, _, w) {
    for (var B = _; B < w; B++) {
      var j = D[B];
      if (ht(j) && po(A, j))
        return B;
    }
  }
  function T(A, D, _, w, B, j) {
    if (A !== D) {
      ht(D.elm) && ht(w) && (D = w[B] = pv(D));
      var k = D.elm = A.elm;
      if (ln(A.isAsyncPlaceholder)) {
        ht(D.asyncFactory.resolved) ? L(A.elm, D, _) : D.isAsyncPlaceholder = !0;
        return;
      }
      if (ln(D.isStatic) && ln(A.isStatic) && D.key === A.key && (ln(D.isCloned) || ln(D.isOnce))) {
        D.componentInstance = A.componentInstance;
        return;
      }
      var X, rt = D.data;
      ht(rt) && ht(X = rt.hook) && ht(X = X.prepatch) && X(A, D);
      var et = A.children, Z = D.children;
      if (ht(rt) && g(D)) {
        for (X = 0; X < s.update.length; ++X)
          s.update[X](A, D);
        ht(X = rt.hook) && ht(X = X.update) && X(A, D);
      }
      te(D.text) ? ht(et) && ht(Z) ? et !== Z && b(k, et, Z, _, j) : ht(Z) ? (ht(A.text) && i.setTextContent(k, ""), y(k, null, Z, 0, Z.length - 1, _)) : ht(et) ? C(et, 0, et.length - 1) : ht(A.text) && i.setTextContent(k, "") : A.text !== D.text && i.setTextContent(k, D.text), ht(rt) && ht(X = rt.hook) && ht(X = X.postpatch) && X(A, D);
    }
  }
  function O(A, D, _) {
    if (ln(_) && ht(A.parent))
      A.parent.data.pendingInsert = D;
    else
      for (var w = 0; w < D.length; ++w)
        D[w].data.hook.insert(D[w]);
  }
  var S = Ur("attrs,class,staticClass,staticStyle,key");
  function L(A, D, _, w) {
    var B, j = D.tag, k = D.data, X = D.children;
    if (w = w || k && k.pre, D.elm = A, ln(D.isComment) && ht(D.asyncFactory))
      return D.isAsyncPlaceholder = !0, !0;
    if (ht(k) && (ht(B = k.hook) && ht(B = B.init) && B(
      D,
      !0
      /* hydrating */
    ), ht(B = D.componentInstance)))
      return u(D, _), !0;
    if (ht(j)) {
      if (ht(X))
        if (!A.hasChildNodes())
          p(D, X, _);
        else if (ht(B = k) && ht(B = B.domProps) && ht(B = B.innerHTML)) {
          if (B !== A.innerHTML)
            return !1;
        } else {
          for (var rt = !0, et = A.firstChild, Z = 0; Z < X.length; Z++) {
            if (!et || !L(et, X[Z], _, w)) {
              rt = !1;
              break;
            }
            et = et.nextSibling;
          }
          if (!rt || et)
            return !1;
        }
      if (ht(k)) {
        var dt = !1;
        for (var vt in k)
          if (!S(vt)) {
            dt = !0, m(D, _);
            break;
          }
        !dt && k.class && ru(k.class);
      }
    } else
      A.data !== D.text && (A.data = D.text);
    return !0;
  }
  return function(D, _, w, B) {
    if (te(_)) {
      ht(D) && E(D);
      return;
    }
    var j = !1, k = [];
    if (te(D))
      j = !0, f(_, k);
    else {
      var X = ht(D.nodeType);
      if (!X && po(D, _))
        T(D, _, k, null, null, B);
      else {
        if (X) {
          if (D.nodeType === 1 && D.hasAttribute(wb) && (D.removeAttribute(wb), w = !0), ln(w) && L(D, _, k))
            return O(_, k, !0), D;
          D = a(D);
        }
        var rt = D.elm, et = i.parentNode(rt);
        if (f(
          _,
          k,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          rt._leaveCb ? null : et,
          i.nextSibling(rt)
        ), ht(_.parent))
          for (var Z = _.parent, dt = g(_); Z; ) {
            for (var vt = 0; vt < s.destroy.length; ++vt)
              s.destroy[vt](Z);
            if (Z.elm = _.elm, dt) {
              for (var bt = 0; bt < s.create.length; ++bt)
                s.create[bt](Ia, Z);
              var it = Z.data.hook.insert;
              if (it.merged)
                for (var R = it.fns.slice(1), V = 0; V < R.length; V++)
                  R[V]();
            } else
              Ll(Z);
            Z = Z.parent;
          }
        ht(et) ? C([D], 0, 0) : ht(D.tag) && E(D);
      }
    }
    return O(_, k, j), _.elm;
  };
}
var j4 = {
  create: zm,
  update: zm,
  destroy: function(t) {
    zm(t, Ia);
  }
};
function zm(e, t) {
  (e.data.directives || t.data.directives) && U4(e, t);
}
function U4(e, t) {
  var n = e === Ia, s = t === Ia, r = cO(e.data.directives, e.context), i = cO(t.data.directives, t.context), a = [], o = [], l, f, d;
  for (l in i)
    f = r[l], d = i[l], f ? (d.oldValue = f.value, d.oldArg = f.arg, Uu(d, "update", t, e), d.def && d.def.componentUpdated && o.push(d)) : (Uu(d, "bind", t, e), d.def && d.def.inserted && a.push(d));
  if (a.length) {
    var u = function() {
      for (var c = 0; c < a.length; c++)
        Uu(a[c], "inserted", t, e);
    };
    n ? Sa(t, "insert", u) : u();
  }
  if (o.length && Sa(t, "postpatch", function() {
    for (var c = 0; c < o.length; c++)
      Uu(o[c], "componentUpdated", t, e);
  }), !n)
    for (l in r)
      i[l] || Uu(r[l], "unbind", e, e, s);
}
var W4 = /* @__PURE__ */ Object.create(null);
function cO(e, t) {
  var n = /* @__PURE__ */ Object.create(null);
  if (!e)
    return n;
  var s, r;
  for (s = 0; s < e.length; s++) {
    if (r = e[s], r.modifiers || (r.modifiers = W4), n[$4(r)] = r, t._setupState && t._setupState.__sfc) {
      var i = r.def || rf(t, "_setupState", "v-" + r.name);
      typeof i == "function" ? r.def = {
        bind: i,
        update: i
      } : r.def = i;
    }
    r.def = r.def || rf(t.$options, "directives", r.name);
  }
  return n;
}
function $4(e) {
  return e.rawName || "".concat(e.name, ".").concat(Object.keys(e.modifiers || {}).join("."));
}
function Uu(e, t, n, s, r) {
  var i = e.def && e.def[t];
  if (i)
    try {
      i(n.elm, e, n, s, r);
    } catch (a) {
      ko(a, n.context, "directive ".concat(e.name, " ").concat(t, " hook"));
    }
}
var z4 = [V4, j4];
function hO(e, t) {
  var n = t.componentOptions;
  if (!(ht(n) && n.Ctor.options.inheritAttrs === !1) && !(te(e.data.attrs) && te(t.data.attrs))) {
    var s, r, i, a = t.elm, o = e.data.attrs || {}, l = t.data.attrs || {};
    (ht(l.__ob__) || ln(l._v_attr_proxy)) && (l = t.data.attrs = He({}, l));
    for (s in l)
      r = l[s], i = o[s], i !== r && dO(a, s, r, t.data.pre);
    (bu || SS) && l.value !== o.value && dO(a, "value", l.value);
    for (s in o)
      te(l[s]) && (aE(s) ? a.removeAttributeNS(Mv, oI(s)) : aI(s) || a.removeAttribute(s));
  }
}
function dO(e, t, n, s) {
  s || e.tagName.indexOf("-") > -1 ? fO(e, t, n) : d4(t) ? sf(n) ? e.removeAttribute(t) : (n = t === "allowfullscreen" && e.tagName === "EMBED" ? "true" : t, e.setAttribute(t, n)) : aI(t) ? e.setAttribute(t, h4(t, n)) : aE(t) ? sf(n) ? e.removeAttributeNS(Mv, oI(t)) : e.setAttributeNS(Mv, t, n) : fO(e, t, n);
}
function fO(e, t, n) {
  if (sf(n))
    e.removeAttribute(t);
  else {
    if (bu && !Ou && e.tagName === "TEXTAREA" && t === "placeholder" && n !== "" && !e.__ieph) {
      var s = function(r) {
        r.stopImmediatePropagation(), e.removeEventListener("input", s);
      };
      e.addEventListener("input", s), e.__ieph = !0;
    }
    e.setAttribute(t, n);
  }
}
var K4 = {
  create: hO,
  update: hO
};
function pO(e, t) {
  var n = t.elm, s = t.data, r = e.data;
  if (!(te(s.staticClass) && te(s.class) && (te(r) || te(r.staticClass) && te(r.class)))) {
    var i = f4(t), a = n._transitionClasses;
    ht(a) && (i = oE(i, lE(a))), i !== n._prevClass && (n.setAttribute("class", i), n._prevClass = i);
  }
}
var G4 = {
  create: pO,
  update: pO
}, Km = "__r", Gm = "__c";
function k4(e) {
  if (ht(e[Km])) {
    var t = bu ? "change" : "input";
    e[t] = [].concat(e[Km], e[t] || []), delete e[Km];
  }
  ht(e[Gm]) && (e.change = [].concat(e[Gm], e.change || []), delete e[Gm]);
}
var Ac;
function H4(e, t, n) {
  var s = Ac;
  return function r() {
    var i = t.apply(null, arguments);
    i !== null && uI(e, r, n, s);
  };
}
var Y4 = vv && !(Vb && Number(Vb[1]) <= 53);
function X4(e, t, n, s) {
  if (Y4) {
    var r = nI, i = t;
    t = i._wrapper = function(a) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        a.target === a.currentTarget || // event is fired after handler attachment
        a.timeStamp >= r || // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        a.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        a.target.ownerDocument !== document
      )
        return i.apply(this, arguments);
    };
  }
  Ac.addEventListener(e, t, IS ? { capture: n, passive: s } : n);
}
function uI(e, t, n, s) {
  (s || Ac).removeEventListener(
    e,
    //@ts-expect-error
    t._wrapper || t,
    n
  );
}
function km(e, t) {
  if (!(te(e.data.on) && te(t.data.on))) {
    var n = t.data.on || {}, s = e.data.on || {};
    Ac = t.elm || e.elm, k4(n), WS(n, s, X4, uI, H4, t.context), Ac = void 0;
  }
}
var Z4 = {
  create: km,
  update: km,
  // @ts-expect-error emptyNode has actually data
  destroy: function(e) {
    return km(e, Ia);
  }
}, Wh;
function mO(e, t) {
  if (!(te(e.data.domProps) && te(t.data.domProps))) {
    var n, s, r = t.elm, i = e.data.domProps || {}, a = t.data.domProps || {};
    (ht(a.__ob__) || ln(a._v_attr_proxy)) && (a = t.data.domProps = He({}, a));
    for (n in i)
      n in a || (r[n] = "");
    for (n in a) {
      if (s = a[n], n === "textContent" || n === "innerHTML") {
        if (t.children && (t.children.length = 0), s === i[n])
          continue;
        r.childNodes.length === 1 && r.removeChild(r.childNodes[0]);
      }
      if (n === "value" && r.tagName !== "PROGRESS") {
        r._value = s;
        var o = te(s) ? "" : String(s);
        J4(r, o) && (r.value = o);
      } else if (n === "innerHTML" && uE(r.tagName) && te(r.innerHTML)) {
        Wh = Wh || document.createElement("div"), Wh.innerHTML = "<svg>".concat(s, "</svg>");
        for (var l = Wh.firstChild; r.firstChild; )
          r.removeChild(r.firstChild);
        for (; l.firstChild; )
          r.appendChild(l.firstChild);
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        s !== i[n]
      )
        try {
          r[n] = s;
        } catch {
        }
    }
  }
}
function J4(e, t) {
  return (
    //@ts-expect-error
    !e.composing && (e.tagName === "OPTION" || Q4(e, t) || q4(e, t))
  );
}
function Q4(e, t) {
  var n = !0;
  try {
    n = document.activeElement !== e;
  } catch {
  }
  return n && e.value !== t;
}
function q4(e, t) {
  var n = e.value, s = e._vModifiers;
  if (ht(s)) {
    if (s.number)
      return Pc(n) !== Pc(t);
    if (s.trim)
      return n.trim() !== t.trim();
  }
  return n !== t;
}
var t8 = {
  create: mO,
  update: mO
}, e8 = tl(function(e) {
  var t = {}, n = /;(?![^(]*\))/g, s = /:(.+)/;
  return e.split(n).forEach(function(r) {
    if (r) {
      var i = r.split(s);
      i.length > 1 && (t[i[0].trim()] = i[1].trim());
    }
  }), t;
});
function Hm(e) {
  var t = cI(e.style);
  return e.staticStyle ? He(e.staticStyle, t) : t;
}
function cI(e) {
  return Array.isArray(e) ? bS(e) : typeof e == "string" ? e8(e) : e;
}
function n8(e, t) {
  var n = {}, s;
  if (t)
    for (var r = e; r.componentInstance; )
      r = r.componentInstance._vnode, r && r.data && (s = Hm(r.data)) && He(n, s);
  (s = Hm(e.data)) && He(n, s);
  for (var i = e; i = i.parent; )
    i.data && (s = Hm(i.data)) && He(n, s);
  return n;
}
var i8 = /^--/, gO = /\s*!important$/, vO = function(e, t, n) {
  if (i8.test(t))
    e.style.setProperty(t, n);
  else if (gO.test(n))
    e.style.setProperty(Qc(t), n.replace(gO, ""), "important");
  else {
    var s = r8(t);
    if (Array.isArray(n))
      for (var r = 0, i = n.length; r < i; r++)
        e.style[s] = n[r];
    else
      e.style[s] = n;
  }
}, yO = ["Webkit", "Moz", "ms"], $h, r8 = tl(function(e) {
  if ($h = $h || document.createElement("div").style, e = Ko(e), e !== "filter" && e in $h)
    return e;
  for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < yO.length; n++) {
    var s = yO[n] + t;
    if (s in $h)
      return s;
  }
});
function EO(e, t) {
  var n = t.data, s = e.data;
  if (!(te(n.staticStyle) && te(n.style) && te(s.staticStyle) && te(s.style))) {
    var r, i, a = t.elm, o = s.staticStyle, l = s.normalizedStyle || s.style || {}, f = o || l, d = cI(t.data.style) || {};
    t.data.normalizedStyle = ht(d.__ob__) ? He({}, d) : d;
    var u = n8(t, !0);
    for (i in f)
      te(u[i]) && vO(a, i, "");
    for (i in u)
      r = u[i], r !== f[i] && vO(a, i, r ?? "");
  }
}
var s8 = {
  create: EO,
  update: EO
}, hI = /\s+/;
function dI(e, t) {
  if (!(!t || !(t = t.trim())))
    if (e.classList)
      t.indexOf(" ") > -1 ? t.split(hI).forEach(function(s) {
        return e.classList.add(s);
      }) : e.classList.add(t);
    else {
      var n = " ".concat(e.getAttribute("class") || "", " ");
      n.indexOf(" " + t + " ") < 0 && e.setAttribute("class", (n + t).trim());
    }
}
function fI(e, t) {
  if (!(!t || !(t = t.trim())))
    if (e.classList)
      t.indexOf(" ") > -1 ? t.split(hI).forEach(function(r) {
        return e.classList.remove(r);
      }) : e.classList.remove(t), e.classList.length || e.removeAttribute("class");
    else {
      for (var n = " ".concat(e.getAttribute("class") || "", " "), s = " " + t + " "; n.indexOf(s) >= 0; )
        n = n.replace(s, " ");
      n = n.trim(), n ? e.setAttribute("class", n) : e.removeAttribute("class");
    }
}
function pI(e) {
  if (e) {
    if (typeof e == "object") {
      var t = {};
      return e.css !== !1 && He(t, CO(e.name || "v")), He(t, e), t;
    } else if (typeof e == "string")
      return CO(e);
  }
}
var CO = tl(function(e) {
  return {
    enterClass: "".concat(e, "-enter"),
    enterToClass: "".concat(e, "-enter-to"),
    enterActiveClass: "".concat(e, "-enter-active"),
    leaveClass: "".concat(e, "-leave"),
    leaveToClass: "".concat(e, "-leave-to"),
    leaveActiveClass: "".concat(e, "-leave-active")
  };
}), mI = zi && !Ou, Cl = "transition", Ym = "animation", hd = "transition", af = "transitionend", Iv = "animation", gI = "animationend";
mI && (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0 && (hd = "WebkitTransition", af = "webkitTransitionEnd"), window.onanimationend === void 0 && window.onwebkitanimationend !== void 0 && (Iv = "WebkitAnimation", gI = "webkitAnimationEnd"));
var xO = zi ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (
  /* istanbul ignore next */
  function(e) {
    return e();
  }
);
function vI(e) {
  xO(function() {
    xO(e);
  });
}
function Do(e, t) {
  var n = e._transitionClasses || (e._transitionClasses = []);
  n.indexOf(t) < 0 && (n.push(t), dI(e, t));
}
function $s(e, t) {
  e._transitionClasses && no(e._transitionClasses, t), fI(e, t);
}
function yI(e, t, n) {
  var s = EI(e, t), r = s.type, i = s.timeout, a = s.propCount;
  if (!r)
    return n();
  var o = r === Cl ? af : gI, l = 0, f = function() {
    e.removeEventListener(o, d), n();
  }, d = function(u) {
    u.target === e && ++l >= a && f();
  };
  setTimeout(function() {
    l < a && f();
  }, i + 1), e.addEventListener(o, d);
}
var a8 = /\b(transform|all)(,|$)/;
function EI(e, t) {
  var n = window.getComputedStyle(e), s = (n[hd + "Delay"] || "").split(", "), r = (n[hd + "Duration"] || "").split(", "), i = bO(s, r), a = (n[Iv + "Delay"] || "").split(", "), o = (n[Iv + "Duration"] || "").split(", "), l = bO(a, o), f, d = 0, u = 0;
  t === Cl ? i > 0 && (f = Cl, d = i, u = r.length) : t === Ym ? l > 0 && (f = Ym, d = l, u = o.length) : (d = Math.max(i, l), f = d > 0 ? i > l ? Cl : Ym : null, u = f ? f === Cl ? r.length : o.length : 0);
  var c = f === Cl && a8.test(n[hd + "Property"]);
  return {
    type: f,
    timeout: d,
    propCount: u,
    hasTransform: c
  };
}
function bO(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max.apply(null, t.map(function(n, s) {
    return OO(n) + OO(e[s]);
  }));
}
function OO(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function _v(e, t) {
  var n = e.elm;
  ht(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb());
  var s = pI(e.data.transition);
  if (!te(s) && !(ht(n._enterCb) || n.nodeType !== 1)) {
    for (var r = s.css, i = s.type, a = s.enterClass, o = s.enterToClass, l = s.enterActiveClass, f = s.appearClass, d = s.appearToClass, u = s.appearActiveClass, c = s.beforeEnter, h = s.enter, p = s.afterEnter, g = s.enterCancelled, m = s.beforeAppear, v = s.appear, y = s.afterAppear, E = s.appearCancelled, C = s.duration, x = _o, b = _o.$vnode; b && b.parent; )
      x = b.context, b = b.parent;
    var P = !x._isMounted || !e.isRootInsert;
    if (!(P && !v && v !== "")) {
      var T = P && f ? f : a, O = P && u ? u : l, S = P && d ? d : o, L = P && m || c, A = P && Ae(v) ? v : h, D = P && y || p, _ = P && E || g, w = Pc(pi(C) ? C.enter : C), B = r !== !1 && !Ou, j = cE(A), k = n._enterCb = Xd(function() {
        B && ($s(n, S), $s(n, O)), k.cancelled ? (B && $s(n, T), _ && _(n)) : D && D(n), n._enterCb = null;
      });
      e.data.show || Sa(e, "insert", function() {
        var X = n.parentNode, rt = X && X._pending && X._pending[e.key];
        rt && rt.tag === e.tag && rt.elm._leaveCb && rt.elm._leaveCb(), A && A(n, k);
      }), L && L(n), B && (Do(n, T), Do(n, O), vI(function() {
        $s(n, T), k.cancelled || (Do(n, S), j || (xI(w) ? setTimeout(k, w) : yI(n, i, k)));
      })), e.data.show && (t && t(), A && A(n, k)), !B && !j && k();
    }
  }
}
function CI(e, t) {
  var n = e.elm;
  ht(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb());
  var s = pI(e.data.transition);
  if (te(s) || n.nodeType !== 1)
    return t();
  if (ht(n._leaveCb))
    return;
  var r = s.css, i = s.type, a = s.leaveClass, o = s.leaveToClass, l = s.leaveActiveClass, f = s.beforeLeave, d = s.leave, u = s.afterLeave, c = s.leaveCancelled, h = s.delayLeave, p = s.duration, g = r !== !1 && !Ou, m = cE(d), v = Pc(pi(p) ? p.leave : p), y = n._leaveCb = Xd(function() {
    n.parentNode && n.parentNode._pending && (n.parentNode._pending[e.key] = null), g && ($s(n, o), $s(n, l)), y.cancelled ? (g && $s(n, a), c && c(n)) : (t(), u && u(n)), n._leaveCb = null;
  });
  h ? h(E) : E();
  function E() {
    y.cancelled || (!e.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[e.key] = e), f && f(n), g && (Do(n, a), Do(n, l), vI(function() {
      $s(n, a), y.cancelled || (Do(n, o), m || (xI(v) ? setTimeout(y, v) : yI(n, i, y)));
    })), d && d(n, y), !g && !m && y());
  }
}
function xI(e) {
  return typeof e == "number" && !isNaN(e);
}
function cE(e) {
  if (te(e))
    return !1;
  var t = e.fns;
  return ht(t) ? cE(Array.isArray(t) ? t[0] : t) : (e._length || e.length) > 1;
}
function TO(e, t) {
  t.data.show !== !0 && _v(t);
}
var o8 = zi ? {
  create: TO,
  activate: TO,
  remove: function(e, t) {
    e.data.show !== !0 ? CI(e, t) : t();
  }
} : {}, l8 = [K4, G4, Z4, t8, s8, o8], u8 = l8.concat(z4), c8 = F4({ nodeOps: w4, modules: u8 });
Ou && document.addEventListener("selectionchange", function() {
  var e = document.activeElement;
  e && e.vmodel && hE(e, "input");
});
var bI = {
  inserted: function(e, t, n, s) {
    n.tag === "select" ? (s.elm && !s.elm._vOptions ? Sa(n, "postpatch", function() {
      bI.componentUpdated(e, t, n);
    }) : PO(e, t, n.context), e._vOptions = [].map.call(e.options, of)) : (n.tag === "textarea" || Sv(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener("compositionstart", h8), e.addEventListener("compositionend", IO), e.addEventListener("change", IO), Ou && (e.vmodel = !0)));
  },
  componentUpdated: function(e, t, n) {
    if (n.tag === "select") {
      PO(e, t, n.context);
      var s = e._vOptions, r = e._vOptions = [].map.call(e.options, of);
      if (r.some(function(a, o) {
        return !Go(a, s[o]);
      })) {
        var i = e.multiple ? t.value.some(function(a) {
          return SO(a, r);
        }) : t.value !== t.oldValue && SO(t.value, r);
        i && hE(e, "change");
      }
    }
  }
};
function PO(e, t, n) {
  MO(e, t), (bu || SS) && setTimeout(function() {
    MO(e, t);
  }, 0);
}
function MO(e, t, n) {
  var s = t.value, r = e.multiple;
  if (!(r && !Array.isArray(s))) {
    for (var i, a, o = 0, l = e.options.length; o < l; o++)
      if (a = e.options[o], r)
        i = TS(s, of(a)) > -1, a.selected !== i && (a.selected = i);
      else if (Go(of(a), s)) {
        e.selectedIndex !== o && (e.selectedIndex = o);
        return;
      }
    r || (e.selectedIndex = -1);
  }
}
function SO(e, t) {
  return t.every(function(n) {
    return !Go(n, e);
  });
}
function of(e) {
  return "_value" in e ? e._value : e.value;
}
function h8(e) {
  e.target.composing = !0;
}
function IO(e) {
  e.target.composing && (e.target.composing = !1, hE(e.target, "input"));
}
function hE(e, t) {
  var n = document.createEvent("HTMLEvents");
  n.initEvent(t, !0, !0), e.dispatchEvent(n);
}
function Dv(e) {
  return e.componentInstance && (!e.data || !e.data.transition) ? Dv(e.componentInstance._vnode) : e;
}
var d8 = {
  bind: function(e, t, n) {
    var s = t.value;
    n = Dv(n);
    var r = n.data && n.data.transition, i = e.__vOriginalDisplay = e.style.display === "none" ? "" : e.style.display;
    s && r ? (n.data.show = !0, _v(n, function() {
      e.style.display = i;
    })) : e.style.display = s ? i : "none";
  },
  update: function(e, t, n) {
    var s = t.value, r = t.oldValue;
    if (!s != !r) {
      n = Dv(n);
      var i = n.data && n.data.transition;
      i ? (n.data.show = !0, s ? _v(n, function() {
        e.style.display = e.__vOriginalDisplay;
      }) : CI(n, function() {
        e.style.display = "none";
      })) : e.style.display = s ? e.__vOriginalDisplay : "none";
    }
  },
  unbind: function(e, t, n, s, r) {
    r || (e.style.display = e.__vOriginalDisplay);
  }
}, f8 = {
  model: bI,
  show: d8
}, OI = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function Av(e) {
  var t = e && e.componentOptions;
  return t && t.Ctor.options.abstract ? Av(YS(t.children)) : e;
}
function TI(e) {
  var t = {}, n = e.$options;
  for (var s in n.propsData)
    t[s] = e[s];
  var r = n._parentListeners;
  for (var s in r)
    t[Ko(s)] = r[s];
  return t;
}
function _O(e, t) {
  if (/\d-keep-alive$/.test(t.tag))
    return e("keep-alive", {
      props: t.componentOptions.propsData
    });
}
function p8(e) {
  for (; e = e.parent; )
    if (e.data.transition)
      return !0;
}
function m8(e, t) {
  return t.key === e.key && t.tag === e.tag;
}
var g8 = function(e) {
  return e.tag || Sc(e);
}, v8 = function(e) {
  return e.name === "show";
}, y8 = {
  name: "transition",
  props: OI,
  abstract: !0,
  render: function(e) {
    var t = this, n = this.$slots.default;
    if (n && (n = n.filter(g8), !!n.length)) {
      var s = this.mode, r = n[0];
      if (p8(this.$vnode))
        return r;
      var i = Av(r);
      if (!i)
        return r;
      if (this._leaving)
        return _O(e, r);
      var a = "__transition-".concat(this._uid, "-");
      i.key = i.key == null ? i.isComment ? a + "comment" : a + i.tag : Jc(i.key) ? String(i.key).indexOf(a) === 0 ? i.key : a + i.key : i.key;
      var o = (i.data || (i.data = {})).transition = TI(this), l = this._vnode, f = Av(l);
      if (i.data.directives && i.data.directives.some(v8) && (i.data.show = !0), f && f.data && !m8(i, f) && !Sc(f) && // #6687 component root is a comment node
      !(f.componentInstance && f.componentInstance._vnode.isComment)) {
        var d = f.data.transition = He({}, o);
        if (s === "out-in")
          return this._leaving = !0, Sa(d, "afterLeave", function() {
            t._leaving = !1, t.$forceUpdate();
          }), _O(e, r);
        if (s === "in-out") {
          if (Sc(i))
            return l;
          var u, c = function() {
            u();
          };
          Sa(o, "afterEnter", c), Sa(o, "enterCancelled", c), Sa(d, "delayLeave", function(h) {
            u = h;
          });
        }
      }
      return r;
    }
  }
}, PI = He({
  tag: String,
  moveClass: String
}, OI);
delete PI.mode;
var E8 = {
  props: PI,
  beforeMount: function() {
    var e = this, t = this._update;
    this._update = function(n, s) {
      var r = qS(e);
      e.__patch__(
        e._vnode,
        e.kept,
        !1,
        // hydrating
        !0
        // removeOnly (!important, avoids unnecessary moves)
      ), e._vnode = e.kept, r(), t.call(e, n, s);
    };
  },
  render: function(e) {
    for (var t = this.tag || this.$vnode.data.tag || "span", n = /* @__PURE__ */ Object.create(null), s = this.prevChildren = this.children, r = this.$slots.default || [], i = this.children = [], a = TI(this), o = 0; o < r.length; o++) {
      var l = r[o];
      l.tag && l.key != null && String(l.key).indexOf("__vlist") !== 0 && (i.push(l), n[l.key] = l, (l.data || (l.data = {})).transition = a);
    }
    if (s) {
      for (var f = [], d = [], o = 0; o < s.length; o++) {
        var l = s[o];
        l.data.transition = a, l.data.pos = l.elm.getBoundingClientRect(), n[l.key] ? f.push(l) : d.push(l);
      }
      this.kept = e(t, null, f), this.removed = d;
    }
    return e(t, null, i);
  },
  updated: function() {
    var e = this.prevChildren, t = this.moveClass || (this.name || "v") + "-move";
    !e.length || !this.hasMove(e[0].elm, t) || (e.forEach(C8), e.forEach(x8), e.forEach(b8), this._reflow = document.body.offsetHeight, e.forEach(function(n) {
      if (n.data.moved) {
        var s = n.elm, r = s.style;
        Do(s, t), r.transform = r.WebkitTransform = r.transitionDuration = "", s.addEventListener(af, s._moveCb = function i(a) {
          a && a.target !== s || (!a || /transform$/.test(a.propertyName)) && (s.removeEventListener(af, i), s._moveCb = null, $s(s, t));
        });
      }
    }));
  },
  methods: {
    hasMove: function(e, t) {
      if (!mI)
        return !1;
      if (this._hasMove)
        return this._hasMove;
      var n = e.cloneNode();
      e._transitionClasses && e._transitionClasses.forEach(function(r) {
        fI(n, r);
      }), dI(n, t), n.style.display = "none", this.$el.appendChild(n);
      var s = EI(n);
      return this.$el.removeChild(n), this._hasMove = s.hasTransform;
    }
  }
};
function C8(e) {
  e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb();
}
function x8(e) {
  e.data.newPos = e.elm.getBoundingClientRect();
}
function b8(e) {
  var t = e.data.pos, n = e.data.newPos, s = t.left - n.left, r = t.top - n.top;
  if (s || r) {
    e.data.moved = !0;
    var i = e.elm.style;
    i.transform = i.WebkitTransform = "translate(".concat(s, "px,").concat(r, "px)"), i.transitionDuration = "0s";
  }
}
var O8 = {
  Transition: y8,
  TransitionGroup: E8
};
$t.config.mustUseProp = u4;
$t.config.isReservedTag = lI;
$t.config.isReservedAttr = o4;
$t.config.getTagNamespace = E4;
$t.config.isUnknownElement = C4;
He($t.options.directives, f8);
He($t.options.components, O8);
$t.prototype.__patch__ = zi ? c8 : rn;
$t.prototype.$mount = function(e, t) {
  return e = e && zi ? x4(e) : void 0, mK(this, e, t);
};
zi && setTimeout(function() {
  gr.devtools && Zd && Zd.emit("init", $t);
}, 0);
const T8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EffectScope: Y0,
  computed: ez,
  customRef: X5,
  default: $t,
  defineAsyncComponent: Gz,
  defineComponent: aK,
  del: k0,
  effectScope: az,
  getCurrentInstance: B5,
  getCurrentScope: jS,
  h: Uz,
  inject: cz,
  isProxy: $5,
  isReactive: Io,
  isReadonly: el,
  isRef: ei,
  isShallow: Qd,
  markRaw: z5,
  mergeDefaults: Lz,
  nextTick: tp,
  onActivated: qz,
  onBeforeMount: Hz,
  onBeforeUnmount: Jz,
  onBeforeUpdate: Xz,
  onDeactivated: tK,
  onErrorCaptured: sK,
  onMounted: Yz,
  onRenderTracked: nK,
  onRenderTriggered: iK,
  onScopeDispose: lz,
  onServerPrefetch: eK,
  onUnmounted: Qz,
  onUpdated: Zz,
  provide: uz,
  proxyRefs: Y5,
  reactive: W5,
  readonly: BS,
  ref: K5,
  set: Jf,
  shallowReactive: H0,
  shallowReadonly: tz,
  shallowRef: G5,
  toRaw: RS,
  toRef: VS,
  toRefs: Z5,
  triggerRef: k5,
  unref: H5,
  useAttrs: Dz,
  useCssModule: zz,
  useCssVars: Kz,
  useListeners: Az,
  useSlots: _z,
  version: JS,
  watch: sz,
  watchEffect: iz,
  watchPostEffect: FS,
  watchSyncEffect: rz
}, Symbol.toStringTag, { value: "Module" }));
var MI = { exports: {} };
const P8 = /* @__PURE__ */ eM(T8);
(function(e, t) {
  (function(s, r) {
    e.exports = r(P8);
  })(typeof self < "u" ? self : _t, function(n) {
    return (
      /******/
      function(s) {
        var r = {};
        function i(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return s[a].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = s, i.c = r, i.d = function(a, o, l) {
          i.o(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: l });
        }, i.r = function(a) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
        }, i.t = function(a, o) {
          if (o & 1 && (a = i(a)), o & 8 || o & 4 && typeof a == "object" && a && a.__esModule)
            return a;
          var l = /* @__PURE__ */ Object.create(null);
          if (i.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: a }), o & 2 && typeof a != "string")
            for (var f in a)
              i.d(l, f, (function(d) {
                return a[d];
              }).bind(null, f));
          return l;
        }, i.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, i.p = "/dist/", i(i.s = "./src/index.ts");
      }({
        /***/
        "./src/components/VAlert/VAlert.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VAlert/VAlert.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAlert/VAlert.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAlert/VAlert.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAlert.sass */
              "./src/components/VAlert/VAlert.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, f.default, u.default).extend({
              name: "v-alert",
              props: {
                border: {
                  type: String,
                  validator: function(m) {
                    return ["top", "right", "bottom", "left"].includes(m);
                  }
                },
                closeLabel: {
                  type: String,
                  default: "$vuetify.close"
                },
                coloredBorder: Boolean,
                dense: Boolean,
                dismissible: Boolean,
                closeIcon: {
                  type: String,
                  default: "$cancel"
                },
                icon: {
                  default: "",
                  type: [Boolean, String],
                  validator: function(m) {
                    return typeof m == "string" || m === !1;
                  }
                },
                outlined: Boolean,
                prominent: Boolean,
                text: Boolean,
                type: {
                  type: String,
                  validator: function(m) {
                    return ["info", "error", "success", "warning"].includes(m);
                  }
                },
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              computed: {
                __cachedBorder: function() {
                  var m;
                  if (!this.border)
                    return null;
                  var v = {
                    staticClass: "v-alert__border",
                    class: (m = {}, m["v-alert__border--" + this.border] = !0, m)
                  };
                  return this.coloredBorder && (v = this.setBackgroundColor(this.computedColor, v), v.class["v-alert__border--has-color"] = !0), this.$createElement("div", v);
                },
                __cachedDismissible: function() {
                  var m = this;
                  if (!this.dismissible)
                    return null;
                  var v = this.iconColor;
                  return this.$createElement(o.default, {
                    staticClass: "v-alert__dismissible",
                    props: {
                      color: v,
                      icon: !0,
                      small: !0
                    },
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.closeLabel)
                    },
                    on: {
                      click: function() {
                        return m.isActive = !1;
                      }
                    }
                  }, [this.$createElement(l.default, {
                    props: {
                      color: v
                    }
                  }, this.closeIcon)]);
                },
                __cachedIcon: function() {
                  return this.computedIcon ? this.$createElement(l.default, {
                    staticClass: "v-alert__icon",
                    props: {
                      color: this.iconColor
                    }
                  }, this.computedIcon) : null;
                },
                classes: function() {
                  var m = p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-alert--border": !!this.border,
                    "v-alert--dense": this.dense,
                    "v-alert--outlined": this.outlined,
                    "v-alert--prominent": this.prominent,
                    "v-alert--text": this.text
                  });
                  return this.border && (m["v-alert--border-" + this.border] = !0), m;
                },
                computedColor: function() {
                  return this.color || this.type;
                },
                computedIcon: function() {
                  return this.icon === !1 ? !1 : typeof this.icon == "string" && this.icon ? this.icon : ["error", "info", "success", "warning"].includes(this.type) ? "$" + this.type : !1;
                },
                hasColoredIcon: function() {
                  return this.hasText || !!this.border && this.coloredBorder;
                },
                hasText: function() {
                  return this.text || this.outlined;
                },
                iconColor: function() {
                  return this.hasColoredIcon ? this.computedColor : void 0;
                },
                isDark: function() {
                  return this.type && !this.coloredBorder && !this.outlined ? !0 : d.default.options.computed.isDark.call(this);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("outline") && Object(h.breaking)("outline", "outlined", this);
              },
              methods: {
                genWrapper: function() {
                  var m = [this.$slots.prepend || this.__cachedIcon, this.genContent(), this.__cachedBorder, this.$slots.append, this.$scopedSlots.close ? this.$scopedSlots.close({
                    toggle: this.toggle
                  }) : this.__cachedDismissible], v = {
                    staticClass: "v-alert__wrapper"
                  };
                  return this.$createElement("div", v, m);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-alert__content"
                  }, this.$slots.default);
                },
                genAlert: function() {
                  var m = {
                    staticClass: "v-alert",
                    attrs: {
                      role: "alert"
                    },
                    on: this.listeners$,
                    class: this.classes,
                    style: this.styles,
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }]
                  };
                  if (!this.coloredBorder) {
                    var v = this.hasText ? this.setTextColor : this.setBackgroundColor;
                    m = v(this.computedColor, m);
                  }
                  return this.$createElement("div", m, [this.genWrapper()]);
                },
                /** @public */
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              },
              render: function(m) {
                var v = this.genAlert();
                return this.transition ? m("transition", {
                  props: {
                    name: this.transition,
                    origin: this.origin,
                    mode: this.mode
                  }
                }, [v]) : v;
              }
            });
          }
        ),
        /***/
        "./src/components/VAlert/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VAlert/index.ts ***!
            \****************************************/
          /*! exports provided: VAlert, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAlert */
              "./src/components/VAlert/VAlert.ts"
            );
            i.d(r, "VAlert", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VApp/VApp.sass": (
          /*!***************************************!*\
            !*** ./src/components/VApp/VApp.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VApp/VApp.ts": (
          /*!*************************************!*\
            !*** ./src/components/VApp/VApp.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VApp.sass */
              "./src/components/VApp/VApp.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-app",
              props: {
                dark: {
                  type: Boolean,
                  default: void 0
                },
                id: {
                  type: String,
                  default: "app"
                },
                light: {
                  type: Boolean,
                  default: void 0
                }
              },
              computed: {
                isDark: function() {
                  return this.$vuetify.theme.dark;
                }
              },
              beforeCreate: function() {
                if (!this.$vuetify || this.$vuetify === this.$root)
                  throw new Error("Vuetify is not properly initialized, see https://v2.vuetifyjs.com/getting-started/quick-start#bootstrapping-the-vuetify-object");
              },
              render: function(d) {
                var u = d("div", {
                  staticClass: "v-application--wrap"
                }, this.$slots.default);
                return d("div", {
                  staticClass: "v-application",
                  class: l({
                    "v-application--is-rtl": this.$vuetify.rtl,
                    "v-application--is-ltr": !this.$vuetify.rtl
                  }, this.themeClasses),
                  attrs: {
                    "data-app": !0
                  },
                  domProps: {
                    id: this.id
                  }
                }, [u]);
              }
            });
          }
        ),
        /***/
        "./src/components/VApp/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VApp/index.ts ***!
            \**************************************/
          /*! exports provided: VApp, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VApp */
              "./src/components/VApp/VApp.ts"
            );
            i.d(r, "VApp", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBar.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VAppBar/VAppBar.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBar.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VAppBar/VAppBar.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAppBar.sass */
              "./src/components/VAppBar/VAppBar.sass"
            );
            var a = i(
              /*! ../VToolbar/VToolbar */
              "./src/components/VToolbar/VToolbar.ts"
            ), o = i(
              /*! ../../directives/scroll */
              "./src/directives/scroll/index.ts"
            ), l = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), f = i(
              /*! ../../mixins/scrollable */
              "./src/mixins/scrollable/index.ts"
            ), d = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), u = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(a.default, f.default, d.default, u.default, Object(l.default)("top", ["clippedLeft", "clippedRight", "computedHeight", "invertedScroll", "isExtended", "isProminent", "value"]));
            r.default = g.extend({
              name: "v-app-bar",
              directives: {
                Scroll: o.default
              },
              provide: function() {
                return {
                  VAppBar: this
                };
              },
              props: {
                clippedLeft: Boolean,
                clippedRight: Boolean,
                collapseOnScroll: Boolean,
                elevateOnScroll: Boolean,
                fadeImgOnScroll: Boolean,
                hideOnScroll: Boolean,
                invertedScroll: Boolean,
                scrollOffScreen: Boolean,
                shrinkOnScroll: Boolean,
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              data: function() {
                return {
                  isActive: this.value
                };
              },
              computed: {
                applicationProperty: function() {
                  return this.bottom ? "bottom" : "top";
                },
                canScroll: function() {
                  return f.default.options.computed.canScroll.call(this) && (this.invertedScroll || this.elevateOnScroll || this.hideOnScroll || this.collapseOnScroll || this.isBooted || // If falsy, user has provided an
                  // explicit value which should
                  // overwrite anything we do
                  !this.value);
                },
                classes: function() {
                  return p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-toolbar--collapse": this.collapse || this.collapseOnScroll,
                    "v-app-bar": !0,
                    "v-app-bar--clipped": this.clippedLeft || this.clippedRight,
                    "v-app-bar--fade-img-on-scroll": this.fadeImgOnScroll,
                    "v-app-bar--elevate-on-scroll": this.elevateOnScroll,
                    "v-app-bar--fixed": !this.absolute && (this.app || this.fixed),
                    "v-app-bar--hide-shadow": this.hideShadow,
                    "v-app-bar--is-scrolled": this.currentScroll > 0,
                    "v-app-bar--shrink-on-scroll": this.shrinkOnScroll
                  });
                },
                scrollRatio: function() {
                  var v = this.computedScrollThreshold;
                  return Math.max((v - this.currentScroll) / v, 0);
                },
                computedContentHeight: function() {
                  if (!this.shrinkOnScroll)
                    return a.default.options.computed.computedContentHeight.call(this);
                  var v = this.dense ? 48 : 56, y = this.computedOriginalHeight;
                  return v + (y - v) * this.scrollRatio;
                },
                computedFontSize: function() {
                  if (this.isProminent) {
                    var v = 1.25, y = 1.5;
                    return v + (y - v) * this.scrollRatio;
                  }
                },
                computedLeft: function() {
                  return !this.app || this.clippedLeft ? 0 : this.$vuetify.application.left;
                },
                computedMarginTop: function() {
                  return this.app ? this.$vuetify.application.bar : 0;
                },
                computedOpacity: function() {
                  if (this.fadeImgOnScroll)
                    return this.scrollRatio;
                },
                computedOriginalHeight: function() {
                  var v = a.default.options.computed.computedContentHeight.call(this);
                  return this.isExtended && (v += parseInt(this.extensionHeight)), v;
                },
                computedRight: function() {
                  return !this.app || this.clippedRight ? 0 : this.$vuetify.application.right;
                },
                computedScrollThreshold: function() {
                  return this.scrollThreshold ? Number(this.scrollThreshold) : this.computedOriginalHeight - (this.dense ? 48 : 56);
                },
                computedTransform: function() {
                  if (!this.canScroll || this.elevateOnScroll && this.currentScroll === 0 && this.isActive || this.isActive)
                    return 0;
                  var v = this.scrollOffScreen ? this.computedHeight : this.computedContentHeight;
                  return this.bottom ? v : -v;
                },
                hideShadow: function() {
                  return this.elevateOnScroll && this.isExtended ? this.currentScroll < this.computedScrollThreshold : this.elevateOnScroll ? this.currentScroll === 0 || this.computedTransform < 0 : (!this.isExtended || this.scrollOffScreen) && this.computedTransform !== 0;
                },
                isCollapsed: function() {
                  return this.collapseOnScroll ? this.currentScroll > 0 : a.default.options.computed.isCollapsed.call(this);
                },
                isProminent: function() {
                  return a.default.options.computed.isProminent.call(this) || this.shrinkOnScroll;
                },
                styles: function() {
                  return p(p({}, a.default.options.computed.styles.call(this)), {
                    fontSize: Object(c.convertToUnit)(this.computedFontSize, "rem"),
                    marginTop: Object(c.convertToUnit)(this.computedMarginTop),
                    transform: "translateY(" + Object(c.convertToUnit)(this.computedTransform) + ")",
                    left: Object(c.convertToUnit)(this.computedLeft),
                    right: Object(c.convertToUnit)(this.computedRight)
                  });
                }
              },
              watch: {
                canScroll: "onScroll",
                computedTransform: function() {
                  !this.canScroll || !this.clippedLeft && !this.clippedRight || this.callUpdate();
                },
                invertedScroll: function(v) {
                  this.isActive = !v || this.currentScroll !== 0;
                },
                hideOnScroll: function(v) {
                  this.isActive = !v || this.currentScroll < this.computedScrollThreshold;
                }
              },
              created: function() {
                this.invertedScroll && (this.isActive = !1);
              },
              methods: {
                genBackground: function() {
                  var v = a.default.options.methods.genBackground.call(this);
                  return v.data = this._b(v.data || {}, v.tag, {
                    style: {
                      opacity: this.computedOpacity
                    }
                  }), v;
                },
                updateApplication: function() {
                  return this.invertedScroll ? 0 : this.computedHeight + this.computedTransform;
                },
                thresholdMet: function() {
                  if (this.invertedScroll) {
                    this.isActive = this.currentScroll > this.computedScrollThreshold;
                    return;
                  }
                  this.hideOnScroll && (this.isActive = this.isScrollingUp || this.currentScroll < this.computedScrollThreshold), !(this.currentThreshold < this.computedScrollThreshold) && (this.savedScroll = this.currentScroll);
                }
              },
              render: function(v) {
                var y = a.default.options.render.call(this, v);
                return y.data = y.data || {}, this.canScroll && (y.data.directives = y.data.directives || [], y.data.directives.push({
                  arg: this.scrollTarget,
                  name: "scroll",
                  value: this.onScroll
                })), y;
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBarNavIcon.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VAppBar/VAppBarNavIcon.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VBtn/VBtn */
              "./src/components/VBtn/VBtn.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = f.a.extend({
              name: "v-app-bar-nav-icon",
              functional: !0,
              render: function(c, h) {
                var p = h.slots, g = h.listeners, m = h.props, v = h.data, y = Object.assign(v, {
                  staticClass: ("v-app-bar__nav-icon " + (v.staticClass || "")).trim(),
                  props: d(d({}, m), {
                    icon: !0
                  }),
                  on: g
                }), E = p().default;
                return c(o.default, y, E || [c(a.default, "$menu")]);
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBarTitle.ts": (
          /*!************************************************!*\
            !*** ./src/components/VAppBar/VAppBarTitle.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../services/goto/easing-patterns */
              "./src/services/goto/easing-patterns.ts"
            ), f = Object(a.inject)("VAppBar", "v-app-bar-title", "v-app-bar");
            r.default = f.extend().extend({
              name: "v-app-bar-title",
              data: function() {
                return {
                  contentWidth: 0,
                  left: 0,
                  width: 0
                };
              },
              watch: {
                "$vuetify.breakpoint.width": "updateDimensions"
              },
              computed: {
                styles: function() {
                  if (!this.contentWidth)
                    return {};
                  var u = this.width, c = this.contentWidth, h = Object(l.easeInOutCubic)(Math.min(1, this.VAppBar.scrollRatio * 1.5));
                  return {
                    width: Object(o.convertToUnit)(u + (c - u) * h),
                    visibility: this.VAppBar.scrollRatio ? "visible" : "hidden"
                  };
                }
              },
              mounted: function() {
                this.updateDimensions();
              },
              methods: {
                updateDimensions: function() {
                  var u = this.$refs.placeholder.getBoundingClientRect();
                  this.width = u.width, this.left = u.left, this.contentWidth = this.$refs.content.scrollWidth;
                }
              },
              render: function(u) {
                return u("div", {
                  class: "v-toolbar__title v-app-bar-title"
                }, [u("div", {
                  class: "v-app-bar-title__content",
                  style: this.styles,
                  ref: "content"
                }, [this.$slots.default]), u("div", {
                  class: "v-app-bar-title__placeholder",
                  style: {
                    visibility: this.VAppBar.scrollRatio ? "hidden" : "visible"
                  },
                  ref: "placeholder"
                }, [this.$slots.default])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAppBar/index.ts ***!
            \*****************************************/
          /*! exports provided: VAppBar, VAppBarNavIcon, VAppBarTitle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAppBar */
              "./src/components/VAppBar/VAppBar.ts"
            );
            i.d(r, "VAppBar", function() {
              return a.default;
            });
            var o = i(
              /*! ./VAppBarNavIcon */
              "./src/components/VAppBar/VAppBarNavIcon.ts"
            );
            i.d(r, "VAppBarNavIcon", function() {
              return o.default;
            });
            var l = i(
              /*! ./VAppBarTitle */
              "./src/components/VAppBar/VAppBarTitle.ts"
            );
            i.d(r, "VAppBarTitle", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VAppBar: a.default,
                VAppBarNavIcon: o.default,
                VAppBarTitle: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VAutocomplete/VAutocomplete.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VAutocomplete/VAutocomplete.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAutocomplete/VAutocomplete.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VAutocomplete/VAutocomplete.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAutocomplete.sass */
              "./src/components/VAutocomplete/VAutocomplete.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = d(d({}, a.defaultMenuProps), {
              offsetY: !0,
              offsetOverflow: !0,
              transition: !1
            });
            r.default = a.default.extend({
              name: "v-autocomplete",
              props: {
                autoSelectFirst: {
                  type: Boolean,
                  default: !1
                },
                filter: {
                  type: Function,
                  default: function(h, p, g) {
                    return g.toLocaleLowerCase().indexOf(p.toLocaleLowerCase()) > -1;
                  }
                },
                hideNoData: Boolean,
                menuProps: {
                  type: a.default.options.props.menuProps.type,
                  default: function() {
                    return u;
                  }
                },
                noFilter: Boolean,
                searchInput: {
                  type: String
                }
              },
              data: function() {
                return {
                  lazySearch: this.searchInput
                };
              },
              computed: {
                classes: function() {
                  return d(d({}, a.default.options.computed.classes.call(this)), {
                    "v-autocomplete": !0,
                    "v-autocomplete--is-selecting-index": this.selectedIndex > -1
                  });
                },
                computedItems: function() {
                  return this.filteredItems;
                },
                selectedValues: function() {
                  var h = this;
                  return this.selectedItems.map(function(p) {
                    return h.getValue(p);
                  });
                },
                hasDisplayedItems: function() {
                  var h = this;
                  return this.hideSelected ? this.filteredItems.some(function(p) {
                    return !h.hasItem(p);
                  }) : this.filteredItems.length > 0;
                },
                currentRange: function() {
                  return this.selectedItem == null ? 0 : String(this.getText(this.selectedItem)).length;
                },
                filteredItems: function() {
                  var h = this;
                  return !this.isSearching || this.noFilter || this.internalSearch == null ? this.allItems : this.allItems.filter(function(p) {
                    var g = Object(f.getPropertyFromItem)(p, h.itemText), m = g != null ? String(g) : "";
                    return h.filter(p, String(h.internalSearch), m);
                  });
                },
                internalSearch: {
                  get: function() {
                    return this.lazySearch;
                  },
                  set: function(h) {
                    this.lazySearch !== h && (this.lazySearch = h, this.$emit("update:search-input", h));
                  }
                },
                isAnyValueAllowed: function() {
                  return !1;
                },
                isDirty: function() {
                  return this.searchIsDirty || this.selectedItems.length > 0;
                },
                isSearching: function() {
                  return this.multiple && this.searchIsDirty || this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);
                },
                menuCanShow: function() {
                  return this.isFocused ? this.hasDisplayedItems || !this.hideNoData : !1;
                },
                $_menuProps: function() {
                  var h = a.default.options.computed.$_menuProps.call(this);
                  return h.contentClass = ("v-autocomplete__content " + (h.contentClass || "")).trim(), d(d({}, u), h);
                },
                searchIsDirty: function() {
                  return this.internalSearch != null && this.internalSearch !== "";
                },
                selectedItem: function() {
                  var h = this;
                  return this.multiple ? null : this.selectedItems.find(function(p) {
                    return h.valueComparator(h.getValue(p), h.getValue(h.internalValue));
                  });
                },
                listData: function() {
                  var h = a.default.options.computed.listData.call(this);
                  return h.props = d(d({}, h.props), {
                    items: this.virtualizedItems,
                    noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,
                    searchInput: this.internalSearch
                  }), h;
                }
              },
              watch: {
                filteredItems: "onFilteredItemsChanged",
                internalValue: "setSearch",
                isFocused: function(h) {
                  h ? (document.addEventListener("copy", this.onCopy), this.$refs.input && this.$refs.input.select()) : (document.removeEventListener("copy", this.onCopy), this.blur(), this.updateSelf());
                },
                isMenuActive: function(h) {
                  h || !this.hasSlot || (this.lazySearch = null);
                },
                items: function(h, p) {
                  !(p && p.length) && this.hideNoData && this.isFocused && !this.isMenuActive && h.length && this.activateMenu();
                },
                searchInput: function(h) {
                  this.lazySearch = h;
                },
                internalSearch: "onInternalSearchChanged",
                itemText: "updateSelf"
              },
              created: function() {
                this.setSearch();
              },
              destroyed: function() {
                document.removeEventListener("copy", this.onCopy);
              },
              methods: {
                onFilteredItemsChanged: function(h, p) {
                  var g = this;
                  if (h !== p) {
                    if (!this.autoSelectFirst) {
                      var m = p[this.$refs.menu.listIndex];
                      m ? this.setMenuIndex(h.findIndex(function(v) {
                        return v === m;
                      })) : this.setMenuIndex(-1), this.$emit("update:list-index", this.$refs.menu.listIndex);
                    }
                    this.$nextTick(function() {
                      !g.internalSearch || h.length !== 1 && !g.autoSelectFirst || (g.$refs.menu.getTiles(), g.autoSelectFirst && h.length && (g.setMenuIndex(0), g.$emit("update:list-index", g.$refs.menu.listIndex)));
                    });
                  }
                },
                onInternalSearchChanged: function() {
                  this.updateMenuDimensions();
                },
                updateMenuDimensions: function() {
                  this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions();
                },
                changeSelectedIndex: function(h) {
                  this.searchIsDirty || (this.multiple && h === f.keyCodes.left ? this.selectedIndex === -1 ? this.selectedIndex = this.selectedItems.length - 1 : this.selectedIndex-- : this.multiple && h === f.keyCodes.right ? this.selectedIndex >= this.selectedItems.length - 1 ? this.selectedIndex = -1 : this.selectedIndex++ : (h === f.keyCodes.backspace || h === f.keyCodes.delete) && this.deleteCurrentItem());
                },
                deleteCurrentItem: function() {
                  var h = this.selectedIndex, p = this.selectedItems[h];
                  if (!(!this.isInteractive || this.getDisabled(p))) {
                    var g = this.selectedItems.length - 1;
                    if (this.selectedIndex === -1 && g !== 0) {
                      this.selectedIndex = g;
                      return;
                    }
                    var m = this.selectedItems.length, v = h !== m - 1 ? h : h - 1, y = this.selectedItems[v];
                    y ? this.selectItem(p) : this.setValue(this.multiple ? [] : null), this.selectedIndex = v;
                  }
                },
                clearableCallback: function() {
                  this.internalSearch = null, a.default.options.methods.clearableCallback.call(this);
                },
                genInput: function() {
                  var h = o.default.options.methods.genInput.call(this);
                  return h.data = Object(l.default)(h.data, {
                    attrs: {
                      "aria-activedescendant": Object(f.getObjectValueByPath)(this.$refs.menu, "activeTile.id"),
                      autocomplete: Object(f.getObjectValueByPath)(h.data, "attrs.autocomplete", "off")
                    },
                    domProps: {
                      value: this.internalSearch
                    }
                  }), h;
                },
                genInputSlot: function() {
                  var h = a.default.options.methods.genInputSlot.call(this);
                  return h.data.attrs.role = "combobox", h;
                },
                genSelections: function() {
                  return this.hasSlot || this.multiple ? a.default.options.methods.genSelections.call(this) : [];
                },
                onClick: function(h) {
                  this.isInteractive && (this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus(), this.isAppendInner(h.target) || this.activateMenu());
                },
                onInput: function(h) {
                  if (!(this.selectedIndex > -1 || !h.target)) {
                    var p = h.target, g = p.value;
                    p.value && this.activateMenu(), !this.multiple && g === "" && this.deleteCurrentItem(), this.internalSearch = g, this.badInput = p.validity && p.validity.badInput;
                  }
                },
                onKeyDown: function(h) {
                  var p = h.keyCode;
                  (h.ctrlKey || ![f.keyCodes.home, f.keyCodes.end].includes(p)) && a.default.options.methods.onKeyDown.call(this, h), this.changeSelectedIndex(p);
                },
                onSpaceDown: function(h) {
                },
                onTabDown: function(h) {
                  a.default.options.methods.onTabDown.call(this, h), this.updateSelf();
                },
                onUpDown: function(h) {
                  h.preventDefault(), this.activateMenu();
                },
                selectItem: function(h) {
                  a.default.options.methods.selectItem.call(this, h), this.setSearch();
                },
                setSelectedItems: function() {
                  a.default.options.methods.setSelectedItems.call(this), this.isFocused || this.setSearch();
                },
                setSearch: function() {
                  var h = this;
                  this.$nextTick(function() {
                    (!h.multiple || !h.internalSearch || !h.isMenuActive) && (h.internalSearch = !h.selectedItems.length || h.multiple || h.hasSlot ? null : h.getText(h.selectedItem));
                  });
                },
                updateSelf: function() {
                  !this.searchIsDirty && !this.internalValue || !this.multiple && !this.valueComparator(this.internalSearch, this.getValue(this.internalValue)) && this.setSearch();
                },
                hasItem: function(h) {
                  return this.selectedValues.indexOf(this.getValue(h)) > -1;
                },
                onCopy: function(h) {
                  var p, g;
                  if (this.selectedIndex !== -1) {
                    var m = this.selectedItems[this.selectedIndex], v = this.getText(m);
                    (p = h.clipboardData) === null || p === void 0 || p.setData("text/plain", v), (g = h.clipboardData) === null || g === void 0 || g.setData("text/vnd.vuetify.autocomplete.item+plain", v), h.preventDefault();
                  }
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VAutocomplete/index.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VAutocomplete/index.ts ***!
            \***********************************************/
          /*! exports provided: VAutocomplete, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAutocomplete */
              "./src/components/VAutocomplete/VAutocomplete.ts"
            );
            i.d(r, "VAutocomplete", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VAvatar/VAvatar.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VAvatar/VAvatar.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAvatar/VAvatar.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VAvatar/VAvatar.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAvatar.sass */
              "./src/components/VAvatar/VAvatar.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), l = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(d.default)(a.default, o.default, l.default).extend({
              name: "v-avatar",
              props: {
                left: Boolean,
                right: Boolean,
                size: {
                  type: [Number, String],
                  default: 48
                }
              },
              computed: {
                classes: function() {
                  return u({
                    "v-avatar--left": this.left,
                    "v-avatar--right": this.right
                  }, this.roundedClasses);
                },
                styles: function() {
                  return u({
                    height: Object(f.convertToUnit)(this.size),
                    minWidth: Object(f.convertToUnit)(this.size),
                    width: Object(f.convertToUnit)(this.size)
                  }, this.measurableStyles);
                }
              },
              render: function(h) {
                var p = {
                  staticClass: "v-avatar",
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                };
                return h("div", this.setBackgroundColor(this.color, p), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VAvatar/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAvatar/index.ts ***!
            \*****************************************/
          /*! exports provided: VAvatar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAvatar */
              "./src/components/VAvatar/VAvatar.ts"
            );
            i.d(r, "VAvatar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBadge/VBadge.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VBadge/VBadge.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBadge/VBadge.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VBadge/VBadge.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBadge.sass */
              "./src/components/VBadge/VBadge.sass"
            );
            var a = i(
              /*! ../VIcon/VIcon */
              "./src/components/VIcon/VIcon.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), u = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = function(m, v) {
              var y = {};
              for (var E in m)
                Object.prototype.hasOwnProperty.call(m, E) && v.indexOf(E) < 0 && (y[E] = m[E]);
              if (m != null && typeof Object.getOwnPropertySymbols == "function")
                for (var C = 0, E = Object.getOwnPropertySymbols(m); C < E.length; C++)
                  v.indexOf(E[C]) < 0 && Object.prototype.propertyIsEnumerable.call(m, E[C]) && (y[E[C]] = m[E[C]]);
              return y;
            };
            r.default = Object(c.default)(o.default, Object(u.factory)(["left", "bottom"]), l.default, f.default, d.default).extend({
              name: "v-badge",
              props: {
                avatar: Boolean,
                bordered: Boolean,
                color: {
                  type: String,
                  default: "primary"
                },
                content: {
                  required: !1
                },
                dot: Boolean,
                label: {
                  type: String,
                  default: "$vuetify.badge"
                },
                icon: String,
                inline: Boolean,
                offsetX: [Number, String],
                offsetY: [Number, String],
                overlap: Boolean,
                tile: Boolean,
                transition: {
                  type: String,
                  default: "scale-rotate-transition"
                },
                value: {
                  default: !0
                }
              },
              computed: {
                classes: function() {
                  return p({
                    "v-badge--avatar": this.avatar,
                    "v-badge--bordered": this.bordered,
                    "v-badge--bottom": this.bottom,
                    "v-badge--dot": this.dot,
                    "v-badge--icon": this.icon != null,
                    "v-badge--inline": this.inline,
                    "v-badge--left": this.left,
                    "v-badge--overlap": this.overlap,
                    "v-badge--tile": this.tile
                  }, this.themeClasses);
                },
                computedBottom: function() {
                  return this.bottom ? "auto" : this.computedYOffset;
                },
                computedLeft: function() {
                  return this.isRtl ? this.left ? this.computedXOffset : "auto" : this.left ? "auto" : this.computedXOffset;
                },
                computedRight: function() {
                  return this.isRtl ? this.left ? "auto" : this.computedXOffset : this.left ? this.computedXOffset : "auto";
                },
                computedTop: function() {
                  return this.bottom ? this.computedYOffset : "auto";
                },
                computedXOffset: function() {
                  return this.calcPosition(this.offsetX);
                },
                computedYOffset: function() {
                  return this.calcPosition(this.offsetY);
                },
                isRtl: function() {
                  return this.$vuetify.rtl;
                },
                // Default fallback if offsetX
                // or offsetY are undefined.
                offset: function() {
                  return this.overlap ? this.dot ? 8 : 12 : this.dot ? 2 : 4;
                },
                styles: function() {
                  return this.inline ? {} : {
                    bottom: this.computedBottom,
                    left: this.computedLeft,
                    right: this.computedRight,
                    top: this.computedTop
                  };
                }
              },
              methods: {
                calcPosition: function(v) {
                  return "calc(100% - " + Object(h.convertToUnit)(v || this.offset) + ")";
                },
                genBadge: function() {
                  var v = this.$vuetify.lang, y = this.$attrs["aria-label"] || v.t(this.label), E = this.setBackgroundColor(this.color, {
                    staticClass: "v-badge__badge",
                    style: this.styles,
                    attrs: {
                      "aria-atomic": this.$attrs["aria-atomic"] || "true",
                      "aria-label": y,
                      "aria-live": this.$attrs["aria-live"] || "polite",
                      title: this.$attrs.title,
                      role: this.$attrs.role || "status"
                    },
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }]
                  }), C = this.$createElement("span", E, [this.genBadgeContent()]);
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition,
                      origin: this.origin,
                      mode: this.mode
                    }
                  }, [C]) : C;
                },
                genBadgeContent: function() {
                  if (!this.dot) {
                    var v = Object(h.getSlot)(this, "badge");
                    if (v)
                      return v;
                    if (this.content)
                      return String(this.content);
                    if (this.icon)
                      return this.$createElement(a.default, this.icon);
                  }
                },
                genBadgeWrapper: function() {
                  return this.$createElement("span", {
                    staticClass: "v-badge__wrapper"
                  }, [this.genBadge()]);
                }
              },
              render: function(v) {
                var y = [this.genBadgeWrapper()], E = [Object(h.getSlot)(this)], C = this.$attrs;
                C["aria-atomic"], C["aria-label"], C["aria-live"], C.role, C.title;
                var x = g(C, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
                return this.inline && this.left ? E.unshift(y) : E.push(y), v("span", {
                  staticClass: "v-badge",
                  attrs: x,
                  class: this.classes
                }, E);
              }
            });
          }
        ),
        /***/
        "./src/components/VBadge/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VBadge/index.ts ***!
            \****************************************/
          /*! exports provided: VBadge, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBadge */
              "./src/components/VBadge/VBadge.ts"
            );
            i.d(r, "VBadge", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBanner/VBanner.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VBanner/VBanner.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBanner/VBanner.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VBanner/VBanner.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBanner.sass */
              "./src/components/VBanner/VBanner.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VAvatar */
              "./src/components/VAvatar/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), d = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), u = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, d.default, u.default).extend({
              name: "v-banner",
              inheritAttrs: !1,
              props: {
                app: Boolean,
                icon: String,
                iconColor: String,
                singleLine: Boolean,
                sticky: Boolean,
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              computed: {
                classes: function() {
                  return p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-banner--has-icon": this.hasIcon,
                    "v-banner--is-mobile": this.isMobile,
                    "v-banner--single-line": this.singleLine,
                    "v-banner--sticky": this.isSticky
                  });
                },
                hasIcon: function() {
                  return !!(this.icon || this.$slots.icon);
                },
                isSticky: function() {
                  return this.sticky || this.app;
                },
                styles: function() {
                  var m = p({}, a.default.options.computed.styles.call(this));
                  if (this.isSticky) {
                    var v = this.app ? this.$vuetify.application.bar + this.$vuetify.application.top : 0;
                    m.top = Object(h.convertToUnit)(v), m.position = "sticky", m.zIndex = 1;
                  }
                  return m;
                }
              },
              methods: {
                /** @public */
                toggle: function() {
                  this.isActive = !this.isActive;
                },
                iconClick: function(m) {
                  this.$emit("click:icon", m);
                },
                genIcon: function() {
                  if (this.hasIcon) {
                    var m;
                    return this.icon ? m = this.$createElement(l.default, {
                      props: {
                        color: this.iconColor,
                        size: 28
                      }
                    }, [this.icon]) : m = this.$slots.icon, this.$createElement(o.default, {
                      staticClass: "v-banner__icon",
                      props: {
                        color: this.color,
                        size: 40
                      },
                      on: {
                        click: this.iconClick
                      }
                    }, [m]);
                  }
                },
                genText: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__text"
                  }, this.$slots.default);
                },
                genActions: function() {
                  var m = this, v = Object(h.getSlot)(this, "actions", {
                    dismiss: function() {
                      return m.isActive = !1;
                    }
                  });
                  if (v)
                    return this.$createElement("div", {
                      staticClass: "v-banner__actions"
                    }, v);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__content"
                  }, [this.genIcon(), this.genText()]);
                },
                genWrapper: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__wrapper"
                  }, [this.genContent(), this.genActions()]);
                }
              },
              render: function(m) {
                var v = {
                  staticClass: "v-banner",
                  attrs: this.attrs$,
                  class: this.classes,
                  style: this.styles,
                  directives: [{
                    name: "show",
                    value: this.isActive
                  }]
                };
                return m(f.VExpandTransition, [m("div", this.outlined ? v : this.setBackgroundColor(this.color, v), [this.genWrapper()])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VBanner/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VBanner/index.ts ***!
            \*****************************************/
          /*! exports provided: VBanner, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBanner */
              "./src/components/VBanner/VBanner.ts"
            );
            i.d(r, "VBanner", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBottomNavigation/VBottomNavigation.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VBottomNavigation/VBottomNavigation.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBottomNavigation/VBottomNavigation.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VBottomNavigation/VBottomNavigation.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBottomNavigation.sass */
              "./src/components/VBottomNavigation/VBottomNavigation.sass"
            );
            var a = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), o = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/scrollable */
              "./src/mixins/scrollable/index.ts"
            ), c = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), h = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = function() {
              return m = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, m.apply(this, arguments);
            };
            r.default = Object(p.default)(
              Object(a.default)("bottom", ["height", "inputValue"]),
              l.default,
              f.default,
              Object(h.factory)("inputValue"),
              d.default,
              u.default,
              c.default
              /* @vue/component */
            ).extend({
              name: "v-bottom-navigation",
              props: {
                activeClass: {
                  type: String,
                  default: "v-btn--active"
                },
                backgroundColor: String,
                grow: Boolean,
                height: {
                  type: [Number, String],
                  default: 56
                },
                hideOnScroll: Boolean,
                horizontal: Boolean,
                inputValue: {
                  type: Boolean,
                  default: !0
                },
                mandatory: Boolean,
                shift: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              data: function() {
                return {
                  isActive: this.inputValue
                };
              },
              computed: {
                canScroll: function() {
                  return u.default.options.computed.canScroll.call(this) && (this.hideOnScroll || !this.inputValue);
                },
                classes: function() {
                  return {
                    "v-bottom-navigation--absolute": this.absolute,
                    "v-bottom-navigation--grow": this.grow,
                    "v-bottom-navigation--fixed": !this.absolute && (this.app || this.fixed),
                    "v-bottom-navigation--horizontal": this.horizontal,
                    "v-bottom-navigation--shift": this.shift
                  };
                },
                styles: function() {
                  return m(m({}, this.measurableStyles), {
                    transform: this.isActive ? "none" : "translateY(100%)"
                  });
                }
              },
              watch: {
                canScroll: "onScroll"
              },
              created: function() {
                this.$attrs.hasOwnProperty("active") && Object(g.breaking)("active.sync", "value or v-model", this);
              },
              methods: {
                thresholdMet: function() {
                  this.hideOnScroll && (this.isActive = !this.isScrollingUp || this.currentScroll > this.computedScrollThreshold, this.$emit("update:input-value", this.isActive)), !(this.currentThreshold < this.computedScrollThreshold) && (this.savedScroll = this.currentScroll);
                },
                updateApplication: function() {
                  return this.$el ? this.$el.clientHeight : 0;
                },
                updateValue: function(y) {
                  this.$emit("change", y);
                }
              },
              render: function(y) {
                var E = this.setBackgroundColor(this.backgroundColor, {
                  staticClass: "v-bottom-navigation",
                  class: this.classes,
                  style: this.styles,
                  props: {
                    activeClass: this.activeClass,
                    mandatory: !!(this.mandatory || this.value !== void 0),
                    tag: this.tag,
                    value: this.internalValue
                  },
                  on: {
                    change: this.updateValue
                  }
                });
                return this.canScroll && (E.directives = E.directives || [], E.directives.push({
                  arg: this.scrollTarget,
                  name: "scroll",
                  value: this.onScroll
                })), y(o.default, this.setTextColor(this.color, E), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VBottomNavigation/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VBottomNavigation/index.ts ***!
            \***************************************************/
          /*! exports provided: VBottomNavigation, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBottomNavigation */
              "./src/components/VBottomNavigation/VBottomNavigation.ts"
            );
            i.d(r, "VBottomNavigation", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBottomSheet/VBottomSheet.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VBottomSheet/VBottomSheet.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBottomSheet/VBottomSheet.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VBottomSheet/VBottomSheet.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBottomSheet.sass */
              "./src/components/VBottomSheet/VBottomSheet.sass"
            );
            var a = i(
              /*! ../VDialog/VDialog */
              "./src/components/VDialog/VDialog.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-bottom-sheet",
              props: {
                inset: Boolean,
                maxWidth: [String, Number],
                transition: {
                  type: String,
                  default: "bottom-sheet-transition"
                }
              },
              computed: {
                classes: function() {
                  return o(o({}, a.default.options.computed.classes.call(this)), {
                    "v-bottom-sheet": !0,
                    "v-bottom-sheet--inset": this.inset
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VBottomSheet/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VBottomSheet/index.ts ***!
            \**********************************************/
          /*! exports provided: VBottomSheet, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBottomSheet */
              "./src/components/VBottomSheet/VBottomSheet.ts"
            );
            i.d(r, "VBottomSheet", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbs.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbs.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbs.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbs.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBreadcrumbs.sass */
              "./src/components/VBreadcrumbs/VBreadcrumbs.sass"
            );
            var a = i(
              /*! ./VBreadcrumbsItem */
              "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts"
            ), o = i(
              /*! ./VBreadcrumbsDivider */
              "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(
              l.default
              /* @vue/component */
            ).extend({
              name: "v-breadcrumbs",
              props: {
                divider: {
                  type: String,
                  default: "/"
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                large: Boolean
              },
              computed: {
                classes: function() {
                  return d({
                    "v-breadcrumbs--large": this.large
                  }, this.themeClasses);
                }
              },
              methods: {
                genDivider: function() {
                  return this.$createElement(o.default, this.$slots.divider ? this.$slots.divider : this.divider);
                },
                genItems: function() {
                  for (var c = [], h = !!this.$scopedSlots.item, p = [], g = 0; g < this.items.length; g++) {
                    var m = this.items[g];
                    p.push(m.text), h ? c.push(this.$scopedSlots.item({
                      item: m
                    })) : c.push(this.$createElement(a.default, {
                      key: p.join("."),
                      props: m
                    }, [m.text])), g < this.items.length - 1 && c.push(this.genDivider());
                  }
                  return c;
                }
              },
              render: function(c) {
                var h = this.$slots.default || this.genItems();
                return c("ul", {
                  staticClass: "v-breadcrumbs",
                  class: this.classes
                }, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(a.createSimpleFunctional)("v-breadcrumbs__divider", "li");
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbsItem.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-breadcrumbs-item",
              props: {
                // In a breadcrumb, the currently
                // active item should be dimmed
                activeClass: {
                  type: String,
                  default: "v-breadcrumbs__item--disabled"
                },
                ripple: {
                  type: [Boolean, Object],
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  var d;
                  return d = {
                    "v-breadcrumbs__item": !0
                  }, d[this.activeClass] = this.disabled, d;
                }
              },
              render: function(d) {
                var u = this.generateRouteLink(), c = u.tag, h = u.data;
                return d("li", [d(c, l(l({}, h), {
                  attrs: l(l({}, h.attrs), {
                    "aria-current": this.isActive && this.isLink ? "page" : void 0
                  })
                }), this.$slots.default)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VBreadcrumbs/index.ts ***!
            \**********************************************/
          /*! exports provided: VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBreadcrumbs */
              "./src/components/VBreadcrumbs/VBreadcrumbs.ts"
            );
            i.d(r, "VBreadcrumbs", function() {
              return a.default;
            });
            var o = i(
              /*! ./VBreadcrumbsItem */
              "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts"
            );
            i.d(r, "VBreadcrumbsItem", function() {
              return o.default;
            });
            var l = i(
              /*! ./VBreadcrumbsDivider */
              "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts"
            );
            i.d(r, "VBreadcrumbsDivider", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VBreadcrumbs: a.default,
                VBreadcrumbsItem: o.default,
                VBreadcrumbsDivider: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VBtn/VBtn.sass": (
          /*!***************************************!*\
            !*** ./src/components/VBtn/VBtn.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBtn/VBtn.ts": (
          /*!*************************************!*\
            !*** ./src/components/VBtn/VBtn.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBtn.sass */
              "./src/components/VBtn/VBtn.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VProgressCircular */
              "./src/components/VProgressCircular/index.ts"
            ), l = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), u = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), c = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), h = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function m(C) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? m = function(b) {
                return typeof b;
              } : m = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
              }, m(C);
            }
            var v = function() {
              return v = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var T in x)
                    Object.prototype.hasOwnProperty.call(x, T) && (C[T] = x[T]);
                }
                return C;
              }, v.apply(this, arguments);
            }, y = function(C, x) {
              var b = typeof Symbol == "function" && C[Symbol.iterator];
              if (!b)
                return C;
              var P = b.call(C), T, O = [], S;
              try {
                for (; (x === void 0 || x-- > 0) && !(T = P.next()).done; )
                  O.push(T.value);
              } catch (L) {
                S = {
                  error: L
                };
              } finally {
                try {
                  T && !T.done && (b = P.return) && b.call(P);
                } finally {
                  if (S)
                    throw S.error;
                }
              }
              return O;
            }, E = Object(p.default)(
              a.default,
              c.default,
              u.default,
              h.default,
              Object(l.factory)("btnToggle"),
              Object(f.factory)("inputValue")
              /* @vue/component */
            );
            r.default = E.extend().extend({
              name: "v-btn",
              props: {
                activeClass: {
                  type: String,
                  default: function() {
                    return this.btnToggle ? this.btnToggle.activeClass : "";
                  }
                },
                block: Boolean,
                depressed: Boolean,
                fab: Boolean,
                icon: Boolean,
                loading: Boolean,
                outlined: Boolean,
                plain: Boolean,
                retainFocusOnClick: Boolean,
                rounded: Boolean,
                tag: {
                  type: String,
                  default: "button"
                },
                text: Boolean,
                tile: Boolean,
                type: {
                  type: String,
                  default: "button"
                },
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-btn--active"
                };
              },
              computed: {
                classes: function() {
                  return v(v(v(v(v(v({
                    "v-btn": !0
                  }, c.default.options.computed.classes.call(this)), {
                    "v-btn--absolute": this.absolute,
                    "v-btn--block": this.block,
                    "v-btn--bottom": this.bottom,
                    "v-btn--disabled": this.disabled,
                    "v-btn--is-elevated": this.isElevated,
                    "v-btn--fab": this.fab,
                    "v-btn--fixed": this.fixed,
                    "v-btn--has-bg": this.hasBg,
                    "v-btn--icon": this.icon,
                    "v-btn--left": this.left,
                    "v-btn--loading": this.loading,
                    "v-btn--outlined": this.outlined,
                    "v-btn--plain": this.plain,
                    "v-btn--right": this.right,
                    "v-btn--round": this.isRound,
                    "v-btn--rounded": this.rounded,
                    "v-btn--router": this.to,
                    "v-btn--text": this.text,
                    "v-btn--tile": this.tile,
                    "v-btn--top": this.top
                  }), this.themeClasses), this.groupClasses), this.elevationClasses), this.sizeableClasses);
                },
                computedElevation: function() {
                  if (!this.disabled)
                    return d.default.options.computed.computedElevation.call(this);
                },
                computedRipple: function() {
                  var x, b = this.icon || this.fab ? {
                    circle: !0
                  } : !0;
                  return this.disabled ? !1 : (x = this.ripple) !== null && x !== void 0 ? x : b;
                },
                hasBg: function() {
                  return !this.text && !this.plain && !this.outlined && !this.icon;
                },
                isElevated: function() {
                  return !this.icon && !this.text && !this.outlined && !this.depressed && !this.disabled && !this.plain && (this.elevation == null || Number(this.elevation) > 0);
                },
                isRound: function() {
                  return !!(this.icon || this.fab);
                },
                styles: function() {
                  return v({}, this.measurableStyles);
                }
              },
              created: function() {
                var x = this, b = [["flat", "text"], ["outline", "outlined"], ["round", "rounded"]];
                b.forEach(function(P) {
                  var T = y(P, 2), O = T[0], S = T[1];
                  x.$attrs.hasOwnProperty(O) && Object(g.breaking)(O, S, x);
                });
              },
              methods: {
                click: function(x) {
                  !this.retainFocusOnClick && !this.fab && x.detail && this.$el.blur(), this.$emit("click", x), this.btnToggle && this.toggle();
                },
                genContent: function() {
                  return this.$createElement("span", {
                    staticClass: "v-btn__content"
                  }, this.$slots.default);
                },
                genLoader: function() {
                  return this.$createElement("span", {
                    class: "v-btn__loader"
                  }, this.$slots.loader || [this.$createElement(o.default, {
                    props: {
                      indeterminate: !0,
                      size: 23,
                      width: 2
                    }
                  })]);
                }
              },
              render: function(x) {
                var b = [this.genContent(), this.loading && this.genLoader()], P = this.generateRouteLink(), T = P.tag, O = P.data, S = this.hasBg ? this.setBackgroundColor : this.setTextColor;
                return T === "button" && (O.attrs.type = this.type, O.attrs.disabled = this.disabled), O.attrs.value = ["string", "number"].includes(m(this.value)) ? this.value : JSON.stringify(this.value), x(T, this.disabled ? O : S(this.color, O), b);
              }
            });
          }
        ),
        /***/
        "./src/components/VBtn/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VBtn/index.ts ***!
            \**************************************/
          /*! exports provided: VBtn, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBtn */
              "./src/components/VBtn/VBtn.ts"
            );
            i.d(r, "VBtn", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBtnToggle/VBtnToggle.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VBtnToggle/VBtnToggle.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBtnToggle/VBtnToggle.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VBtnToggle/VBtnToggle.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBtnToggle.sass */
              "./src/components/VBtnToggle/VBtnToggle.sass"
            );
            var a = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.default, o.default).extend({
              name: "v-btn-toggle",
              props: {
                backgroundColor: String,
                borderless: Boolean,
                dense: Boolean,
                group: Boolean,
                rounded: Boolean,
                shaped: Boolean,
                tile: Boolean
              },
              computed: {
                classes: function() {
                  return f(f(f({}, a.default.options.computed.classes.call(this)), {
                    "v-btn-toggle": !0,
                    "v-btn-toggle--borderless": this.borderless,
                    "v-btn-toggle--dense": this.dense,
                    "v-btn-toggle--group": this.group,
                    "v-btn-toggle--rounded": this.rounded,
                    "v-btn-toggle--shaped": this.shaped,
                    "v-btn-toggle--tile": this.tile
                  }), this.themeClasses);
                }
              },
              methods: {
                genData: function() {
                  var u = this.setTextColor(this.color, f({}, a.default.options.methods.genData.call(this)));
                  return this.group ? u : this.setBackgroundColor(this.backgroundColor, u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VBtnToggle/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VBtnToggle/index.ts ***!
            \********************************************/
          /*! exports provided: VBtnToggle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBtnToggle */
              "./src/components/VBtnToggle/VBtnToggle.ts"
            );
            i.d(r, "VBtnToggle", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendar.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCalendar/VCalendar.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/calendar-with-events */
              "./src/components/VCalendar/mixins/calendar-with-events.ts"
            ), o = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), l = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), f = i(
              /*! ./VCalendarMonthly */
              "./src/components/VCalendar/VCalendarMonthly.ts"
            ), d = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            ), u = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            ), c = i(
              /*! ./VCalendarCategory */
              "./src/components/VCalendar/VCalendarCategory.ts"
            ), h = i(
              /*! ./util/parser */
              "./src/components/VCalendar/util/parser.ts"
            );
            function p(m) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? p = function(y) {
                return typeof y;
              } : p = function(y) {
                return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
              }, p(m);
            }
            var g = function() {
              return g = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, g.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-calendar",
              props: g(g(g(g({}, o.default.calendar), o.default.weeks), o.default.intervals), o.default.category),
              data: function() {
                return {
                  lastStart: null,
                  lastEnd: null
                };
              },
              computed: {
                parsedValue: function() {
                  return Object(l.validateTimestamp)(this.value) ? Object(l.parseTimestamp)(this.value, !0) : this.parsedStart || this.times.today;
                },
                parsedCategoryDays: function() {
                  return parseInt(this.categoryDays) || 1;
                },
                renderProps: function() {
                  var v = this.parsedValue, y = null, E = this.maxDays, C = this.parsedWeekdays, x = this.parsedCategories, b = v, P = v;
                  switch (this.type) {
                    case "month":
                      y = f.default, b = Object(l.getStartOfMonth)(v), P = Object(l.getEndOfMonth)(v);
                      break;
                    case "week":
                      y = d.default, b = this.getStartOfWeek(v), P = this.getEndOfWeek(v), E = 7;
                      break;
                    case "day":
                      y = d.default, E = 1, C = [b.weekday];
                      break;
                    case "4day":
                      y = d.default, P = Object(l.relativeDays)(Object(l.copyTimestamp)(P), l.nextDay, 3), Object(l.updateFormatted)(P), E = 4, C = [b.weekday, (b.weekday + 1) % 7, (b.weekday + 2) % 7, (b.weekday + 3) % 7];
                      break;
                    case "custom-weekly":
                      y = u.default, b = this.parsedStart || v, P = this.parsedEnd;
                      break;
                    case "custom-daily":
                      y = d.default, b = this.parsedStart || v, P = this.parsedEnd;
                      break;
                    case "category":
                      var T = this.parsedCategoryDays;
                      y = c.default, P = Object(l.relativeDays)(Object(l.copyTimestamp)(P), l.nextDay, T), Object(l.updateFormatted)(P), E = T, C = [];
                      for (var O = 0; O < T; O++)
                        C.push((b.weekday + O) % 7);
                      x = this.getCategoryList(x);
                      break;
                    default:
                      throw new Error(this.type + " is not a valid Calendar type");
                  }
                  return {
                    component: y,
                    start: b,
                    end: P,
                    maxDays: E,
                    weekdays: C,
                    categories: x
                  };
                },
                eventWeekdays: function() {
                  return this.renderProps.weekdays;
                },
                categoryMode: function() {
                  return this.type === "category";
                },
                title: function() {
                  var v = this.renderProps, y = v.start, E = v.end, C = y.year !== E.year, x = C || y.month !== E.month;
                  return C ? this.monthShortFormatter(y, !0) + " " + y.year + " - " + this.monthShortFormatter(E, !0) + " " + E.year : x ? this.monthShortFormatter(y, !0) + " - " + this.monthShortFormatter(E, !0) + " " + E.year : this.monthLongFormatter(y, !1) + " " + y.year;
                },
                monthLongFormatter: function() {
                  return this.getFormatter({
                    timeZone: "UTC",
                    month: "long"
                  });
                },
                monthShortFormatter: function() {
                  return this.getFormatter({
                    timeZone: "UTC",
                    month: "short"
                  });
                },
                parsedCategories: function() {
                  return Object(h.getParsedCategories)(this.categories, this.categoryText);
                }
              },
              watch: {
                renderProps: "checkChange"
              },
              mounted: function() {
                this.updateEventVisibility(), this.checkChange();
              },
              updated: function() {
                window.requestAnimationFrame(this.updateEventVisibility);
              },
              methods: {
                checkChange: function() {
                  var v = this, y = v.lastStart, E = v.lastEnd, C = this.renderProps, x = C.start, b = C.end;
                  (!y || !E || x.date !== y.date || b.date !== E.date) && (this.lastStart = x, this.lastEnd = b, this.$emit("change", {
                    start: x,
                    end: b
                  }));
                },
                move: function(v) {
                  v === void 0 && (v = 1);
                  for (var y = Object(l.copyTimestamp)(this.parsedValue), E = v > 0, C = E ? l.nextDay : l.prevDay, x = E ? l.DAYS_IN_MONTH_MAX : l.DAY_MIN, b = E ? v : -v; --b >= 0; )
                    switch (this.type) {
                      case "month":
                        y.day = x, C(y);
                        break;
                      case "week":
                        Object(l.relativeDays)(y, C, l.DAYS_IN_WEEK);
                        break;
                      case "day":
                        Object(l.relativeDays)(y, C, 1);
                        break;
                      case "4day":
                        Object(l.relativeDays)(y, C, 4);
                        break;
                      case "category":
                        Object(l.relativeDays)(y, C, this.parsedCategoryDays);
                        break;
                    }
                  Object(l.updateWeekday)(y), Object(l.updateFormatted)(y), Object(l.updateRelative)(y, this.times.now), this.value instanceof Date ? this.$emit("input", Object(l.timestampToDate)(y)) : typeof this.value == "number" ? this.$emit("input", Object(l.timestampToDate)(y).getTime()) : this.$emit("input", y.date), this.$emit("moved", y);
                },
                next: function(v) {
                  v === void 0 && (v = 1), this.move(v);
                },
                prev: function(v) {
                  v === void 0 && (v = 1), this.move(-v);
                },
                timeToY: function(v, y) {
                  y === void 0 && (y = !0);
                  var E = this.$children[0];
                  return E && E.timeToY ? E.timeToY(v, y) : !1;
                },
                timeDelta: function(v) {
                  var y = this.$children[0];
                  return y && y.timeDelta ? y.timeDelta(v) : !1;
                },
                minutesToPixels: function(v) {
                  var y = this.$children[0];
                  return y && y.minutesToPixels ? y.minutesToPixels(v) : -1;
                },
                scrollToTime: function(v) {
                  var y = this.$children[0];
                  return y && y.scrollToTime ? y.scrollToTime(v) : !1;
                },
                parseTimestamp: function(v, y) {
                  return Object(l.parseTimestamp)(v, y, this.times.now);
                },
                timestampToDate: function(v) {
                  return Object(l.timestampToDate)(v);
                },
                getCategoryList: function(v) {
                  var y = this;
                  if (!this.noEvents) {
                    var E = v.reduce(function(b, P, T) {
                      return p(P) === "object" && P.categoryName ? b[P.categoryName] = {
                        index: T,
                        count: 0
                      } : typeof P == "string" && (b[P] = {
                        index: T,
                        count: 0
                      }), b;
                    }, {});
                    if (!this.categoryHideDynamic || !this.categoryShowAll) {
                      var C = v.length;
                      this.parsedEvents.forEach(function(b) {
                        var P = b.category;
                        typeof P != "string" && (P = y.categoryForInvalid), P && (P in E ? E[P].count++ : y.categoryHideDynamic || (E[P] = {
                          index: C++,
                          count: 1
                        }));
                      });
                    }
                    if (!this.categoryShowAll)
                      for (var x in E)
                        E[x].count === 0 && delete E[x];
                    v = v.filter(function(b) {
                      return p(b) === "object" && b.categoryName ? E.hasOwnProperty(b.categoryName) : typeof b == "string" ? E.hasOwnProperty(b) : !1;
                    });
                  }
                  return v;
                }
              },
              render: function(v) {
                var y = this, E = this.renderProps, C = E.start, x = E.end, b = E.maxDays, P = E.component, T = E.weekdays, O = E.categories;
                return v(P, {
                  staticClass: "v-calendar",
                  class: {
                    "v-calendar-events": !this.noEvents
                  },
                  props: g(g({}, this.$props), {
                    start: C.date,
                    end: x.date,
                    maxDays: b,
                    weekdays: T,
                    categories: O
                  }),
                  attrs: {
                    role: "grid"
                  },
                  directives: [{
                    modifiers: {
                      quiet: !0
                    },
                    name: "resize",
                    value: this.updateEventVisibility
                  }],
                  on: g(g({}, this.$listeners), {
                    "click:date": function(L, A) {
                      y.$listeners.input && y.$emit("input", L.date), y.$listeners["click:date"] && y.$emit("click:date", L, A);
                    }
                  }),
                  scopedSlots: this.getScopedSlots()
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarCategory.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VCalendar/VCalendarCategory.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarCategory.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarCategory.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarCategory.sass */
              "./src/components/VCalendar/VCalendarCategory.sass"
            );
            var a = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), f = i(
              /*! ./util/parser */
              "./src/components/VCalendar/util/parser.ts"
            );
            function d(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(m) {
                return typeof m;
              } : d = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, d(p);
            }
            var u = function() {
              return u = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, u.apply(this, arguments);
            }, c = function(p, g) {
              var m = typeof Symbol == "function" && p[Symbol.iterator];
              if (!m)
                return p;
              var v = m.call(p), y, E = [], C;
              try {
                for (; (g === void 0 || g-- > 0) && !(y = v.next()).done; )
                  E.push(y.value);
              } catch (x) {
                C = {
                  error: x
                };
              } finally {
                try {
                  y && !y.done && (m = v.return) && m.call(v);
                } finally {
                  if (C)
                    throw C.error;
                }
              }
              return E;
            }, h = function(p, g, m) {
              if (m || arguments.length === 2)
                for (var v = 0, y = g.length, E; v < y; v++)
                  (E || !(v in g)) && (E || (E = Array.prototype.slice.call(g, 0, v)), E[v] = g[v]);
              return p.concat(E || Array.prototype.slice.call(g));
            };
            r.default = a.default.extend({
              name: "v-calendar-category",
              props: l.default.category,
              computed: {
                classes: function() {
                  return u({
                    "v-calendar-daily": !0,
                    "v-calendar-category": !0
                  }, this.themeClasses);
                },
                parsedCategories: function() {
                  return Object(f.getParsedCategories)(this.categories, this.categoryText);
                }
              },
              methods: {
                genDayHeader: function(g, m) {
                  var v = this, y = {
                    staticClass: "v-calendar-category__columns"
                  }, E = u(u({
                    week: this.days
                  }, g), {
                    index: m
                  }), C = this.parsedCategories.map(function(x) {
                    return v.genDayHeaderCategory(g, v.getCategoryScope(E, x));
                  });
                  return [this.$createElement("div", y, C)];
                },
                getCategoryScope: function(g, m) {
                  var v = d(m) === "object" && m && m.categoryName === this.categoryForInvalid ? null : m;
                  return u(u({}, g), {
                    category: v
                  });
                },
                genDayHeaderCategory: function(g, m) {
                  var v = this, y = d(m.category) === "object" ? m.category.categoryName : m.category;
                  return this.$createElement("div", {
                    staticClass: "v-calendar-category__column-header",
                    on: this.getDefaultMouseEventHandlers(":day-category", function(E) {
                      return v.getCategoryScope(v.getSlotScope(g), m.category);
                    })
                  }, [Object(o.getSlot)(this, "category", m) || this.genDayHeaderCategoryTitle(y), Object(o.getSlot)(this, "day-header", m)]);
                },
                genDayHeaderCategoryTitle: function(g) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-category__category"
                  }, g === null ? this.categoryForInvalid : g);
                },
                genDays: function() {
                  var g = this, m = [];
                  return this.days.forEach(function(v, y) {
                    var E = new Array(g.parsedCategories.length || 1);
                    E.fill(v), m.push.apply(m, h([], c(E.map(function(C, x) {
                      return g.genDay(C, y, x);
                    })), !1));
                  }), m;
                },
                genDay: function(g, m, v) {
                  var y = this, E = this.parsedCategories[v];
                  return this.$createElement("div", {
                    key: g.date + "-" + v,
                    staticClass: "v-calendar-daily__day",
                    class: this.getRelativeClasses(g),
                    on: this.getDefaultMouseEventHandlers(":time", function(C) {
                      return y.getSlotScope(y.getTimestampAtEvent(C, g));
                    })
                  }, h(h([], c(this.genDayIntervals(m, E)), !1), c(this.genDayBody(g, E)), !1));
                },
                genDayIntervals: function(g, m) {
                  var v = this;
                  return this.intervals[g].map(function(y) {
                    return v.genDayInterval(y, m);
                  });
                },
                genDayInterval: function(g, m) {
                  var v = this, y = Object(o.convertToUnit)(this.intervalHeight), E = this.intervalStyle || this.intervalStyleDefault, C = {
                    key: g.time,
                    staticClass: "v-calendar-daily__day-interval",
                    style: u({
                      height: y
                    }, E(u(u({}, g), {
                      category: m
                    })))
                  }, x = Object(o.getSlot)(this, "interval", function() {
                    return v.getCategoryScope(v.getSlotScope(g), m);
                  });
                  return this.$createElement("div", C, x);
                },
                genDayBody: function(g, m) {
                  var v = {
                    staticClass: "v-calendar-category__columns"
                  }, y = [this.genDayBodyCategory(g, m)];
                  return [this.$createElement("div", v, y)];
                },
                genDayBodyCategory: function(g, m) {
                  var v = this, y = {
                    staticClass: "v-calendar-category__column",
                    on: this.getDefaultMouseEventHandlers(":time-category", function(C) {
                      return v.getCategoryScope(v.getSlotScope(v.getTimestampAtEvent(C, g)), m);
                    })
                  }, E = Object(o.getSlot)(this, "day-body", function() {
                    return v.getCategoryScope(v.getSlotScope(g), m);
                  });
                  return this.$createElement("div", y, E);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarDaily.sass": (
          /*!******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarDaily.sass ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarDaily.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VCalendar/VCalendarDaily.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarDaily.sass */
              "./src/components/VCalendar/VCalendarDaily.sass"
            );
            var a = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ./mixins/calendar-with-intervals */
              "./src/components/VCalendar/mixins/calendar-with-intervals.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, d.apply(this, arguments);
            }, u = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            }, c = function(h, p, g) {
              if (g || arguments.length === 2)
                for (var m = 0, v = p.length, y; m < v; m++)
                  (y || !(m in p)) && (y || (y = Array.prototype.slice.call(p, 0, m)), y[m] = p[m]);
              return h.concat(y || Array.prototype.slice.call(p));
            };
            r.default = l.default.extend({
              name: "v-calendar-daily",
              directives: {
                Resize: a.default
              },
              data: function() {
                return {
                  scrollPush: 0
                };
              },
              computed: {
                classes: function() {
                  return d({
                    "v-calendar-daily": !0
                  }, this.themeClasses);
                }
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function() {
                  this.$nextTick(this.onResize);
                },
                onResize: function() {
                  this.scrollPush = this.getScrollPush();
                },
                getScrollPush: function() {
                  var p = this.$refs.scrollArea, g = this.$refs.pane;
                  return p && g ? p.offsetWidth - g.offsetWidth : 0;
                },
                genHead: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__head",
                    style: {
                      marginRight: this.scrollPush + "px"
                    }
                  }, c([this.genHeadIntervals()], u(this.genHeadDays()), !1));
                },
                genHeadIntervals: function() {
                  var p = Object(f.convertToUnit)(this.intervalWidth);
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__intervals-head",
                    style: {
                      width: p
                    }
                  }, Object(f.getSlot)(this, "interval-header"));
                },
                genHeadDays: function() {
                  return this.days.map(this.genHeadDay);
                },
                genHeadDay: function(p, g) {
                  var m = this;
                  return this.$createElement("div", {
                    key: p.date,
                    staticClass: "v-calendar-daily_head-day",
                    class: this.getRelativeClasses(p),
                    on: this.getDefaultMouseEventHandlers(":day", function(v) {
                      return d({
                        nativeEvent: v
                      }, m.getSlotScope(p));
                    })
                  }, c([this.genHeadWeekday(p), this.genHeadDayLabel(p)], u(this.genDayHeader(p, g)), !1));
                },
                genDayHeader: function(p, g) {
                  var m = this;
                  return Object(f.getSlot)(this, "day-header", function() {
                    return d(d({
                      week: m.days
                    }, p), {
                      index: g
                    });
                  }) || [];
                },
                genHeadWeekday: function(p) {
                  var g = p.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(g, {
                    staticClass: "v-calendar-daily_head-weekday"
                  }), this.weekdayFormatter(p, this.shortWeekdays));
                },
                genHeadDayLabel: function(p) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily_head-day-label"
                  }, Object(f.getSlot)(this, "day-label-header", p) || [this.genHeadDayButton(p)]);
                },
                genHeadDayButton: function(p) {
                  var g = p.present ? this.color : "transparent";
                  return this.$createElement(o.default, {
                    props: {
                      color: g,
                      fab: !0,
                      depressed: !0
                    },
                    on: this.getMouseEventHandlers({
                      "click:date": {
                        event: "click",
                        stop: !0
                      },
                      "contextmenu:date": {
                        event: "contextmenu",
                        stop: !0,
                        prevent: !0,
                        result: !1
                      }
                    }, function(m) {
                      return d({
                        nativeEvent: m
                      }, p);
                    })
                  }, this.dayFormatter(p, !1));
                },
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__body"
                  }, [this.genScrollArea()]);
                },
                genScrollArea: function() {
                  return this.$createElement("div", {
                    ref: "scrollArea",
                    staticClass: "v-calendar-daily__scroll-area"
                  }, [this.genPane()]);
                },
                genPane: function() {
                  return this.$createElement("div", {
                    ref: "pane",
                    staticClass: "v-calendar-daily__pane",
                    style: {
                      height: Object(f.convertToUnit)(this.bodyHeight)
                    }
                  }, [this.genDayContainer()]);
                },
                genDayContainer: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__day-container"
                  }, c([this.genBodyIntervals()], u(this.genDays()), !1));
                },
                genDays: function() {
                  return this.days.map(this.genDay);
                },
                genDay: function(p, g) {
                  var m = this;
                  return this.$createElement("div", {
                    key: p.date,
                    staticClass: "v-calendar-daily__day",
                    class: this.getRelativeClasses(p),
                    on: this.getDefaultMouseEventHandlers(":time", function(v) {
                      return d({
                        nativeEvent: v
                      }, m.getSlotScope(m.getTimestampAtEvent(v, p)));
                    })
                  }, c(c([], u(this.genDayIntervals(g)), !1), u(this.genDayBody(p)), !1));
                },
                genDayBody: function(p) {
                  var g = this;
                  return Object(f.getSlot)(this, "day-body", function() {
                    return g.getSlotScope(p);
                  }) || [];
                },
                genDayIntervals: function(p) {
                  return this.intervals[p].map(this.genDayInterval);
                },
                genDayInterval: function(p) {
                  var g = this, m = Object(f.convertToUnit)(this.intervalHeight), v = this.intervalStyle || this.intervalStyleDefault, y = {
                    key: p.time,
                    staticClass: "v-calendar-daily__day-interval",
                    style: d({
                      height: m
                    }, v(p))
                  }, E = Object(f.getSlot)(this, "interval", function() {
                    return g.getSlotScope(p);
                  });
                  return this.$createElement("div", y, E);
                },
                genBodyIntervals: function() {
                  var p = this, g = Object(f.convertToUnit)(this.intervalWidth), m = {
                    staticClass: "v-calendar-daily__intervals-body",
                    style: {
                      width: g
                    },
                    on: this.getDefaultMouseEventHandlers(":interval", function(v) {
                      return d({
                        nativeEvent: v
                      }, p.getTimestampAtEvent(v, p.parsedStart));
                    })
                  };
                  return this.$createElement("div", m, this.genIntervalLabels());
                },
                genIntervalLabels: function() {
                  return this.intervals.length ? this.intervals[0].map(this.genIntervalLabel) : null;
                },
                genIntervalLabel: function(p) {
                  var g = Object(f.convertToUnit)(this.intervalHeight), m = this.shortIntervals, v = this.showIntervalLabel || this.showIntervalLabelDefault, y = v(p), E = y ? this.intervalFormatter(p, m) : void 0;
                  return this.$createElement("div", {
                    key: p.time,
                    staticClass: "v-calendar-daily__interval",
                    style: {
                      height: g
                    }
                  }, [this.$createElement("div", {
                    staticClass: "v-calendar-daily__interval-text"
                  }, E)]);
                }
              },
              render: function(p) {
                return p("div", {
                  class: this.classes,
                  on: {
                    dragstart: function(m) {
                      m.preventDefault();
                    }
                  },
                  directives: [{
                    modifiers: {
                      quiet: !0
                    },
                    name: "resize",
                    value: this.onResize
                  }]
                }, [this.hideHeader ? "" : this.genHead(), this.genBody()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarMonthly.ts": (
          /*!******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarMonthly.ts ***!
            \******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarWeekly.sass */
              "./src/components/VCalendar/VCalendarWeekly.sass"
            );
            var a = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            ), o = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = a.default.extend({
              name: "v-calendar-monthly",
              computed: {
                staticClass: function() {
                  return "v-calendar-monthly v-calendar-weekly";
                },
                parsedStart: function() {
                  return Object(o.getStartOfMonth)(Object(o.parseTimestamp)(this.start, !0));
                },
                parsedEnd: function() {
                  return Object(o.getEndOfMonth)(Object(o.parseTimestamp)(this.end, !0));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarWeekly.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarWeekly.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarWeekly.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VCalendar/VCalendarWeekly.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarWeekly.sass */
              "./src/components/VCalendar/VCalendarWeekly.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ./mixins/calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            ), d = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), u = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = o.default.extend({
              name: "v-calendar-weekly",
              props: d.default.weeks,
              computed: {
                staticClass: function() {
                  return "v-calendar-weekly";
                },
                classes: function() {
                  return this.themeClasses;
                },
                parsedMinWeeks: function() {
                  return parseInt(this.minWeeks);
                },
                days: function() {
                  var m = this.parsedMinWeeks * this.parsedWeekdays.length, v = this.getStartOfWeek(this.parsedStart), y = this.getEndOfWeek(this.parsedEnd);
                  return Object(u.createDayList)(v, y, this.times.today, this.weekdaySkips, Number.MAX_SAFE_INTEGER, m);
                },
                todayWeek: function() {
                  var m = this.times.today, v = this.getStartOfWeek(m), y = this.getEndOfWeek(m);
                  return Object(u.createDayList)(v, y, m, this.weekdaySkips, this.parsedWeekdays.length, this.parsedWeekdays.length);
                },
                monthFormatter: function() {
                  if (this.monthFormat)
                    return this.monthFormat;
                  var m = {
                    timeZone: "UTC",
                    month: "long"
                  }, v = {
                    timeZone: "UTC",
                    month: "short"
                  };
                  return Object(u.createNativeLocaleFormatter)(this.currentLocale, function(y, E) {
                    return E ? v : m;
                  });
                }
              },
              methods: {
                isOutside: function(m) {
                  var v = Object(u.getDayIdentifier)(m);
                  return v < Object(u.getDayIdentifier)(this.parsedStart) || v > Object(u.getDayIdentifier)(this.parsedEnd);
                },
                genHead: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__head",
                    attrs: {
                      role: "row"
                    }
                  }, this.genHeadDays());
                },
                genHeadDays: function() {
                  var m = this.todayWeek.map(this.genHeadDay);
                  return this.showWeek && m.unshift(this.$createElement("div", {
                    staticClass: "v-calendar-weekly__head-weeknumber"
                  })), m;
                },
                genHeadDay: function(m, v) {
                  var y = this.isOutside(this.days[v]), E = m.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(E, {
                    key: m.date,
                    staticClass: "v-calendar-weekly__head-weekday",
                    class: this.getRelativeClasses(m, y),
                    attrs: {
                      role: "columnheader"
                    }
                  }), this.weekdayFormatter(m, this.shortWeekdays));
                },
                genWeeks: function() {
                  for (var m = this.days, v = this.parsedWeekdays.length, y = [], E = 0; E < m.length; E += v)
                    y.push(this.genWeek(m.slice(E, E + v), this.getWeekNumber(m[E])));
                  return y;
                },
                genWeek: function(m, v) {
                  var y = this, E = m.map(function(C, x) {
                    return y.genDay(C, x, m);
                  });
                  return this.showWeek && E.unshift(this.genWeekNumber(v)), this.$createElement("div", {
                    key: m[0].date,
                    staticClass: "v-calendar-weekly__week",
                    attrs: {
                      role: "row"
                    }
                  }, E);
                },
                getWeekNumber: function(m) {
                  return Object(f.weekNumber)(m.year, m.month - 1, m.day, this.parsedWeekdays[0], parseInt(this.localeFirstDayOfYear));
                },
                genWeekNumber: function(m) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__weeknumber"
                  }, [this.$createElement("small", String(m))]);
                },
                genDay: function(m, v, y) {
                  var E = this.isOutside(m);
                  return this.$createElement("div", {
                    key: m.date,
                    staticClass: "v-calendar-weekly__day",
                    class: this.getRelativeClasses(m, E),
                    attrs: {
                      role: "cell"
                    },
                    on: this.getDefaultMouseEventHandlers(":day", function(C) {
                      return c({
                        nativeEvent: C
                      }, m);
                    })
                  }, p([this.genDayLabel(m)], h(Object(l.getSlot)(this, "day", function() {
                    return c({
                      outside: E,
                      index: v,
                      week: y
                    }, m);
                  }) || []), !1));
                },
                genDayLabel: function(m) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__day-label"
                  }, Object(l.getSlot)(this, "day-label", m) || [this.genDayLabelButton(m)]);
                },
                genDayLabelButton: function(m) {
                  var v = m.present ? this.color : "transparent", y = m.day === 1 && this.showMonthOnFirst;
                  return this.$createElement(a.default, {
                    props: {
                      color: v,
                      fab: !0,
                      depressed: !0,
                      small: !0
                    },
                    on: this.getMouseEventHandlers({
                      "click:date": {
                        event: "click",
                        stop: !0
                      },
                      "contextmenu:date": {
                        event: "contextmenu",
                        stop: !0,
                        prevent: !0,
                        result: !1
                      }
                    }, function(E) {
                      return c({
                        nativeEvent: E
                      }, m);
                    })
                  }, y ? this.monthFormatter(m, this.shortMonths) + " " + this.dayFormatter(m, !1) : this.dayFormatter(m, !1));
                },
                genDayMonth: function(m) {
                  var v = m.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(v, {
                    staticClass: "v-calendar-weekly__day-month"
                  }), Object(l.getSlot)(this, "day-month", m) || this.monthFormatter(m, this.shortMonths));
                }
              },
              render: function(m) {
                return m("div", {
                  staticClass: this.staticClass,
                  class: this.classes,
                  on: {
                    dragstart: function(y) {
                      y.preventDefault();
                    }
                  }
                }, p([this.hideHeader ? "" : this.genHead()], h(this.genWeeks()), !1));
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCalendar/index.ts ***!
            \*******************************************/
          /*! exports provided: VCalendar, VCalendarCategory, VCalendarDaily, VCalendarWeekly, VCalendarMonthly, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCalendar */
              "./src/components/VCalendar/VCalendar.ts"
            );
            i.d(r, "VCalendar", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            );
            i.d(r, "VCalendarDaily", function() {
              return o.default;
            });
            var l = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            );
            i.d(r, "VCalendarWeekly", function() {
              return l.default;
            });
            var f = i(
              /*! ./VCalendarMonthly */
              "./src/components/VCalendar/VCalendarMonthly.ts"
            );
            i.d(r, "VCalendarMonthly", function() {
              return f.default;
            });
            var d = i(
              /*! ./VCalendarCategory */
              "./src/components/VCalendar/VCalendarCategory.ts"
            );
            i.d(r, "VCalendarCategory", function() {
              return d.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCalendar: a.default,
                VCalendarCategory: d.default,
                VCalendarDaily: o.default,
                VCalendarWeekly: l.default,
                VCalendarMonthly: f.default
              }
            };
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-base.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-base.ts ***!
            \**********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), f = i(
              /*! ../../../mixins/mouse */
              "./src/mixins/mouse/index.ts"
            ), d = i(
              /*! ../../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ./times */
              "./src/components/VCalendar/mixins/times.ts"
            ), c = i(
              /*! ../../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), p = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = Object(a.default)(
              o.default,
              l.default,
              f.default,
              d.default,
              u.default
              /* @vue/component */
            ).extend({
              name: "calendar-base",
              directives: {
                Resize: c.default
              },
              props: h.default.base,
              computed: {
                parsedWeekdays: function() {
                  return Array.isArray(this.weekdays) ? this.weekdays : (this.weekdays || "").split(",").map(function(m) {
                    return parseInt(m, 10);
                  });
                },
                weekdaySkips: function() {
                  return Object(p.getWeekdaySkips)(this.parsedWeekdays);
                },
                weekdaySkipsReverse: function() {
                  var m = this.weekdaySkips.slice();
                  return m.reverse(), m;
                },
                parsedStart: function() {
                  return Object(p.parseTimestamp)(this.start, !0);
                },
                parsedEnd: function() {
                  var m = this.parsedStart, v = this.end && Object(p.parseTimestamp)(this.end) || m;
                  return Object(p.getTimestampIdentifier)(v) < Object(p.getTimestampIdentifier)(m) ? m : v;
                },
                days: function() {
                  return Object(p.createDayList)(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips);
                },
                dayFormatter: function() {
                  if (this.dayFormat)
                    return this.dayFormat;
                  var m = {
                    timeZone: "UTC",
                    day: "numeric"
                  };
                  return Object(p.createNativeLocaleFormatter)(this.currentLocale, function(v, y) {
                    return m;
                  });
                },
                weekdayFormatter: function() {
                  if (this.weekdayFormat)
                    return this.weekdayFormat;
                  var m = {
                    timeZone: "UTC",
                    weekday: "long"
                  }, v = {
                    timeZone: "UTC",
                    weekday: "short"
                  };
                  return Object(p.createNativeLocaleFormatter)(this.currentLocale, function(y, E) {
                    return E ? v : m;
                  });
                }
              },
              methods: {
                getRelativeClasses: function(m, v) {
                  return v === void 0 && (v = !1), {
                    "v-present": m.present,
                    "v-past": m.past,
                    "v-future": m.future,
                    "v-outside": v
                  };
                },
                getStartOfWeek: function(m) {
                  return Object(p.getStartOfWeek)(m, this.parsedWeekdays, this.times.today);
                },
                getEndOfWeek: function(m) {
                  return Object(p.getEndOfWeek)(m, this.parsedWeekdays, this.times.today);
                },
                getFormatter: function(m) {
                  return Object(p.createNativeLocaleFormatter)(this.locale, function(v, y) {
                    return m;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-events.sass": (
          /*!*******************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-events.sass ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-events.ts": (
          /*!*****************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-events.ts ***!
            \*****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./calendar-with-events.sass */
              "./src/components/VCalendar/mixins/calendar-with-events.sass"
            );
            var a = i(
              /*! ../../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! ./calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), l = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), f = i(
              /*! ../modes */
              "./src/components/VCalendar/modes/index.ts"
            ), d = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), u = i(
              /*! ../util/events */
              "./src/components/VCalendar/util/events.ts"
            );
            function c(v) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(E) {
                return typeof E;
              } : c = function(E) {
                return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
              }, c(v);
            }
            var h = function() {
              return h = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, h.apply(this, arguments);
            }, p = 100, g = 95, m = 1440;
            r.default = o.default.extend({
              name: "calendar-with-events",
              directives: {
                ripple: a.default
              },
              props: h(h(h({}, l.default.events), l.default.calendar), l.default.category),
              computed: {
                noEvents: function() {
                  return this.events.length === 0;
                },
                parsedEvents: function() {
                  return this.events.map(this.parseEvent);
                },
                parsedEventOverlapThreshold: function() {
                  return parseInt(this.eventOverlapThreshold);
                },
                eventTimedFunction: function() {
                  var y = this;
                  return typeof this.eventTimed == "function" ? this.eventTimed : function(E) {
                    return !!E[y.eventTimed];
                  };
                },
                eventCategoryFunction: function() {
                  var y = this;
                  return typeof this.eventCategory == "function" ? this.eventCategory : function(E) {
                    return E[y.eventCategory];
                  };
                },
                eventTextColorFunction: function() {
                  var y = this;
                  return typeof this.eventTextColor == "function" ? this.eventTextColor : function() {
                    return y.eventTextColor;
                  };
                },
                eventNameFunction: function() {
                  var y = this;
                  return typeof this.eventName == "function" ? this.eventName : function(E, C) {
                    return E.input[y.eventName] || "";
                  };
                },
                eventModeFunction: function() {
                  return typeof this.eventOverlapMode == "function" ? this.eventOverlapMode : f.CalendarEventOverlapModes[this.eventOverlapMode];
                },
                eventWeekdays: function() {
                  return this.parsedWeekdays;
                },
                categoryMode: function() {
                  return this.type === "category";
                }
              },
              methods: {
                eventColorFunction: function(y) {
                  return typeof this.eventColor == "function" ? this.eventColor(y) : y.color || this.eventColor;
                },
                parseEvent: function(y, E) {
                  return E === void 0 && (E = 0), Object(u.parseEvent)(y, E, this.eventStart, this.eventEnd, this.eventTimedFunction(y), this.categoryMode ? this.eventCategoryFunction(y) : !1);
                },
                formatTime: function(y, E) {
                  var C = this.getFormatter({
                    timeZone: "UTC",
                    hour: "numeric",
                    minute: y.minute > 0 ? "numeric" : void 0
                  });
                  return C(y, !0);
                },
                updateEventVisibility: function() {
                  if (!(this.noEvents || !this.eventMore)) {
                    var y = this.eventHeight, E = this.getEventsMap();
                    for (var C in E) {
                      var x = E[C], b = x.parent, P = x.events, T = x.more;
                      if (!T)
                        break;
                      for (var O = b.getBoundingClientRect(), S = P.length - 1, L = P.map(function(B) {
                        return {
                          event: B,
                          bottom: B.getBoundingClientRect().bottom
                        };
                      }).sort(function(B, j) {
                        return B.bottom - j.bottom;
                      }), A = 0, D = 0; D <= S; D++) {
                        var _ = L[D].bottom, w = D === S ? _ > O.bottom : _ + y > O.bottom;
                        w && (L[D].event.style.display = "none", A++);
                      }
                      A ? (T.style.display = "", T.innerHTML = this.$vuetify.lang.t(this.eventMoreText, A)) : T.style.display = "none";
                    }
                  }
                },
                getEventsMap: function() {
                  var y = {}, E = this.$refs.events;
                  return !E || !E.forEach || E.forEach(function(C) {
                    var x = C.getAttribute("data-date");
                    C.parentElement && x && (x in y || (y[x] = {
                      parent: C.parentElement,
                      more: null,
                      events: []
                    }), C.getAttribute("data-more") ? y[x].more = C : (y[x].events.push(C), C.style.display = ""));
                  }), y;
                },
                genDayEvent: function(y, E) {
                  var C = y.event, x = this.eventHeight, b = this.eventMarginBottom, P = Object(d.getDayIdentifier)(E), T = E.week, O = P === C.startIdentifier, S = P === C.endIdentifier, L = g;
                  if (!this.categoryMode)
                    for (var A = E.index + 1; A < T.length; A++) {
                      var D = Object(d.getDayIdentifier)(T[A]);
                      if (C.endIdentifier >= D)
                        L += p, S = S || D === C.endIdentifier;
                      else {
                        S = !0;
                        break;
                      }
                    }
                  var _ = {
                    eventParsed: C,
                    day: E,
                    start: O,
                    end: S,
                    timed: !1
                  };
                  return this.genEvent(C, _, !1, {
                    staticClass: "v-event",
                    class: {
                      "v-event-start": O,
                      "v-event-end": S
                    },
                    style: {
                      height: x + "px",
                      width: L + "%",
                      "margin-bottom": b + "px"
                    },
                    attrs: {
                      "data-date": E.date
                    },
                    key: C.index,
                    ref: "events",
                    refInFor: !0
                  });
                },
                genTimedEvent: function(y, E) {
                  var C = y.event, x = y.left, b = y.width;
                  if (E.timeDelta(C.end) < 0 || E.timeDelta(C.start) >= 1 || Object(u.isEventHiddenOn)(C, E))
                    return !1;
                  var P = Object(d.getDayIdentifier)(E), T = C.startIdentifier >= P, O = C.endIdentifier > P, S = T ? E.timeToY(C.start) : 0, L = O ? E.timeToY(m) : E.timeToY(C.end), A = Math.max(this.eventHeight, L - S), D = {
                    eventParsed: C,
                    day: E,
                    start: T,
                    end: O,
                    timed: !0
                  };
                  return this.genEvent(C, D, !0, {
                    staticClass: "v-event-timed",
                    style: {
                      top: S + "px",
                      height: A + "px",
                      left: x + "%",
                      width: b + "%"
                    }
                  });
                },
                genEvent: function(y, E, C, x) {
                  var b = this, P, T = this.$scopedSlots.event, O = this.eventTextColorFunction(y.input), S = this.eventColorFunction(y.input), L = y.start.hour < 12 && y.end.hour >= 12, A = Object(d.diffMinutes)(y.start, y.end) <= this.parsedEventOverlapThreshold, D = this.formatTime, _ = function() {
                    return D(y.start, L) + " - " + D(y.end, !0);
                  }, w = function() {
                    var k = b.eventNameFunction(y, C);
                    if (y.start.hasTime)
                      if (C) {
                        var X = _(), rt = A ? ", " : b.$createElement("br");
                        return b.$createElement("span", {
                          staticClass: "v-event-summary"
                        }, [b.$createElement("strong", [k]), rt, X]);
                      } else {
                        var X = D(y.start, !0);
                        return b.$createElement("span", {
                          staticClass: "v-event-summary"
                        }, [b.$createElement("strong", [X]), " ", k]);
                      }
                    return b.$createElement("span", {
                      staticClass: "v-event-summary"
                    }, [k]);
                  }, B = h(h({}, E), {
                    event: y.input,
                    outside: E.day.outside,
                    singline: A,
                    overlapsNoon: L,
                    formatTime: D,
                    timeSummary: _,
                    eventSummary: w
                  });
                  return this.$createElement("div", this.setTextColor(O, this.setBackgroundColor(S, h({
                    on: this.getDefaultMouseEventHandlers(":event", function(j) {
                      return h(h({}, B), {
                        nativeEvent: j
                      });
                    }),
                    directives: [{
                      name: "ripple",
                      value: (P = this.eventRipple) !== null && P !== void 0 ? P : !0
                    }]
                  }, x))), T ? T(B) : [this.genName(w)]);
                },
                genName: function(y) {
                  return this.$createElement("div", {
                    staticClass: "pl-1"
                  }, [y()]);
                },
                genPlaceholder: function(y) {
                  var E = this.eventHeight + this.eventMarginBottom;
                  return this.$createElement("div", {
                    style: {
                      height: E + "px"
                    },
                    attrs: {
                      "data-date": y.date
                    },
                    ref: "events",
                    refInFor: !0
                  });
                },
                genMore: function(y) {
                  var E, C = this.eventHeight, x = this.eventMarginBottom;
                  return this.$createElement("div", {
                    staticClass: "v-event-more pl-1",
                    class: {
                      "v-outside": y.outside
                    },
                    attrs: {
                      "data-date": y.date,
                      "data-more": 1
                    },
                    directives: [{
                      name: "ripple",
                      value: (E = this.eventRipple) !== null && E !== void 0 ? E : !0
                    }],
                    on: this.getDefaultMouseEventHandlers(":more", function(b) {
                      return h({
                        nativeEvent: b
                      }, y);
                    }),
                    style: {
                      display: "none",
                      height: C + "px",
                      "margin-bottom": x + "px"
                    },
                    ref: "events",
                    refInFor: !0
                  });
                },
                getVisibleEvents: function() {
                  var y = Object(d.getDayIdentifier)(this.days[0]), E = Object(d.getDayIdentifier)(this.days[this.days.length - 1]);
                  return this.parsedEvents.filter(function(C) {
                    return Object(u.isEventOverlapping)(C, y, E);
                  });
                },
                isEventForCategory: function(y, E) {
                  return !this.categoryMode || c(E) === "object" && E.categoryName && E.categoryName === y.category || typeof y.category == "string" && E === y.category || typeof y.category != "string" && E === null;
                },
                getEventsForDay: function(y) {
                  var E = Object(d.getDayIdentifier)(y), C = this.eventWeekdays[0];
                  return this.parsedEvents.filter(function(x) {
                    return Object(u.isEventStart)(x, y, E, C);
                  });
                },
                getEventsForDayAll: function(y) {
                  var E = this, C = Object(d.getDayIdentifier)(y), x = this.eventWeekdays[0];
                  return this.parsedEvents.filter(function(b) {
                    return b.allDay && (E.categoryMode ? Object(u.isEventOn)(b, C) : Object(u.isEventStart)(b, y, C, x)) && E.isEventForCategory(b, y.category);
                  });
                },
                getEventsForDayTimed: function(y) {
                  var E = this, C = Object(d.getDayIdentifier)(y);
                  return this.parsedEvents.filter(function(x) {
                    return !x.allDay && Object(u.isEventOn)(x, C) && E.isEventForCategory(x, y.category);
                  });
                },
                getScopedSlots: function() {
                  var y = this;
                  if (this.noEvents)
                    return h({}, this.$scopedSlots);
                  var E = this.eventModeFunction(this.parsedEvents, this.eventWeekdays[0], this.parsedEventOverlapThreshold), C = function(L) {
                    return !!L;
                  }, x = function(L, A, D, _) {
                    var w = A(L), B = E(L, w, _, y.categoryMode);
                    if (_)
                      return B.map(function(k) {
                        return D(k, L);
                      }).filter(C);
                    var j = [];
                    return B.forEach(function(k, X) {
                      for (; j.length < k.column; )
                        j.push(y.genPlaceholder(L));
                      var rt = D(k, L);
                      rt && j.push(rt);
                    }), j;
                  }, b = this.$scopedSlots, P = b.day, T = b["day-header"], O = b["day-body"];
                  return h(h({}, b), {
                    day: function(L) {
                      var A = x(L, y.getEventsForDay, y.genDayEvent, !1);
                      if (A && A.length > 0 && y.eventMore && A.push(y.genMore(L)), P) {
                        var D = P(L);
                        D && (A = A ? A.concat(D) : D);
                      }
                      return A;
                    },
                    "day-header": function(L) {
                      var A = x(L, y.getEventsForDayAll, y.genDayEvent, !1);
                      if (T) {
                        var D = T(L);
                        D && (A = A ? A.concat(D) : D);
                      }
                      return A;
                    },
                    "day-body": function(L) {
                      var A = x(L, y.getEventsForDayTimed, y.genTimedEvent, !0), D = [y.$createElement("div", {
                        staticClass: "v-event-timed-container"
                      }, A)];
                      if (O) {
                        var _ = O(L);
                        _ && (D = D.concat(_));
                      }
                      return D;
                    }
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-intervals.ts": (
          /*!********************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-intervals.ts ***!
            \********************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), o = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), l = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = a.default.extend({
              name: "calendar-with-intervals",
              props: o.default.intervals,
              computed: {
                parsedFirstInterval: function() {
                  return parseInt(this.firstInterval);
                },
                parsedIntervalMinutes: function() {
                  return parseInt(this.intervalMinutes);
                },
                parsedIntervalCount: function() {
                  return parseInt(this.intervalCount);
                },
                parsedIntervalHeight: function() {
                  return parseFloat(this.intervalHeight);
                },
                parsedFirstTime: function() {
                  return Object(l.parseTime)(this.firstTime);
                },
                firstMinute: function() {
                  var d = this.parsedFirstTime;
                  return d !== !1 && d >= 0 && d <= l.MINUTES_IN_DAY ? d : this.parsedFirstInterval * this.parsedIntervalMinutes;
                },
                bodyHeight: function() {
                  return this.parsedIntervalCount * this.parsedIntervalHeight;
                },
                days: function() {
                  return Object(l.createDayList)(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips, this.maxDays);
                },
                intervals: function() {
                  var d = this.days, u = this.firstMinute, c = this.parsedIntervalMinutes, h = this.parsedIntervalCount, p = this.times.now;
                  return d.map(function(g) {
                    return Object(l.createIntervalList)(g, u, c, h, p);
                  });
                },
                intervalFormatter: function() {
                  if (this.intervalFormat)
                    return this.intervalFormat;
                  var d = {
                    timeZone: "UTC",
                    hour: "2-digit",
                    minute: "2-digit"
                  }, u = {
                    timeZone: "UTC",
                    hour: "numeric",
                    minute: "2-digit"
                  }, c = {
                    timeZone: "UTC",
                    hour: "numeric"
                  };
                  return Object(l.createNativeLocaleFormatter)(this.currentLocale, function(h, p) {
                    return p ? h.minute === 0 ? c : u : d;
                  });
                }
              },
              methods: {
                showIntervalLabelDefault: function(d) {
                  var u = this.intervals[0][0], c = u.hour === d.hour && u.minute === d.minute;
                  return !c;
                },
                intervalStyleDefault: function(d) {
                },
                getTimestampAtEvent: function(d, u) {
                  var c = Object(l.copyTimestamp)(u), h = d.currentTarget.getBoundingClientRect(), p = this.firstMinute, g = d, m = d, v = g.changedTouches || g.touches, y = v && v[0] ? v[0].clientY : m.clientY, E = (y - h.top) / this.parsedIntervalHeight, C = Math.floor(E * this.parsedIntervalMinutes), x = p + C;
                  return Object(l.updateMinutes)(c, x, this.times.now);
                },
                getSlotScope: function(d) {
                  var u = Object(l.copyTimestamp)(d);
                  return u.timeToY = this.timeToY, u.timeDelta = this.timeDelta, u.minutesToPixels = this.minutesToPixels, u.week = this.days, u;
                },
                scrollToTime: function(d) {
                  var u = this.timeToY(d), c = this.$refs.scrollArea;
                  return u === !1 || !c ? !1 : (c.scrollTop = u, !0);
                },
                minutesToPixels: function(d) {
                  return d / this.parsedIntervalMinutes * this.parsedIntervalHeight;
                },
                timeToY: function(d, u) {
                  u === void 0 && (u = !0);
                  var c = this.timeDelta(d);
                  return c !== !1 && (c *= this.bodyHeight, u && (c < 0 && (c = 0), c > this.bodyHeight && (c = this.bodyHeight))), c;
                },
                timeDelta: function(d) {
                  var u = Object(l.parseTime)(d);
                  if (u === !1)
                    return !1;
                  var c = this.firstMinute, h = this.parsedIntervalCount * this.parsedIntervalMinutes;
                  return (u - c) / h;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/times.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/mixins/times.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = o.a.extend({
              name: "times",
              props: {
                now: {
                  type: String,
                  validator: l.validateTimestamp
                }
              },
              data: function() {
                return {
                  times: {
                    now: Object(l.parseTimestamp)("0000-00-00 00:00", !0),
                    today: Object(l.parseTimestamp)("0000-00-00", !0)
                  }
                };
              },
              computed: {
                parsedNow: function() {
                  return this.now ? Object(l.parseTimestamp)(this.now, !0) : null;
                }
              },
              watch: {
                parsedNow: "updateTimes"
              },
              created: function() {
                this.updateTimes(), this.setPresent();
              },
              methods: {
                setPresent: function() {
                  this.times.now.present = this.times.today.present = !0, this.times.now.past = this.times.today.past = !1, this.times.now.future = this.times.today.future = !1;
                },
                updateTimes: function() {
                  var d = this.parsedNow || this.getNow();
                  this.updateDay(d, this.times.now), this.updateTime(d, this.times.now), this.updateDay(d, this.times.today);
                },
                getNow: function() {
                  return Object(l.parseDate)(/* @__PURE__ */ new Date());
                },
                updateDay: function(d, u) {
                  d.date !== u.date && (u.year = d.year, u.month = d.month, u.day = d.day, u.weekday = d.weekday, u.date = d.date);
                },
                updateTime: function(d, u) {
                  d.time !== u.time && (u.hour = d.hour, u.minute = d.minute, u.time = d.time);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/modes/column.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/modes/column.ts ***!
            \**************************************************/
          /*! exports provided: column */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "column", function() {
              return l;
            });
            var a = i(
              /*! ./common */
              "./src/components/VCalendar/modes/common.ts"
            ), o = 100, l = function(d, u, c) {
              var h = Object(a.getOverlapGroupHandler)(u);
              return function(p, g, m, v) {
                var y = h.getVisuals(p, g, m, v);
                return m && y.forEach(function(E) {
                  E.left = E.column * o / E.columnCount, E.width = o / E.columnCount;
                }), y;
              };
            };
          }
        ),
        /***/
        "./src/components/VCalendar/modes/common.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/modes/common.ts ***!
            \**************************************************/
          /*! exports provided: getVisuals, hasOverlap, setColumnCount, getRange, getDayRange, getNormalizedRange, getOpenGroup, getOverlapGroupHandler */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "getVisuals", function() {
              return f;
            }), i.d(r, "hasOverlap", function() {
              return d;
            }), i.d(r, "setColumnCount", function() {
              return u;
            }), i.d(r, "getRange", function() {
              return c;
            }), i.d(r, "getDayRange", function() {
              return h;
            }), i.d(r, "getNormalizedRange", function() {
              return p;
            }), i.d(r, "getOpenGroup", function() {
              return g;
            }), i.d(r, "getOverlapGroupHandler", function() {
              return m;
            });
            var a = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), o = function(v, y) {
              var E = typeof Symbol == "function" && v[Symbol.iterator];
              if (!E)
                return v;
              var C = E.call(v), x, b = [], P;
              try {
                for (; (y === void 0 || y-- > 0) && !(x = C.next()).done; )
                  b.push(x.value);
              } catch (T) {
                P = {
                  error: T
                };
              } finally {
                try {
                  x && !x.done && (E = C.return) && E.call(C);
                } finally {
                  if (P)
                    throw P.error;
                }
              }
              return b;
            }, l = 864e5;
            function f(v, y) {
              y === void 0 && (y = 0);
              var E = v.map(function(C) {
                return {
                  event: C,
                  columnCount: 0,
                  column: 0,
                  left: 0,
                  width: 100
                };
              });
              return E.sort(function(C, x) {
                return Math.max(y, C.event.startTimestampIdentifier) - Math.max(y, x.event.startTimestampIdentifier) || x.event.endTimestampIdentifier - C.event.endTimestampIdentifier;
              }), E;
            }
            function d(v, y, E, C, x) {
              return x === void 0 && (x = !0), x ? !(v >= C || y <= E) : !(v > C || y < E);
            }
            function u(v) {
              v.forEach(function(y) {
                y.visuals.forEach(function(E) {
                  E.columnCount = v.length;
                });
              });
            }
            function c(v) {
              return [v.startTimestampIdentifier, v.endTimestampIdentifier];
            }
            function h(v) {
              return [v.startIdentifier, v.endIdentifier];
            }
            function p(v, y) {
              return [Math.max(y, v.startTimestampIdentifier), Math.min(y + l, v.endTimestampIdentifier)];
            }
            function g(v, y, E, C) {
              for (var x = 0; x < v.length; x++) {
                var b = v[x], P = !1;
                if (d(y, E, b.start, b.end, C))
                  for (var T = 0; T < b.visuals.length; T++) {
                    var O = b.visuals[T], S = o(C ? c(O.event) : h(O.event), 2), L = S[0], A = S[1];
                    if (d(y, E, L, A, C)) {
                      P = !0;
                      break;
                    }
                  }
                if (!P)
                  return x;
              }
              return -1;
            }
            function m(v) {
              var y = {
                groups: [],
                min: -1,
                max: -1,
                reset: function() {
                  y.groups = [], y.min = y.max = -1;
                },
                getVisuals: function(C, x, b, P) {
                  P === void 0 && (P = !1), (C.weekday === v || P) && y.reset();
                  var T = Object(a.getTimestampIdentifier)(C), O = f(x, T);
                  return O.forEach(function(S) {
                    var L = o(b ? c(S.event) : h(S.event), 2), A = L[0], D = L[1];
                    y.groups.length > 0 && !d(A, D, y.min, y.max, b) && (u(y.groups), y.reset());
                    var _ = g(y.groups, A, D, b);
                    _ === -1 && (_ = y.groups.length, y.groups.push({
                      start: A,
                      end: D,
                      visuals: []
                    }));
                    var w = y.groups[_];
                    w.visuals.push(S), w.start = Math.min(w.start, A), w.end = Math.max(w.end, D), S.column = _, y.min === -1 ? (y.min = A, y.max = D) : (y.min = Math.min(y.min, A), y.max = Math.max(y.max, D));
                  }), u(y.groups), b && y.reset(), O;
                }
              };
              return y;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/modes/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/modes/index.ts ***!
            \*************************************************/
          /*! exports provided: CalendarEventOverlapModes */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "CalendarEventOverlapModes", function() {
              return l;
            });
            var a = i(
              /*! ./stack */
              "./src/components/VCalendar/modes/stack.ts"
            ), o = i(
              /*! ./column */
              "./src/components/VCalendar/modes/column.ts"
            ), l = {
              stack: a.stack,
              column: o.column
            };
          }
        ),
        /***/
        "./src/components/VCalendar/modes/stack.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/modes/stack.ts ***!
            \*************************************************/
          /*! exports provided: stack */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "stack", function() {
              return h;
            });
            var a = i(
              /*! ./common */
              "./src/components/VCalendar/modes/common.ts"
            ), o = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), l = function(O) {
              var S = typeof Symbol == "function" && Symbol.iterator, L = S && O[S], A = 0;
              if (L)
                return L.call(O);
              if (O && typeof O.length == "number")
                return {
                  next: function() {
                    return O && A >= O.length && (O = void 0), {
                      value: O && O[A++],
                      done: !O
                    };
                  }
                };
              throw new TypeError(S ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, f = function(O, S) {
              var L = typeof Symbol == "function" && O[Symbol.iterator];
              if (!L)
                return O;
              var A = L.call(O), D, _ = [], w;
              try {
                for (; (S === void 0 || S-- > 0) && !(D = A.next()).done; )
                  _.push(D.value);
              } catch (B) {
                w = {
                  error: B
                };
              } finally {
                try {
                  D && !D.done && (L = A.return) && L.call(A);
                } finally {
                  if (w)
                    throw w.error;
                }
              }
              return _;
            }, d = 100, u = 5, c = 1.7, h = function(S, L, A) {
              var D = Object(a.getOverlapGroupHandler)(L);
              return function(_, w, B, j) {
                var k, X, rt, et, Z, dt;
                if (!B)
                  return D.getVisuals(_, w, B, j);
                var vt = Object(o.getTimestampIdentifier)(_), bt = Object(a.getVisuals)(w, vt), it = x(bt, vt);
                try {
                  for (var R = l(it), V = R.next(); !V.done; V = R.next()) {
                    var tt = V.value, Y = [];
                    try {
                      for (var $ = (rt = void 0, l(tt.visuals)), z = $.next(); !z.done; z = $.next()) {
                        var at = z.value, ct = b(at, vt), St = v(ct, Y);
                        if (St === !1) {
                          var F = E(ct, Y);
                          F && (ct.parent = F, ct.sibling = Object(a.hasOverlap)(ct.start, ct.end, F.start, T(F.start, A)), ct.index = F.index + 1, F.children.push(ct));
                        } else {
                          var M = f(y(ct, Y, St - 1, St - 1), 1), F = M[0], I = y(ct, Y, St + 1, St + Y.length, !0);
                          ct.children = I, ct.index = St, F && (ct.parent = F, ct.sibling = Object(a.hasOverlap)(ct.start, ct.end, F.start, T(F.start, A)), F.children.push(ct));
                          try {
                            for (var N = (Z = void 0, l(I)), G = N.next(); !G.done; G = N.next()) {
                              var nt = G.value;
                              nt.parent === F && (nt.parent = ct);
                              var lt = nt.index - ct.index <= 1;
                              lt && ct.sibling && Object(a.hasOverlap)(ct.start, T(ct.start, A), nt.start, nt.end) && (nt.sibling = !0);
                            }
                          } catch (Lt) {
                            Z = {
                              error: Lt
                            };
                          } finally {
                            try {
                              G && !G.done && (dt = N.return) && dt.call(N);
                            } finally {
                              if (Z)
                                throw Z.error;
                            }
                          }
                        }
                        Y.push(ct);
                      }
                    } catch (yt) {
                      rt = {
                        error: yt
                      };
                    } finally {
                      try {
                        z && !z.done && (et = $.return) && et.call($);
                      } finally {
                        if (rt)
                          throw rt.error;
                      }
                    }
                    p(Y, A);
                  }
                } catch (yt) {
                  k = {
                    error: yt
                  };
                } finally {
                  try {
                    V && !V.done && (X = R.return) && X.call(R);
                  } finally {
                    if (k)
                      throw k.error;
                  }
                }
                return bt.sort(function(yt, Lt) {
                  return yt.left - Lt.left || yt.event.startTimestampIdentifier - Lt.event.startTimestampIdentifier;
                }), bt;
              };
            };
            function p(O, S) {
              var L, A;
              try {
                for (var D = l(O), _ = D.next(); !_.done; _ = D.next()) {
                  var w = _.value, B = w.visual, j = w.parent, k = P(w) + 1, X = j ? j.visual.left : 0, rt = d - X, et = Math.min(u, d / k), Z = g(w, O), dt = rt / (k - w.index + 1), vt = rt / (k - w.index + (w.sibling ? 1 : 0)) * Z;
                  j && (B.left = w.sibling ? X + dt : X + et), B.width = C(w, O, S) ? d - B.left : Math.min(d - B.left, vt * c);
                }
              } catch (bt) {
                L = {
                  error: bt
                };
              } finally {
                try {
                  _ && !_.done && (A = D.return) && A.call(D);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
            }
            function g(O, S) {
              if (!O.children.length)
                return 1;
              var L = O.index + S.length, A = O.children.reduce(function(D, _) {
                return Math.min(D, _.index);
              }, L);
              return A - O.index;
            }
            function m(O, S) {
              var L, A, D = [];
              try {
                for (var _ = l(S), w = _.next(); !w.done; w = _.next()) {
                  var B = w.value;
                  Object(a.hasOverlap)(O.start, O.end, B.start, B.end) && D.push(B.index);
                }
              } catch (j) {
                L = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (A = _.return) && A.call(_);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return D;
            }
            function v(O, S) {
              var L = m(O, S);
              L.sort();
              for (var A = 0; A < L.length; A++)
                if (A < L[A])
                  return A;
              return !1;
            }
            function y(O, S, L, A, D) {
              var _, w;
              D === void 0 && (D = !1);
              var B = [];
              try {
                for (var j = l(S), k = j.next(); !k.done; k = j.next()) {
                  var X = k.value;
                  X.index >= L && X.index <= A && Object(a.hasOverlap)(O.start, O.end, X.start, X.end) && B.push(X);
                }
              } catch (et) {
                _ = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (w = j.return) && w.call(j);
                } finally {
                  if (_)
                    throw _.error;
                }
              }
              if (D && B.length > 0) {
                var rt = B.reduce(function(et, Z) {
                  return Math.min(et, Z.index);
                }, B[0].index);
                return B.filter(function(et) {
                  return et.index === rt;
                });
              }
              return B;
            }
            function E(O, S) {
              var L, A, D = null;
              try {
                for (var _ = l(S), w = _.next(); !w.done; w = _.next()) {
                  var B = w.value;
                  Object(a.hasOverlap)(O.start, O.end, B.start, B.end) && (D === null || B.index > D.index) && (D = B);
                }
              } catch (j) {
                L = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (A = _.return) && A.call(_);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return D;
            }
            function C(O, S, L) {
              var A, D;
              try {
                for (var _ = l(S), w = _.next(); !w.done; w = _.next()) {
                  var B = w.value;
                  if (B !== O && B.index > O.index && Object(a.hasOverlap)(O.start, T(O.start, L), B.start, B.end))
                    return !1;
                }
              } catch (j) {
                A = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (D = _.return) && D.call(_);
                } finally {
                  if (A)
                    throw A.error;
                }
              }
              return !0;
            }
            function x(O, S) {
              var L, A, D, _, w = [];
              try {
                for (var B = l(O), j = B.next(); !j.done; j = B.next()) {
                  var k = j.value, X = f(Object(a.getNormalizedRange)(k.event, S), 2), rt = X[0], et = X[1], Z = !1;
                  try {
                    for (var dt = (D = void 0, l(w)), vt = dt.next(); !vt.done; vt = dt.next()) {
                      var bt = vt.value;
                      if (Object(a.hasOverlap)(rt, et, bt.start, bt.end)) {
                        bt.visuals.push(k), bt.end = Math.max(bt.end, et), Z = !0;
                        break;
                      }
                    }
                  } catch (it) {
                    D = {
                      error: it
                    };
                  } finally {
                    try {
                      vt && !vt.done && (_ = dt.return) && _.call(dt);
                    } finally {
                      if (D)
                        throw D.error;
                    }
                  }
                  Z || w.push({
                    start: rt,
                    end: et,
                    visuals: [k]
                  });
                }
              } catch (it) {
                L = {
                  error: it
                };
              } finally {
                try {
                  j && !j.done && (A = B.return) && A.call(B);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return w;
            }
            function b(O, S) {
              var L = f(Object(a.getNormalizedRange)(O.event, S), 2), A = L[0], D = L[1];
              return {
                parent: null,
                sibling: !0,
                index: 0,
                visual: O,
                start: A,
                end: D,
                children: []
              };
            }
            function P(O) {
              var S, L, A = O.index;
              try {
                for (var D = l(O.children), _ = D.next(); !_.done; _ = D.next()) {
                  var w = _.value, B = P(w);
                  B > A && (A = B);
                }
              } catch (j) {
                S = {
                  error: j
                };
              } finally {
                try {
                  _ && !_.done && (L = D.return) && L.call(D);
                } finally {
                  if (S)
                    throw S.error;
                }
              }
              return A;
            }
            function T(O, S) {
              var L = O % 100, A = L + S, D = Math.floor(A / 60), _ = A % 60;
              return O - L + D * 100 + _;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/events.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/util/events.ts ***!
            \*************************************************/
          /*! exports provided: parseEvent, isEventOn, isEventHiddenOn, isEventStart, isEventOverlapping */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parseEvent", function() {
              return o;
            }), i.d(r, "isEventOn", function() {
              return l;
            }), i.d(r, "isEventHiddenOn", function() {
              return f;
            }), i.d(r, "isEventStart", function() {
              return d;
            }), i.d(r, "isEventOverlapping", function() {
              return u;
            });
            var a = i(
              /*! ./timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            function o(c, h, p, g, m, v) {
              m === void 0 && (m = !1), v === void 0 && (v = !1);
              var y = c[p], E = c[g], C = Object(a.parseTimestamp)(y, !0), x = E ? Object(a.parseTimestamp)(E, !0) : C, b = Object(a.isTimedless)(y) ? Object(a.updateHasTime)(C, m) : C, P = Object(a.isTimedless)(E) ? Object(a.updateHasTime)(x, m) : x, T = Object(a.getDayIdentifier)(b), O = Object(a.getTimestampIdentifier)(b), S = Object(a.getDayIdentifier)(P), L = b.hasTime ? 0 : 2359, A = Object(a.getTimestampIdentifier)(P) + L, D = !b.hasTime;
              return {
                input: c,
                start: b,
                startIdentifier: T,
                startTimestampIdentifier: O,
                end: P,
                endIdentifier: S,
                endTimestampIdentifier: A,
                allDay: D,
                index: h,
                category: v
              };
            }
            function l(c, h) {
              return h >= c.startIdentifier && h <= c.endIdentifier;
            }
            function f(c, h) {
              return c.end.time === "00:00" && c.end.date === h.date && c.start.date !== h.date;
            }
            function d(c, h, p, g) {
              return p === c.startIdentifier || g === h.weekday && l(c, p);
            }
            function u(c, h, p) {
              return h <= c.endIdentifier && p >= c.startIdentifier;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/parser.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/util/parser.ts ***!
            \*************************************************/
          /*! exports provided: parsedCategoryText, getParsedCategories */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parsedCategoryText", function() {
              return l;
            }), i.d(r, "getParsedCategories", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            var o = function() {
              return o = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, o.apply(this, arguments);
            };
            function l(d, u) {
              return typeof u == "string" && a(d) === "object" && d ? d[u] : typeof u == "function" ? u(d) : d;
            }
            function f(d, u) {
              return typeof d == "string" ? d.split(/\s*,\s/) : Array.isArray(d) ? d.map(function(c) {
                if (typeof c == "string")
                  return c;
                var h = typeof c.categoryName == "string" ? c.categoryName : l(c, u);
                return o(o({}, c), {
                  categoryName: h
                });
              }) : [];
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/props.ts": (
          /*!************************************************!*\
            !*** ./src/components/VCalendar/util/props.ts ***!
            \************************************************/
          /*! exports provided: default, validateNumber, validateWeekdays */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "validateNumber", function() {
              return l;
            }), i.d(r, "validateWeekdays", function() {
              return f;
            });
            var a = i(
              /*! ./timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), o = i(
              /*! ../modes */
              "./src/components/VCalendar/modes/index.ts"
            );
            r.default = {
              base: {
                start: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp,
                  default: function() {
                    return Object(a.parseDate)(/* @__PURE__ */ new Date()).date;
                  }
                },
                end: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp
                },
                weekdays: {
                  type: [Array, String],
                  default: function() {
                    return [0, 1, 2, 3, 4, 5, 6];
                  },
                  validate: f
                },
                hideHeader: {
                  type: Boolean
                },
                shortWeekdays: {
                  type: Boolean,
                  default: !0
                },
                weekdayFormat: {
                  type: Function,
                  default: null
                },
                dayFormat: {
                  type: Function,
                  default: null
                }
              },
              intervals: {
                maxDays: {
                  type: Number,
                  default: 7
                },
                shortIntervals: {
                  type: Boolean,
                  default: !0
                },
                intervalHeight: {
                  type: [Number, String],
                  default: 48,
                  validate: l
                },
                intervalWidth: {
                  type: [Number, String],
                  default: 60,
                  validate: l
                },
                intervalMinutes: {
                  type: [Number, String],
                  default: 60,
                  validate: l
                },
                firstInterval: {
                  type: [Number, String],
                  default: 0,
                  validate: l
                },
                firstTime: {
                  type: [Number, String, Object],
                  validate: a.validateTime
                },
                intervalCount: {
                  type: [Number, String],
                  default: 24,
                  validate: l
                },
                intervalFormat: {
                  type: Function,
                  default: null
                },
                intervalStyle: {
                  type: Function,
                  default: null
                },
                showIntervalLabel: {
                  type: Function,
                  default: null
                }
              },
              weeks: {
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                minWeeks: {
                  validate: l,
                  default: 1
                },
                shortMonths: {
                  type: Boolean,
                  default: !0
                },
                showMonthOnFirst: {
                  type: Boolean,
                  default: !0
                },
                showWeek: Boolean,
                monthFormat: {
                  type: Function,
                  default: null
                }
              },
              calendar: {
                type: {
                  type: String,
                  default: "month"
                },
                value: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp
                }
              },
              category: {
                categories: {
                  type: [Array, String],
                  default: ""
                },
                categoryText: {
                  type: [String, Function]
                },
                categoryHideDynamic: {
                  type: Boolean
                },
                categoryShowAll: {
                  type: Boolean
                },
                categoryForInvalid: {
                  type: String,
                  default: ""
                },
                categoryDays: {
                  type: [Number, String],
                  default: 1,
                  validate: function(u) {
                    return isFinite(parseInt(u)) && parseInt(u) > 0;
                  }
                }
              },
              events: {
                events: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                eventStart: {
                  type: String,
                  default: "start"
                },
                eventEnd: {
                  type: String,
                  default: "end"
                },
                eventTimed: {
                  type: [String, Function],
                  default: "timed"
                },
                eventCategory: {
                  type: [String, Function],
                  default: "category"
                },
                eventHeight: {
                  type: Number,
                  default: 20
                },
                eventColor: {
                  type: [String, Function],
                  default: "primary"
                },
                eventTextColor: {
                  type: [String, Function],
                  default: "white"
                },
                eventName: {
                  type: [String, Function],
                  default: "name"
                },
                eventOverlapThreshold: {
                  type: [String, Number],
                  default: 60
                },
                eventOverlapMode: {
                  type: [String, Function],
                  default: "stack",
                  validate: function(u) {
                    return u in o.CalendarEventOverlapModes || typeof u == "function";
                  }
                },
                eventMore: {
                  type: Boolean,
                  default: !0
                },
                eventMoreText: {
                  type: String,
                  default: "$vuetify.calendar.moreEvents"
                },
                eventRipple: {
                  type: [Boolean, Object],
                  default: null
                },
                eventMarginBottom: {
                  type: Number,
                  default: 1
                }
              }
            };
            function l(d) {
              return isFinite(parseInt(d));
            }
            function f(d) {
              if (typeof d == "string" && (d = d.split(",")), Array.isArray(d)) {
                var u = d.map(function(v) {
                  return parseInt(v);
                });
                if (u.length > a.DAYS_IN_WEEK || u.length === 0)
                  return !1;
                for (var c = {}, h = !1, p = 0; p < u.length; p++) {
                  var g = u[p];
                  if (!isFinite(g) || g < 0 || g >= a.DAYS_IN_WEEK)
                    return !1;
                  if (p > 0) {
                    var m = g - u[p - 1];
                    if (m < 0) {
                      if (h)
                        return !1;
                      h = !0;
                    } else if (m === 0)
                      return !1;
                  }
                  if (c[g])
                    return !1;
                  c[g] = !0;
                }
                return !0;
              }
              return !1;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/timestamp.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VCalendar/util/timestamp.ts ***!
            \****************************************************/
          /*! exports provided: PARSE_REGEX, PARSE_TIME, DAYS_IN_MONTH, DAYS_IN_MONTH_LEAP, DAYS_IN_MONTH_MIN, DAYS_IN_MONTH_MAX, MONTH_MAX, MONTH_MIN, DAY_MIN, DAYS_IN_WEEK, MINUTES_IN_HOUR, MINUTE_MAX, MINUTES_IN_DAY, HOURS_IN_DAY, HOUR_MAX, FIRST_HOUR, OFFSET_YEAR, OFFSET_MONTH, OFFSET_HOUR, OFFSET_TIME, getStartOfWeek, getEndOfWeek, getStartOfMonth, getEndOfMonth, validateTime, parseTime, validateTimestamp, parseTimestamp, parseDate, getDayIdentifier, getTimeIdentifier, getTimestampIdentifier, updateRelative, isTimedless, updateHasTime, updateMinutes, updateWeekday, updateFormatted, getWeekday, daysInMonth, copyTimestamp, padNumber, getDate, getTime, nextMinutes, nextDay, prevDay, relativeDays, diffMinutes, findWeekday, getWeekdaySkips, timestampToDate, createDayList, createIntervalList, createNativeLocaleFormatter */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "PARSE_REGEX", function() {
              return l;
            }), i.d(r, "PARSE_TIME", function() {
              return f;
            }), i.d(r, "DAYS_IN_MONTH", function() {
              return d;
            }), i.d(r, "DAYS_IN_MONTH_LEAP", function() {
              return u;
            }), i.d(r, "DAYS_IN_MONTH_MIN", function() {
              return c;
            }), i.d(r, "DAYS_IN_MONTH_MAX", function() {
              return h;
            }), i.d(r, "MONTH_MAX", function() {
              return p;
            }), i.d(r, "MONTH_MIN", function() {
              return g;
            }), i.d(r, "DAY_MIN", function() {
              return m;
            }), i.d(r, "DAYS_IN_WEEK", function() {
              return v;
            }), i.d(r, "MINUTES_IN_HOUR", function() {
              return y;
            }), i.d(r, "MINUTE_MAX", function() {
              return E;
            }), i.d(r, "MINUTES_IN_DAY", function() {
              return C;
            }), i.d(r, "HOURS_IN_DAY", function() {
              return x;
            }), i.d(r, "HOUR_MAX", function() {
              return b;
            }), i.d(r, "FIRST_HOUR", function() {
              return P;
            }), i.d(r, "OFFSET_YEAR", function() {
              return T;
            }), i.d(r, "OFFSET_MONTH", function() {
              return O;
            }), i.d(r, "OFFSET_HOUR", function() {
              return S;
            }), i.d(r, "OFFSET_TIME", function() {
              return L;
            }), i.d(r, "getStartOfWeek", function() {
              return A;
            }), i.d(r, "getEndOfWeek", function() {
              return D;
            }), i.d(r, "getStartOfMonth", function() {
              return _;
            }), i.d(r, "getEndOfMonth", function() {
              return w;
            }), i.d(r, "validateTime", function() {
              return B;
            }), i.d(r, "parseTime", function() {
              return j;
            }), i.d(r, "validateTimestamp", function() {
              return k;
            }), i.d(r, "parseTimestamp", function() {
              return X;
            }), i.d(r, "parseDate", function() {
              return rt;
            }), i.d(r, "getDayIdentifier", function() {
              return et;
            }), i.d(r, "getTimeIdentifier", function() {
              return Z;
            }), i.d(r, "getTimestampIdentifier", function() {
              return dt;
            }), i.d(r, "updateRelative", function() {
              return vt;
            }), i.d(r, "isTimedless", function() {
              return bt;
            }), i.d(r, "updateHasTime", function() {
              return it;
            }), i.d(r, "updateMinutes", function() {
              return R;
            }), i.d(r, "updateWeekday", function() {
              return V;
            }), i.d(r, "updateFormatted", function() {
              return tt;
            }), i.d(r, "getWeekday", function() {
              return Y;
            }), i.d(r, "daysInMonth", function() {
              return $;
            }), i.d(r, "copyTimestamp", function() {
              return z;
            }), i.d(r, "padNumber", function() {
              return at;
            }), i.d(r, "getDate", function() {
              return ct;
            }), i.d(r, "getTime", function() {
              return St;
            }), i.d(r, "nextMinutes", function() {
              return F;
            }), i.d(r, "nextDay", function() {
              return M;
            }), i.d(r, "prevDay", function() {
              return I;
            }), i.d(r, "relativeDays", function() {
              return N;
            }), i.d(r, "diffMinutes", function() {
              return G;
            }), i.d(r, "findWeekday", function() {
              return nt;
            }), i.d(r, "getWeekdaySkips", function() {
              return lt;
            }), i.d(r, "timestampToDate", function() {
              return yt;
            }), i.d(r, "createDayList", function() {
              return Lt;
            }), i.d(r, "createIntervalList", function() {
              return Nt;
            }), i.d(r, "createNativeLocaleFormatter", function() {
              return Jt;
            });
            var a = i(
              /*! ../../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            );
            function o(J) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(Ct) {
                return typeof Ct;
              } : o = function(Ct) {
                return Ct && typeof Symbol == "function" && Ct.constructor === Symbol && Ct !== Symbol.prototype ? "symbol" : typeof Ct;
              }, o(J);
            }
            var l = /^(\d{4})-(\d{1,2})(-(\d{1,2}))?([^\d]+(\d{1,2}))?(:(\d{1,2}))?(:(\d{1,2}))?$/, f = /(\d\d?)(:(\d\d?)|)(:(\d\d?)|)/, d = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], u = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], c = 28, h = 31, p = 12, g = 1, m = 1, v = 7, y = 60, E = 59, C = 24 * 60, x = 24, b = 23, P = 0, T = 1e4, O = 100, S = 100, L = 1e4;
            function A(J, ft, Ct) {
              var Mt = z(J);
              return nt(Mt, ft[0], I), tt(Mt), Ct && vt(Mt, Ct, Mt.hasTime), Mt;
            }
            function D(J, ft, Ct) {
              var Mt = z(J);
              return nt(Mt, ft[ft.length - 1]), tt(Mt), Ct && vt(Mt, Ct, Mt.hasTime), Mt;
            }
            function _(J) {
              var ft = z(J);
              return ft.day = m, V(ft), tt(ft), ft;
            }
            function w(J) {
              var ft = z(J);
              return ft.day = $(ft.year, ft.month), V(ft), tt(ft), ft;
            }
            function B(J) {
              return typeof J == "number" && isFinite(J) || !!f.exec(J) || o(J) === "object" && isFinite(J.hour) && isFinite(J.minute);
            }
            function j(J) {
              if (typeof J == "number")
                return J;
              if (typeof J == "string") {
                var ft = f.exec(J);
                return ft ? parseInt(ft[1]) * 60 + parseInt(ft[3] || 0) : !1;
              } else
                return o(J) === "object" ? typeof J.hour != "number" || typeof J.minute != "number" ? !1 : J.hour * 60 + J.minute : !1;
            }
            function k(J) {
              return typeof J == "number" && isFinite(J) || typeof J == "string" && !!l.exec(J) || J instanceof Date;
            }
            function X(J, ft, Ct) {
              if (ft === void 0 && (ft = !1), typeof J == "number" && isFinite(J) && (J = new Date(J)), J instanceof Date) {
                var Mt = rt(J);
                return Ct && vt(Mt, Ct, Mt.hasTime), Mt;
              }
              if (typeof J != "string") {
                if (ft)
                  throw new Error(J + " is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.");
                return null;
              }
              var Ot = l.exec(J);
              if (!Ot) {
                if (ft)
                  throw new Error(J + " is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.");
                return null;
              }
              var kt = {
                date: J,
                time: "",
                year: parseInt(Ot[1]),
                month: parseInt(Ot[2]),
                day: parseInt(Ot[4]) || 1,
                hour: parseInt(Ot[6]) || 0,
                minute: parseInt(Ot[8]) || 0,
                weekday: 0,
                hasDay: !!Ot[4],
                hasTime: !!(Ot[6] && Ot[8]),
                past: !1,
                present: !1,
                future: !1
              };
              return V(kt), tt(kt), Ct && vt(kt, Ct, kt.hasTime), kt;
            }
            function rt(J) {
              return tt({
                date: "",
                time: "",
                year: J.getFullYear(),
                month: J.getMonth() + 1,
                day: J.getDate(),
                weekday: J.getDay(),
                hour: J.getHours(),
                minute: J.getMinutes(),
                hasDay: !0,
                hasTime: !0,
                past: !1,
                present: !0,
                future: !1
              });
            }
            function et(J) {
              return J.year * T + J.month * O + J.day;
            }
            function Z(J) {
              return J.hour * S + J.minute;
            }
            function dt(J) {
              return et(J) * L + Z(J);
            }
            function vt(J, ft, Ct) {
              Ct === void 0 && (Ct = !1);
              var Mt = et(ft), Ot = et(J), kt = Mt === Ot;
              return J.hasTime && Ct && kt && (Mt = Z(ft), Ot = Z(J), kt = Mt === Ot), J.past = Ot < Mt, J.present = kt, J.future = Ot > Mt, J;
            }
            function bt(J) {
              return J instanceof Date || typeof J == "number" && isFinite(J);
            }
            function it(J, ft, Ct) {
              return J.hasTime !== ft && (J.hasTime = ft, ft || (J.hour = b, J.minute = E, J.time = St(J)), Ct && vt(J, Ct, J.hasTime)), J;
            }
            function R(J, ft, Ct) {
              return J.hasTime = !0, J.hour = Math.floor(ft / y), J.minute = ft % y, J.time = St(J), Ct && vt(J, Ct, !0), J;
            }
            function V(J) {
              return J.weekday = Y(J), J;
            }
            function tt(J) {
              return J.time = St(J), J.date = ct(J), J;
            }
            function Y(J) {
              if (J.hasDay) {
                var ft = Math.floor, Ct = J.day, Mt = (J.month + 9) % p + 1, Ot = ft(J.year / 100), kt = J.year % 100 - (J.month <= 2 ? 1 : 0);
                return ((Ct + ft(2.6 * Mt - 0.2) - 2 * Ot + kt + ft(kt / 4) + ft(Ot / 4)) % 7 + 7) % 7;
              }
              return J.weekday;
            }
            function $(J, ft) {
              return Object(a.isLeapYear)(J) ? u[ft] : d[ft];
            }
            function z(J) {
              var ft = J.date, Ct = J.time, Mt = J.year, Ot = J.month, kt = J.day, de = J.weekday, Pe = J.hour, Me = J.minute, Ce = J.hasDay, $e = J.hasTime, bn = J.past, Ye = J.present, Hn = J.future;
              return {
                date: ft,
                time: Ct,
                year: Mt,
                month: Ot,
                day: kt,
                weekday: de,
                hour: Pe,
                minute: Me,
                hasDay: Ce,
                hasTime: $e,
                past: bn,
                present: Ye,
                future: Hn
              };
            }
            function at(J, ft) {
              for (var Ct = String(J); Ct.length < ft; )
                Ct = "0" + Ct;
              return Ct;
            }
            function ct(J) {
              var ft = at(J.year, 4) + "-" + at(J.month, 2);
              return J.hasDay && (ft += "-" + at(J.day, 2)), ft;
            }
            function St(J) {
              return J.hasTime ? at(J.hour, 2) + ":" + at(J.minute, 2) : "";
            }
            function F(J, ft) {
              for (J.minute += ft; J.minute > y; )
                J.minute -= y, J.hour++, J.hour >= x && (M(J), J.hour = P);
              return J;
            }
            function M(J) {
              return J.day++, J.weekday = (J.weekday + 1) % v, J.day > c && J.day > $(J.year, J.month) && (J.day = m, J.month++, J.month > p && (J.month = g, J.year++)), J;
            }
            function I(J) {
              return J.day--, J.weekday = (J.weekday + 6) % v, J.day < m && (J.month--, J.month < g && (J.year--, J.month = p), J.day = $(J.year, J.month)), J;
            }
            function N(J, ft, Ct) {
              for (ft === void 0 && (ft = M), Ct === void 0 && (Ct = 1); --Ct >= 0; )
                ft(J);
              return J;
            }
            function G(J, ft) {
              var Ct = (ft.year - J.year) * 525600, Mt = (ft.month - J.month) * 43800, Ot = (ft.day - J.day) * 1440, kt = (ft.hour - J.hour) * 60, de = ft.minute - J.minute;
              return Ct + Mt + Ot + kt + de;
            }
            function nt(J, ft, Ct, Mt) {
              for (Ct === void 0 && (Ct = M), Mt === void 0 && (Mt = 6); J.weekday !== ft && --Mt >= 0; )
                Ct(J);
              return J;
            }
            function lt(J) {
              for (var ft = [1, 1, 1, 1, 1, 1, 1], Ct = [0, 0, 0, 0, 0, 0, 0], Mt = 0; Mt < J.length; Mt++)
                Ct[J[Mt]] = 1;
              for (var Ot = 0; Ot < v; Ot++) {
                for (var kt = 1, de = 1; de < v; de++) {
                  var Pe = (Ot + de) % v;
                  if (Ct[Pe])
                    break;
                  kt++;
                }
                ft[Ot] = Ct[Ot] * kt;
              }
              return ft;
            }
            function yt(J) {
              var ft = at(J.hour, 2) + ":" + at(J.minute, 2), Ct = J.date;
              return /* @__PURE__ */ new Date(Ct + "T" + ft + ":00+00:00");
            }
            function Lt(J, ft, Ct, Mt, Ot, kt) {
              Ot === void 0 && (Ot = 42), kt === void 0 && (kt = 0);
              var de = et(ft), Pe = [], Me = z(J), Ce = 0, $e = Ce === de;
              if (de < et(J))
                throw new Error("End date is earlier than start date.");
              for (; (!$e || Pe.length < kt) && Pe.length < Ot; ) {
                if (Ce = et(Me), $e = $e || Ce === de, Mt[Me.weekday] === 0) {
                  Me = M(Me);
                  continue;
                }
                var bn = z(Me);
                tt(bn), vt(bn, Ct), Pe.push(bn), Me = N(Me, M, Mt[Me.weekday]);
              }
              if (!Pe.length)
                throw new Error("No dates found using specified start date, end date, and weekdays.");
              return Pe;
            }
            function Nt(J, ft, Ct, Mt, Ot) {
              for (var kt = [], de = 0; de < Mt; de++) {
                var Pe = ft + de * Ct, Me = z(J);
                kt.push(R(Me, Pe, Ot));
              }
              return kt;
            }
            function Jt(J, ft) {
              var Ct = function(Ot, kt) {
                return "";
              };
              return typeof Intl > "u" || typeof Intl.DateTimeFormat > "u" ? Ct : function(Mt, Ot) {
                try {
                  var kt = new Intl.DateTimeFormat(J || void 0, ft(Mt, Ot));
                  return kt.format(yt(Mt));
                } catch {
                  return "";
                }
              };
            }
          }
        ),
        /***/
        "./src/components/VCard/VCard.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VCard/VCard.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCard/VCard.ts": (
          /*!***************************************!*\
            !*** ./src/components/VCard/VCard.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCard.sass */
              "./src/components/VCard/VCard.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), l = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(o.default, l.default, a.default).extend({
              name: "v-card",
              props: {
                flat: Boolean,
                hover: Boolean,
                img: String,
                link: Boolean,
                loaderHeight: {
                  type: [Number, String],
                  default: 4
                },
                raised: Boolean
              },
              computed: {
                classes: function() {
                  return d(d(d({
                    "v-card": !0
                  }, l.default.options.computed.classes.call(this)), {
                    "v-card--flat": this.flat,
                    "v-card--hover": this.hover,
                    "v-card--link": this.isClickable,
                    "v-card--loading": this.loading,
                    "v-card--disabled": this.disabled,
                    "v-card--raised": this.raised
                  }), a.default.options.computed.classes.call(this));
                },
                styles: function() {
                  var c = d({}, a.default.options.computed.styles.call(this));
                  return this.img && (c.background = 'url("' + this.img + '") center center / cover no-repeat'), c;
                }
              },
              methods: {
                genProgress: function() {
                  var c = o.default.options.methods.genProgress.call(this);
                  return c ? this.$createElement("div", {
                    staticClass: "v-card__progress",
                    key: "progress"
                  }, [c]) : null;
                }
              },
              render: function(c) {
                var h = this.generateRouteLink(), p = h.tag, g = h.data;
                return g.style = this.styles, this.isClickable && (g.attrs = g.attrs || {}, g.attrs.tabindex = 0), c(p, this.setBackgroundColor(this.color, g), [this.genProgress(), this.$slots.default]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCard/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VCard/index.ts ***!
            \***************************************/
          /*! exports provided: VCard, VCardActions, VCardSubtitle, VCardText, VCardTitle, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VCardActions", function() {
              return l;
            }), i.d(r, "VCardSubtitle", function() {
              return f;
            }), i.d(r, "VCardText", function() {
              return d;
            }), i.d(r, "VCardTitle", function() {
              return u;
            });
            var a = i(
              /*! ./VCard */
              "./src/components/VCard/VCard.ts"
            );
            i.d(r, "VCard", function() {
              return a.default;
            });
            var o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = Object(o.createSimpleFunctional)("v-card__actions"), f = Object(o.createSimpleFunctional)("v-card__subtitle"), d = Object(o.createSimpleFunctional)("v-card__text"), u = Object(o.createSimpleFunctional)("v-card__title");
            r.default = {
              $_vuetify_subcomponents: {
                VCard: a.default,
                VCardActions: l,
                VCardSubtitle: f,
                VCardText: d,
                VCardTitle: u
              }
            };
          }
        ),
        /***/
        "./src/components/VCarousel/VCarousel.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VCarousel/VCarousel.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCarousel/VCarousel.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCarousel/VCarousel.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCarousel.sass */
              "./src/components/VCarousel/VCarousel.sass"
            );
            var a = i(
              /*! ../VWindow/VWindow */
              "./src/components/VWindow/VWindow.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            ), d = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-carousel",
              props: {
                continuous: {
                  type: Boolean,
                  default: !0
                },
                cycle: Boolean,
                delimiterIcon: {
                  type: String,
                  default: "$delimiter"
                },
                height: {
                  type: [Number, String],
                  default: 500
                },
                hideDelimiters: Boolean,
                hideDelimiterBackground: Boolean,
                interval: {
                  type: [Number, String],
                  default: 6e3,
                  validator: function(g) {
                    return g > 0;
                  }
                },
                mandatory: {
                  type: Boolean,
                  default: !0
                },
                progress: Boolean,
                progressColor: String,
                showArrows: {
                  type: Boolean,
                  default: !0
                },
                verticalDelimiters: {
                  type: String,
                  default: void 0
                }
              },
              // pass down the parent's theme
              provide: function() {
                return {
                  parentTheme: this.theme
                };
              },
              data: function() {
                return {
                  internalHeight: this.height,
                  slideTimeout: void 0
                };
              },
              computed: {
                classes: function() {
                  return h(h({}, a.default.options.computed.classes.call(this)), {
                    "v-carousel": !0,
                    "v-carousel--hide-delimiter-background": this.hideDelimiterBackground,
                    "v-carousel--vertical-delimiters": this.isVertical
                  });
                },
                isDark: function() {
                  return this.dark || !this.light;
                },
                isVertical: function() {
                  return this.verticalDelimiters != null;
                }
              },
              watch: {
                internalValue: "restartTimeout",
                interval: "restartTimeout",
                height: function(g, m) {
                  g === m || !g || (this.internalHeight = g);
                },
                cycle: function(g) {
                  g ? this.restartTimeout() : (clearTimeout(this.slideTimeout), this.slideTimeout = void 0);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("hide-controls") && Object(c.breaking)("hide-controls", ':show-arrows="false"', this);
              },
              mounted: function() {
                this.startTimeout();
              },
              methods: {
                genControlIcons: function() {
                  return this.isVertical ? null : a.default.options.methods.genControlIcons.call(this);
                },
                genDelimiters: function() {
                  return this.$createElement("div", {
                    staticClass: "v-carousel__controls",
                    style: {
                      left: this.verticalDelimiters === "left" && this.isVertical ? 0 : "auto",
                      right: this.verticalDelimiters === "right" ? 0 : "auto"
                    }
                  }, [this.genItems()]);
                },
                genItems: function() {
                  for (var g = this, m = this.items.length, v = [], y = 0; y < m; y++) {
                    var E = this.$createElement(o.default, {
                      staticClass: "v-carousel__controls__item",
                      attrs: {
                        "aria-label": this.$vuetify.lang.t("$vuetify.carousel.ariaLabel.delimiter", y + 1, m)
                      },
                      props: {
                        icon: !0,
                        small: !0,
                        value: this.getValue(this.items[y], y)
                      },
                      key: y
                    }, [this.$createElement(l.default, {
                      props: {
                        size: 18
                      }
                    }, this.delimiterIcon)]);
                    v.push(E);
                  }
                  return this.$createElement(d.default, {
                    props: {
                      value: this.internalValue,
                      mandatory: this.mandatory
                    },
                    on: {
                      change: function(x) {
                        g.internalValue = x;
                      }
                    }
                  }, v);
                },
                genProgress: function() {
                  return this.$createElement(f.default, {
                    staticClass: "v-carousel__progress",
                    props: {
                      color: this.progressColor,
                      value: (this.internalIndex + 1) / this.items.length * 100
                    }
                  });
                },
                restartTimeout: function() {
                  this.slideTimeout && clearTimeout(this.slideTimeout), this.slideTimeout = void 0, window.requestAnimationFrame(this.startTimeout);
                },
                startTimeout: function() {
                  this.cycle && (this.slideTimeout = window.setTimeout(this.next, +this.interval > 0 ? +this.interval : 6e3));
                }
              },
              render: function(g) {
                var m = a.default.options.render.call(this, g);
                return m.data.style = "height: " + Object(u.convertToUnit)(this.height) + ";", this.hideDelimiters || m.children.push(this.genDelimiters()), (this.progress || this.progressColor) && m.children.push(this.genProgress()), m;
              }
            });
          }
        ),
        /***/
        "./src/components/VCarousel/VCarouselItem.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VCarousel/VCarouselItem.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            ), o = i(
              /*! ../VImg */
              "./src/components/VImg/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(l.default)(a.default, d.default);
            r.default = c.extend().extend({
              name: "v-carousel-item",
              inject: {
                parentTheme: {
                  default: {
                    isDark: !1
                  }
                }
              },
              // pass down the parent's theme
              provide: function() {
                return {
                  theme: this.parentTheme
                };
              },
              inheritAttrs: !1,
              methods: {
                genDefaultSlot: function() {
                  return [this.$createElement(o.VImg, {
                    staticClass: "v-carousel__item",
                    props: u(u({}, this.$attrs), {
                      height: this.windowGroup.internalHeight
                    }),
                    on: this.$listeners,
                    scopedSlots: {
                      placeholder: this.$scopedSlots.placeholder
                    }
                  }, Object(f.getSlot)(this))];
                },
                genWindowItem: function() {
                  var p = this.generateRouteLink(), g = p.tag, m = p.data;
                  return m.staticClass = "v-window-item", m.directives.push({
                    name: "show",
                    value: this.isActive
                  }), this.$createElement(g, m, this.genDefaultSlot());
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCarousel/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCarousel/index.ts ***!
            \*******************************************/
          /*! exports provided: VCarousel, VCarouselItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCarousel */
              "./src/components/VCarousel/VCarousel.ts"
            );
            i.d(r, "VCarousel", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCarouselItem */
              "./src/components/VCarousel/VCarouselItem.ts"
            );
            i.d(r, "VCarouselItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCarousel: a.default,
                VCarouselItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VCheckbox/VCheckbox.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VCheckbox/VCheckbox.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCheckbox/VCheckbox.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCheckbox/VCheckbox.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCheckbox.sass */
              "./src/components/VCheckbox/VCheckbox.sass"
            ), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), l = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            }, d = function(u, c) {
              var h = {};
              for (var p in u)
                Object.prototype.hasOwnProperty.call(u, p) && c.indexOf(p) < 0 && (h[p] = u[p]);
              if (u != null && typeof Object.getOwnPropertySymbols == "function")
                for (var g = 0, p = Object.getOwnPropertySymbols(u); g < p.length; g++)
                  c.indexOf(p[g]) < 0 && Object.prototype.propertyIsEnumerable.call(u, p[g]) && (h[p[g]] = u[p[g]]);
              return h;
            };
            r.default = l.default.extend({
              name: "v-checkbox",
              props: {
                indeterminate: Boolean,
                indeterminateIcon: {
                  type: String,
                  default: "$checkboxIndeterminate"
                },
                offIcon: {
                  type: String,
                  default: "$checkboxOff"
                },
                onIcon: {
                  type: String,
                  default: "$checkboxOn"
                }
              },
              data: function() {
                return {
                  inputIndeterminate: this.indeterminate
                };
              },
              computed: {
                classes: function() {
                  return f(f({}, o.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls": !0,
                    "v-input--checkbox": !0,
                    "v-input--indeterminate": this.inputIndeterminate
                  });
                },
                computedIcon: function() {
                  return this.inputIndeterminate ? this.indeterminateIcon : this.isActive ? this.onIcon : this.offIcon;
                },
                // Do not return undefined if disabled,
                // according to spec, should still show
                // a color when disabled and active
                validationState: function() {
                  if (!(this.isDisabled && !this.inputIndeterminate)) {
                    if (this.hasError && this.shouldValidate)
                      return "error";
                    if (this.hasSuccess)
                      return "success";
                    if (this.hasColor !== null)
                      return this.computedColor;
                  }
                }
              },
              watch: {
                indeterminate: function(c) {
                  var h = this;
                  this.$nextTick(function() {
                    return h.inputIndeterminate = c;
                  });
                },
                inputIndeterminate: function(c) {
                  this.$emit("update:indeterminate", c);
                },
                isActive: function() {
                  this.indeterminate && (this.inputIndeterminate = !1);
                }
              },
              methods: {
                genCheckbox: function() {
                  var c = this.attrs$;
                  c.title;
                  var h = d(c, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.$createElement(a.default, this.setTextColor(this.validationState, {
                    props: {
                      dense: this.dense,
                      dark: this.dark,
                      light: this.light
                    }
                  }), this.computedIcon), this.genInput("checkbox", f(f({}, h), {
                    "aria-checked": this.inputIndeterminate ? "mixed" : this.isActive.toString()
                  })), this.genRipple(this.setTextColor(this.rippleState))]);
                },
                genDefaultSlot: function() {
                  return [this.genCheckbox(), this.genLabel()];
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCheckbox/VSimpleCheckbox.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VCheckbox/VSimpleCheckbox.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCheckbox/VSimpleCheckbox.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VCheckbox/VSimpleCheckbox.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSimpleCheckbox.sass */
              "./src/components/VCheckbox/VSimpleCheckbox.sass"
            );
            var a = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o), f = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), d = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = l.a.extend({
              name: "v-simple-checkbox",
              functional: !0,
              directives: {
                Ripple: a.default
              },
              props: p(p(p({}, d.default.options.props), u.default.options.props), {
                disabled: Boolean,
                ripple: {
                  type: Boolean,
                  default: !0
                },
                value: Boolean,
                indeterminate: Boolean,
                indeterminateIcon: {
                  type: String,
                  default: "$checkboxIndeterminate"
                },
                onIcon: {
                  type: String,
                  default: "$checkboxOn"
                },
                offIcon: {
                  type: String,
                  default: "$checkboxOff"
                }
              }),
              render: function(m, v) {
                var y = v.props, E = v.data;
                v.listeners;
                var C = [], x = y.offIcon;
                if (y.indeterminate ? x = y.indeterminateIcon : y.value && (x = y.onIcon), C.push(m(f.VIcon, d.default.options.methods.setTextColor(y.value && y.color, {
                  props: {
                    disabled: y.disabled,
                    dark: y.dark,
                    light: y.light
                  }
                }), x)), y.ripple && !y.disabled) {
                  var b = m("div", d.default.options.methods.setTextColor(y.color, {
                    staticClass: "v-input--selection-controls__ripple",
                    directives: [{
                      def: a.default,
                      name: "ripple",
                      value: {
                        center: !0
                      }
                    }]
                  }));
                  C.push(b);
                }
                return m("div", Object(c.default)(E, {
                  class: {
                    "v-simple-checkbox": !0,
                    "v-simple-checkbox--disabled": y.disabled
                  },
                  on: {
                    click: function(T) {
                      T.stopPropagation(), E.on && E.on.input && !y.disabled && Object(h.wrapInArray)(E.on.input).forEach(function(O) {
                        return O(!y.value);
                      });
                    }
                  }
                }), [m("div", {
                  staticClass: "v-input--selection-controls__input"
                }, C)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCheckbox/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCheckbox/index.ts ***!
            \*******************************************/
          /*! exports provided: VCheckbox, VSimpleCheckbox, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCheckbox */
              "./src/components/VCheckbox/VCheckbox.ts"
            );
            i.d(r, "VCheckbox", function() {
              return a.default;
            });
            var o = i(
              /*! ./VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            );
            i.d(r, "VSimpleCheckbox", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCheckbox: a.default,
                VSimpleCheckbox: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VChip/VChip.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VChip/VChip.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VChip/VChip.ts": (
          /*!***************************************!*\
            !*** ./src/components/VChip/VChip.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VChip.sass */
              "./src/components/VChip/VChip.sass"
            );
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), h = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), p = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = function() {
              return m = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, m.apply(this, arguments);
            }, v = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], T;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (O) {
                T = {
                  error: O
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (T)
                    throw T.error;
                }
              }
              return P;
            };
            r.default = Object(a.default)(f.default, p.default, h.default, u.default, Object(d.factory)("chipGroup"), Object(c.factory)("inputValue")).extend({
              name: "v-chip",
              props: {
                active: {
                  type: Boolean,
                  default: !0
                },
                activeClass: {
                  type: String,
                  default: function() {
                    return this.chipGroup ? this.chipGroup.activeClass : "";
                  }
                },
                close: Boolean,
                closeIcon: {
                  type: String,
                  default: "$delete"
                },
                closeLabel: {
                  type: String,
                  default: "$vuetify.close"
                },
                disabled: Boolean,
                draggable: Boolean,
                filter: Boolean,
                filterIcon: {
                  type: String,
                  default: "$complete"
                },
                label: Boolean,
                link: Boolean,
                outlined: Boolean,
                pill: Boolean,
                tag: {
                  type: String,
                  default: "span"
                },
                textColor: String,
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-chip--active"
                };
              },
              computed: {
                classes: function() {
                  return m(m(m(m(m({
                    "v-chip": !0
                  }, h.default.options.computed.classes.call(this)), {
                    "v-chip--clickable": this.isClickable,
                    "v-chip--disabled": this.disabled,
                    "v-chip--draggable": this.draggable,
                    "v-chip--label": this.label,
                    "v-chip--link": this.isLink,
                    "v-chip--no-color": !this.color,
                    "v-chip--outlined": this.outlined,
                    "v-chip--pill": this.pill,
                    "v-chip--removable": this.hasClose
                  }), this.themeClasses), this.sizeableClasses), this.groupClasses);
                },
                hasClose: function() {
                  return !!this.close;
                },
                isClickable: function() {
                  return !!(h.default.options.computed.isClickable.call(this) || this.chipGroup);
                }
              },
              created: function() {
                var E = this, C = [["outline", "outlined"], ["selected", "input-value"], ["value", "active"], ["@input", "@active.sync"]];
                C.forEach(function(x) {
                  var b = v(x, 2), P = b[0], T = b[1];
                  E.$attrs.hasOwnProperty(P) && Object(g.breaking)(P, T, E);
                });
              },
              methods: {
                click: function(E) {
                  this.$emit("click", E), this.chipGroup && this.toggle();
                },
                genFilter: function() {
                  var E = [];
                  return this.isActive && E.push(this.$createElement(l.default, {
                    staticClass: "v-chip__filter",
                    props: {
                      left: !0
                    }
                  }, this.filterIcon)), this.$createElement(o.VExpandXTransition, E);
                },
                genClose: function() {
                  var E = this;
                  return this.$createElement(l.default, {
                    staticClass: "v-chip__close",
                    props: {
                      right: !0,
                      size: 18
                    },
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.closeLabel)
                    },
                    on: {
                      click: function(x) {
                        x.stopPropagation(), x.preventDefault(), E.$emit("click:close"), E.$emit("update:active", !1);
                      }
                    }
                  }, this.closeIcon);
                },
                genContent: function() {
                  return this.$createElement("span", {
                    staticClass: "v-chip__content"
                  }, [this.filter && this.genFilter(), this.$slots.default, this.hasClose && this.genClose()]);
                }
              },
              render: function(E) {
                var C = [this.genContent()], x = this.generateRouteLink(), b = x.tag, P = x.data;
                P.attrs = m(m({}, P.attrs), {
                  draggable: this.draggable ? "true" : void 0,
                  tabindex: this.chipGroup && !this.disabled ? 0 : P.attrs.tabindex
                }), P.directives.push({
                  name: "show",
                  value: this.active
                }), P = this.setBackgroundColor(this.color, P);
                var T = this.textColor || this.outlined && this.color;
                return E(b, this.setTextColor(T, P), C);
              }
            });
          }
        ),
        /***/
        "./src/components/VChip/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VChip/index.ts ***!
            \***************************************/
          /*! exports provided: VChip, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VChip */
              "./src/components/VChip/VChip.ts"
            );
            i.d(r, "VChip", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VChipGroup/VChipGroup.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VChipGroup/VChipGroup.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VChipGroup/VChipGroup.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VChipGroup/VChipGroup.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VChipGroup.sass */
              "./src/components/VChipGroup/VChipGroup.sass"
            );
            var a = i(
              /*! ../VSlideGroup/VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.BaseSlideGroup, o.default).extend({
              name: "v-chip-group",
              provide: function() {
                return {
                  chipGroup: this
                };
              },
              props: {
                column: Boolean
              },
              computed: {
                classes: function() {
                  return f(f({}, a.BaseSlideGroup.options.computed.classes.call(this)), {
                    "v-chip-group": !0,
                    "v-chip-group--column": this.column
                  });
                }
              },
              watch: {
                column: function(u) {
                  u && (this.scrollOffset = 0), this.$nextTick(this.onResize);
                }
              },
              methods: {
                genData: function() {
                  return this.setTextColor(this.color, f({}, a.BaseSlideGroup.options.methods.genData.call(this)));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VChipGroup/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VChipGroup/index.ts ***!
            \********************************************/
          /*! exports provided: VChipGroup, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VChipGroup */
              "./src/components/VChipGroup/VChipGroup.ts"
            );
            i.d(r, "VChipGroup", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPicker.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VColorPicker/VColorPicker.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPicker.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VColorPicker/VColorPicker.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPicker.sass */
              "./src/components/VColorPicker/VColorPicker.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ./VColorPickerPreview */
              "./src/components/VColorPicker/VColorPickerPreview.ts"
            ), l = i(
              /*! ./VColorPickerCanvas */
              "./src/components/VColorPicker/VColorPickerCanvas.ts"
            ), f = i(
              /*! ./VColorPickerEdit */
              "./src/components/VColorPicker/VColorPickerEdit.ts"
            ), d = i(
              /*! ./VColorPickerSwatches */
              "./src/components/VColorPicker/VColorPickerSwatches.ts"
            ), u = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), g = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), m = function() {
              return m = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, m.apply(this, arguments);
            };
            r.default = Object(c.default)(p.default, g.default).extend({
              name: "v-color-picker",
              props: {
                canvasHeight: {
                  type: [String, Number],
                  default: 150
                },
                disabled: Boolean,
                dotSize: {
                  type: [Number, String],
                  default: 10
                },
                flat: Boolean,
                hideCanvas: Boolean,
                hideSliders: Boolean,
                hideInputs: Boolean,
                hideModeSwitch: Boolean,
                mode: {
                  type: String,
                  default: "rgba",
                  validator: function(y) {
                    return Object.keys(f.modes).includes(y);
                  }
                },
                showSwatches: Boolean,
                swatches: Array,
                swatchesMaxHeight: {
                  type: [Number, String],
                  default: 150
                },
                value: {
                  type: [Object, String]
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  internalValue: Object(u.fromRGBA)({
                    r: 255,
                    g: 0,
                    b: 0,
                    a: 1
                  })
                };
              },
              computed: {
                hideAlpha: function() {
                  return this.value ? !Object(u.hasAlpha)(this.value) : !1;
                }
              },
              watch: {
                value: {
                  handler: function(y) {
                    this.updateColor(Object(u.parseColor)(y, this.internalValue));
                  },
                  immediate: !0
                }
              },
              methods: {
                updateColor: function(y) {
                  this.internalValue = y;
                  var E = Object(u.extractColor)(this.internalValue, this.value);
                  Object(h.deepEqual)(E, this.value) || (this.$emit("input", E), this.$emit("update:color", this.internalValue));
                },
                genCanvas: function() {
                  return this.$createElement(l.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      dotSize: this.dotSize,
                      width: this.width,
                      height: this.canvasHeight
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                },
                genControls: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__controls"
                  }, [!this.hideSliders && this.genPreview(), !this.hideInputs && this.genEdit()]);
                },
                genEdit: function() {
                  var y = this;
                  return this.$createElement(f.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      hideAlpha: this.hideAlpha,
                      hideModeSwitch: this.hideModeSwitch,
                      mode: this.mode
                    },
                    on: {
                      "update:color": this.updateColor,
                      "update:mode": function(C) {
                        return y.$emit("update:mode", C);
                      }
                    }
                  });
                },
                genPreview: function() {
                  return this.$createElement(o.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      hideAlpha: this.hideAlpha
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                },
                genSwatches: function() {
                  return this.$createElement(d.default, {
                    props: {
                      dark: this.dark,
                      light: this.light,
                      disabled: this.disabled,
                      swatches: this.swatches,
                      color: this.internalValue,
                      maxHeight: this.swatchesMaxHeight
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                }
              },
              render: function(y) {
                return y(a.default, {
                  staticClass: "v-color-picker",
                  class: m(m({
                    "v-color-picker--flat": this.flat
                  }, this.themeClasses), this.elevationClasses),
                  props: {
                    maxWidth: this.width
                  }
                }, [!this.hideCanvas && this.genCanvas(), (!this.hideSliders || !this.hideInputs) && this.genControls(), this.showSwatches && this.genSwatches()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerCanvas.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerCanvas.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerCanvas.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerCanvas.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerCanvas.sass */
              "./src/components/VColorPicker/VColorPickerCanvas.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend({
              name: "v-color-picker-canvas",
              props: {
                color: {
                  type: Object,
                  default: function() {
                    return Object(o.fromRGBA)({
                      r: 255,
                      g: 0,
                      b: 0,
                      a: 1
                    });
                  }
                },
                disabled: Boolean,
                dotSize: {
                  type: [Number, String],
                  default: 10
                },
                height: {
                  type: [Number, String],
                  default: 150
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  boundingRect: {
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                  }
                };
              },
              computed: {
                dot: function() {
                  return this.color ? {
                    x: this.color.hsva.s * parseInt(this.width, 10),
                    y: (1 - this.color.hsva.v) * parseInt(this.height, 10)
                  } : {
                    x: 0,
                    y: 0
                  };
                }
              },
              watch: {
                "color.hue": "updateCanvas"
              },
              mounted: function() {
                this.updateCanvas();
              },
              methods: {
                emitColor: function(u, c) {
                  var h = this.boundingRect, p = h.left, g = h.top, m = h.width, v = h.height;
                  this.$emit("update:color", Object(o.fromHSVA)({
                    h: this.color.hue,
                    s: Object(a.clamp)(u - p, 0, m) / m,
                    v: 1 - Object(a.clamp)(c - g, 0, v) / v,
                    a: this.color.alpha
                  }));
                },
                updateCanvas: function() {
                  if (this.color) {
                    var u = this.$refs.canvas, c = u.getContext("2d");
                    if (c) {
                      var h = c.createLinearGradient(0, 0, u.width, 0);
                      h.addColorStop(0, "hsla(0, 0%, 100%, 1)"), h.addColorStop(1, "hsla(" + this.color.hue + ", 100%, 50%, 1)"), c.fillStyle = h, c.fillRect(0, 0, u.width, u.height);
                      var p = c.createLinearGradient(0, 0, 0, u.height);
                      p.addColorStop(0, "hsla(0, 0%, 100%, 0)"), p.addColorStop(1, "hsla(0, 0%, 0%, 1)"), c.fillStyle = p, c.fillRect(0, 0, u.width, u.height);
                    }
                  }
                },
                handleClick: function(u) {
                  this.disabled || (this.boundingRect = this.$el.getBoundingClientRect(), this.emitColor(u.clientX, u.clientY));
                },
                handleMouseDown: function(u) {
                  u.preventDefault(), !this.disabled && (this.boundingRect = this.$el.getBoundingClientRect(), window.addEventListener("mousemove", this.handleMouseMove), window.addEventListener("mouseup", this.handleMouseUp));
                },
                handleMouseMove: function(u) {
                  this.disabled || this.emitColor(u.clientX, u.clientY);
                },
                handleMouseUp: function() {
                  window.removeEventListener("mousemove", this.handleMouseMove), window.removeEventListener("mouseup", this.handleMouseUp);
                },
                genCanvas: function() {
                  return this.$createElement("canvas", {
                    ref: "canvas",
                    attrs: {
                      width: this.width,
                      height: this.height
                    }
                  });
                },
                genDot: function() {
                  var u = parseInt(this.dotSize, 10) / 2, c = Object(a.convertToUnit)(this.dot.x - u), h = Object(a.convertToUnit)(this.dot.y - u);
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__canvas-dot",
                    class: {
                      "v-color-picker__canvas-dot--disabled": this.disabled
                    },
                    style: {
                      width: Object(a.convertToUnit)(this.dotSize),
                      height: Object(a.convertToUnit)(this.dotSize),
                      transform: "translate(" + c + ", " + h + ")"
                    }
                  });
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-color-picker__canvas",
                  style: {
                    width: Object(a.convertToUnit)(this.width),
                    height: Object(a.convertToUnit)(this.height)
                  },
                  on: {
                    click: this.handleClick,
                    mousedown: this.handleMouseDown
                  }
                }, [this.genCanvas(), this.genDot()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerEdit.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerEdit.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerEdit.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerEdit.ts ***!
            \*********************************************************/
          /*! exports provided: modes, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "modes", function() {
              return h;
            }), i(
              /*! ./VColorPickerEdit.sass */
              "./src/components/VColorPicker/VColorPickerEdit.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), c = function(p, g) {
              var m = typeof Symbol == "function" && p[Symbol.iterator];
              if (!m)
                return p;
              var v = m.call(p), y, E = [], C;
              try {
                for (; (g === void 0 || g-- > 0) && !(y = v.next()).done; )
                  E.push(y.value);
              } catch (x) {
                C = {
                  error: x
                };
              } finally {
                try {
                  y && !y.done && (m = v.return) && m.call(v);
                } finally {
                  if (C)
                    throw C.error;
                }
              }
              return E;
            }, h = {
              rgba: {
                inputs: [["r", 255, "int"], ["g", 255, "int"], ["b", 255, "int"], ["a", 1, "float"]],
                from: u.fromRGBA
              },
              hsla: {
                inputs: [["h", 360, "int"], ["s", 1, "float"], ["l", 1, "float"], ["a", 1, "float"]],
                from: u.fromHSLA
              },
              hexa: {
                from: u.fromHexa
              }
            };
            r.default = d.a.extend({
              name: "v-color-picker-edit",
              props: {
                color: Object,
                disabled: Boolean,
                hideAlpha: Boolean,
                hideModeSwitch: Boolean,
                mode: {
                  type: String,
                  default: "rgba",
                  validator: function(g) {
                    return Object.keys(h).includes(g);
                  }
                }
              },
              data: function() {
                return {
                  modes: h,
                  internalMode: this.mode
                };
              },
              computed: {
                currentMode: function() {
                  return this.modes[this.internalMode];
                }
              },
              watch: {
                mode: function(g) {
                  this.internalMode = g;
                }
              },
              created: function() {
                this.internalMode = this.mode;
              },
              methods: {
                getValue: function(g, m) {
                  return m === "float" ? Math.round(g * 100) / 100 : m === "int" ? Math.round(g) : 0;
                },
                parseValue: function(g, m) {
                  return m === "float" ? parseFloat(g) : m === "int" && parseInt(g, 10) || 0;
                },
                changeMode: function() {
                  var g = Object.keys(this.modes), m = g.indexOf(this.internalMode), v = g[(m + 1) % g.length];
                  this.internalMode = v, this.$emit("update:mode", v);
                },
                genInput: function(g, m, v, y) {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__input"
                  }, [this.$createElement("input", {
                    key: g,
                    attrs: m,
                    domProps: {
                      value: v
                    },
                    on: y
                  }), this.$createElement("span", g.toUpperCase())]);
                },
                genInputs: function() {
                  var g = this;
                  if (this.internalMode === "hexa") {
                    var m = this.color.hexa, v = this.hideAlpha && m.endsWith("FF") ? m.substr(0, 7) : m;
                    return this.genInput("hex", {
                      maxlength: this.hideAlpha ? 7 : 9,
                      disabled: this.disabled
                    }, v, {
                      change: function(C) {
                        var x = C.target;
                        g.$emit("update:color", g.currentMode.from(Object(l.parseHex)(x.value)));
                      }
                    });
                  } else {
                    var y = this.hideAlpha ? this.currentMode.inputs.slice(0, -1) : this.currentMode.inputs;
                    return y.map(function(E) {
                      var C = c(E, 3), x = C[0], b = C[1], P = C[2], T = g.color[g.internalMode];
                      return g.genInput(x, {
                        type: "number",
                        min: 0,
                        max: b,
                        step: P === "float" ? "0.01" : P === "int" ? "1" : void 0,
                        disabled: g.disabled
                      }, g.getValue(T[x], P), {
                        input: function(S) {
                          var L, A = S.target, D = g.parseValue(A.value || "0", P);
                          g.$emit("update:color", g.currentMode.from(Object.assign({}, T, (L = {}, L[x] = D, L)), g.color.alpha));
                        }
                      });
                    });
                  }
                },
                genSwitch: function() {
                  return this.$createElement(a.default, {
                    props: {
                      small: !0,
                      icon: !0,
                      disabled: this.disabled
                    },
                    on: {
                      click: this.changeMode
                    }
                  }, [this.$createElement(o.default, "$unfold")]);
                }
              },
              render: function(g) {
                return g("div", {
                  staticClass: "v-color-picker__edit"
                }, [this.genInputs(), !this.hideModeSwitch && this.genSwitch()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerPreview.sass": (
          /*!**************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerPreview.sass ***!
            \**************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerPreview.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerPreview.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerPreview.sass */
              "./src/components/VColorPicker/VColorPickerPreview.sass"
            );
            var a = i(
              /*! ../VSlider/VSlider */
              "./src/components/VSlider/VSlider.ts"
            ), o = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l), d = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = f.a.extend({
              name: "v-color-picker-preview",
              props: {
                color: Object,
                disabled: Boolean,
                hideAlpha: Boolean
              },
              methods: {
                genAlpha: function() {
                  var h = this;
                  return this.genTrack({
                    staticClass: "v-color-picker__alpha",
                    props: {
                      thumbColor: "grey lighten-2",
                      hideDetails: !0,
                      value: this.color.alpha,
                      step: 0,
                      min: 0,
                      max: 1
                    },
                    style: {
                      backgroundImage: this.disabled ? void 0 : "linear-gradient(to " + (this.$vuetify.rtl ? "left" : "right") + ", transparent, " + Object(o.RGBtoCSS)(this.color.rgba) + ")"
                    },
                    on: {
                      input: function(g) {
                        return h.color.alpha !== g && h.$emit("update:color", Object(d.fromHSVA)(u(u({}, h.color.hsva), {
                          a: g
                        })));
                      }
                    }
                  });
                },
                genSliders: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__sliders"
                  }, [this.genHue(), !this.hideAlpha && this.genAlpha()]);
                },
                genDot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__dot"
                  }, [this.$createElement("div", {
                    style: {
                      background: Object(o.RGBAtoCSS)(this.color.rgba)
                    }
                  })]);
                },
                genHue: function() {
                  var h = this;
                  return this.genTrack({
                    staticClass: "v-color-picker__hue",
                    props: {
                      thumbColor: "grey lighten-2",
                      hideDetails: !0,
                      value: this.color.hue,
                      step: 0,
                      min: 0,
                      max: 360
                    },
                    on: {
                      input: function(g) {
                        return h.color.hue !== g && h.$emit("update:color", Object(d.fromHSVA)(u(u({}, h.color.hsva), {
                          h: g
                        })));
                      }
                    }
                  });
                },
                genTrack: function(h) {
                  return this.$createElement(a.default, u(u({
                    class: "v-color-picker__track"
                  }, h), {
                    props: u({
                      disabled: this.disabled
                    }, h.props)
                  }));
                }
              },
              render: function(h) {
                return h("div", {
                  staticClass: "v-color-picker__preview",
                  class: {
                    "v-color-picker__preview--hide-alpha": this.hideAlpha
                  }
                }, [this.genDot(), this.genSliders()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerSwatches.sass": (
          /*!***************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerSwatches.sass ***!
            \***************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerSwatches.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerSwatches.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerSwatches.sass */
              "./src/components/VColorPicker/VColorPickerSwatches.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../util/colors */
              "./src/util/colors.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            );
            function h(m) {
              return Object.keys(m).map(function(v) {
                var y = m[v];
                return y.base ? [y.base, y.darken4, y.darken3, y.darken2, y.darken1, y.lighten1, y.lighten2, y.lighten3, y.lighten4, y.lighten5] : [y.black, y.white, y.transparent];
              });
            }
            var p = Object(l.fromHex)("#FFFFFF").rgba, g = Object(l.fromHex)("#000000").rgba;
            r.default = Object(d.default)(u.default).extend({
              name: "v-color-picker-swatches",
              props: {
                swatches: {
                  type: Array,
                  default: function() {
                    return h(o.default);
                  }
                },
                disabled: Boolean,
                color: Object,
                maxWidth: [Number, String],
                maxHeight: [Number, String]
              },
              methods: {
                genColor: function(v) {
                  var y = this, E = this.$createElement("div", {
                    style: {
                      background: v
                    }
                  }, [Object(f.deepEqual)(this.color, Object(l.parseColor)(v, null)) && this.$createElement(a.default, {
                    props: {
                      small: !0,
                      dark: Object(c.contrastRatio)(this.color.rgba, p) > 2 && this.color.alpha > 0.5,
                      light: Object(c.contrastRatio)(this.color.rgba, g) > 2 && this.color.alpha > 0.5
                    }
                  }, "$success")]);
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__color",
                    on: {
                      // TODO: Less hacky way of catching transparent
                      click: function() {
                        return y.disabled || y.$emit("update:color", Object(l.fromHex)(v === "transparent" ? "#00000000" : v));
                      }
                    }
                  }, [E]);
                },
                genSwatches: function() {
                  var v = this;
                  return this.swatches.map(function(y) {
                    var E = y.map(v.genColor);
                    return v.$createElement("div", {
                      staticClass: "v-color-picker__swatch"
                    }, E);
                  });
                }
              },
              render: function(v) {
                return v("div", {
                  staticClass: "v-color-picker__swatches",
                  style: {
                    maxWidth: Object(f.convertToUnit)(this.maxWidth),
                    maxHeight: Object(f.convertToUnit)(this.maxHeight)
                  }
                }, [this.$createElement("div", this.genSwatches())]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VColorPicker/index.ts ***!
            \**********************************************/
          /*! exports provided: VColorPicker, VColorPickerSwatches, VColorPickerCanvas, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VColorPicker */
              "./src/components/VColorPicker/VColorPicker.ts"
            );
            i.d(r, "VColorPicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VColorPickerSwatches */
              "./src/components/VColorPicker/VColorPickerSwatches.ts"
            );
            i.d(r, "VColorPickerSwatches", function() {
              return o.default;
            });
            var l = i(
              /*! ./VColorPickerCanvas */
              "./src/components/VColorPicker/VColorPickerCanvas.ts"
            );
            i.d(r, "VColorPickerCanvas", function() {
              return l.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VColorPicker/util/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VColorPicker/util/index.ts ***!
            \***************************************************/
          /*! exports provided: fromHSVA, fromHSLA, fromRGBA, fromHexa, fromHex, parseColor, extractColor, hasAlpha */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromHSVA", function() {
              return d;
            }), i.d(r, "fromHSLA", function() {
              return u;
            }), i.d(r, "fromRGBA", function() {
              return c;
            }), i.d(r, "fromHexa", function() {
              return h;
            }), i.d(r, "fromHex", function() {
              return p;
            }), i.d(r, "parseColor", function() {
              return m;
            }), i.d(r, "extractColor", function() {
              return y;
            }), i.d(r, "hasAlpha", function() {
              return E;
            });
            var a = i(
              /*! ../../../util/colorUtils */
              "./src/util/colorUtils.ts"
            );
            function o(C) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(b) {
                return typeof b;
              } : o = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
              }, o(C);
            }
            var l = function() {
              return l = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var T in x)
                    Object.prototype.hasOwnProperty.call(x, T) && (C[T] = x[T]);
                }
                return C;
              }, l.apply(this, arguments);
            }, f = function(C, x) {
              var b = {};
              for (var P in C)
                Object.prototype.hasOwnProperty.call(C, P) && x.indexOf(P) < 0 && (b[P] = C[P]);
              if (C != null && typeof Object.getOwnPropertySymbols == "function")
                for (var T = 0, P = Object.getOwnPropertySymbols(C); T < P.length; T++)
                  x.indexOf(P[T]) < 0 && Object.prototype.propertyIsEnumerable.call(C, P[T]) && (b[P[T]] = C[P[T]]);
              return b;
            };
            function d(C) {
              C = l({}, C);
              var x = Object(a.HSVAtoHex)(C), b = Object(a.HSVAtoHSLA)(C), P = Object(a.HSVAtoRGBA)(C);
              return {
                alpha: C.a,
                hex: x.substr(0, 7),
                hexa: x,
                hsla: b,
                hsva: C,
                hue: C.h,
                rgba: P
              };
            }
            function u(C) {
              var x = Object(a.HSLAtoHSVA)(C), b = Object(a.HSVAtoHex)(x), P = Object(a.HSVAtoRGBA)(x);
              return {
                alpha: x.a,
                hex: b.substr(0, 7),
                hexa: b,
                hsla: C,
                hsva: x,
                hue: x.h,
                rgba: P
              };
            }
            function c(C) {
              var x = Object(a.RGBAtoHSVA)(C), b = Object(a.RGBAtoHex)(C), P = Object(a.HSVAtoHSLA)(x);
              return {
                alpha: x.a,
                hex: b.substr(0, 7),
                hexa: b,
                hsla: P,
                hsva: x,
                hue: x.h,
                rgba: C
              };
            }
            function h(C) {
              var x = Object(a.HexToHSVA)(C), b = Object(a.HSVAtoHSLA)(x), P = Object(a.HSVAtoRGBA)(x);
              return {
                alpha: x.a,
                hex: C.substr(0, 7),
                hexa: C,
                hsla: b,
                hsva: x,
                hue: x.h,
                rgba: P
              };
            }
            function p(C) {
              return h(Object(a.parseHex)(C));
            }
            function g(C, x) {
              return x.every(function(b) {
                return C.hasOwnProperty(b);
              });
            }
            function m(C, x) {
              if (!C)
                return c({
                  r: 255,
                  g: 0,
                  b: 0,
                  a: 1
                });
              if (typeof C == "string") {
                if (C === "transparent")
                  return h("#00000000");
                var b = Object(a.parseHex)(C);
                return x && b === x.hexa ? x : h(b);
              }
              if (o(C) === "object") {
                if (C.hasOwnProperty("alpha"))
                  return C;
                var P = C.hasOwnProperty("a") ? parseFloat(C.a) : 1;
                if (g(C, ["r", "g", "b"]))
                  return x && C === x.rgba ? x : c(l(l({}, C), {
                    a: P
                  }));
                if (g(C, ["h", "s", "l"]))
                  return x && C === x.hsla ? x : u(l(l({}, C), {
                    a: P
                  }));
                if (g(C, ["h", "s", "v"]))
                  return x && C === x.hsva ? x : d(l(l({}, C), {
                    a: P
                  }));
              }
              return c({
                r: 255,
                g: 0,
                b: 0,
                a: 1
              });
            }
            function v(C, x) {
              if (x) {
                C.a;
                var b = f(C, ["a"]);
                return b;
              }
              return C;
            }
            function y(C, x) {
              if (x == null)
                return C;
              if (typeof x == "string")
                return x.length === 7 ? C.hex : C.hexa;
              if (o(x) === "object") {
                var b = typeof x.a == "number" && x.a === 0 ? !!x.a : !x.a;
                if (g(x, ["r", "g", "b"]))
                  return v(C.rgba, b);
                if (g(x, ["h", "s", "l"]))
                  return v(C.hsla, b);
                if (g(x, ["h", "s", "v"]))
                  return v(C.hsva, b);
              }
              return C;
            }
            function E(C) {
              return C ? typeof C == "string" ? C.length > 7 : o(C) === "object" ? g(C, ["a"]) || g(C, ["alpha"]) : !1 : !1;
            }
          }
        ),
        /***/
        "./src/components/VCombobox/VCombobox.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCombobox/VCombobox.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VAutocomplete/VAutocomplete.sass */
              "./src/components/VAutocomplete/VAutocomplete.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VAutocomplete/VAutocomplete */
              "./src/components/VAutocomplete/VAutocomplete.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function f(u) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? f = function(h) {
                return typeof h;
              } : f = function(h) {
                return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
              }, f(u);
            }
            var d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = o.default.extend({
              name: "v-combobox",
              props: {
                delimiters: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                returnObject: {
                  type: Boolean,
                  default: !0
                }
              },
              data: function() {
                return {
                  editingIndex: -1
                };
              },
              computed: {
                computedCounterValue: function() {
                  return this.multiple ? this.selectedItems.length : (this.internalSearch || "").toString().length;
                },
                hasSlot: function() {
                  return a.default.options.computed.hasSlot.call(this) || this.multiple;
                },
                isAnyValueAllowed: function() {
                  return !0;
                },
                menuCanShow: function() {
                  return this.isFocused ? this.hasDisplayedItems || !!this.$slots["no-data"] && !this.hideNoData : !1;
                },
                searchIsDirty: function() {
                  return this.internalSearch != null;
                }
              },
              methods: {
                onInternalSearchChanged: function(c) {
                  if (c && this.multiple && this.delimiters.length) {
                    var h = this.delimiters.find(function(p) {
                      return c.endsWith(p);
                    });
                    h != null && (this.internalSearch = c.slice(0, c.length - h.length), this.updateTags());
                  }
                  this.updateMenuDimensions();
                },
                genInput: function() {
                  var c = o.default.options.methods.genInput.call(this);
                  return delete c.data.attrs.name, c.data.on.paste = this.onPaste, c;
                },
                genChipSelection: function(c, h) {
                  var p = this, g = a.default.options.methods.genChipSelection.call(this, c, h);
                  return this.multiple && (g.componentOptions.listeners = d(d({}, g.componentOptions.listeners), {
                    dblclick: function() {
                      p.editingIndex = h, p.internalSearch = p.getText(c), p.selectedIndex = -1;
                    }
                  })), g;
                },
                onChipInput: function(c) {
                  a.default.options.methods.onChipInput.call(this, c), this.editingIndex = -1;
                },
                // Requires a manual definition
                // to overwrite removal in v-autocomplete
                onEnterDown: function(c) {
                  c.preventDefault(), !(this.getMenuIndex() > -1) && this.$nextTick(this.updateSelf);
                },
                onKeyDown: function(c) {
                  var h = c.keyCode;
                  (c.ctrlKey || ![l.keyCodes.home, l.keyCodes.end].includes(h)) && a.default.options.methods.onKeyDown.call(this, c), this.multiple && h === l.keyCodes.left && this.$refs.input.selectionStart === 0 ? this.updateSelf() : h === l.keyCodes.enter && this.onEnterDown(c), this.changeSelectedIndex(h);
                },
                onTabDown: function(c) {
                  if (this.multiple && this.internalSearch && this.getMenuIndex() === -1)
                    return c.preventDefault(), c.stopPropagation(), this.updateTags();
                  o.default.options.methods.onTabDown.call(this, c);
                },
                selectItem: function(c) {
                  this.editingIndex > -1 ? this.updateEditing() : (o.default.options.methods.selectItem.call(this, c), this.internalSearch && this.multiple && this.getText(c).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase()) && (this.internalSearch = null));
                },
                setSelectedItems: function() {
                  this.internalValue == null || this.internalValue === "" ? this.selectedItems = [] : this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];
                },
                setValue: function(c) {
                  a.default.options.methods.setValue.call(this, c === void 0 ? this.internalSearch : c);
                },
                updateEditing: function() {
                  var c = this, h = this.internalValue.slice(), p = this.selectedItems.findIndex(function(m) {
                    return c.getText(m) === c.internalSearch;
                  });
                  if (p > -1) {
                    var g = f(h[p]) === "object" ? Object.assign({}, h[p]) : h[p];
                    h.splice(p, 1), h.push(g);
                  } else
                    h[this.editingIndex] = this.internalSearch;
                  this.setValue(h), this.editingIndex = -1, this.internalSearch = null;
                },
                updateCombobox: function() {
                  if (this.searchIsDirty) {
                    this.internalSearch !== this.getText(this.internalValue) && this.setValue();
                    var c = !!this.$scopedSlots.selection || this.hasChips;
                    c && (this.internalSearch = null);
                  }
                },
                updateSelf: function() {
                  this.multiple ? this.updateTags() : this.updateCombobox();
                },
                updateTags: function() {
                  var c = this, h = this.getMenuIndex();
                  if (!(h < 0 && !this.searchIsDirty || !this.internalSearch)) {
                    if (this.editingIndex > -1)
                      return this.updateEditing();
                    var p = this.selectedItems.findIndex(function(v) {
                      return c.internalSearch === c.getText(v);
                    }), g = p > -1 && f(this.selectedItems[p]) === "object" ? Object.assign({}, this.selectedItems[p]) : this.internalSearch;
                    if (p > -1) {
                      var m = this.internalValue.slice();
                      m.splice(p, 1), this.setValue(m);
                    }
                    if (h > -1)
                      return this.internalSearch = null;
                    this.selectItem(g), this.internalSearch = null;
                  }
                },
                onPaste: function(c) {
                  var h;
                  if (this.$emit("paste", c), !(!this.multiple || this.searchIsDirty)) {
                    var p = (h = c.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/vnd.vuetify.autocomplete.item+plain");
                    p && this.findExistingIndex(p) === -1 && (c.preventDefault(), a.default.options.methods.selectItem.call(this, p));
                  }
                },
                clearableCallback: function() {
                  this.editingIndex = -1, o.default.options.methods.clearableCallback.call(this);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCombobox/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCombobox/index.ts ***!
            \*******************************************/
          /*! exports provided: VCombobox, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCombobox */
              "./src/components/VCombobox/VCombobox.ts"
            );
            i.d(r, "VCombobox", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VContent/VContent.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VContent/VContent.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VMain/VMain */
              "./src/components/VMain/VMain.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = a.default.extend({
              name: "v-main",
              created: function() {
                Object(o.deprecate)("v-content", "v-main", this);
              },
              render: function(f) {
                var d = a.default.options.render.call(this, f);
                return d.data.staticClass += " v-content", d.children[0].data.staticClass += " v-content__wrap", f(d.tag, d.data, d.children);
              }
            });
          }
        ),
        /***/
        "./src/components/VContent/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VContent/index.ts ***!
            \******************************************/
          /*! exports provided: VContent, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VContent */
              "./src/components/VContent/VContent.ts"
            );
            i.d(r, "VContent", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VCounter/VCounter.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VCounter/VCounter.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCounter/VCounter.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VCounter/VCounter.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCounter.sass */
              "./src/components/VCounter/VCounter.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-counter",
              functional: !0,
              props: {
                value: {
                  type: [Number, String],
                  default: ""
                },
                max: [Number, String]
              },
              render: function(d, u) {
                var c = u.props, h = parseInt(c.max, 10), p = parseInt(c.value, 10), g = h ? p + " / " + h : String(c.value), m = h && p > h;
                return d("div", {
                  staticClass: "v-counter",
                  class: l({
                    "error--text": m
                  }, Object(a.functionalThemeClasses)(u))
                }, g);
              }
            });
          }
        ),
        /***/
        "./src/components/VCounter/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VCounter/index.ts ***!
            \******************************************/
          /*! exports provided: VCounter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCounter */
              "./src/components/VCounter/VCounter.ts"
            );
            i.d(r, "VCounter", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VData/VData.ts": (
          /*!***************************************!*\
            !*** ./src/components/VData/VData.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o), f = function() {
              return f = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, f.apply(this, arguments);
            }, d = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, u = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            r.default = l.a.extend({
              name: "v-data",
              inheritAttrs: !1,
              props: {
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                options: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                },
                sortBy: {
                  type: [String, Array]
                },
                sortDesc: {
                  type: [Boolean, Array]
                },
                customSort: {
                  type: Function,
                  default: a.sortItems
                },
                mustSort: Boolean,
                multiSort: Boolean,
                page: {
                  type: Number,
                  default: 1
                },
                itemsPerPage: {
                  type: Number,
                  default: 10
                },
                groupBy: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                groupDesc: {
                  type: [Boolean, Array],
                  default: function() {
                    return [];
                  }
                },
                customGroup: {
                  type: Function,
                  default: a.groupItems
                },
                locale: {
                  type: String,
                  default: "en-US"
                },
                disableSort: Boolean,
                disablePagination: Boolean,
                disableFiltering: Boolean,
                search: String,
                customFilter: {
                  type: Function,
                  default: a.searchItems
                },
                serverItemsLength: {
                  type: Number,
                  default: -1
                }
              },
              data: function() {
                var h, p, g = {
                  page: this.page,
                  itemsPerPage: this.itemsPerPage,
                  sortBy: Object(a.wrapInArray)(this.sortBy),
                  sortDesc: Object(a.wrapInArray)(this.sortDesc),
                  groupBy: Object(a.wrapInArray)(this.groupBy),
                  groupDesc: Object(a.wrapInArray)(this.groupDesc),
                  mustSort: this.mustSort,
                  multiSort: this.multiSort
                };
                this.options && (g = Object.assign(g, this.options));
                var m = g.sortBy, v = g.sortDesc, y = g.groupBy, E = g.groupDesc, C = m.length - v.length, x = y.length - E.length;
                return C > 0 && (h = g.sortDesc).push.apply(h, u([], d(Object(a.fillArray)(C, !1)), !1)), x > 0 && (p = g.groupDesc).push.apply(p, u([], d(Object(a.fillArray)(x, !1)), !1)), {
                  internalOptions: g
                };
              },
              computed: {
                itemsLength: function() {
                  return this.serverItemsLength >= 0 ? this.serverItemsLength : this.filteredItems.length;
                },
                pageCount: function() {
                  return this.internalOptions.itemsPerPage <= 0 ? 1 : Math.ceil(this.itemsLength / this.internalOptions.itemsPerPage);
                },
                pageStart: function() {
                  return this.internalOptions.itemsPerPage === -1 || !this.items.length ? 0 : (this.internalOptions.page - 1) * this.internalOptions.itemsPerPage;
                },
                pageStop: function() {
                  return this.internalOptions.itemsPerPage === -1 ? this.itemsLength : this.items.length ? Math.min(this.itemsLength, this.internalOptions.page * this.internalOptions.itemsPerPage) : 0;
                },
                isGrouped: function() {
                  return !!this.internalOptions.groupBy.length;
                },
                pagination: function() {
                  return {
                    page: this.internalOptions.page,
                    itemsPerPage: this.internalOptions.itemsPerPage,
                    pageStart: this.pageStart,
                    pageStop: this.pageStop,
                    pageCount: this.pageCount,
                    itemsLength: this.itemsLength
                  };
                },
                filteredItems: function() {
                  var h = this.items.slice();
                  return !this.disableFiltering && this.serverItemsLength <= 0 && (h = this.customFilter(h, this.search)), h;
                },
                computedItems: function() {
                  var h = this.filteredItems.slice();
                  return (!this.disableSort || this.internalOptions.groupBy.length) && this.serverItemsLength <= 0 && (h = this.sortItems(h)), !this.disablePagination && this.serverItemsLength <= 0 && (h = this.paginateItems(h)), h;
                },
                groupedItems: function() {
                  return this.isGrouped ? this.groupItems(this.computedItems) : null;
                },
                scopedProps: function() {
                  return {
                    sort: this.sort,
                    sortArray: this.sortArray,
                    group: this.group,
                    items: this.computedItems,
                    options: this.internalOptions,
                    updateOptions: this.updateOptions,
                    pagination: this.pagination,
                    groupedItems: this.groupedItems,
                    originalItemsLength: this.items.length
                  };
                },
                computedOptions: function() {
                  return f({}, this.options);
                }
              },
              watch: {
                computedOptions: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.updateOptions(h);
                  },
                  deep: !0,
                  immediate: !0
                },
                internalOptions: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.$emit("update:options", h);
                  },
                  deep: !0,
                  immediate: !0
                },
                page: function(h) {
                  this.updateOptions({
                    page: h
                  });
                },
                "internalOptions.page": function(h) {
                  this.$emit("update:page", h);
                },
                itemsPerPage: function(h) {
                  this.updateOptions({
                    itemsPerPage: h
                  });
                },
                "internalOptions.itemsPerPage": function(h) {
                  this.$emit("update:items-per-page", h);
                },
                sortBy: function(h) {
                  this.updateOptions({
                    sortBy: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.sortBy": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:sort-by", Array.isArray(this.sortBy) ? h : h[0]);
                },
                sortDesc: function(h) {
                  this.updateOptions({
                    sortDesc: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.sortDesc": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:sort-desc", Array.isArray(this.sortDesc) ? h : h[0]);
                },
                groupBy: function(h) {
                  this.updateOptions({
                    groupBy: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.groupBy": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:group-by", Array.isArray(this.groupBy) ? h : h[0]);
                },
                groupDesc: function(h) {
                  this.updateOptions({
                    groupDesc: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.groupDesc": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:group-desc", Array.isArray(this.groupDesc) ? h : h[0]);
                },
                multiSort: function(h) {
                  this.updateOptions({
                    multiSort: h
                  });
                },
                "internalOptions.multiSort": function(h) {
                  this.$emit("update:multi-sort", h);
                },
                mustSort: function(h) {
                  this.updateOptions({
                    mustSort: h
                  });
                },
                "internalOptions.mustSort": function(h) {
                  this.$emit("update:must-sort", h);
                },
                pageCount: {
                  handler: function(h) {
                    this.$emit("page-count", h);
                  },
                  immediate: !0
                },
                computedItems: {
                  handler: function(h) {
                    this.$emit("current-items", h);
                  },
                  immediate: !0
                },
                pagination: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.$emit("pagination", this.pagination);
                  },
                  immediate: !0
                }
              },
              methods: {
                toggle: function(h, p, g, m, v, y) {
                  var E = p.slice(), C = g.slice(), x = E.findIndex(function(b) {
                    return b === h;
                  });
                  return x < 0 ? (y || (E = [], C = []), E.push(h), C.push(!1)) : x >= 0 && !C[x] ? C[x] = !0 : v ? C[x] = !1 : (E.splice(x, 1), C.splice(x, 1)), (!Object(a.deepEqual)(E, p) || !Object(a.deepEqual)(C, g)) && (m = 1), {
                    by: E,
                    desc: C,
                    page: m
                  };
                },
                group: function(h) {
                  var p = this.toggle(h, this.internalOptions.groupBy, this.internalOptions.groupDesc, this.internalOptions.page, !0, !1), g = p.by, m = p.desc, v = p.page;
                  this.updateOptions({
                    groupBy: g,
                    groupDesc: m,
                    page: v
                  });
                },
                sort: function(h) {
                  if (Array.isArray(h))
                    return this.sortArray(h);
                  var p = this.toggle(h, this.internalOptions.sortBy, this.internalOptions.sortDesc, this.internalOptions.page, this.internalOptions.mustSort, this.internalOptions.multiSort), g = p.by, m = p.desc, v = p.page;
                  this.updateOptions({
                    sortBy: g,
                    sortDesc: m,
                    page: v
                  });
                },
                sortArray: function(h) {
                  var p = this, g = h.map(function(m) {
                    var v = p.internalOptions.sortBy.findIndex(function(y) {
                      return y === m;
                    });
                    return v > -1 ? p.internalOptions.sortDesc[v] : !1;
                  });
                  this.updateOptions({
                    sortBy: h,
                    sortDesc: g
                  });
                },
                updateOptions: function(h) {
                  this.internalOptions = f(f(f({}, this.internalOptions), h), {
                    page: this.serverItemsLength < 0 ? Math.max(1, Math.min(h.page || this.internalOptions.page, this.pageCount)) : h.page || this.internalOptions.page
                  });
                },
                sortItems: function(h) {
                  var p = [], g = [];
                  return this.disableSort || (p = this.internalOptions.sortBy, g = this.internalOptions.sortDesc), this.internalOptions.groupBy.length && (p = u(u([], d(this.internalOptions.groupBy), !1), d(p), !1), g = u(u([], d(this.internalOptions.groupDesc), !1), d(g), !1)), this.customSort(h, p, g, this.locale);
                },
                groupItems: function(h) {
                  return this.customGroup(h, this.internalOptions.groupBy, this.internalOptions.groupDesc);
                },
                paginateItems: function(h) {
                  return this.serverItemsLength === -1 && h.length <= this.pageStart && (this.internalOptions.page = Math.max(1, Math.ceil(h.length / this.internalOptions.itemsPerPage)) || 1), h.slice(this.pageStart, this.pageStop);
                }
              },
              render: function() {
                return this.$scopedSlots.default && this.$scopedSlots.default(this.scopedProps);
              }
            });
          }
        ),
        /***/
        "./src/components/VData/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VData/index.ts ***!
            \***************************************/
          /*! exports provided: VData, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VData */
              "./src/components/VData/VData.ts"
            );
            i.d(r, "VData", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataFooter.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataIterator/VDataFooter.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataFooter.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VDataIterator/VDataFooter.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataFooter.sass */
              "./src/components/VDataIterator/VDataFooter.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function c(h) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(g) {
                return typeof g;
              } : c = function(g) {
                return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
              }, c(h);
            }
            r.default = d.a.extend({
              name: "v-data-footer",
              props: {
                options: {
                  type: Object,
                  required: !0
                },
                pagination: {
                  type: Object,
                  required: !0
                },
                itemsPerPageOptions: {
                  type: Array,
                  default: function() {
                    return [5, 10, 15, -1];
                  }
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                firstIcon: {
                  type: String,
                  default: "$first"
                },
                lastIcon: {
                  type: String,
                  default: "$last"
                },
                itemsPerPageText: {
                  type: String,
                  default: "$vuetify.dataFooter.itemsPerPageText"
                },
                itemsPerPageAllText: {
                  type: String,
                  default: "$vuetify.dataFooter.itemsPerPageAll"
                },
                showFirstLastPage: Boolean,
                showCurrentPage: Boolean,
                disablePagination: Boolean,
                disableItemsPerPage: Boolean,
                pageText: {
                  type: String,
                  default: "$vuetify.dataFooter.pageText"
                }
              },
              computed: {
                disableNextPageIcon: function() {
                  return this.options.itemsPerPage <= 0 || this.options.page * this.options.itemsPerPage >= this.pagination.itemsLength || this.pagination.pageStop < 0;
                },
                computedDataItemsPerPageOptions: function() {
                  var p = this;
                  return this.itemsPerPageOptions.map(function(g) {
                    return c(g) === "object" ? g : p.genDataItemsPerPageOption(g);
                  });
                }
              },
              methods: {
                updateOptions: function(p) {
                  this.$emit("update:options", Object.assign({}, this.options, p));
                },
                onFirstPage: function() {
                  this.updateOptions({
                    page: 1
                  });
                },
                onPreviousPage: function() {
                  this.updateOptions({
                    page: this.options.page - 1
                  });
                },
                onNextPage: function() {
                  this.updateOptions({
                    page: this.options.page + 1
                  });
                },
                onLastPage: function() {
                  this.updateOptions({
                    page: this.pagination.pageCount
                  });
                },
                onChangeItemsPerPage: function(p) {
                  this.updateOptions({
                    itemsPerPage: p,
                    page: 1
                  });
                },
                genDataItemsPerPageOption: function(p) {
                  return {
                    text: p === -1 ? this.$vuetify.lang.t(this.itemsPerPageAllText) : String(p),
                    value: p
                  };
                },
                genItemsPerPageSelect: function() {
                  var p = this.options.itemsPerPage, g = this.computedDataItemsPerPageOptions;
                  return g.length <= 1 ? null : (g.find(function(m) {
                    return m.value === p;
                  }) || (p = g[0]), this.$createElement("div", {
                    staticClass: "v-data-footer__select"
                  }, [this.$vuetify.lang.t(this.itemsPerPageText), this.$createElement(a.default, {
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.itemsPerPageText)
                    },
                    props: {
                      disabled: this.disableItemsPerPage,
                      items: g,
                      value: p,
                      hideDetails: !0,
                      auto: !0,
                      minWidth: "75px"
                    },
                    on: {
                      input: this.onChangeItemsPerPage
                    }
                  })]));
                },
                genPaginationInfo: function() {
                  var p = ["–"], g = this.pagination.itemsLength, m = this.pagination.pageStart, v = this.pagination.pageStop;
                  return this.pagination.itemsLength && this.pagination.itemsPerPage ? (m = this.pagination.pageStart + 1, v = g < this.pagination.pageStop || this.pagination.pageStop < 0 ? g : this.pagination.pageStop, p = this.$scopedSlots["page-text"] ? [this.$scopedSlots["page-text"]({
                    pageStart: m,
                    pageStop: v,
                    itemsLength: g
                  })] : [this.$vuetify.lang.t(this.pageText, m, v, g)]) : this.$scopedSlots["page-text"] && (p = [this.$scopedSlots["page-text"]({
                    pageStart: m,
                    pageStop: v,
                    itemsLength: g
                  })]), this.$createElement("div", {
                    class: "v-data-footer__pagination"
                  }, p);
                },
                genIcon: function(p, g, m, v) {
                  return this.$createElement(l.default, {
                    props: {
                      disabled: g || this.disablePagination,
                      icon: !0,
                      text: !0
                      // dark: this.dark, // TODO: add mixin
                      // light: this.light // TODO: add mixin
                    },
                    on: {
                      click: p
                    },
                    attrs: {
                      "aria-label": m
                      // TODO: Localization
                    }
                  }, [this.$createElement(o.default, v)]);
                },
                genIcons: function() {
                  var p = [], g = [];
                  return p.push(this.genIcon(this.onPreviousPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.prevPage"), this.$vuetify.rtl ? this.nextIcon : this.prevIcon)), g.push(this.genIcon(this.onNextPage, this.disableNextPageIcon, this.$vuetify.lang.t("$vuetify.dataFooter.nextPage"), this.$vuetify.rtl ? this.prevIcon : this.nextIcon)), this.showFirstLastPage && (p.unshift(this.genIcon(this.onFirstPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.firstPage"), this.$vuetify.rtl ? this.lastIcon : this.firstIcon)), g.push(this.genIcon(this.onLastPage, this.options.page >= this.pagination.pageCount || this.options.itemsPerPage === -1, this.$vuetify.lang.t("$vuetify.dataFooter.lastPage"), this.$vuetify.rtl ? this.firstIcon : this.lastIcon))), [this.$createElement("div", {
                    staticClass: "v-data-footer__icons-before"
                  }, p), this.showCurrentPage && this.$createElement("span", [this.options.page.toString()]), this.$createElement("div", {
                    staticClass: "v-data-footer__icons-after"
                  }, g)];
                }
              },
              render: function() {
                return this.$createElement("div", {
                  staticClass: "v-data-footer"
                }, [Object(u.getSlot)(this, "prepend"), this.genItemsPerPageSelect(), this.genPaginationInfo(), this.genIcons()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataIterator.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataIterator/VDataIterator.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VData */
              "./src/components/VData/index.ts"
            ), o = i(
              /*! ./VDataFooter */
              "./src/components/VDataIterator/VDataFooter.ts"
            ), l = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            };
            r.default = Object(d.default)(l.default, f.default).extend({
              name: "v-data-iterator",
              props: h(h({}, a.VData.options.props), {
                itemKey: {
                  type: String,
                  default: "id"
                },
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                singleSelect: Boolean,
                expanded: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                mobileBreakpoint: h(h({}, l.default.options.props.mobileBreakpoint), {
                  default: 600
                }),
                singleExpand: Boolean,
                loading: [Boolean, String],
                noResultsText: {
                  type: String,
                  default: "$vuetify.dataIterator.noResultsText"
                },
                noDataText: {
                  type: String,
                  default: "$vuetify.noDataText"
                },
                loadingText: {
                  type: String,
                  default: "$vuetify.dataIterator.loadingText"
                },
                hideDefaultFooter: Boolean,
                footerProps: Object,
                selectableKey: {
                  type: String,
                  default: "isSelectable"
                }
              }),
              data: function() {
                return {
                  selection: {},
                  expansion: {},
                  internalCurrentItems: [],
                  shiftKeyDown: !1,
                  lastEntry: -1
                };
              },
              computed: {
                everyItem: function() {
                  var m = this;
                  return !!this.selectableItems.length && this.selectableItems.every(function(v) {
                    return m.isSelected(v);
                  });
                },
                someItems: function() {
                  var m = this;
                  return this.selectableItems.some(function(v) {
                    return m.isSelected(v);
                  });
                },
                sanitizedFooterProps: function() {
                  return Object(u.camelizeObjectKeys)(this.footerProps);
                },
                selectableItems: function() {
                  var m = this;
                  return this.internalCurrentItems.filter(function(v) {
                    return m.isSelectable(v);
                  });
                }
              },
              watch: {
                value: {
                  handler: function(m) {
                    var v = this;
                    this.selection = m.reduce(function(y, E) {
                      return y[Object(u.getObjectValueByPath)(E, v.itemKey)] = E, y;
                    }, {});
                  },
                  immediate: !0
                },
                selection: function(m, v) {
                  Object(u.deepEqual)(Object.keys(m), Object.keys(v)) || this.$emit("input", Object.values(m));
                },
                expanded: {
                  handler: function(m) {
                    var v = this;
                    this.expansion = m.reduce(function(y, E) {
                      return y[Object(u.getObjectValueByPath)(E, v.itemKey)] = !0, y;
                    }, {});
                  },
                  immediate: !0
                },
                expansion: function(m, v) {
                  var y = this;
                  if (!Object(u.deepEqual)(m, v)) {
                    var E = Object.keys(m).filter(function(x) {
                      return m[x];
                    }), C = E.length ? this.items.filter(function(x) {
                      return E.includes(String(Object(u.getObjectValueByPath)(x, y.itemKey)));
                    }) : [];
                    this.$emit("update:expanded", C);
                  }
                }
              },
              created: function() {
                var m = this, v = [["disable-initial-sort", "sort-by"], ["filter", "custom-filter"], ["pagination", "options"], ["total-items", "server-items-length"], ["hide-actions", "hide-default-footer"], ["rows-per-page-items", "footer-props.items-per-page-options"], ["rows-per-page-text", "footer-props.items-per-page-text"], ["prev-icon", "footer-props.prev-icon"], ["next-icon", "footer-props.next-icon"]];
                v.forEach(function(E) {
                  var C = p(E, 2), x = C[0], b = C[1];
                  m.$attrs.hasOwnProperty(x) && Object(c.breaking)(x, b, m);
                });
                var y = ["expand", "content-class", "content-props", "content-tag"];
                y.forEach(function(E) {
                  m.$attrs.hasOwnProperty(E) && Object(c.removed)(E);
                });
              },
              mounted: function() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp);
              },
              beforeDestroy: function() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
              },
              methods: {
                onKeyDown: function(m) {
                  this.shiftKeyDown = m.keyCode === u.keyCodes.shift || m.shiftKey;
                },
                onKeyUp: function(m) {
                  (m.keyCode === u.keyCodes.shift || !m.shiftKey) && (this.shiftKeyDown = !1);
                },
                toggleSelectAll: function(m) {
                  for (var v = Object.assign({}, this.selection), y = 0; y < this.selectableItems.length; y++) {
                    var E = this.selectableItems[y];
                    if (this.isSelectable(E)) {
                      var C = Object(u.getObjectValueByPath)(E, this.itemKey);
                      m ? v[C] = E : delete v[C];
                    }
                  }
                  this.selection = v, this.$emit("toggle-select-all", {
                    items: this.internalCurrentItems,
                    value: m
                  });
                },
                isSelectable: function(m) {
                  return Object(u.getObjectValueByPath)(m, this.selectableKey) !== !1;
                },
                isSelected: function(m) {
                  return !!this.selection[Object(u.getObjectValueByPath)(m, this.itemKey)] || !1;
                },
                select: function(m, v, y) {
                  var E = this;
                  if (v === void 0 && (v = !0), y === void 0 && (y = !0), !!this.isSelectable(m)) {
                    var C = this.singleSelect ? {} : Object.assign({}, this.selection), x = Object(u.getObjectValueByPath)(m, this.itemKey);
                    v ? C[x] = m : delete C[x];
                    var b = this.selectableItems.findIndex(function(L) {
                      return Object(u.getObjectValueByPath)(L, E.itemKey) === x;
                    });
                    if (this.lastEntry === -1)
                      this.lastEntry = b;
                    else if (this.shiftKeyDown && !this.singleSelect && y) {
                      var P = Object(u.getObjectValueByPath)(this.selectableItems[this.lastEntry], this.itemKey), T = Object.keys(this.selection).includes(String(P));
                      this.multipleSelect(T, y, C, b);
                    }
                    if (this.lastEntry = b, this.singleSelect && y) {
                      var O = Object.keys(this.selection), S = O.length && Object(u.getObjectValueByPath)(this.selection[O[0]], this.itemKey);
                      S && S !== x && this.$emit("item-selected", {
                        item: this.selection[S],
                        value: !1
                      });
                    }
                    this.selection = C, y && this.$emit("item-selected", {
                      item: m,
                      value: v
                    });
                  }
                },
                multipleSelect: function(m, v, y, E) {
                  m === void 0 && (m = !0), v === void 0 && (v = !0);
                  for (var C = E < this.lastEntry ? E : this.lastEntry, x = E < this.lastEntry ? this.lastEntry : E, b = C; b <= x; b++) {
                    var P = this.selectableItems[b], T = Object(u.getObjectValueByPath)(P, this.itemKey);
                    m ? y[T] = P : delete y[T], v && this.$emit("item-selected", {
                      currentItem: P,
                      value: m
                    });
                  }
                },
                isExpanded: function(m) {
                  return this.expansion[Object(u.getObjectValueByPath)(m, this.itemKey)] || !1;
                },
                expand: function(m, v) {
                  v === void 0 && (v = !0);
                  var y = this.singleExpand ? {} : Object.assign({}, this.expansion), E = Object(u.getObjectValueByPath)(m, this.itemKey);
                  v ? y[E] = !0 : delete y[E], this.expansion = y, this.$emit("item-expanded", {
                    item: m,
                    value: v
                  });
                },
                createItemProps: function(m, v) {
                  var y = this;
                  return {
                    item: m,
                    index: v,
                    select: function(C) {
                      return y.select(m, C);
                    },
                    isSelected: this.isSelected(m),
                    expand: function(C) {
                      return y.expand(m, C);
                    },
                    isExpanded: this.isExpanded(m),
                    isMobile: this.isMobile
                  };
                },
                genEmptyWrapper: function(m) {
                  return this.$createElement("div", m);
                },
                genEmpty: function(m, v) {
                  if (m === 0 && this.loading) {
                    var y = this.$slots.loading || this.$vuetify.lang.t(this.loadingText);
                    return this.genEmptyWrapper(y);
                  } else if (m === 0) {
                    var E = this.$slots["no-data"] || this.$vuetify.lang.t(this.noDataText);
                    return this.genEmptyWrapper(E);
                  } else if (v === 0) {
                    var C = this.$slots["no-results"] || this.$vuetify.lang.t(this.noResultsText);
                    return this.genEmptyWrapper(C);
                  }
                  return null;
                },
                genItems: function(m) {
                  var v = this, y = this.genEmpty(m.originalItemsLength, m.pagination.itemsLength);
                  return y ? [y] : this.$scopedSlots.default ? this.$scopedSlots.default(h(h({}, m), {
                    isSelected: this.isSelected,
                    select: this.select,
                    isExpanded: this.isExpanded,
                    isMobile: this.isMobile,
                    expand: this.expand
                  })) : this.$scopedSlots.item ? m.items.map(function(E, C) {
                    return v.$scopedSlots.item(v.createItemProps(E, C));
                  }) : [];
                },
                genFooter: function(m) {
                  if (this.hideDefaultFooter)
                    return null;
                  var v = {
                    props: h(h({}, this.sanitizedFooterProps), {
                      options: m.options,
                      pagination: m.pagination
                    }),
                    on: {
                      "update:options": function(C) {
                        return m.updateOptions(C);
                      }
                    }
                  }, y = Object(u.getPrefixedScopedSlots)("footer.", this.$scopedSlots);
                  return this.$createElement(o.default, h({
                    scopedSlots: y
                  }, v));
                },
                genDefaultScopedSlot: function(m) {
                  var v = h(h({}, m), {
                    someItems: this.someItems,
                    everyItem: this.everyItem,
                    toggleSelectAll: this.toggleSelectAll
                  });
                  return this.$createElement("div", {
                    staticClass: "v-data-iterator"
                  }, [Object(u.getSlot)(this, "header", v, !0), this.genItems(m), this.genFooter(m), Object(u.getSlot)(this, "footer", v, !0)]);
                }
              },
              render: function() {
                var m = this;
                return this.$createElement(a.VData, {
                  props: this.$props,
                  on: {
                    "update:options": function(y, E) {
                      return !Object(u.deepEqual)(y, E) && m.$emit("update:options", y);
                    },
                    "update:page": function(y) {
                      return m.$emit("update:page", y);
                    },
                    "update:items-per-page": function(y) {
                      return m.$emit("update:items-per-page", y);
                    },
                    "update:sort-by": function(y) {
                      return m.$emit("update:sort-by", y);
                    },
                    "update:sort-desc": function(y) {
                      return m.$emit("update:sort-desc", y);
                    },
                    "update:group-by": function(y) {
                      return m.$emit("update:group-by", y);
                    },
                    "update:group-desc": function(y) {
                      return m.$emit("update:group-desc", y);
                    },
                    pagination: function(y, E) {
                      return !Object(u.deepEqual)(y, E) && m.$emit("pagination", y);
                    },
                    "current-items": function(y) {
                      m.internalCurrentItems = y, m.$emit("current-items", y);
                    },
                    "page-count": function(y) {
                      return m.$emit("page-count", y);
                    }
                  },
                  scopedSlots: {
                    default: this.genDefaultScopedSlot
                  }
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDataIterator/index.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VDataIterator/index.ts ***!
            \***********************************************/
          /*! exports provided: VDataIterator, VDataFooter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDataIterator */
              "./src/components/VDataIterator/VDataIterator.ts"
            );
            i.d(r, "VDataIterator", function() {
              return a.default;
            });
            var o = i(
              /*! ./VDataFooter */
              "./src/components/VDataIterator/VDataFooter.ts"
            );
            i.d(r, "VDataFooter", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VDataIterator: a.default,
                VDataFooter: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDataTable/MobileRow.ts": (
          /*!************************************************!*\
            !*** ./src/components/VDataTable/MobileRow.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "row",
              functional: !0,
              props: {
                headers: Array,
                hideDefaultHeader: Boolean,
                index: Number,
                item: Object,
                rtl: Boolean
              },
              render: function(u, c) {
                var h = c.props, p = c.slots, g = c.data, m = p(), v = h.headers.map(function(y) {
                  var E = {
                    "v-data-table__mobile-row": !0
                  }, C = [], x = Object(l.getObjectValueByPath)(h.item, y.value), b = y.value, P = g.scopedSlots && g.scopedSlots.hasOwnProperty(b) && g.scopedSlots[b], T = m.hasOwnProperty(b) && m[b];
                  P ? C.push(P({
                    item: h.item,
                    isMobile: !0,
                    header: y,
                    index: h.index,
                    value: x
                  })) : T ? C.push(T) : C.push(x == null ? x : String(x));
                  var O = [u("div", {
                    staticClass: "v-data-table__mobile-row__cell"
                  }, C)];
                  return y.value !== "dataTableSelect" && !h.hideDefaultHeader && O.unshift(u("div", {
                    staticClass: "v-data-table__mobile-row__header"
                  }, [y.text])), u("td", {
                    class: E
                  }, O);
                });
                return u("tr", f(f({}, g), {
                  staticClass: "v-data-table__mobile-table-row"
                }), v);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/Row.ts": (
          /*!******************************************!*\
            !*** ./src/components/VDataTable/Row.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, d = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            function u(c) {
              var h;
              return c.length !== 1 || !["td", "th"].includes((h = c[0]) === null || h === void 0 ? void 0 : h.tag);
            }
            r.default = o.a.extend({
              name: "row",
              functional: !0,
              props: {
                headers: Array,
                index: Number,
                item: Object,
                rtl: Boolean
              },
              render: function(h, p) {
                var g = p.props, m = p.slots, v = p.data, y = m(), E = g.headers.map(function(C) {
                  var x = [], b = Object(l.getObjectValueByPath)(g.item, C.value), P = C.value, T = v.scopedSlots && v.scopedSlots.hasOwnProperty(P) && v.scopedSlots[P], O = y.hasOwnProperty(P) && y[P];
                  T ? x.push.apply(x, d([], f(Object(l.wrapInArray)(T({
                    item: g.item,
                    isMobile: !1,
                    header: C,
                    index: g.index,
                    value: b
                  }))), !1)) : O ? x.push.apply(x, d([], f(Object(l.wrapInArray)(O)), !1)) : x.push(b == null ? b : String(b));
                  var S = "text-" + (C.align || "start");
                  return u(x) ? h("td", {
                    class: [S, C.cellClass, {
                      "v-data-table__divider": C.divider
                    }]
                  }, x) : x;
                });
                return h("tr", v, E);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/RowGroup.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VDataTable/RowGroup.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, f = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            r.default = o.a.extend({
              name: "row-group",
              functional: !0,
              props: {
                value: {
                  type: Boolean,
                  default: !0
                },
                headerClass: {
                  type: String,
                  default: "v-row-group__header"
                },
                contentClass: String,
                summaryClass: {
                  type: String,
                  default: "v-row-group__summary"
                }
              },
              render: function(u, c) {
                var h = c.slots, p = c.props, g = h(), m = [];
                return g["column.header"] ? m.push(u("tr", {
                  staticClass: p.headerClass
                }, g["column.header"])) : g["row.header"] && m.push.apply(m, f([], l(g["row.header"]), !1)), g["row.content"] && p.value && m.push.apply(m, f([], l(g["row.content"]), !1)), g["column.summary"] ? m.push(u("tr", {
                  staticClass: p.summaryClass
                }, g["column.summary"])) : g["row.summary"] && m.push.apply(m, f([], l(g["row.summary"]), !1)), m;
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTable.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VDataTable/VDataTable.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTable.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VDataTable/VDataTable.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataTable.sass */
              "./src/components/VDataTable/VDataTable.sass"
            );
            var a = i(
              /*! ../VData */
              "./src/components/VData/index.ts"
            ), o = i(
              /*! ../VDataIterator */
              "./src/components/VDataIterator/index.ts"
            ), l = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), f = i(
              /*! ./VDataTableHeader */
              "./src/components/VDataTable/VDataTableHeader.ts"
            ), d = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), u = i(
              /*! ./Row */
              "./src/components/VDataTable/Row.ts"
            ), c = i(
              /*! ./RowGroup */
              "./src/components/VDataTable/RowGroup.ts"
            ), h = i(
              /*! ../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), p = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            ), g = i(
              /*! ./MobileRow */
              "./src/components/VDataTable/MobileRow.ts"
            ), m = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), v = i(
              /*! ../../mixins/mouse */
              "./src/mixins/mouse/index.ts"
            ), y = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), E = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), C = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), x = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), b = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            function P(A) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? P = function(_) {
                return typeof _;
              } : P = function(_) {
                return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
              }, P(A);
            }
            var T = function() {
              return T = Object.assign || function(A) {
                for (var D, _ = 1, w = arguments.length; _ < w; _++) {
                  D = arguments[_];
                  for (var B in D)
                    Object.prototype.hasOwnProperty.call(D, B) && (A[B] = D[B]);
                }
                return A;
              }, T.apply(this, arguments);
            }, O = function(A, D) {
              var _ = typeof Symbol == "function" && A[Symbol.iterator];
              if (!_)
                return A;
              var w = _.call(A), B, j = [], k;
              try {
                for (; (D === void 0 || D-- > 0) && !(B = w.next()).done; )
                  j.push(B.value);
              } catch (X) {
                k = {
                  error: X
                };
              } finally {
                try {
                  B && !B.done && (_ = w.return) && _.call(w);
                } finally {
                  if (k)
                    throw k.error;
                }
              }
              return j;
            };
            function S(A, D, _) {
              return function(w) {
                var B = Object(C.getObjectValueByPath)(A, w.value);
                return w.filter ? w.filter(B, D, A) : _(B, D, A);
              };
            }
            function L(A, D, _, w, B, j) {
              return D = typeof D == "string" ? D.trim() : null, j === "union" ? !(D && w.length) && !_.length ? A : A.filter(function(k) {
                return _.length && _.every(S(k, D, C.defaultFilter)) ? !0 : D && w.some(S(k, D, B));
              }) : j === "intersection" ? A.filter(function(k) {
                var X = _.every(S(k, D, C.defaultFilter)), rt = !D || w.some(S(k, D, B));
                return X && rt;
              }) : A;
            }
            r.default = Object(E.default)(o.VDataIterator, m.default, v.default).extend({
              name: "v-data-table",
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: y.default
              },
              props: {
                headers: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                showSelect: Boolean,
                checkboxColor: String,
                showExpand: Boolean,
                showGroupBy: Boolean,
                // TODO: Fix
                // virtualRows: Boolean,
                height: [Number, String],
                hideDefaultHeader: Boolean,
                caption: String,
                dense: Boolean,
                headerProps: Object,
                calculateWidths: Boolean,
                fixedHeader: Boolean,
                headersLength: Number,
                expandIcon: {
                  type: String,
                  default: "$expand"
                },
                customFilter: {
                  type: Function,
                  default: C.defaultFilter
                },
                filterMode: {
                  type: String,
                  default: "intersection"
                },
                itemClass: {
                  type: [String, Function],
                  default: function() {
                    return "";
                  }
                },
                itemStyle: {
                  type: [String, Function],
                  default: function() {
                    return "";
                  }
                },
                loaderHeight: {
                  type: [Number, String],
                  default: 4
                }
              },
              data: function() {
                return {
                  internalGroupBy: [],
                  openCache: {},
                  widths: []
                };
              },
              computed: {
                computedHeaders: function() {
                  var D = this;
                  if (!this.headers)
                    return [];
                  var _ = this.headers.filter(function(j) {
                    return j.value === void 0 || !D.internalGroupBy.find(function(k) {
                      return k === j.value;
                    });
                  }), w = {
                    text: "",
                    sortable: !1,
                    width: "1px"
                  };
                  if (this.showSelect) {
                    var B = _.findIndex(function(j) {
                      return j.value === "data-table-select";
                    });
                    B < 0 ? _.unshift(T(T({}, w), {
                      value: "data-table-select"
                    })) : _.splice(B, 1, T(T({}, w), _[B]));
                  }
                  if (this.showExpand) {
                    var B = _.findIndex(function(k) {
                      return k.value === "data-table-expand";
                    });
                    B < 0 ? _.unshift(T(T({}, w), {
                      value: "data-table-expand"
                    })) : _.splice(B, 1, T(T({}, w), _[B]));
                  }
                  return _;
                },
                colspanAttrs: function() {
                  return this.isMobile ? void 0 : {
                    colspan: this.headersLength || this.computedHeaders.length
                  };
                },
                columnSorters: function() {
                  return this.computedHeaders.reduce(function(D, _) {
                    return _.sort && (D[_.value] = _.sort), D;
                  }, {});
                },
                headersWithCustomFilters: function() {
                  return this.headers.filter(function(D) {
                    return D.filter && (!D.hasOwnProperty("filterable") || D.filterable === !0);
                  });
                },
                headersWithoutCustomFilters: function() {
                  return this.headers.filter(function(D) {
                    return !D.filter && (!D.hasOwnProperty("filterable") || D.filterable === !0);
                  });
                },
                sanitizedHeaderProps: function() {
                  return Object(C.camelizeObjectKeys)(this.headerProps);
                },
                computedItemsPerPage: function() {
                  var D = this.options && this.options.itemsPerPage ? this.options.itemsPerPage : this.itemsPerPage, _ = this.sanitizedFooterProps.itemsPerPageOptions;
                  if (_ && !_.find(function(B) {
                    return typeof B == "number" ? B === D : B.value === D;
                  })) {
                    var w = _[0];
                    return P(w) === "object" ? w.value : w;
                  }
                  return D;
                },
                groupByText: function() {
                  var D = this, _, w, B;
                  return (B = (w = (_ = this.headers) === null || _ === void 0 ? void 0 : _.find(function(j) {
                    var k;
                    return j.value === ((k = D.internalGroupBy) === null || k === void 0 ? void 0 : k[0]);
                  })) === null || w === void 0 ? void 0 : w.text) !== null && B !== void 0 ? B : "";
                }
              },
              created: function() {
                var D = this, _ = [["sort-icon", "header-props.sort-icon"], ["hide-headers", "hide-default-header"], ["select-all", "show-select"]];
                _.forEach(function(w) {
                  var B = O(w, 2), j = B[0], k = B[1];
                  D.$attrs.hasOwnProperty(j) && Object(x.breaking)(j, k, D);
                });
              },
              mounted: function() {
                this.calculateWidths && (window.addEventListener("resize", this.calcWidths), this.calcWidths());
              },
              beforeDestroy: function() {
                this.calculateWidths && window.removeEventListener("resize", this.calcWidths);
              },
              methods: {
                calcWidths: function() {
                  this.widths = Array.from(this.$el.querySelectorAll("th")).map(function(D) {
                    return D.clientWidth;
                  });
                },
                customFilterWithColumns: function(D, _) {
                  return L(D, _, this.headersWithCustomFilters, this.headersWithoutCustomFilters, this.customFilter, this.filterMode);
                },
                customSortWithHeaders: function(D, _, w, B) {
                  return this.customSort(D, _, w, B, this.columnSorters);
                },
                createItemProps: function(D, _) {
                  var w = this, B = T(T({}, o.VDataIterator.options.methods.createItemProps.call(this, D, _)), {
                    headers: this.computedHeaders
                  });
                  return T(T({}, B), {
                    attrs: {
                      class: {
                        "v-data-table__selected": B.isSelected
                      }
                    },
                    on: T(T({}, this.getDefaultMouseEventHandlers(":row", function() {
                      return B;
                    }, !0)), {
                      // TODO: the first argument should be the event, and the second argument should be data,
                      // but this is a breaking change so it's for v3
                      click: function(k) {
                        return w.$emit("click:row", D, B, k);
                      }
                    })
                  });
                },
                genCaption: function(D) {
                  return this.caption ? [this.$createElement("caption", [this.caption])] : Object(C.getSlot)(this, "caption", D, !0);
                },
                genColgroup: function(D) {
                  var _ = this;
                  return this.$createElement("colgroup", this.computedHeaders.map(function(w) {
                    return _.$createElement("col", {
                      class: {
                        divider: w.divider
                      }
                    });
                  }));
                },
                genLoading: function() {
                  var D = this.$createElement("th", {
                    staticClass: "column",
                    attrs: this.colspanAttrs
                  }, [this.genProgress()]), _ = this.$createElement("tr", {
                    staticClass: "v-data-table__progress"
                  }, [D]);
                  return this.$createElement("thead", [_]);
                },
                genHeaders: function(D) {
                  var _ = {
                    props: T(T({}, this.sanitizedHeaderProps), {
                      headers: this.computedHeaders,
                      options: D.options,
                      mobile: this.isMobile,
                      showGroupBy: this.showGroupBy,
                      checkboxColor: this.checkboxColor,
                      someItems: this.someItems,
                      everyItem: this.everyItem,
                      singleSelect: this.singleSelect,
                      disableSort: this.disableSort
                    }),
                    on: {
                      sort: D.sort,
                      group: D.group,
                      "toggle-select-all": this.toggleSelectAll
                    }
                  }, w = [Object(C.getSlot)(this, "header", T(T({}, _), {
                    isMobile: this.isMobile
                  }))];
                  if (!this.hideDefaultHeader) {
                    var B = Object(C.getPrefixedScopedSlots)("header.", this.$scopedSlots);
                    w.push(this.$createElement(f.default, T(T({}, _), {
                      scopedSlots: B
                    })));
                  }
                  return this.loading && w.push(this.genLoading()), w;
                },
                genEmptyWrapper: function(D) {
                  return this.$createElement("tr", {
                    staticClass: "v-data-table__empty-wrapper"
                  }, [this.$createElement("td", {
                    attrs: this.colspanAttrs
                  }, D)]);
                },
                genItems: function(D, _) {
                  var w = this.genEmpty(_.originalItemsLength, _.pagination.itemsLength);
                  return w ? [w] : _.groupedItems ? this.genGroupedRows(_.groupedItems, _) : this.genRows(D, _);
                },
                genGroupedRows: function(D, _) {
                  var w = this;
                  return D.map(function(B) {
                    return w.openCache.hasOwnProperty(B.name) || w.$set(w.openCache, B.name, !0), w.$scopedSlots.group ? w.$scopedSlots.group({
                      group: B.name,
                      options: _.options,
                      isMobile: w.isMobile,
                      items: B.items,
                      headers: w.computedHeaders
                    }) : w.genDefaultGroupedRow(B.name, B.items, _);
                  });
                },
                genDefaultGroupedRow: function(D, _, w) {
                  var B = this, j = !!this.openCache[D], k = [this.$createElement("template", {
                    slot: "row.content"
                  }, this.genRows(_, w))], X = function() {
                    return B.$set(B.openCache, D, !B.openCache[D]);
                  }, rt = function() {
                    return w.updateOptions({
                      groupBy: [],
                      groupDesc: []
                    });
                  };
                  if (this.$scopedSlots["group.header"])
                    k.unshift(this.$createElement("template", {
                      slot: "column.header"
                    }, [this.$scopedSlots["group.header"]({
                      group: D,
                      groupBy: w.options.groupBy,
                      isMobile: this.isMobile,
                      items: _,
                      headers: this.computedHeaders,
                      isOpen: j,
                      toggle: X,
                      remove: rt
                    })]));
                  else {
                    var et = this.$createElement(l.default, {
                      staticClass: "ma-0",
                      props: {
                        icon: !0,
                        small: !0
                      },
                      on: {
                        click: X
                      }
                    }, [this.$createElement(d.default, [j ? "$minus" : "$plus"])]), Z = this.$createElement(l.default, {
                      staticClass: "ma-0",
                      props: {
                        icon: !0,
                        small: !0
                      },
                      on: {
                        click: rt
                      }
                    }, [this.$createElement(d.default, ["$close"])]), dt = this.$createElement("td", {
                      staticClass: "text-start",
                      attrs: this.colspanAttrs
                    }, [et, this.groupByText + ": " + D, Z]);
                    k.unshift(this.$createElement("template", {
                      slot: "column.header"
                    }, [dt]));
                  }
                  return this.$scopedSlots["group.summary"] && k.push(this.$createElement("template", {
                    slot: "column.summary"
                  }, [this.$scopedSlots["group.summary"]({
                    group: D,
                    groupBy: w.options.groupBy,
                    isMobile: this.isMobile,
                    items: _,
                    headers: this.computedHeaders,
                    isOpen: j,
                    toggle: X
                  })])), this.$createElement(c.default, {
                    key: D,
                    props: {
                      value: j
                    }
                  }, k);
                },
                genRows: function(D, _) {
                  return this.$scopedSlots.item ? this.genScopedRows(D, _) : this.genDefaultRows(D, _);
                },
                genScopedRows: function(D, _) {
                  for (var w = [], B = 0; B < D.length; B++) {
                    var j = D[B];
                    w.push(this.$scopedSlots.item(T(T({}, this.createItemProps(j, B)), {
                      isMobile: this.isMobile
                    }))), this.isExpanded(j) && w.push(this.$scopedSlots["expanded-item"]({
                      headers: this.computedHeaders,
                      isMobile: this.isMobile,
                      index: B,
                      item: j
                    }));
                  }
                  return w;
                },
                genDefaultRows: function(D, _) {
                  var w = this;
                  return this.$scopedSlots["expanded-item"] ? D.map(function(B, j) {
                    return w.genDefaultExpandedRow(B, j);
                  }) : D.map(function(B, j) {
                    return w.genDefaultSimpleRow(B, j);
                  });
                },
                genDefaultExpandedRow: function(D, _) {
                  var w = this.isExpanded(D), B = {
                    "v-data-table__expanded v-data-table__expanded__row": w
                  }, j = this.genDefaultSimpleRow(D, _, B), k = this.$createElement("tr", {
                    staticClass: "v-data-table__expanded v-data-table__expanded__content"
                  }, [this.$scopedSlots["expanded-item"]({
                    headers: this.computedHeaders,
                    isMobile: this.isMobile,
                    item: D
                  })]);
                  return this.$createElement(c.default, {
                    props: {
                      value: w
                    }
                  }, [this.$createElement("template", {
                    slot: "row.header"
                  }, [j]), this.$createElement("template", {
                    slot: "row.content"
                  }, [k])]);
                },
                genDefaultSimpleRow: function(D, _, w) {
                  var B = this;
                  w === void 0 && (w = {});
                  var j = Object(C.getPrefixedScopedSlots)("item.", this.$scopedSlots), k = this.createItemProps(D, _);
                  if (this.showSelect) {
                    var X = j["data-table-select"];
                    j["data-table-select"] = X ? function() {
                      return X(T(T({}, k), {
                        isMobile: B.isMobile
                      }));
                    } : function() {
                      var et;
                      return B.$createElement(h.default, {
                        staticClass: "v-data-table__checkbox",
                        props: {
                          value: k.isSelected,
                          disabled: !B.isSelectable(D),
                          color: (et = B.checkboxColor) !== null && et !== void 0 ? et : ""
                        },
                        on: {
                          input: function(dt) {
                            return k.select(dt);
                          }
                        }
                      });
                    };
                  }
                  if (this.showExpand) {
                    var rt = j["data-table-expand"];
                    j["data-table-expand"] = rt ? function() {
                      return rt(k);
                    } : function() {
                      return B.$createElement(d.default, {
                        staticClass: "v-data-table__expand-icon",
                        class: {
                          "v-data-table__expand-icon--active": k.isExpanded
                        },
                        on: {
                          click: function(Z) {
                            Z.stopPropagation(), k.expand(!k.isExpanded);
                          }
                        }
                      }, [B.expandIcon]);
                    };
                  }
                  return this.$createElement(this.isMobile ? g.default : u.default, {
                    key: Object(C.getObjectValueByPath)(D, this.itemKey),
                    class: Object(b.mergeClasses)(T(T({}, w), {
                      "v-data-table__selected": k.isSelected
                    }), Object(C.getPropertyFromItem)(D, this.itemClass)),
                    style: Object(b.mergeStyles)({}, Object(C.getPropertyFromItem)(D, this.itemStyle)),
                    props: {
                      headers: this.computedHeaders,
                      hideDefaultHeader: this.hideDefaultHeader,
                      index: _,
                      item: D,
                      rtl: this.$vuetify.rtl
                    },
                    scopedSlots: j,
                    on: k.on
                  });
                },
                genBody: function(D) {
                  var _ = T(T({}, D), {
                    expand: this.expand,
                    headers: this.computedHeaders,
                    isExpanded: this.isExpanded,
                    isMobile: this.isMobile,
                    isSelected: this.isSelected,
                    select: this.select
                  });
                  return this.$scopedSlots.body ? this.$scopedSlots.body(_) : this.$createElement("tbody", [Object(C.getSlot)(this, "body.prepend", _, !0), this.genItems(D.items, D), Object(C.getSlot)(this, "body.append", _, !0)]);
                },
                genFoot: function(D) {
                  var _, w;
                  return (w = (_ = this.$scopedSlots).foot) === null || w === void 0 ? void 0 : w.call(_, D);
                },
                genFooters: function(D) {
                  var _ = {
                    props: T({
                      options: D.options,
                      pagination: D.pagination,
                      itemsPerPageText: "$vuetify.dataTable.itemsPerPageText"
                    }, this.sanitizedFooterProps),
                    on: {
                      "update:options": function(j) {
                        return D.updateOptions(j);
                      }
                    },
                    widths: this.widths,
                    headers: this.computedHeaders
                  }, w = [Object(C.getSlot)(this, "footer", _, !0)];
                  return this.hideDefaultFooter || w.push(this.$createElement(o.VDataFooter, T(T({}, _), {
                    scopedSlots: Object(C.getPrefixedScopedSlots)("footer.", this.$scopedSlots)
                  }))), w;
                },
                genDefaultScopedSlot: function(D) {
                  var _ = {
                    height: this.height,
                    fixedHeader: this.fixedHeader,
                    dense: this.dense
                  };
                  return this.$createElement(p.default, {
                    props: _,
                    class: {
                      "v-data-table--mobile": this.isMobile,
                      "v-data-table--selectable": this.showSelect
                    }
                  }, [this.proxySlot("top", Object(C.getSlot)(this, "top", T(T({}, D), {
                    isMobile: this.isMobile
                  }), !0)), this.genCaption(D), this.genColgroup(D), this.genHeaders(D), this.genBody(D), this.genFoot(D), this.proxySlot("bottom", this.genFooters(D))]);
                },
                proxySlot: function(D, _) {
                  return this.$createElement("template", {
                    slot: D
                  }, _);
                }
              },
              render: function() {
                var D = this;
                return this.$createElement(a.VData, {
                  props: T(T({}, this.$props), {
                    customFilter: this.customFilterWithColumns,
                    customSort: this.customSortWithHeaders,
                    itemsPerPage: this.computedItemsPerPage
                  }),
                  on: {
                    "update:options": function(w, B) {
                      D.internalGroupBy = w.groupBy || [], !Object(C.deepEqual)(w, B) && D.$emit("update:options", w);
                    },
                    "update:page": function(w) {
                      return D.$emit("update:page", w);
                    },
                    "update:items-per-page": function(w) {
                      return D.$emit("update:items-per-page", w);
                    },
                    "update:sort-by": function(w) {
                      return D.$emit("update:sort-by", w);
                    },
                    "update:sort-desc": function(w) {
                      return D.$emit("update:sort-desc", w);
                    },
                    "update:group-by": function(w) {
                      return D.$emit("update:group-by", w);
                    },
                    "update:group-desc": function(w) {
                      return D.$emit("update:group-desc", w);
                    },
                    pagination: function(w, B) {
                      return !Object(C.deepEqual)(w, B) && D.$emit("pagination", w);
                    },
                    "current-items": function(w) {
                      D.internalCurrentItems = w, D.$emit("current-items", w);
                    },
                    "page-count": function(w) {
                      return D.$emit("page-count", w);
                    }
                  },
                  scopedSlots: {
                    default: this.genDefaultScopedSlot
                  }
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeader.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeader.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeader.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeader.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataTableHeader.sass */
              "./src/components/VDataTable/VDataTableHeader.sass"
            );
            var a = i(
              /*! ./VDataTableHeaderMobile */
              "./src/components/VDataTable/VDataTableHeaderMobile.ts"
            ), o = i(
              /*! ./VDataTableHeaderDesktop */
              "./src/components/VDataTable/VDataTableHeaderDesktop.ts"
            ), l = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), f = i(
              /*! ../../util/dedupeModelListeners */
              "./src/util/dedupeModelListeners.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = i(
              /*! ../../util/rebuildFunctionalSlots */
              "./src/util/rebuildFunctionalSlots.ts"
            ), c = i(
              /*! vue */
              "vue"
            ), h = /* @__PURE__ */ i.n(c), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = h.a.extend({
              name: "v-data-table-header",
              functional: !0,
              props: p(p({}, l.default.options.props), {
                mobile: Boolean
              }),
              render: function(m, v) {
                var y = v.props, E = v.data, C = v.slots;
                Object(f.default)(E);
                var x = Object(u.default)(C(), m);
                return E = Object(d.default)(E, {
                  props: y
                }), y.mobile ? m(a.default, E, x) : m(o.default, E, x);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeaderDesktop.ts": (
          /*!**************************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeaderDesktop.ts ***!
            \**************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = Object(a.default)(o.default).extend({
              name: "v-data-table-header-desktop",
              methods: {
                genGroupByToggle: function(c) {
                  var h = this;
                  return this.$createElement("span", {
                    on: {
                      click: function(g) {
                        g.stopPropagation(), h.$emit("group", c.value);
                      }
                    }
                  }, ["group"]);
                },
                getAria: function(c, h) {
                  var p = this, g = function(E) {
                    return p.$vuetify.lang.t("$vuetify.dataTable.ariaLabel." + E);
                  }, m = "none", v = [g("sortNone"), g("activateAscending")];
                  return c ? (h ? (m = "descending", v = [g("sortDescending"), g(this.options.mustSort ? "activateAscending" : "activateNone")]) : (m = "ascending", v = [g("sortAscending"), g("activateDescending")]), {
                    ariaSort: m,
                    ariaLabel: v.join(" ")
                  }) : {
                    ariaSort: m,
                    ariaLabel: v.join(" ")
                  };
                },
                genHeader: function(c) {
                  var h = this, p = {
                    attrs: {
                      role: "columnheader",
                      scope: "col",
                      "aria-label": c.text || ""
                    },
                    style: {
                      width: Object(l.convertToUnit)(c.width),
                      minWidth: Object(l.convertToUnit)(c.width)
                    },
                    class: d(d(["text-" + (c.align || "start")], f(Object(l.wrapInArray)(c.class)), !1), [c.divider && "v-data-table__divider"], !1),
                    on: {}
                  }, g = [];
                  if (c.value === "data-table-select" && !this.singleSelect)
                    return this.$createElement("th", p, [this.genSelectAll()]);
                  if (g.push(this.$scopedSlots.hasOwnProperty(c.value) ? this.$scopedSlots[c.value]({
                    header: c
                  }) : this.$createElement("span", [c.text])), !this.disableSort && (c.sortable || !c.hasOwnProperty("sortable"))) {
                    p.on.click = function() {
                      return h.$emit("sort", c.value);
                    };
                    var m = this.options.sortBy.findIndex(function(b) {
                      return b === c.value;
                    }), v = m >= 0, y = this.options.sortDesc[m];
                    p.class.push("sortable");
                    var E = this.getAria(v, y), C = E.ariaLabel, x = E.ariaSort;
                    p.attrs["aria-label"] += (c.text ? ": " : "") + C, p.attrs["aria-sort"] = x, v && (p.class.push("active"), p.class.push(y ? "desc" : "asc")), c.align === "end" ? g.unshift(this.genSortIcon()) : g.push(this.genSortIcon()), this.options.multiSort && v && g.push(this.$createElement("span", {
                      class: "v-data-table-header__sort-badge"
                    }, [String(m + 1)]));
                  }
                  return this.showGroupBy && c.groupable !== !1 && g.push(this.genGroupByToggle(c)), this.$createElement("th", p, g);
                }
              },
              render: function() {
                var c = this;
                return this.$createElement("thead", {
                  staticClass: "v-data-table-header"
                }, [this.$createElement("tr", this.headers.map(function(h) {
                  return c.genHeader(h);
                }))]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeaderMobile.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeaderMobile.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), l = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), f = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            }, c = function(h, p, g) {
              if (g || arguments.length === 2)
                for (var m = 0, v = p.length, y; m < v; m++)
                  (y || !(m in p)) && (y || (y = Array.prototype.slice.call(p, 0, m)), y[m] = p[m]);
              return h.concat(y || Array.prototype.slice.call(p));
            };
            r.default = Object(a.default)(f.default).extend({
              name: "v-data-table-header-mobile",
              props: {
                sortByText: {
                  type: String,
                  default: "$vuetify.dataTable.sortBy"
                }
              },
              methods: {
                genSortChip: function(p) {
                  var g = this, m = [p.item.text], v = this.options.sortBy.findIndex(function(C) {
                    return C === p.item.value;
                  }), y = v >= 0, E = this.options.sortDesc[v];
                  return m.push(this.$createElement("div", {
                    staticClass: "v-chip__close",
                    class: {
                      sortable: !0,
                      active: y,
                      asc: y && !E,
                      desc: y && E
                    }
                  }, [this.genSortIcon()])), this.$createElement(l.default, {
                    staticClass: "sortable",
                    on: {
                      click: function(x) {
                        x.stopPropagation(), g.$emit("sort", p.item.value);
                      }
                    }
                  }, m);
                },
                genSortSelect: function(p) {
                  var g = this;
                  return this.$createElement(o.default, {
                    props: {
                      label: this.$vuetify.lang.t(this.sortByText),
                      items: p,
                      hideDetails: !0,
                      multiple: this.options.multiSort,
                      value: this.options.multiSort ? this.options.sortBy : this.options.sortBy[0],
                      menuProps: {
                        closeOnContentClick: !0
                      }
                    },
                    on: {
                      change: function(v) {
                        return g.$emit("sort", v);
                      }
                    },
                    scopedSlots: {
                      selection: function(v) {
                        return g.genSortChip(v);
                      }
                    }
                  });
                }
              },
              render: function(p) {
                var g = [], m = this.headers.find(function(C) {
                  return C.value === "data-table-select";
                });
                m && !this.singleSelect && g.push(this.$createElement("div", {
                  class: c(["v-data-table-header-mobile__select"], u(Object(d.wrapInArray)(m.class)), !1),
                  attrs: {
                    width: m.width
                  }
                }, [this.genSelectAll()]));
                var v = this.headers.filter(function(C) {
                  return C.sortable !== !1 && C.value !== "data-table-select";
                }).map(function(C) {
                  return {
                    text: C.text,
                    value: C.value
                  };
                });
                !this.disableSort && v.length && g.push(this.genSortSelect(v));
                var y = g.length ? p("th", [p("div", {
                  staticClass: "v-data-table-header-mobile__wrapper"
                }, g)]) : void 0, E = p("tr", [y]);
                return p("thead", {
                  staticClass: "v-data-table-header v-data-table-header-mobile"
                }, [E]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VEditDialog.sass": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/VEditDialog.sass ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VEditDialog.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VDataTable/VEditDialog.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VEditDialog.sass */
              "./src/components/VDataTable/VEditDialog.sass"
            );
            var a = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), d = i(
              /*! ../VMenu */
              "./src/components/VMenu/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(u.default)(a.default, o.default).extend({
              name: "v-edit-dialog",
              props: {
                cancelText: {
                  default: "Cancel"
                },
                large: Boolean,
                eager: Boolean,
                persistent: Boolean,
                saveText: {
                  default: "Save"
                },
                transition: {
                  type: String,
                  default: "slide-x-reverse-transition"
                }
              },
              data: function() {
                return {
                  isActive: !1
                };
              },
              watch: {
                isActive: function(h) {
                  h ? (this.$emit("open"), setTimeout(this.focus, 50)) : this.$emit("close");
                }
              },
              methods: {
                cancel: function() {
                  this.isActive = !1, this.$emit("cancel");
                },
                focus: function() {
                  var h = this.$refs.content.querySelector("input");
                  h && h.focus();
                },
                genButton: function(h, p) {
                  return this.$createElement(f.default, {
                    props: {
                      text: !0,
                      color: "primary",
                      light: !0
                    },
                    on: {
                      click: h
                    }
                  }, p);
                },
                genActions: function() {
                  var h = this;
                  return this.$createElement("div", {
                    class: "v-small-dialog__actions"
                  }, [this.genButton(this.cancel, this.cancelText), this.genButton(function() {
                    h.save(h.returnValue), h.$emit("save");
                  }, this.saveText)]);
                },
                genContent: function() {
                  var h = this;
                  return this.$createElement("div", {
                    staticClass: "v-small-dialog__content",
                    on: {
                      keydown: function(g) {
                        g.keyCode === l.keyCodes.esc && h.cancel(), g.keyCode === l.keyCodes.enter && (h.save(h.returnValue), h.$emit("save"));
                      }
                    },
                    ref: "content"
                  }, [this.$slots.input]);
                }
              },
              render: function(h) {
                var p = this;
                return h(d.default, {
                  staticClass: "v-small-dialog",
                  class: this.themeClasses,
                  props: {
                    contentClass: "v-small-dialog__menu-content",
                    transition: this.transition,
                    origin: "top right",
                    right: !0,
                    value: this.isActive,
                    closeOnClick: !this.persistent,
                    closeOnContentClick: !1,
                    eager: this.eager,
                    light: this.light,
                    dark: this.dark
                  },
                  on: {
                    input: function(m) {
                      return p.isActive = m;
                    }
                  },
                  scopedSlots: {
                    activator: function(m) {
                      var v = m.on;
                      return h("div", {
                        staticClass: "v-small-dialog__activator",
                        on: v
                      }, [h("span", {
                        staticClass: "v-small-dialog__activator__content"
                      }, p.$slots.default)]);
                    }
                  }
                }, [this.genContent(), this.large ? this.genActions() : null]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VSimpleTable.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VDataTable/VSimpleTable.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VSimpleTable.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VDataTable/VSimpleTable.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSimpleTable.sass */
              "./src/components/VDataTable/VSimpleTable.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(o.default).extend({
              name: "v-simple-table",
              props: {
                dense: Boolean,
                fixedHeader: Boolean,
                height: [Number, String]
              },
              computed: {
                classes: function() {
                  return f({
                    "v-data-table--dense": this.dense,
                    "v-data-table--fixed-height": !!this.height && !this.fixedHeader,
                    "v-data-table--fixed-header": this.fixedHeader,
                    "v-data-table--has-top": !!this.$slots.top,
                    "v-data-table--has-bottom": !!this.$slots.bottom
                  }, this.themeClasses);
                }
              },
              methods: {
                genWrapper: function() {
                  return this.$slots.wrapper || this.$createElement("div", {
                    staticClass: "v-data-table__wrapper",
                    style: {
                      height: Object(a.convertToUnit)(this.height)
                    }
                  }, [this.$createElement("table", this.$slots.default)]);
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-data-table",
                  class: this.classes
                }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VVirtualTable.sass": (
          /*!******************************************************!*\
            !*** ./src/components/VDataTable/VVirtualTable.sass ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VVirtualTable.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/VVirtualTable.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VVirtualTable.sass */
              "./src/components/VDataTable/VVirtualTable.sass"
            );
            var a = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = Object(o.default)(a.default);
            r.default = f.extend().extend({
              name: "v-virtual-table",
              props: {
                chunkSize: {
                  type: Number,
                  default: 25
                },
                headerHeight: {
                  type: Number,
                  default: 48
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                rowHeight: {
                  type: Number,
                  default: 48
                }
              },
              data: function() {
                return {
                  scrollTop: 0,
                  oldChunk: 0,
                  scrollDebounce: null,
                  invalidateCache: !1
                };
              },
              computed: {
                itemsLength: function() {
                  return this.items.length;
                },
                totalHeight: function() {
                  return this.itemsLength * this.rowHeight + this.headerHeight;
                },
                topIndex: function() {
                  return Math.floor(this.scrollTop / this.rowHeight);
                },
                chunkIndex: function() {
                  return Math.floor(this.topIndex / this.chunkSize);
                },
                startIndex: function() {
                  return Math.max(0, this.chunkIndex * this.chunkSize - this.chunkSize);
                },
                offsetTop: function() {
                  return Math.max(0, this.startIndex * this.rowHeight);
                },
                stopIndex: function() {
                  return Math.min(this.startIndex + this.chunkSize * 3, this.itemsLength);
                },
                offsetBottom: function() {
                  return Math.max(0, (this.itemsLength - this.stopIndex - this.startIndex) * this.rowHeight);
                }
              },
              watch: {
                chunkIndex: function(u, c) {
                  this.oldChunk = c;
                },
                items: function() {
                  this.cachedItems = null, this.$refs.table.scrollTop = 0;
                }
              },
              created: function() {
                this.cachedItems = null;
              },
              mounted: function() {
                this.scrollDebounce = Object(l.debounce)(this.onScroll, 50), this.$refs.table.addEventListener("scroll", this.scrollDebounce, {
                  passive: !0
                });
              },
              beforeDestroy: function() {
                this.$refs.table.removeEventListener("scroll", this.scrollDebounce);
              },
              methods: {
                createStyleHeight: function(u) {
                  return {
                    height: u + "px"
                  };
                },
                genBody: function() {
                  return (this.cachedItems === null || this.chunkIndex !== this.oldChunk) && (this.cachedItems = this.genItems(), this.oldChunk = this.chunkIndex), this.$createElement("tbody", [this.$createElement("tr", {
                    style: this.createStyleHeight(this.offsetTop)
                  }), this.cachedItems, this.$createElement("tr", {
                    style: this.createStyleHeight(this.offsetBottom)
                  })]);
                },
                genItems: function() {
                  return this.$scopedSlots.items({
                    items: this.items.slice(this.startIndex, this.stopIndex)
                  });
                },
                onScroll: function(u) {
                  var c = u.target;
                  this.scrollTop = c.scrollTop;
                },
                genTable: function() {
                  return this.$createElement("div", {
                    ref: "table",
                    staticClass: "v-virtual-table__table"
                  }, [this.$createElement("table", [this.$slots["body.before"], this.genBody(), this.$slots["body.after"]])]);
                },
                genWrapper: function() {
                  return this.$createElement("div", {
                    staticClass: "v-virtual-table__wrapper",
                    style: {
                      height: Object(l.convertToUnit)(this.height)
                    }
                  }, [this.genTable()]);
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-data-table v-virtual-table",
                  class: this.classes
                }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VDataTable/index.ts ***!
            \********************************************/
          /*! exports provided: VDataTable, VEditDialog, VTableOverflow, VDataTableHeader, VSimpleTable, VVirtualTable, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VTableOverflow", function() {
              return c;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VDataTable */
              "./src/components/VDataTable/VDataTable.ts"
            );
            i.d(r, "VDataTable", function() {
              return o.default;
            });
            var l = i(
              /*! ./VDataTableHeader */
              "./src/components/VDataTable/VDataTableHeader.ts"
            );
            i.d(r, "VDataTableHeader", function() {
              return l.default;
            });
            var f = i(
              /*! ./VEditDialog */
              "./src/components/VDataTable/VEditDialog.ts"
            );
            i.d(r, "VEditDialog", function() {
              return f.default;
            });
            var d = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            );
            i.d(r, "VSimpleTable", function() {
              return d.default;
            });
            var u = i(
              /*! ./VVirtualTable */
              "./src/components/VDataTable/VVirtualTable.ts"
            );
            i.d(r, "VVirtualTable", function() {
              return u.default;
            });
            var c = Object(a.createSimpleFunctional)("v-table__overflow");
            r.default = {
              $_vuetify_subcomponents: {
                VDataTable: o.default,
                VDataTableHeader: l.default,
                VEditDialog: f.default,
                VTableOverflow: c,
                VSimpleTable: d.default,
                VVirtualTable: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDataTable/mixins/header.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/mixins/header.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), l = i(
              /*! ../../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)().extend({
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: l.default
              },
              props: {
                headers: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                options: {
                  type: Object,
                  default: function() {
                    return {
                      page: 1,
                      itemsPerPage: 10,
                      sortBy: [],
                      sortDesc: [],
                      groupBy: [],
                      groupDesc: [],
                      multiSort: !1,
                      mustSort: !1
                    };
                  }
                },
                checkboxColor: String,
                sortIcon: {
                  type: String,
                  default: "$sort"
                },
                everyItem: Boolean,
                someItems: Boolean,
                showGroupBy: Boolean,
                singleSelect: Boolean,
                disableSort: Boolean
              },
              methods: {
                genSelectAll: function() {
                  var c = this, h, p = {
                    props: {
                      value: this.everyItem,
                      indeterminate: !this.everyItem && this.someItems,
                      color: (h = this.checkboxColor) !== null && h !== void 0 ? h : ""
                    },
                    on: {
                      input: function(m) {
                        return c.$emit("toggle-select-all", m);
                      }
                    }
                  };
                  return this.$scopedSlots["data-table-select"] ? this.$scopedSlots["data-table-select"](p) : this.$createElement(o.default, d({
                    staticClass: "v-data-table__checkbox"
                  }, p));
                },
                genSortIcon: function() {
                  return this.$createElement(a.default, {
                    staticClass: "v-data-table-header__icon",
                    props: {
                      size: 18
                    }
                  }, [this.sortIcon]);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePicker.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VDatePicker/VDatePicker.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDatePickerTitle */
              "./src/components/VDatePicker/VDatePickerTitle.ts"
            ), o = i(
              /*! ./VDatePickerHeader */
              "./src/components/VDatePicker/VDatePickerHeader.ts"
            ), l = i(
              /*! ./VDatePickerDateTable */
              "./src/components/VDatePicker/VDatePickerDateTable.ts"
            ), f = i(
              /*! ./VDatePickerMonthTable */
              "./src/components/VDatePicker/VDatePickerMonthTable.ts"
            ), d = i(
              /*! ./VDatePickerYears */
              "./src/components/VDatePicker/VDatePickerYears.ts"
            ), u = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), c = i(
              /*! ../../mixins/picker */
              "./src/mixins/picker/index.ts"
            ), h = i(
              /*! ./util/isDateAllowed */
              "./src/components/VDatePicker/util/isDateAllowed.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../VCalendar/util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), E = function() {
              return E = Object.assign || function(x) {
                for (var b, P = 1, T = arguments.length; P < T; P++) {
                  b = arguments[P];
                  for (var O in b)
                    Object.prototype.hasOwnProperty.call(b, O) && (x[O] = b[O]);
                }
                return x;
              }, E.apply(this, arguments);
            }, C = function(x, b) {
              var P = typeof Symbol == "function" && x[Symbol.iterator];
              if (!P)
                return x;
              var T = P.call(x), O, S = [], L;
              try {
                for (; (b === void 0 || b-- > 0) && !(O = T.next()).done; )
                  S.push(O.value);
              } catch (A) {
                L = {
                  error: A
                };
              } finally {
                try {
                  O && !O.done && (P = T.return) && P.call(T);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return S;
            };
            r.default = Object(p.default)(u.default, c.default).extend({
              name: "v-date-picker",
              props: {
                activePicker: String,
                allowedDates: Function,
                // Function formatting the day in date picker table
                dayFormat: Function,
                disabled: Boolean,
                events: {
                  type: [Array, Function, Object],
                  default: function() {
                    return null;
                  }
                },
                eventColor: {
                  type: [Array, Function, Object, String],
                  default: function() {
                    return "warning";
                  }
                },
                firstDayOfWeek: {
                  type: [String, Number],
                  default: 0
                },
                // Function formatting the tableDate in the day/month table header
                headerDateFormat: Function,
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                max: String,
                min: String,
                // Function formatting month in the months table
                monthFormat: Function,
                multiple: Boolean,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                nextMonthAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.nextMonthAriaLabel"
                },
                nextYearAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.nextYearAriaLabel"
                },
                pickerDate: String,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                prevMonthAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.prevMonthAriaLabel"
                },
                prevYearAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.prevYearAriaLabel"
                },
                range: Boolean,
                reactive: Boolean,
                readonly: Boolean,
                scrollable: Boolean,
                showCurrent: {
                  type: [Boolean, String],
                  default: !0
                },
                selectedItemsText: {
                  type: String,
                  default: "$vuetify.datePicker.itemsSelected"
                },
                showAdjacentMonths: Boolean,
                showWeek: Boolean,
                // Function formatting currently selected date in the picker title
                titleDateFormat: Function,
                type: {
                  type: String,
                  default: "date",
                  validator: function(b) {
                    return ["date", "month"].includes(b);
                  }
                  // TODO: year
                },
                value: [Array, String],
                weekdayFormat: Function,
                // Function formatting the year in table header and pickup title
                yearFormat: Function,
                yearIcon: String
              },
              data: function() {
                var b = this, P = /* @__PURE__ */ new Date();
                return {
                  internalActivePicker: this.type.toUpperCase(),
                  inputDay: null,
                  inputMonth: null,
                  inputYear: null,
                  isReversing: !1,
                  now: P,
                  // tableDate is a string in 'YYYY' / 'YYYY-M' format (leading zero for month is not required)
                  tableDate: function() {
                    if (b.pickerDate)
                      return b.pickerDate;
                    var T = Object(g.wrapInArray)(b.value), O = T[T.length - 1] || (typeof b.showCurrent == "string" ? b.showCurrent : P.getFullYear() + "-" + (P.getMonth() + 1));
                    return Object(y.sanitizeDateString)(O, b.type === "date" ? "month" : "year");
                  }()
                };
              },
              computed: {
                multipleValue: function() {
                  return Object(g.wrapInArray)(this.value);
                },
                isMultiple: function() {
                  return this.multiple || this.range;
                },
                lastValue: function() {
                  return this.isMultiple ? this.multipleValue[this.multipleValue.length - 1] : this.value;
                },
                selectedMonths: function() {
                  return !this.value || this.type === "month" ? this.value : this.isMultiple ? this.multipleValue.map(function(b) {
                    return b.substr(0, 7);
                  }) : this.value.substr(0, 7);
                },
                current: function() {
                  return this.showCurrent === !0 ? Object(y.sanitizeDateString)(this.now.getFullYear() + "-" + (this.now.getMonth() + 1) + "-" + this.now.getDate(), this.type) : this.showCurrent || null;
                },
                inputDate: function() {
                  return this.type === "date" ? this.inputYear + "-" + Object(y.pad)(this.inputMonth + 1) + "-" + Object(y.pad)(this.inputDay) : this.inputYear + "-" + Object(y.pad)(this.inputMonth + 1);
                },
                tableMonth: function() {
                  return Number((this.pickerDate || this.tableDate).split("-")[1]) - 1;
                },
                tableYear: function() {
                  return Number((this.pickerDate || this.tableDate).split("-")[0]);
                },
                minMonth: function() {
                  return this.min ? Object(y.sanitizeDateString)(this.min, "month") : null;
                },
                maxMonth: function() {
                  return this.max ? Object(y.sanitizeDateString)(this.max, "month") : null;
                },
                minYear: function() {
                  return this.min ? Object(y.sanitizeDateString)(this.min, "year") : null;
                },
                maxYear: function() {
                  return this.max ? Object(y.sanitizeDateString)(this.max, "year") : null;
                },
                formatters: function() {
                  return {
                    year: this.yearFormat || Object(y.createNativeLocaleFormatter)(this.currentLocale, {
                      year: "numeric",
                      timeZone: "UTC"
                    }, {
                      length: 4
                    }),
                    titleDate: this.titleDateFormat || (this.isMultiple ? this.defaultTitleMultipleDateFormatter : this.defaultTitleDateFormatter)
                  };
                },
                defaultTitleMultipleDateFormatter: function() {
                  var b = this;
                  return function(P) {
                    return P.length ? P.length === 1 ? b.defaultTitleDateFormatter(P[0]) : b.$vuetify.lang.t(b.selectedItemsText, P.length) : "-";
                  };
                },
                defaultTitleDateFormatter: function() {
                  var b = {
                    year: {
                      year: "numeric",
                      timeZone: "UTC"
                    },
                    month: {
                      month: "long",
                      timeZone: "UTC"
                    },
                    date: {
                      weekday: "short",
                      month: "short",
                      day: "numeric",
                      timeZone: "UTC"
                    }
                  }, P = Object(y.createNativeLocaleFormatter)(this.currentLocale, b[this.type], {
                    start: 0,
                    length: {
                      date: 10,
                      month: 7,
                      year: 4
                    }[this.type]
                  }), T = function(S) {
                    return P(S).replace(/([^\d\s])([\d])/g, function(L, A, D) {
                      return A + " " + D;
                    }).replace(", ", ",<br>");
                  };
                  return this.landscape ? T : P;
                }
              },
              watch: {
                internalActivePicker: {
                  immediate: !0,
                  handler: function(b) {
                    this.$emit("update:active-picker", b);
                  }
                },
                activePicker: function(b) {
                  this.internalActivePicker = b;
                },
                tableDate: function(b, P) {
                  var T = this.type === "month" ? "year" : "month";
                  this.isReversing = Object(y.sanitizeDateString)(b, T) < Object(y.sanitizeDateString)(P, T), this.$emit("update:picker-date", b);
                },
                pickerDate: function(b) {
                  b ? this.tableDate = b : this.lastValue && this.type === "date" ? this.tableDate = Object(y.sanitizeDateString)(this.lastValue, "month") : this.lastValue && this.type === "month" && (this.tableDate = Object(y.sanitizeDateString)(this.lastValue, "year"));
                },
                value: function(b, P) {
                  this.checkMultipleProp(), this.setInputDate(), (!this.isMultiple && this.value && !this.pickerDate || this.isMultiple && this.multipleValue.length && (!P || !P.length) && !this.pickerDate) && (this.tableDate = Object(y.sanitizeDateString)(this.inputDate, this.type === "month" ? "year" : "month"));
                },
                type: function(b) {
                  if (this.internalActivePicker = b.toUpperCase(), this.value && this.value.length) {
                    var P = this.multipleValue.map(function(T) {
                      return Object(y.sanitizeDateString)(T, b);
                    }).filter(this.isDateAllowed);
                    this.$emit("input", this.isMultiple ? P : P[0]);
                  }
                }
              },
              created: function() {
                this.checkMultipleProp(), this.pickerDate !== this.tableDate && this.$emit("update:picker-date", this.tableDate), this.setInputDate();
              },
              methods: {
                emitInput: function(b) {
                  if (this.range) {
                    if (this.multipleValue.length !== 1)
                      this.$emit("input", [b]);
                    else {
                      var P = [this.multipleValue[0], b];
                      this.$emit("input", P), this.$emit("change", P);
                    }
                    return;
                  }
                  var T = this.multiple ? this.multipleValue.indexOf(b) === -1 ? this.multipleValue.concat([b]) : this.multipleValue.filter(function(O) {
                    return O !== b;
                  }) : b;
                  this.$emit("input", T), this.multiple || this.$emit("change", b);
                },
                checkMultipleProp: function() {
                  if (this.value != null) {
                    var b = this.value.constructor.name, P = this.isMultiple ? "Array" : "String";
                    b !== P && Object(v.consoleWarn)("Value must be " + (this.isMultiple ? "an" : "a") + " " + P + ", got " + b, this);
                  }
                },
                isDateAllowed: function(b) {
                  return Object(h.default)(b, this.min, this.max, this.allowedDates);
                },
                yearClick: function(b) {
                  this.inputYear = b, this.type === "month" ? this.tableDate = "" + b : this.tableDate = b + "-" + Object(y.pad)((this.tableMonth || 0) + 1), this.internalActivePicker = "MONTH", this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate) && this.$emit("input", this.inputDate);
                },
                monthClick: function(b) {
                  var P = C(b.split("-"), 2), T = P[0], O = P[1];
                  this.inputYear = parseInt(T, 10), this.inputMonth = parseInt(O, 10) - 1, this.type === "date" ? (this.inputDay && (this.inputDay = Math.min(this.inputDay, Object(m.daysInMonth)(this.inputYear, this.inputMonth + 1))), this.tableDate = b, this.internalActivePicker = "DATE", this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate) && this.$emit("input", this.inputDate)) : this.emitInput(this.inputDate);
                },
                dateClick: function(b) {
                  var P = C(b.split("-"), 3), T = P[0], O = P[1], S = P[2];
                  this.inputYear = parseInt(T, 10), this.inputMonth = parseInt(O, 10) - 1, this.inputDay = parseInt(S, 10), this.emitInput(this.inputDate);
                },
                genPickerTitle: function() {
                  var b = this;
                  return this.$createElement(a.default, {
                    props: {
                      date: this.value ? this.formatters.titleDate(this.isMultiple ? this.multipleValue : this.value) : "",
                      disabled: this.disabled,
                      readonly: this.readonly,
                      selectingYear: this.internalActivePicker === "YEAR",
                      year: this.formatters.year(this.multipleValue.length ? "" + this.inputYear : this.tableDate),
                      yearIcon: this.yearIcon,
                      value: this.multipleValue[0]
                    },
                    slot: "title",
                    on: {
                      "update:selecting-year": function(T) {
                        return b.internalActivePicker = T ? "YEAR" : b.type.toUpperCase();
                      }
                    }
                  });
                },
                genTableHeader: function() {
                  var b = this;
                  return this.$createElement(o.default, {
                    props: {
                      nextIcon: this.nextIcon,
                      color: this.color,
                      dark: this.dark,
                      disabled: this.disabled,
                      format: this.headerDateFormat,
                      light: this.light,
                      locale: this.locale,
                      min: this.internalActivePicker === "DATE" ? this.minMonth : this.minYear,
                      max: this.internalActivePicker === "DATE" ? this.maxMonth : this.maxYear,
                      nextAriaLabel: this.internalActivePicker === "DATE" ? this.nextMonthAriaLabel : this.nextYearAriaLabel,
                      prevAriaLabel: this.internalActivePicker === "DATE" ? this.prevMonthAriaLabel : this.prevYearAriaLabel,
                      prevIcon: this.prevIcon,
                      readonly: this.readonly,
                      value: this.internalActivePicker === "DATE" ? Object(y.pad)(this.tableYear, 4) + "-" + Object(y.pad)(this.tableMonth + 1) : "" + Object(y.pad)(this.tableYear, 4)
                    },
                    on: {
                      toggle: function() {
                        return b.internalActivePicker = b.internalActivePicker === "DATE" ? "MONTH" : "YEAR";
                      },
                      input: function(T) {
                        return b.tableDate = T;
                      }
                    }
                  });
                },
                genDateTable: function() {
                  var b = this;
                  return this.$createElement(l.default, {
                    props: {
                      allowedDates: this.allowedDates,
                      color: this.color,
                      current: this.current,
                      dark: this.dark,
                      disabled: this.disabled,
                      events: this.events,
                      eventColor: this.eventColor,
                      firstDayOfWeek: this.firstDayOfWeek,
                      format: this.dayFormat,
                      light: this.light,
                      locale: this.locale,
                      localeFirstDayOfYear: this.localeFirstDayOfYear,
                      min: this.min,
                      max: this.max,
                      range: this.range,
                      readonly: this.readonly,
                      scrollable: this.scrollable,
                      showAdjacentMonths: this.showAdjacentMonths,
                      showWeek: this.showWeek,
                      tableDate: Object(y.pad)(this.tableYear, 4) + "-" + Object(y.pad)(this.tableMonth + 1),
                      value: this.value,
                      weekdayFormat: this.weekdayFormat
                    },
                    ref: "table",
                    on: E({
                      input: this.dateClick,
                      "update:table-date": function(T) {
                        return b.tableDate = T;
                      }
                    }, Object(y.createItemTypeListeners)(this, ":date"))
                  });
                },
                genMonthTable: function() {
                  var b = this;
                  return this.$createElement(f.default, {
                    props: {
                      allowedDates: this.type === "month" ? this.allowedDates : null,
                      color: this.color,
                      current: this.current ? Object(y.sanitizeDateString)(this.current, "month") : null,
                      dark: this.dark,
                      disabled: this.disabled,
                      events: this.type === "month" ? this.events : null,
                      eventColor: this.type === "month" ? this.eventColor : null,
                      format: this.monthFormat,
                      light: this.light,
                      locale: this.locale,
                      min: this.minMonth,
                      max: this.maxMonth,
                      range: this.range,
                      readonly: this.readonly && this.type === "month",
                      scrollable: this.scrollable,
                      value: this.selectedMonths,
                      tableDate: "" + Object(y.pad)(this.tableYear, 4)
                    },
                    ref: "table",
                    on: E({
                      input: this.monthClick,
                      "update:table-date": function(T) {
                        return b.tableDate = T;
                      }
                    }, Object(y.createItemTypeListeners)(this, ":month"))
                  });
                },
                genYears: function() {
                  return this.$createElement(d.default, {
                    props: {
                      color: this.color,
                      format: this.yearFormat,
                      locale: this.locale,
                      min: this.minYear,
                      max: this.maxYear,
                      value: this.tableYear
                    },
                    on: E({
                      input: this.yearClick
                    }, Object(y.createItemTypeListeners)(this, ":year"))
                  });
                },
                genPickerBody: function() {
                  var b = this.internalActivePicker === "YEAR" ? [this.genYears()] : [this.genTableHeader(), this.internalActivePicker === "DATE" ? this.genDateTable() : this.genMonthTable()];
                  return this.$createElement("div", {
                    key: this.internalActivePicker
                  }, b);
                },
                setInputDate: function() {
                  if (this.lastValue) {
                    var b = this.lastValue.split("-");
                    this.inputYear = parseInt(b[0], 10), this.inputMonth = parseInt(b[1], 10) - 1, this.type === "date" && (this.inputDay = parseInt(b[2], 10));
                  } else
                    this.inputYear = this.inputYear || this.now.getFullYear(), this.inputMonth = this.inputMonth == null ? this.inputMonth : this.now.getMonth(), this.inputDay = this.inputDay || this.now.getDate();
                }
              },
              render: function() {
                return this.genPicker("v-picker--date");
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerDateTable.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerDateTable.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/date-picker-table */
              "./src/components/VDatePicker/mixins/date-picker-table.ts"
            ), o = i(
              /*! ../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-date-table",
              props: {
                firstDayOfWeek: {
                  type: [String, Number],
                  default: 0
                },
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                showAdjacentMonths: Boolean,
                showWeek: Boolean,
                weekdayFormat: Function
              },
              computed: {
                formatter: function() {
                  return this.format || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    day: "numeric",
                    timeZone: "UTC"
                  }, {
                    start: 8,
                    length: 2
                  });
                },
                weekdayFormatter: function() {
                  return this.weekdayFormat || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    weekday: "narrow",
                    timeZone: "UTC"
                  });
                },
                weekDays: function() {
                  var c = this, h = parseInt(this.firstDayOfWeek, 10);
                  return this.weekdayFormatter ? Object(f.createRange)(7).map(function(p) {
                    return c.weekdayFormatter("2017-01-" + (h + p + 15));
                  }) : Object(f.createRange)(7).map(function(p) {
                    return ["S", "M", "T", "W", "T", "F", "S"][(p + h) % 7];
                  });
                }
              },
              methods: {
                calculateTableDate: function(c) {
                  return Object(l.monthChange)(this.tableDate, Math.sign(c || 1));
                },
                genTHead: function() {
                  var c = this, h = this.weekDays.map(function(p) {
                    return c.$createElement("th", p);
                  });
                  return this.showWeek && h.unshift(this.$createElement("th")), this.$createElement("thead", this.genTR(h));
                },
                // Returns number of the days from the firstDayOfWeek to the first day of the current month
                weekDaysBeforeFirstDayOfTheMonth: function() {
                  var c = /* @__PURE__ */ new Date(this.displayedYear + "-" + Object(l.pad)(this.displayedMonth + 1) + "-01T00:00:00+00:00"), h = c.getUTCDay();
                  return (h - parseInt(this.firstDayOfWeek) + 7) % 7;
                },
                getWeekNumber: function(c) {
                  return Object(o.weekNumber)(this.displayedYear, this.displayedMonth, c, parseInt(this.firstDayOfWeek), parseInt(this.localeFirstDayOfYear));
                },
                genWeekNumber: function(c) {
                  return this.$createElement("td", [this.$createElement("small", {
                    staticClass: "v-date-picker-table--date__week"
                  }, String(c).padStart(2, "0"))]);
                },
                // eslint-disable-next-line max-statements
                genTBody: function() {
                  var c = [], h = new Date(this.displayedYear, this.displayedMonth + 1, 0).getDate(), p = [], g = this.weekDaysBeforeFirstDayOfTheMonth();
                  this.showWeek && p.push(this.genWeekNumber(this.getWeekNumber(1)));
                  for (var m = this.displayedMonth ? this.displayedYear : this.displayedYear - 1, v = (this.displayedMonth + 11) % 12, y = new Date(this.displayedYear, this.displayedMonth, 0).getDate(), E = this.showWeek ? 8 : 7; g--; ) {
                    var C = m + "-" + Object(l.pad)(v + 1) + "-" + Object(l.pad)(y - g);
                    p.push(this.$createElement("td", this.showAdjacentMonths ? [this.genButton(C, !0, "date", this.formatter, !0)] : []));
                  }
                  for (g = 1; g <= h; g++) {
                    var C = this.displayedYear + "-" + Object(l.pad)(this.displayedMonth + 1) + "-" + Object(l.pad)(g);
                    p.push(this.$createElement("td", [this.genButton(C, !0, "date", this.formatter)])), p.length % E === 0 && (c.push(this.genTR(p)), p = [], this.showWeek && (g < h || this.showAdjacentMonths) && p.push(this.genWeekNumber(this.getWeekNumber(g + 7))));
                  }
                  for (var x = this.displayedMonth === 11 ? this.displayedYear + 1 : this.displayedYear, b = (this.displayedMonth + 1) % 12, P = 1; p.length < E; ) {
                    var C = x + "-" + Object(l.pad)(b + 1) + "-" + Object(l.pad)(P++);
                    p.push(this.$createElement("td", this.showAdjacentMonths ? [this.genButton(C, !0, "date", this.formatter, !0)] : []));
                  }
                  return p.length && c.push(this.genTR(p)), this.$createElement("tbody", c);
                },
                genTR: function(c) {
                  return [this.$createElement("tr", c)];
                }
              },
              render: function() {
                return this.genTable("v-date-picker-table v-date-picker-table--date", [this.genTHead(), this.genTBody()], this.calculateTableDate);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerHeader.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerHeader.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerHeader.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerHeader.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerHeader.sass */
              "./src/components/VDatePicker/VDatePickerHeader.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            };
            r.default = Object(c.default)(
              l.default,
              f.default,
              d.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-header",
              props: {
                disabled: Boolean,
                format: Function,
                min: String,
                max: String,
                nextAriaLabel: String,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevAriaLabel: String,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                readonly: Boolean,
                value: {
                  type: [Number, String],
                  required: !0
                }
              },
              data: function() {
                return {
                  isReversing: !1
                };
              },
              computed: {
                formatter: function() {
                  return this.format ? this.format : String(this.value).split("-")[1] ? Object(u.createNativeLocaleFormatter)(this.currentLocale, {
                    month: "long",
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 7
                  }) : Object(u.createNativeLocaleFormatter)(this.currentLocale, {
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 4
                  });
                }
              },
              watch: {
                value: function(m, v) {
                  this.isReversing = m < v;
                }
              },
              methods: {
                genBtn: function(m) {
                  var v = this, y = m > 0 ? this.nextAriaLabel : this.prevAriaLabel, E = y ? this.$vuetify.lang.t(y) : void 0, C = this.disabled || m < 0 && this.min && this.calculateChange(m) < this.min || m > 0 && this.max && this.calculateChange(m) > this.max;
                  return this.$createElement(a.default, {
                    attrs: {
                      "aria-label": E
                    },
                    props: {
                      dark: this.dark,
                      disabled: C,
                      icon: !0,
                      light: this.light
                    },
                    on: {
                      click: function(b) {
                        b.stopPropagation(), v.$emit("input", v.calculateChange(m));
                      }
                    }
                  }, [this.$createElement(o.default, m < 0 == !this.$vuetify.rtl ? this.prevIcon : this.nextIcon)]);
                },
                calculateChange: function(m) {
                  var v = p(String(this.value).split("-").map(Number), 2), y = v[0], E = v[1];
                  return E == null ? "" + (y + m) : Object(u.monthChange)(String(this.value), m);
                },
                genHeader: function() {
                  var m = this, v = !this.disabled && (this.color || "accent"), y = this.$createElement("div", this.setTextColor(v, {
                    key: String(this.value)
                  }), [this.$createElement("button", {
                    attrs: {
                      type: "button"
                    },
                    on: {
                      click: function() {
                        return m.$emit("toggle");
                      }
                    }
                  }, [this.$slots.default || this.formatter(String(this.value))])]), E = this.$createElement("transition", {
                    props: {
                      name: this.isReversing === !this.$vuetify.rtl ? "tab-reverse-transition" : "tab-transition"
                    }
                  }, [y]);
                  return this.$createElement("div", {
                    staticClass: "v-date-picker-header__value",
                    class: {
                      "v-date-picker-header__value--disabled": this.disabled
                    }
                  }, [E]);
                }
              },
              render: function() {
                return this.$createElement("div", {
                  staticClass: "v-date-picker-header",
                  class: h({
                    "v-date-picker-header--disabled": this.disabled
                  }, this.themeClasses)
                }, [this.genBtn(-1), this.genHeader(), this.genBtn(1)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerMonthTable.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerMonthTable.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/date-picker-table */
              "./src/components/VDatePicker/mixins/date-picker-table.ts"
            ), o = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-month-table",
              computed: {
                formatter: function() {
                  return this.format || Object(o.createNativeLocaleFormatter)(this.currentLocale, {
                    month: "short",
                    timeZone: "UTC"
                  }, {
                    start: 5,
                    length: 2
                  });
                }
              },
              methods: {
                calculateTableDate: function(d) {
                  return "" + (parseInt(this.tableDate, 10) + Math.sign(d || 1));
                },
                genTBody: function() {
                  for (var d = this, u = [], c = Array(3).fill(null), h = 12 / c.length, p = function(y) {
                    var E = c.map(function(C, x) {
                      var b = y * c.length + x, P = d.displayedYear + "-" + Object(o.pad)(b + 1);
                      return d.$createElement("td", {
                        key: b
                      }, [d.genButton(P, !1, "month", d.formatter)]);
                    });
                    u.push(g.$createElement("tr", {
                      key: y
                    }, E));
                  }, g = this, m = 0; m < h; m++)
                    p(m);
                  return this.$createElement("tbody", u);
                }
              },
              render: function() {
                return this.genTable("v-date-picker-table v-date-picker-table--month", [this.genTBody()], this.calculateTableDate);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTable.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTable.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTitle.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTitle.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTitle.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTitle.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerTitle.sass */
              "./src/components/VDatePicker/VDatePickerTitle.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              o.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-title",
              props: {
                date: {
                  type: String,
                  default: ""
                },
                disabled: Boolean,
                readonly: Boolean,
                selectingYear: Boolean,
                value: {
                  type: String
                },
                year: {
                  type: [Number, String],
                  default: ""
                },
                yearIcon: {
                  type: String
                }
              },
              data: function() {
                return {
                  isReversing: !1
                };
              },
              computed: {
                computedTransition: function() {
                  return this.isReversing ? "picker-reverse-transition" : "picker-transition";
                }
              },
              watch: {
                value: function(d, u) {
                  this.isReversing = d < u;
                }
              },
              methods: {
                genYearIcon: function() {
                  return this.$createElement(a.default, {
                    props: {
                      dark: !0
                    }
                  }, this.yearIcon);
                },
                getYearBtn: function() {
                  return this.genPickerButton("selectingYear", !0, [String(this.year), this.yearIcon ? this.genYearIcon() : null], !1, "v-date-picker-title__year");
                },
                genTitleText: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [this.$createElement("div", {
                    domProps: {
                      innerHTML: this.date || "&nbsp;"
                    },
                    key: this.value
                  })]);
                },
                genTitleDate: function() {
                  return this.genPickerButton("selectingYear", !1, [this.genTitleText()], !1, "v-date-picker-title__date");
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-date-picker-title",
                  class: {
                    "v-date-picker-title--disabled": this.disabled
                  }
                }, [this.getYearBtn(), this.genTitleDate()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerYears.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerYears.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerYears.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerYears.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerYears.sass */
              "./src/components/VDatePicker/VDatePickerYears.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), f = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-years",
              props: {
                format: Function,
                min: [Number, String],
                max: [Number, String],
                readonly: Boolean,
                value: [Number, String]
              },
              data: function() {
                return {
                  defaultColor: "primary"
                };
              },
              computed: {
                formatter: function() {
                  return this.format || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 4
                  });
                }
              },
              mounted: function() {
                var c = this;
                setTimeout(function() {
                  var h = c.$el.getElementsByClassName("active")[0];
                  h ? c.$el.scrollTop = h.offsetTop - c.$el.offsetHeight / 2 + h.offsetHeight / 2 : c.min && !c.max ? c.$el.scrollTop = c.$el.scrollHeight : !c.min && c.max ? c.$el.scrollTop = 0 : c.$el.scrollTop = c.$el.scrollHeight / 2 - c.$el.offsetHeight / 2;
                });
              },
              methods: {
                genYearItem: function(c) {
                  var h = this, p = this.formatter("" + c), g = parseInt(this.value, 10) === c, m = g && (this.color || "primary");
                  return this.$createElement("li", this.setTextColor(m, {
                    key: c,
                    class: {
                      active: g
                    },
                    on: Object(f.mergeListeners)({
                      click: function() {
                        return h.$emit("input", c);
                      }
                    }, Object(l.createItemTypeNativeListeners)(this, ":year", c))
                  }), p);
                },
                genYearItems: function() {
                  for (var c = [], h = this.value ? parseInt(this.value, 10) : (/* @__PURE__ */ new Date()).getFullYear(), p = this.max ? parseInt(this.max, 10) : h + 100, g = Math.min(p, this.min ? parseInt(this.min, 10) : h - 100), m = p; m >= g; m--)
                    c.push(this.genYearItem(m));
                  return c;
                }
              },
              render: function() {
                return this.$createElement("ul", {
                  staticClass: "v-date-picker-years",
                  ref: "years"
                }, this.genYearItems());
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VDatePicker/index.ts ***!
            \*********************************************/
          /*! exports provided: VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDatePicker */
              "./src/components/VDatePicker/VDatePicker.ts"
            );
            i.d(r, "VDatePicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VDatePickerTitle */
              "./src/components/VDatePicker/VDatePickerTitle.ts"
            );
            i.d(r, "VDatePickerTitle", function() {
              return o.default;
            });
            var l = i(
              /*! ./VDatePickerHeader */
              "./src/components/VDatePicker/VDatePickerHeader.ts"
            );
            i.d(r, "VDatePickerHeader", function() {
              return l.default;
            });
            var f = i(
              /*! ./VDatePickerDateTable */
              "./src/components/VDatePicker/VDatePickerDateTable.ts"
            );
            i.d(r, "VDatePickerDateTable", function() {
              return f.default;
            });
            var d = i(
              /*! ./VDatePickerMonthTable */
              "./src/components/VDatePicker/VDatePickerMonthTable.ts"
            );
            i.d(r, "VDatePickerMonthTable", function() {
              return d.default;
            });
            var u = i(
              /*! ./VDatePickerYears */
              "./src/components/VDatePicker/VDatePickerYears.ts"
            );
            i.d(r, "VDatePickerYears", function() {
              return u.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VDatePicker: a.default,
                VDatePickerTitle: o.default,
                VDatePickerHeader: l.default,
                VDatePickerDateTable: f.default,
                VDatePickerMonthTable: d.default,
                VDatePickerYears: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/mixins/date-picker-table.ts": (
          /*!****************************************************************!*\
            !*** ./src/components/VDatePicker/mixins/date-picker-table.ts ***!
            \****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VDatePickerTable.sass */
              "./src/components/VDatePicker/VDatePickerTable.sass"
            );
            var a = i(
              /*! ../../../directives/touch */
              "./src/directives/touch/index.ts"
            ), o = i(
              /*! ../../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), f = i(
              /*! ../../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../util */
              "./src/components/VDatePicker/util/index.ts"
            ), u = i(
              /*! ../util/isDateAllowed */
              "./src/components/VDatePicker/util/isDateAllowed.ts"
            ), c = i(
              /*! ../../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), p = i(
              /*! ../../../util/helpers */
              "./src/util/helpers.ts"
            ), g = function() {
              return g = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, g.apply(this, arguments);
            }, m = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], T;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (O) {
                T = {
                  error: O
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (T)
                    throw T.error;
                }
              }
              return P;
            }, v = function(y, E, C) {
              if (C || arguments.length === 2)
                for (var x = 0, b = E.length, P; x < b; x++)
                  (P || !(x in E)) && (P || (P = Array.prototype.slice.call(E, 0, x)), P[x] = E[x]);
              return y.concat(P || Array.prototype.slice.call(E));
            };
            r.default = Object(h.default)(
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              directives: {
                Touch: a.default
              },
              props: {
                allowedDates: Function,
                current: String,
                disabled: Boolean,
                format: Function,
                events: {
                  type: [Array, Function, Object],
                  default: function() {
                    return null;
                  }
                },
                eventColor: {
                  type: [Array, Function, Object, String],
                  default: function() {
                    return "warning";
                  }
                },
                min: String,
                max: String,
                range: Boolean,
                readonly: Boolean,
                scrollable: Boolean,
                tableDate: {
                  type: String,
                  required: !0
                },
                value: [String, Array]
              },
              data: function() {
                return {
                  isReversing: !1,
                  wheelThrottle: null
                };
              },
              computed: {
                computedTransition: function() {
                  return this.isReversing === !this.$vuetify.rtl ? "tab-reverse-transition" : "tab-transition";
                },
                displayedMonth: function() {
                  return Number(this.tableDate.split("-")[1]) - 1;
                },
                displayedYear: function() {
                  return Number(this.tableDate.split("-")[0]);
                }
              },
              watch: {
                tableDate: function(E, C) {
                  this.isReversing = E < C;
                }
              },
              mounted: function() {
                this.wheelThrottle = Object(p.throttle)(this.wheel, 250);
              },
              methods: {
                genButtonClasses: function(E, C, x, b, P, T) {
                  return g({
                    "v-size--default": !C,
                    "v-date-picker-table__current": b,
                    "v-btn--active": x,
                    "v-btn--flat": !E || this.disabled,
                    "v-btn--text": x === b,
                    "v-btn--rounded": C,
                    "v-btn--disabled": !E || this.disabled,
                    "v-btn--outlined": b && !x,
                    "v-date-picker--first-in-range": P,
                    "v-date-picker--last-in-range": T
                  }, this.themeClasses);
                },
                genButtonEvents: function(E, C, x) {
                  var b = this;
                  if (!this.disabled)
                    return Object(c.mergeListeners)({
                      click: function() {
                        C && !b.readonly && b.$emit("input", E);
                      }
                    }, Object(d.createItemTypeNativeListeners)(this, ":" + x, E));
                },
                genButton: function(E, C, x, b, P) {
                  P === void 0 && (P = !1);
                  var T = Object(u.default)(E, this.min, this.max, this.allowedDates), O = this.isSelected(E) && T, S = E === this.current, L = O ? this.setBackgroundColor : this.setTextColor, A = (O || S) && (this.color || "accent"), D = !1, _ = !1;
                  return this.range && this.value && Array.isArray(this.value) && (D = E === this.value[0], _ = E === this.value[this.value.length - 1]), this.$createElement("button", L(A, {
                    staticClass: "v-btn",
                    class: this.genButtonClasses(T && !P, C, O, S, D, _),
                    attrs: {
                      type: "button"
                    },
                    domProps: {
                      disabled: this.disabled || !T || P
                    },
                    on: this.genButtonEvents(E, T, x)
                  }), [this.$createElement("div", {
                    staticClass: "v-btn__content"
                  }, [b(E)]), this.genEvents(E)]);
                },
                getEventColors: function(E) {
                  var C = function(T) {
                    return Array.isArray(T) ? T : [T];
                  }, x, b = [];
                  if (Array.isArray(this.events) ? x = this.events.includes(E) : this.events instanceof Function ? x = this.events(E) || !1 : this.events ? x = this.events[E] || !1 : x = !1, x)
                    x !== !0 ? b = C(x) : typeof this.eventColor == "string" ? b = [this.eventColor] : typeof this.eventColor == "function" ? b = C(this.eventColor(E)) : Array.isArray(this.eventColor) ? b = this.eventColor : b = C(this.eventColor[E]);
                  else
                    return [];
                  return b.filter(function(P) {
                    return P;
                  });
                },
                genEvents: function(E) {
                  var C = this, x = this.getEventColors(E);
                  return x.length ? this.$createElement("div", {
                    staticClass: "v-date-picker-table__events"
                  }, x.map(function(b) {
                    return C.$createElement("div", C.setBackgroundColor(b));
                  })) : null;
                },
                isValidScroll: function(E, C) {
                  var x = C(E), b = x.split("-").length === 1 ? "year" : "month";
                  return E < 0 && (this.min ? x >= Object(d.sanitizeDateString)(this.min, b) : !0) || E > 0 && (this.max ? x <= Object(d.sanitizeDateString)(this.max, b) : !0);
                },
                wheel: function(E, C) {
                  this.$emit("update:table-date", C(E.deltaY));
                },
                touch: function(E, C) {
                  this.$emit("update:table-date", C(E));
                },
                genTable: function(E, C, x) {
                  var b = this, P = this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [this.$createElement("table", {
                    key: this.tableDate
                  }, C)]), T = {
                    name: "touch",
                    value: {
                      left: function(S) {
                        return S.offsetX < -15 && b.isValidScroll(1, x) && b.touch(1, x);
                      },
                      right: function(S) {
                        return S.offsetX > 15 && b.isValidScroll(-1, x) && b.touch(-1, x);
                      }
                    }
                  };
                  return this.$createElement("div", {
                    staticClass: E,
                    class: g({
                      "v-date-picker-table--disabled": this.disabled
                    }, this.themeClasses),
                    on: !this.disabled && this.scrollable ? {
                      wheel: function(S) {
                        S.preventDefault(), b.isValidScroll(S.deltaY, x) && b.wheelThrottle(S, x);
                      }
                    } : void 0,
                    directives: [T]
                  }, [P]);
                },
                isSelected: function(E) {
                  if (Array.isArray(this.value))
                    if (this.range && this.value.length === 2) {
                      var C = m(v([], m(this.value), !1).sort(), 2), x = C[0], b = C[1];
                      return x <= E && E <= b;
                    } else
                      return this.value.indexOf(E) !== -1;
                  return E === this.value;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/util/createNativeLocaleFormatter.ts": (
          /*!************************************************************************!*\
            !*** ./src/components/VDatePicker/util/createNativeLocaleFormatter.ts ***!
            \************************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(f, d) {
              var u = typeof Symbol == "function" && f[Symbol.iterator];
              if (!u)
                return f;
              var c = u.call(f), h, p = [], g;
              try {
                for (; (d === void 0 || d-- > 0) && !(h = c.next()).done; )
                  p.push(h.value);
              } catch (m) {
                g = {
                  error: m
                };
              } finally {
                try {
                  h && !h.done && (u = c.return) && u.call(c);
                } finally {
                  if (g)
                    throw g.error;
                }
              }
              return p;
            };
            function l(f, d, u) {
              u === void 0 && (u = {
                start: 0,
                length: 0
              });
              var c = function(g) {
                var m = o(g.trim().split(" ")[0].split("-"), 3), v = m[0], y = m[1], E = m[2];
                return [Object(a.default)(v, 4), Object(a.default)(y || 1), Object(a.default)(E || 1)].join("-");
              };
              try {
                var h = new Intl.DateTimeFormat(f || void 0, d);
                return function(p) {
                  return h.format(/* @__PURE__ */ new Date(c(p) + "T00:00:00+00:00"));
                };
              } catch {
                return u.start || u.length ? function(g) {
                  return c(g).substr(u.start || 0, u.length);
                } : void 0;
              }
            }
            r.default = l;
          }
        ),
        /***/
        "./src/components/VDatePicker/util/eventHelpers.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VDatePicker/util/eventHelpers.ts ***!
            \*********************************************************/
          /*! exports provided: createItemTypeNativeListeners, createItemTypeListeners */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createItemTypeNativeListeners", function() {
              return a;
            }), i.d(r, "createItemTypeListeners", function() {
              return o;
            });
            function a(l, f, d) {
              return Object.keys(l.$listeners).reduce(function(u, c) {
                return c.endsWith(f) && (u[c.slice(0, -f.length)] = function(h) {
                  return l.$emit(c, d, h);
                }), u;
              }, {});
            }
            function o(l, f) {
              return Object.keys(l.$listeners).reduce(function(d, u) {
                return u.endsWith(f) && (d[u] = l.$listeners[u]), d;
              }, {});
            }
          }
        ),
        /***/
        "./src/components/VDatePicker/util/index.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VDatePicker/util/index.ts ***!
            \**************************************************/
          /*! exports provided: createItemTypeListeners, createItemTypeNativeListeners, createNativeLocaleFormatter, monthChange, sanitizeDateString, pad */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./eventHelpers */
              "./src/components/VDatePicker/util/eventHelpers.ts"
            );
            i.d(r, "createItemTypeListeners", function() {
              return a.createItemTypeListeners;
            }), i.d(r, "createItemTypeNativeListeners", function() {
              return a.createItemTypeNativeListeners;
            });
            var o = i(
              /*! ./createNativeLocaleFormatter */
              "./src/components/VDatePicker/util/createNativeLocaleFormatter.ts"
            );
            i.d(r, "createNativeLocaleFormatter", function() {
              return o.default;
            });
            var l = i(
              /*! ./monthChange */
              "./src/components/VDatePicker/util/monthChange.ts"
            );
            i.d(r, "monthChange", function() {
              return l.default;
            });
            var f = i(
              /*! ./sanitizeDateString */
              "./src/components/VDatePicker/util/sanitizeDateString.ts"
            );
            i.d(r, "sanitizeDateString", function() {
              return f.default;
            });
            var d = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            );
            i.d(r, "pad", function() {
              return d.default;
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/util/isDateAllowed.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/util/isDateAllowed.ts ***!
            \**********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o, l, f, d) {
              return (!d || d(o)) && (!l || o >= l.substr(0, 10)) && (!f || o <= f);
            }
          }
        ),
        /***/
        "./src/components/VDatePicker/util/monthChange.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/util/monthChange.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(l, f) {
              var d = typeof Symbol == "function" && l[Symbol.iterator];
              if (!d)
                return l;
              var u = d.call(l), c, h = [], p;
              try {
                for (; (f === void 0 || f-- > 0) && !(c = u.next()).done; )
                  h.push(c.value);
              } catch (g) {
                p = {
                  error: g
                };
              } finally {
                try {
                  c && !c.done && (d = u.return) && d.call(u);
                } finally {
                  if (p)
                    throw p.error;
                }
              }
              return h;
            };
            r.default = function(l, f) {
              var d = o(l.split("-").map(Number), 2), u = d[0], c = d[1];
              return c + f === 0 ? u - 1 + "-12" : c + f === 13 ? u + 1 + "-01" : u + "-" + Object(a.default)(c + f);
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/util/pad.ts": (
          /*!************************************************!*\
            !*** ./src/components/VDatePicker/util/pad.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = function(l, f, d) {
              return f = f >> 0, l = String(l), d = String(d), l.length > f ? String(l) : (f = f - l.length, f > d.length && (d += d.repeat(f / d.length)), d.slice(0, f) + String(l));
            };
            r.default = function(o, l) {
              return l === void 0 && (l = 2), a(o, l, "0");
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/util/sanitizeDateString.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VDatePicker/util/sanitizeDateString.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(l, f) {
              var d = typeof Symbol == "function" && l[Symbol.iterator];
              if (!d)
                return l;
              var u = d.call(l), c, h = [], p;
              try {
                for (; (f === void 0 || f-- > 0) && !(c = u.next()).done; )
                  h.push(c.value);
              } catch (g) {
                p = {
                  error: g
                };
              } finally {
                try {
                  c && !c.done && (d = u.return) && d.call(u);
                } finally {
                  if (p)
                    throw p.error;
                }
              }
              return h;
            };
            r.default = function(l, f) {
              var d = o(l.split("-"), 3), u = d[0], c = d[1], h = c === void 0 ? 1 : c, p = d[2], g = p === void 0 ? 1 : p;
              return (u + "-" + Object(a.default)(h) + "-" + Object(a.default)(g)).substr(0, {
                date: 10,
                month: 7,
                year: 4
              }[f]);
            };
          }
        ),
        /***/
        "./src/components/VDialog/VDialog.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VDialog/VDialog.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDialog/VDialog.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VDialog/VDialog.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDialog.sass */
              "./src/components/VDialog/VDialog.sass"
            );
            var a = i(
              /*! ../VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            ), o = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), l = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), f = i(
              /*! ../../mixins/detachable */
              "./src/mixins/detachable/index.ts"
            ), d = i(
              /*! ../../mixins/overlayable */
              "./src/mixins/overlayable/index.ts"
            ), u = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), c = i(
              /*! ../../mixins/stackable */
              "./src/mixins/stackable/index.ts"
            ), h = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), v = function() {
              return v = Object.assign || function(x) {
                for (var b, P = 1, T = arguments.length; P < T; P++) {
                  b = arguments[P];
                  for (var O in b)
                    Object.prototype.hasOwnProperty.call(b, O) && (x[O] = b[O]);
                }
                return x;
              }, v.apply(this, arguments);
            }, y = function(x, b) {
              var P = typeof Symbol == "function" && x[Symbol.iterator];
              if (!P)
                return x;
              var T = P.call(x), O, S = [], L;
              try {
                for (; (b === void 0 || b-- > 0) && !(O = T.next()).done; )
                  S.push(O.value);
              } catch (A) {
                L = {
                  error: A
                };
              } finally {
                try {
                  O && !O.done && (P = T.return) && P.call(T);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return S;
            }, E = function(x, b, P) {
              if (P || arguments.length === 2)
                for (var T = 0, O = b.length, S; T < O; T++)
                  (S || !(T in b)) && (S || (S = Array.prototype.slice.call(b, 0, T)), S[T] = b[T]);
              return x.concat(S || Array.prototype.slice.call(b));
            }, C = Object(p.default)(l.default, f.default, d.default, u.default, c.default, o.default);
            r.default = C.extend({
              name: "v-dialog",
              directives: {
                ClickOutside: h.default
              },
              props: {
                dark: Boolean,
                disabled: Boolean,
                fullscreen: Boolean,
                light: Boolean,
                maxWidth: [String, Number],
                noClickAnimation: Boolean,
                origin: {
                  type: String,
                  default: "center center"
                },
                persistent: Boolean,
                retainFocus: {
                  type: Boolean,
                  default: !0
                },
                scrollable: Boolean,
                transition: {
                  type: [String, Boolean],
                  default: "dialog-transition"
                },
                width: [String, Number]
              },
              data: function() {
                return {
                  activatedBy: null,
                  animate: !1,
                  animateTimeout: -1,
                  stackMinZIndex: 200,
                  previousActiveElement: null
                };
              },
              computed: {
                classes: function() {
                  var b;
                  return b = {}, b[("v-dialog " + this.contentClass).trim()] = !0, b["v-dialog--active"] = this.isActive, b["v-dialog--persistent"] = this.persistent, b["v-dialog--fullscreen"] = this.fullscreen, b["v-dialog--scrollable"] = this.scrollable, b["v-dialog--animated"] = this.animate, b;
                },
                contentClasses: function() {
                  return {
                    "v-dialog__content": !0,
                    "v-dialog__content--active": this.isActive
                  };
                },
                hasActivator: function() {
                  return !!(this.$slots.activator || this.$scopedSlots.activator);
                }
              },
              watch: {
                isActive: function(b) {
                  var P;
                  b ? (this.show(), this.hideScroll()) : (this.removeOverlay(), this.unbind(), (P = this.previousActiveElement) === null || P === void 0 || P.focus());
                },
                fullscreen: function(b) {
                  this.isActive && (b ? (this.hideScroll(), this.removeOverlay(!1)) : (this.showScroll(), this.genOverlay()));
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("full-width") && Object(g.removed)("full-width", this);
              },
              beforeMount: function() {
                var b = this;
                this.$nextTick(function() {
                  b.isBooted = b.isActive, b.isActive && b.show();
                });
              },
              beforeDestroy: function() {
                typeof window < "u" && this.unbind();
              },
              methods: {
                animateClick: function() {
                  var b = this;
                  this.animate = !1, this.$nextTick(function() {
                    b.animate = !0, window.clearTimeout(b.animateTimeout), b.animateTimeout = window.setTimeout(function() {
                      return b.animate = !1;
                    }, 150);
                  });
                },
                closeConditional: function(b) {
                  var P = b.target;
                  return !(this._isDestroyed || !this.isActive || this.$refs.content.contains(P) || this.overlay && P && !this.overlay.$el.contains(P)) && this.activeZIndex >= this.getMaxZIndex();
                },
                hideScroll: function() {
                  this.fullscreen ? document.documentElement.classList.add("overflow-y-hidden") : d.default.options.methods.hideScroll.call(this);
                },
                show: function() {
                  var b = this;
                  !this.fullscreen && !this.hideOverlay && this.genOverlay(), this.$nextTick(function() {
                    b.$nextTick(function() {
                      var P, T;
                      !((P = b.$refs.dialog) === null || P === void 0) && P.contains(document.activeElement) || (b.previousActiveElement = document.activeElement, (T = b.$refs.dialog) === null || T === void 0 || T.focus()), b.bind();
                    });
                  });
                },
                bind: function() {
                  window.addEventListener("focusin", this.onFocusin);
                },
                unbind: function() {
                  window.removeEventListener("focusin", this.onFocusin);
                },
                onClickOutside: function(b) {
                  this.$emit("click:outside", b), this.persistent ? this.noClickAnimation || this.animateClick() : this.isActive = !1;
                },
                onKeydown: function(b) {
                  if (b.keyCode === m.keyCodes.esc && !this.getOpenDependents().length)
                    if (this.persistent)
                      this.noClickAnimation || this.animateClick();
                    else {
                      this.isActive = !1;
                      var P = this.getActivator();
                      this.$nextTick(function() {
                        return P && P.focus();
                      });
                    }
                  this.$emit("keydown", b);
                },
                // On focus change, wrap focus to stay inside the dialog
                // https://github.com/vuetifyjs/vuetify/issues/6892
                onFocusin: function(b) {
                  if (!(!b || !this.retainFocus)) {
                    var P = b.target;
                    if (P && this.$refs.dialog && // It isn't the document or the dialog body
                    ![document, this.$refs.dialog].includes(P) && // It isn't inside the dialog body
                    !this.$refs.dialog.contains(P) && // We're the topmost dialog
                    this.activeZIndex >= this.getMaxZIndex() && // It isn't inside a dependent element (like a menu)
                    !this.getOpenDependentElements().some(function(S) {
                      return S.contains(P);
                    })) {
                      var T = this.$refs.dialog.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])'), O = E([], y(T), !1).find(function(S) {
                        return !S.hasAttribute("disabled") && !S.matches('[tabindex="-1"]');
                      });
                      O && O.focus();
                    }
                  }
                },
                genContent: function() {
                  var b = this;
                  return this.showLazyContent(function() {
                    return [b.$createElement(a.VThemeProvider, {
                      props: {
                        root: !0,
                        light: b.light,
                        dark: b.dark
                      }
                    }, [b.$createElement("div", {
                      class: b.contentClasses,
                      attrs: v({
                        role: "dialog",
                        "aria-modal": b.hideOverlay ? void 0 : "true"
                      }, b.getScopeIdAttrs()),
                      on: {
                        keydown: b.onKeydown
                      },
                      style: {
                        zIndex: b.activeZIndex
                      },
                      ref: "content"
                    }, [b.genTransition()])])];
                  });
                },
                genTransition: function() {
                  var b = this.genInnerContent();
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition,
                      origin: this.origin,
                      appear: !0
                    }
                  }, [b]) : b;
                },
                genInnerContent: function() {
                  var b = {
                    class: this.classes,
                    attrs: {
                      tabindex: this.isActive ? 0 : void 0
                    },
                    ref: "dialog",
                    directives: [{
                      name: "click-outside",
                      value: {
                        handler: this.onClickOutside,
                        closeConditional: this.closeConditional,
                        include: this.getOpenDependentElements
                      }
                    }, {
                      name: "show",
                      value: this.isActive
                    }],
                    style: {
                      transformOrigin: this.origin
                    }
                  };
                  return this.fullscreen || (b.style = v(v({}, b.style), {
                    maxWidth: Object(m.convertToUnit)(this.maxWidth),
                    width: Object(m.convertToUnit)(this.width)
                  })), this.$createElement("div", b, this.getContentSlot());
                }
              },
              render: function(b) {
                return b("div", {
                  staticClass: "v-dialog__container",
                  class: {
                    "v-dialog__container--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  }
                }, [this.genActivator(), this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDialog/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VDialog/index.ts ***!
            \*****************************************/
          /*! exports provided: VDialog, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDialog */
              "./src/components/VDialog/VDialog.ts"
            );
            i.d(r, "VDialog", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VDivider/VDivider.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VDivider/VDivider.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDivider/VDivider.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VDivider/VDivider.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDivider.sass */
              "./src/components/VDivider/VDivider.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-divider",
              props: {
                inset: Boolean,
                vertical: Boolean
              },
              render: function(f) {
                var d;
                return (!this.$attrs.role || this.$attrs.role === "separator") && (d = this.vertical ? "vertical" : "horizontal"), f("hr", {
                  class: o({
                    "v-divider": !0,
                    "v-divider--inset": this.inset,
                    "v-divider--vertical": this.vertical
                  }, this.themeClasses),
                  attrs: o({
                    role: "separator",
                    "aria-orientation": d
                  }, this.$attrs),
                  on: this.$listeners
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDivider/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VDivider/index.ts ***!
            \******************************************/
          /*! exports provided: VDivider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDivider */
              "./src/components/VDivider/VDivider.ts"
            );
            i.d(r, "VDivider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanel.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanel.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanel.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanel.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(
              Object(a.factory)("expansionPanels", "v-expansion-panel", "v-expansion-panels"),
              Object(o.provide)("expansionPanel", !0)
              /* @vue/component */
            ).extend({
              name: "v-expansion-panel",
              props: {
                disabled: Boolean,
                readonly: Boolean
              },
              data: function() {
                return {
                  content: null,
                  header: null,
                  nextIsActive: !1
                };
              },
              computed: {
                classes: function() {
                  return d({
                    "v-expansion-panel--active": this.isActive,
                    "v-expansion-panel--next-active": this.nextIsActive,
                    "v-expansion-panel--disabled": this.isDisabled
                  }, this.groupClasses);
                },
                isDisabled: function() {
                  return this.expansionPanels.disabled || this.disabled;
                },
                isReadonly: function() {
                  return this.expansionPanels.readonly || this.readonly;
                }
              },
              methods: {
                registerContent: function(c) {
                  this.content = c;
                },
                unregisterContent: function() {
                  this.content = null;
                },
                registerHeader: function(c) {
                  this.header = c, c.$on("click", this.onClick);
                },
                unregisterHeader: function() {
                  this.header = null;
                },
                onClick: function(c) {
                  c.detail && this.header.$el.blur(), this.$emit("click", c), this.isReadonly || this.isDisabled || this.toggle();
                },
                toggle: function() {
                  var c = this;
                  this.$nextTick(function() {
                    return c.$emit("change");
                  });
                }
              },
              render: function(c) {
                return c("div", {
                  staticClass: "v-expansion-panel",
                  class: this.classes,
                  attrs: {
                    "aria-expanded": String(this.isActive)
                  }
                }, Object(l.getSlot)(this));
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanelContent.ts": (
          /*!******************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanelContent.ts ***!
            \******************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = Object(u.default)(o.default, l.default, Object(f.inject)("expansionPanel", "v-expansion-panel-content", "v-expansion-panel"));
            r.default = c.extend().extend({
              name: "v-expansion-panel-content",
              data: function() {
                return {
                  isActive: !1
                };
              },
              computed: {
                parentIsActive: function() {
                  return this.expansionPanel.isActive;
                }
              },
              watch: {
                parentIsActive: {
                  immediate: !0,
                  handler: function(p, g) {
                    var m = this;
                    p && (this.isBooted = !0), g == null ? this.isActive = p : this.$nextTick(function() {
                      return m.isActive = p;
                    });
                  }
                }
              },
              created: function() {
                this.expansionPanel.registerContent(this);
              },
              beforeDestroy: function() {
                this.expansionPanel.unregisterContent();
              },
              render: function(p) {
                var g = this;
                return p(a.VExpandTransition, this.showLazyContent(function() {
                  return [p("div", g.setBackgroundColor(g.color, {
                    staticClass: "v-expansion-panel-content",
                    directives: [{
                      name: "show",
                      value: g.isActive
                    }]
                  }), [p("div", {
                    class: "v-expansion-panel-content__wrap"
                  }, Object(d.getSlot)(g, "default", {
                    open: g.isActive
                  }))])];
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanelHeader.ts": (
          /*!*****************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanelHeader.ts ***!
            \*****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), d = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = Object(c.default)(l.default, Object(f.inject)("expansionPanel", "v-expansion-panel-header", "v-expansion-panel"));
            r.default = p.extend().extend({
              name: "v-expansion-panel-header",
              directives: {
                ripple: d.default
              },
              props: {
                disableIconRotate: Boolean,
                expandIcon: {
                  type: String,
                  default: "$expand"
                },
                hideActions: Boolean,
                ripple: {
                  type: [Boolean, Object],
                  default: !1
                }
              },
              data: function() {
                return {
                  hasMousedown: !1
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-expansion-panel-header--active": this.isActive,
                    "v-expansion-panel-header--mousedown": this.hasMousedown
                  };
                },
                isActive: function() {
                  return this.expansionPanel.isActive;
                },
                isDisabled: function() {
                  return this.expansionPanel.isDisabled;
                },
                isReadonly: function() {
                  return this.expansionPanel.isReadonly;
                }
              },
              created: function() {
                this.expansionPanel.registerHeader(this);
              },
              beforeDestroy: function() {
                this.expansionPanel.unregisterHeader();
              },
              methods: {
                onClick: function(m) {
                  this.$emit("click", m);
                },
                genIcon: function() {
                  var m = Object(u.getSlot)(this, "actions", {
                    open: this.isActive
                  }) || [this.$createElement(o.default, this.expandIcon)];
                  return this.$createElement(a.VFadeTransition, [this.$createElement("div", {
                    staticClass: "v-expansion-panel-header__icon",
                    class: {
                      "v-expansion-panel-header__icon--disable-rotate": this.disableIconRotate
                    },
                    directives: [{
                      name: "show",
                      value: !this.isDisabled
                    }]
                  }, m)]);
                }
              },
              render: function(m) {
                var v = this;
                return m("button", this.setBackgroundColor(this.color, {
                  staticClass: "v-expansion-panel-header",
                  class: this.classes,
                  attrs: {
                    tabindex: this.isDisabled ? -1 : null,
                    type: "button",
                    "aria-expanded": this.isActive
                  },
                  directives: [{
                    name: "ripple",
                    value: this.ripple
                  }],
                  on: h(h({}, this.$listeners), {
                    click: this.onClick,
                    mousedown: function() {
                      return v.hasMousedown = !0;
                    },
                    mouseup: function() {
                      return v.hasMousedown = !1;
                    }
                  })
                }), [Object(u.getSlot)(this, "default", {
                  open: this.isActive
                }, !0), this.hideActions || this.genIcon()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanels.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanels.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VExpansionPanel.sass */
              "./src/components/VExpansionPanel/VExpansionPanel.sass"
            );
            var a = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = a.BaseItemGroup.extend({
              name: "v-expansion-panels",
              provide: function() {
                return {
                  expansionPanels: this
                };
              },
              props: {
                accordion: Boolean,
                disabled: Boolean,
                flat: Boolean,
                hover: Boolean,
                focusable: Boolean,
                inset: Boolean,
                popout: Boolean,
                readonly: Boolean,
                tile: Boolean
              },
              computed: {
                classes: function() {
                  return l(l({}, a.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-expansion-panels": !0,
                    "v-expansion-panels--accordion": this.accordion,
                    "v-expansion-panels--flat": this.flat,
                    "v-expansion-panels--hover": this.hover,
                    "v-expansion-panels--focusable": this.focusable,
                    "v-expansion-panels--inset": this.inset,
                    "v-expansion-panels--popout": this.popout,
                    "v-expansion-panels--tile": this.tile
                  });
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("expand") && Object(o.breaking)("expand", "multiple", this), Array.isArray(this.value) && this.value.length > 0 && typeof this.value[0] == "boolean" && Object(o.breaking)(':value="[true, false, true]"', ':value="[0, 2]"', this);
              },
              methods: {
                updateItem: function(d, u) {
                  var c = this.getValue(d, u), h = this.getValue(d, u + 1);
                  d.isActive = this.toggleMethod(c), d.nextIsActive = this.toggleMethod(h);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VExpansionPanel/index.ts ***!
            \*************************************************/
          /*! exports provided: VExpansionPanels, VExpansionPanel, VExpansionPanelHeader, VExpansionPanelContent, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VExpansionPanels */
              "./src/components/VExpansionPanel/VExpansionPanels.ts"
            );
            i.d(r, "VExpansionPanels", function() {
              return a.default;
            });
            var o = i(
              /*! ./VExpansionPanel */
              "./src/components/VExpansionPanel/VExpansionPanel.ts"
            );
            i.d(r, "VExpansionPanel", function() {
              return o.default;
            });
            var l = i(
              /*! ./VExpansionPanelContent */
              "./src/components/VExpansionPanel/VExpansionPanelContent.ts"
            );
            i.d(r, "VExpansionPanelContent", function() {
              return l.default;
            });
            var f = i(
              /*! ./VExpansionPanelHeader */
              "./src/components/VExpansionPanel/VExpansionPanelHeader.ts"
            );
            i.d(r, "VExpansionPanelHeader", function() {
              return f.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VExpansionPanels: a.default,
                VExpansionPanel: o.default,
                VExpansionPanelHeader: f.default,
                VExpansionPanelContent: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VFileInput/VFileInput.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VFileInput/VFileInput.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VFileInput/VFileInput.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VFileInput/VFileInput.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VFileInput.sass */
              "./src/components/VFileInput/VFileInput.sass"
            );
            var a = i(
              /*! ../VTextField */
              "./src/components/VTextField/index.ts"
            ), o = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            function u(g) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function(v) {
                return typeof v;
              } : u = function(v) {
                return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
              }, u(g);
            }
            var c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = a.default.extend({
              name: "v-file-input",
              model: {
                prop: "value",
                event: "change"
              },
              props: {
                chips: Boolean,
                clearable: {
                  type: Boolean,
                  default: !0
                },
                counterSizeString: {
                  type: String,
                  default: "$vuetify.fileInput.counterSize"
                },
                counterString: {
                  type: String,
                  default: "$vuetify.fileInput.counter"
                },
                hideInput: Boolean,
                multiple: Boolean,
                placeholder: String,
                prependIcon: {
                  type: String,
                  default: "$file"
                },
                readonly: {
                  type: Boolean,
                  default: !1
                },
                showSize: {
                  type: [Boolean, Number],
                  default: !1,
                  validator: function(m) {
                    return typeof m == "boolean" || [1e3, 1024].includes(m);
                  }
                },
                smallChips: Boolean,
                truncateLength: {
                  type: [Number, String],
                  default: 22
                },
                type: {
                  type: String,
                  default: "file"
                },
                value: {
                  default: void 0,
                  validator: function(m) {
                    return Object(l.wrapInArray)(m).every(function(v) {
                      return v != null && u(v) === "object";
                    });
                  }
                }
              },
              computed: {
                classes: function() {
                  return c(c({}, a.default.options.computed.classes.call(this)), {
                    "v-file-input": !0
                  });
                },
                computedCounterValue: function() {
                  var m = this.multiple && this.lazyValue ? this.lazyValue.length : this.lazyValue instanceof File ? 1 : 0;
                  if (!this.showSize)
                    return this.$vuetify.lang.t(this.counterString, m);
                  var v = this.internalArrayValue.reduce(function(y, E) {
                    var C = E.size, x = C === void 0 ? 0 : C;
                    return y + x;
                  }, 0);
                  return this.$vuetify.lang.t(this.counterSizeString, m, Object(l.humanReadableFileSize)(v, this.base === 1024));
                },
                internalArrayValue: function() {
                  return Object(l.wrapInArray)(this.internalValue);
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(m) {
                    this.lazyValue = m, this.$emit("change", this.lazyValue);
                  }
                },
                isDirty: function() {
                  return this.internalArrayValue.length > 0;
                },
                isLabelActive: function() {
                  return this.isDirty;
                },
                text: function() {
                  var m = this;
                  return !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? [this.placeholder] : this.internalArrayValue.map(function(v) {
                    var y = v.name, E = y === void 0 ? "" : y, C = v.size, x = C === void 0 ? 0 : C, b = m.truncateText(E);
                    return m.showSize ? b + " (" + Object(l.humanReadableFileSize)(x, m.base === 1024) + ")" : b;
                  });
                },
                base: function() {
                  return typeof this.showSize != "boolean" ? this.showSize : void 0;
                },
                hasChips: function() {
                  return this.chips || this.smallChips;
                }
              },
              watch: {
                readonly: {
                  handler: function(m) {
                    m === !0 && Object(f.consoleError)("readonly is not supported on <v-file-input>", this);
                  },
                  immediate: !0
                },
                value: function(m) {
                  var v = this.multiple ? m : m ? [m] : [];
                  Object(l.deepEqual)(v, this.$refs.input.files) || (this.$refs.input.value = "");
                }
              },
              methods: {
                clearableCallback: function() {
                  this.internalValue = this.multiple ? [] : null, this.$refs.input.value = "";
                },
                genChips: function() {
                  var m = this;
                  return this.isDirty ? this.text.map(function(v, y) {
                    return m.$createElement(o.VChip, {
                      props: {
                        small: m.smallChips
                      },
                      on: {
                        "click:close": function() {
                          var C = m.internalValue;
                          C.splice(y, 1), m.internalValue = C;
                        }
                      }
                    }, [v]);
                  }) : [];
                },
                genControl: function() {
                  var m = a.default.options.methods.genControl.call(this);
                  return this.hideInput && (m.data.style = Object(d.mergeStyles)(m.data.style, {
                    display: "none"
                  })), m;
                },
                genInput: function() {
                  var m = a.default.options.methods.genInput.call(this);
                  return m.data.attrs.multiple = this.multiple, delete m.data.domProps.value, delete m.data.on.input, m.data.on.change = this.onInput, [this.genSelections(), m];
                },
                genPrependSlot: function() {
                  var m = this;
                  if (!this.prependIcon)
                    return null;
                  var v = this.genIcon("prepend", function() {
                    m.$refs.input.click();
                  });
                  return this.genSlot("prepend", "outer", [v]);
                },
                genSelectionText: function() {
                  var m = this.text.length;
                  return m < 2 ? this.text : this.showSize && !this.counter ? [this.computedCounterValue] : [this.$vuetify.lang.t(this.counterString, m)];
                },
                genSelections: function() {
                  var m = this, v = [];
                  return this.isDirty && this.$scopedSlots.selection ? this.internalArrayValue.forEach(function(y, E) {
                    m.$scopedSlots.selection && v.push(m.$scopedSlots.selection({
                      text: m.text[E],
                      file: y,
                      index: E
                    }));
                  }) : v.push(this.hasChips && this.isDirty ? this.genChips() : this.genSelectionText()), this.$createElement("div", {
                    staticClass: "v-file-input__text",
                    class: {
                      "v-file-input__text--placeholder": this.placeholder && !this.isDirty,
                      "v-file-input__text--chips": this.hasChips && !this.$scopedSlots.selection
                    }
                  }, v);
                },
                genTextFieldSlot: function() {
                  var m = this, v = a.default.options.methods.genTextFieldSlot.call(this);
                  return v.data.on = c(c({}, v.data.on || {}), {
                    click: function(E) {
                      E.target && E.target.nodeName === "LABEL" || m.$refs.input.click();
                    }
                  }), v;
                },
                onInput: function(m) {
                  var v = p([], h(m.target.files || []), !1);
                  this.internalValue = this.multiple ? v : v[0], this.initialValue = this.internalValue;
                },
                onKeyDown: function(m) {
                  this.$emit("keydown", m);
                },
                truncateText: function(m) {
                  if (m.length < Number(this.truncateLength))
                    return m;
                  var v = Math.floor((Number(this.truncateLength) - 1) / 2);
                  return m.slice(0, v) + "…" + m.slice(m.length - v);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VFileInput/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VFileInput/index.ts ***!
            \********************************************/
          /*! exports provided: VFileInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VFileInput */
              "./src/components/VFileInput/VFileInput.ts"
            );
            i.d(r, "VFileInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VFooter/VFooter.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VFooter/VFooter.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VFooter/VFooter.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VFooter/VFooter.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VFooter.sass */
              "./src/components/VFooter/VFooter.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), l = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, Object(o.default)("footer", ["height", "inset"]), l.default).extend({
              name: "v-footer",
              props: {
                height: {
                  default: "auto",
                  type: [Number, String]
                },
                inset: Boolean,
                padless: Boolean,
                tag: {
                  type: String,
                  default: "footer"
                }
              },
              computed: {
                applicationProperty: function() {
                  return this.inset ? "insetFooter" : "footer";
                },
                classes: function() {
                  return u(u({}, a.default.options.computed.classes.call(this)), {
                    "v-footer--absolute": this.absolute,
                    "v-footer--fixed": !this.absolute && (this.app || this.fixed),
                    "v-footer--padless": this.padless,
                    "v-footer--inset": this.inset
                  });
                },
                computedBottom: function() {
                  if (this.isPositioned)
                    return this.app ? this.$vuetify.application.bottom : 0;
                },
                computedLeft: function() {
                  if (this.isPositioned)
                    return this.app && this.inset ? this.$vuetify.application.left : 0;
                },
                computedRight: function() {
                  if (this.isPositioned)
                    return this.app && this.inset ? this.$vuetify.application.right : 0;
                },
                isPositioned: function() {
                  return !!(this.absolute || this.fixed || this.app);
                },
                styles: function() {
                  var h = parseInt(this.height);
                  return u(u({}, a.default.options.computed.styles.call(this)), {
                    height: isNaN(h) ? h : Object(d.convertToUnit)(h),
                    left: Object(d.convertToUnit)(this.computedLeft),
                    right: Object(d.convertToUnit)(this.computedRight),
                    bottom: Object(d.convertToUnit)(this.computedBottom)
                  });
                }
              },
              methods: {
                updateApplication: function() {
                  var h = parseInt(this.height);
                  return isNaN(h) ? this.$el ? this.$el.clientHeight : 0 : h;
                }
              },
              render: function(h) {
                var p = this.setBackgroundColor(this.color, {
                  staticClass: "v-footer",
                  class: this.classes,
                  style: this.styles
                });
                return h(this.tag, p, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VFooter/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VFooter/index.ts ***!
            \*****************************************/
          /*! exports provided: VFooter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VFooter */
              "./src/components/VFooter/VFooter.ts"
            );
            i.d(r, "VFooter", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VForm/VForm.ts": (
          /*!***************************************!*\
            !*** ./src/components/VForm/VForm.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(a.default)(
              o.default,
              Object(l.provide)("form")
              /* @vue/component */
            ).extend({
              name: "v-form",
              provide: function() {
                return {
                  form: this
                };
              },
              inheritAttrs: !1,
              props: {
                disabled: Boolean,
                lazyValidation: Boolean,
                readonly: Boolean,
                value: Boolean
              },
              data: function() {
                return {
                  inputs: [],
                  watchers: [],
                  errorBag: {}
                };
              },
              watch: {
                errorBag: {
                  handler: function(u) {
                    var c = Object.values(u).includes(!0);
                    this.$emit("input", !c);
                  },
                  deep: !0,
                  immediate: !0
                }
              },
              methods: {
                watchInput: function(u) {
                  var c = this, h = function(m) {
                    return m.$watch("hasError", function(v) {
                      c.$set(c.errorBag, m._uid, v);
                    }, {
                      immediate: !0
                    });
                  }, p = {
                    _uid: u._uid,
                    valid: function() {
                    },
                    shouldValidate: function() {
                    }
                  };
                  return this.lazyValidation ? p.shouldValidate = u.$watch("shouldValidate", function(g) {
                    g && (c.errorBag.hasOwnProperty(u._uid) || (p.valid = h(u)));
                  }) : p.valid = h(u), p;
                },
                /** @public */
                validate: function() {
                  return this.inputs.filter(function(u) {
                    return !u.validate(!0);
                  }).length === 0;
                },
                /** @public */
                reset: function() {
                  this.inputs.forEach(function(u) {
                    return u.reset();
                  }), this.resetErrorBag();
                },
                resetErrorBag: function() {
                  var u = this;
                  this.lazyValidation && setTimeout(function() {
                    u.errorBag = {};
                  }, 0);
                },
                /** @public */
                resetValidation: function() {
                  this.inputs.forEach(function(u) {
                    return u.resetValidation();
                  }), this.resetErrorBag();
                },
                register: function(u) {
                  this.inputs.push(u), this.watchers.push(this.watchInput(u));
                },
                unregister: function(u) {
                  var c = this.inputs.find(function(p) {
                    return p._uid === u._uid;
                  });
                  if (c) {
                    var h = this.watchers.find(function(p) {
                      return p._uid === c._uid;
                    });
                    h && (h.valid(), h.shouldValidate()), this.watchers = this.watchers.filter(function(p) {
                      return p._uid !== c._uid;
                    }), this.inputs = this.inputs.filter(function(p) {
                      return p._uid !== c._uid;
                    }), this.$delete(this.errorBag, c._uid);
                  }
                }
              },
              render: function(u) {
                var c = this;
                return u("form", {
                  staticClass: "v-form",
                  attrs: f({
                    novalidate: !0
                  }, this.attrs$),
                  on: {
                    submit: function(p) {
                      return c.$emit("submit", p);
                    }
                  }
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VForm/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VForm/index.ts ***!
            \***************************************/
          /*! exports provided: VForm, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VForm */
              "./src/components/VForm/VForm.ts"
            );
            i.d(r, "VForm", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VGrid/VCol.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/VCol.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, d.apply(this, arguments);
            }, u = ["sm", "md", "lg", "xl"], c = function() {
              return u.reduce(function(y, E) {
                return y[E] = {
                  type: [Boolean, String, Number],
                  default: !1
                }, y;
              }, {});
            }(), h = function() {
              return u.reduce(function(y, E) {
                return y["offset" + Object(f.upperFirst)(E)] = {
                  type: [String, Number],
                  default: null
                }, y;
              }, {});
            }(), p = function() {
              return u.reduce(function(y, E) {
                return y["order" + Object(f.upperFirst)(E)] = {
                  type: [String, Number],
                  default: null
                }, y;
              }, {});
            }(), g = {
              col: Object.keys(c),
              offset: Object.keys(h),
              order: Object.keys(p)
            };
            function m(y, E, C) {
              var x = y;
              if (!(C == null || C === !1)) {
                if (E) {
                  var b = E.replace(y, "");
                  x += "-" + b;
                }
                return y === "col" && (C === "" || C === !0) || (x += "-" + C), x.toLowerCase();
              }
            }
            var v = /* @__PURE__ */ new Map();
            r.default = o.a.extend({
              name: "v-col",
              functional: !0,
              props: d(d(d(d(d(d({
                cols: {
                  type: [Boolean, String, Number],
                  default: !1
                }
              }, c), {
                offset: {
                  type: [String, Number],
                  default: null
                }
              }), h), {
                order: {
                  type: [String, Number],
                  default: null
                }
              }), p), {
                alignSelf: {
                  type: String,
                  default: null,
                  validator: function(E) {
                    return ["auto", "start", "end", "center", "baseline", "stretch"].includes(E);
                  }
                },
                tag: {
                  type: String,
                  default: "div"
                }
              }),
              render: function(E, C) {
                var x, b = C.props, P = C.data, T = C.children;
                C.parent;
                var O = "";
                for (var S in b)
                  O += String(b[S]);
                var L = v.get(O);
                if (!L) {
                  L = [];
                  var A;
                  for (A in g)
                    g[A].forEach(function(_) {
                      var w = b[_], B = m(A, _, w);
                      B && L.push(B);
                    });
                  var D = L.some(function(_) {
                    return _.startsWith("col-");
                  });
                  L.push((x = {
                    // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
                    col: !D || !b.cols
                  }, x["col-" + b.cols] = b.cols, x["offset-" + b.offset] = b.offset, x["order-" + b.order] = b.order, x["align-self-" + b.alignSelf] = b.alignSelf, x)), v.set(O, L);
                }
                return E(b.tag, Object(l.default)(P, {
                  class: L
                }), T);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VContainer.ts": (
          /*!********************************************!*\
            !*** ./src/components/VGrid/VContainer.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            ), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            ), o = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            r.default = Object(a.default)("container").extend({
              name: "v-container",
              functional: !0,
              props: {
                id: String,
                tag: {
                  type: String,
                  default: "div"
                },
                fluid: {
                  type: Boolean,
                  default: !1
                }
              },
              render: function(f, d) {
                var u = d.props, c = d.data, h = d.children, p, g = c.attrs;
                return g && (c.attrs = {}, p = Object.keys(g).filter(function(m) {
                  if (m === "slot")
                    return !1;
                  var v = g[m];
                  return m.startsWith("data-") ? (c.attrs[m] = v, !1) : v || typeof v == "string";
                })), u.id && (c.domProps = c.domProps || {}, c.domProps.id = u.id), f(u.tag, Object(o.default)(c, {
                  staticClass: "container",
                  class: Array({
                    "container--fluid": u.fluid
                  }).concat(p || [])
                }), h);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VFlex.ts": (
          /*!***************************************!*\
            !*** ./src/components/VGrid/VFlex.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            );
            r.default = Object(a.default)("flex");
          }
        ),
        /***/
        "./src/components/VGrid/VGrid.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VGrid.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VGrid/VLayout.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VLayout.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            );
            r.default = Object(a.default)("layout");
          }
        ),
        /***/
        "./src/components/VGrid/VRow.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/VRow.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(S) {
                for (var L, A = 1, D = arguments.length; A < D; A++) {
                  L = arguments[A];
                  for (var _ in L)
                    Object.prototype.hasOwnProperty.call(L, _) && (S[_] = L[_]);
                }
                return S;
              }, d.apply(this, arguments);
            }, u = function(S, L) {
              var A = typeof Symbol == "function" && S[Symbol.iterator];
              if (!A)
                return S;
              var D = A.call(S), _, w = [], B;
              try {
                for (; (L === void 0 || L-- > 0) && !(_ = D.next()).done; )
                  w.push(_.value);
              } catch (j) {
                B = {
                  error: j
                };
              } finally {
                try {
                  _ && !_.done && (A = D.return) && A.call(D);
                } finally {
                  if (B)
                    throw B.error;
                }
              }
              return w;
            }, c = function(S, L, A) {
              if (A || arguments.length === 2)
                for (var D = 0, _ = L.length, w; D < _; D++)
                  (w || !(D in L)) && (w || (w = Array.prototype.slice.call(L, 0, D)), w[D] = L[D]);
              return S.concat(w || Array.prototype.slice.call(L));
            }, h = ["sm", "md", "lg", "xl"], p = ["start", "end", "center"];
            function g(S, L) {
              return h.reduce(function(A, D) {
                return A[S + Object(f.upperFirst)(D)] = L(), A;
              }, {});
            }
            var m = function(L) {
              return c(c([], u(p), !1), ["baseline", "stretch"], !1).includes(L);
            }, v = g("align", function() {
              return {
                type: String,
                default: null,
                validator: m
              };
            }), y = function(L) {
              return c(c([], u(p), !1), ["space-between", "space-around"], !1).includes(L);
            }, E = g("justify", function() {
              return {
                type: String,
                default: null,
                validator: y
              };
            }), C = function(L) {
              return c(c([], u(p), !1), ["space-between", "space-around", "stretch"], !1).includes(L);
            }, x = g("alignContent", function() {
              return {
                type: String,
                default: null,
                validator: C
              };
            }), b = {
              align: Object.keys(v),
              justify: Object.keys(E),
              alignContent: Object.keys(x)
            }, P = {
              align: "align",
              justify: "justify",
              alignContent: "align-content"
            };
            function T(S, L, A) {
              var D = P[S];
              if (A != null) {
                if (L) {
                  var _ = L.replace(S, "");
                  D += "-" + _;
                }
                return D += "-" + A, D.toLowerCase();
              }
            }
            var O = /* @__PURE__ */ new Map();
            r.default = o.a.extend({
              name: "v-row",
              functional: !0,
              props: d(d(d(d(d({
                tag: {
                  type: String,
                  default: "div"
                },
                dense: Boolean,
                noGutters: Boolean,
                align: {
                  type: String,
                  default: null,
                  validator: m
                }
              }, v), {
                justify: {
                  type: String,
                  default: null,
                  validator: y
                }
              }), E), {
                alignContent: {
                  type: String,
                  default: null,
                  validator: C
                }
              }), x),
              render: function(L, A) {
                var D, _ = A.props, w = A.data, B = A.children, j = "";
                for (var k in _)
                  j += String(_[k]);
                var X = O.get(j);
                if (!X) {
                  X = [];
                  var rt;
                  for (rt in b)
                    b[rt].forEach(function(et) {
                      var Z = _[et], dt = T(rt, et, Z);
                      dt && X.push(dt);
                    });
                  X.push((D = {
                    "no-gutters": _.noGutters,
                    "row--dense": _.dense
                  }, D["align-" + _.align] = _.align, D["justify-" + _.justify] = _.justify, D["align-content-" + _.alignContent] = _.alignContent, D)), O.set(j, X);
                }
                return L(_.tag, Object(l.default)(w, {
                  staticClass: "row",
                  class: X
                }), B);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VSpacer.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VSpacer.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(a.createSimpleFunctional)("spacer", "div", "v-spacer");
          }
        ),
        /***/
        "./src/components/VGrid/_grid.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/_grid.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VGrid/grid.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/grid.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(f) {
              return o.a.extend({
                name: "v-" + f,
                functional: !0,
                props: {
                  id: String,
                  tag: {
                    type: String,
                    default: "div"
                  }
                },
                render: function(u, c) {
                  var h = c.props, p = c.data, g = c.children;
                  p.staticClass = (f + " " + (p.staticClass || "")).trim();
                  var m = p.attrs;
                  if (m) {
                    p.attrs = {};
                    var v = Object.keys(m).filter(function(y) {
                      if (y === "slot")
                        return !1;
                      var E = m[y];
                      return y.startsWith("data-") ? (p.attrs[y] = E, !1) : E || typeof E == "string";
                    });
                    v.length && (p.staticClass += " " + v.join(" "));
                  }
                  return h.id && (p.domProps = p.domProps || {}, p.domProps.id = h.id), u(h.tag, p, g);
                }
              });
            }
          }
        ),
        /***/
        "./src/components/VGrid/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VGrid/index.ts ***!
            \***************************************/
          /*! exports provided: VContainer, VCol, VRow, VSpacer, VLayout, VFlex, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VContainer */
              "./src/components/VGrid/VContainer.ts"
            );
            i.d(r, "VContainer", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCol */
              "./src/components/VGrid/VCol.ts"
            );
            i.d(r, "VCol", function() {
              return o.default;
            });
            var l = i(
              /*! ./VRow */
              "./src/components/VGrid/VRow.ts"
            );
            i.d(r, "VRow", function() {
              return l.default;
            });
            var f = i(
              /*! ./VSpacer */
              "./src/components/VGrid/VSpacer.ts"
            );
            i.d(r, "VSpacer", function() {
              return f.default;
            });
            var d = i(
              /*! ./VLayout */
              "./src/components/VGrid/VLayout.ts"
            );
            i.d(r, "VLayout", function() {
              return d.default;
            });
            var u = i(
              /*! ./VFlex */
              "./src/components/VGrid/VFlex.ts"
            );
            i.d(r, "VFlex", function() {
              return u.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VContainer: a.default,
                VCol: o.default,
                VRow: l.default,
                VSpacer: f.default,
                VLayout: d.default,
                VFlex: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VHover/VHover.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VHover/VHover.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), o = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = Object(l.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-hover",
              props: {
                disabled: {
                  type: Boolean,
                  default: !1
                },
                value: {
                  type: Boolean,
                  default: void 0
                }
              },
              methods: {
                onMouseEnter: function() {
                  this.runDelay("open");
                },
                onMouseLeave: function() {
                  this.runDelay("close");
                }
              },
              render: function() {
                if (!this.$scopedSlots.default && this.value === void 0)
                  return Object(f.consoleWarn)("v-hover is missing a default scopedSlot or bound value", this), null;
                var u;
                return this.$scopedSlots.default && (u = this.$scopedSlots.default({
                  hover: this.isActive
                })), Array.isArray(u) && u.length === 1 && (u = u[0]), !u || Array.isArray(u) || !u.tag ? (Object(f.consoleWarn)("v-hover should only contain a single element", this), u) : (this.disabled || (u.data = u.data || {}, this._g(u.data, {
                  mouseenter: this.onMouseEnter,
                  mouseleave: this.onMouseLeave
                })), u);
              }
            });
          }
        ),
        /***/
        "./src/components/VHover/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VHover/index.ts ***!
            \****************************************/
          /*! exports provided: VHover, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VHover */
              "./src/components/VHover/VHover.ts"
            );
            i.d(r, "VHover", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VIcon/VIcon.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VIcon/VIcon.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VIcon/VIcon.ts": (
          /*!***************************************!*\
            !*** ./src/components/VIcon/VIcon.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VIcon.sass */
              "./src/components/VIcon/VIcon.sass"
            );
            var a = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! vue */
              "vue"
            ), c = /* @__PURE__ */ i.n(u), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(E) {
                for (var C, x = 1, b = arguments.length; x < b; x++) {
                  C = arguments[x];
                  for (var P in C)
                    Object.prototype.hasOwnProperty.call(C, P) && (E[P] = C[P]);
                }
                return E;
              }, p.apply(this, arguments);
            }, g;
            (function(E) {
              E.xSmall = "12px", E.small = "16px", E.default = "24px", E.medium = "28px", E.large = "36px", E.xLarge = "40px";
            })(g || (g = {}));
            function m(E) {
              return ["fas", "far", "fal", "fab", "fad", "fak"].some(function(C) {
                return E.includes(C);
              });
            }
            function v(E) {
              return /^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(E) && /[\dz]$/i.test(E) && E.length > 4;
            }
            var y = Object(h.default)(
              a.default,
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-icon",
              props: {
                dense: Boolean,
                disabled: Boolean,
                left: Boolean,
                right: Boolean,
                size: [Number, String],
                tag: {
                  type: String,
                  required: !1,
                  default: "i"
                }
              },
              computed: {
                medium: function() {
                  return !1;
                },
                hasClickListener: function() {
                  return !!(this.listeners$.click || this.listeners$["!click"]);
                }
              },
              methods: {
                getIcon: function() {
                  var C = "";
                  return this.$slots.default && (C = this.$slots.default[0].text.trim()), Object(d.remapInternalIcon)(this, C);
                },
                getSize: function() {
                  var C = {
                    xSmall: this.xSmall,
                    small: this.small,
                    medium: this.medium,
                    large: this.large,
                    xLarge: this.xLarge
                  }, x = Object(d.keys)(C).find(function(b) {
                    return C[b];
                  });
                  return x && g[x] || Object(d.convertToUnit)(this.size);
                },
                // Component data for both font icon and SVG wrapper span
                getDefaultData: function() {
                  return {
                    staticClass: "v-icon notranslate",
                    class: {
                      "v-icon--disabled": this.disabled,
                      "v-icon--left": this.left,
                      "v-icon--link": this.hasClickListener,
                      "v-icon--right": this.right,
                      "v-icon--dense": this.dense
                    },
                    attrs: p({
                      "aria-hidden": !this.hasClickListener,
                      disabled: this.hasClickListener && this.disabled,
                      type: this.hasClickListener ? "button" : void 0
                    }, this.attrs$),
                    on: this.listeners$
                  };
                },
                getSvgWrapperData: function() {
                  var C = this.getSize(), x = p(p({}, this.getDefaultData()), {
                    style: C ? {
                      fontSize: C,
                      height: C,
                      width: C
                    } : void 0
                  });
                  return this.applyColors(x), x;
                },
                applyColors: function(C) {
                  C.class = p(p({}, C.class), this.themeClasses), this.setTextColor(this.color, C);
                },
                renderFontIcon: function(C, x) {
                  var b = [], P = this.getDefaultData(), T = "material-icons", O = C.indexOf("-"), S = O <= -1;
                  S ? b.push(C) : (T = C.slice(0, O), m(T) && (T = "")), P.class[T] = !0, P.class[C] = !S;
                  var L = this.getSize();
                  return L && (P.style = {
                    fontSize: L
                  }), this.applyColors(P), x(this.hasClickListener ? "button" : this.tag, P, b);
                },
                renderSvgIcon: function(C, x) {
                  var b = {
                    class: "v-icon__svg",
                    attrs: {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: "0 0 24 24",
                      role: "img",
                      "aria-hidden": !0
                    }
                  }, P = this.getSize();
                  return P && (b.style = {
                    fontSize: P,
                    height: P,
                    width: P
                  }), x(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [x("svg", b, [x("path", {
                    attrs: {
                      d: C
                    }
                  })])]);
                },
                renderSvgIconComponent: function(C, x) {
                  var b = {
                    class: {
                      "v-icon__component": !0
                    }
                  }, P = this.getSize();
                  P && (b.style = {
                    fontSize: P,
                    height: P,
                    width: P
                  }), this.applyColors(b);
                  var T = C.component;
                  return b.props = C.props, b.nativeOn = b.on, x(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [x(T, b)]);
                }
              },
              render: function(C) {
                var x = this.getIcon();
                return typeof x == "string" ? v(x) ? this.renderSvgIcon(x, C) : this.renderFontIcon(x, C) : this.renderSvgIconComponent(x, C);
              }
            });
            r.default = c.a.extend({
              name: "v-icon",
              $_wrapperFor: y,
              functional: !0,
              render: function(C, x) {
                var b = x.data, P = x.children, T = "";
                return b.domProps && (T = b.domProps.textContent || b.domProps.innerHTML || T, delete b.domProps.textContent, delete b.domProps.innerHTML), C(y, b, T ? [T] : P);
              }
            });
          }
        ),
        /***/
        "./src/components/VIcon/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VIcon/index.ts ***!
            \***************************************/
          /*! exports provided: VIcon, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VIcon */
              "./src/components/VIcon/VIcon.ts"
            );
            i.d(r, "VIcon", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VImg/VImg.sass": (
          /*!***************************************!*\
            !*** ./src/components/VImg/VImg.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VImg/VImg.ts": (
          /*!*************************************!*\
            !*** ./src/components/VImg/VImg.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VImg.sass */
              "./src/components/VImg/VImg.sass"
            );
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../VResponsive */
              "./src/components/VResponsive/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function h(g) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? h = function(v) {
                return typeof v;
              } : h = function(v) {
                return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
              }, h(g);
            }
            var p = typeof window < "u" && "IntersectionObserver" in window;
            r.default = Object(f.default)(o.default, l.default).extend({
              name: "v-img",
              directives: {
                intersect: a.default
              },
              props: {
                alt: String,
                contain: Boolean,
                eager: Boolean,
                gradient: String,
                lazySrc: String,
                options: {
                  type: Object,
                  // For more information on types, navigate to:
                  // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                  default: function() {
                    return {
                      root: void 0,
                      rootMargin: void 0,
                      threshold: void 0
                    };
                  }
                },
                position: {
                  type: String,
                  default: "center center"
                },
                sizes: String,
                src: {
                  type: [String, Object],
                  default: ""
                },
                srcset: String,
                transition: {
                  type: [Boolean, String],
                  default: "fade-transition"
                }
              },
              data: function() {
                return {
                  currentSrc: "",
                  image: null,
                  isLoading: !0,
                  calculatedAspectRatio: void 0,
                  naturalWidth: void 0,
                  hasError: !1
                };
              },
              computed: {
                computedAspectRatio: function() {
                  return Number(this.normalisedSrc.aspect || this.calculatedAspectRatio);
                },
                normalisedSrc: function() {
                  return this.src && h(this.src) === "object" ? {
                    src: this.src.src,
                    srcset: this.srcset || this.src.srcset,
                    lazySrc: this.lazySrc || this.src.lazySrc,
                    aspect: Number(this.aspectRatio || this.src.aspect)
                  } : {
                    src: this.src,
                    srcset: this.srcset,
                    lazySrc: this.lazySrc,
                    aspect: Number(this.aspectRatio || 0)
                  };
                },
                __cachedImage: function() {
                  if (!(this.normalisedSrc.src || this.normalisedSrc.lazySrc || this.gradient))
                    return [];
                  var m = [], v = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc;
                  this.gradient && m.push("linear-gradient(" + this.gradient + ")"), v && m.push('url("' + v + '")');
                  var y = this.$createElement("div", {
                    staticClass: "v-image__image",
                    class: {
                      "v-image__image--preload": this.isLoading,
                      "v-image__image--contain": this.contain,
                      "v-image__image--cover": !this.contain
                    },
                    style: {
                      backgroundImage: m.join(", "),
                      backgroundPosition: this.position
                    },
                    key: +this.isLoading
                  });
                  return this.transition ? this.$createElement("transition", {
                    attrs: {
                      name: this.transition,
                      mode: "in-out"
                    }
                  }, [y]) : y;
                }
              },
              watch: {
                src: function() {
                  this.isLoading ? this.loadImage() : this.init(void 0, void 0, !0);
                },
                "$vuetify.breakpoint.width": "getSrc"
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function(m, v, y) {
                  if (!(p && !y && !this.eager)) {
                    if (this.normalisedSrc.lazySrc) {
                      var E = new Image();
                      E.src = this.normalisedSrc.lazySrc, this.pollForSize(E, null);
                    }
                    this.normalisedSrc.src && this.loadImage();
                  }
                },
                onLoad: function() {
                  this.getSrc(), this.isLoading = !1, this.$emit("load", this.src), this.image && (this.normalisedSrc.src.endsWith(".svg") || this.normalisedSrc.src.startsWith("data:image/svg+xml")) && (this.image.naturalHeight && this.image.naturalWidth ? (this.naturalWidth = this.image.naturalWidth, this.calculatedAspectRatio = this.image.naturalWidth / this.image.naturalHeight) : this.calculatedAspectRatio = 1);
                },
                onError: function() {
                  this.hasError = !0, this.$emit("error", this.src);
                },
                getSrc: function() {
                  this.image && (this.currentSrc = this.image.currentSrc || this.image.src);
                },
                loadImage: function() {
                  var m = this, v = new Image();
                  this.image = v, v.onload = function() {
                    v.decode ? v.decode().catch(function(y) {
                      Object(u.consoleWarn)(`Failed to decode image, trying to render anyway

` + ("src: " + m.normalisedSrc.src) + (y.message ? `
Original error: ` + y.message : ""), m);
                    }).then(m.onLoad) : m.onLoad();
                  }, v.onerror = this.onError, this.hasError = !1, this.sizes && (v.sizes = this.sizes), this.normalisedSrc.srcset && (v.srcset = this.normalisedSrc.srcset), v.src = this.normalisedSrc.src, this.$emit("loadstart", this.normalisedSrc.src), this.aspectRatio || this.pollForSize(v), this.getSrc();
                },
                pollForSize: function(m, v) {
                  var y = this;
                  v === void 0 && (v = 100);
                  var E = function C() {
                    var x = m.naturalHeight, b = m.naturalWidth;
                    x || b ? (y.naturalWidth = b, y.calculatedAspectRatio = b / x) : !m.complete && y.isLoading && !y.hasError && v != null && setTimeout(C, v);
                  };
                  E();
                },
                genContent: function() {
                  var m = o.default.options.methods.genContent.call(this);
                  return this.naturalWidth && this._b(m.data, "div", {
                    style: {
                      width: this.naturalWidth + "px"
                    }
                  }), m;
                },
                __genPlaceholder: function() {
                  var m = Object(c.getSlot)(this, "placeholder");
                  if (m) {
                    var v = this.isLoading ? [this.$createElement("div", {
                      staticClass: "v-image__placeholder"
                    }, m)] : [];
                    return this.transition ? this.$createElement("transition", {
                      props: {
                        appear: !0,
                        name: this.transition
                      }
                    }, v) : v[0];
                  }
                }
              },
              render: function(m) {
                var v = o.default.options.render.call(this, m), y = Object(d.default)(v.data, {
                  staticClass: "v-image",
                  attrs: {
                    "aria-label": this.alt,
                    role: this.alt ? "img" : void 0
                  },
                  class: this.themeClasses,
                  // Only load intersect directive if it
                  // will work in the current browser.
                  directives: p ? [{
                    name: "intersect",
                    modifiers: {
                      once: !0
                    },
                    value: {
                      handler: this.init,
                      options: this.options
                    }
                  }] : void 0
                });
                return v.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()], m(v.tag, y, v.children);
              }
            });
          }
        ),
        /***/
        "./src/components/VImg/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VImg/index.ts ***!
            \**************************************/
          /*! exports provided: VImg, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VImg */
              "./src/components/VImg/VImg.ts"
            );
            i.d(r, "VImg", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VInput/VInput.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VInput/VInput.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VInput/VInput.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VInput/VInput.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VInput.sass */
              "./src/components/VInput/VInput.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), l = i(
              /*! ../VMessages */
              "./src/components/VMessages/index.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/validatable */
              "./src/mixins/validatable/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(f.default, d.default);
            r.default = g.extend().extend({
              name: "v-input",
              inheritAttrs: !1,
              props: {
                appendIcon: String,
                backgroundColor: {
                  type: String,
                  default: ""
                },
                dense: Boolean,
                height: [Number, String],
                hideDetails: [Boolean, String],
                hideSpinButtons: Boolean,
                hint: String,
                id: String,
                label: String,
                loading: Boolean,
                persistentHint: Boolean,
                prependIcon: String,
                value: null
              },
              data: function() {
                return {
                  lazyValue: this.value,
                  hasMouseDown: !1
                };
              },
              computed: {
                classes: function() {
                  return p({
                    "v-input--has-state": this.hasState,
                    "v-input--hide-details": !this.showDetails,
                    "v-input--is-label-active": this.isLabelActive,
                    "v-input--is-dirty": this.isDirty,
                    "v-input--is-disabled": this.isDisabled,
                    "v-input--is-focused": this.isFocused,
                    // <v-switch loading>.loading === '' so we can't just cast to boolean
                    "v-input--is-loading": this.loading !== !1 && this.loading != null,
                    "v-input--is-readonly": this.isReadonly,
                    "v-input--dense": this.dense,
                    "v-input--hide-spin-buttons": this.hideSpinButtons
                  }, this.themeClasses);
                },
                computedId: function() {
                  return this.id || "input-" + this._uid;
                },
                hasDetails: function() {
                  return this.messagesToDisplay.length > 0;
                },
                hasHint: function() {
                  return !this.hasMessages && !!this.hint && (this.persistentHint || this.isFocused);
                },
                hasLabel: function() {
                  return !!(this.$slots.label || this.label);
                },
                // Proxy for `lazyValue`
                // This allows an input
                // to function without
                // a provided model
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(v) {
                    this.lazyValue = v, this.$emit(this.$_modelEvent, v);
                  }
                },
                isDirty: function() {
                  return !!this.lazyValue;
                },
                isLabelActive: function() {
                  return this.isDirty;
                },
                messagesToDisplay: function() {
                  var v = this;
                  return this.hasHint ? [this.hint] : this.hasMessages ? this.validations.map(function(y) {
                    if (typeof y == "string")
                      return y;
                    var E = y(v.internalValue);
                    return typeof E == "string" ? E : "";
                  }).filter(function(y) {
                    return y !== "";
                  }) : [];
                },
                showDetails: function() {
                  return this.hideDetails === !1 || this.hideDetails === "auto" && this.hasDetails;
                }
              },
              watch: {
                value: function(v) {
                  this.lazyValue = v;
                }
              },
              beforeCreate: function() {
                this.$_modelEvent = this.$options.model && this.$options.model.event || "input";
              },
              methods: {
                genContent: function() {
                  return [this.genPrependSlot(), this.genControl(), this.genAppendSlot()];
                },
                genControl: function() {
                  return this.$createElement("div", {
                    staticClass: "v-input__control",
                    attrs: {
                      title: this.attrs$.title
                    }
                  }, [this.genInputSlot(), this.genMessages()]);
                },
                genDefaultSlot: function() {
                  return [this.genLabel(), this.$slots.default];
                },
                genIcon: function(v, y, E) {
                  var C = this, x;
                  E === void 0 && (E = {});
                  var b = this[v + "Icon"], P = "click:" + Object(u.kebabCase)(v), T = !!(this.listeners$[P] || y), O = {
                    prepend: "prependAction",
                    prependInner: "prependAction",
                    append: "appendAction",
                    appendOuter: "appendAction",
                    clear: "clear"
                  }[v], S = T && O ? this.$vuetify.lang.t("$vuetify.input." + O, (x = this.label) !== null && x !== void 0 ? x : "") : void 0, L = Object(c.default)({
                    attrs: {
                      "aria-label": S,
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      light: this.light,
                      tabindex: v === "clear" ? -1 : void 0
                    },
                    on: T ? {
                      click: function(D) {
                        D.preventDefault(), D.stopPropagation(), C.$emit(P, D), y && y(D);
                      },
                      // Container has g event that will
                      // trigger menu open if enclosed
                      mouseup: function(D) {
                        D.preventDefault(), D.stopPropagation();
                      }
                    } : void 0
                  }, E);
                  return this.$createElement("div", {
                    staticClass: "v-input__icon",
                    class: v ? "v-input__icon--" + Object(u.kebabCase)(v) : void 0
                  }, [this.$createElement(a.default, L, b)]);
                },
                genInputSlot: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
                    staticClass: "v-input__slot",
                    style: {
                      height: Object(u.convertToUnit)(this.height)
                    },
                    on: {
                      click: this.onClick,
                      mousedown: this.onMouseDown,
                      mouseup: this.onMouseUp
                    },
                    ref: "input-slot"
                  }), [this.genDefaultSlot()]);
                },
                genLabel: function() {
                  return this.hasLabel ? this.$createElement(o.default, {
                    props: {
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      focused: this.hasState,
                      for: this.computedId,
                      light: this.light
                    }
                  }, this.$slots.label || this.label) : null;
                },
                genMessages: function() {
                  var v = this;
                  return this.showDetails ? this.$createElement(l.default, {
                    props: {
                      color: this.hasHint ? "" : this.validationState,
                      dark: this.dark,
                      light: this.light,
                      value: this.messagesToDisplay
                    },
                    attrs: {
                      role: this.hasMessages ? "alert" : null
                    },
                    scopedSlots: {
                      default: function(E) {
                        return Object(u.getSlot)(v, "message", E);
                      }
                    }
                  }) : null;
                },
                genSlot: function(v, y, E) {
                  if (!E.length)
                    return null;
                  var C = v + "-" + y;
                  return this.$createElement("div", {
                    staticClass: "v-input__" + C,
                    ref: C
                  }, E);
                },
                genPrependSlot: function() {
                  var v = [];
                  return this.$slots.prepend ? v.push(this.$slots.prepend) : this.prependIcon && v.push(this.genIcon("prepend")), this.genSlot("prepend", "outer", v);
                },
                genAppendSlot: function() {
                  var v = [];
                  return this.$slots.append ? v.push(this.$slots.append) : this.appendIcon && v.push(this.genIcon("append")), this.genSlot("append", "outer", v);
                },
                onClick: function(v) {
                  this.$emit("click", v);
                },
                onMouseDown: function(v) {
                  this.hasMouseDown = !0, this.$emit("mousedown", v);
                },
                onMouseUp: function(v) {
                  this.hasMouseDown = !1, this.$emit("mouseup", v);
                }
              },
              render: function(v) {
                return v("div", this.setTextColor(this.validationState, {
                  staticClass: "v-input",
                  class: this.classes
                }), this.genContent());
              }
            });
          }
        ),
        /***/
        "./src/components/VInput/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VInput/index.ts ***!
            \****************************************/
          /*! exports provided: VInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VInput */
              "./src/components/VInput/VInput.ts"
            );
            i.d(r, "VInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VItemGroup/VItem.sass": (
          /*!**********************************************!*\
            !*** ./src/components/VItemGroup/VItem.sass ***!
            \**********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VItemGroup/VItem.ts": (
          /*!********************************************!*\
            !*** ./src/components/VItemGroup/VItem.ts ***!
            \********************************************/
          /*! exports provided: BaseItem, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "BaseItem", function() {
              return c;
            }), i(
              /*! ./VItem.sass */
              "./src/components/VItemGroup/VItem.sass"
            );
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = d.a.extend({
              props: {
                activeClass: String,
                value: {
                  required: !1
                },
                disabled: Boolean
              },
              data: function() {
                return {
                  isActive: !1
                };
              },
              methods: {
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              },
              render: function() {
                var p;
                if (!this.$scopedSlots.default)
                  return Object(l.consoleWarn)("v-item is missing a default scopedSlot", this), null;
                var g;
                return this.$scopedSlots.default && (g = this.$scopedSlots.default({
                  active: this.isActive,
                  toggle: this.toggle
                })), Array.isArray(g) && g.length === 1 && (g = g[0]), !g || Array.isArray(g) || !g.tag ? (Object(l.consoleWarn)("v-item should only contain a single element", this), g) : (g.data = this._b(g.data || {}, g.tag, {
                  class: (p = {}, p[this.activeClass] = this.isActive, p["v-item--disabled"] = this.disabled, p)
                }), this.disabled && (g.data.attrs = u(u({}, g.data.attrs), {
                  tabindex: -1
                })), g);
              }
            });
            r.default = Object(o.default)(c, Object(a.factory)("itemGroup", "v-item", "v-item-group")).extend({
              name: "v-item"
            });
          }
        ),
        /***/
        "./src/components/VItemGroup/VItemGroup.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VItemGroup/VItemGroup.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VItemGroup/VItemGroup.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VItemGroup/VItemGroup.ts ***!
            \*************************************************/
          /*! exports provided: BaseItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "BaseItemGroup", function() {
              return c;
            }), i(
              /*! ./VItemGroup.sass */
              "./src/components/VItemGroup/VItemGroup.sass"
            );
            var a = i(
              /*! ../../mixins/comparable */
              "./src/mixins/comparable/index.ts"
            ), o = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(f.default)(a.default, o.default, l.default).extend({
              name: "base-item-group",
              props: {
                activeClass: {
                  type: String,
                  default: "v-item--active"
                },
                mandatory: Boolean,
                max: {
                  type: [Number, String],
                  default: null
                },
                multiple: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              data: function() {
                return {
                  // As long as a value is defined, show it
                  // Otherwise, check if multiple
                  // to determine which default to provide
                  internalLazyValue: this.value !== void 0 ? this.value : this.multiple ? [] : void 0,
                  items: []
                };
              },
              computed: {
                classes: function() {
                  return u({
                    "v-item-group": !0
                  }, this.themeClasses);
                },
                selectedIndex: function() {
                  return this.selectedItem && this.items.indexOf(this.selectedItem) || -1;
                },
                selectedItem: function() {
                  if (!this.multiple)
                    return this.selectedItems[0];
                },
                selectedItems: function() {
                  var p = this;
                  return this.items.filter(function(g, m) {
                    return p.toggleMethod(p.getValue(g, m));
                  });
                },
                selectedValues: function() {
                  return this.internalValue == null ? [] : Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue];
                },
                toggleMethod: function() {
                  var p = this;
                  if (!this.multiple)
                    return function(m) {
                      return p.valueComparator(p.internalValue, m);
                    };
                  var g = this.internalValue;
                  return Array.isArray(g) ? function(m) {
                    return g.some(function(v) {
                      return p.valueComparator(v, m);
                    });
                  } : function() {
                    return !1;
                  };
                }
              },
              watch: {
                internalValue: "updateItemsState",
                items: "updateItemsState"
              },
              created: function() {
                this.multiple && !Array.isArray(this.internalValue) && Object(d.consoleWarn)("Model must be bound to an array if the multiple property is true.", this);
              },
              methods: {
                genData: function() {
                  return {
                    class: this.classes
                  };
                },
                getValue: function(p, g) {
                  return p.value === void 0 ? g : p.value;
                },
                onClick: function(p) {
                  this.updateInternalValue(this.getValue(p, this.items.indexOf(p)));
                },
                register: function(p) {
                  var g = this, m = this.items.push(p) - 1;
                  p.$on("change", function() {
                    return g.onClick(p);
                  }), this.mandatory && !this.selectedValues.length && this.updateMandatory(), this.updateItem(p, m);
                },
                unregister: function(p) {
                  if (!this._isDestroyed) {
                    var g = this.items.indexOf(p), m = this.getValue(p, g);
                    this.items.splice(g, 1);
                    var v = this.selectedValues.indexOf(m);
                    if (!(v < 0)) {
                      if (!this.mandatory)
                        return this.updateInternalValue(m);
                      this.multiple && Array.isArray(this.internalValue) ? this.internalValue = this.internalValue.filter(function(y) {
                        return y !== m;
                      }) : this.internalValue = void 0, this.selectedItems.length || this.updateMandatory(!0);
                    }
                  }
                },
                updateItem: function(p, g) {
                  var m = this.getValue(p, g);
                  p.isActive = this.toggleMethod(m);
                },
                // https://github.com/vuetifyjs/vuetify/issues/5352
                updateItemsState: function() {
                  var p = this;
                  this.$nextTick(function() {
                    if (p.mandatory && !p.selectedItems.length)
                      return p.updateMandatory();
                    p.items.forEach(p.updateItem);
                  });
                },
                updateInternalValue: function(p) {
                  this.multiple ? this.updateMultiple(p) : this.updateSingle(p);
                },
                updateMandatory: function(p) {
                  if (this.items.length) {
                    var g = this.items.slice();
                    p && g.reverse();
                    var m = g.find(function(y) {
                      return !y.disabled;
                    });
                    if (m) {
                      var v = this.items.indexOf(m);
                      this.updateInternalValue(this.getValue(m, v));
                    }
                  }
                },
                updateMultiple: function(p) {
                  var g = this, m = Array.isArray(this.internalValue) ? this.internalValue : [], v = m.slice(), y = v.findIndex(function(E) {
                    return g.valueComparator(E, p);
                  });
                  this.mandatory && // Item already exists
                  y > -1 && // value would be reduced below min
                  v.length - 1 < 1 || // Max is set
                  this.max != null && // Item doesn't exist
                  y < 0 && // value would be increased above max
                  v.length + 1 > this.max || (y > -1 ? v.splice(y, 1) : v.push(p), this.internalValue = v);
                },
                updateSingle: function(p) {
                  var g = this.valueComparator(this.internalValue, p);
                  this.mandatory && g || (this.internalValue = g ? void 0 : p);
                }
              },
              render: function(p) {
                return p(this.tag, this.genData(), this.$slots.default);
              }
            });
            r.default = c.extend({
              name: "v-item-group",
              provide: function() {
                return {
                  itemGroup: this
                };
              }
            });
          }
        ),
        /***/
        "./src/components/VItemGroup/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VItemGroup/index.ts ***!
            \********************************************/
          /*! exports provided: VItem, VItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VItem */
              "./src/components/VItemGroup/VItem.ts"
            );
            i.d(r, "VItem", function() {
              return a.default;
            });
            var o = i(
              /*! ./VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            );
            i.d(r, "VItemGroup", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VItem: a.default,
                VItemGroup: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VLabel/VLabel.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VLabel/VLabel.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VLabel/VLabel.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VLabel/VLabel.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VLabel.sass */
              "./src/components/VLabel/VLabel.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(l.default)(o.default).extend({
              name: "v-label",
              functional: !0,
              props: {
                absolute: Boolean,
                color: {
                  type: String,
                  default: "primary"
                },
                disabled: Boolean,
                focused: Boolean,
                for: String,
                left: {
                  type: [Number, String],
                  default: 0
                },
                right: {
                  type: [Number, String],
                  default: "auto"
                },
                value: Boolean
              },
              render: function(h, p) {
                var g = p.children, m = p.listeners, v = p.props, y = p.data, E = Object(d.default)({
                  staticClass: "v-label",
                  class: u({
                    "v-label--active": v.value,
                    "v-label--is-disabled": v.disabled
                  }, Object(o.functionalThemeClasses)(p)),
                  attrs: {
                    for: v.for,
                    "aria-hidden": !v.for
                  },
                  on: m,
                  style: {
                    left: Object(f.convertToUnit)(v.left),
                    right: Object(f.convertToUnit)(v.right),
                    position: v.absolute ? "absolute" : "relative"
                  },
                  ref: "label"
                }, y);
                return h("label", a.default.options.methods.setTextColor(v.focused && v.color, E), g);
              }
            });
          }
        ),
        /***/
        "./src/components/VLabel/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VLabel/index.ts ***!
            \****************************************/
          /*! exports provided: VLabel, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VLabel */
              "./src/components/VLabel/VLabel.ts"
            );
            i.d(r, "VLabel", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VLazy/VLazy.ts": (
          /*!***************************************!*\
            !*** ./src/components/VLazy/VLazy.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, o.default).extend({
              name: "VLazy",
              directives: {
                intersect: l.default
              },
              props: {
                options: {
                  type: Object,
                  // For more information on types, navigate to:
                  // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                  default: function() {
                    return {
                      root: void 0,
                      rootMargin: void 0,
                      threshold: void 0
                    };
                  }
                },
                tag: {
                  type: String,
                  default: "div"
                },
                transition: {
                  type: String,
                  default: "fade-transition"
                }
              },
              computed: {
                styles: function() {
                  return u({}, this.measurableStyles);
                }
              },
              methods: {
                genContent: function() {
                  var h = this.isActive && Object(d.getSlot)(this);
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, h) : h;
                },
                onObserve: function(h, p, g) {
                  this.isActive || (this.isActive = g);
                }
              },
              render: function(h) {
                return h(this.tag, {
                  staticClass: "v-lazy",
                  attrs: this.$attrs,
                  directives: [{
                    name: "intersect",
                    value: {
                      handler: this.onObserve,
                      options: this.options
                    }
                  }],
                  on: this.$listeners,
                  style: this.styles
                }, [this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VLazy/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VLazy/index.ts ***!
            \***************************************/
          /*! exports provided: VLazy, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VLazy */
              "./src/components/VLazy/VLazy.ts"
            );
            i.d(r, "VLazy", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VList/VList.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VList/VList.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VList.ts": (
          /*!***************************************!*\
            !*** ./src/components/VList/VList.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VList.sass */
              "./src/components/VList/VList.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = function() {
              return o = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, o.apply(this, arguments);
            }, l = function(f) {
              var d = typeof Symbol == "function" && Symbol.iterator, u = d && f[d], c = 0;
              if (u)
                return u.call(f);
              if (f && typeof f.length == "number")
                return {
                  next: function() {
                    return f && c >= f.length && (f = void 0), {
                      value: f && f[c++],
                      done: !f
                    };
                  }
                };
              throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = a.default.extend().extend({
              name: "v-list",
              provide: function() {
                return {
                  isInList: !0,
                  list: this
                };
              },
              inject: {
                isInMenu: {
                  default: !1
                },
                isInNav: {
                  default: !1
                }
              },
              props: {
                dense: Boolean,
                disabled: Boolean,
                expand: Boolean,
                flat: Boolean,
                nav: Boolean,
                rounded: Boolean,
                subheader: Boolean,
                threeLine: Boolean,
                twoLine: Boolean
              },
              data: function() {
                return {
                  groups: []
                };
              },
              computed: {
                classes: function() {
                  return o(o({}, a.default.options.computed.classes.call(this)), {
                    "v-list--dense": this.dense,
                    "v-list--disabled": this.disabled,
                    "v-list--flat": this.flat,
                    "v-list--nav": this.nav,
                    "v-list--rounded": this.rounded,
                    "v-list--subheader": this.subheader,
                    "v-list--two-line": this.twoLine,
                    "v-list--three-line": this.threeLine
                  });
                }
              },
              methods: {
                register: function(d) {
                  this.groups.push(d);
                },
                unregister: function(d) {
                  var u = this.groups.findIndex(function(c) {
                    return c._uid === d._uid;
                  });
                  u > -1 && this.groups.splice(u, 1);
                },
                listClick: function(d) {
                  var u, c;
                  if (!this.expand)
                    try {
                      for (var h = l(this.groups), p = h.next(); !p.done; p = h.next()) {
                        var g = p.value;
                        g.toggle(d);
                      }
                    } catch (m) {
                      u = {
                        error: m
                      };
                    } finally {
                      try {
                        p && !p.done && (c = h.return) && c.call(h);
                      } finally {
                        if (u)
                          throw u.error;
                      }
                    }
                }
              },
              render: function(d) {
                var u = {
                  staticClass: "v-list",
                  class: this.classes,
                  style: this.styles,
                  attrs: o({
                    role: this.isInNav || this.isInMenu ? void 0 : "list"
                  }, this.attrs$)
                };
                return d(this.tag, this.setBackgroundColor(this.color, u), [this.$slots.default]);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListGroup.sass": (
          /*!**********************************************!*\
            !*** ./src/components/VList/VListGroup.sass ***!
            \**********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListGroup.ts": (
          /*!********************************************!*\
            !*** ./src/components/VList/VListGroup.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListGroup.sass */
              "./src/components/VList/VListGroup.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ./VListItem */
              "./src/components/VList/VListItem.ts"
            ), l = i(
              /*! ./VListItemIcon */
              "./src/components/VList/VListItemIcon.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), u = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), c = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), h = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), p = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), g = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), y = function() {
              return y = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var T in x)
                    Object.prototype.hasOwnProperty.call(x, T) && (C[T] = x[T]);
                }
                return C;
              }, y.apply(this, arguments);
            }, E = Object(m.default)(f.default, d.default, u.default, Object(h.inject)("list"), c.default);
            r.default = E.extend().extend({
              name: "v-list-group",
              directives: {
                ripple: p.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: ""
                },
                appendIcon: {
                  type: String,
                  default: "$expand"
                },
                color: {
                  type: String,
                  default: "primary"
                },
                disabled: Boolean,
                group: [String, RegExp],
                noAction: Boolean,
                prependIcon: String,
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                },
                subGroup: Boolean
              },
              computed: {
                classes: function() {
                  return {
                    "v-list-group--active": this.isActive,
                    "v-list-group--disabled": this.disabled,
                    "v-list-group--no-action": this.noAction,
                    "v-list-group--sub-group": this.subGroup
                  };
                }
              },
              watch: {
                isActive: function(x) {
                  !this.subGroup && x && this.list && this.list.listClick(this._uid);
                },
                $route: "onRouteChange"
              },
              created: function() {
                this.list && this.list.register(this), this.group && this.$route && this.value == null && (this.isActive = this.matchRoute(this.$route.path));
              },
              beforeDestroy: function() {
                this.list && this.list.unregister(this);
              },
              methods: {
                click: function(x) {
                  var b = this;
                  this.disabled || (this.isBooted = !0, this.$emit("click", x), this.$nextTick(function() {
                    return b.isActive = !b.isActive;
                  }));
                },
                genIcon: function(x) {
                  return this.$createElement(a.default, x);
                },
                genAppendIcon: function() {
                  var x = this.subGroup ? !1 : this.appendIcon;
                  return !x && !this.$slots.appendIcon ? null : this.$createElement(l.default, {
                    staticClass: "v-list-group__header__append-icon"
                  }, [this.$slots.appendIcon || this.genIcon(x)]);
                },
                genHeader: function() {
                  var x;
                  return this.$createElement(o.default, {
                    staticClass: "v-list-group__header",
                    attrs: {
                      "aria-expanded": String(this.isActive),
                      role: "button"
                    },
                    class: (x = {}, x[this.activeClass] = this.isActive, x),
                    props: {
                      inputValue: this.isActive
                    },
                    directives: [{
                      name: "ripple",
                      value: this.ripple
                    }],
                    on: y(y({}, this.listeners$), {
                      click: this.click
                    })
                  }, [this.genPrependIcon(), this.$slots.activator, this.genAppendIcon()]);
                },
                genItems: function() {
                  var x = this;
                  return this.showLazyContent(function() {
                    return [x.$createElement("div", {
                      staticClass: "v-list-group__items",
                      directives: [{
                        name: "show",
                        value: x.isActive
                      }]
                    }, Object(v.getSlot)(x))];
                  });
                },
                genPrependIcon: function() {
                  var x = this.subGroup && this.prependIcon == null ? "$subgroup" : this.prependIcon;
                  return !x && !this.$slots.prependIcon ? null : this.$createElement(l.default, {
                    staticClass: "v-list-group__header__prepend-icon"
                  }, [this.$slots.prependIcon || this.genIcon(x)]);
                },
                onRouteChange: function(x) {
                  if (this.group) {
                    var b = this.matchRoute(x.path);
                    b && this.isActive !== b && this.list && this.list.listClick(this._uid), this.isActive = b;
                  }
                },
                toggle: function(x) {
                  var b = this, P = this._uid === x;
                  P && (this.isBooted = !0), this.$nextTick(function() {
                    return b.isActive = P;
                  });
                },
                matchRoute: function(x) {
                  return x.match(this.group) !== null;
                }
              },
              render: function(x) {
                return x("div", this.setTextColor(this.isActive && this.color, {
                  staticClass: "v-list-group",
                  class: this.classes
                }), [this.genHeader(), x(g.VExpandTransition, this.genItems())]);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItem.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VList/VListItem.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListItem.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VList/VListItem.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListItem.sass */
              "./src/components/VList/VListItem.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), l = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), u = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), c = i(
              /*! ./../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, g.apply(this, arguments);
            }, m = Object(p.default)(a.default, o.default, f.default, Object(l.factory)("listItemGroup"), Object(d.factory)("inputValue"));
            r.default = m.extend().extend({
              name: "v-list-item",
              directives: {
                Ripple: u.default
              },
              inject: {
                isInGroup: {
                  default: !1
                },
                isInList: {
                  default: !1
                },
                isInMenu: {
                  default: !1
                },
                isInNav: {
                  default: !1
                }
              },
              inheritAttrs: !1,
              props: {
                activeClass: {
                  type: String,
                  default: function() {
                    return this.listItemGroup ? this.listItemGroup.activeClass : "";
                  }
                },
                dense: Boolean,
                inactive: Boolean,
                link: Boolean,
                selectable: {
                  type: Boolean
                },
                tag: {
                  type: String,
                  default: "div"
                },
                threeLine: Boolean,
                twoLine: Boolean,
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-list-item--active"
                };
              },
              computed: {
                classes: function() {
                  return g(g(g({
                    "v-list-item": !0
                  }, o.default.options.computed.classes.call(this)), {
                    "v-list-item--dense": this.dense,
                    "v-list-item--disabled": this.disabled,
                    "v-list-item--link": this.isClickable && !this.inactive,
                    "v-list-item--selectable": this.selectable,
                    "v-list-item--three-line": this.threeLine,
                    "v-list-item--two-line": this.twoLine
                  }), this.themeClasses);
                },
                isClickable: function() {
                  return !!(o.default.options.computed.isClickable.call(this) || this.listItemGroup);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("avatar") && Object(h.removed)("avatar", this);
              },
              methods: {
                click: function(y) {
                  y.detail && this.$el.blur(), this.$emit("click", y), this.to || this.toggle();
                },
                genAttrs: function() {
                  var y = g({
                    "aria-disabled": this.disabled ? !0 : void 0,
                    tabindex: this.isClickable && !this.disabled ? 0 : -1
                  }, this.$attrs);
                  return this.$attrs.hasOwnProperty("role") || this.isInNav || (this.isInGroup ? (y.role = "option", y["aria-selected"] = String(this.isActive)) : this.isInMenu ? (y.role = this.isClickable ? "menuitem" : void 0, y.id = y.id || "list-item-" + this._uid) : this.isInList && (y.role = "listitem")), y;
                },
                toggle: function() {
                  this.to && this.inputValue === void 0 && (this.isActive = !this.isActive), this.$emit("change");
                }
              },
              render: function(y) {
                var E = this, C = this.generateRouteLink(), x = C.tag, b = C.data;
                b.attrs = g(g({}, b.attrs), this.genAttrs()), b[this.to ? "nativeOn" : "on"] = g(g({}, b[this.to ? "nativeOn" : "on"]), {
                  keydown: function(O) {
                    E.disabled || (O.keyCode === c.keyCodes.enter && E.click(O), E.$emit("keydown", O));
                  }
                }), this.inactive && (x = "div"), this.inactive && this.to && (b.on = b.nativeOn, delete b.nativeOn);
                var P = this.$scopedSlots.default ? this.$scopedSlots.default({
                  active: this.isActive,
                  toggle: this.toggle
                }) : this.$slots.default;
                return y(x, this.isActive ? this.setTextColor(this.color, b) : b, P);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemAction.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VList/VListItemAction.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "v-list-item-action",
              functional: !0,
              render: function(f, d) {
                var u = d.data, c = d.children, h = c === void 0 ? [] : c;
                u.staticClass = u.staticClass ? "v-list-item__action " + u.staticClass : "v-list-item__action";
                var p = h.filter(function(g) {
                  return g.isComment === !1 && g.text !== " ";
                });
                return p.length > 1 && (u.staticClass += " v-list-item__action--stack"), f("div", u, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemAvatar.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VList/VListItemAvatar.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VAvatar */
              "./src/components/VAvatar/index.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-list-item-avatar",
              props: {
                horizontal: Boolean,
                size: {
                  type: [Number, String],
                  default: 40
                }
              },
              computed: {
                classes: function() {
                  return o(o({
                    "v-list-item__avatar--horizontal": this.horizontal
                  }, a.default.options.computed.classes.call(this)), {
                    "v-avatar--tile": this.tile || this.horizontal
                  });
                }
              },
              render: function(f) {
                var d = a.default.options.render.call(this, f);
                return d.data = d.data || {}, d.data.staticClass += " v-list-item__avatar", d;
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemGroup.sass": (
          /*!**************************************************!*\
            !*** ./src/components/VList/VListItemGroup.sass ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListItemGroup.ts": (
          /*!************************************************!*\
            !*** ./src/components/VList/VListItemGroup.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListItemGroup.sass */
              "./src/components/VList/VListItemGroup.sass"
            );
            var a = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.BaseItemGroup, o.default).extend({
              name: "v-list-item-group",
              provide: function() {
                return {
                  isInGroup: !0,
                  listItemGroup: this
                };
              },
              computed: {
                classes: function() {
                  return f(f({}, a.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-list-item-group": !0
                  });
                }
              },
              methods: {
                genData: function() {
                  return this.setTextColor(this.color, f(f({}, a.BaseItemGroup.options.methods.genData.call(this)), {
                    attrs: {
                      role: "listbox"
                    }
                  }));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemIcon.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VList/VListItemIcon.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "v-list-item-icon",
              functional: !0,
              render: function(f, d) {
                var u = d.data, c = d.children;
                return u.staticClass = ("v-list-item__icon " + (u.staticClass || "")).trim(), f("div", u, c);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VList/index.ts ***!
            \***************************************/
          /*! exports provided: VListItemActionText, VListItemContent, VListItemTitle, VListItemSubtitle, VList, VListGroup, VListItem, VListItemAction, VListItemAvatar, VListItemIcon, VListItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VListItemActionText", function() {
              return p;
            }), i.d(r, "VListItemContent", function() {
              return g;
            }), i.d(r, "VListItemTitle", function() {
              return m;
            }), i.d(r, "VListItemSubtitle", function() {
              return v;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VList */
              "./src/components/VList/VList.ts"
            );
            i.d(r, "VList", function() {
              return o.default;
            });
            var l = i(
              /*! ./VListGroup */
              "./src/components/VList/VListGroup.ts"
            );
            i.d(r, "VListGroup", function() {
              return l.default;
            });
            var f = i(
              /*! ./VListItem */
              "./src/components/VList/VListItem.ts"
            );
            i.d(r, "VListItem", function() {
              return f.default;
            });
            var d = i(
              /*! ./VListItemGroup */
              "./src/components/VList/VListItemGroup.ts"
            );
            i.d(r, "VListItemGroup", function() {
              return d.default;
            });
            var u = i(
              /*! ./VListItemAction */
              "./src/components/VList/VListItemAction.ts"
            );
            i.d(r, "VListItemAction", function() {
              return u.default;
            });
            var c = i(
              /*! ./VListItemAvatar */
              "./src/components/VList/VListItemAvatar.ts"
            );
            i.d(r, "VListItemAvatar", function() {
              return c.default;
            });
            var h = i(
              /*! ./VListItemIcon */
              "./src/components/VList/VListItemIcon.ts"
            );
            i.d(r, "VListItemIcon", function() {
              return h.default;
            });
            var p = Object(a.createSimpleFunctional)("v-list-item__action-text", "span"), g = Object(a.createSimpleFunctional)("v-list-item__content", "div"), m = Object(a.createSimpleFunctional)("v-list-item__title", "div"), v = Object(a.createSimpleFunctional)("v-list-item__subtitle", "div");
            r.default = {
              $_vuetify_subcomponents: {
                VList: o.default,
                VListGroup: l.default,
                VListItem: f.default,
                VListItemAction: u.default,
                VListItemActionText: p,
                VListItemAvatar: c.default,
                VListItemContent: g,
                VListItemGroup: d.default,
                VListItemIcon: h.default,
                VListItemSubtitle: v,
                VListItemTitle: m
              }
            };
          }
        ),
        /***/
        "./src/components/VMain/VMain.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VMain/VMain.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMain/VMain.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMain/VMain.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMain.sass */
              "./src/components/VMain/VMain.sass"
            );
            var a = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            );
            r.default = a.default.extend({
              name: "v-main",
              props: {
                tag: {
                  type: String,
                  default: "main"
                }
              },
              computed: {
                styles: function() {
                  var l = this.$vuetify.application, f = l.bar, d = l.top, u = l.right, c = l.footer, h = l.insetFooter, p = l.bottom, g = l.left;
                  return {
                    paddingTop: d + f + "px",
                    paddingRight: u + "px",
                    paddingBottom: c + h + p + "px",
                    paddingLeft: g + "px"
                  };
                }
              },
              render: function(l) {
                var f = {
                  staticClass: "v-main",
                  style: this.styles,
                  ref: "main"
                };
                return l(this.tag, f, [l("div", {
                  staticClass: "v-main__wrap"
                }, this.$slots.default)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMain/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMain/index.ts ***!
            \***************************************/
          /*! exports provided: VMain, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMain */
              "./src/components/VMain/VMain.ts"
            );
            i.d(r, "VMain", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VMenu/VMenu.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VMenu/VMenu.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMenu/VMenu.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMenu/VMenu.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMenu.sass */
              "./src/components/VMenu/VMenu.sass"
            );
            var a = i(
              /*! ../VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            ), o = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/menuable */
              "./src/mixins/menuable/index.ts"
            ), u = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), c = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), E = i(
              /*! ../../services/goto */
              "./src/services/goto/index.ts"
            ), C = function() {
              return C = Object.assign || function(T) {
                for (var O, S = 1, L = arguments.length; S < L; S++) {
                  O = arguments[S];
                  for (var A in O)
                    Object.prototype.hasOwnProperty.call(O, A) && (T[A] = O[A]);
                }
                return T;
              }, C.apply(this, arguments);
            }, x = function(T, O) {
              var S = typeof Symbol == "function" && T[Symbol.iterator];
              if (!S)
                return T;
              var L = S.call(T), A, D = [], _;
              try {
                for (; (O === void 0 || O-- > 0) && !(A = L.next()).done; )
                  D.push(A.value);
              } catch (w) {
                _ = {
                  error: w
                };
              } finally {
                try {
                  A && !A.done && (S = L.return) && S.call(L);
                } finally {
                  if (_)
                    throw _.error;
                }
              }
              return D;
            }, b = function(T, O, S) {
              if (S || arguments.length === 2)
                for (var L = 0, A = O.length, D; L < A; L++)
                  (D || !(L in O)) && (D || (D = Array.prototype.slice.call(O, 0, L)), D[L] = O[L]);
              return T.concat(D || Array.prototype.slice.call(O));
            }, P = Object(m.default)(f.default, l.default, u.default, c.default, h.default, d.default);
            r.default = P.extend({
              name: "v-menu",
              directives: {
                ClickOutside: p.default,
                Resize: g.default
              },
              provide: function() {
                return {
                  isInMenu: !0,
                  // Pass theme through to default slot
                  theme: this.theme
                };
              },
              props: {
                auto: Boolean,
                closeOnClick: {
                  type: Boolean,
                  default: !0
                },
                closeOnContentClick: {
                  type: Boolean,
                  default: !0
                },
                disabled: Boolean,
                disableKeys: Boolean,
                maxHeight: {
                  type: [Number, String],
                  default: "auto"
                },
                offsetX: Boolean,
                offsetY: Boolean,
                openOnHover: Boolean,
                origin: {
                  type: String,
                  default: "top left"
                },
                transition: {
                  type: [Boolean, String],
                  default: "v-menu-transition"
                },
                contentProps: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                }
              },
              data: function() {
                return {
                  calculatedTopAuto: 0,
                  defaultOffset: 8,
                  hasJustFocused: !1,
                  listIndex: -1,
                  resizeTimeout: 0,
                  selectedIndex: null,
                  tiles: []
                };
              },
              computed: {
                activeTile: function() {
                  return this.tiles[this.listIndex];
                },
                calculatedLeft: function() {
                  var O = Math.max(this.dimensions.content.width, parseFloat(this.calculatedMinWidth));
                  return this.auto ? Object(y.convertToUnit)(this.calcXOverflow(this.calcLeftAuto(), O)) || "0" : this.calcLeft(O) || "0";
                },
                calculatedMaxHeight: function() {
                  var O = this.auto ? "200px" : Object(y.convertToUnit)(this.maxHeight);
                  return O || "0";
                },
                calculatedMaxWidth: function() {
                  return Object(y.convertToUnit)(this.maxWidth) || "0";
                },
                calculatedMinWidth: function() {
                  if (this.minWidth)
                    return Object(y.convertToUnit)(this.minWidth) || "0";
                  var O = Math.min(this.dimensions.activator.width + Number(this.nudgeWidth) + (this.auto ? 16 : 0), Math.max(this.pageWidth - 24, 0)), S = isNaN(parseInt(this.calculatedMaxWidth)) ? O : parseInt(this.calculatedMaxWidth);
                  return Object(y.convertToUnit)(Math.min(S, O)) || "0";
                },
                calculatedTop: function() {
                  var O = this.auto ? Object(y.convertToUnit)(this.calcYOverflow(this.calculatedTopAuto)) : this.calcTop();
                  return O || "0";
                },
                hasClickableTiles: function() {
                  return !!this.tiles.find(function(O) {
                    return O.tabIndex > -1;
                  });
                },
                styles: function() {
                  return {
                    maxHeight: this.calculatedMaxHeight,
                    minWidth: this.calculatedMinWidth,
                    maxWidth: this.calculatedMaxWidth,
                    top: this.calculatedTop,
                    left: this.calculatedLeft,
                    transformOrigin: this.origin,
                    zIndex: this.zIndex || this.activeZIndex
                  };
                }
              },
              watch: {
                isActive: function(O) {
                  O || (this.listIndex = -1);
                },
                isContentActive: function(O) {
                  this.hasJustFocused = O;
                },
                listIndex: function(O, S) {
                  if (O in this.tiles) {
                    var L = this.tiles[O];
                    L.classList.add("v-list-item--highlighted");
                    var A = this.$refs.content.scrollTop, D = this.$refs.content.clientHeight;
                    A > L.offsetTop - 8 ? Object(E.default)(L.offsetTop - L.clientHeight, {
                      appOffset: !1,
                      duration: 300,
                      container: this.$refs.content
                    }) : A + D < L.offsetTop + L.clientHeight + 8 && Object(E.default)(L.offsetTop - D + L.clientHeight * 2, {
                      appOffset: !1,
                      duration: 300,
                      container: this.$refs.content
                    });
                  }
                  S in this.tiles && this.tiles[S].classList.remove("v-list-item--highlighted");
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("full-width") && Object(v.removed)("full-width", this);
              },
              mounted: function() {
                this.isActive && this.callActivate();
              },
              methods: {
                activate: function() {
                  var O = this;
                  this.updateDimensions(), requestAnimationFrame(function() {
                    O.startTransition().then(function() {
                      O.$refs.content && (O.calculatedTopAuto = O.calcTopAuto(), O.auto && (O.$refs.content.scrollTop = O.calcScrollPosition()));
                    });
                  });
                },
                calcScrollPosition: function() {
                  var O = this.$refs.content, S = O.querySelector(".v-list-item--active"), L = O.scrollHeight - O.offsetHeight;
                  return S ? Math.min(L, Math.max(0, S.offsetTop - O.offsetHeight / 2 + S.offsetHeight / 2)) : O.scrollTop;
                },
                calcLeftAuto: function() {
                  return parseInt(this.dimensions.activator.left - this.defaultOffset * 2);
                },
                calcTopAuto: function() {
                  var O = this.$refs.content, S = O.querySelector(".v-list-item--active");
                  if (S || (this.selectedIndex = null), this.offsetY || !S)
                    return this.computedTop;
                  this.selectedIndex = Array.from(this.tiles).indexOf(S);
                  var L = S.offsetTop - this.calcScrollPosition(), A = O.querySelector(".v-list-item").offsetTop;
                  return this.computedTop - L - A - 1;
                },
                changeListIndex: function(O) {
                  if (this.getTiles(), !(!this.isActive || !this.hasClickableTiles)) {
                    if (O.keyCode === y.keyCodes.tab) {
                      this.isActive = !1;
                      return;
                    } else if (O.keyCode === y.keyCodes.down)
                      this.nextTile();
                    else if (O.keyCode === y.keyCodes.up)
                      this.prevTile();
                    else if (O.keyCode === y.keyCodes.end)
                      this.lastTile();
                    else if (O.keyCode === y.keyCodes.home)
                      this.firstTile();
                    else if (O.keyCode === y.keyCodes.enter && this.listIndex !== -1)
                      this.tiles[this.listIndex].click();
                    else
                      return;
                    O.preventDefault();
                  }
                },
                closeConditional: function(O) {
                  var S = O.target;
                  return this.isActive && !this._isDestroyed && this.closeOnClick && !this.$refs.content.contains(S);
                },
                genActivatorAttributes: function() {
                  var O = o.default.options.methods.genActivatorAttributes.call(this);
                  return this.activeTile && this.activeTile.id ? C(C({}, O), {
                    "aria-activedescendant": this.activeTile.id
                  }) : O;
                },
                genActivatorListeners: function() {
                  var O = d.default.options.methods.genActivatorListeners.call(this);
                  return this.disableKeys || (O.keydown = this.onKeyDown), O;
                },
                genTransition: function() {
                  var O = this.genContent();
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, [O]) : O;
                },
                genDirectives: function() {
                  var O = this, S = [{
                    name: "show",
                    value: this.isContentActive
                  }];
                  return !this.openOnHover && this.closeOnClick && S.push({
                    name: "click-outside",
                    value: {
                      handler: function() {
                        O.isActive = !1;
                      },
                      closeConditional: this.closeConditional,
                      include: function() {
                        return b([O.$el], x(O.getOpenDependentElements()), !1);
                      }
                    }
                  }), S;
                },
                genContent: function() {
                  var O, S = this, L = {
                    attrs: C(C(C({}, this.getScopeIdAttrs()), this.contentProps), {
                      role: "role" in this.$attrs ? this.$attrs.role : "menu"
                    }),
                    staticClass: "v-menu__content",
                    class: C(C(C({}, this.rootThemeClasses), this.roundedClasses), (O = {
                      "v-menu__content--auto": this.auto,
                      "v-menu__content--fixed": this.activatorFixed,
                      menuable__content__active: this.isActive
                    }, O[this.contentClass.trim()] = !0, O)),
                    style: this.styles,
                    directives: this.genDirectives(),
                    ref: "content",
                    on: {
                      click: function(D) {
                        var _ = D.target;
                        _.getAttribute("disabled") || S.closeOnContentClick && (S.isActive = !1);
                      },
                      keydown: this.onKeyDown
                    }
                  };
                  return this.$listeners.scroll && (L.on = L.on || {}, L.on.scroll = this.$listeners.scroll), !this.disabled && this.openOnHover && (L.on = L.on || {}, L.on.mouseenter = this.mouseEnterHandler), this.openOnHover && (L.on = L.on || {}, L.on.mouseleave = this.mouseLeaveHandler), this.$createElement("div", L, this.getContentSlot());
                },
                getTiles: function() {
                  this.$refs.content && (this.tiles = Array.from(this.$refs.content.querySelectorAll(".v-list-item, .v-divider, .v-subheader")));
                },
                mouseEnterHandler: function() {
                  var O = this;
                  this.runDelay("open", function() {
                    O.hasJustFocused || (O.hasJustFocused = !0);
                  });
                },
                mouseLeaveHandler: function(O) {
                  var S = this;
                  this.runDelay("close", function() {
                    var L;
                    !((L = S.$refs.content) === null || L === void 0) && L.contains(O.relatedTarget) || requestAnimationFrame(function() {
                      S.isActive = !1, S.callDeactivate();
                    });
                  });
                },
                nextTile: function() {
                  var O = this.tiles[this.listIndex + 1];
                  if (!O) {
                    if (!this.tiles.length)
                      return;
                    this.listIndex = -1, this.nextTile();
                    return;
                  }
                  this.listIndex++, O.tabIndex === -1 && this.nextTile();
                },
                prevTile: function() {
                  var O = this.tiles[this.listIndex - 1];
                  if (!O) {
                    if (!this.tiles.length)
                      return;
                    this.listIndex = this.tiles.length, this.prevTile();
                    return;
                  }
                  this.listIndex--, O.tabIndex === -1 && this.prevTile();
                },
                lastTile: function() {
                  var O = this.tiles[this.tiles.length - 1];
                  O && (this.listIndex = this.tiles.length - 1, O.tabIndex === -1 && this.prevTile());
                },
                firstTile: function() {
                  var O = this.tiles[0];
                  O && (this.listIndex = 0, O.tabIndex === -1 && this.nextTile());
                },
                onKeyDown: function(O) {
                  var S = this;
                  if (!this.disableKeys) {
                    if (O.keyCode === y.keyCodes.esc) {
                      setTimeout(function() {
                        S.isActive = !1;
                      });
                      var L = this.getActivator();
                      this.$nextTick(function() {
                        return L && L.focus();
                      });
                    } else
                      !this.isActive && [y.keyCodes.up, y.keyCodes.down].includes(O.keyCode) && (this.isActive = !0);
                    this.$nextTick(function() {
                      return S.changeListIndex(O);
                    });
                  }
                },
                onResize: function() {
                  this.isActive && (this.$refs.content.offsetWidth, this.updateDimensions(), clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.updateDimensions, 100));
                }
              },
              render: function(O) {
                var S = this, L = {
                  staticClass: "v-menu",
                  class: {
                    "v-menu--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  },
                  directives: [{
                    arg: "500",
                    name: "resize",
                    value: this.onResize
                  }]
                };
                return O("div", L, [!this.activator && this.genActivator(), this.showLazyContent(function() {
                  return [S.$createElement(a.VThemeProvider, {
                    props: {
                      root: !0,
                      light: S.light,
                      dark: S.dark
                    }
                  }, [S.genTransition()])];
                })]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMenu/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMenu/index.ts ***!
            \***************************************/
          /*! exports provided: VMenu, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMenu */
              "./src/components/VMenu/VMenu.ts"
            );
            i.d(r, "VMenu", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VMessages/VMessages.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VMessages/VMessages.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMessages/VMessages.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VMessages/VMessages.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMessages.sass */
              "./src/components/VMessages/VMessages.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(l.default)(a.default, o.default).extend({
              name: "v-messages",
              props: {
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              methods: {
                genChildren: function() {
                  return this.$createElement("transition-group", {
                    staticClass: "v-messages__wrapper",
                    attrs: {
                      name: "message-transition",
                      tag: "div"
                    }
                  }, this.value.map(this.genMessage));
                },
                genMessage: function(u, c) {
                  return this.$createElement("div", {
                    staticClass: "v-messages__message",
                    key: c
                  }, Object(f.getSlot)(this, "default", {
                    message: u,
                    key: c
                  }) || [u]);
                }
              },
              render: function(u) {
                return u("div", this.setTextColor(this.color, {
                  staticClass: "v-messages",
                  class: this.themeClasses
                }), [this.genChildren()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMessages/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VMessages/index.ts ***!
            \*******************************************/
          /*! exports provided: VMessages, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMessages */
              "./src/components/VMessages/VMessages.ts"
            );
            i.d(r, "VMessages", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/VNavigationDrawer.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VNavigationDrawer/VNavigationDrawer.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/VNavigationDrawer.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VNavigationDrawer/VNavigationDrawer.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VNavigationDrawer.sass */
              "./src/components/VNavigationDrawer/VNavigationDrawer.sass"
            );
            var a = i(
              /*! ../VImg/VImg */
              "./src/components/VImg/VImg.ts"
            ), o = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), u = i(
              /*! ../../mixins/overlayable */
              "./src/mixins/overlayable/index.ts"
            ), c = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), m = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), v = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), y = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), E = function() {
              return E = Object.assign || function(x) {
                for (var b, P = 1, T = arguments.length; P < T; P++) {
                  b = arguments[P];
                  for (var O in b)
                    Object.prototype.hasOwnProperty.call(b, O) && (x[O] = b[O]);
                }
                return x;
              }, E.apply(this, arguments);
            }, C = Object(y.default)(Object(o.default)("left", ["isActive", "isMobile", "miniVariant", "expandOnHover", "permanent", "right", "temporary", "width"]), l.default, f.default, d.default, u.default, c.default, h.default);
            r.default = C.extend({
              name: "v-navigation-drawer",
              directives: {
                ClickOutside: p.default,
                Resize: g.default,
                Touch: m.default
              },
              provide: function() {
                return {
                  isInNav: this.tag === "nav"
                };
              },
              props: {
                bottom: Boolean,
                clipped: Boolean,
                disableResizeWatcher: Boolean,
                disableRouteWatcher: Boolean,
                expandOnHover: Boolean,
                floating: Boolean,
                height: {
                  type: [Number, String],
                  default: function() {
                    return this.app ? "100vh" : "100%";
                  }
                },
                miniVariant: Boolean,
                miniVariantWidth: {
                  type: [Number, String],
                  default: 56
                },
                permanent: Boolean,
                right: Boolean,
                src: {
                  type: [String, Object],
                  default: ""
                },
                stateless: Boolean,
                tag: {
                  type: String,
                  default: function() {
                    return this.app ? "nav" : "aside";
                  }
                },
                temporary: Boolean,
                touchless: Boolean,
                width: {
                  type: [Number, String],
                  default: 256
                },
                value: null
              },
              data: function() {
                return {
                  isMouseover: !1,
                  touchArea: {
                    left: 0,
                    right: 0
                  },
                  stackMinZIndex: 6
                };
              },
              computed: {
                /**
                 * Used for setting an app value from a dynamic
                 * property. Called from applicationable.js
                 */
                applicationProperty: function() {
                  return this.right ? "right" : "left";
                },
                classes: function() {
                  return E({
                    "v-navigation-drawer": !0,
                    "v-navigation-drawer--absolute": this.absolute,
                    "v-navigation-drawer--bottom": this.bottom,
                    "v-navigation-drawer--clipped": this.clipped,
                    "v-navigation-drawer--close": !this.isActive,
                    "v-navigation-drawer--fixed": !this.absolute && (this.app || this.fixed),
                    "v-navigation-drawer--floating": this.floating,
                    "v-navigation-drawer--is-mobile": this.isMobile,
                    "v-navigation-drawer--is-mouseover": this.isMouseover,
                    "v-navigation-drawer--mini-variant": this.isMiniVariant,
                    "v-navigation-drawer--custom-mini-variant": Number(this.miniVariantWidth) !== 56,
                    "v-navigation-drawer--open": this.isActive,
                    "v-navigation-drawer--open-on-hover": this.expandOnHover,
                    "v-navigation-drawer--right": this.right,
                    "v-navigation-drawer--temporary": this.temporary
                  }, this.themeClasses);
                },
                computedMaxHeight: function() {
                  if (!this.hasApp)
                    return null;
                  var b = this.$vuetify.application.bottom + this.$vuetify.application.footer + this.$vuetify.application.bar;
                  return this.clipped ? b + this.$vuetify.application.top : b;
                },
                computedTop: function() {
                  if (!this.hasApp)
                    return 0;
                  var b = this.$vuetify.application.bar;
                  return b += this.clipped ? this.$vuetify.application.top : 0, b;
                },
                computedTransform: function() {
                  return this.isActive ? 0 : this.isBottom || this.right ? 100 : -100;
                },
                computedWidth: function() {
                  return this.isMiniVariant ? this.miniVariantWidth : this.width;
                },
                hasApp: function() {
                  return this.app && !this.isMobile && !this.temporary;
                },
                isBottom: function() {
                  return this.bottom && this.isMobile;
                },
                isMiniVariant: function() {
                  return !this.expandOnHover && this.miniVariant || this.expandOnHover && !this.isMouseover;
                },
                isMobile: function() {
                  return !this.stateless && !this.permanent && d.default.options.computed.isMobile.call(this);
                },
                reactsToClick: function() {
                  return !this.stateless && !this.permanent && (this.isMobile || this.temporary);
                },
                reactsToMobile: function() {
                  return this.app && !this.disableResizeWatcher && !this.permanent && !this.stateless && !this.temporary;
                },
                reactsToResize: function() {
                  return !this.disableResizeWatcher && !this.stateless;
                },
                reactsToRoute: function() {
                  return !this.disableRouteWatcher && !this.stateless && (this.temporary || this.isMobile);
                },
                showOverlay: function() {
                  return !this.hideOverlay && this.isActive && (this.isMobile || this.temporary);
                },
                styles: function() {
                  var b = this.isBottom ? "translateY" : "translateX";
                  return {
                    height: Object(v.convertToUnit)(this.height),
                    top: this.isBottom ? "auto" : Object(v.convertToUnit)(this.computedTop),
                    maxHeight: this.computedMaxHeight != null ? "calc(100% - " + Object(v.convertToUnit)(this.computedMaxHeight) + ")" : void 0,
                    transform: b + "(" + Object(v.convertToUnit)(this.computedTransform, "%") + ")",
                    width: Object(v.convertToUnit)(this.computedWidth)
                  };
                }
              },
              watch: {
                $route: "onRouteChange",
                isActive: function(b) {
                  this.$emit("input", b);
                },
                /**
                 * When mobile changes, adjust the active state
                 * only when there has been a previous value
                 */
                isMobile: function(b, P) {
                  !b && this.isActive && !this.temporary && this.removeOverlay(), !(P == null || !this.reactsToResize || !this.reactsToMobile) && (this.isActive = !b);
                },
                permanent: function(b) {
                  b && (this.isActive = !0);
                },
                showOverlay: function(b) {
                  b ? this.genOverlay() : this.removeOverlay();
                },
                value: function(b) {
                  if (!this.permanent) {
                    if (b == null) {
                      this.init();
                      return;
                    }
                    b !== this.isActive && (this.isActive = b);
                  }
                },
                expandOnHover: "updateMiniVariant",
                isMouseover: function(b) {
                  this.updateMiniVariant(!b);
                }
              },
              beforeMount: function() {
                this.init();
              },
              methods: {
                calculateTouchArea: function() {
                  var b = this.$el.parentNode;
                  if (b) {
                    var P = b.getBoundingClientRect();
                    this.touchArea = {
                      left: P.left + 50,
                      right: P.right - 50
                    };
                  }
                },
                closeConditional: function() {
                  return this.isActive && !this._isDestroyed && this.reactsToClick;
                },
                genAppend: function() {
                  return this.genPosition("append");
                },
                genBackground: function() {
                  var b = {
                    height: "100%",
                    width: "100%",
                    src: this.src
                  }, P = this.$scopedSlots.img ? this.$scopedSlots.img(b) : this.$createElement(a.default, {
                    props: b
                  });
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__image"
                  }, [P]);
                },
                genDirectives: function() {
                  var b = this, P = [{
                    name: "click-outside",
                    value: {
                      handler: function() {
                        b.isActive = !1;
                      },
                      closeConditional: this.closeConditional,
                      include: this.getOpenDependentElements
                    }
                  }];
                  return !this.touchless && !this.stateless && P.push({
                    name: "touch",
                    value: {
                      parent: !0,
                      left: this.swipeLeft,
                      right: this.swipeRight
                    }
                  }), P;
                },
                genListeners: function() {
                  var b = this, P = {
                    mouseenter: function() {
                      return b.isMouseover = !0;
                    },
                    mouseleave: function() {
                      return b.isMouseover = !1;
                    },
                    transitionend: function(O) {
                      if (O.target === O.currentTarget) {
                        b.$emit("transitionend", O);
                        var S = document.createEvent("UIEvents");
                        S.initUIEvent("resize", !0, !1, window, 0), window.dispatchEvent(S);
                      }
                    }
                  };
                  return this.miniVariant && (P.click = function() {
                    return b.$emit("update:mini-variant", !1);
                  }), P;
                },
                genPosition: function(b) {
                  var P = Object(v.getSlot)(this, b);
                  return P && this.$createElement("div", {
                    staticClass: "v-navigation-drawer__" + b
                  }, P);
                },
                genPrepend: function() {
                  return this.genPosition("prepend");
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__content"
                  }, this.$slots.default);
                },
                genBorder: function() {
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__border"
                  });
                },
                init: function() {
                  this.permanent ? this.isActive = !0 : this.stateless || this.value != null ? this.isActive = this.value : this.temporary || (this.isActive = !this.isMobile);
                },
                onRouteChange: function() {
                  this.reactsToRoute && this.closeConditional() && (this.isActive = !1);
                },
                swipeLeft: function(b) {
                  this.isActive && this.right || (this.calculateTouchArea(), !(Math.abs(b.touchendX - b.touchstartX) < 100) && (this.right && b.touchstartX >= this.touchArea.right ? this.isActive = !0 : !this.right && this.isActive && (this.isActive = !1)));
                },
                swipeRight: function(b) {
                  this.isActive && !this.right || (this.calculateTouchArea(), !(Math.abs(b.touchendX - b.touchstartX) < 100) && (!this.right && b.touchstartX <= this.touchArea.left ? this.isActive = !0 : this.right && this.isActive && (this.isActive = !1)));
                },
                /**
                 * Update the application layout
                 */
                updateApplication: function() {
                  if (!this.isActive || this.isMobile || this.temporary || !this.$el)
                    return 0;
                  var b = Number(this.miniVariant ? this.miniVariantWidth : this.width);
                  return isNaN(b) ? this.$el.clientWidth : b;
                },
                updateMiniVariant: function(b) {
                  this.expandOnHover && this.miniVariant !== b && this.$emit("update:mini-variant", b);
                }
              },
              render: function(b) {
                var P = [this.genPrepend(), this.genContent(), this.genAppend(), this.genBorder()];
                return (this.src || Object(v.getSlot)(this, "img")) && P.unshift(this.genBackground()), b(this.tag, this.setBackgroundColor(this.color, {
                  class: this.classes,
                  style: this.styles,
                  directives: this.genDirectives(),
                  on: this.genListeners()
                }), P);
              }
            });
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VNavigationDrawer/index.ts ***!
            \***************************************************/
          /*! exports provided: VNavigationDrawer, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VNavigationDrawer */
              "./src/components/VNavigationDrawer/VNavigationDrawer.ts"
            );
            i.d(r, "VNavigationDrawer", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOtpInput/VOtpInput.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VOtpInput/VOtpInput.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOtpInput/VOtpInput.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VOtpInput/VOtpInput.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VTextField/VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            ), i(
              /*! ./VOtpInput.sass */
              "./src/components/VOtpInput/VOtpInput.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), l = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = function() {
              return c = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, c.apply(this, arguments);
            }, h = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, p = function(m, v, y) {
              if (y || arguments.length === 2)
                for (var E = 0, C = v.length, x; E < C; E++)
                  (x || !(E in v)) && (x || (x = Array.prototype.slice.call(v, 0, E)), x[E] = v[E]);
              return m.concat(x || Array.prototype.slice.call(v));
            }, g = Object(u.default)(a.default);
            r.default = g.extend().extend({
              name: "v-otp-input",
              directives: {
                ripple: l.default
              },
              inheritAttrs: !1,
              props: {
                length: {
                  type: [Number, String],
                  default: 6
                },
                type: {
                  type: String,
                  default: "text"
                },
                plain: Boolean
              },
              data: function() {
                return {
                  initialValue: null,
                  isBooted: !1,
                  otp: []
                };
              },
              computed: {
                outlined: function() {
                  return !this.plain;
                },
                classes: function() {
                  return c(c(c({}, a.default.options.computed.classes.call(this)), o.default.options.computed.classes.call(this)), {
                    "v-otp-input--plain": this.plain
                  });
                }
              },
              watch: {
                isFocused: "updateValue",
                value: function(v) {
                  this.lazyValue = v, this.otp = (v == null ? void 0 : v.split("")) || [];
                }
              },
              created: function() {
                var v;
                this.$attrs.hasOwnProperty("browser-autocomplete") && Object(d.breaking)("browser-autocomplete", "autocomplete", this), this.otp = ((v = this.internalValue) === null || v === void 0 ? void 0 : v.split("")) || [];
              },
              mounted: function() {
                var v = this;
                requestAnimationFrame(function() {
                  return v.isBooted = !0;
                });
              },
              methods: {
                /** @public */
                focus: function(v, y) {
                  this.onFocus(v, y || 0);
                },
                genInputSlot: function(v) {
                  var y = this;
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
                    staticClass: "v-input__slot",
                    style: {
                      height: Object(f.convertToUnit)(this.height)
                    },
                    on: {
                      click: function() {
                        return y.onClick(v);
                      },
                      mousedown: function(C) {
                        return y.onMouseDown(C, v);
                      },
                      mouseup: function(C) {
                        return y.onMouseUp(C, v);
                      }
                    }
                  }), [this.genDefaultSlot(v)]);
                },
                genControl: function(v) {
                  return this.$createElement("div", {
                    staticClass: "v-input__control"
                  }, [this.genInputSlot(v)]);
                },
                genDefaultSlot: function(v) {
                  return [this.genFieldset(), this.genTextFieldSlot(v)];
                },
                genContent: function() {
                  var v = this;
                  return Array.from({
                    length: +this.length
                  }, function(y, E) {
                    return v.$createElement("div", v.setTextColor(v.validationState, {
                      staticClass: "v-input",
                      class: v.classes
                    }), [v.genControl(E)]);
                  });
                },
                genFieldset: function() {
                  return this.$createElement("fieldset", {
                    attrs: {
                      "aria-hidden": !0
                    }
                  }, [this.genLegend()]);
                },
                genLegend: function() {
                  var v = this.$createElement("span", {
                    domProps: {
                      innerHTML: "&#8203;"
                    }
                  });
                  return this.$createElement("legend", {
                    style: {
                      width: "0px"
                    }
                  }, [v]);
                },
                genInput: function(v) {
                  var y = this, E = Object.assign({}, this.listeners$);
                  return delete E.change, this.$createElement("input", {
                    style: {},
                    domProps: {
                      value: this.otp[v],
                      min: this.type === "number" ? 0 : null
                    },
                    attrs: c(c({}, this.attrs$), {
                      autocomplete: "one-time-code",
                      disabled: this.isDisabled,
                      readonly: this.isReadonly,
                      type: this.type,
                      id: this.computedId + "--" + v,
                      class: "otp-field-box--" + v
                    }),
                    on: Object.assign(E, {
                      blur: this.onBlur,
                      input: function(x) {
                        return y.onInput(x, v);
                      },
                      focus: function(x) {
                        return y.onFocus(x, v);
                      },
                      keydown: this.onKeyDown,
                      keyup: function(x) {
                        return y.onKeyUp(x, v);
                      }
                    }),
                    ref: "input",
                    refInFor: !0
                  });
                },
                genTextFieldSlot: function(v) {
                  return this.$createElement("div", {
                    staticClass: "v-text-field__slot"
                  }, [this.genInput(v)]);
                },
                onBlur: function(v) {
                  var y = this;
                  this.isFocused = !1, v && this.$nextTick(function() {
                    return y.$emit("blur", v);
                  });
                },
                onClick: function(v) {
                  this.isFocused || this.isDisabled || !this.$refs.input[v] || this.onFocus(void 0, v);
                },
                onFocus: function(v, y) {
                  v == null || v.preventDefault(), v == null || v.stopPropagation();
                  var E = this.$refs.input, C = this.$refs.input && E[y || 0];
                  if (C) {
                    if (document.activeElement !== C)
                      return C.focus(), C.select();
                    this.isFocused || (this.isFocused = !0, C.select(), v && this.$emit("focus", v));
                  }
                },
                onInput: function(v, y) {
                  for (var E = +this.length - 1, C = v.target, x = C.value, b = (x == null ? void 0 : x.split("")) || [], P = p([], h(this.otp), !1), T = 0; T < b.length; T++) {
                    var O = y + T;
                    if (O > E)
                      break;
                    P[O] = b[T].toString();
                  }
                  b.length || P.splice(y, 1), this.otp = P, this.internalValue = this.otp.join(""), y + b.length >= +this.length ? (this.onCompleted(), this.clearFocus(y)) : b.length && this.changeFocus(y + b.length);
                },
                clearFocus: function(v) {
                  var y = this.$refs.input[v];
                  y.blur();
                },
                onKeyDown: function(v) {
                  v.keyCode === f.keyCodes.enter && this.$emit("change", this.internalValue), this.$emit("keydown", v);
                },
                onMouseDown: function(v, y) {
                  v.target !== this.$refs.input[y] && (v.preventDefault(), v.stopPropagation()), a.default.options.methods.onMouseDown.call(this, v);
                },
                onMouseUp: function(v, y) {
                  this.hasMouseDown && this.focus(v, y), a.default.options.methods.onMouseUp.call(this, v);
                },
                changeFocus: function(v) {
                  this.onFocus(void 0, v || 0);
                },
                updateValue: function(v) {
                  this.hasColor = v, v ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                },
                onKeyUp: function(v, y) {
                  v.preventDefault();
                  var E = v.key;
                  if (!["Tab", "Shift", "Meta", "Control", "Alt"].includes(E) && !["Delete"].includes(E)) {
                    if (E === "ArrowLeft" || E === "Backspace" && !this.otp[y])
                      return y > 0 && this.changeFocus(y - 1);
                    if (E === "ArrowRight")
                      return y + 1 < +this.length && this.changeFocus(y + 1);
                  }
                },
                onCompleted: function() {
                  var v = this.otp.join("");
                  v.length === +this.length && this.$emit("finish", v);
                }
              },
              render: function(v) {
                return v("div", {
                  staticClass: "v-otp-input",
                  class: this.themeClasses
                }, this.genContent());
              }
            });
          }
        ),
        /***/
        "./src/components/VOtpInput/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VOtpInput/index.ts ***!
            \*******************************************/
          /*! exports provided: VOtpInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOtpInput */
              "./src/components/VOtpInput/VOtpInput.ts"
            );
            i.d(r, "VOtpInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOverflowBtn/VOverflowBtn.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VOverflowBtn/VOverflowBtn.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOverflowBtn/VOverflowBtn.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VOverflowBtn/VOverflowBtn.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VOverflowBtn.sass */
              "./src/components/VOverflowBtn/VOverflowBtn.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VAutocomplete */
              "./src/components/VAutocomplete/index.ts"
            ), l = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), f = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = o.default.extend({
              name: "v-overflow-btn",
              props: {
                editable: Boolean,
                segmented: Boolean
              },
              computed: {
                classes: function() {
                  return u(u({}, o.default.options.computed.classes.call(this)), {
                    "v-overflow-btn": !0,
                    "v-overflow-btn--segmented": this.segmented,
                    "v-overflow-btn--editable": this.editable
                  });
                },
                isAnyValueAllowed: function() {
                  return this.editable || o.default.options.computed.isAnyValueAllowed.call(this);
                },
                isSingle: function() {
                  return !0;
                },
                computedItems: function() {
                  return this.segmented ? this.allItems : this.filteredItems;
                },
                labelValue: function() {
                  return this.isFocused && !this.persistentPlaceholder || this.isLabelActive;
                }
              },
              methods: {
                genSelections: function() {
                  return this.editable ? o.default.options.methods.genSelections.call(this) : a.default.options.methods.genSelections.call(this);
                },
                genCommaSelection: function(h, p, g) {
                  return this.segmented ? this.genSegmentedBtn(h) : a.default.options.methods.genCommaSelection.call(this, h, p, g);
                },
                genInput: function() {
                  var h = l.default.options.methods.genInput.call(this);
                  return h.data = h.data || {}, h.data.domProps.value = this.editable ? this.internalSearch : "", h.data.attrs.readonly = !this.isAnyValueAllowed, h;
                },
                genLabel: function() {
                  if (this.editable && this.isFocused)
                    return null;
                  var h = l.default.options.methods.genLabel.call(this);
                  return h && (h.data = h.data || {}, h.data.style = {}, h);
                },
                genSegmentedBtn: function(h) {
                  var p = this, g = this.getValue(h), m = this.computedItems.find(function(v) {
                    return p.getValue(v) === g;
                  }) || h;
                  return !m.text || !m.callback ? (Object(d.consoleWarn)('When using "segmented" prop without a selection slot, items must contain both a text and callback property', this), null) : this.$createElement(f.default, {
                    props: {
                      text: !0
                    },
                    on: {
                      click: function(y) {
                        y.stopPropagation(), m.callback(y);
                      }
                    }
                  }, [m.text]);
                },
                updateValue: function(h) {
                  h ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VOverflowBtn/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VOverflowBtn/index.ts ***!
            \**********************************************/
          /*! exports provided: VOverflowBtn, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOverflowBtn */
              "./src/components/VOverflowBtn/VOverflowBtn.ts"
            );
            i.d(r, "VOverflowBtn", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOverlay/VOverlay.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VOverlay/VOverlay.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOverlay/VOverlay.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VOverlay/VOverlay.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VOverlay.sass */
              "./src/components/VOverlay/VOverlay.sass"
            );
            var a = i(
              /*! ./../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ./../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "v-overlay",
              props: {
                absolute: Boolean,
                color: {
                  type: String,
                  default: "#212121"
                },
                dark: {
                  type: Boolean,
                  default: !0
                },
                opacity: {
                  type: [Number, String],
                  default: 0.46
                },
                value: {
                  default: !0
                },
                zIndex: {
                  type: [Number, String],
                  default: 5
                }
              },
              computed: {
                __scrim: function() {
                  var c = this.setBackgroundColor(this.color, {
                    staticClass: "v-overlay__scrim",
                    style: {
                      opacity: this.computedOpacity
                    }
                  });
                  return this.$createElement("div", c);
                },
                classes: function() {
                  return d({
                    "v-overlay--absolute": this.absolute,
                    "v-overlay--active": this.isActive
                  }, this.themeClasses);
                },
                computedOpacity: function() {
                  return Number(this.isActive ? this.opacity : 0);
                },
                styles: function() {
                  return {
                    zIndex: this.zIndex
                  };
                }
              },
              methods: {
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-overlay__content"
                  }, this.$slots.default);
                }
              },
              render: function(c) {
                var h = [this.__scrim];
                return this.isActive && h.push(this.genContent()), c("div", {
                  staticClass: "v-overlay",
                  on: this.$listeners,
                  class: this.classes,
                  style: this.styles
                }, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VOverlay/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VOverlay/index.ts ***!
            \******************************************/
          /*! exports provided: VOverlay, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOverlay */
              "./src/components/VOverlay/VOverlay.ts"
            );
            i.d(r, "VOverlay", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VPagination/VPagination.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VPagination/VPagination.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VPagination/VPagination.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VPagination/VPagination.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VPagination.sass */
              "./src/components/VPagination/VPagination.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/intersectable */
              "./src/mixins/intersectable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = Object(u.default)(l.default, Object(f.default)({
              onVisible: ["init"]
            }), d.default).extend({
              name: "v-pagination",
              directives: {
                Resize: o.default
              },
              props: {
                circle: Boolean,
                disabled: Boolean,
                navigationColor: String,
                navigationTextColor: String,
                length: {
                  type: Number,
                  default: 0,
                  validator: function(m) {
                    return m % 1 === 0;
                  }
                },
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                totalVisible: [Number, String],
                value: {
                  type: Number,
                  default: 0
                },
                pageAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.page"
                },
                currentPageAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.currentPage"
                },
                previousAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.previous"
                },
                nextAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.next"
                },
                wrapperAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.wrapper"
                }
              },
              data: function() {
                return {
                  maxButtons: 0,
                  selected: null
                };
              },
              computed: {
                classes: function() {
                  return c({
                    "v-pagination": !0,
                    "v-pagination--circle": this.circle,
                    "v-pagination--disabled": this.disabled
                  }, this.themeClasses);
                },
                items: function() {
                  var m = parseInt(this.totalVisible, 10);
                  if (m === 0 || isNaN(this.length) || this.length > Number.MAX_SAFE_INTEGER)
                    return [];
                  var v = Math.min(Math.max(0, m) || this.length, Math.max(0, this.maxButtons) || this.length, this.length);
                  if (this.length <= v)
                    return this.range(1, this.length);
                  var y = v % 2 === 0 ? 1 : 0, E = Math.floor(v / 2), C = this.length - E + 1 + y;
                  if (this.value > E && this.value < C) {
                    var x = 1, b = this.length, P = this.value - E + 2, T = this.value + E - 2 - y, O = P - 1 === x + 1 ? 2 : "...", S = T + 1 === b - 1 ? T + 1 : "...";
                    return p(p([1, O], h(this.range(P, T)), !1), [S, this.length], !1);
                  } else if (this.value === E) {
                    var T = this.value + E - 1 - y;
                    return p(p([], h(this.range(1, T)), !1), ["...", this.length], !1);
                  } else if (this.value === C) {
                    var P = this.value - E + 1;
                    return p([1, "..."], h(this.range(P, this.length)), !1);
                  } else
                    return p(p(p([], h(this.range(1, E)), !1), ["..."], !1), h(this.range(C, this.length)), !1);
                }
              },
              watch: {
                value: function() {
                  this.init();
                }
              },
              beforeMount: function() {
                this.init();
              },
              methods: {
                init: function() {
                  var m = this;
                  this.selected = null, this.onResize(), this.$nextTick(this.onResize), setTimeout(function() {
                    return m.selected = m.value;
                  }, 100);
                },
                onResize: function() {
                  var m = this.$el && this.$el.parentElement ? this.$el.parentElement.clientWidth : window.innerWidth;
                  this.maxButtons = Math.floor((m - 96) / 42);
                },
                next: function(m) {
                  m.preventDefault(), this.$emit("input", this.value + 1), this.$emit("next");
                },
                previous: function(m) {
                  m.preventDefault(), this.$emit("input", this.value - 1), this.$emit("previous");
                },
                range: function(m, v) {
                  var y = [];
                  m = m > 0 ? m : 1;
                  for (var E = m; E <= v; E++)
                    y.push(E);
                  return y;
                },
                genIcon: function(m, v, y, E, C) {
                  return m("li", [m("button", this.setBackgroundColor(this.navigationColor, {
                    staticClass: "v-pagination__navigation",
                    class: {
                      "v-pagination__navigation--disabled": y
                    },
                    attrs: {
                      disabled: y,
                      type: "button",
                      "aria-label": C
                    },
                    on: y ? {} : {
                      click: E
                    }
                  }), [m(a.default, {
                    props: {
                      color: this.navigationTextColor
                    }
                  }, [v])])]);
                },
                genItem: function(m, v) {
                  var y = this, E = v === this.value && (this.color || "primary"), C = v === this.value, x = C ? this.currentPageAriaLabel : this.pageAriaLabel;
                  return m("button", this.setBackgroundColor(E, {
                    staticClass: "v-pagination__item",
                    class: {
                      "v-pagination__item--active": v === this.value
                    },
                    attrs: {
                      type: "button",
                      "aria-current": C,
                      "aria-label": this.$vuetify.lang.t(x, v)
                    },
                    on: {
                      click: function() {
                        return y.$emit("input", v);
                      }
                    }
                  }), [v.toString()]);
                },
                genItems: function(m) {
                  var v = this;
                  return this.items.map(function(y, E) {
                    return m("li", {
                      key: E
                    }, [isNaN(Number(y)) ? m("span", {
                      class: "v-pagination__more"
                    }, [y.toString()]) : v.genItem(m, y)]);
                  });
                },
                genList: function(m, v) {
                  return m("ul", {
                    directives: [{
                      modifiers: {
                        quiet: !0
                      },
                      name: "resize",
                      value: this.onResize
                    }],
                    class: this.classes
                  }, v);
                }
              },
              render: function(m) {
                var v = [this.genIcon(m, this.$vuetify.rtl ? this.nextIcon : this.prevIcon, this.value <= 1, this.previous, this.$vuetify.lang.t(this.previousAriaLabel)), this.genItems(m), this.genIcon(m, this.$vuetify.rtl ? this.prevIcon : this.nextIcon, this.value >= this.length, this.next, this.$vuetify.lang.t(this.nextAriaLabel))];
                return m("nav", {
                  attrs: {
                    role: "navigation",
                    "aria-label": this.$vuetify.lang.t(this.wrapperAriaLabel)
                  }
                }, [this.genList(m, v)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VPagination/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VPagination/index.ts ***!
            \*********************************************/
          /*! exports provided: VPagination, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VPagination */
              "./src/components/VPagination/VPagination.ts"
            );
            i.d(r, "VPagination", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VParallax/VParallax.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VParallax/VParallax.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VParallax/VParallax.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VParallax/VParallax.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VParallax.sass */
              "./src/components/VParallax/VParallax.sass"
            );
            var a = i(
              /*! ../../mixins/translatable */
              "./src/mixins/translatable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = Object(o.default)(a.default);
            r.default = l.extend().extend({
              name: "v-parallax",
              props: {
                alt: {
                  type: String,
                  default: ""
                },
                height: {
                  type: [String, Number],
                  default: 500
                },
                src: String,
                srcset: String
              },
              data: function() {
                return {
                  isBooted: !1
                };
              },
              computed: {
                styles: function() {
                  return {
                    display: "block",
                    opacity: this.isBooted ? 1 : 0,
                    transform: "translate(-50%, " + this.parallax + "px)"
                  };
                }
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function() {
                  var d = this, u = this.$refs.img;
                  u && (u.complete ? (this.translate(), this.listeners()) : u.addEventListener("load", function() {
                    d.translate(), d.listeners();
                  }, !1), this.isBooted = !0);
                },
                objHeight: function() {
                  return this.$refs.img.naturalHeight;
                }
              },
              render: function(d) {
                var u = {
                  staticClass: "v-parallax__image",
                  style: this.styles,
                  attrs: {
                    src: this.src,
                    srcset: this.srcset,
                    alt: this.alt
                  },
                  ref: "img"
                }, c = d("div", {
                  staticClass: "v-parallax__image-container"
                }, [d("img", u)]), h = d("div", {
                  staticClass: "v-parallax__content"
                }, this.$slots.default);
                return d("div", {
                  staticClass: "v-parallax",
                  style: {
                    height: this.height + "px"
                  },
                  on: this.$listeners
                }, [c, h]);
              }
            });
          }
        ),
        /***/
        "./src/components/VParallax/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VParallax/index.ts ***!
            \*******************************************/
          /*! exports provided: VParallax, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VParallax */
              "./src/components/VParallax/VParallax.ts"
            );
            i.d(r, "VParallax", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VPicker/VPicker.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VPicker/VPicker.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VPicker/VPicker.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VPicker/VPicker.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VPicker.sass */
              "./src/components/VPicker/VPicker.sass"
            ), i(
              /*! ../VCard/VCard.sass */
              "./src/components/VCard/VCard.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(d.default)(a.default, o.default, l.default).extend({
              name: "v-picker",
              props: {
                flat: Boolean,
                fullWidth: Boolean,
                landscape: Boolean,
                noTitle: Boolean,
                transition: {
                  type: String,
                  default: "fade-transition"
                },
                width: {
                  type: [Number, String],
                  default: 290
                }
              },
              computed: {
                computedTitleColor: function() {
                  var h = this.isDark ? !1 : this.color || "primary";
                  return this.color || h;
                }
              },
              methods: {
                genTitle: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.computedTitleColor, {
                    staticClass: "v-picker__title",
                    class: {
                      "v-picker__title--landscape": this.landscape
                    }
                  }), this.$slots.title);
                },
                genBodyTransition: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, this.$slots.default);
                },
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-picker__body",
                    class: u({
                      "v-picker__body--no-title": this.noTitle
                    }, this.themeClasses),
                    style: this.fullWidth ? void 0 : {
                      width: Object(f.convertToUnit)(this.width)
                    }
                  }, [this.genBodyTransition()]);
                },
                genActions: function() {
                  return this.$createElement("div", {
                    staticClass: "v-picker__actions v-card__actions",
                    class: {
                      "v-picker__actions--no-title": this.noTitle
                    }
                  }, this.$slots.actions);
                }
              },
              render: function(h) {
                return h("div", {
                  staticClass: "v-picker v-card",
                  class: u(u({
                    "v-picker--flat": this.flat,
                    "v-picker--landscape": this.landscape,
                    "v-picker--full-width": this.fullWidth
                  }, this.themeClasses), this.elevationClasses)
                }, [this.$slots.title ? this.genTitle() : null, this.genBody(), this.$slots.actions ? this.genActions() : null]);
              }
            });
          }
        ),
        /***/
        "./src/components/VPicker/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VPicker/index.ts ***!
            \*****************************************/
          /*! exports provided: VPicker, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VPicker */
              "./src/components/VPicker/VPicker.ts"
            );
            i.d(r, "VPicker", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VProgressCircular/VProgressCircular.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VProgressCircular/VProgressCircular.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VProgressCircular/VProgressCircular.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VProgressCircular/VProgressCircular.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VProgressCircular.sass */
              "./src/components/VProgressCircular/VProgressCircular.sass"
            );
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = o.default.extend({
              name: "v-progress-circular",
              directives: {
                intersect: a.default
              },
              props: {
                button: Boolean,
                indeterminate: Boolean,
                rotate: {
                  type: [Number, String],
                  default: 0
                },
                size: {
                  type: [Number, String],
                  default: 32
                },
                width: {
                  type: [Number, String],
                  default: 4
                },
                value: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  radius: 20,
                  isVisible: !0
                };
              },
              computed: {
                calculatedSize: function() {
                  return Number(this.size) + (this.button ? 8 : 0);
                },
                circumference: function() {
                  return 2 * Math.PI * this.radius;
                },
                classes: function() {
                  return {
                    "v-progress-circular--visible": this.isVisible,
                    "v-progress-circular--indeterminate": this.indeterminate,
                    "v-progress-circular--button": this.button
                  };
                },
                normalizedValue: function() {
                  return this.value < 0 ? 0 : this.value > 100 ? 100 : parseFloat(this.value);
                },
                strokeDashArray: function() {
                  return Math.round(this.circumference * 1e3) / 1e3;
                },
                strokeDashOffset: function() {
                  return (100 - this.normalizedValue) / 100 * this.circumference + "px";
                },
                strokeWidth: function() {
                  return Number(this.width) / +this.size * this.viewBoxSize * 2;
                },
                styles: function() {
                  return {
                    height: Object(l.convertToUnit)(this.calculatedSize),
                    width: Object(l.convertToUnit)(this.calculatedSize)
                  };
                },
                svgStyles: function() {
                  return {
                    transform: "rotate(" + Number(this.rotate) + "deg)"
                  };
                },
                viewBoxSize: function() {
                  return this.radius / (1 - Number(this.width) / +this.size);
                }
              },
              methods: {
                genCircle: function(d, u) {
                  return this.$createElement("circle", {
                    class: "v-progress-circular__" + d,
                    attrs: {
                      fill: "transparent",
                      cx: 2 * this.viewBoxSize,
                      cy: 2 * this.viewBoxSize,
                      r: this.radius,
                      "stroke-width": this.strokeWidth,
                      "stroke-dasharray": this.strokeDashArray,
                      "stroke-dashoffset": u
                    }
                  });
                },
                genSvg: function() {
                  var d = [this.indeterminate || this.genCircle("underlay", 0), this.genCircle("overlay", this.strokeDashOffset)];
                  return this.$createElement("svg", {
                    style: this.svgStyles,
                    attrs: {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: this.viewBoxSize + " " + this.viewBoxSize + " " + 2 * this.viewBoxSize + " " + 2 * this.viewBoxSize
                    }
                  }, d);
                },
                genInfo: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-circular__info"
                  }, this.$slots.default);
                },
                onObserve: function(d, u, c) {
                  this.isVisible = c;
                }
              },
              render: function(d) {
                return d("div", this.setTextColor(this.color, {
                  staticClass: "v-progress-circular",
                  attrs: {
                    role: "progressbar",
                    "aria-valuemin": 0,
                    "aria-valuemax": 100,
                    "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
                  },
                  class: this.classes,
                  directives: [{
                    name: "intersect",
                    value: this.onObserve
                  }],
                  style: this.styles,
                  on: this.$listeners
                }), [this.genSvg(), this.genInfo()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VProgressCircular/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VProgressCircular/index.ts ***!
            \***************************************************/
          /*! exports provided: VProgressCircular, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VProgressCircular */
              "./src/components/VProgressCircular/VProgressCircular.ts"
            );
            i.d(r, "VProgressCircular", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VProgressLinear/VProgressLinear.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VProgressLinear/VProgressLinear.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VProgressLinear/VProgressLinear.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VProgressLinear/VProgressLinear.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VProgressLinear.sass */
              "./src/components/VProgressLinear/VProgressLinear.sass"
            );
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(l.default, Object(f.factory)(["absolute", "fixed", "top", "bottom"]), d.default, u.default);
            r.default = g.extend({
              name: "v-progress-linear",
              directives: {
                intersect: o.default
              },
              props: {
                active: {
                  type: Boolean,
                  default: !0
                },
                backgroundColor: {
                  type: String,
                  default: null
                },
                backgroundOpacity: {
                  type: [Number, String],
                  default: null
                },
                bufferValue: {
                  type: [Number, String],
                  default: 100
                },
                color: {
                  type: String,
                  default: "primary"
                },
                height: {
                  type: [Number, String],
                  default: 4
                },
                indeterminate: Boolean,
                query: Boolean,
                reverse: Boolean,
                rounded: Boolean,
                stream: Boolean,
                striped: Boolean,
                value: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  internalLazyValue: this.value || 0,
                  isVisible: !0
                };
              },
              computed: {
                __cachedBackground: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor || this.color, {
                    staticClass: "v-progress-linear__background",
                    style: this.backgroundStyle
                  }));
                },
                __cachedBar: function() {
                  return this.$createElement(this.computedTransition, [this.__cachedBarType]);
                },
                __cachedBarType: function() {
                  return this.indeterminate ? this.__cachedIndeterminate : this.__cachedDeterminate;
                },
                __cachedBuffer: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-linear__buffer",
                    style: this.styles
                  });
                },
                __cachedDeterminate: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-progress-linear__determinate",
                    style: {
                      width: Object(c.convertToUnit)(this.normalizedValue, "%")
                    }
                  }));
                },
                __cachedIndeterminate: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-linear__indeterminate",
                    class: {
                      "v-progress-linear__indeterminate--active": this.active
                    }
                  }, [this.genProgressBar("long"), this.genProgressBar("short")]);
                },
                __cachedStream: function() {
                  return this.stream ? this.$createElement("div", this.setTextColor(this.color, {
                    staticClass: "v-progress-linear__stream",
                    style: {
                      width: Object(c.convertToUnit)(100 - this.normalizedBuffer, "%")
                    }
                  })) : null;
                },
                backgroundStyle: function() {
                  var v, y = this.backgroundOpacity == null ? this.backgroundColor ? 1 : 0.3 : parseFloat(this.backgroundOpacity);
                  return v = {
                    opacity: y
                  }, v[this.isReversed ? "right" : "left"] = Object(c.convertToUnit)(this.normalizedValue, "%"), v.width = Object(c.convertToUnit)(Math.max(0, this.normalizedBuffer - this.normalizedValue), "%"), v;
                },
                classes: function() {
                  return p({
                    "v-progress-linear--absolute": this.absolute,
                    "v-progress-linear--fixed": this.fixed,
                    "v-progress-linear--query": this.query,
                    "v-progress-linear--reactive": this.reactive,
                    "v-progress-linear--reverse": this.isReversed,
                    "v-progress-linear--rounded": this.rounded,
                    "v-progress-linear--striped": this.striped,
                    "v-progress-linear--visible": this.isVisible
                  }, this.themeClasses);
                },
                computedTransition: function() {
                  return this.indeterminate ? a.VFadeTransition : a.VSlideXTransition;
                },
                isReversed: function() {
                  return this.$vuetify.rtl !== this.reverse;
                },
                normalizedBuffer: function() {
                  return this.normalize(this.bufferValue);
                },
                normalizedValue: function() {
                  return this.normalize(this.internalLazyValue);
                },
                reactive: function() {
                  return !!this.$listeners.change;
                },
                styles: function() {
                  var v = {};
                  return this.active || (v.height = 0), !this.indeterminate && parseFloat(this.normalizedBuffer) !== 100 && (v.width = Object(c.convertToUnit)(this.normalizedBuffer, "%")), v;
                }
              },
              methods: {
                genContent: function() {
                  var v = Object(c.getSlot)(this, "default", {
                    value: this.internalLazyValue
                  });
                  return v ? this.$createElement("div", {
                    staticClass: "v-progress-linear__content"
                  }, v) : null;
                },
                genListeners: function() {
                  var v = this.$listeners;
                  return this.reactive && (v.click = this.onClick), v;
                },
                genProgressBar: function(v) {
                  var y;
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-progress-linear__indeterminate",
                    class: (y = {}, y[v] = !0, y)
                  }));
                },
                onClick: function(v) {
                  if (this.reactive) {
                    var y = this.$el.getBoundingClientRect().width;
                    this.internalValue = v.offsetX / y * 100;
                  }
                },
                onObserve: function(v, y, E) {
                  this.isVisible = E;
                },
                normalize: function(v) {
                  return v < 0 ? 0 : v > 100 ? 100 : parseFloat(v);
                }
              },
              render: function(v) {
                var y = {
                  staticClass: "v-progress-linear",
                  attrs: {
                    role: "progressbar",
                    "aria-valuemin": 0,
                    "aria-valuemax": this.normalizedBuffer,
                    "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
                  },
                  class: this.classes,
                  directives: [{
                    name: "intersect",
                    value: this.onObserve
                  }],
                  style: {
                    bottom: this.bottom ? 0 : void 0,
                    height: this.active ? Object(c.convertToUnit)(this.height) : 0,
                    top: this.top ? 0 : void 0
                  },
                  on: this.genListeners()
                };
                return v("div", y, [this.__cachedStream, this.__cachedBackground, this.__cachedBuffer, this.__cachedBar, this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VProgressLinear/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VProgressLinear/index.ts ***!
            \*************************************************/
          /*! exports provided: VProgressLinear, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VProgressLinear */
              "./src/components/VProgressLinear/VProgressLinear.ts"
            );
            i.d(r, "VProgressLinear", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadio.sass": (
          /*!************************************************!*\
            !*** ./src/components/VRadioGroup/VRadio.sass ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadio.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VRadioGroup/VRadio.ts ***!
            \**********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRadio.sass */
              "./src/components/VRadioGroup/VRadio.sass"
            );
            var a = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), u = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), c = i(
              /*! ../../mixins/rippleable */
              "./src/mixins/rippleable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), y = function() {
              return y = Object.assign || function(x) {
                for (var b, P = 1, T = arguments.length; P < T; P++) {
                  b = arguments[P];
                  for (var O in b)
                    Object.prototype.hasOwnProperty.call(b, O) && (x[O] = b[O]);
                }
                return x;
              }, y.apply(this, arguments);
            }, E = function(x, b) {
              var P = {};
              for (var T in x)
                Object.prototype.hasOwnProperty.call(x, T) && b.indexOf(T) < 0 && (P[T] = x[T]);
              if (x != null && typeof Object.getOwnPropertySymbols == "function")
                for (var O = 0, T = Object.getOwnPropertySymbols(x); O < T.length; O++)
                  b.indexOf(T[O]) < 0 && Object.prototype.propertyIsEnumerable.call(x, T[O]) && (P[T[O]] = x[T[O]]);
              return P;
            }, C = Object(m.default)(f.default, d.default, c.default, Object(u.factory)("radioGroup"), h.default);
            r.default = C.extend().extend({
              name: "v-radio",
              inheritAttrs: !1,
              props: {
                disabled: {
                  type: Boolean,
                  default: null
                },
                id: String,
                label: String,
                name: String,
                offIcon: {
                  type: String,
                  default: "$radioOff"
                },
                onIcon: {
                  type: String,
                  default: "$radioOn"
                },
                readonly: {
                  type: Boolean,
                  default: null
                },
                value: {
                  default: null
                }
              },
              data: function() {
                return {
                  isFocused: !1
                };
              },
              computed: {
                classes: function() {
                  return y(y({
                    "v-radio--is-disabled": this.isDisabled,
                    "v-radio--is-focused": this.isFocused
                  }, this.themeClasses), this.groupClasses);
                },
                computedColor: function() {
                  if (!this.isDisabled)
                    return p.default.options.computed.computedColor.call(this);
                },
                computedIcon: function() {
                  return this.isActive ? this.onIcon : this.offIcon;
                },
                computedId: function() {
                  return l.default.options.computed.computedId.call(this);
                },
                hasLabel: l.default.options.computed.hasLabel,
                hasState: function() {
                  return (this.radioGroup || {}).hasState;
                },
                isDisabled: function() {
                  var b;
                  return (b = this.disabled) !== null && b !== void 0 ? b : !!this.radioGroup && this.radioGroup.isDisabled;
                },
                isReadonly: function() {
                  var b;
                  return (b = this.readonly) !== null && b !== void 0 ? b : !!this.radioGroup && this.radioGroup.isReadonly;
                },
                computedName: function() {
                  return this.name || !this.radioGroup ? this.name : this.radioGroup.name || "radio-" + this.radioGroup._uid;
                },
                rippleState: function() {
                  return p.default.options.computed.rippleState.call(this);
                },
                validationState: function() {
                  return (this.radioGroup || {}).validationState || this.computedColor;
                }
              },
              methods: {
                genInput: function(b) {
                  return p.default.options.methods.genInput.call(this, "radio", b);
                },
                genLabel: function() {
                  return this.hasLabel ? this.$createElement(a.default, {
                    on: {
                      // Label shouldn't cause the input to focus
                      click: p.prevent
                    },
                    attrs: {
                      for: this.computedId
                    },
                    props: {
                      color: this.validationState,
                      focused: this.hasState
                    }
                  }, Object(g.getSlot)(this, "label") || this.label) : null;
                },
                genRadio: function() {
                  var b = this.attrs$;
                  b.title;
                  var P = E(b, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.$createElement(o.default, this.setTextColor(this.validationState, {
                    props: {
                      dense: this.radioGroup && this.radioGroup.dense
                    }
                  }), this.computedIcon), this.genInput(y({
                    name: this.computedName,
                    value: this.value
                  }, P)), this.genRipple(this.setTextColor(this.rippleState))]);
                },
                onFocus: function(b) {
                  this.isFocused = !0, this.$emit("focus", b);
                },
                onBlur: function(b) {
                  this.isFocused = !1, this.$emit("blur", b);
                },
                onChange: function() {
                  this.isDisabled || this.isReadonly || this.isActive || this.toggle();
                },
                onKeydown: function() {
                }
                // Override default with noop
              },
              render: function(b) {
                var P = {
                  staticClass: "v-radio",
                  class: this.classes,
                  on: Object(v.mergeListeners)({
                    click: this.onChange
                  }, this.listeners$),
                  attrs: {
                    title: this.attrs$.title
                  }
                };
                return b("div", P, [this.genRadio(), this.genLabel()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadioGroup.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VRadioGroup/VRadioGroup.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadioGroup.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VRadioGroup/VRadioGroup.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            ), i(
              /*! ./VRadioGroup.sass */
              "./src/components/VRadioGroup/VRadioGroup.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            }, d = Object(l.default)(o.BaseItemGroup, a.default);
            r.default = d.extend({
              name: "v-radio-group",
              provide: function() {
                return {
                  radioGroup: this
                };
              },
              props: {
                column: {
                  type: Boolean,
                  default: !0
                },
                height: {
                  type: [Number, String],
                  default: "auto"
                },
                name: String,
                row: Boolean,
                // If no value set on VRadio
                // will match valueComparator
                // force default to null
                value: null
              },
              computed: {
                classes: function() {
                  return f(f({}, a.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls v-input--radio-group": !0,
                    "v-input--radio-group--column": this.column && !this.row,
                    "v-input--radio-group--row": this.row
                  });
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-input--radio-group__input",
                    attrs: {
                      id: this.id,
                      role: "radiogroup",
                      "aria-labelledby": this.computedId
                    }
                  }, a.default.options.methods.genDefaultSlot.call(this));
                },
                genInputSlot: function() {
                  var c = a.default.options.methods.genInputSlot.call(this);
                  return delete c.data.on.click, c;
                },
                genLabel: function() {
                  var c = a.default.options.methods.genLabel.call(this);
                  return c ? (c.data.attrs.id = this.computedId, delete c.data.attrs.for, c.tag = "legend", c) : null;
                },
                onClick: o.BaseItemGroup.options.methods.onClick
              },
              render: function(c) {
                var h = a.default.options.render.call(this, c);
                return this._b(h.data, "div", this.attrs$), h;
              }
            });
          }
        ),
        /***/
        "./src/components/VRadioGroup/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VRadioGroup/index.ts ***!
            \*********************************************/
          /*! exports provided: VRadioGroup, VRadio, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRadioGroup */
              "./src/components/VRadioGroup/VRadioGroup.ts"
            );
            i.d(r, "VRadioGroup", function() {
              return a.default;
            });
            var o = i(
              /*! ./VRadio */
              "./src/components/VRadioGroup/VRadio.ts"
            );
            i.d(r, "VRadio", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VRadioGroup: a.default,
                VRadio: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VRangeSlider/VRangeSlider.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VRangeSlider/VRangeSlider.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRangeSlider/VRangeSlider.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VRangeSlider/VRangeSlider.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRangeSlider.sass */
              "./src/components/VRangeSlider/VRangeSlider.sass"
            );
            var a = i(
              /*! ../VSlider */
              "./src/components/VSlider/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = function() {
              return l = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, l.apply(this, arguments);
            }, f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = a.default.extend({
              name: "v-range-slider",
              props: {
                value: {
                  type: Array,
                  default: function() {
                    return [0, 0];
                  }
                }
              },
              data: function() {
                return {
                  activeThumb: null,
                  lazyValue: this.value
                };
              },
              computed: {
                classes: function() {
                  return l(l({}, a.default.options.computed.classes.call(this)), {
                    "v-input--range-slider": !0
                  });
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(c) {
                    var h = this, p = c.map(function(v) {
                      return v === void 0 && (v = 0), h.roundValue(Math.min(Math.max(v, h.minValue), h.maxValue));
                    });
                    if (p[0] > p[1] || p[1] < p[0]) {
                      if (this.activeThumb !== null) {
                        var g = this.activeThumb === 1 ? 0 : 1, m = this.$refs["thumb_" + g];
                        m.focus();
                      }
                      p = [p[1], p[0]];
                    }
                    this.lazyValue = p, Object(o.deepEqual)(p, this.value) || this.$emit("input", p), this.validate();
                  }
                },
                inputWidth: function() {
                  var c = this;
                  return this.internalValue.map(function(h) {
                    return (c.roundValue(h) - c.minValue) / (c.maxValue - c.minValue) * 100;
                  });
                }
              },
              methods: {
                getTrackStyle: function(c, h, p, g) {
                  var m;
                  p === void 0 && (p = 0), g === void 0 && (g = 0);
                  var v = this.vertical ? this.$vuetify.rtl ? "top" : "bottom" : this.$vuetify.rtl ? "right" : "left", y = this.vertical ? "height" : "width", E = "calc(" + c + "% + " + p + "px)", C = "calc(" + h + "% + " + g + "px)";
                  return m = {
                    transition: this.trackTransition
                  }, m[v] = E, m[y] = C, m;
                },
                getIndexOfClosestValue: function(c, h) {
                  return Math.abs(c[0] - h) < Math.abs(c[1] - h) ? 0 : 1;
                },
                genInput: function() {
                  var c = this;
                  return Object(o.createRange)(2).map(function(h) {
                    var p = a.default.options.methods.genInput.call(c);
                    return p.data = p.data || {}, p.data.attrs = p.data.attrs || {}, p.data.attrs.value = c.internalValue[h], p.data.attrs.id = "input-" + (h ? "max" : "min") + "-" + c._uid, p;
                  });
                },
                genTrackContainer: function() {
                  var c = this, h = [], p = this.isDisabled ? 10 : 0, g = [{
                    class: "v-slider__track-background",
                    color: this.computedTrackColor,
                    styles: [0, this.inputWidth[0], 0, -p]
                  }, {
                    class: this.isDisabled ? "v-slider__track-background" : "v-slider__track-fill",
                    color: this.isDisabled ? this.computedTrackColor : this.computedTrackFillColor,
                    styles: [this.inputWidth[0], Math.abs(this.inputWidth[1] - this.inputWidth[0]), p, p * -2]
                  }, {
                    class: "v-slider__track-background",
                    color: this.computedTrackColor,
                    styles: [this.inputWidth[1], Math.abs(100 - this.inputWidth[1]), p, -p]
                  }];
                  return this.$vuetify.rtl && g.reverse(), h.push.apply(h, d([], f(g.map(function(m) {
                    return c.$createElement("div", c.setBackgroundColor(m.color, {
                      staticClass: m.class,
                      style: c.getTrackStyle.apply(c, d([], f(m.styles), !1))
                    }));
                  })), !1)), this.$createElement("div", {
                    staticClass: "v-slider__track-container",
                    ref: "track"
                  }, h);
                },
                genChildren: function() {
                  var c = this;
                  return [this.genInput(), this.genTrackContainer(), this.genSteps(), Object(o.createRange)(2).map(function(h) {
                    var p = c.internalValue[h], g = function(x) {
                      c.isFocused = !0, c.activeThumb = h, c.$emit("focus", x);
                    }, m = function(x) {
                      c.isFocused = !1, c.activeThumb = null, c.$emit("blur", x);
                    }, v = c.inputWidth[h], y = c.isActive && c.activeThumb === h, E = c.isFocused && c.activeThumb === h;
                    return c.genThumbContainer(p, v, y, E, g, m, "thumb_" + h);
                  })];
                },
                reevaluateSelected: function(c) {
                  this.activeThumb = this.getIndexOfClosestValue(this.internalValue, c);
                  var h = "thumb_" + this.activeThumb, p = this.$refs[h];
                  p.focus();
                },
                onSliderMouseDown: function(c) {
                  var h = this, p, g = this.parseMouseMove(c);
                  if (this.reevaluateSelected(g), this.oldValue = this.internalValue, this.isActive = !0, !((p = c.target) === null || p === void 0) && p.matches(".v-slider__thumb-container, .v-slider__thumb-container *")) {
                    this.thumbPressed = !0;
                    var m = c.target.getBoundingClientRect(), v = "touches" in c ? c.touches[0] : c;
                    this.startOffset = this.vertical ? v.clientY - (m.top + m.height / 2) : v.clientX - (m.left + m.width / 2);
                  } else
                    this.startOffset = 0, window.clearTimeout(this.mouseTimeout), this.mouseTimeout = window.setTimeout(function() {
                      h.thumbPressed = !0;
                    }, 300);
                  var y = o.passiveSupported ? {
                    passive: !0,
                    capture: !0
                  } : !0, E = o.passiveSupported ? {
                    passive: !0
                  } : !1, C = "touches" in c;
                  this.onMouseMove(c), this.app.addEventListener(C ? "touchmove" : "mousemove", this.onMouseMove, E), Object(o.addOnceEventListener)(this.app, C ? "touchend" : "mouseup", this.onSliderMouseUp, y), this.$emit("start", this.internalValue);
                },
                onSliderClick: function(c) {
                  if (!this.isActive) {
                    if (this.noClick) {
                      this.noClick = !1;
                      return;
                    }
                    var h = this.parseMouseMove(c);
                    this.reevaluateSelected(h), this.setInternalValue(h), this.$emit("change", this.internalValue);
                  }
                },
                onMouseMove: function(c) {
                  var h = this.parseMouseMove(c);
                  c.type === "mousemove" && (this.thumbPressed = !0), this.activeThumb === null && (this.activeThumb = this.getIndexOfClosestValue(this.internalValue, h)), this.setInternalValue(h);
                },
                onKeyDown: function(c) {
                  if (this.activeThumb !== null) {
                    var h = this.parseKeyDown(c, this.internalValue[this.activeThumb]);
                    h != null && (this.setInternalValue(h), this.$emit("change", this.internalValue));
                  }
                },
                setInternalValue: function(c) {
                  var h = this;
                  this.internalValue = this.internalValue.map(function(p, g) {
                    return g === h.activeThumb ? c : Number(p);
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VRangeSlider/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VRangeSlider/index.ts ***!
            \**********************************************/
          /*! exports provided: VRangeSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRangeSlider */
              "./src/components/VRangeSlider/VRangeSlider.ts"
            );
            i.d(r, "VRangeSlider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VRating/VRating.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VRating/VRating.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRating/VRating.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VRating/VRating.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRating.sass */
              "./src/components/VRating/VRating.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), d = i(
              /*! ../../mixins/rippleable */
              "./src/mixins/rippleable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(h.default)(o.default, l.default, d.default, f.default, u.default).extend({
              name: "v-rating",
              props: {
                backgroundColor: {
                  type: String,
                  default: "accent"
                },
                color: {
                  type: String,
                  default: "primary"
                },
                clearable: Boolean,
                dense: Boolean,
                emptyIcon: {
                  type: String,
                  default: "$ratingEmpty"
                },
                fullIcon: {
                  type: String,
                  default: "$ratingFull"
                },
                halfIcon: {
                  type: String,
                  default: "$ratingHalf"
                },
                halfIncrements: Boolean,
                hover: Boolean,
                length: {
                  type: [Number, String],
                  default: 5
                },
                readonly: Boolean,
                size: [Number, String],
                value: {
                  type: Number,
                  default: 0
                },
                iconLabel: {
                  type: String,
                  default: "$vuetify.rating.ariaLabel.icon"
                }
              },
              data: function() {
                return {
                  hoverIndex: -1,
                  internalValue: this.value
                };
              },
              computed: {
                directives: function() {
                  return this.readonly || !this.ripple ? [] : [{
                    name: "ripple",
                    value: {
                      circle: !0
                    }
                  }];
                },
                iconProps: function() {
                  var g = this.$props, m = g.dark, v = g.large, y = g.light, E = g.medium, C = g.small, x = g.size, b = g.xLarge, P = g.xSmall;
                  return {
                    dark: m,
                    large: v,
                    light: y,
                    medium: E,
                    size: x,
                    small: C,
                    xLarge: b,
                    xSmall: P
                  };
                },
                isHovering: function() {
                  return this.hover && this.hoverIndex >= 0;
                }
              },
              watch: {
                internalValue: function(g) {
                  g !== this.value && this.$emit("input", g);
                },
                value: function(g) {
                  this.internalValue = g;
                }
              },
              methods: {
                createClickFn: function(g) {
                  var m = this;
                  return function(v) {
                    if (!m.readonly) {
                      var y = m.genHoverIndex(v, g);
                      m.clearable && m.internalValue === y ? m.internalValue = 0 : m.internalValue = y;
                    }
                  };
                },
                createProps: function(g) {
                  var m = {
                    index: g,
                    value: this.internalValue,
                    click: this.createClickFn(g),
                    isFilled: Math.floor(this.internalValue) > g,
                    isHovered: Math.floor(this.hoverIndex) > g
                  };
                  return this.halfIncrements && (m.isHalfHovered = !m.isHovered && (this.hoverIndex - g) % 1 > 0, m.isHalfFilled = !m.isFilled && (this.internalValue - g) % 1 > 0), m;
                },
                genHoverIndex: function(g, m) {
                  var v = this.isHalfEvent(g);
                  return this.halfIncrements && this.$vuetify.rtl && (v = !v), m + (v ? 0.5 : 1);
                },
                getIconName: function(g) {
                  var m = this.isHovering ? g.isHovered : g.isFilled, v = this.isHovering ? g.isHalfHovered : g.isHalfFilled;
                  return m ? this.fullIcon : v ? this.halfIcon : this.emptyIcon;
                },
                getColor: function(g) {
                  if (this.isHovering) {
                    if (g.isHovered || g.isHalfHovered)
                      return this.color;
                  } else if (g.isFilled || g.isHalfFilled)
                    return this.color;
                  return this.backgroundColor;
                },
                isHalfEvent: function(g) {
                  if (this.halfIncrements) {
                    var m = g.target && g.target.getBoundingClientRect();
                    if (m && g.pageX - m.left < m.width / 2)
                      return !0;
                  }
                  return !1;
                },
                onMouseEnter: function(g, m) {
                  var v = this;
                  this.runDelay("open", function() {
                    v.hoverIndex = v.genHoverIndex(g, m);
                  });
                },
                onMouseLeave: function() {
                  var g = this;
                  this.runDelay("close", function() {
                    return g.hoverIndex = -1;
                  });
                },
                genItem: function(g) {
                  var m = this, v = this.createProps(g);
                  if (this.$scopedSlots.item)
                    return this.$scopedSlots.item(v);
                  var y = {
                    click: v.click
                  };
                  return this.hover && (y.mouseenter = function(E) {
                    return m.onMouseEnter(E, g);
                  }, y.mouseleave = this.onMouseLeave, this.halfIncrements && (y.mousemove = function(E) {
                    return m.onMouseEnter(E, g);
                  })), this.$createElement(a.default, this.setTextColor(this.getColor(v), {
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.iconLabel, g + 1, Number(this.length))
                    },
                    directives: this.directives,
                    props: this.iconProps,
                    on: y
                  }), [this.getIconName(v)]);
                }
              },
              render: function(g) {
                var m = this, v = Object(c.createRange)(Number(this.length)).map(function(y) {
                  return m.genItem(y);
                });
                return g("div", {
                  staticClass: "v-rating",
                  class: {
                    "v-rating--readonly": this.readonly,
                    "v-rating--dense": this.dense
                  }
                }, v);
              }
            });
          }
        ),
        /***/
        "./src/components/VRating/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VRating/index.ts ***!
            \*****************************************/
          /*! exports provided: VRating, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRating */
              "./src/components/VRating/VRating.ts"
            );
            i.d(r, "VRating", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VResponsive/VResponsive.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VResponsive/VResponsive.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VResponsive/VResponsive.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VResponsive/VResponsive.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VResponsive.sass */
              "./src/components/VResponsive/VResponsive.sass"
            );
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              name: "v-responsive",
              props: {
                aspectRatio: [String, Number],
                contentClass: String
              },
              computed: {
                computedAspectRatio: function() {
                  return Number(this.aspectRatio);
                },
                aspectStyle: function() {
                  return this.computedAspectRatio ? {
                    paddingBottom: 1 / this.computedAspectRatio * 100 + "%"
                  } : void 0;
                },
                __cachedSizer: function() {
                  return this.aspectStyle ? this.$createElement("div", {
                    style: this.aspectStyle,
                    staticClass: "v-responsive__sizer"
                  }) : [];
                }
              },
              methods: {
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-responsive__content",
                    class: this.contentClass
                  }, Object(l.getSlot)(this));
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-responsive",
                  style: this.measurableStyles,
                  on: this.$listeners
                }, [this.__cachedSizer, this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VResponsive/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VResponsive/index.ts ***!
            \*********************************************/
          /*! exports provided: VResponsive, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VResponsive */
              "./src/components/VResponsive/VResponsive.ts"
            );
            i.d(r, "VResponsive", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSelect/VSelect.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSelect/VSelect.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSelect/VSelect.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSelect/VSelect.ts ***!
            \*******************************************/
          /*! exports provided: defaultMenuProps, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "defaultMenuProps", function() {
              return x;
            }), i(
              /*! ../VTextField/VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            ), i(
              /*! ./VSelect.sass */
              "./src/components/VSelect/VSelect.sass"
            );
            var a = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), o = i(
              /*! ../VMenu */
              "./src/components/VMenu/index.ts"
            ), l = i(
              /*! ./VSelectList */
              "./src/components/VSelect/VSelectList.ts"
            ), f = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), d = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), u = i(
              /*! ../../mixins/comparable */
              "./src/mixins/comparable/index.ts"
            ), c = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), h = i(
              /*! ../../mixins/filterable */
              "./src/mixins/filterable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), m = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), E = function() {
              return E = Object.assign || function(P) {
                for (var T, O = 1, S = arguments.length; O < S; O++) {
                  T = arguments[O];
                  for (var L in T)
                    Object.prototype.hasOwnProperty.call(T, L) && (P[L] = T[L]);
                }
                return P;
              }, E.apply(this, arguments);
            }, C = function(P) {
              var T = typeof Symbol == "function" && Symbol.iterator, O = T && P[T], S = 0;
              if (O)
                return O.call(P);
              if (P && typeof P.length == "number")
                return {
                  next: function() {
                    return P && S >= P.length && (P = void 0), {
                      value: P && P[S++],
                      done: !P
                    };
                  }
                };
              throw new TypeError(T ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, x = {
              closeOnClick: !1,
              closeOnContentClick: !1,
              disableKeys: !0,
              openOnClick: !1,
              maxHeight: 304
            }, b = Object(y.default)(d.default, u.default, c.default, h.default);
            r.default = b.extend().extend({
              name: "v-select",
              directives: {
                ClickOutside: p.default
              },
              props: {
                appendIcon: {
                  type: String,
                  default: "$dropdown"
                },
                attach: {
                  type: null,
                  default: !1
                },
                cacheItems: Boolean,
                chips: Boolean,
                clearable: Boolean,
                deletableChips: Boolean,
                disableLookup: Boolean,
                eager: Boolean,
                hideSelected: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                itemColor: {
                  type: String,
                  default: "primary"
                },
                itemDisabled: {
                  type: [String, Array, Function],
                  default: "disabled"
                },
                itemText: {
                  type: [String, Array, Function],
                  default: "text"
                },
                itemValue: {
                  type: [String, Array, Function],
                  default: "value"
                },
                menuProps: {
                  type: [String, Array, Object],
                  default: function() {
                    return x;
                  }
                },
                multiple: Boolean,
                openOnClear: Boolean,
                returnObject: Boolean,
                smallChips: Boolean
              },
              data: function() {
                return {
                  cachedItems: this.cacheItems ? this.items : [],
                  menuIsBooted: !1,
                  isMenuActive: !1,
                  lastItem: 20,
                  // As long as a value is defined, show it
                  // Otherwise, check if multiple
                  // to determine which default to provide
                  lazyValue: this.value !== void 0 ? this.value : this.multiple ? [] : void 0,
                  selectedIndex: -1,
                  selectedItems: [],
                  keyboardLookupPrefix: "",
                  keyboardLookupLastTime: 0
                };
              },
              computed: {
                /* All items that the select has */
                allItems: function() {
                  return this.filterDuplicates(this.cachedItems.concat(this.items));
                },
                classes: function() {
                  return E(E({}, d.default.options.computed.classes.call(this)), {
                    "v-select": !0,
                    "v-select--chips": this.hasChips,
                    "v-select--chips--small": this.smallChips,
                    "v-select--is-menu-active": this.isMenuActive,
                    "v-select--is-multi": this.multiple
                  });
                },
                /* Used by other components to overwrite */
                computedItems: function() {
                  return this.allItems;
                },
                computedOwns: function() {
                  return "list-" + this._uid;
                },
                computedCounterValue: function() {
                  var T, O = this.multiple ? this.selectedItems : ((T = this.getText(this.selectedItems[0])) !== null && T !== void 0 ? T : "").toString();
                  return typeof this.counterValue == "function" ? this.counterValue(O) : O.length;
                },
                directives: function() {
                  var T = this;
                  return this.isFocused ? [{
                    name: "click-outside",
                    value: {
                      handler: this.blur,
                      closeConditional: this.closeConditional,
                      include: function() {
                        return T.getOpenDependentElements();
                      }
                    }
                  }] : void 0;
                },
                dynamicHeight: function() {
                  return "auto";
                },
                hasChips: function() {
                  return this.chips || this.smallChips;
                },
                hasSlot: function() {
                  return !!(this.hasChips || this.$scopedSlots.selection);
                },
                isDirty: function() {
                  return this.selectedItems.length > 0;
                },
                listData: function() {
                  var T, O = this.$vnode && this.$vnode.context.$options._scopeId, S = O ? (T = {}, T[O] = !0, T) : {};
                  return {
                    attrs: E(E({}, S), {
                      id: this.computedOwns
                    }),
                    props: {
                      action: this.multiple,
                      color: this.itemColor,
                      dense: this.dense,
                      hideSelected: this.hideSelected,
                      items: this.virtualizedItems,
                      itemDisabled: this.itemDisabled,
                      itemText: this.itemText,
                      itemValue: this.itemValue,
                      noDataText: this.$vuetify.lang.t(this.noDataText),
                      selectedItems: this.selectedItems
                    },
                    on: {
                      select: this.selectItem
                    },
                    scopedSlots: {
                      item: this.$scopedSlots.item
                    }
                  };
                },
                staticList: function() {
                  return (this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"]) && Object(v.consoleError)("assert: staticList should not be called if slots are used"), this.$createElement(l.default, this.listData);
                },
                virtualizedItems: function() {
                  return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem);
                },
                menuCanShow: function() {
                  return !0;
                },
                $_menuProps: function() {
                  var T = typeof this.menuProps == "string" ? this.menuProps.split(",") : this.menuProps;
                  return Array.isArray(T) && (T = T.reduce(function(O, S) {
                    return O[S.trim()] = !0, O;
                  }, {})), E(E(E({}, x), {
                    eager: this.eager,
                    value: this.menuCanShow && this.isMenuActive,
                    nudgeBottom: T.offsetY ? 1 : 0
                  }), T);
                }
              },
              watch: {
                internalValue: function(T) {
                  var O = this;
                  this.initialValue = T, this.setSelectedItems(), this.multiple && this.$nextTick(function() {
                    var S;
                    (S = O.$refs.menu) === null || S === void 0 || S.updateDimensions();
                  }), this.hideSelected && this.$nextTick(function() {
                    O.onScroll();
                  });
                },
                isMenuActive: function(T) {
                  var O = this;
                  window.setTimeout(function() {
                    return O.onMenuActiveChange(T);
                  });
                },
                items: {
                  immediate: !0,
                  handler: function(T) {
                    var O = this;
                    this.cacheItems && this.$nextTick(function() {
                      O.cachedItems = O.filterDuplicates(O.cachedItems.concat(T));
                    }), this.setSelectedItems();
                  }
                }
              },
              methods: {
                /** @public */
                blur: function(T) {
                  d.default.options.methods.blur.call(this, T), this.isMenuActive = !1, this.isFocused = !1, this.selectedIndex = -1, this.setMenuIndex(-1);
                },
                /** @public */
                activateMenu: function() {
                  !this.isInteractive || this.isMenuActive || (this.isMenuActive = !0);
                },
                clearableCallback: function() {
                  var T = this;
                  this.setValue(this.multiple ? [] : null), this.setMenuIndex(-1), this.$nextTick(function() {
                    return T.$refs.input && T.$refs.input.focus();
                  }), this.openOnClear && (this.isMenuActive = !0);
                },
                closeConditional: function(T) {
                  return this.isMenuActive ? !this._isDestroyed && // Click originates from outside the menu content
                  // Multiple selects don't close when an item is clicked
                  (!this.getContent() || !this.getContent().contains(T.target)) && // Click originates from outside the element
                  this.$el && !this.$el.contains(T.target) && T.target !== this.$el : !0;
                },
                filterDuplicates: function(T) {
                  for (var O = /* @__PURE__ */ new Map(), S = 0; S < T.length; ++S) {
                    var L = T[S];
                    if (L != null) {
                      if (L.header || L.divider) {
                        O.set(L, L);
                        continue;
                      }
                      var A = this.getValue(L);
                      !O.has(A) && O.set(A, L);
                    }
                  }
                  return Array.from(O.values());
                },
                findExistingIndex: function(T) {
                  var O = this, S = this.getValue(T);
                  return (this.internalValue || []).findIndex(function(L) {
                    return O.valueComparator(O.getValue(L), S);
                  });
                },
                getContent: function() {
                  return this.$refs.menu && this.$refs.menu.$refs.content;
                },
                genChipSelection: function(T, O) {
                  var S = this, L = this.isDisabled || this.getDisabled(T), A = !L && this.isInteractive;
                  return this.$createElement(a.default, {
                    staticClass: "v-chip--select",
                    attrs: {
                      tabindex: -1
                    },
                    props: {
                      close: this.deletableChips && A,
                      disabled: L,
                      inputValue: O === this.selectedIndex,
                      small: this.smallChips
                    },
                    on: {
                      click: function(_) {
                        A && (_.stopPropagation(), S.selectedIndex = O);
                      },
                      "click:close": function() {
                        return S.onChipInput(T);
                      }
                    },
                    key: JSON.stringify(this.getValue(T))
                  }, this.getText(T));
                },
                genCommaSelection: function(T, O, S) {
                  var L = O === this.selectedIndex && this.computedColor, A = this.isDisabled || this.getDisabled(T);
                  return this.$createElement("div", this.setTextColor(L, {
                    staticClass: "v-select__selection v-select__selection--comma",
                    class: {
                      "v-select__selection--disabled": A
                    },
                    key: JSON.stringify(this.getValue(T))
                  }), "" + this.getText(T) + (S ? "" : ", "));
                },
                genDefaultSlot: function() {
                  var T = this.genSelections(), O = this.genInput();
                  return Array.isArray(T) ? T.push(O) : (T.children = T.children || [], T.children.push(O)), [this.genFieldset(), this.$createElement("div", {
                    staticClass: "v-select__slot",
                    directives: this.directives
                  }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, T, this.suffix ? this.genAffix("suffix") : null, this.genClearIcon(), this.genIconSlot(), this.genHiddenInput()]), this.genMenu(), this.genProgress()];
                },
                genIcon: function(T, O, S) {
                  var L = f.default.options.methods.genIcon.call(this, T, O, S);
                  return T === "append" && (L.children[0].data = Object(g.default)(L.children[0].data, {
                    attrs: {
                      tabindex: L.children[0].componentOptions.listeners && "-1",
                      "aria-hidden": "true",
                      "aria-label": void 0
                    }
                  })), L;
                },
                genInput: function() {
                  var T = d.default.options.methods.genInput.call(this);
                  return delete T.data.attrs.name, T.data = Object(g.default)(T.data, {
                    domProps: {
                      value: null
                    },
                    attrs: {
                      readonly: !0,
                      type: "text",
                      "aria-readonly": String(this.isReadonly),
                      "aria-activedescendant": Object(m.getObjectValueByPath)(this.$refs.menu, "activeTile.id"),
                      autocomplete: Object(m.getObjectValueByPath)(T.data, "attrs.autocomplete", "off"),
                      placeholder: !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? this.placeholder : void 0
                    },
                    on: {
                      keypress: this.onKeyPress
                    }
                  }), T;
                },
                genHiddenInput: function() {
                  return this.$createElement("input", {
                    domProps: {
                      value: this.lazyValue
                    },
                    attrs: {
                      type: "hidden",
                      name: this.attrs$.name
                    }
                  });
                },
                genInputSlot: function() {
                  var T = d.default.options.methods.genInputSlot.call(this);
                  return T.data.attrs = E(E({}, T.data.attrs), {
                    role: "button",
                    "aria-haspopup": "listbox",
                    "aria-expanded": String(this.isMenuActive),
                    "aria-owns": this.computedOwns
                  }), T;
                },
                genList: function() {
                  return this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"] ? this.genListWithSlot() : this.staticList;
                },
                genListWithSlot: function() {
                  var T = this, O = ["prepend-item", "no-data", "append-item"].filter(function(S) {
                    return T.$slots[S];
                  }).map(function(S) {
                    return T.$createElement("template", {
                      slot: S
                    }, T.$slots[S]);
                  });
                  return this.$createElement(l.default, E({}, this.listData), O);
                },
                genMenu: function() {
                  var T = this, O = this.$_menuProps;
                  return O.activator = this.$refs["input-slot"], "attach" in O || (// TODO: make this a computed property or helper or something
                  this.attach === "" || // If used as a boolean prop (<v-menu attach>)
                  this.attach === !0 || // If bound to a boolean (<v-menu :attach="true">)
                  this.attach === "attach" ? O.attach = this.$el : O.attach = this.attach), this.$createElement(o.default, {
                    attrs: {
                      role: void 0
                    },
                    props: O,
                    on: {
                      input: function(L) {
                        T.isMenuActive = L, T.isFocused = L;
                      },
                      scroll: this.onScroll
                    },
                    ref: "menu"
                  }, [this.genList()]);
                },
                genSelections: function() {
                  var T = this.selectedItems.length, O = new Array(T), S;
                  for (this.$scopedSlots.selection ? S = this.genSlotSelection : this.hasChips ? S = this.genChipSelection : S = this.genCommaSelection; T--; )
                    O[T] = S(this.selectedItems[T], T, T === O.length - 1);
                  return this.$createElement("div", {
                    staticClass: "v-select__selections"
                  }, O);
                },
                genSlotSelection: function(T, O) {
                  var S = this;
                  return this.$scopedSlots.selection({
                    attrs: {
                      class: "v-chip--select"
                    },
                    parent: this,
                    item: T,
                    index: O,
                    select: function(A) {
                      A.stopPropagation(), S.selectedIndex = O;
                    },
                    selected: O === this.selectedIndex,
                    disabled: !this.isInteractive
                  });
                },
                getMenuIndex: function() {
                  return this.$refs.menu ? this.$refs.menu.listIndex : -1;
                },
                getDisabled: function(T) {
                  return Object(m.getPropertyFromItem)(T, this.itemDisabled, !1);
                },
                getText: function(T) {
                  return Object(m.getPropertyFromItem)(T, this.itemText, T);
                },
                getValue: function(T) {
                  return Object(m.getPropertyFromItem)(T, this.itemValue, this.getText(T));
                },
                onBlur: function(T) {
                  T && this.$emit("blur", T);
                },
                onChipInput: function(T) {
                  this.multiple ? this.selectItem(T) : this.setValue(null), this.selectedItems.length === 0 ? this.isMenuActive = !0 : this.isMenuActive = !1, this.selectedIndex = -1;
                },
                onClick: function(T) {
                  this.isInteractive && (this.isAppendInner(T.target) || (this.isMenuActive = !0), this.isFocused || (this.isFocused = !0, this.$emit("focus")), this.$emit("click", T));
                },
                onEscDown: function(T) {
                  T.preventDefault(), this.isMenuActive && (T.stopPropagation(), this.isMenuActive = !1);
                },
                onKeyPress: function(T) {
                  var O = this;
                  if (!(this.multiple || !this.isInteractive || this.disableLookup || T.key.length > 1 || T.ctrlKey || T.metaKey || T.altKey)) {
                    var S = 1e3, L = performance.now();
                    L - this.keyboardLookupLastTime > S && (this.keyboardLookupPrefix = ""), this.keyboardLookupPrefix += T.key.toLowerCase(), this.keyboardLookupLastTime = L;
                    var A = this.allItems.findIndex(function(_) {
                      var w, B = ((w = O.getText(_)) !== null && w !== void 0 ? w : "").toString();
                      return B.toLowerCase().startsWith(O.keyboardLookupPrefix);
                    }), D = this.allItems[A];
                    A !== -1 && (this.lastItem = Math.max(this.lastItem, A + 5), this.setValue(this.returnObject ? D : this.getValue(D)), this.$nextTick(function() {
                      return O.$refs.menu.getTiles();
                    }), setTimeout(function() {
                      return O.setMenuIndex(A);
                    }));
                  }
                },
                onKeyDown: function(T) {
                  var O = this;
                  if (!(this.isReadonly && T.keyCode !== m.keyCodes.tab)) {
                    var S = T.keyCode, L = this.$refs.menu;
                    if (this.$emit("keydown", T), !!L) {
                      if (this.isMenuActive && [m.keyCodes.up, m.keyCodes.down, m.keyCodes.home, m.keyCodes.end, m.keyCodes.enter].includes(S) && this.$nextTick(function() {
                        L.changeListIndex(T), O.$emit("update:list-index", L.listIndex);
                      }), [m.keyCodes.enter, m.keyCodes.space].includes(S) && this.activateMenu(), !this.isMenuActive && [m.keyCodes.up, m.keyCodes.down, m.keyCodes.home, m.keyCodes.end].includes(S))
                        return this.onUpDown(T);
                      if (S === m.keyCodes.esc)
                        return this.onEscDown(T);
                      if (S === m.keyCodes.tab)
                        return this.onTabDown(T);
                      if (S === m.keyCodes.space)
                        return this.onSpaceDown(T);
                    }
                  }
                },
                onMenuActiveChange: function(T) {
                  if (!(this.multiple && !T || this.getMenuIndex() > -1)) {
                    var O = this.$refs.menu;
                    if (!(!O || !this.isDirty)) {
                      this.$refs.menu.getTiles();
                      for (var S = 0; S < O.tiles.length; S++)
                        if (O.tiles[S].getAttribute("aria-selected") === "true") {
                          this.setMenuIndex(S);
                          break;
                        }
                    }
                  }
                },
                onMouseUp: function(T) {
                  var O = this;
                  this.hasMouseDown && T.which !== 3 && this.isInteractive && this.isAppendInner(T.target) && this.$nextTick(function() {
                    return O.isMenuActive = !O.isMenuActive;
                  }), d.default.options.methods.onMouseUp.call(this, T);
                },
                onScroll: function() {
                  var T = this;
                  if (!this.isMenuActive)
                    requestAnimationFrame(function() {
                      var S = T.getContent();
                      S && (S.scrollTop = 0);
                    });
                  else {
                    if (this.lastItem > this.computedItems.length)
                      return;
                    var O = this.getContent().scrollHeight - (this.getContent().scrollTop + this.getContent().clientHeight) < 200;
                    O && (this.lastItem += 20);
                  }
                },
                onSpaceDown: function(T) {
                  T.preventDefault();
                },
                onTabDown: function(T) {
                  var O = this.$refs.menu;
                  if (O) {
                    var S = O.activeTile;
                    !this.multiple && S && this.isMenuActive ? (T.preventDefault(), T.stopPropagation(), S.click()) : this.blur(T);
                  }
                },
                onUpDown: function(T) {
                  var O = this, S = this.$refs.menu;
                  if (S) {
                    if (T.preventDefault(), this.multiple)
                      return this.activateMenu();
                    var L = T.keyCode;
                    S.isBooted = !0, window.requestAnimationFrame(function() {
                      if (S.getTiles(), !S.hasClickableTiles)
                        return O.activateMenu();
                      switch (L) {
                        case m.keyCodes.up:
                          S.prevTile();
                          break;
                        case m.keyCodes.down:
                          S.nextTile();
                          break;
                        case m.keyCodes.home:
                          S.firstTile();
                          break;
                        case m.keyCodes.end:
                          S.lastTile();
                          break;
                      }
                      O.selectItem(O.allItems[O.getMenuIndex()]);
                    });
                  }
                },
                selectItem: function(T) {
                  var O = this;
                  if (!this.multiple)
                    this.setValue(this.returnObject ? T : this.getValue(T)), this.isMenuActive = !1;
                  else {
                    var S = (this.internalValue || []).slice(), L = this.findExistingIndex(T);
                    if (L !== -1 ? S.splice(L, 1) : S.push(T), this.setValue(S.map(function(D) {
                      return O.returnObject ? D : O.getValue(D);
                    })), this.hideSelected)
                      this.setMenuIndex(-1);
                    else {
                      var A = this.allItems.indexOf(T);
                      ~A && (this.$nextTick(function() {
                        return O.$refs.menu.getTiles();
                      }), setTimeout(function() {
                        return O.setMenuIndex(A);
                      }));
                    }
                  }
                },
                setMenuIndex: function(T) {
                  this.$refs.menu && (this.$refs.menu.listIndex = T);
                },
                setSelectedItems: function() {
                  var T, O, S = this, L = [], A = !this.multiple || !Array.isArray(this.internalValue) ? [this.internalValue] : this.internalValue, D = function(X) {
                    var rt = _.allItems.findIndex(function(et) {
                      return S.valueComparator(S.getValue(et), S.getValue(X));
                    });
                    rt > -1 && L.push(_.allItems[rt]);
                  }, _ = this;
                  try {
                    for (var w = C(A), B = w.next(); !B.done; B = w.next()) {
                      var j = B.value;
                      D(j);
                    }
                  } catch (k) {
                    T = {
                      error: k
                    };
                  } finally {
                    try {
                      B && !B.done && (O = w.return) && O.call(w);
                    } finally {
                      if (T)
                        throw T.error;
                    }
                  }
                  this.selectedItems = L;
                },
                setValue: function(T) {
                  this.valueComparator(T, this.internalValue) || (this.internalValue = T, this.$emit("change", T));
                },
                isAppendInner: function(T) {
                  var O = this.$refs["append-inner"];
                  return O && (O === T || O.contains(T));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSelect/VSelectList.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VSelect/VSelectList.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), o = i(
              /*! ../VDivider */
              "./src/components/VDivider/index.ts"
            ), l = i(
              /*! ../VSubheader */
              "./src/components/VSubheader/index.ts"
            ), f = i(
              /*! ../VList */
              "./src/components/VList/index.ts"
            ), d = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), u = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), c = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, g.apply(this, arguments);
            };
            r.default = Object(p.default)(u.default, c.default).extend({
              name: "v-select-list",
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: d.default
              },
              props: {
                action: Boolean,
                dense: Boolean,
                hideSelected: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                itemDisabled: {
                  type: [String, Array, Function],
                  default: "disabled"
                },
                itemText: {
                  type: [String, Array, Function],
                  default: "text"
                },
                itemValue: {
                  type: [String, Array, Function],
                  default: "value"
                },
                noDataText: String,
                noFilter: Boolean,
                searchInput: null,
                selectedItems: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              computed: {
                parsedItems: function() {
                  var v = this;
                  return this.selectedItems.map(function(y) {
                    return v.getValue(y);
                  });
                },
                tileActiveClass: function() {
                  return Object.keys(this.setTextColor(this.color).class || {}).join(" ");
                },
                staticNoDataTile: function() {
                  var v = {
                    attrs: {
                      role: void 0
                    },
                    on: {
                      mousedown: function(E) {
                        return E.preventDefault();
                      }
                      // Prevent onBlur from being called
                    }
                  };
                  return this.$createElement(f.VListItem, v, [this.genTileContent(this.noDataText)]);
                }
              },
              methods: {
                genAction: function(v, y) {
                  var E = this;
                  return this.$createElement(f.VListItemAction, [this.$createElement(a.default, {
                    props: {
                      color: this.color,
                      value: y,
                      ripple: !1
                    },
                    on: {
                      input: function() {
                        return E.$emit("select", v);
                      }
                    }
                  })]);
                },
                genDivider: function(v) {
                  return this.$createElement(o.default, {
                    props: v
                  });
                },
                genFilteredText: function(v) {
                  if (v = v || "", !this.searchInput || this.noFilter)
                    return v;
                  var y = this.getMaskedCharacters(v), E = y.start, C = y.middle, x = y.end;
                  return [E, this.genHighlight(C), x];
                },
                genHeader: function(v) {
                  return this.$createElement(l.default, {
                    props: v
                  }, v.header);
                },
                genHighlight: function(v) {
                  return this.$createElement("span", {
                    staticClass: "v-list-item__mask"
                  }, v);
                },
                getMaskedCharacters: function(v) {
                  var y = (this.searchInput || "").toString().toLocaleLowerCase(), E = v.toLocaleLowerCase().indexOf(y);
                  if (E < 0)
                    return {
                      start: v,
                      middle: "",
                      end: ""
                    };
                  var C = v.slice(0, E), x = v.slice(E, E + y.length), b = v.slice(E + y.length);
                  return {
                    start: C,
                    middle: x,
                    end: b
                  };
                },
                genTile: function(v) {
                  var y = this, E = v.item, C = v.index, x = v.disabled, b = x === void 0 ? null : x, P = v.value, T = P === void 0 ? !1 : P;
                  T || (T = this.hasItem(E)), E === Object(E) && (b = b !== null ? b : this.getDisabled(E));
                  var O = {
                    attrs: {
                      // Default behavior in list does not
                      // contain aria-selected by default
                      "aria-selected": String(T),
                      id: "list-item-" + this._uid + "-" + C,
                      role: "option"
                    },
                    on: {
                      mousedown: function(D) {
                        D.preventDefault();
                      },
                      click: function() {
                        return b || y.$emit("select", E);
                      }
                    },
                    props: {
                      activeClass: this.tileActiveClass,
                      disabled: b,
                      ripple: !0,
                      inputValue: T
                    }
                  };
                  if (!this.$scopedSlots.item)
                    return this.$createElement(f.VListItem, O, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(E, T) : null, this.genTileContent(E, C)]);
                  var S = this, L = this.$scopedSlots.item({
                    parent: S,
                    item: E,
                    attrs: g(g({}, O.attrs), O.props),
                    on: O.on
                  });
                  return this.needsTile(L) ? this.$createElement(f.VListItem, O, L) : L;
                },
                genTileContent: function(v, y) {
                  return this.$createElement(f.VListItemContent, [this.$createElement(f.VListItemTitle, [this.genFilteredText(this.getText(v))])]);
                },
                hasItem: function(v) {
                  return this.parsedItems.indexOf(this.getValue(v)) > -1;
                },
                needsTile: function(v) {
                  return v.length !== 1 || v[0].componentOptions == null || v[0].componentOptions.Ctor.options.name !== "v-list-item";
                },
                getDisabled: function(v) {
                  return !!Object(h.getPropertyFromItem)(v, this.itemDisabled, !1);
                },
                getText: function(v) {
                  return String(Object(h.getPropertyFromItem)(v, this.itemText, v));
                },
                getValue: function(v) {
                  return Object(h.getPropertyFromItem)(v, this.itemValue, this.getText(v));
                }
              },
              render: function() {
                for (var v = [], y = this.items.length, E = 0; E < y; E++) {
                  var C = this.items[E];
                  this.hideSelected && this.hasItem(C) || (C == null ? v.push(this.genTile({
                    item: C,
                    index: E
                  })) : C.header ? v.push(this.genHeader(C)) : C.divider ? v.push(this.genDivider(C)) : v.push(this.genTile({
                    item: C,
                    index: E
                  })));
                }
                return v.length || v.push(this.$slots["no-data"] || this.staticNoDataTile), this.$slots["prepend-item"] && v.unshift(this.$slots["prepend-item"]), this.$slots["append-item"] && v.push(this.$slots["append-item"]), this.$createElement(f.VList, {
                  staticClass: "v-select-list",
                  class: this.themeClasses,
                  attrs: {
                    role: "listbox",
                    tabindex: -1
                  },
                  props: {
                    dense: this.dense
                  }
                }, v);
              }
            });
          }
        ),
        /***/
        "./src/components/VSelect/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSelect/index.ts ***!
            \*****************************************/
          /*! exports provided: VSelect, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSelect */
              "./src/components/VSelect/VSelect.ts"
            );
            i.d(r, "VSelect", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSheet/VSheet.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VSheet/VSheet.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSheet/VSheet.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSheet/VSheet.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSheet.sass */
              "./src/components/VSheet/VSheet.sass"
            );
            var a = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), f = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), d = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, o.default, l.default, f.default, d.default, u.default).extend({
              name: "v-sheet",
              props: {
                outlined: Boolean,
                shaped: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              computed: {
                classes: function() {
                  return h(h(h({
                    "v-sheet": !0,
                    "v-sheet--outlined": this.outlined,
                    "v-sheet--shaped": this.shaped
                  }, this.themeClasses), this.elevationClasses), this.roundedClasses);
                },
                styles: function() {
                  return this.measurableStyles;
                }
              },
              render: function(g) {
                var m = {
                  class: this.classes,
                  style: this.styles,
                  on: this.listeners$
                };
                return g(this.tag, this.setBackgroundColor(this.color, m), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VSheet/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VSheet/index.ts ***!
            \****************************************/
          /*! exports provided: VSheet, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSheet */
              "./src/components/VSheet/VSheet.ts"
            );
            i.d(r, "VSheet", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/VSkeletonLoader.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VSkeletonLoader/VSkeletonLoader.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/VSkeletonLoader.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VSkeletonLoader/VSkeletonLoader.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSkeletonLoader.sass */
              "./src/components/VSkeletonLoader/VSkeletonLoader.sass"
            );
            var a = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), o = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            };
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "VSkeletonLoader",
              props: {
                boilerplate: Boolean,
                loading: Boolean,
                loadingText: {
                  type: String,
                  default: "$vuetify.loading"
                },
                tile: Boolean,
                transition: String,
                type: String,
                types: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                }
              },
              computed: {
                attrs: function() {
                  return this.isLoading ? u({
                    "aria-busy": this.boilerplate ? void 0 : !0,
                    "aria-live": this.boilerplate ? void 0 : "polite",
                    "aria-label": this.boilerplate ? void 0 : this.$vuetify.lang.t(this.loadingText),
                    role: this.boilerplate ? void 0 : "alert"
                  }, this.$attrs) : this.$attrs;
                },
                classes: function() {
                  return u(u({
                    "v-skeleton-loader--boilerplate": this.boilerplate,
                    "v-skeleton-loader--is-loading": this.isLoading,
                    "v-skeleton-loader--tile": this.tile
                  }, this.themeClasses), this.elevationClasses);
                },
                isLoading: function() {
                  return !("default" in this.$scopedSlots) || this.loading;
                },
                rootTypes: function() {
                  return u({
                    actions: "button@2",
                    article: "heading, paragraph",
                    avatar: "avatar",
                    button: "button",
                    card: "image, card-heading",
                    "card-avatar": "image, list-item-avatar",
                    "card-heading": "heading",
                    chip: "chip",
                    "date-picker": "list-item, card-heading, divider, date-picker-options, date-picker-days, actions",
                    "date-picker-options": "text, avatar@2",
                    "date-picker-days": "avatar@28",
                    heading: "heading",
                    image: "image",
                    "list-item": "text",
                    "list-item-avatar": "avatar, text",
                    "list-item-two-line": "sentences",
                    "list-item-avatar-two-line": "avatar, sentences",
                    "list-item-three-line": "paragraph",
                    "list-item-avatar-three-line": "avatar, paragraph",
                    paragraph: "text@3",
                    sentences: "text@2",
                    table: "table-heading, table-thead, table-tbody, table-tfoot",
                    "table-heading": "heading, text",
                    "table-thead": "heading@6",
                    "table-tbody": "table-row-divider@6",
                    "table-row-divider": "table-row, divider",
                    "table-row": "table-cell@6",
                    "table-cell": "text",
                    "table-tfoot": "text@2, avatar@2",
                    text: "text"
                  }, this.types);
                }
              },
              methods: {
                genBone: function(p, g) {
                  return this.$createElement("div", {
                    staticClass: "v-skeleton-loader__" + p + " v-skeleton-loader__bone"
                  }, g);
                },
                genBones: function(p) {
                  var g = this, m = c(p.split("@"), 2), v = m[0], y = m[1], E = function() {
                    return g.genStructure(v);
                  };
                  return Array.from({
                    length: y
                  }).map(E);
                },
                // Fix type when this is merged
                // https://github.com/microsoft/TypeScript/pull/33050
                genStructure: function(p) {
                  var g = [];
                  p = p || this.type || "";
                  var m = this.rootTypes[p] || "";
                  if (p !== m) {
                    if (p.indexOf(",") > -1)
                      return this.mapBones(p);
                    if (p.indexOf("@") > -1)
                      return this.genBones(p);
                    m.indexOf(",") > -1 ? g = this.mapBones(m) : m.indexOf("@") > -1 ? g = this.genBones(m) : m && g.push(this.genStructure(m));
                  }
                  return [this.genBone(p, g)];
                },
                genSkeleton: function() {
                  var p = [];
                  return this.isLoading ? p.push(this.genStructure()) : p.push(Object(d.getSlot)(this)), this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    },
                    // Only show transition when
                    // content has been loaded
                    on: {
                      afterEnter: this.resetStyles,
                      beforeEnter: this.onBeforeEnter,
                      beforeLeave: this.onBeforeLeave,
                      leaveCancelled: this.resetStyles
                    }
                  }, p) : p;
                },
                mapBones: function(p) {
                  return p.replace(/\s/g, "").split(",").map(this.genStructure);
                },
                onBeforeEnter: function(p) {
                  this.resetStyles(p), this.isLoading && (p._initialStyle = {
                    display: p.style.display,
                    transition: p.style.transition
                  }, p.style.setProperty("transition", "none", "important"));
                },
                onBeforeLeave: function(p) {
                  p.style.setProperty("display", "none", "important");
                },
                resetStyles: function(p) {
                  p._initialStyle && (p.style.display = p._initialStyle.display || "", p.style.transition = p._initialStyle.transition, delete p._initialStyle);
                }
              },
              render: function(p) {
                return p("div", {
                  staticClass: "v-skeleton-loader",
                  attrs: this.attrs,
                  on: this.$listeners,
                  class: this.classes,
                  style: this.isLoading ? this.measurableStyles : void 0
                }, [this.genSkeleton()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSkeletonLoader/index.ts ***!
            \*************************************************/
          /*! exports provided: VSkeletonLoader, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSkeletonLoader */
              "./src/components/VSkeletonLoader/VSkeletonLoader.ts"
            );
            i.d(r, "VSkeletonLoader", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideGroup.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideGroup.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideGroup.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideGroup.ts ***!
            \***************************************************/
          /*! exports provided: calculateUpdatedOffset, calculateCenteredOffset, BaseSlideGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "calculateUpdatedOffset", function() {
              return v;
            }), i.d(r, "calculateCenteredOffset", function() {
              return y;
            }), i.d(r, "BaseSlideGroup", function() {
              return E;
            }), i(
              /*! ./VSlideGroup.sass */
              "./src/components/VSlideGroup/VSlideGroup.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), f = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), d = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), u = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var T in x)
                    Object.prototype.hasOwnProperty.call(x, T) && (C[T] = x[T]);
                }
                return C;
              }, p.apply(this, arguments);
            }, g = function(C) {
              var x = typeof Symbol == "function" && Symbol.iterator, b = x && C[x], P = 0;
              if (b)
                return b.call(C);
              if (C && typeof C.length == "number")
                return {
                  next: function() {
                    return C && P >= C.length && (C = void 0), {
                      value: C && C[P++],
                      done: !C
                    };
                  }
                };
              throw new TypeError(x ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            function m(C) {
              var x = 0.501, b = Math.abs(C);
              return Math.sign(C) * (b / ((1 / x - 2) * (1 - b) + 1));
            }
            function v(C, x, b, P) {
              var T = C.clientWidth, O = b ? x.content - C.offsetLeft - T : C.offsetLeft;
              b && (P = -P);
              var S = x.wrapper + P, L = T + O, A = T * 0.4;
              return O <= P ? P = Math.max(O - A, 0) : S <= L && (P = Math.min(P - (S - L - A), x.content - x.wrapper)), b ? -P : P;
            }
            function y(C, x, b) {
              var P = C.offsetLeft, T = C.clientWidth;
              if (b) {
                var O = x.content - P - T / 2 - x.wrapper / 2;
                return -Math.min(x.content - x.wrapper, Math.max(0, O));
              } else {
                var O = P + T / 2 - x.wrapper / 2;
                return Math.min(x.content - x.wrapper, Math.max(0, O));
              }
            }
            var E = Object(c.default)(l.BaseItemGroup, f.default).extend({
              name: "base-slide-group",
              directives: {
                Resize: d.default,
                Touch: u.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: "v-slide-item--active"
                },
                centerActive: Boolean,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                showArrows: {
                  type: [Boolean, String],
                  validator: function(x) {
                    return typeof x == "boolean" || ["always", "never", "desktop", "mobile"].includes(x);
                  }
                }
              },
              data: function() {
                return {
                  isOverflowing: !1,
                  resizeTimeout: 0,
                  startX: 0,
                  isSwipingHorizontal: !1,
                  isSwiping: !1,
                  scrollOffset: 0,
                  widths: {
                    content: 0,
                    wrapper: 0
                  }
                };
              },
              computed: {
                canTouch: function() {
                  return typeof window < "u";
                },
                __cachedNext: function() {
                  return this.genTransition("next");
                },
                __cachedPrev: function() {
                  return this.genTransition("prev");
                },
                classes: function() {
                  return p(p({}, l.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-slide-group": !0,
                    "v-slide-group--has-affixes": this.hasAffixes,
                    "v-slide-group--is-overflowing": this.isOverflowing
                  });
                },
                hasAffixes: function() {
                  switch (this.showArrows) {
                    case "always":
                      return !0;
                    case "desktop":
                      return !this.isMobile;
                    case !0:
                      return this.isOverflowing || Math.abs(this.scrollOffset) > 0;
                    case "mobile":
                      return this.isMobile || this.isOverflowing || Math.abs(this.scrollOffset) > 0;
                    case "never":
                      return !1;
                    default:
                      return !this.isMobile && (this.isOverflowing || Math.abs(this.scrollOffset) > 0);
                  }
                },
                hasNext: function() {
                  if (!this.hasAffixes)
                    return !1;
                  var x = this.widths, b = x.content, P = x.wrapper;
                  return b > Math.abs(this.scrollOffset) + P;
                },
                hasPrev: function() {
                  return this.hasAffixes && this.scrollOffset !== 0;
                }
              },
              watch: {
                internalValue: "setWidths",
                // When overflow changes, the arrows alter
                // the widths of the content and wrapper
                // and need to be recalculated
                isOverflowing: "setWidths",
                scrollOffset: function(x) {
                  this.$vuetify.rtl && (x = -x);
                  var b = x <= 0 ? m(-x) : x > this.widths.content - this.widths.wrapper ? -(this.widths.content - this.widths.wrapper) + m(this.widths.content - this.widths.wrapper - x) : -x;
                  this.$vuetify.rtl && (b = -b), this.$refs.content.style.transform = "translateX(" + b + "px)";
                }
              },
              mounted: function() {
                var x = this;
                if (typeof ResizeObserver < "u") {
                  var b = new ResizeObserver(function() {
                    x.onResize();
                  });
                  b.observe(this.$el), b.observe(this.$refs.content), this.$on("hook:destroyed", function() {
                    b.disconnect();
                  });
                } else {
                  var P = 0;
                  this.$on("hook:beforeUpdate", function() {
                    var T;
                    P = (((T = x.$refs.content) === null || T === void 0 ? void 0 : T.children) || []).length;
                  }), this.$on("hook:updated", function() {
                    var T;
                    P !== (((T = x.$refs.content) === null || T === void 0 ? void 0 : T.children) || []).length && x.setWidths();
                  });
                }
              },
              methods: {
                onScroll: function() {
                  this.$refs.wrapper.scrollLeft = 0;
                },
                onFocusin: function(x) {
                  var b, P, T, O;
                  if (this.isOverflowing)
                    try {
                      for (var S = g(Object(h.composedPath)(x)), L = S.next(); !L.done; L = S.next()) {
                        var A = L.value;
                        try {
                          for (var D = (T = void 0, g(this.items)), _ = D.next(); !_.done; _ = D.next()) {
                            var w = _.value;
                            if (w.$el === A) {
                              this.scrollOffset = v(w.$el, this.widths, this.$vuetify.rtl, this.scrollOffset);
                              return;
                            }
                          }
                        } catch (B) {
                          T = {
                            error: B
                          };
                        } finally {
                          try {
                            _ && !_.done && (O = D.return) && O.call(D);
                          } finally {
                            if (T)
                              throw T.error;
                          }
                        }
                      }
                    } catch (B) {
                      b = {
                        error: B
                      };
                    } finally {
                      try {
                        L && !L.done && (P = S.return) && P.call(S);
                      } finally {
                        if (b)
                          throw b.error;
                      }
                    }
                },
                // Always generate next for scrollable hint
                genNext: function() {
                  var x = this, b = this.$scopedSlots.next ? this.$scopedSlots.next({}) : this.$slots.next || this.__cachedNext;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__next",
                    class: {
                      "v-slide-group__next--disabled": !this.hasNext
                    },
                    on: {
                      click: function() {
                        return x.onAffixClick("next");
                      }
                    },
                    key: "next"
                  }, [b]);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__content",
                    ref: "content",
                    on: {
                      focusin: this.onFocusin
                    }
                  }, this.$slots.default);
                },
                genData: function() {
                  return {
                    class: this.classes,
                    directives: [{
                      name: "resize",
                      value: this.onResize
                    }]
                  };
                },
                genIcon: function(x) {
                  var b = x;
                  this.$vuetify.rtl && x === "prev" ? b = "next" : this.$vuetify.rtl && x === "next" && (b = "prev");
                  var P = "" + x[0].toUpperCase() + x.slice(1), T = this["has" + P];
                  return !this.showArrows && !T ? null : this.$createElement(a.default, {
                    props: {
                      disabled: !T
                    }
                  }, this[b + "Icon"]);
                },
                // Always generate prev for scrollable hint
                genPrev: function() {
                  var x = this, b = this.$scopedSlots.prev ? this.$scopedSlots.prev({}) : this.$slots.prev || this.__cachedPrev;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__prev",
                    class: {
                      "v-slide-group__prev--disabled": !this.hasPrev
                    },
                    on: {
                      click: function() {
                        return x.onAffixClick("prev");
                      }
                    },
                    key: "prev"
                  }, [b]);
                },
                genTransition: function(x) {
                  return this.$createElement(o.VFadeTransition, [this.genIcon(x)]);
                },
                genWrapper: function() {
                  var x = this;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__wrapper",
                    directives: [{
                      name: "touch",
                      value: {
                        start: function(P) {
                          return x.overflowCheck(P, x.onTouchStart);
                        },
                        move: function(P) {
                          return x.overflowCheck(P, x.onTouchMove);
                        },
                        end: function(P) {
                          return x.overflowCheck(P, x.onTouchEnd);
                        }
                      }
                    }],
                    ref: "wrapper",
                    on: {
                      scroll: this.onScroll
                    }
                  }, [this.genContent()]);
                },
                calculateNewOffset: function(x, b, P, T) {
                  var O = P ? -1 : 1, S = O * T + (x === "prev" ? -1 : 1) * b.wrapper;
                  return O * Math.max(Math.min(S, b.content - b.wrapper), 0);
                },
                onAffixClick: function(x) {
                  this.$emit("click:" + x), this.scrollTo(x);
                },
                onResize: function() {
                  this._isDestroyed || this.setWidths();
                },
                onTouchStart: function(x) {
                  var b = this.$refs.content;
                  this.startX = this.scrollOffset + x.touchstartX, b.style.setProperty("transition", "none"), b.style.setProperty("willChange", "transform");
                },
                onTouchMove: function(x) {
                  if (this.canTouch) {
                    if (!this.isSwiping) {
                      var b = x.touchmoveX - x.touchstartX, P = x.touchmoveY - x.touchstartY;
                      this.isSwipingHorizontal = Math.abs(b) > Math.abs(P), this.isSwiping = !0;
                    }
                    this.isSwipingHorizontal && (this.scrollOffset = this.startX - x.touchmoveX, document.documentElement.style.overflowY = "hidden");
                  }
                },
                onTouchEnd: function() {
                  if (this.canTouch) {
                    var x = this.$refs, b = x.content, P = x.wrapper, T = b.clientWidth - P.clientWidth;
                    b.style.setProperty("transition", null), b.style.setProperty("willChange", null), this.$vuetify.rtl ? this.scrollOffset > 0 || !this.isOverflowing ? this.scrollOffset = 0 : this.scrollOffset <= -T && (this.scrollOffset = -T) : this.scrollOffset < 0 || !this.isOverflowing ? this.scrollOffset = 0 : this.scrollOffset >= T && (this.scrollOffset = T), this.isSwiping = !1, document.documentElement.style.removeProperty("overflow-y");
                  }
                },
                overflowCheck: function(x, b) {
                  x.stopPropagation(), this.isOverflowing && b(x);
                },
                scrollIntoView: function() {
                  if (!this.selectedItem && this.items.length) {
                    var x = this.items[this.items.length - 1].$el.getBoundingClientRect(), b = this.$refs.wrapper.getBoundingClientRect();
                    (this.$vuetify.rtl && b.right < x.right || !this.$vuetify.rtl && b.left > x.left) && this.scrollTo("prev");
                  }
                  this.selectedItem && (this.selectedIndex === 0 || !this.centerActive && !this.isOverflowing ? this.scrollOffset = 0 : this.centerActive ? this.scrollOffset = y(this.selectedItem.$el, this.widths, this.$vuetify.rtl) : this.isOverflowing && (this.scrollOffset = v(this.selectedItem.$el, this.widths, this.$vuetify.rtl, this.scrollOffset)));
                },
                scrollTo: function(x) {
                  this.scrollOffset = this.calculateNewOffset(x, {
                    // Force reflow
                    content: this.$refs.content ? this.$refs.content.clientWidth : 0,
                    wrapper: this.$refs.wrapper ? this.$refs.wrapper.clientWidth : 0
                  }, this.$vuetify.rtl, this.scrollOffset);
                },
                setWidths: function() {
                  var x = this;
                  window.requestAnimationFrame(function() {
                    if (!x._isDestroyed) {
                      var b = x.$refs, P = b.content, T = b.wrapper;
                      x.widths = {
                        content: P ? P.clientWidth : 0,
                        wrapper: T ? T.clientWidth : 0
                      }, x.isOverflowing = x.widths.wrapper + 1 < x.widths.content, x.scrollIntoView();
                    }
                  });
                }
              },
              render: function(x) {
                return x("div", this.genData(), [this.genPrev(), this.genWrapper(), this.genNext()]);
              }
            });
            r.default = E.extend({
              name: "v-slide-group",
              provide: function() {
                return {
                  slideGroup: this
                };
              }
            });
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideItem.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideItem.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VItemGroup/VItem */
              "./src/components/VItemGroup/VItem.ts"
            ), o = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              a.BaseItem,
              Object(o.factory)("slideGroup")
              /* @vue/component */
            ).extend({
              name: "v-slide-item"
            });
          }
        ),
        /***/
        "./src/components/VSlideGroup/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VSlideGroup/index.ts ***!
            \*********************************************/
          /*! exports provided: VSlideGroup, VSlideItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            );
            i.d(r, "VSlideGroup", function() {
              return a.default;
            });
            var o = i(
              /*! ./VSlideItem */
              "./src/components/VSlideGroup/VSlideItem.ts"
            );
            i.d(r, "VSlideItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VSlideGroup: a.default,
                VSlideItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VSlider/VSlider.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSlider/VSlider.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSlider/VSlider.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSlider/VSlider.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSlider.sass */
              "./src/components/VSlider/VSlider.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), d = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = Object(l.default)(
              a.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-slider",
              directives: {
                ClickOutside: d.default
              },
              mixins: [f.default],
              props: {
                disabled: Boolean,
                inverseLabel: Boolean,
                max: {
                  type: [Number, String],
                  default: 100
                },
                min: {
                  type: [Number, String],
                  default: 0
                },
                step: {
                  type: [Number, String],
                  default: 1
                },
                thumbColor: String,
                thumbLabel: {
                  type: [Boolean, String],
                  default: void 0,
                  validator: function(g) {
                    return typeof g == "boolean" || g === "always";
                  }
                },
                thumbSize: {
                  type: [Number, String],
                  default: 32
                },
                tickLabels: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                ticks: {
                  type: [Boolean, String],
                  default: !1,
                  validator: function(g) {
                    return typeof g == "boolean" || g === "always";
                  }
                },
                tickSize: {
                  type: [Number, String],
                  default: 2
                },
                trackColor: String,
                trackFillColor: String,
                value: [Number, String],
                vertical: Boolean
              },
              data: function() {
                return {
                  app: null,
                  oldValue: null,
                  thumbPressed: !1,
                  mouseTimeout: -1,
                  isFocused: !1,
                  isActive: !1,
                  noClick: !1,
                  startOffset: 0
                };
              },
              computed: {
                classes: function() {
                  return h(h({}, a.default.options.computed.classes.call(this)), {
                    "v-input__slider": !0,
                    "v-input__slider--vertical": this.vertical,
                    "v-input__slider--inverse-label": this.inverseLabel
                  });
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(g) {
                    g = isNaN(g) ? this.minValue : g;
                    var m = this.roundValue(Math.min(Math.max(g, this.minValue), this.maxValue));
                    m !== this.lazyValue && (this.lazyValue = m, this.$emit("input", m));
                  }
                },
                trackTransition: function() {
                  return this.thumbPressed ? this.showTicks || this.stepNumeric ? "0.1s cubic-bezier(0.25, 0.8, 0.5, 1)" : "none" : "";
                },
                minValue: function() {
                  return parseFloat(this.min);
                },
                maxValue: function() {
                  return parseFloat(this.max);
                },
                stepNumeric: function() {
                  return this.step > 0 ? parseFloat(this.step) : 0;
                },
                inputWidth: function() {
                  var g = (this.roundValue(this.internalValue) - this.minValue) / (this.maxValue - this.minValue) * 100;
                  return isNaN(g) ? 0 : g;
                },
                trackFillStyles: function() {
                  var g, m = this.vertical ? "bottom" : "left", v = this.vertical ? "top" : "right", y = this.vertical ? "height" : "width", E = this.$vuetify.rtl ? "auto" : "0", C = this.$vuetify.rtl ? "0" : "auto", x = this.isDisabled ? "calc(" + this.inputWidth + "% - 10px)" : this.inputWidth + "%";
                  return g = {
                    transition: this.trackTransition
                  }, g[m] = E, g[v] = C, g[y] = x, g;
                },
                trackStyles: function() {
                  var g, m = this.vertical ? this.$vuetify.rtl ? "bottom" : "top" : this.$vuetify.rtl ? "left" : "right", v = this.vertical ? "height" : "width", y = "0px", E = this.isDisabled ? "calc(" + (100 - this.inputWidth) + "% - 10px)" : "calc(" + (100 - this.inputWidth) + "%)";
                  return g = {
                    transition: this.trackTransition
                  }, g[m] = y, g[v] = E, g;
                },
                showTicks: function() {
                  return this.tickLabels.length > 0 || !!(!this.isDisabled && this.stepNumeric && this.ticks);
                },
                numTicks: function() {
                  return Math.ceil((this.maxValue - this.minValue) / this.stepNumeric);
                },
                showThumbLabel: function() {
                  return !this.isDisabled && !!(this.thumbLabel || this.$scopedSlots["thumb-label"]);
                },
                computedTrackColor: function() {
                  if (!this.isDisabled)
                    return this.trackColor ? this.trackColor : this.isDark ? this.validationState : this.validationState || "primary lighten-3";
                },
                computedTrackFillColor: function() {
                  if (!this.isDisabled)
                    return this.trackFillColor ? this.trackFillColor : this.validationState || this.computedColor;
                },
                computedThumbColor: function() {
                  return this.thumbColor ? this.thumbColor : this.validationState || this.computedColor;
                }
              },
              watch: {
                min: function(g) {
                  var m = parseFloat(g);
                  m > this.internalValue && this.$emit("input", m);
                },
                max: function(g) {
                  var m = parseFloat(g);
                  m < this.internalValue && this.$emit("input", m);
                },
                value: {
                  handler: function(g) {
                    this.internalValue = g;
                  },
                  immediate: !0
                }
              },
              mounted: function() {
                this.app = document.querySelector("[data-app]") || Object(c.consoleWarn)("Missing v-app or a non-body wrapping element with the [data-app] attribute", this);
              },
              methods: {
                genDefaultSlot: function() {
                  var g = [this.genLabel()], m = this.genSlider();
                  return this.inverseLabel ? g.unshift(m) : g.push(m), g.push(this.genProgress()), g;
                },
                genSlider: function() {
                  return this.$createElement("div", {
                    class: h({
                      "v-slider": !0,
                      "v-slider--horizontal": !this.vertical,
                      "v-slider--vertical": this.vertical,
                      "v-slider--focused": this.isFocused,
                      "v-slider--active": this.isActive,
                      "v-slider--disabled": this.isDisabled,
                      "v-slider--readonly": this.isReadonly
                    }, this.themeClasses),
                    directives: [{
                      name: "click-outside",
                      value: this.onBlur
                    }],
                    on: {
                      click: this.onSliderClick,
                      mousedown: this.onSliderMouseDown,
                      touchstart: this.onSliderMouseDown
                    }
                  }, this.genChildren());
                },
                genChildren: function() {
                  return [this.genInput(), this.genTrackContainer(), this.genSteps(), this.genThumbContainer(this.internalValue, this.inputWidth, this.isActive, this.isFocused, this.onFocus, this.onBlur)];
                },
                genInput: function() {
                  return this.$createElement("input", {
                    attrs: h({
                      value: this.internalValue,
                      id: this.computedId,
                      disabled: !0,
                      readonly: !0,
                      tabindex: -1
                    }, this.$attrs)
                    // on: this.genListeners(), // TODO: do we need to attach the listeners to input?
                  });
                },
                genTrackContainer: function() {
                  var g = [this.$createElement("div", this.setBackgroundColor(this.computedTrackColor, {
                    staticClass: "v-slider__track-background",
                    style: this.trackStyles
                  })), this.$createElement("div", this.setBackgroundColor(this.computedTrackFillColor, {
                    staticClass: "v-slider__track-fill",
                    style: this.trackFillStyles
                  }))];
                  return this.$createElement("div", {
                    staticClass: "v-slider__track-container",
                    ref: "track"
                  }, g);
                },
                genSteps: function() {
                  var g = this;
                  if (!this.step || !this.showTicks)
                    return null;
                  var m = parseFloat(this.tickSize), v = Object(u.createRange)(this.numTicks + 1), y = this.vertical ? "bottom" : this.$vuetify.rtl ? "right" : "left", E = this.vertical ? this.$vuetify.rtl ? "left" : "right" : "top";
                  this.vertical && v.reverse();
                  var C = v.map(function(x) {
                    var b, P = [];
                    g.tickLabels[x] && P.push(g.$createElement("div", {
                      staticClass: "v-slider__tick-label"
                    }, g.tickLabels[x]));
                    var T = x * (100 / g.numTicks), O = g.$vuetify.rtl ? 100 - g.inputWidth < T : T < g.inputWidth;
                    return g.$createElement("span", {
                      key: x,
                      staticClass: "v-slider__tick",
                      class: {
                        "v-slider__tick--filled": O
                      },
                      style: (b = {
                        width: m + "px",
                        height: m + "px"
                      }, b[y] = "calc(" + T + "% - " + m / 2 + "px)", b[E] = "calc(50% - " + m / 2 + "px)", b)
                    }, P);
                  });
                  return this.$createElement("div", {
                    staticClass: "v-slider__ticks-container",
                    class: {
                      "v-slider__ticks-container--always-show": this.ticks === "always" || this.tickLabels.length > 0
                    }
                  }, C);
                },
                genThumbContainer: function(g, m, v, y, E, C, x) {
                  x === void 0 && (x = "thumb");
                  var b = [this.genThumb()], P = this.genThumbLabelContent(g);
                  return this.showThumbLabel && b.push(this.genThumbLabel(P)), this.$createElement("div", this.setTextColor(this.computedThumbColor, {
                    ref: x,
                    key: x,
                    staticClass: "v-slider__thumb-container",
                    class: {
                      "v-slider__thumb-container--active": v,
                      "v-slider__thumb-container--focused": y,
                      "v-slider__thumb-container--show-label": this.showThumbLabel
                    },
                    style: this.getThumbContainerStyles(m),
                    attrs: {
                      role: "slider",
                      tabindex: this.isDisabled ? -1 : this.$attrs.tabindex ? this.$attrs.tabindex : 0,
                      "aria-label": this.$attrs["aria-label"] || this.label,
                      "aria-valuemin": this.min,
                      "aria-valuemax": this.max,
                      "aria-valuenow": this.internalValue,
                      "aria-readonly": String(this.isReadonly),
                      "aria-orientation": this.vertical ? "vertical" : "horizontal"
                    },
                    on: {
                      focus: E,
                      blur: C,
                      keydown: this.onKeyDown
                    }
                  }), b);
                },
                genThumbLabelContent: function(g) {
                  return this.$scopedSlots["thumb-label"] ? this.$scopedSlots["thumb-label"]({
                    value: g
                  }) : [this.$createElement("span", [String(g)])];
                },
                genThumbLabel: function(g) {
                  var m = Object(u.convertToUnit)(this.thumbSize), v = this.vertical ? "translateY(20%) translateY(" + (Number(this.thumbSize) / 3 - 1) + "px) translateX(55%) rotate(135deg)" : "translateY(-20%) translateY(-12px) translateX(-50%) rotate(45deg)";
                  return this.$createElement(o.VScaleTransition, {
                    props: {
                      origin: "bottom center"
                    }
                  }, [this.$createElement("div", {
                    staticClass: "v-slider__thumb-label-container",
                    directives: [{
                      name: "show",
                      value: this.isFocused || this.isActive || this.thumbLabel === "always"
                    }]
                  }, [this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
                    staticClass: "v-slider__thumb-label",
                    style: {
                      height: m,
                      width: m,
                      transform: v
                    }
                  }), [this.$createElement("div", g)])])]);
                },
                genThumb: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
                    staticClass: "v-slider__thumb"
                  }));
                },
                getThumbContainerStyles: function(g) {
                  var m, v = this.vertical ? "top" : "left", y = this.$vuetify.rtl ? 100 - g : g;
                  return y = this.vertical ? 100 - y : y, m = {
                    transition: this.trackTransition
                  }, m[v] = y + "%", m;
                },
                onSliderMouseDown: function(g) {
                  var m = this, v;
                  if (g.preventDefault(), this.oldValue = this.internalValue, this.isActive = !0, !((v = g.target) === null || v === void 0) && v.matches(".v-slider__thumb-container, .v-slider__thumb-container *")) {
                    this.thumbPressed = !0;
                    var y = g.target.getBoundingClientRect(), E = "touches" in g ? g.touches[0] : g;
                    this.startOffset = this.vertical ? E.clientY - (y.top + y.height / 2) : E.clientX - (y.left + y.width / 2);
                  } else
                    this.startOffset = 0, window.clearTimeout(this.mouseTimeout), this.mouseTimeout = window.setTimeout(function() {
                      m.thumbPressed = !0;
                    }, 300);
                  var C = u.passiveSupported ? {
                    passive: !0,
                    capture: !0
                  } : !0, x = u.passiveSupported ? {
                    passive: !0
                  } : !1, b = "touches" in g;
                  this.onMouseMove(g), this.app.addEventListener(b ? "touchmove" : "mousemove", this.onMouseMove, x), Object(u.addOnceEventListener)(this.app, b ? "touchend" : "mouseup", this.onSliderMouseUp, C), this.$emit("start", this.internalValue);
                },
                onSliderMouseUp: function(g) {
                  g.stopPropagation(), window.clearTimeout(this.mouseTimeout), this.thumbPressed = !1;
                  var m = u.passiveSupported ? {
                    passive: !0
                  } : !1;
                  this.app.removeEventListener("touchmove", this.onMouseMove, m), this.app.removeEventListener("mousemove", this.onMouseMove, m), this.$emit("mouseup", g), this.$emit("end", this.internalValue), Object(u.deepEqual)(this.oldValue, this.internalValue) || (this.$emit("change", this.internalValue), this.noClick = !0), this.isActive = !1;
                },
                onMouseMove: function(g) {
                  g.type === "mousemove" && (this.thumbPressed = !0), this.internalValue = this.parseMouseMove(g);
                },
                onKeyDown: function(g) {
                  if (this.isInteractive) {
                    var m = this.parseKeyDown(g, this.internalValue);
                    m == null || m < this.minValue || m > this.maxValue || (this.internalValue = m, this.$emit("change", m));
                  }
                },
                onSliderClick: function(g) {
                  if (this.noClick) {
                    this.noClick = !1;
                    return;
                  }
                  var m = this.$refs.thumb;
                  m.focus(), this.onMouseMove(g), this.$emit("change", this.internalValue);
                },
                onBlur: function(g) {
                  this.isFocused = !1, this.$emit("blur", g);
                },
                onFocus: function(g) {
                  this.isFocused = !0, this.$emit("focus", g);
                },
                parseMouseMove: function(g) {
                  var m = this.vertical ? "top" : "left", v = this.vertical ? "height" : "width", y = this.vertical ? "clientY" : "clientX", E = this.$refs.track.getBoundingClientRect(), C = m, x = E[C], b = v, P = E[b], T = "touches" in g ? g.touches[0][y] : g[y], O = Math.min(Math.max((T - x - this.startOffset) / P, 0), 1) || 0;
                  return this.vertical && (O = 1 - O), this.$vuetify.rtl && (O = 1 - O), parseFloat(this.min) + O * (this.maxValue - this.minValue);
                },
                parseKeyDown: function(g, m) {
                  if (this.isInteractive) {
                    var v = u.keyCodes.pageup, y = u.keyCodes.pagedown, E = u.keyCodes.end, C = u.keyCodes.home, x = u.keyCodes.left, b = u.keyCodes.right, P = u.keyCodes.down, T = u.keyCodes.up;
                    if ([v, y, E, C, x, b, P, T].includes(g.keyCode)) {
                      g.preventDefault();
                      var O = this.stepNumeric || 1, S = (this.maxValue - this.minValue) / O;
                      if ([x, b, P, T].includes(g.keyCode)) {
                        var L = this.$vuetify.rtl ? [x, T] : [b, T], A = L.includes(g.keyCode) ? 1 : -1, D = g.shiftKey ? 3 : g.ctrlKey ? 2 : 1;
                        m = m + A * O * D;
                      } else if (g.keyCode === C)
                        m = this.minValue;
                      else if (g.keyCode === E)
                        m = this.maxValue;
                      else {
                        var A = g.keyCode === y ? 1 : -1;
                        m = m - A * O * (S > 100 ? S / 10 : 10);
                      }
                      return m;
                    }
                  }
                },
                roundValue: function(g) {
                  if (!this.stepNumeric)
                    return g;
                  var m = this.step.toString().trim(), v = m.indexOf(".") > -1 ? m.length - m.indexOf(".") - 1 : 0, y = this.minValue % this.stepNumeric, E = Math.round((g - y) / this.stepNumeric) * this.stepNumeric + y;
                  return parseFloat(Math.min(E, this.maxValue).toFixed(v));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSlider/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSlider/index.ts ***!
            \*****************************************/
          /*! exports provided: VSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSlider */
              "./src/components/VSlider/VSlider.ts"
            );
            i.d(r, "VSlider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSnackbar/VSnackbar.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VSnackbar/VSnackbar.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSnackbar/VSnackbar.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VSnackbar/VSnackbar.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSnackbar.sass */
              "./src/components/VSnackbar/VSnackbar.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = Object(u.default)(
              a.default,
              o.default,
              f.default,
              Object(d.factory)(["absolute", "bottom", "left", "right", "top"])
              /* @vue/component */
            ).extend({
              name: "v-snackbar",
              props: {
                app: Boolean,
                centered: Boolean,
                contentClass: {
                  type: String,
                  default: ""
                },
                multiLine: Boolean,
                text: Boolean,
                timeout: {
                  type: [Number, String],
                  default: 5e3
                },
                transition: {
                  type: [Boolean, String],
                  default: "v-snack-transition",
                  validator: function(g) {
                    return typeof g == "string" || g === !1;
                  }
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  activeTimeout: -1
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-snack--absolute": this.absolute,
                    "v-snack--active": this.isActive,
                    "v-snack--bottom": this.bottom || !this.top,
                    "v-snack--centered": this.centered,
                    "v-snack--has-background": this.hasBackground,
                    "v-snack--left": this.left,
                    "v-snack--multi-line": this.multiLine && !this.vertical,
                    "v-snack--right": this.right,
                    "v-snack--text": this.text,
                    "v-snack--top": this.top,
                    "v-snack--vertical": this.vertical
                  };
                },
                // Text and outlined styles both
                // use transparent backgrounds
                hasBackground: function() {
                  return !this.text && !this.outlined;
                },
                // Snackbar is dark by default
                // override themeable logic.
                isDark: function() {
                  return this.hasBackground ? !this.light : l.default.options.computed.isDark.call(this);
                },
                styles: function() {
                  if (this.absolute || !this.app)
                    return {};
                  var g = this.$vuetify.application, m = g.bar, v = g.bottom, y = g.footer, E = g.insetFooter, C = g.left, x = g.right, b = g.top;
                  return {
                    paddingBottom: Object(c.convertToUnit)(v + y + E),
                    paddingLeft: Object(c.convertToUnit)(C),
                    paddingRight: Object(c.convertToUnit)(x),
                    paddingTop: Object(c.convertToUnit)(m + b)
                  };
                }
              },
              watch: {
                isActive: "setTimeout",
                timeout: "setTimeout"
              },
              mounted: function() {
                this.isActive && this.setTimeout();
              },
              created: function() {
                this.$attrs.hasOwnProperty("auto-height") && Object(h.removed)("auto-height", this), this.timeout == 0 && Object(h.deprecate)('timeout="0"', "-1", this);
              },
              methods: {
                genActions: function() {
                  return this.$createElement("div", {
                    staticClass: "v-snack__action "
                  }, [Object(c.getSlot)(this, "action", {
                    attrs: {
                      class: "v-snack__btn"
                    }
                  })]);
                },
                genContent: function() {
                  var g;
                  return this.$createElement("div", {
                    staticClass: "v-snack__content",
                    class: (g = {}, g[this.contentClass] = !0, g),
                    attrs: {
                      role: "status",
                      "aria-live": "polite"
                    }
                  }, [Object(c.getSlot)(this)]);
                },
                genWrapper: function() {
                  var g = this, m = this.hasBackground ? this.setBackgroundColor : this.setTextColor, v = m(this.color, {
                    staticClass: "v-snack__wrapper",
                    class: a.default.options.computed.classes.call(this),
                    style: a.default.options.computed.styles.call(this),
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }],
                    on: {
                      pointerenter: function() {
                        return window.clearTimeout(g.activeTimeout);
                      },
                      pointerleave: this.setTimeout
                    }
                  });
                  return this.$createElement("div", v, [this.genContent(), this.genActions()]);
                },
                genTransition: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, [this.genWrapper()]);
                },
                setTimeout: function() {
                  var g = this;
                  window.clearTimeout(this.activeTimeout);
                  var m = Number(this.timeout);
                  !this.isActive || // TODO: remove 0 in v3
                  [0, -1].includes(m) || (this.activeTimeout = window.setTimeout(function() {
                    g.isActive = !1;
                  }, m));
                }
              },
              render: function(g) {
                return g("div", {
                  staticClass: "v-snack",
                  class: this.classes,
                  style: this.styles
                }, [this.transition !== !1 ? this.genTransition() : this.genWrapper()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSnackbar/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSnackbar/index.ts ***!
            \*******************************************/
          /*! exports provided: VSnackbar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSnackbar */
              "./src/components/VSnackbar/VSnackbar.ts"
            );
            i.d(r, "VSnackbar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSparkline/VSparkline.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSparkline/VSparkline.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ./helpers/core */
              "./src/components/VSparkline/helpers/core.ts"
            ), f = i(
              /*! ./helpers/path */
              "./src/components/VSparkline/helpers/path.ts"
            );
            function d(c) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(p) {
                return typeof p;
              } : d = function(p) {
                return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
              }, d(c);
            }
            var u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "VSparkline",
              inheritAttrs: !1,
              props: {
                autoDraw: Boolean,
                autoDrawDuration: {
                  type: Number,
                  default: 2e3
                },
                autoDrawEasing: {
                  type: String,
                  default: "ease"
                },
                autoLineWidth: {
                  type: Boolean,
                  default: !1
                },
                color: {
                  type: String,
                  default: "primary"
                },
                fill: {
                  type: Boolean,
                  default: !1
                },
                gradient: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                gradientDirection: {
                  type: String,
                  validator: function(h) {
                    return ["top", "bottom", "left", "right"].includes(h);
                  },
                  default: "top"
                },
                height: {
                  type: [String, Number],
                  default: 75
                },
                labels: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                labelSize: {
                  type: [Number, String],
                  default: 7
                },
                lineWidth: {
                  type: [String, Number],
                  default: 4
                },
                padding: {
                  type: [String, Number],
                  default: 8
                },
                showLabels: Boolean,
                smooth: {
                  type: [Boolean, Number, String],
                  default: !1
                },
                type: {
                  type: String,
                  default: "trend",
                  validator: function(h) {
                    return ["trend", "bar"].includes(h);
                  }
                },
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  lastLength: 0
                };
              },
              computed: {
                parsedPadding: function() {
                  return Number(this.padding);
                },
                parsedWidth: function() {
                  return Number(this.width);
                },
                parsedHeight: function() {
                  return parseInt(this.height, 10);
                },
                parsedLabelSize: function() {
                  return parseInt(this.labelSize, 10) || 7;
                },
                totalHeight: function() {
                  var h = this.parsedHeight;
                  return this.hasLabels && (h += parseInt(this.labelSize, 10) * 1.5), h;
                },
                totalWidth: function() {
                  var h = this.parsedWidth;
                  return this.type === "bar" && (h = Math.max(this.value.length * this._lineWidth, h)), h;
                },
                totalValues: function() {
                  return this.value.length;
                },
                _lineWidth: function() {
                  if (this.autoLineWidth && this.type !== "trend") {
                    var h = this.parsedPadding * (this.totalValues + 1);
                    return (this.parsedWidth - h) / this.totalValues;
                  } else
                    return parseFloat(this.lineWidth) || 4;
                },
                boundary: function() {
                  if (this.type === "bar")
                    return {
                      minX: 0,
                      maxX: this.totalWidth,
                      minY: 0,
                      maxY: this.parsedHeight
                    };
                  var h = this.parsedPadding;
                  return {
                    minX: h,
                    maxX: this.totalWidth - h,
                    minY: h,
                    maxY: this.parsedHeight - h
                  };
                },
                hasLabels: function() {
                  return !!(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);
                },
                parsedLabels: function() {
                  for (var h = [], p = this._values, g = p.length, m = 0; h.length < g; m++) {
                    var v = p[m], y = this.labels[m];
                    y || (y = d(v) === "object" ? v.value : v), h.push({
                      x: v.x,
                      value: String(y)
                    });
                  }
                  return h;
                },
                normalizedValues: function() {
                  return this.value.map(function(h) {
                    return typeof h == "number" ? h : h.value;
                  });
                },
                _values: function() {
                  return this.type === "trend" ? Object(l.genPoints)(this.normalizedValues, this.boundary) : Object(l.genBars)(this.normalizedValues, this.boundary);
                },
                textY: function() {
                  var h = this.parsedHeight;
                  return this.type === "trend" && (h -= 4), h;
                },
                _radius: function() {
                  return this.smooth === !0 ? 8 : Number(this.smooth);
                }
              },
              watch: {
                value: {
                  immediate: !0,
                  handler: function() {
                    var h = this;
                    this.$nextTick(function() {
                      if (!(!h.autoDraw || h.type === "bar" || !h.$refs.path)) {
                        var p = h.$refs.path, g = p.getTotalLength();
                        h.fill ? (p.style.transformOrigin = "bottom center", p.style.transition = "none", p.style.transform = "scaleY(0)", p.getBoundingClientRect(), p.style.transition = "transform " + h.autoDrawDuration + "ms " + h.autoDrawEasing, p.style.transform = "scaleY(1)") : (p.style.transition = "none", p.style.strokeDasharray = g + " " + g, p.style.strokeDashoffset = Math.abs(g - (h.lastLength || 0)).toString(), p.getBoundingClientRect(), p.style.transition = "stroke-dashoffset " + h.autoDrawDuration + "ms " + h.autoDrawEasing, p.style.strokeDashoffset = "0"), h.lastLength = g;
                      }
                    });
                  }
                }
              },
              methods: {
                genGradient: function() {
                  var h = this, p = this.gradientDirection, g = this.gradient.slice();
                  g.length || g.push("");
                  var m = Math.max(g.length - 1, 1), v = g.reverse().map(function(y, E) {
                    return h.$createElement("stop", {
                      attrs: {
                        offset: E / m,
                        "stop-color": y || "currentColor"
                      }
                    });
                  });
                  return this.$createElement("defs", [this.$createElement("linearGradient", {
                    attrs: {
                      id: this._uid,
                      gradientUnits: "userSpaceOnUse",
                      x1: p === "left" ? "100%" : "0",
                      y1: p === "top" ? "100%" : "0",
                      x2: p === "right" ? "100%" : "0",
                      y2: p === "bottom" ? "100%" : "0"
                    }
                  }, v)]);
                },
                genG: function(h) {
                  return this.$createElement("g", {
                    style: {
                      fontSize: "8",
                      textAnchor: "middle",
                      dominantBaseline: "mathematical",
                      fill: "currentColor"
                    }
                    // TODO: TS 3.5 is too eager with the array type here
                  }, h);
                },
                genPath: function() {
                  var h = Object(l.genPoints)(this.normalizedValues, this.boundary);
                  return this.$createElement("path", {
                    attrs: {
                      d: Object(f.genPath)(h, this._radius, this.fill, this.parsedHeight),
                      fill: this.fill ? "url(#" + this._uid + ")" : "none",
                      stroke: this.fill ? "none" : "url(#" + this._uid + ")"
                    },
                    ref: "path"
                  });
                },
                genLabels: function(h) {
                  var p = this, g = this.parsedLabels.map(function(m, v) {
                    return p.$createElement("text", {
                      attrs: {
                        x: m.x + h + p._lineWidth / 2,
                        y: p.textY + p.parsedLabelSize * 0.75,
                        "font-size": Number(p.labelSize) || 7
                      }
                    }, [p.genLabel(m, v)]);
                  });
                  return this.genG(g);
                },
                genLabel: function(h, p) {
                  return this.$scopedSlots.label ? this.$scopedSlots.label({
                    index: p,
                    value: h.value
                  }) : h.value;
                },
                genBars: function() {
                  if (!(!this.value || this.totalValues < 2)) {
                    var h = Object(l.genBars)(this.normalizedValues, this.boundary), p = (Math.abs(h[0].x - h[1].x) - this._lineWidth) / 2;
                    return this.$createElement("svg", {
                      attrs: {
                        display: "block",
                        viewBox: "0 0 " + this.totalWidth + " " + this.totalHeight
                      }
                    }, [this.genGradient(), this.genClipPath(h, p, this._lineWidth, "sparkline-bar-" + this._uid), this.hasLabels ? this.genLabels(p) : void 0, this.$createElement("g", {
                      attrs: {
                        "clip-path": "url(#sparkline-bar-" + this._uid + "-clip)",
                        fill: "url(#" + this._uid + ")"
                      }
                    }, [this.$createElement("rect", {
                      attrs: {
                        x: 0,
                        y: 0,
                        width: this.totalWidth,
                        height: this.height
                      }
                    })])]);
                  }
                },
                genClipPath: function(h, p, g, m) {
                  var v = this, y = typeof this.smooth == "number" ? this.smooth : this.smooth ? 2 : 0;
                  return this.$createElement("clipPath", {
                    attrs: {
                      id: m + "-clip"
                    }
                  }, h.map(function(E) {
                    return v.$createElement("rect", {
                      attrs: {
                        x: E.x + p,
                        y: E.y,
                        width: g,
                        height: E.height,
                        rx: y,
                        ry: y
                      }
                    }, [v.autoDraw ? v.$createElement("animate", {
                      attrs: {
                        attributeName: "height",
                        from: 0,
                        to: E.height,
                        dur: v.autoDrawDuration + "ms",
                        fill: "freeze"
                      }
                    }) : void 0]);
                  }));
                },
                genTrend: function() {
                  return this.$createElement("svg", this.setTextColor(this.color, {
                    attrs: u(u({}, this.$attrs), {
                      display: "block",
                      "stroke-width": this._lineWidth || 1,
                      viewBox: "0 0 " + this.width + " " + this.totalHeight
                    })
                  }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);
                }
              },
              render: function(h) {
                if (!(this.totalValues < 2))
                  return this.type === "trend" ? this.genTrend() : this.genBars();
              }
            });
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/core.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/core.ts ***!
            \***************************************************/
          /*! exports provided: genPoints, genBars */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "genPoints", function() {
              return l;
            }), i.d(r, "genBars", function() {
              return f;
            });
            var a = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, o = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            function l(d, u) {
              var c = u.minX, h = u.maxX, p = u.minY, g = u.maxY, m = d.length, v = Math.max.apply(Math, o([], a(d), !1)), y = Math.min.apply(Math, o([], a(d), !1)), E = (h - c) / (m - 1), C = (g - p) / (v - y || 1);
              return d.map(function(x, b) {
                return {
                  x: c + b * E,
                  y: g - (x - y) * C,
                  value: x
                };
              });
            }
            function f(d, u) {
              var c = u.minX, h = u.maxX, p = u.minY, g = u.maxY, m = d.length, v = Math.max.apply(Math, o([], a(d), !1)), y = Math.min.apply(Math, o([], a(d), !1));
              y > 0 && (y = 0), v < 0 && (v = 0);
              var E = h / m, C = (g - p) / (v - y || 1), x = g - Math.abs(y * C);
              return d.map(function(b, P) {
                var T = Math.abs(C * b);
                return {
                  x: c + P * E,
                  y: x - T + +(b < 0) * T,
                  height: T,
                  value: b
                };
              });
            }
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/math.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/math.ts ***!
            \***************************************************/
          /*! exports provided: checkCollinear, getDistance, moveTo */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "checkCollinear", function() {
              return o;
            }), i.d(r, "getDistance", function() {
              return l;
            }), i.d(r, "moveTo", function() {
              return f;
            });
            function a(d) {
              return parseInt(d, 10);
            }
            function o(d, u, c) {
              return a(d.x + c.x) === a(2 * u.x) && a(d.y + c.y) === a(2 * u.y);
            }
            function l(d, u) {
              return Math.sqrt(Math.pow(u.x - d.x, 2) + Math.pow(u.y - d.y, 2));
            }
            function f(d, u, c) {
              var h = {
                x: d.x - u.x,
                y: d.y - u.y
              }, p = Math.sqrt(h.x * h.x + h.y * h.y), g = {
                x: h.x / p,
                y: h.y / p
              };
              return {
                x: u.x + g.x * c,
                y: u.y + g.y * c
              };
            }
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/path.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/path.ts ***!
            \***************************************************/
          /*! exports provided: genPath */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "genPath", function() {
              return o;
            });
            var a = i(
              /*! ./math */
              "./src/components/VSparkline/helpers/math.ts"
            );
            function o(l, f, d, u) {
              d === void 0 && (d = !1), u === void 0 && (u = 75);
              var c = l.shift(), h = l[l.length - 1];
              return (d ? "M" + c.x + " " + (u - c.x + 2) + " L" + c.x + " " + c.y : "M" + c.x + " " + c.y) + l.map(function(p, g) {
                var m = l[g + 1], v = l[g - 1] || c, y = m && Object(a.checkCollinear)(m, p, v);
                if (!m || y)
                  return "L" + p.x + " " + p.y;
                var E = Math.min(Object(a.getDistance)(v, p), Object(a.getDistance)(m, p)), C = E / 2 < f, x = C ? E / 2 : f, b = Object(a.moveTo)(v, p, x), P = Object(a.moveTo)(m, p, x);
                return "L" + b.x + " " + b.y + "S" + p.x + " " + p.y + " " + P.x + " " + P.y;
              }).join("") + (d ? "L" + h.x + " " + (u - c.x + 2) + " Z" : "");
            }
          }
        ),
        /***/
        "./src/components/VSparkline/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSparkline/index.ts ***!
            \********************************************/
          /*! exports provided: VSparkline, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSparkline */
              "./src/components/VSparkline/VSparkline.ts"
            );
            i.d(r, "VSparkline", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSpeedDial/VSpeedDial.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSpeedDial/VSpeedDial.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSpeedDial/VSpeedDial.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSpeedDial/VSpeedDial.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSpeedDial.sass */
              "./src/components/VSpeedDial/VSpeedDial.sass"
            );
            var a = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), o = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), l = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), f = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(o.default, a.default, l.default).extend({
              name: "v-speed-dial",
              directives: {
                ClickOutside: f.default
              },
              props: {
                direction: {
                  type: String,
                  default: "top",
                  validator: function(c) {
                    return ["top", "right", "bottom", "left"].includes(c);
                  }
                },
                openOnHover: Boolean,
                transition: {
                  type: String,
                  default: "scale-transition"
                }
              },
              computed: {
                classes: function() {
                  var c;
                  return c = {
                    "v-speed-dial": !0,
                    "v-speed-dial--top": this.top,
                    "v-speed-dial--right": this.right,
                    "v-speed-dial--bottom": this.bottom,
                    "v-speed-dial--left": this.left,
                    "v-speed-dial--absolute": this.absolute,
                    "v-speed-dial--fixed": this.fixed
                  }, c["v-speed-dial--direction-" + this.direction] = !0, c["v-speed-dial--is-active"] = this.isActive, c;
                }
              },
              render: function(c) {
                var h = this, p = [], g = {
                  class: this.classes,
                  directives: [{
                    name: "click-outside",
                    value: function() {
                      return h.isActive = !1;
                    }
                  }],
                  on: {
                    click: function() {
                      return h.isActive = !h.isActive;
                    }
                  }
                };
                if (this.openOnHover && (g.on.mouseenter = function() {
                  return h.isActive = !0;
                }, g.on.mouseleave = function() {
                  return h.isActive = !1;
                }), this.isActive) {
                  var m = 0;
                  p = (this.$slots.default || []).map(function(y, E) {
                    return y.tag && typeof y.componentOptions < "u" && (y.componentOptions.Ctor.options.name === "v-btn" || y.componentOptions.Ctor.options.name === "v-tooltip") ? (m++, c("div", {
                      style: {
                        transitionDelay: m * 0.05 + "s"
                      },
                      key: E
                    }, [y])) : (y.key = E, y);
                  });
                }
                var v = c("transition-group", {
                  class: "v-speed-dial__list",
                  props: {
                    name: this.transition,
                    mode: this.mode,
                    origin: this.origin,
                    tag: "div"
                  }
                }, p);
                return c("div", g, [this.$slots.activator, v]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSpeedDial/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSpeedDial/index.ts ***!
            \********************************************/
          /*! exports provided: VSpeedDial, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSpeedDial */
              "./src/components/VSpeedDial/VSpeedDial.ts"
            );
            i.d(r, "VSpeedDial", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VStepper/VStepper.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VStepper/VStepper.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VStepper/VStepper.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VStepper/VStepper.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VStepper.sass */
              "./src/components/VStepper/VStepper.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(f.default)(a.default, Object(o.provide)("stepper"), l.default);
            r.default = c.extend({
              name: "v-stepper",
              provide: function() {
                return {
                  stepClick: this.stepClick,
                  isVertical: this.vertical
                };
              },
              props: {
                altLabels: Boolean,
                nonLinear: Boolean,
                flat: Boolean,
                vertical: Boolean
              },
              data: function() {
                var p = {
                  isBooted: !1,
                  steps: [],
                  content: [],
                  isReverse: !1
                };
                return p.internalLazyValue = this.value != null ? this.value : (p[0] || {}).step || 1, p;
              },
              computed: {
                classes: function() {
                  return u({
                    "v-stepper--flat": this.flat,
                    "v-stepper--is-booted": this.isBooted,
                    "v-stepper--vertical": this.vertical,
                    "v-stepper--alt-labels": this.altLabels,
                    "v-stepper--non-linear": this.nonLinear
                  }, a.default.options.computed.classes.call(this));
                },
                styles: function() {
                  return u({}, a.default.options.computed.styles.call(this));
                }
              },
              watch: {
                internalValue: function(p, g) {
                  this.isReverse = Number(p) < Number(g), g && (this.isBooted = !0), this.updateView();
                }
              },
              created: function() {
                this.$listeners.input && Object(d.breaking)("@input", "@change", this);
              },
              mounted: function() {
                this.updateView();
              },
              methods: {
                register: function(p) {
                  p.$options.name === "v-stepper-step" ? this.steps.push(p) : p.$options.name === "v-stepper-content" && (p.isVertical = this.vertical, this.content.push(p));
                },
                unregister: function(p) {
                  p.$options.name === "v-stepper-step" ? this.steps = this.steps.filter(function(g) {
                    return g !== p;
                  }) : p.$options.name === "v-stepper-content" && (p.isVertical = this.vertical, this.content = this.content.filter(function(g) {
                    return g !== p;
                  }));
                },
                stepClick: function(p) {
                  var g = this;
                  this.$nextTick(function() {
                    return g.internalValue = p;
                  });
                },
                updateView: function() {
                  for (var p = this.steps.length; --p >= 0; )
                    this.steps[p].toggle(this.internalValue);
                  for (var p = this.content.length; --p >= 0; )
                    this.content[p].toggle(this.internalValue, this.isReverse);
                }
              },
              render: function(p) {
                return p(this.tag, {
                  staticClass: "v-stepper",
                  class: this.classes,
                  style: this.styles
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/VStepperContent.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VStepper/VStepperContent.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = Object(f.default)(Object(o.inject)("stepper", "v-stepper-content", "v-stepper"));
            r.default = d.extend().extend({
              name: "v-stepper-content",
              inject: {
                isVerticalProvided: {
                  from: "isVertical"
                }
              },
              props: {
                step: {
                  type: [Number, String],
                  required: !0
                }
              },
              data: function() {
                return {
                  height: 0,
                  // Must be null to allow
                  // previous comparison
                  isActive: null,
                  isReverse: !1,
                  isVertical: this.isVerticalProvided
                };
              },
              computed: {
                computedTransition: function() {
                  var c = this.$vuetify.rtl ? !this.isReverse : this.isReverse;
                  return c ? a.VTabReverseTransition : a.VTabTransition;
                },
                styles: function() {
                  return this.isVertical ? {
                    height: Object(l.convertToUnit)(this.height)
                  } : {};
                }
              },
              watch: {
                isActive: function(c, h) {
                  if (c && h == null) {
                    this.height = "auto";
                    return;
                  }
                  this.isVertical && (this.isActive ? this.enter() : this.leave());
                }
              },
              mounted: function() {
                this.$refs.wrapper.addEventListener("transitionend", this.onTransition, !1), this.stepper && this.stepper.register(this);
              },
              beforeDestroy: function() {
                this.$refs.wrapper.removeEventListener("transitionend", this.onTransition, !1), this.stepper && this.stepper.unregister(this);
              },
              methods: {
                onTransition: function(c) {
                  !this.isActive || c.propertyName !== "height" || (this.height = "auto");
                },
                enter: function() {
                  var c = this, h = 0;
                  requestAnimationFrame(function() {
                    h = c.$refs.wrapper.scrollHeight;
                  }), this.height = 0, setTimeout(function() {
                    return c.isActive && (c.height = h || "auto");
                  }, 450);
                },
                leave: function() {
                  var c = this;
                  this.height = this.$refs.wrapper.clientHeight, setTimeout(function() {
                    return c.height = 0;
                  }, 10);
                },
                toggle: function(c, h) {
                  this.isActive = c.toString() === this.step.toString(), this.isReverse = h;
                }
              },
              render: function(c) {
                var h = {
                  staticClass: "v-stepper__content"
                }, p = {
                  staticClass: "v-stepper__wrapper",
                  style: this.styles,
                  ref: "wrapper"
                };
                this.isVertical || (h.directives = [{
                  name: "show",
                  value: this.isActive
                }]);
                var g = c("div", p, [this.$slots.default]), m = c("div", h, [g]);
                return c(this.computedTransition, {
                  on: this.$listeners
                }, [m]);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/VStepperStep.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VStepper/VStepperStep.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = Object(d.default)(o.default, Object(l.inject)("stepper", "v-stepper-step", "v-stepper"));
            r.default = c.extend().extend({
              name: "v-stepper-step",
              directives: {
                ripple: f.default
              },
              inject: ["stepClick"],
              props: {
                color: {
                  type: String,
                  default: "primary"
                },
                complete: Boolean,
                completeIcon: {
                  type: String,
                  default: "$complete"
                },
                editable: Boolean,
                editIcon: {
                  type: String,
                  default: "$edit"
                },
                errorIcon: {
                  type: String,
                  default: "$error"
                },
                rules: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                step: [Number, String]
              },
              data: function() {
                return {
                  isActive: !1,
                  isInactive: !0
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-stepper__step--active": this.isActive,
                    "v-stepper__step--editable": this.editable,
                    "v-stepper__step--inactive": this.isInactive,
                    "v-stepper__step--error error--text": this.hasError,
                    "v-stepper__step--complete": this.complete
                  };
                },
                hasError: function() {
                  return this.rules.some(function(p) {
                    return p() !== !0;
                  });
                }
              },
              mounted: function() {
                this.stepper && this.stepper.register(this);
              },
              beforeDestroy: function() {
                this.stepper && this.stepper.unregister(this);
              },
              methods: {
                click: function(p) {
                  p.stopPropagation(), this.$emit("click", p), this.editable && this.stepClick(this.step);
                },
                genIcon: function(p) {
                  return this.$createElement(a.default, p);
                },
                genLabel: function() {
                  return this.$createElement("div", {
                    staticClass: "v-stepper__label"
                  }, this.$slots.default);
                },
                genStep: function() {
                  var p = !this.hasError && (this.complete || this.isActive) ? this.color : !1;
                  return this.$createElement("span", this.setBackgroundColor(p, {
                    staticClass: "v-stepper__step__step"
                  }), this.genStepContent());
                },
                genStepContent: function() {
                  var p = [];
                  return this.hasError ? p.push(this.genIcon(this.errorIcon)) : this.complete ? this.editable ? p.push(this.genIcon(this.editIcon)) : p.push(this.genIcon(this.completeIcon)) : p.push(String(this.step)), p;
                },
                keyboardClick: function(p) {
                  p.keyCode === u.keyCodes.space && this.click(p);
                },
                toggle: function(p) {
                  this.isActive = p.toString() === this.step.toString(), this.isInactive = Number(p) < Number(this.step);
                }
              },
              render: function(p) {
                return p("div", {
                  attrs: {
                    tabindex: this.editable ? 0 : -1
                  },
                  staticClass: "v-stepper__step",
                  class: this.classes,
                  directives: [{
                    name: "ripple",
                    value: this.editable
                  }],
                  on: {
                    click: this.click,
                    keydown: this.keyboardClick
                  }
                }, [this.genStep(), this.genLabel()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VStepper/index.ts ***!
            \******************************************/
          /*! exports provided: VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VStepperHeader", function() {
              return d;
            }), i.d(r, "VStepperItems", function() {
              return u;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VStepper */
              "./src/components/VStepper/VStepper.ts"
            );
            i.d(r, "VStepper", function() {
              return o.default;
            });
            var l = i(
              /*! ./VStepperStep */
              "./src/components/VStepper/VStepperStep.ts"
            );
            i.d(r, "VStepperStep", function() {
              return l.default;
            });
            var f = i(
              /*! ./VStepperContent */
              "./src/components/VStepper/VStepperContent.ts"
            );
            i.d(r, "VStepperContent", function() {
              return f.default;
            });
            var d = Object(a.createSimpleFunctional)("v-stepper__header"), u = Object(a.createSimpleFunctional)("v-stepper__items");
            r.default = {
              $_vuetify_subcomponents: {
                VStepper: o.default,
                VStepperContent: f.default,
                VStepperStep: l.default,
                VStepperHeader: d,
                VStepperItems: u
              }
            };
          }
        ),
        /***/
        "./src/components/VSubheader/VSubheader.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSubheader/VSubheader.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSubheader/VSubheader.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSubheader/VSubheader.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSubheader.sass */
              "./src/components/VSubheader/VSubheader.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-subheader",
              props: {
                inset: Boolean
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-subheader",
                  class: l({
                    "v-subheader--inset": this.inset
                  }, this.themeClasses),
                  attrs: this.$attrs,
                  on: this.$listeners
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VSubheader/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSubheader/index.ts ***!
            \********************************************/
          /*! exports provided: VSubheader, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSubheader */
              "./src/components/VSubheader/VSubheader.ts"
            );
            i.d(r, "VSubheader", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSwitch/VSwitch.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSwitch/VSwitch.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSwitch/VSwitch.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSwitch/VSwitch.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            ), i(
              /*! ./VSwitch.sass */
              "./src/components/VSwitch/VSwitch.sass"
            );
            var a = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), o = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), l = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), f = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), d = i(
              /*! ../VProgressCircular/VProgressCircular */
              "./src/components/VProgressCircular/VProgressCircular.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, c.apply(this, arguments);
            }, h = function(p, g) {
              var m = {};
              for (var v in p)
                Object.prototype.hasOwnProperty.call(p, v) && g.indexOf(v) < 0 && (m[v] = p[v]);
              if (p != null && typeof Object.getOwnPropertySymbols == "function")
                for (var y = 0, v = Object.getOwnPropertySymbols(p); y < v.length; y++)
                  g.indexOf(v[y]) < 0 && Object.prototype.propertyIsEnumerable.call(p, v[y]) && (m[v[y]] = p[v[y]]);
              return m;
            };
            r.default = a.default.extend({
              name: "v-switch",
              directives: {
                Touch: l.default
              },
              props: {
                inset: Boolean,
                loading: {
                  type: [Boolean, String],
                  default: !1
                },
                flat: {
                  type: Boolean,
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  return c(c({}, o.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls v-input--switch": !0,
                    "v-input--switch--flat": this.flat,
                    "v-input--switch--inset": this.inset
                  });
                },
                attrs: function() {
                  return {
                    "aria-checked": String(this.isActive),
                    "aria-disabled": String(this.isDisabled),
                    role: "switch"
                  };
                },
                // Do not return undefined if disabled,
                // according to spec, should still show
                // a color when disabled and active
                validationState: function() {
                  if (this.hasError && this.shouldValidate)
                    return "error";
                  if (this.hasSuccess)
                    return "success";
                  if (this.hasColor !== null)
                    return this.computedColor;
                },
                switchData: function() {
                  return this.setTextColor(this.loading ? void 0 : this.validationState, {
                    class: this.themeClasses
                  });
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return [this.genSwitch(), this.genLabel()];
                },
                genSwitch: function() {
                  var g = this.attrs$;
                  g.title;
                  var m = h(g, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.genInput("checkbox", c(c({}, this.attrs), m)), this.genRipple(this.setTextColor(this.validationState, {
                    directives: [{
                      name: "touch",
                      value: {
                        left: this.onSwipeLeft,
                        right: this.onSwipeRight
                      }
                    }]
                  })), this.$createElement("div", c({
                    staticClass: "v-input--switch__track"
                  }, this.switchData)), this.$createElement("div", c({
                    staticClass: "v-input--switch__thumb"
                  }, this.switchData), [this.genProgress()])]);
                },
                genProgress: function() {
                  return this.$createElement(f.VFabTransition, {}, [this.loading === !1 ? null : this.$slots.progress || this.$createElement(d.default, {
                    props: {
                      color: this.loading === !0 || this.loading === "" ? this.color || "primary" : this.loading,
                      size: 16,
                      width: 2,
                      indeterminate: !0
                    }
                  })]);
                },
                onSwipeLeft: function() {
                  this.isActive && this.onChange();
                },
                onSwipeRight: function() {
                  this.isActive || this.onChange();
                },
                onKeydown: function(g) {
                  (g.keyCode === u.keyCodes.left && this.isActive || g.keyCode === u.keyCodes.right && !this.isActive) && this.onChange();
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSwitch/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSwitch/index.ts ***!
            \*****************************************/
          /*! exports provided: VSwitch, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSwitch */
              "./src/components/VSwitch/VSwitch.ts"
            );
            i.d(r, "VSwitch", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSystemBar/VSystemBar.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSystemBar/VSystemBar.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSystemBar/VSystemBar.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSystemBar/VSystemBar.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSystemBar.sass */
              "./src/components/VSystemBar/VSystemBar.sass"
            );
            var a = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(
              Object(a.default)("bar", ["height", "window"]),
              o.default,
              l.default
              /* @vue/component */
            ).extend({
              name: "v-system-bar",
              props: {
                height: [Number, String],
                lightsOut: Boolean,
                window: Boolean
              },
              computed: {
                classes: function() {
                  return u({
                    "v-system-bar--lights-out": this.lightsOut,
                    "v-system-bar--absolute": this.absolute,
                    "v-system-bar--fixed": !this.absolute && (this.app || this.fixed),
                    "v-system-bar--window": this.window
                  }, this.themeClasses);
                },
                computedHeight: function() {
                  return this.height ? isNaN(parseInt(this.height)) ? this.height : parseInt(this.height) : this.window ? 32 : 24;
                },
                styles: function() {
                  return {
                    height: Object(d.convertToUnit)(this.computedHeight)
                  };
                }
              },
              methods: {
                updateApplication: function() {
                  return this.$el ? this.$el.clientHeight : this.computedHeight;
                }
              },
              render: function(h) {
                var p = {
                  staticClass: "v-system-bar",
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                };
                return h("div", this.setBackgroundColor(this.color, p), Object(d.getSlot)(this));
              }
            });
          }
        ),
        /***/
        "./src/components/VSystemBar/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSystemBar/index.ts ***!
            \********************************************/
          /*! exports provided: VSystemBar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSystemBar */
              "./src/components/VSystemBar/VSystemBar.ts"
            );
            i.d(r, "VSystemBar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTabs/VTab.ts": (
          /*!**************************************!*\
            !*** ./src/components/VTabs/VTab.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ./../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(d.default)(
              o.default,
              // Must be after routable
              // to overwrite activeClass
              Object(a.factory)("tabsBar"),
              l.default
            );
            r.default = c.extend().extend().extend({
              name: "v-tab",
              props: {
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                },
                tabValue: {
                  required: !1
                }
              },
              data: function() {
                return {
                  proxyClass: "v-tab--active"
                };
              },
              computed: {
                classes: function() {
                  return u(u(u({
                    "v-tab": !0
                  }, o.default.options.computed.classes.call(this)), {
                    "v-tab--disabled": this.disabled
                  }), this.groupClasses);
                },
                value: function() {
                  if (this.tabValue != null)
                    return this.tabValue;
                  var p = this.to || this.href;
                  if (p == null)
                    return p;
                  if (this.$router && this.to === Object(this.to)) {
                    var g = this.$router.resolve(this.to, this.$route, this.append);
                    p = g.href;
                  }
                  return p.replace("#", "");
                }
              },
              methods: {
                click: function(p) {
                  if (this.disabled) {
                    p.preventDefault();
                    return;
                  }
                  this.href && this.href.indexOf("#") > -1 && p.preventDefault(), p.detail && this.$el.blur(), this.$emit("click", p), this.to || this.toggle();
                },
                toggle: function() {
                  (!this.isActive || !this.tabsBar.mandatory && !this.to) && this.$emit("change");
                }
              },
              render: function(p) {
                var g = this, m = this.generateRouteLink(), v = m.tag, y = m.data;
                return y.attrs = u(u({}, y.attrs), {
                  "aria-selected": String(this.isActive),
                  role: "tab",
                  tabindex: this.disabled ? -1 : 0
                }), y.on = u(u({}, y.on), {
                  keydown: function(C) {
                    C.keyCode === f.keyCodes.enter && g.click(C), g.$emit("keydown", C);
                  }
                }), p(v, y, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabItem.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTabs/VTabItem.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            );
            r.default = a.default.extend({
              name: "v-tab-item",
              props: {
                id: String
              },
              methods: {
                genWindowItem: function() {
                  var l = a.default.options.methods.genWindowItem.call(this);
                  return l.data.domProps = l.data.domProps || {}, l.data.domProps.id = this.id || this.value, l;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabs.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VTabs/VTabs.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTabs/VTabs.ts": (
          /*!***************************************!*\
            !*** ./src/components/VTabs/VTabs.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTabs.sass */
              "./src/components/VTabs/VTabs.sass"
            );
            var a = i(
              /*! ./VTabsBar */
              "./src/components/VTabs/VTabsBar.ts"
            ), o = i(
              /*! ./VTabsItems */
              "./src/components/VTabs/VTabsItems.ts"
            ), l = i(
              /*! ./VTabsSlider */
              "./src/components/VTabs/VTabsSlider.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, g.apply(this, arguments);
            }, m = Object(p.default)(f.default, d.default, u.default);
            r.default = m.extend().extend({
              name: "v-tabs",
              directives: {
                Resize: c.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: ""
                },
                alignWithTitle: Boolean,
                backgroundColor: String,
                centerActive: Boolean,
                centered: Boolean,
                fixedTabs: Boolean,
                grow: Boolean,
                height: {
                  type: [Number, String],
                  default: void 0
                },
                hideSlider: Boolean,
                iconsAndText: Boolean,
                mobileBreakpoint: [String, Number],
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                optional: Boolean,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                right: Boolean,
                showArrows: [Boolean, String],
                sliderColor: String,
                sliderSize: {
                  type: [Number, String],
                  default: 2
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  resizeTimeout: 0,
                  slider: {
                    height: null,
                    left: null,
                    right: null,
                    top: null,
                    width: null
                  },
                  transitionTime: 300
                };
              },
              computed: {
                classes: function() {
                  return g({
                    "v-tabs--align-with-title": this.alignWithTitle,
                    "v-tabs--centered": this.centered,
                    "v-tabs--fixed-tabs": this.fixedTabs,
                    "v-tabs--grow": this.grow,
                    "v-tabs--icons-and-text": this.iconsAndText,
                    "v-tabs--right": this.right,
                    "v-tabs--vertical": this.vertical
                  }, this.themeClasses);
                },
                isReversed: function() {
                  return this.$vuetify.rtl && this.vertical;
                },
                sliderStyles: function() {
                  return {
                    height: Object(h.convertToUnit)(this.slider.height),
                    left: this.isReversed ? void 0 : Object(h.convertToUnit)(this.slider.left),
                    right: this.isReversed ? Object(h.convertToUnit)(this.slider.right) : void 0,
                    top: this.vertical ? Object(h.convertToUnit)(this.slider.top) : void 0,
                    transition: this.slider.left != null ? null : "none",
                    width: Object(h.convertToUnit)(this.slider.width)
                  };
                },
                computedColor: function() {
                  return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                }
              },
              watch: {
                alignWithTitle: "callSlider",
                centered: "callSlider",
                centerActive: "callSlider",
                fixedTabs: "callSlider",
                grow: "callSlider",
                iconsAndText: "callSlider",
                right: "callSlider",
                showArrows: "callSlider",
                vertical: "callSlider",
                "$vuetify.application.left": "onResize",
                "$vuetify.application.right": "onResize",
                "$vuetify.rtl": "onResize"
              },
              mounted: function() {
                var y = this;
                if (typeof ResizeObserver < "u") {
                  var E = new ResizeObserver(function() {
                    y.onResize();
                  });
                  E.observe(this.$el), this.$on("hook:destroyed", function() {
                    E.disconnect();
                  });
                }
                this.$nextTick(function() {
                  window.setTimeout(y.callSlider, 30);
                });
              },
              methods: {
                callSlider: function() {
                  var y = this;
                  return this.hideSlider || !this.$refs.items || !this.$refs.items.selectedItems.length ? (this.slider.width = 0, !1) : (this.$nextTick(function() {
                    var E = y.$refs.items.selectedItems[0];
                    if (!E || !E.$el) {
                      y.slider.width = 0, y.slider.left = 0;
                      return;
                    }
                    var C = E.$el;
                    y.slider = {
                      height: y.vertical ? C.scrollHeight : Number(y.sliderSize),
                      left: y.vertical ? 0 : C.offsetLeft,
                      right: y.vertical ? 0 : C.offsetLeft + C.offsetWidth,
                      top: C.offsetTop,
                      width: y.vertical ? Number(y.sliderSize) : C.scrollWidth
                    };
                  }), !0);
                },
                genBar: function(y, E) {
                  var C = this, x = {
                    style: {
                      height: Object(h.convertToUnit)(this.height)
                    },
                    props: {
                      activeClass: this.activeClass,
                      centerActive: this.centerActive,
                      dark: this.dark,
                      light: this.light,
                      mandatory: !this.optional,
                      mobileBreakpoint: this.mobileBreakpoint,
                      nextIcon: this.nextIcon,
                      prevIcon: this.prevIcon,
                      showArrows: this.showArrows,
                      value: this.internalValue
                    },
                    on: {
                      "call:slider": this.callSlider,
                      change: function(P) {
                        C.internalValue = P;
                      }
                    },
                    ref: "items"
                  };
                  return this.setTextColor(this.computedColor, x), this.setBackgroundColor(this.backgroundColor, x), this.$createElement(a.default, x, [this.genSlider(E), y]);
                },
                genItems: function(y, E) {
                  var C = this;
                  return y || (E.length ? this.$createElement(o.default, {
                    props: {
                      value: this.internalValue
                    },
                    on: {
                      change: function(b) {
                        C.internalValue = b;
                      }
                    }
                  }, E) : null);
                },
                genSlider: function(y) {
                  return this.hideSlider ? null : (y || (y = this.$createElement(l.default, {
                    props: {
                      color: this.sliderColor
                    }
                  })), this.$createElement("div", {
                    staticClass: "v-tabs-slider-wrapper",
                    style: this.sliderStyles
                  }, [y]));
                },
                onResize: function() {
                  this._isDestroyed || (clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.callSlider, 0));
                },
                parseNodes: function() {
                  for (var y = null, E = null, C = [], x = [], b = this.$slots.default || [], P = b.length, T = 0; T < P; T++) {
                    var O = b[T];
                    if (O.componentOptions)
                      switch (O.componentOptions.Ctor.options.name) {
                        case "v-tabs-slider":
                          E = O;
                          break;
                        case "v-tabs-items":
                          y = O;
                          break;
                        case "v-tab-item":
                          C.push(O);
                          break;
                        default:
                          x.push(O);
                      }
                    else
                      x.push(O);
                  }
                  return {
                    tab: x,
                    slider: E,
                    items: y,
                    item: C
                  };
                }
              },
              render: function(y) {
                var E = this.parseNodes(), C = E.tab, x = E.slider, b = E.items, P = E.item;
                return y("div", {
                  staticClass: "v-tabs",
                  class: this.classes,
                  directives: [{
                    name: "resize",
                    modifiers: {
                      quiet: !0
                    },
                    value: this.onResize
                  }]
                }, [this.genBar(C, x), this.genItems(b, P)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsBar.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTabs/VTabsBar.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VSlideGroup/VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c) {
              var h = typeof Symbol == "function" && Symbol.iterator, p = h && c[h], g = 0;
              if (p)
                return p.call(c);
              if (c && typeof c.length == "number")
                return {
                  next: function() {
                    return c && g >= c.length && (c = void 0), {
                      value: c && c[g++],
                      done: !c
                    };
                  }
                };
              throw new TypeError(h ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = Object(f.default)(
              a.BaseSlideGroup,
              l.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-tabs-bar",
              provide: function() {
                return {
                  tabsBar: this
                };
              },
              computed: {
                classes: function() {
                  return d(d(d({}, a.BaseSlideGroup.options.computed.classes.call(this)), {
                    "v-tabs-bar": !0,
                    "v-tabs-bar--is-mobile": this.isMobile,
                    // TODO: Remove this and move to v-slide-group
                    "v-tabs-bar--show-arrows": this.showArrows
                  }), this.themeClasses);
                }
              },
              watch: {
                items: "callSlider",
                internalValue: "callSlider",
                $route: "onRouteChange"
              },
              methods: {
                callSlider: function() {
                  this.isBooted && this.$emit("call:slider");
                },
                genContent: function() {
                  var h = a.BaseSlideGroup.options.methods.genContent.call(this);
                  return h.data = h.data || {}, h.data.staticClass += " v-tabs-bar__content", h;
                },
                onRouteChange: function(h, p) {
                  var g, m;
                  if (!this.mandatory) {
                    var v = this.items, y = h.path, E = p.path, C = !1, x = !1;
                    try {
                      for (var b = u(v), P = b.next(); !P.done; P = b.next()) {
                        var T = P.value;
                        if (T.to === E ? x = !0 : T.to === y && (C = !0), C && x)
                          break;
                      }
                    } catch (O) {
                      g = {
                        error: O
                      };
                    } finally {
                      try {
                        P && !P.done && (m = b.return) && m.call(b);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                    !C && x && (this.internalValue = void 0);
                  }
                }
              },
              render: function(h) {
                var p = a.BaseSlideGroup.options.render.call(this, h);
                return p.data.attrs = {
                  role: "tablist"
                }, p;
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsItems.ts": (
          /*!********************************************!*\
            !*** ./src/components/VTabs/VTabsItems.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindow */
              "./src/components/VWindow/VWindow.ts"
            ), o = i(
              /*! ./../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-tabs-items",
              props: {
                mandatory: {
                  type: Boolean,
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  return l(l({}, a.default.options.computed.classes.call(this)), {
                    "v-tabs-items": !0
                  });
                },
                isDark: function() {
                  return this.rootIsDark;
                }
              },
              methods: {
                getValue: function(d, u) {
                  return d.id || o.BaseItemGroup.options.methods.getValue.call(this, d, u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsSlider.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTabs/VTabsSlider.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              name: "v-tabs-slider",
              render: function(f) {
                return f("div", this.setBackgroundColor(this.color, {
                  staticClass: "v-tabs-slider"
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VTabs/index.ts ***!
            \***************************************/
          /*! exports provided: VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTabs */
              "./src/components/VTabs/VTabs.ts"
            );
            i.d(r, "VTabs", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTab */
              "./src/components/VTabs/VTab.ts"
            );
            i.d(r, "VTab", function() {
              return o.default;
            });
            var l = i(
              /*! ./VTabsItems */
              "./src/components/VTabs/VTabsItems.ts"
            );
            i.d(r, "VTabsItems", function() {
              return l.default;
            });
            var f = i(
              /*! ./VTabItem */
              "./src/components/VTabs/VTabItem.ts"
            );
            i.d(r, "VTabItem", function() {
              return f.default;
            });
            var d = i(
              /*! ./VTabsSlider */
              "./src/components/VTabs/VTabsSlider.ts"
            );
            i.d(r, "VTabsSlider", function() {
              return d.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTabs: a.default,
                VTab: o.default,
                VTabsItems: l.default,
                VTabItem: f.default,
                VTabsSlider: d.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTextField/VTextField.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VTextField/VTextField.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTextField/VTextField.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VTextField/VTextField.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VCounter */
              "./src/components/VCounter/index.ts"
            ), l = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), f = i(
              /*! ../../mixins/intersectable */
              "./src/mixins/intersectable/index.ts"
            ), d = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), u = i(
              /*! ../../mixins/validatable */
              "./src/mixins/validatable/index.ts"
            ), c = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), p = i(
              /*! ../../util/dom */
              "./src/util/dom.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), v = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), y = function() {
              return y = Object.assign || function(T) {
                for (var O, S = 1, L = arguments.length; S < L; S++) {
                  O = arguments[S];
                  for (var A in O)
                    Object.prototype.hasOwnProperty.call(O, A) && (T[A] = O[A]);
                }
                return T;
              }, y.apply(this, arguments);
            }, E = function(T, O) {
              var S = {};
              for (var L in T)
                Object.prototype.hasOwnProperty.call(T, L) && O.indexOf(L) < 0 && (S[L] = T[L]);
              if (T != null && typeof Object.getOwnPropertySymbols == "function")
                for (var A = 0, L = Object.getOwnPropertySymbols(T); A < L.length; A++)
                  O.indexOf(L[A]) < 0 && Object.prototype.propertyIsEnumerable.call(T, L[A]) && (S[L[A]] = T[L[A]]);
              return S;
            }, C = function(T, O) {
              var S = typeof Symbol == "function" && T[Symbol.iterator];
              if (!S)
                return T;
              var L = S.call(T), A, D = [], _;
              try {
                for (; (O === void 0 || O-- > 0) && !(A = L.next()).done; )
                  D.push(A.value);
              } catch (w) {
                _ = {
                  error: w
                };
              } finally {
                try {
                  A && !A.done && (S = L.return) && S.call(L);
                } finally {
                  if (_)
                    throw _.error;
                }
              }
              return D;
            }, x = function(T, O, S) {
              if (S || arguments.length === 2)
                for (var L = 0, A = O.length, D; L < A; L++)
                  (D || !(L in O)) && (D || (D = Array.prototype.slice.call(O, 0, L)), D[L] = O[L]);
              return T.concat(D || Array.prototype.slice.call(O));
            }, b = Object(v.default)(a.default, Object(f.default)({
              onVisible: ["onResize", "tryAutofocus"]
            }), d.default), P = ["color", "file", "time", "date", "datetime-local", "week", "month"];
            r.default = b.extend().extend({
              name: "v-text-field",
              directives: {
                resize: c.default,
                ripple: h.default
              },
              inheritAttrs: !1,
              props: {
                appendOuterIcon: String,
                autofocus: Boolean,
                clearable: Boolean,
                clearIcon: {
                  type: String,
                  default: "$clear"
                },
                counter: [Boolean, Number, String],
                counterValue: Function,
                filled: Boolean,
                flat: Boolean,
                fullWidth: Boolean,
                label: String,
                outlined: Boolean,
                placeholder: String,
                prefix: String,
                prependInnerIcon: String,
                persistentPlaceholder: Boolean,
                reverse: Boolean,
                rounded: Boolean,
                shaped: Boolean,
                singleLine: Boolean,
                solo: Boolean,
                soloInverted: Boolean,
                suffix: String,
                type: {
                  type: String,
                  default: "text"
                }
              },
              data: function() {
                return {
                  badInput: !1,
                  labelWidth: 0,
                  prefixWidth: 0,
                  prependWidth: 0,
                  initialValue: null,
                  isBooted: !1,
                  isClearing: !1
                };
              },
              computed: {
                classes: function() {
                  return y(y({}, a.default.options.computed.classes.call(this)), {
                    "v-text-field": !0,
                    "v-text-field--full-width": this.fullWidth,
                    "v-text-field--prefix": this.prefix,
                    "v-text-field--single-line": this.isSingle,
                    "v-text-field--solo": this.isSolo,
                    "v-text-field--solo-inverted": this.soloInverted,
                    "v-text-field--solo-flat": this.flat,
                    "v-text-field--filled": this.filled,
                    "v-text-field--is-booted": this.isBooted,
                    "v-text-field--enclosed": this.isEnclosed,
                    "v-text-field--reverse": this.reverse,
                    "v-text-field--outlined": this.outlined,
                    "v-text-field--placeholder": this.placeholder,
                    "v-text-field--rounded": this.rounded,
                    "v-text-field--shaped": this.shaped
                  });
                },
                computedColor: function() {
                  var O = u.default.options.computed.computedColor.call(this);
                  return !this.soloInverted || !this.isFocused ? O : this.color || "primary";
                },
                computedCounterValue: function() {
                  return typeof this.counterValue == "function" ? this.counterValue(this.internalValue) : x([], C((this.internalValue || "").toString()), !1).length;
                },
                hasCounter: function() {
                  return this.counter !== !1 && this.counter != null;
                },
                hasDetails: function() {
                  return a.default.options.computed.hasDetails.call(this) || this.hasCounter;
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(O) {
                    this.lazyValue = O, this.$emit("input", this.lazyValue);
                  }
                },
                isDirty: function() {
                  var O;
                  return ((O = this.lazyValue) === null || O === void 0 ? void 0 : O.toString().length) > 0 || this.badInput;
                },
                isEnclosed: function() {
                  return this.filled || this.isSolo || this.outlined;
                },
                isLabelActive: function() {
                  return this.isDirty || P.includes(this.type);
                },
                isSingle: function() {
                  return this.isSolo || this.singleLine || this.fullWidth || // https://material.io/components/text-fields/#filled-text-field
                  this.filled && !this.hasLabel;
                },
                isSolo: function() {
                  return this.solo || this.soloInverted;
                },
                labelPosition: function() {
                  var O = this.prefix && !this.labelValue ? this.prefixWidth : 0;
                  return this.labelValue && this.prependWidth && (O -= this.prependWidth), this.$vuetify.rtl === this.reverse ? {
                    left: O,
                    right: "auto"
                  } : {
                    left: "auto",
                    right: O
                  };
                },
                showLabel: function() {
                  return this.hasLabel && !(this.isSingle && this.labelValue);
                },
                labelValue: function() {
                  return this.isFocused || this.isLabelActive || this.persistentPlaceholder;
                }
              },
              watch: {
                // labelValue: 'setLabelWidth', // moved to mounted, see #11533
                outlined: "setLabelWidth",
                label: function() {
                  this.$nextTick(this.setLabelWidth);
                },
                prefix: function() {
                  this.$nextTick(this.setPrefixWidth);
                },
                isFocused: "updateValue",
                value: function(O) {
                  this.lazyValue = O;
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("box") && Object(m.breaking)("box", "filled", this), this.$attrs.hasOwnProperty("browser-autocomplete") && Object(m.breaking)("browser-autocomplete", "autocomplete", this), this.shaped && !(this.filled || this.outlined || this.isSolo) && Object(m.consoleWarn)("shaped should be used with either filled or outlined", this);
              },
              mounted: function() {
                var O = this;
                this.$watch(function() {
                  return O.labelValue;
                }, this.setLabelWidth), this.autofocus && this.tryAutofocus(), requestAnimationFrame(function() {
                  O.isBooted = !0, requestAnimationFrame(function() {
                    O.isIntersecting || O.onResize();
                  });
                });
              },
              methods: {
                /** @public */
                focus: function() {
                  this.onFocus();
                },
                /** @public */
                blur: function(O) {
                  var S = this;
                  window.requestAnimationFrame(function() {
                    S.$refs.input && S.$refs.input.blur();
                  });
                },
                clearableCallback: function() {
                  var O = this;
                  this.$refs.input && this.$refs.input.focus(), this.$nextTick(function() {
                    return O.internalValue = null;
                  });
                },
                genAppendSlot: function() {
                  var O = [];
                  return this.$slots["append-outer"] ? O.push(this.$slots["append-outer"]) : this.appendOuterIcon && O.push(this.genIcon("appendOuter")), this.genSlot("append", "outer", O);
                },
                genPrependInnerSlot: function() {
                  var O = [];
                  return this.$slots["prepend-inner"] ? O.push(this.$slots["prepend-inner"]) : this.prependInnerIcon && O.push(this.genIcon("prependInner")), this.genSlot("prepend", "inner", O);
                },
                genIconSlot: function() {
                  var O = [];
                  return this.$slots.append ? O.push(this.$slots.append) : this.appendIcon && O.push(this.genIcon("append")), this.genSlot("append", "inner", O);
                },
                genInputSlot: function() {
                  var O = a.default.options.methods.genInputSlot.call(this), S = this.genPrependInnerSlot();
                  return S && (O.children = O.children || [], O.children.unshift(S)), O;
                },
                genClearIcon: function() {
                  return this.clearable ? this.isDirty ? this.genSlot("append", "inner", [this.genIcon("clear", this.clearableCallback)]) : this.genSlot("append", "inner", [this.$createElement("div")]) : null;
                },
                genCounter: function() {
                  var O, S, L;
                  if (!this.hasCounter)
                    return null;
                  var A = this.counter === !0 ? this.attrs$.maxlength : this.counter, D = {
                    dark: this.dark,
                    light: this.light,
                    max: A,
                    value: this.computedCounterValue
                  };
                  return (L = (S = (O = this.$scopedSlots).counter) === null || S === void 0 ? void 0 : S.call(O, {
                    props: D
                  })) !== null && L !== void 0 ? L : this.$createElement(o.default, {
                    props: D
                  });
                },
                genControl: function() {
                  return a.default.options.methods.genControl.call(this);
                },
                genDefaultSlot: function() {
                  return [this.genFieldset(), this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot(), this.genProgress()];
                },
                genFieldset: function() {
                  return this.outlined ? this.$createElement("fieldset", {
                    attrs: {
                      "aria-hidden": !0
                    }
                  }, [this.genLegend()]) : null;
                },
                genLabel: function() {
                  if (!this.showLabel)
                    return null;
                  var O = {
                    props: {
                      absolute: !0,
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      focused: !this.isSingle && (this.isFocused || !!this.validationState),
                      for: this.computedId,
                      left: this.labelPosition.left,
                      light: this.light,
                      right: this.labelPosition.right,
                      value: this.labelValue
                    }
                  };
                  return this.$createElement(l.default, O, this.$slots.label || this.label);
                },
                genLegend: function() {
                  var O = !this.singleLine && (this.labelValue || this.isDirty) ? this.labelWidth : 0, S = this.$createElement("span", {
                    domProps: {
                      innerHTML: "&#8203;"
                    },
                    staticClass: "notranslate"
                  });
                  return this.$createElement("legend", {
                    style: {
                      width: this.isSingle ? void 0 : Object(g.convertToUnit)(O)
                    }
                  }, [S]);
                },
                genInput: function() {
                  var O = Object.assign({}, this.listeners$);
                  delete O.change;
                  var S = this.attrs$;
                  S.title;
                  var L = E(S, ["title"]);
                  return this.$createElement("input", {
                    style: {},
                    domProps: {
                      value: this.type === "number" && Object.is(this.lazyValue, -0) ? "-0" : this.lazyValue
                    },
                    attrs: y(y({}, L), {
                      autofocus: this.autofocus,
                      disabled: this.isDisabled,
                      id: this.computedId,
                      placeholder: this.persistentPlaceholder || this.isFocused || !this.hasLabel ? this.placeholder : void 0,
                      readonly: this.isReadonly,
                      type: this.type
                    }),
                    on: Object.assign(O, {
                      blur: this.onBlur,
                      input: this.onInput,
                      focus: this.onFocus,
                      keydown: this.onKeyDown
                    }),
                    ref: "input",
                    directives: [{
                      name: "resize",
                      modifiers: {
                        quiet: !0
                      },
                      value: this.onResize
                    }]
                  });
                },
                genMessages: function() {
                  if (!this.showDetails)
                    return null;
                  var O = a.default.options.methods.genMessages.call(this), S = this.genCounter();
                  return this.$createElement("div", {
                    staticClass: "v-text-field__details"
                  }, [O, S]);
                },
                genTextFieldSlot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-text-field__slot"
                  }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, this.genInput(), this.suffix ? this.genAffix("suffix") : null]);
                },
                genAffix: function(O) {
                  return this.$createElement("div", {
                    class: "v-text-field__" + O,
                    ref: O
                  }, this[O]);
                },
                onBlur: function(O) {
                  var S = this;
                  this.isFocused = !1, O && this.$nextTick(function() {
                    return S.$emit("blur", O);
                  });
                },
                onClick: function() {
                  this.isFocused || this.isDisabled || !this.$refs.input || this.$refs.input.focus();
                },
                onFocus: function(O) {
                  if (this.$refs.input) {
                    var S = Object(p.attachedRoot)(this.$el);
                    if (S) {
                      if (S.activeElement !== this.$refs.input)
                        return this.$refs.input.focus();
                      this.isFocused || (this.isFocused = !0, O && this.$emit("focus", O));
                    }
                  }
                },
                onInput: function(O) {
                  var S = O.target;
                  this.internalValue = S.value, this.badInput = S.validity && S.validity.badInput;
                },
                onKeyDown: function(O) {
                  O.keyCode === g.keyCodes.enter && this.lazyValue !== this.initialValue && (this.initialValue = this.lazyValue, this.$emit("change", this.initialValue)), this.$emit("keydown", O);
                },
                onMouseDown: function(O) {
                  O.target !== this.$refs.input && (O.preventDefault(), O.stopPropagation()), a.default.options.methods.onMouseDown.call(this, O);
                },
                onMouseUp: function(O) {
                  this.hasMouseDown && this.focus(), a.default.options.methods.onMouseUp.call(this, O);
                },
                setLabelWidth: function() {
                  this.outlined && (this.labelWidth = this.$refs.label ? Math.min(this.$refs.label.scrollWidth * 0.75 + 6, this.$el.offsetWidth - 24) : 0);
                },
                setPrefixWidth: function() {
                  this.$refs.prefix && (this.prefixWidth = this.$refs.prefix.offsetWidth);
                },
                setPrependWidth: function() {
                  !this.outlined || !this.$refs["prepend-inner"] || (this.prependWidth = this.$refs["prepend-inner"].offsetWidth);
                },
                tryAutofocus: function() {
                  if (!this.autofocus || typeof document > "u" || !this.$refs.input)
                    return !1;
                  var O = Object(p.attachedRoot)(this.$el);
                  return !O || O.activeElement === this.$refs.input ? !1 : (this.$refs.input.focus(), !0);
                },
                updateValue: function(O) {
                  this.hasColor = O, O ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                },
                onResize: function() {
                  this.setLabelWidth(), this.setPrefixWidth(), this.setPrependWidth();
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTextField/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VTextField/index.ts ***!
            \********************************************/
          /*! exports provided: VTextField, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTextField */
              "./src/components/VTextField/VTextField.ts"
            );
            i.d(r, "VTextField", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTextarea/VTextarea.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTextarea/VTextarea.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTextarea/VTextarea.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTextarea/VTextarea.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTextarea.sass */
              "./src/components/VTextarea/VTextarea.sass"
            );
            var a = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, l.apply(this, arguments);
            }, f = Object(o.default)(a.default);
            r.default = f.extend({
              name: "v-textarea",
              props: {
                autoGrow: Boolean,
                noResize: Boolean,
                rowHeight: {
                  type: [Number, String],
                  default: 24,
                  validator: function(u) {
                    return !isNaN(parseFloat(u));
                  }
                },
                rows: {
                  type: [Number, String],
                  default: 5,
                  validator: function(u) {
                    return !isNaN(parseInt(u, 10));
                  }
                }
              },
              computed: {
                classes: function() {
                  return l({
                    "v-textarea": !0,
                    "v-textarea--auto-grow": this.autoGrow,
                    "v-textarea--no-resize": this.noResizeHandle
                  }, a.default.options.computed.classes.call(this));
                },
                noResizeHandle: function() {
                  return this.noResize || this.autoGrow;
                }
              },
              watch: {
                autoGrow: function(u) {
                  var c = this;
                  this.$nextTick(function() {
                    var h;
                    u ? c.calculateInputHeight() : (h = c.$refs.input) === null || h === void 0 || h.style.removeProperty("height");
                  });
                },
                lazyValue: function() {
                  this.autoGrow && this.$nextTick(this.calculateInputHeight);
                },
                rowHeight: function() {
                  this.autoGrow && this.$nextTick(this.calculateInputHeight);
                }
              },
              mounted: function() {
                var u = this;
                setTimeout(function() {
                  u.autoGrow && u.calculateInputHeight();
                }, 0);
              },
              methods: {
                calculateInputHeight: function() {
                  var u = this.$refs.input;
                  if (u) {
                    u.style.height = "0";
                    var c = u.scrollHeight, h = parseInt(this.rows, 10) * parseFloat(this.rowHeight);
                    u.style.height = Math.max(h, c) + "px";
                  }
                },
                genInput: function() {
                  var u = a.default.options.methods.genInput.call(this);
                  return u.tag = "textarea", delete u.data.attrs.type, u.data.attrs.rows = this.rows, u;
                },
                onInput: function(u) {
                  a.default.options.methods.onInput.call(this, u), this.autoGrow && this.calculateInputHeight();
                },
                onKeyDown: function(u) {
                  this.isFocused && u.keyCode === 13 && u.stopPropagation(), this.$emit("keydown", u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTextarea/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTextarea/index.ts ***!
            \*******************************************/
          /*! exports provided: VTextarea, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTextarea */
              "./src/components/VTextarea/VTextarea.ts"
            );
            i.d(r, "VTextarea", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VThemeProvider/VThemeProvider.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VThemeProvider/VThemeProvider.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            );
            r.default = a.default.extend({
              name: "v-theme-provider",
              props: {
                root: Boolean
              },
              computed: {
                isDark: function() {
                  return this.root ? this.rootIsDark : a.default.options.computed.isDark.call(this);
                }
              },
              render: function() {
                return this.$slots.default && this.$slots.default.find(function(l) {
                  return !l.isComment && l.text !== " ";
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VThemeProvider/index.ts": (
          /*!************************************************!*\
            !*** ./src/components/VThemeProvider/index.ts ***!
            \************************************************/
          /*! exports provided: VThemeProvider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VThemeProvider */
              "./src/components/VThemeProvider/VThemeProvider.ts"
            );
            i.d(r, "VThemeProvider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTimePicker/SelectingTimes.ts": (
          /*!******************************************************!*\
            !*** ./src/components/VTimePicker/SelectingTimes.ts ***!
            \******************************************************/
          /*! exports provided: SelectingTimes */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "SelectingTimes", function() {
              return a;
            });
            var a;
            (function(o) {
              o[o.Hour = 1] = "Hour", o[o.Minute = 2] = "Minute", o[o.Second = 3] = "Second";
            })(a || (a = {}));
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePicker.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTimePicker/VTimePicker.ts ***!
            \***************************************************/
          /*! exports provided: SelectingTimes, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimePickerTitle */
              "./src/components/VTimePicker/VTimePickerTitle.ts"
            ), o = i(
              /*! ./VTimePickerClock */
              "./src/components/VTimePicker/VTimePickerClock.ts"
            ), l = i(
              /*! ../../mixins/picker */
              "./src/mixins/picker/index.ts"
            ), f = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! ../VDatePicker/util/pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ./SelectingTimes */
              "./src/components/VTimePicker/SelectingTimes.ts"
            );
            i.d(r, "SelectingTimes", function() {
              return h.SelectingTimes;
            });
            var p = function(C, x) {
              var b = typeof Symbol == "function" && C[Symbol.iterator];
              if (!b)
                return C;
              var P = b.call(C), T, O = [], S;
              try {
                for (; (x === void 0 || x-- > 0) && !(T = P.next()).done; )
                  O.push(T.value);
              } catch (L) {
                S = {
                  error: L
                };
              } finally {
                try {
                  T && !T.done && (b = P.return) && b.call(P);
                } finally {
                  if (S)
                    throw S.error;
                }
              }
              return O;
            }, g = Object(d.createRange)(24), m = Object(d.createRange)(12), v = m.map(function(C) {
              return C + 12;
            }), y = Object(d.createRange)(60), E = {
              1: "hour",
              2: "minute",
              3: "second"
            };
            r.default = Object(c.default)(
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker",
              props: {
                activePicker: String,
                allowedHours: [Function, Array],
                allowedMinutes: [Function, Array],
                allowedSeconds: [Function, Array],
                disabled: Boolean,
                format: {
                  type: String,
                  default: "ampm",
                  validator: function(x) {
                    return ["ampm", "24hr"].includes(x);
                  }
                },
                min: String,
                max: String,
                readonly: Boolean,
                scrollable: Boolean,
                useSeconds: Boolean,
                value: null,
                ampmInTitle: Boolean
              },
              data: function() {
                return {
                  inputHour: null,
                  inputMinute: null,
                  inputSecond: null,
                  lazyInputHour: null,
                  lazyInputMinute: null,
                  lazyInputSecond: null,
                  period: "am",
                  selecting: h.SelectingTimes.Hour
                };
              },
              computed: {
                selectingHour: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Hour;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Hour;
                  }
                },
                selectingMinute: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Minute;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Minute;
                  }
                },
                selectingSecond: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Second;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Second;
                  }
                },
                isAllowedHourCb: function() {
                  var x = this, b;
                  if (this.allowedHours instanceof Array ? b = function(S) {
                    return x.allowedHours.includes(S);
                  } : b = this.allowedHours, !this.min && !this.max)
                    return b;
                  var P = this.min ? Number(this.min.split(":")[0]) : 0, T = this.max ? Number(this.max.split(":")[0]) : 23;
                  return function(O) {
                    return O >= P * 1 && O <= T * 1 && (!b || b(O));
                  };
                },
                isAllowedMinuteCb: function() {
                  var x = this, b, P = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour);
                  if (this.allowedMinutes instanceof Array ? b = function(j) {
                    return x.allowedMinutes.includes(j);
                  } : b = this.allowedMinutes, !this.min && !this.max)
                    return P ? b : function() {
                      return !1;
                    };
                  var T = p(this.min ? this.min.split(":").map(Number) : [0, 0], 2), O = T[0], S = T[1], L = p(this.max ? this.max.split(":").map(Number) : [23, 59], 2), A = L[0], D = L[1], _ = O * 60 + S * 1, w = A * 60 + D * 1;
                  return function(B) {
                    var j = 60 * x.inputHour + B;
                    return j >= _ && j <= w && P && (!b || b(B));
                  };
                },
                isAllowedSecondCb: function() {
                  var x = this, b, P = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour), T = P && (!this.isAllowedMinuteCb || this.inputMinute === null || this.isAllowedMinuteCb(this.inputMinute));
                  if (this.allowedSeconds instanceof Array ? b = function(rt) {
                    return x.allowedSeconds.includes(rt);
                  } : b = this.allowedSeconds, !this.min && !this.max)
                    return T ? b : function() {
                      return !1;
                    };
                  var O = p(this.min ? this.min.split(":").map(Number) : [0, 0, 0], 3), S = O[0], L = O[1], A = O[2], D = p(this.max ? this.max.split(":").map(Number) : [23, 59, 59], 3), _ = D[0], w = D[1], B = D[2], j = S * 3600 + L * 60 + (A || 0) * 1, k = _ * 3600 + w * 60 + (B || 0) * 1;
                  return function(X) {
                    var rt = 3600 * x.inputHour + 60 * x.inputMinute + X;
                    return rt >= j && rt <= k && T && (!b || b(X));
                  };
                },
                isAmPm: function() {
                  return this.format === "ampm";
                }
              },
              watch: {
                activePicker: "setPicker",
                selecting: "emitPicker",
                value: "setInputData"
              },
              mounted: function() {
                this.setInputData(this.value), this.$on("update:period", this.setPeriod);
              },
              methods: {
                genValue: function() {
                  return this.inputHour != null && this.inputMinute != null && (!this.useSeconds || this.inputSecond != null) ? Object(u.default)(this.inputHour) + ":" + Object(u.default)(this.inputMinute) + (this.useSeconds ? ":" + Object(u.default)(this.inputSecond) : "") : null;
                },
                emitValue: function() {
                  var x = this.genValue();
                  x !== null && this.$emit("input", x);
                },
                emitPicker: function(x) {
                  var b = "HOUR";
                  x === h.SelectingTimes.Minute ? b = "MINUTE" : x === h.SelectingTimes.Second && (b = "SECOND"), this.$emit("update:active-picker", b);
                },
                setPicker: function(x) {
                  x === "HOUR" ? this.selecting = h.SelectingTimes.Hour : x === "MINUTE" ? this.selecting = h.SelectingTimes.Minute : x === "SECOND" && this.useSeconds && (this.selecting = h.SelectingTimes.Second);
                },
                setPeriod: function(x) {
                  if (this.period = x, this.inputHour != null) {
                    var b = this.inputHour + (x === "am" ? -12 : 12);
                    this.inputHour = this.firstAllowed("hour", b), this.emitValue();
                  }
                },
                setInputData: function(x) {
                  if (x == null || x === "")
                    this.inputHour = null, this.inputMinute = null, this.inputSecond = null;
                  else if (x instanceof Date)
                    this.inputHour = x.getHours(), this.inputMinute = x.getMinutes(), this.inputSecond = x.getSeconds();
                  else {
                    var b = p(x.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6), 6), P = b[1], T = b[2], O = b[4], S = b[5];
                    this.inputHour = S ? this.convert12to24(parseInt(P, 10), S) : parseInt(P, 10), this.inputMinute = parseInt(T, 10), this.inputSecond = parseInt(O || 0, 10);
                  }
                  this.period = this.inputHour == null || this.inputHour < 12 ? "am" : "pm";
                },
                convert24to12: function(x) {
                  return x ? (x - 1) % 12 + 1 : 12;
                },
                convert12to24: function(x, b) {
                  return x % 12 + (b === "pm" ? 12 : 0);
                },
                onInput: function(x) {
                  this.selecting === h.SelectingTimes.Hour ? this.inputHour = this.isAmPm ? this.convert12to24(x, this.period) : x : this.selecting === h.SelectingTimes.Minute ? this.inputMinute = x : this.inputSecond = x, this.emitValue();
                },
                onChange: function(x) {
                  this.$emit("click:" + E[this.selecting], x);
                  var b = this.selecting === (this.useSeconds ? h.SelectingTimes.Second : h.SelectingTimes.Minute);
                  if (this.selecting === h.SelectingTimes.Hour ? this.selecting = h.SelectingTimes.Minute : this.useSeconds && this.selecting === h.SelectingTimes.Minute && (this.selecting = h.SelectingTimes.Second), !(this.inputHour === this.lazyInputHour && this.inputMinute === this.lazyInputMinute && (!this.useSeconds || this.inputSecond === this.lazyInputSecond))) {
                    var P = this.genValue();
                    P !== null && (this.lazyInputHour = this.inputHour, this.lazyInputMinute = this.inputMinute, this.useSeconds && (this.lazyInputSecond = this.inputSecond), b && this.$emit("change", P));
                  }
                },
                firstAllowed: function(x, b) {
                  var P = x === "hour" ? this.isAllowedHourCb : x === "minute" ? this.isAllowedMinuteCb : this.isAllowedSecondCb;
                  if (!P)
                    return b;
                  var T = x === "minute" || x === "second" ? y : this.isAmPm ? b < 12 ? m : v : g, O = T.find(function(S) {
                    return P((S + b) % T.length + T[0]);
                  });
                  return ((O || 0) + b) % T.length + T[0];
                },
                genClock: function() {
                  return this.$createElement(o.default, {
                    props: {
                      allowedValues: this.selecting === h.SelectingTimes.Hour ? this.isAllowedHourCb : this.selecting === h.SelectingTimes.Minute ? this.isAllowedMinuteCb : this.isAllowedSecondCb,
                      color: this.color,
                      dark: this.dark,
                      disabled: this.disabled,
                      double: this.selecting === h.SelectingTimes.Hour && !this.isAmPm,
                      format: this.selecting === h.SelectingTimes.Hour ? this.isAmPm ? this.convert24to12 : function(x) {
                        return x;
                      } : function(x) {
                        return Object(u.default)(x, 2);
                      },
                      light: this.light,
                      max: this.selecting === h.SelectingTimes.Hour ? this.isAmPm && this.period === "am" ? 11 : 23 : 59,
                      min: this.selecting === h.SelectingTimes.Hour && this.isAmPm && this.period === "pm" ? 12 : 0,
                      readonly: this.readonly,
                      scrollable: this.scrollable,
                      size: Number(this.width) - (!this.fullWidth && this.landscape ? 80 : 20),
                      step: this.selecting === h.SelectingTimes.Hour ? 1 : 5,
                      value: this.selecting === h.SelectingTimes.Hour ? this.inputHour : this.selecting === h.SelectingTimes.Minute ? this.inputMinute : this.inputSecond
                    },
                    on: {
                      input: this.onInput,
                      change: this.onChange
                    },
                    ref: "clock"
                  });
                },
                genClockAmPm: function() {
                  return this.$createElement("div", this.setTextColor(this.color || "primary", {
                    staticClass: "v-time-picker-clock__ampm"
                  }), [this.genPickerButton("period", "am", this.$vuetify.lang.t("$vuetify.timePicker.am"), this.disabled || this.readonly), this.genPickerButton("period", "pm", this.$vuetify.lang.t("$vuetify.timePicker.pm"), this.disabled || this.readonly)]);
                },
                genPickerBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-time-picker-clock__container",
                    key: this.selecting
                  }, [!this.ampmInTitle && this.isAmPm && this.genClockAmPm(), this.genClock()]);
                },
                genPickerTitle: function() {
                  var x = this;
                  return this.$createElement(a.default, {
                    props: {
                      ampm: this.isAmPm,
                      ampmReadonly: this.isAmPm && !this.ampmInTitle,
                      disabled: this.disabled,
                      hour: this.inputHour,
                      minute: this.inputMinute,
                      second: this.inputSecond,
                      period: this.period,
                      readonly: this.readonly,
                      useSeconds: this.useSeconds,
                      selecting: this.selecting
                    },
                    on: {
                      "update:selecting": function(P) {
                        return x.selecting = P;
                      },
                      "update:period": function(P) {
                        return x.$emit("update:period", P);
                      }
                    },
                    ref: "title",
                    slot: "title"
                  });
                }
              },
              render: function() {
                return this.genPicker("v-picker--time");
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerClock.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerClock.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerClock.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerClock.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimePickerClock.sass */
              "./src/components/VTimePicker/VTimePickerClock.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker-clock",
              props: {
                allowedValues: Function,
                ampm: Boolean,
                disabled: Boolean,
                double: Boolean,
                format: {
                  type: Function,
                  default: function(u) {
                    return u;
                  }
                },
                max: {
                  type: Number,
                  required: !0
                },
                min: {
                  type: Number,
                  required: !0
                },
                scrollable: Boolean,
                readonly: Boolean,
                rotate: {
                  type: Number,
                  default: 0
                },
                step: {
                  type: Number,
                  default: 1
                },
                value: Number
              },
              data: function() {
                return {
                  inputValue: this.value,
                  isDragging: !1,
                  valueOnMouseDown: null,
                  valueOnMouseUp: null
                };
              },
              computed: {
                count: function() {
                  return this.max - this.min + 1;
                },
                degreesPerUnit: function() {
                  return 360 / this.roundCount;
                },
                degrees: function() {
                  return this.degreesPerUnit * Math.PI / 180;
                },
                displayedValue: function() {
                  return this.value == null ? this.min : this.value;
                },
                innerRadiusScale: function() {
                  return 0.62;
                },
                roundCount: function() {
                  return this.double ? this.count / 2 : this.count;
                }
              },
              watch: {
                value: function(u) {
                  this.inputValue = u;
                }
              },
              methods: {
                wheel: function(u) {
                  u.preventDefault();
                  var c = Math.sign(-u.deltaY || 1), h = this.displayedValue;
                  do
                    h = h + c, h = (h - this.min + this.count) % this.count + this.min;
                  while (!this.isAllowed(h) && h !== this.displayedValue);
                  h !== this.displayedValue && this.update(h);
                },
                isInner: function(u) {
                  return this.double && u - this.min >= this.roundCount;
                },
                handScale: function(u) {
                  return this.isInner(u) ? this.innerRadiusScale : 1;
                },
                isAllowed: function(u) {
                  return !this.allowedValues || this.allowedValues(u);
                },
                genValues: function() {
                  for (var u = [], c = this.min; c <= this.max; c = c + this.step) {
                    var h = c === this.value && (this.color || "accent");
                    u.push(this.$createElement("span", this.setBackgroundColor(h, {
                      staticClass: "v-time-picker-clock__item",
                      class: {
                        "v-time-picker-clock__item--active": c === this.displayedValue,
                        "v-time-picker-clock__item--disabled": this.disabled || !this.isAllowed(c)
                      },
                      style: this.getTransform(c),
                      domProps: {
                        innerHTML: "<span>" + this.format(c) + "</span>"
                      }
                    })));
                  }
                  return u;
                },
                genHand: function() {
                  var u = "scaleY(" + this.handScale(this.displayedValue) + ")", c = this.rotate + this.degreesPerUnit * (this.displayedValue - this.min), h = this.value != null && (this.color || "accent");
                  return this.$createElement("div", this.setBackgroundColor(h, {
                    staticClass: "v-time-picker-clock__hand",
                    class: {
                      "v-time-picker-clock__hand--inner": this.isInner(this.value)
                    },
                    style: {
                      transform: "rotate(" + c + "deg) " + u
                    }
                  }));
                },
                getTransform: function(u) {
                  var c = this.getPosition(u), h = c.x, p = c.y;
                  return {
                    left: 50 + h * 50 + "%",
                    top: 50 + p * 50 + "%"
                  };
                },
                getPosition: function(u) {
                  var c = this.rotate * Math.PI / 180;
                  return {
                    x: Math.sin((u - this.min) * this.degrees + c) * this.handScale(u),
                    y: -Math.cos((u - this.min) * this.degrees + c) * this.handScale(u)
                  };
                },
                onMouseDown: function(u) {
                  u.preventDefault(), this.valueOnMouseDown = null, this.valueOnMouseUp = null, this.isDragging = !0, this.onDragMove(u);
                },
                onMouseUp: function(u) {
                  u.stopPropagation(), this.isDragging = !1, this.valueOnMouseUp !== null && this.isAllowed(this.valueOnMouseUp) && this.$emit("change", this.valueOnMouseUp);
                },
                onDragMove: function(u) {
                  if (u.preventDefault(), !(!this.isDragging && u.type !== "click" || !this.$refs.clock))
                    for (var c = this.$refs.clock.getBoundingClientRect(), h = c.width, p = c.top, g = c.left, m = this.$refs.innerClock.getBoundingClientRect().width, v = ("touches" in u) ? u.touches[0] : u, y = v.clientX, E = v.clientY, C = {
                      x: h / 2,
                      y: -h / 2
                    }, x = {
                      x: y - g,
                      y: p - E
                    }, b = Math.round(this.angle(C, x) - this.rotate + 360) % 360, P = this.double && this.euclidean(C, x) < (m + m * this.innerRadiusScale) / 4, T = Math.ceil(15 / this.degreesPerUnit), O, S = 0; S < T; S++) {
                      if (O = this.angleToValue(b + S * this.degreesPerUnit, P), this.isAllowed(O))
                        return this.setMouseDownValue(O);
                      if (O = this.angleToValue(b - S * this.degreesPerUnit, P), this.isAllowed(O))
                        return this.setMouseDownValue(O);
                    }
                },
                angleToValue: function(u, c) {
                  var h = (Math.round(u / this.degreesPerUnit) + (c ? this.roundCount : 0)) % this.count + this.min;
                  return u < 360 - this.degreesPerUnit / 2 ? h : c ? this.max - this.roundCount + 1 : this.min;
                },
                setMouseDownValue: function(u) {
                  this.valueOnMouseDown === null && (this.valueOnMouseDown = u), this.valueOnMouseUp = u, this.update(u);
                },
                update: function(u) {
                  this.inputValue !== u && (this.inputValue = u, this.$emit("input", u));
                },
                euclidean: function(u, c) {
                  var h = c.x - u.x, p = c.y - u.y;
                  return Math.sqrt(h * h + p * p);
                },
                angle: function(u, c) {
                  var h = 2 * Math.atan2(c.y - u.y - this.euclidean(u, c), c.x - u.x);
                  return Math.abs(h * 180 / Math.PI);
                }
              },
              render: function(u) {
                var c = this, h = {
                  staticClass: "v-time-picker-clock",
                  class: f({
                    "v-time-picker-clock--indeterminate": this.value == null
                  }, this.themeClasses),
                  on: this.readonly || this.disabled ? void 0 : {
                    mousedown: this.onMouseDown,
                    mouseup: this.onMouseUp,
                    mouseleave: function(g) {
                      return c.isDragging && c.onMouseUp(g);
                    },
                    touchstart: this.onMouseDown,
                    touchend: this.onMouseUp,
                    mousemove: this.onDragMove,
                    touchmove: this.onDragMove
                  },
                  ref: "clock"
                };
                return this.scrollable && h.on && (h.on.wheel = this.wheel), u("div", h, [u("div", {
                  staticClass: "v-time-picker-clock__inner",
                  ref: "innerClock"
                }, [this.genHand(), this.genValues()])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerTitle.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerTitle.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerTitle.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerTitle.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimePickerTitle.sass */
              "./src/components/VTimePicker/VTimePickerTitle.sass"
            );
            var a = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), o = i(
              /*! ../VDatePicker/util */
              "./src/components/VDatePicker/util/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ./SelectingTimes */
              "./src/components/VTimePicker/SelectingTimes.ts"
            );
            r.default = Object(l.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker-title",
              props: {
                ampm: Boolean,
                ampmReadonly: Boolean,
                disabled: Boolean,
                hour: Number,
                minute: Number,
                second: Number,
                period: {
                  type: String,
                  validator: function(u) {
                    return u === "am" || u === "pm";
                  }
                },
                readonly: Boolean,
                useSeconds: Boolean,
                selecting: Number
              },
              methods: {
                genTime: function() {
                  var u = this.hour;
                  this.ampm && (u = u ? (u - 1) % 12 + 1 : 12);
                  var c = this.hour == null ? "--" : this.ampm ? String(u) : Object(o.pad)(u), h = this.minute == null ? "--" : Object(o.pad)(this.minute), p = [this.genPickerButton("selecting", f.SelectingTimes.Hour, c, this.disabled), this.$createElement("span", ":"), this.genPickerButton("selecting", f.SelectingTimes.Minute, h, this.disabled)];
                  if (this.useSeconds) {
                    var g = this.second == null ? "--" : Object(o.pad)(this.second);
                    p.push(this.$createElement("span", ":")), p.push(this.genPickerButton("selecting", f.SelectingTimes.Second, g, this.disabled));
                  }
                  return this.$createElement("div", {
                    class: "v-time-picker-title__time"
                  }, p);
                },
                genAmPm: function() {
                  return this.$createElement("div", {
                    staticClass: "v-time-picker-title__ampm",
                    class: {
                      "v-time-picker-title__ampm--readonly": this.ampmReadonly
                    }
                  }, [!this.ampmReadonly || this.period === "am" ? this.genPickerButton("period", "am", this.$vuetify.lang.t("$vuetify.timePicker.am"), this.disabled || this.readonly) : null, !this.ampmReadonly || this.period === "pm" ? this.genPickerButton("period", "pm", this.$vuetify.lang.t("$vuetify.timePicker.pm"), this.disabled || this.readonly) : null]);
                }
              },
              render: function(u) {
                var c = [this.genTime()];
                return this.ampm && c.push(this.genAmPm()), u("div", {
                  staticClass: "v-time-picker-title"
                }, c);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTimePicker/index.ts ***!
            \*********************************************/
          /*! exports provided: VTimePicker, VTimePickerClock, VTimePickerTitle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimePicker */
              "./src/components/VTimePicker/VTimePicker.ts"
            );
            i.d(r, "VTimePicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTimePickerClock */
              "./src/components/VTimePicker/VTimePickerClock.ts"
            );
            i.d(r, "VTimePickerClock", function() {
              return o.default;
            });
            var l = i(
              /*! ./VTimePickerTitle */
              "./src/components/VTimePicker/VTimePickerTitle.ts"
            );
            i.d(r, "VTimePickerTitle", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTimePicker: a.default,
                VTimePickerClock: o.default,
                VTimePickerTitle: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTimeline/VTimeline.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTimeline/VTimeline.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimeline/VTimeline.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTimeline/VTimeline.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimeline.sass */
              "./src/components/VTimeline/VTimeline.sass"
            );
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(a.default)(
              o.default
              /* @vue/component */
            ).extend({
              name: "v-timeline",
              provide: function() {
                return {
                  timeline: this
                };
              },
              props: {
                alignTop: Boolean,
                dense: Boolean,
                reverse: Boolean
              },
              computed: {
                classes: function() {
                  return l({
                    "v-timeline--align-top": this.alignTop,
                    "v-timeline--dense": this.dense,
                    "v-timeline--reverse": this.reverse
                  }, this.themeClasses);
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-timeline",
                  class: this.classes
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimeline/VTimelineItem.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTimeline/VTimelineItem.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = Object(a.default)(
              f.default,
              l.default
              /* @vue/component */
            );
            r.default = u.extend().extend({
              name: "v-timeline-item",
              inject: ["timeline"],
              props: {
                color: {
                  type: String,
                  default: "primary"
                },
                fillDot: Boolean,
                hideDot: Boolean,
                icon: String,
                iconColor: String,
                large: Boolean,
                left: Boolean,
                right: Boolean,
                small: Boolean
              },
              computed: {
                hasIcon: function() {
                  return !!this.icon || !!this.$slots.icon;
                }
              },
              methods: {
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__body"
                  }, this.$slots.default);
                },
                genIcon: function() {
                  return this.$slots.icon ? this.$slots.icon : this.$createElement(o.default, {
                    props: {
                      color: this.iconColor,
                      dark: !this.theme.isDark,
                      small: this.small
                    }
                  }, this.icon);
                },
                genInnerDot: function() {
                  var h = this.setBackgroundColor(this.color);
                  return this.$createElement("div", d({
                    staticClass: "v-timeline-item__inner-dot"
                  }, h), [this.hasIcon && this.genIcon()]);
                },
                genDot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__dot",
                    class: {
                      "v-timeline-item__dot--small": this.small,
                      "v-timeline-item__dot--large": this.large
                    }
                  }, [this.genInnerDot()]);
                },
                genDivider: function() {
                  var h = [];
                  return this.hideDot || h.push(this.genDot()), this.$createElement("div", {
                    staticClass: "v-timeline-item__divider"
                  }, h);
                },
                genOpposite: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__opposite"
                  }, this.$slots.opposite);
                }
              },
              render: function(h) {
                var p = [this.genBody(), this.genDivider()];
                return this.$slots.opposite && p.push(this.genOpposite()), h("div", {
                  staticClass: "v-timeline-item",
                  class: d({
                    "v-timeline-item--fill-dot": this.fillDot,
                    "v-timeline-item--before": this.timeline.reverse ? this.right : this.left,
                    "v-timeline-item--after": this.timeline.reverse ? this.left : this.right
                  }, this.themeClasses)
                }, p);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimeline/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTimeline/index.ts ***!
            \*******************************************/
          /*! exports provided: VTimeline, VTimelineItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimeline */
              "./src/components/VTimeline/VTimeline.ts"
            );
            i.d(r, "VTimeline", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTimelineItem */
              "./src/components/VTimeline/VTimelineItem.ts"
            );
            i.d(r, "VTimelineItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTimeline: a.default,
                VTimelineItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VToolbar/VToolbar.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VToolbar/VToolbar.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VToolbar/VToolbar.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VToolbar/VToolbar.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VToolbar.sass */
              "./src/components/VToolbar/VToolbar.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../VImg/VImg */
              "./src/components/VImg/VImg.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            };
            r.default = a.default.extend({
              name: "v-toolbar",
              props: {
                absolute: Boolean,
                bottom: Boolean,
                collapse: Boolean,
                dense: Boolean,
                extended: Boolean,
                extensionHeight: {
                  default: 48,
                  type: [Number, String]
                },
                flat: Boolean,
                floating: Boolean,
                prominent: Boolean,
                short: Boolean,
                src: {
                  type: [String, Object],
                  default: ""
                },
                tag: {
                  type: String,
                  default: "header"
                }
              },
              data: function() {
                return {
                  isExtended: !1
                };
              },
              computed: {
                computedHeight: function() {
                  var h = this.computedContentHeight;
                  if (!this.isExtended)
                    return h;
                  var p = parseInt(this.extensionHeight);
                  return this.isCollapsed ? h : h + (isNaN(p) ? 0 : p);
                },
                computedContentHeight: function() {
                  return this.height ? parseInt(this.height) : this.isProminent && this.dense ? 96 : this.isProminent && this.short ? 112 : this.isProminent ? 128 : this.dense ? 48 : this.short || this.$vuetify.breakpoint.smAndDown ? 56 : 64;
                },
                classes: function() {
                  return d(d({}, a.default.options.computed.classes.call(this)), {
                    "v-toolbar": !0,
                    "v-toolbar--absolute": this.absolute,
                    "v-toolbar--bottom": this.bottom,
                    "v-toolbar--collapse": this.collapse,
                    "v-toolbar--collapsed": this.isCollapsed,
                    "v-toolbar--dense": this.dense,
                    "v-toolbar--extended": this.isExtended,
                    "v-toolbar--flat": this.flat,
                    "v-toolbar--floating": this.floating,
                    "v-toolbar--prominent": this.isProminent
                  });
                },
                isCollapsed: function() {
                  return this.collapse;
                },
                isProminent: function() {
                  return this.prominent;
                },
                styles: function() {
                  return d(d({}, this.measurableStyles), {
                    height: Object(l.convertToUnit)(this.computedHeight)
                  });
                }
              },
              created: function() {
                var h = this, p = [["app", "<v-app-bar app>"], ["manual-scroll", '<v-app-bar :value="false">'], ["clipped-left", "<v-app-bar clipped-left>"], ["clipped-right", "<v-app-bar clipped-right>"], ["inverted-scroll", "<v-app-bar inverted-scroll>"], ["scroll-off-screen", "<v-app-bar scroll-off-screen>"], ["scroll-target", "<v-app-bar scroll-target>"], ["scroll-threshold", "<v-app-bar scroll-threshold>"], ["card", "<v-app-bar flat>"]];
                p.forEach(function(g) {
                  var m = u(g, 2), v = m[0], y = m[1];
                  h.$attrs.hasOwnProperty(v) && Object(f.breaking)(v, y, h);
                });
              },
              methods: {
                genBackground: function() {
                  var h = {
                    height: Object(l.convertToUnit)(this.computedHeight),
                    src: this.src
                  }, p = this.$scopedSlots.img ? this.$scopedSlots.img({
                    props: h
                  }) : this.$createElement(o.default, {
                    props: h
                  });
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__image"
                  }, [p]);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__content",
                    style: {
                      height: Object(l.convertToUnit)(this.computedContentHeight)
                    }
                  }, Object(l.getSlot)(this));
                },
                genExtension: function() {
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__extension",
                    style: {
                      height: Object(l.convertToUnit)(this.extensionHeight)
                    }
                  }, Object(l.getSlot)(this, "extension"));
                }
              },
              render: function(h) {
                this.isExtended = this.extended || !!this.$scopedSlots.extension;
                var p = [this.genContent()], g = this.setBackgroundColor(this.color, {
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                });
                return this.isExtended && p.push(this.genExtension()), (this.src || this.$scopedSlots.img) && p.unshift(this.genBackground()), h(this.tag, g, p);
              }
            });
          }
        ),
        /***/
        "./src/components/VToolbar/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VToolbar/index.ts ***!
            \******************************************/
          /*! exports provided: VToolbar, VToolbarItems, VToolbarTitle, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VToolbarItems", function() {
              return f;
            }), i.d(r, "VToolbarTitle", function() {
              return l;
            });
            var a = i(
              /*! ./VToolbar */
              "./src/components/VToolbar/VToolbar.ts"
            );
            i.d(r, "VToolbar", function() {
              return a.default;
            });
            var o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = Object(o.createSimpleFunctional)("v-toolbar__title"), f = Object(o.createSimpleFunctional)("v-toolbar__items");
            r.default = {
              $_vuetify_subcomponents: {
                VToolbar: a.default,
                VToolbarItems: f,
                VToolbarTitle: l
              }
            };
          }
        ),
        /***/
        "./src/components/VTooltip/VTooltip.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VTooltip/VTooltip.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTooltip/VTooltip.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTooltip/VTooltip.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTooltip.sass */
              "./src/components/VTooltip/VTooltip.sass"
            );
            var a = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/menuable */
              "./src/mixins/menuable/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(h.default)(o.default, l.default, f.default, d.default).extend({
              name: "v-tooltip",
              props: {
                closeDelay: {
                  type: [Number, String],
                  default: 0
                },
                disabled: Boolean,
                openDelay: {
                  type: [Number, String],
                  default: 0
                },
                openOnHover: {
                  type: Boolean,
                  default: !0
                },
                openOnFocus: {
                  type: Boolean,
                  default: !0
                },
                tag: {
                  type: String,
                  default: "span"
                },
                transition: String
              },
              data: function() {
                return {
                  calculatedMinWidth: 0,
                  closeDependents: !1
                };
              },
              computed: {
                calculatedLeft: function() {
                  var g = this.dimensions, m = g.activator, v = g.content, y = !this.bottom && !this.left && !this.top && !this.right, E = this.attach !== !1 ? m.offsetLeft : m.left, C = 0;
                  return this.top || this.bottom || y ? C = E + m.width / 2 - v.width / 2 : (this.left || this.right) && (C = E + (this.right ? m.width : -v.width) + (this.right ? 10 : -10)), this.nudgeLeft && (C -= parseInt(this.nudgeLeft)), this.nudgeRight && (C += parseInt(this.nudgeRight)), this.calcXOverflow(C, this.dimensions.content.width) + "px";
                },
                calculatedTop: function() {
                  var g = this.dimensions, m = g.activator, v = g.content, y = this.attach !== !1 ? m.offsetTop : m.top, E = 0;
                  return this.top || this.bottom ? E = y + (this.bottom ? m.height : -v.height) + (this.bottom ? 10 : -10) : (this.left || this.right) && (E = y + m.height / 2 - v.height / 2), this.nudgeTop && (E -= parseInt(this.nudgeTop)), this.nudgeBottom && (E += parseInt(this.nudgeBottom)), this.attach === !1 && (E += this.pageYOffset), this.calcYOverflow(E) + "px";
                },
                classes: function() {
                  return {
                    "v-tooltip--top": this.top,
                    "v-tooltip--right": this.right,
                    "v-tooltip--bottom": this.bottom,
                    "v-tooltip--left": this.left,
                    "v-tooltip--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  };
                },
                computedTransition: function() {
                  return this.transition ? this.transition : this.isActive ? "scale-transition" : "fade-transition";
                },
                offsetY: function() {
                  return this.top || this.bottom;
                },
                offsetX: function() {
                  return this.left || this.right;
                },
                styles: function() {
                  return {
                    left: this.calculatedLeft,
                    maxWidth: Object(u.convertToUnit)(this.maxWidth),
                    minWidth: Object(u.convertToUnit)(this.minWidth),
                    top: this.calculatedTop,
                    zIndex: this.zIndex || this.activeZIndex
                  };
                }
              },
              beforeMount: function() {
                var g = this;
                this.$nextTick(function() {
                  g.value && g.callActivate();
                });
              },
              mounted: function() {
                Object(u.getSlotType)(this, "activator", !0) === "v-slot" && Object(c.consoleError)(`v-tooltip's activator slot must be bound, try '<template #activator="data"><v-btn v-on="data.on>'`, this);
              },
              methods: {
                activate: function() {
                  this.updateDimensions(), requestAnimationFrame(this.startTransition);
                },
                deactivate: function() {
                  this.runDelay("close");
                },
                genActivatorListeners: function() {
                  var g = this, m = a.default.options.methods.genActivatorListeners.call(this);
                  return this.openOnFocus && (m.focus = function(v) {
                    g.getActivator(v), g.runDelay("open");
                  }, m.blur = function(v) {
                    g.getActivator(v), g.runDelay("close");
                  }), m.keydown = function(v) {
                    v.keyCode === u.keyCodes.esc && (g.getActivator(v), g.runDelay("close"));
                  }, m;
                },
                genActivatorAttributes: function() {
                  return {
                    "aria-haspopup": !0,
                    "aria-expanded": String(this.isActive)
                  };
                },
                genTransition: function() {
                  var g = this.genContent();
                  return this.computedTransition ? this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [g]) : g;
                },
                genContent: function() {
                  var g;
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-tooltip__content",
                    class: (g = {}, g[this.contentClass] = !0, g.menuable__content__active = this.isActive, g["v-tooltip__content--fixed"] = this.activatorFixed, g),
                    style: this.styles,
                    attrs: this.getScopeIdAttrs(),
                    directives: [{
                      name: "show",
                      value: this.isContentActive
                    }],
                    ref: "content"
                  }), this.getContentSlot());
                }
              },
              render: function(g) {
                var m = this;
                return g(this.tag, {
                  staticClass: "v-tooltip",
                  class: this.classes
                }, [this.showLazyContent(function() {
                  return [m.genTransition()];
                }), this.genActivator()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTooltip/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTooltip/index.ts ***!
            \******************************************/
          /*! exports provided: VTooltip, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTooltip */
              "./src/components/VTooltip/VTooltip.ts"
            );
            i.d(r, "VTooltip", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeview.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTreeview/VTreeview.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeview.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTreeview/VTreeview.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTreeview.sass */
              "./src/components/VTreeview/VTreeview.sass"
            );
            var a = i(
              /*! ./VTreeviewNode */
              "./src/components/VTreeview/VTreeviewNode.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), c = i(
              /*! ./util/filterTreeItems */
              "./src/components/VTreeview/util/filterTreeItems.ts"
            ), h = function() {
              return h = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, h.apply(this, arguments);
            }, p = function(v, y) {
              var E = typeof Symbol == "function" && v[Symbol.iterator];
              if (!E)
                return v;
              var C = E.call(v), x, b = [], P;
              try {
                for (; (y === void 0 || y-- > 0) && !(x = C.next()).done; )
                  b.push(x.value);
              } catch (T) {
                P = {
                  error: T
                };
              } finally {
                try {
                  x && !x.done && (E = C.return) && E.call(C);
                } finally {
                  if (P)
                    throw P.error;
                }
              }
              return b;
            }, g = function(v, y, E) {
              if (E || arguments.length === 2)
                for (var C = 0, x = y.length, b; C < x; C++)
                  (b || !(C in y)) && (b || (b = Array.prototype.slice.call(y, 0, C)), b[C] = y[C]);
              return v.concat(b || Array.prototype.slice.call(y));
            }, m = function(v) {
              var y = typeof Symbol == "function" && Symbol.iterator, E = y && v[y], C = 0;
              if (E)
                return E.call(v);
              if (v && typeof v.length == "number")
                return {
                  next: function() {
                    return v && C >= v.length && (v = void 0), {
                      value: v && v[C++],
                      done: !v
                    };
                  }
                };
              throw new TypeError(y ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = Object(d.default)(
              Object(l.provide)("treeview"),
              o.default
              /* @vue/component */
            ).extend({
              name: "v-treeview",
              provide: function() {
                return {
                  treeview: this
                };
              },
              props: h({
                active: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                dense: Boolean,
                disabled: Boolean,
                filter: Function,
                hoverable: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                multipleActive: Boolean,
                open: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                openAll: Boolean,
                returnObject: {
                  type: Boolean,
                  default: !1
                  // TODO: Should be true in next major
                },
                search: String,
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              }, a.VTreeviewNodeProps),
              data: function() {
                return {
                  level: -1,
                  activeCache: /* @__PURE__ */ new Set(),
                  nodes: {},
                  openCache: /* @__PURE__ */ new Set(),
                  selectedCache: /* @__PURE__ */ new Set()
                };
              },
              computed: {
                excludedItems: function() {
                  var y = /* @__PURE__ */ new Set();
                  if (!this.search)
                    return y;
                  for (var E = 0; E < this.items.length; E++)
                    Object(c.filterTreeItems)(this.filter || c.filterTreeItem, this.items[E], this.search, this.itemKey, this.itemText, this.itemChildren, y);
                  return y;
                }
              },
              watch: {
                items: {
                  handler: function() {
                    var y = this, E = Object.keys(this.nodes).map(function(P) {
                      return Object(f.getObjectValueByPath)(y.nodes[P].item, y.itemKey);
                    }), C = this.getKeys(this.items), x = Object(f.arrayDiff)(C, E);
                    if (!(!x.length && C.length < E.length)) {
                      x.forEach(function(P) {
                        return delete y.nodes[P];
                      });
                      var b = g([], p(this.selectedCache), !1);
                      this.selectedCache = /* @__PURE__ */ new Set(), this.activeCache = /* @__PURE__ */ new Set(), this.openCache = /* @__PURE__ */ new Set(), this.buildTree(this.items), Object(f.deepEqual)(b, g([], p(this.selectedCache), !1)) || this.emitSelected();
                    }
                  },
                  deep: !0
                },
                active: function(y) {
                  this.handleNodeCacheWatcher(y, this.activeCache, this.updateActive, this.emitActive);
                },
                value: function(y) {
                  this.handleNodeCacheWatcher(y, this.selectedCache, this.updateSelected, this.emitSelected);
                },
                open: function(y) {
                  this.handleNodeCacheWatcher(y, this.openCache, this.updateOpen, this.emitOpen);
                }
              },
              created: function() {
                var y, E, C, x, b = this, P = function(w) {
                  return b.returnObject ? Object(f.getObjectValueByPath)(w, b.itemKey) : w;
                };
                this.buildTree(this.items);
                try {
                  for (var T = m(this.value.map(P)), O = T.next(); !O.done; O = T.next()) {
                    var S = O.value;
                    this.updateSelected(S, !0, !0);
                  }
                } catch (_) {
                  y = {
                    error: _
                  };
                } finally {
                  try {
                    O && !O.done && (E = T.return) && E.call(T);
                  } finally {
                    if (y)
                      throw y.error;
                  }
                }
                try {
                  for (var L = m(this.active.map(P)), A = L.next(); !A.done; A = L.next()) {
                    var D = A.value;
                    this.updateActive(D, !0);
                  }
                } catch (_) {
                  C = {
                    error: _
                  };
                } finally {
                  try {
                    A && !A.done && (x = L.return) && x.call(L);
                  } finally {
                    if (C)
                      throw C.error;
                  }
                }
              },
              mounted: function() {
                var y = this;
                (this.$slots.prepend || this.$slots.append) && Object(u.consoleWarn)("The prepend and append slots require a slot-scope attribute", this), this.openAll ? this.updateAll(!0) : (this.open.forEach(function(E) {
                  return y.updateOpen(y.returnObject ? Object(f.getObjectValueByPath)(E, y.itemKey) : E, !0);
                }), this.emitOpen());
              },
              methods: {
                /** @public */
                updateAll: function(y) {
                  var E = this;
                  Object.keys(this.nodes).forEach(function(C) {
                    return E.updateOpen(Object(f.getObjectValueByPath)(E.nodes[C].item, E.itemKey), y);
                  }), this.emitOpen();
                },
                getKeys: function(y, E) {
                  E === void 0 && (E = []);
                  for (var C = 0; C < y.length; C++) {
                    var x = Object(f.getObjectValueByPath)(y[C], this.itemKey);
                    E.push(x);
                    var b = Object(f.getObjectValueByPath)(y[C], this.itemChildren);
                    b && E.push.apply(E, g([], p(this.getKeys(b)), !1));
                  }
                  return E;
                },
                buildTree: function(y, E) {
                  var C = this, x;
                  E === void 0 && (E = null);
                  for (var b = 0; b < y.length; b++) {
                    var P = y[b], T = Object(f.getObjectValueByPath)(P, this.itemKey), O = (x = Object(f.getObjectValueByPath)(P, this.itemChildren)) !== null && x !== void 0 ? x : [], S = this.nodes.hasOwnProperty(T) ? this.nodes[T] : {
                      isSelected: !1,
                      isIndeterminate: !1,
                      isActive: !1,
                      isOpen: !1,
                      vnode: null
                    }, L = {
                      vnode: S.vnode,
                      parent: E,
                      children: O.map(function(w) {
                        return Object(f.getObjectValueByPath)(w, C.itemKey);
                      }),
                      item: P
                    };
                    if (this.buildTree(O, T), this.selectionType !== "independent" && E !== null && !this.nodes.hasOwnProperty(T) && this.nodes.hasOwnProperty(E) ? L.isSelected = this.nodes[E].isSelected : (L.isSelected = S.isSelected, L.isIndeterminate = S.isIndeterminate), L.isActive = S.isActive, L.isOpen = S.isOpen, this.nodes[T] = L, O.length && this.selectionType !== "independent") {
                      var A = this.calculateState(T, this.nodes), D = A.isSelected, _ = A.isIndeterminate;
                      L.isSelected = D, L.isIndeterminate = _;
                    }
                    this.nodes[T].isSelected && (this.selectionType === "independent" || L.children.length === 0) && this.selectedCache.add(T), this.nodes[T].isActive && this.activeCache.add(T), this.nodes[T].isOpen && this.openCache.add(T), this.updateVnodeState(T);
                  }
                },
                calculateState: function(y, E) {
                  var C = E[y].children, x = C.reduce(function(T, O) {
                    return T[0] += +!!E[O].isSelected, T[1] += +!!E[O].isIndeterminate, T;
                  }, [0, 0]), b = !!C.length && x[0] === C.length, P = !b && (x[0] > 0 || x[1] > 0);
                  return {
                    isSelected: b,
                    isIndeterminate: P
                  };
                },
                emitOpen: function() {
                  this.emitNodeCache("update:open", this.openCache);
                },
                emitSelected: function() {
                  this.emitNodeCache("input", this.selectedCache);
                },
                emitActive: function() {
                  this.emitNodeCache("update:active", this.activeCache);
                },
                emitNodeCache: function(y, E) {
                  var C = this;
                  this.$emit(y, this.returnObject ? g([], p(E), !1).map(function(x) {
                    return C.nodes[x].item;
                  }) : g([], p(E), !1));
                },
                handleNodeCacheWatcher: function(y, E, C, x) {
                  var b = this;
                  y = this.returnObject ? y.map(function(T) {
                    return Object(f.getObjectValueByPath)(T, b.itemKey);
                  }) : y;
                  var P = g([], p(E), !1);
                  Object(f.deepEqual)(P, y) || (P.forEach(function(T) {
                    return C(T, !1);
                  }), y.forEach(function(T) {
                    return C(T, !0);
                  }), x());
                },
                getDescendants: function(y, E) {
                  E === void 0 && (E = []);
                  var C = this.nodes[y].children;
                  E.push.apply(E, g([], p(C), !1));
                  for (var x = 0; x < C.length; x++)
                    E = this.getDescendants(C[x], E);
                  return E;
                },
                getParents: function(y) {
                  for (var E = this.nodes[y].parent, C = []; E !== null; )
                    C.push(E), E = this.nodes[E].parent;
                  return C;
                },
                register: function(y) {
                  var E = Object(f.getObjectValueByPath)(y.item, this.itemKey);
                  this.nodes[E].vnode = y, this.updateVnodeState(E);
                },
                unregister: function(y) {
                  var E = Object(f.getObjectValueByPath)(y.item, this.itemKey);
                  this.nodes[E] && (this.nodes[E].vnode = null);
                },
                isParent: function(y) {
                  return this.nodes[y].children && this.nodes[y].children.length;
                },
                updateActive: function(y, E) {
                  var C = this;
                  if (this.nodes.hasOwnProperty(y)) {
                    this.multipleActive || this.activeCache.forEach(function(b) {
                      C.nodes[b].isActive = !1, C.updateVnodeState(b), C.activeCache.delete(b);
                    });
                    var x = this.nodes[y];
                    x && (E ? this.activeCache.add(y) : this.activeCache.delete(y), x.isActive = E, this.updateVnodeState(y));
                  }
                },
                updateSelected: function(y, E, C) {
                  var x, b, P, T, O, S;
                  if (C === void 0 && (C = !1), !!this.nodes.hasOwnProperty(y)) {
                    var L = /* @__PURE__ */ new Map();
                    if (this.selectionType !== "independent") {
                      try {
                        for (var A = m(this.getDescendants(y)), D = A.next(); !D.done; D = A.next()) {
                          var _ = D.value;
                          (!Object(f.getObjectValueByPath)(this.nodes[_].item, this.itemDisabled) || C) && (this.nodes[_].isSelected = E, this.nodes[_].isIndeterminate = !1, L.set(_, E));
                        }
                      } catch (bt) {
                        x = {
                          error: bt
                        };
                      } finally {
                        try {
                          D && !D.done && (b = A.return) && b.call(A);
                        } finally {
                          if (x)
                            throw x.error;
                        }
                      }
                      var w = this.calculateState(y, this.nodes);
                      this.nodes[y].isSelected = E, this.nodes[y].isIndeterminate = w.isIndeterminate, L.set(y, E);
                      try {
                        for (var B = m(this.getParents(y)), j = B.next(); !j.done; j = B.next()) {
                          var k = j.value, X = this.calculateState(k, this.nodes);
                          this.nodes[k].isSelected = X.isSelected, this.nodes[k].isIndeterminate = X.isIndeterminate, L.set(k, X.isSelected);
                        }
                      } catch (bt) {
                        P = {
                          error: bt
                        };
                      } finally {
                        try {
                          j && !j.done && (T = B.return) && T.call(B);
                        } finally {
                          if (P)
                            throw P.error;
                        }
                      }
                    } else
                      this.nodes[y].isSelected = E, this.nodes[y].isIndeterminate = !1, L.set(y, E);
                    try {
                      for (var rt = m(L.entries()), et = rt.next(); !et.done; et = rt.next()) {
                        var Z = p(et.value, 2), dt = Z[0], vt = Z[1];
                        this.updateVnodeState(dt), !(this.selectionType === "leaf" && this.isParent(dt)) && (vt === !0 ? this.selectedCache.add(dt) : this.selectedCache.delete(dt));
                      }
                    } catch (bt) {
                      O = {
                        error: bt
                      };
                    } finally {
                      try {
                        et && !et.done && (S = rt.return) && S.call(rt);
                      } finally {
                        if (O)
                          throw O.error;
                      }
                    }
                  }
                },
                updateOpen: function(y, E) {
                  var C = this;
                  if (this.nodes.hasOwnProperty(y)) {
                    var x = this.nodes[y], b = Object(f.getObjectValueByPath)(x.item, this.itemChildren);
                    b && !b.length && x.vnode && !x.vnode.hasLoaded ? x.vnode.checkChildren().then(function() {
                      return C.updateOpen(y, E);
                    }) : b && b.length && (x.isOpen = E, x.isOpen ? this.openCache.add(y) : this.openCache.delete(y), this.updateVnodeState(y));
                  }
                },
                updateVnodeState: function(y) {
                  var E = this.nodes[y];
                  E && E.vnode && (E.vnode.isSelected = E.isSelected, E.vnode.isIndeterminate = E.isIndeterminate, E.vnode.isActive = E.isActive, E.vnode.isOpen = E.isOpen);
                },
                isExcluded: function(y) {
                  return !!this.search && this.excludedItems.has(y);
                }
              },
              render: function(y) {
                var E = this, C = this.items.length ? this.items.filter(function(x) {
                  return !E.isExcluded(Object(f.getObjectValueByPath)(x, E.itemKey));
                }).map(function(x) {
                  var b = a.default.options.methods.genChild.bind(E);
                  return b(x, E.disabled || Object(f.getObjectValueByPath)(x, E.itemDisabled));
                }) : this.$slots.default;
                return y("div", {
                  staticClass: "v-treeview",
                  class: h({
                    "v-treeview--hoverable": this.hoverable,
                    "v-treeview--dense": this.dense
                  }, this.themeClasses)
                }, C);
              }
            });
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeviewNode.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTreeview/VTreeviewNode.ts ***!
            \***************************************************/
          /*! exports provided: VTreeviewNodeProps, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VTreeviewNodeProps", function() {
              return m;
            });
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, c.apply(this, arguments);
            }, h = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], T;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (O) {
                T = {
                  error: O
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (T)
                    throw T.error;
                }
              }
              return P;
            }, p = function(y, E, C) {
              if (C || arguments.length === 2)
                for (var x = 0, b = E.length, P; x < b; x++)
                  (P || !(x in E)) && (P || (P = Array.prototype.slice.call(E, 0, x)), P[x] = E[x]);
              return y.concat(P || Array.prototype.slice.call(E));
            }, g = Object(d.default)(f.default, Object(l.inject)("treeview")), m = {
              activatable: Boolean,
              activeClass: {
                type: String,
                default: "v-treeview-node--active"
              },
              color: {
                type: String,
                default: "primary"
              },
              disablePerNode: Boolean,
              expandIcon: {
                type: String,
                default: "$subgroup"
              },
              indeterminateIcon: {
                type: String,
                default: "$checkboxIndeterminate"
              },
              itemChildren: {
                type: String,
                default: "children"
              },
              itemDisabled: {
                type: String,
                default: "disabled"
              },
              itemKey: {
                type: String,
                default: "id"
              },
              itemText: {
                type: String,
                default: "name"
              },
              loadChildren: Function,
              loadingIcon: {
                type: String,
                default: "$loading"
              },
              offIcon: {
                type: String,
                default: "$checkboxOff"
              },
              onIcon: {
                type: String,
                default: "$checkboxOn"
              },
              openOnClick: Boolean,
              rounded: Boolean,
              selectable: Boolean,
              selectedColor: {
                type: String,
                default: "accent"
              },
              shaped: Boolean,
              transition: Boolean,
              selectionType: {
                type: String,
                default: "leaf",
                validator: function(E) {
                  return ["leaf", "independent"].includes(E);
                }
              }
            }, v = g.extend().extend({
              name: "v-treeview-node",
              inject: {
                treeview: {
                  default: null
                }
              },
              props: c({
                level: Number,
                item: {
                  type: Object,
                  default: function() {
                    return null;
                  }
                },
                parentIsDisabled: Boolean
              }, m),
              data: function() {
                return {
                  hasLoaded: !1,
                  isActive: !1,
                  isIndeterminate: !1,
                  isLoading: !1,
                  isOpen: !1,
                  isSelected: !1
                  // Node is selected (checkbox)
                };
              },
              computed: {
                disabled: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemDisabled) || !this.disablePerNode && this.parentIsDisabled && this.selectionType === "leaf";
                },
                key: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemKey);
                },
                children: function() {
                  var E = this, C = Object(u.getObjectValueByPath)(this.item, this.itemChildren);
                  return C && C.filter(function(x) {
                    return !E.treeview.isExcluded(Object(u.getObjectValueByPath)(x, E.itemKey));
                  });
                },
                text: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemText);
                },
                scopedProps: function() {
                  return {
                    item: this.item,
                    leaf: !this.children,
                    selected: this.isSelected,
                    indeterminate: this.isIndeterminate,
                    active: this.isActive,
                    open: this.isOpen
                  };
                },
                computedIcon: function() {
                  return this.isIndeterminate ? this.indeterminateIcon : this.isSelected ? this.onIcon : this.offIcon;
                },
                hasChildren: function() {
                  return !!this.children && (!!this.children.length || !!this.loadChildren);
                }
              },
              created: function() {
                this.treeview.register(this);
              },
              beforeDestroy: function() {
                this.treeview.unregister(this);
              },
              methods: {
                checkChildren: function() {
                  var E = this;
                  return new Promise(function(C) {
                    if (!E.children || E.children.length || !E.loadChildren || E.hasLoaded)
                      return C();
                    E.isLoading = !0, C(E.loadChildren(E.item));
                  }).then(function() {
                    E.isLoading = !1, E.hasLoaded = !0;
                  });
                },
                open: function() {
                  this.isOpen = !this.isOpen, this.treeview.updateOpen(this.key, this.isOpen), this.treeview.emitOpen();
                },
                genLabel: function() {
                  var E = [];
                  return this.$scopedSlots.label ? E.push(this.$scopedSlots.label(this.scopedProps)) : E.push(this.text), this.$createElement("div", {
                    slot: "label",
                    staticClass: "v-treeview-node__label"
                  }, E);
                },
                genPrependSlot: function() {
                  return this.$scopedSlots.prepend ? this.$createElement("div", {
                    staticClass: "v-treeview-node__prepend"
                  }, this.$scopedSlots.prepend(this.scopedProps)) : null;
                },
                genAppendSlot: function() {
                  return this.$scopedSlots.append ? this.$createElement("div", {
                    staticClass: "v-treeview-node__append"
                  }, this.$scopedSlots.append(this.scopedProps)) : null;
                },
                genContent: function() {
                  var E = [this.genPrependSlot(), this.genLabel(), this.genAppendSlot()];
                  return this.$createElement("div", {
                    staticClass: "v-treeview-node__content"
                  }, E);
                },
                genToggle: function() {
                  var E = this;
                  return this.$createElement(o.VIcon, {
                    staticClass: "v-treeview-node__toggle",
                    class: {
                      "v-treeview-node__toggle--open": this.isOpen,
                      "v-treeview-node__toggle--loading": this.isLoading
                    },
                    slot: "prepend",
                    on: {
                      click: function(x) {
                        x.stopPropagation(), !E.isLoading && E.checkChildren().then(function() {
                          return E.open();
                        });
                      }
                    }
                  }, [this.isLoading ? this.loadingIcon : this.expandIcon]);
                },
                genCheckbox: function() {
                  var E = this;
                  return this.$createElement(o.VIcon, {
                    staticClass: "v-treeview-node__checkbox",
                    props: {
                      color: this.isSelected || this.isIndeterminate ? this.selectedColor : void 0,
                      disabled: this.disabled
                    },
                    on: {
                      click: function(x) {
                        x.stopPropagation(), !E.isLoading && E.checkChildren().then(function() {
                          E.$nextTick(function() {
                            E.isSelected = !E.isSelected, E.isIndeterminate = !1, E.treeview.updateSelected(E.key, E.isSelected), E.treeview.emitSelected();
                          });
                        });
                      }
                    }
                  }, [this.computedIcon]);
                },
                genLevel: function(E) {
                  var C = this;
                  return Object(u.createRange)(E).map(function() {
                    return C.$createElement("div", {
                      staticClass: "v-treeview-node__level"
                    });
                  });
                },
                genNode: function() {
                  var E, C = this, x = [this.genContent()];
                  return this.selectable && x.unshift(this.genCheckbox()), this.hasChildren ? x.unshift(this.genToggle()) : x.unshift.apply(x, p([], h(this.genLevel(1)), !1)), x.unshift.apply(x, p([], h(this.genLevel(this.level)), !1)), this.$createElement("div", this.setTextColor(this.isActive && this.color, {
                    staticClass: "v-treeview-node__root",
                    class: (E = {}, E[this.activeClass] = this.isActive, E),
                    on: {
                      click: function() {
                        C.openOnClick && C.hasChildren ? C.checkChildren().then(C.open) : C.activatable && !C.disabled && (C.isActive = !C.isActive, C.treeview.updateActive(C.key, C.isActive), C.treeview.emitActive());
                      }
                    }
                  }), x);
                },
                genChild: function(E, C) {
                  return this.$createElement(v, {
                    key: Object(u.getObjectValueByPath)(E, this.itemKey),
                    props: {
                      activatable: this.activatable,
                      activeClass: this.activeClass,
                      item: E,
                      selectable: this.selectable,
                      selectedColor: this.selectedColor,
                      color: this.color,
                      disablePerNode: this.disablePerNode,
                      expandIcon: this.expandIcon,
                      indeterminateIcon: this.indeterminateIcon,
                      offIcon: this.offIcon,
                      onIcon: this.onIcon,
                      loadingIcon: this.loadingIcon,
                      itemKey: this.itemKey,
                      itemText: this.itemText,
                      itemDisabled: this.itemDisabled,
                      itemChildren: this.itemChildren,
                      loadChildren: this.loadChildren,
                      transition: this.transition,
                      openOnClick: this.openOnClick,
                      rounded: this.rounded,
                      shaped: this.shaped,
                      level: this.level + 1,
                      selectionType: this.selectionType,
                      parentIsDisabled: C
                    },
                    scopedSlots: this.$scopedSlots
                  });
                },
                genChildrenWrapper: function() {
                  var E = this;
                  if (!this.isOpen || !this.children)
                    return null;
                  var C = [this.children.map(function(x) {
                    return E.genChild(x, E.disabled);
                  })];
                  return this.$createElement("div", {
                    staticClass: "v-treeview-node__children"
                  }, C);
                },
                genTransition: function() {
                  return this.$createElement(a.VExpandTransition, [this.genChildrenWrapper()]);
                }
              },
              render: function(E) {
                var C = [this.genNode()];
                return this.transition ? C.push(this.genTransition()) : C.push(this.genChildrenWrapper()), E("div", {
                  staticClass: "v-treeview-node",
                  class: {
                    "v-treeview-node--leaf": !this.hasChildren,
                    "v-treeview-node--click": this.openOnClick,
                    "v-treeview-node--disabled": this.disabled,
                    "v-treeview-node--rounded": this.rounded,
                    "v-treeview-node--shaped": this.shaped,
                    "v-treeview-node--selected": this.isSelected
                  },
                  attrs: {
                    "aria-expanded": String(this.isOpen)
                  }
                }, C);
              }
            });
            r.default = v;
          }
        ),
        /***/
        "./src/components/VTreeview/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTreeview/index.ts ***!
            \*******************************************/
          /*! exports provided: VTreeview, VTreeviewNode, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTreeview */
              "./src/components/VTreeview/VTreeview.ts"
            );
            i.d(r, "VTreeview", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTreeviewNode */
              "./src/components/VTreeview/VTreeviewNode.ts"
            );
            i.d(r, "VTreeviewNode", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTreeview: a.default,
                VTreeviewNode: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTreeview/util/filterTreeItems.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VTreeview/util/filterTreeItems.ts ***!
            \**********************************************************/
          /*! exports provided: filterTreeItem, filterTreeItems */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "filterTreeItem", function() {
              return o;
            }), i.d(r, "filterTreeItems", function() {
              return l;
            });
            var a = i(
              /*! ../../../util/helpers */
              "./src/util/helpers.ts"
            );
            function o(f, d, u) {
              var c = Object(a.getObjectValueByPath)(f, u);
              return c.toLocaleLowerCase().indexOf(d.toLocaleLowerCase()) > -1;
            }
            function l(f, d, u, c, h, p, g) {
              if (f(d, u, h))
                return !0;
              var m = Object(a.getObjectValueByPath)(d, p);
              if (m) {
                for (var v = !1, y = 0; y < m.length; y++)
                  l(f, m[y], u, c, h, p, g) && (v = !0);
                if (v)
                  return !0;
              }
              return g.add(Object(a.getObjectValueByPath)(d, c)), !1;
            }
          }
        ),
        /***/
        "./src/components/VVirtualScroll/VVirtualScroll.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VVirtualScroll/VVirtualScroll.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VVirtualScroll/VVirtualScroll.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VVirtualScroll/VVirtualScroll.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VVirtualScroll.sass */
              "./src/components/VVirtualScroll/VVirtualScroll.sass"
            );
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../directives/scroll */
              "./src/directives/scroll/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = a.default.extend({
              name: "v-virtual-scroll",
              directives: {
                Scroll: o.default
              },
              props: {
                bench: {
                  type: [Number, String],
                  default: 0
                },
                itemHeight: {
                  type: [Number, String],
                  required: !0
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              data: function() {
                return {
                  first: 0,
                  last: 0,
                  scrollTop: 0
                };
              },
              computed: {
                __bench: function() {
                  return parseInt(this.bench, 10);
                },
                __itemHeight: function() {
                  return parseInt(this.itemHeight, 10);
                },
                firstToRender: function() {
                  return Math.max(0, this.first - this.__bench);
                },
                lastToRender: function() {
                  return Math.min(this.items.length, this.last + this.__bench);
                }
              },
              watch: {
                height: "onScroll",
                itemHeight: "onScroll"
              },
              mounted: function() {
                this.last = this.getLast(0);
              },
              methods: {
                getChildren: function() {
                  return this.items.slice(this.firstToRender, this.lastToRender).map(this.genChild);
                },
                genChild: function(d, u) {
                  u += this.firstToRender;
                  var c = Object(l.convertToUnit)(u * this.__itemHeight);
                  return this.$createElement("div", {
                    staticClass: "v-virtual-scroll__item",
                    style: {
                      top: c
                    },
                    key: u
                  }, Object(l.getSlot)(this, "default", {
                    index: u,
                    item: d
                  }));
                },
                getFirst: function() {
                  return Math.floor(this.scrollTop / this.__itemHeight);
                },
                getLast: function(d) {
                  var u = parseInt(this.height || 0, 10) || this.$el.clientHeight;
                  return d + Math.ceil(u / this.__itemHeight);
                },
                onScroll: function() {
                  this.scrollTop = this.$el.scrollTop, this.first = this.getFirst(), this.last = this.getLast(this.first);
                }
              },
              render: function(d) {
                var u = d("div", {
                  staticClass: "v-virtual-scroll__container",
                  style: {
                    height: Object(l.convertToUnit)(this.items.length * this.__itemHeight)
                  }
                }, this.getChildren());
                return d("div", {
                  staticClass: "v-virtual-scroll",
                  style: this.measurableStyles,
                  directives: [{
                    name: "scroll",
                    modifiers: {
                      self: !0
                    },
                    value: this.onScroll
                  }],
                  on: this.$listeners
                }, [u]);
              }
            });
          }
        ),
        /***/
        "./src/components/VVirtualScroll/index.ts": (
          /*!************************************************!*\
            !*** ./src/components/VVirtualScroll/index.ts ***!
            \************************************************/
          /*! exports provided: VVirtualScroll, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VVirtualScroll */
              "./src/components/VVirtualScroll/VVirtualScroll.ts"
            );
            i.d(r, "VVirtualScroll", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VWindow/VWindow.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VWindow/VWindow.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VWindow/VWindow.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VWindow/VWindow.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VWindow.sass */
              "./src/components/VWindow/VWindow.sass"
            );
            var a = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = f.BaseItemGroup.extend({
              name: "v-window",
              directives: {
                Touch: a.default
              },
              provide: function() {
                return {
                  windowGroup: this
                };
              },
              props: {
                activeClass: {
                  type: String,
                  default: "v-window-item--active"
                },
                continuous: Boolean,
                mandatory: {
                  type: Boolean,
                  default: !0
                },
                nextIcon: {
                  type: [Boolean, String],
                  default: "$next"
                },
                prevIcon: {
                  type: [Boolean, String],
                  default: "$prev"
                },
                reverse: Boolean,
                showArrows: Boolean,
                showArrowsOnHover: Boolean,
                touch: Object,
                touchless: Boolean,
                value: {
                  required: !1
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  changedByDelimiters: !1,
                  internalHeight: void 0,
                  transitionHeight: void 0,
                  transitionCount: 0,
                  isBooted: !1,
                  isReverse: !1
                };
              },
              computed: {
                isActive: function() {
                  return this.transitionCount > 0;
                },
                classes: function() {
                  return d(d({}, f.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-window--show-arrows-on-hover": this.showArrowsOnHover
                  });
                },
                computedTransition: function() {
                  if (!this.isBooted)
                    return "";
                  var c = this.vertical ? "y" : "x", h = this.internalReverse ? !this.isReverse : this.isReverse, p = h ? "-reverse" : "";
                  return "v-window-" + c + p + "-transition";
                },
                hasActiveItems: function() {
                  return !!this.items.find(function(c) {
                    return !c.disabled;
                  });
                },
                hasNext: function() {
                  return this.continuous || this.internalIndex < this.items.length - 1;
                },
                hasPrev: function() {
                  return this.continuous || this.internalIndex > 0;
                },
                internalIndex: function() {
                  var c = this;
                  return this.items.findIndex(function(h, p) {
                    return c.internalValue === c.getValue(h, p);
                  });
                },
                internalReverse: function() {
                  return this.$vuetify.rtl ? !this.reverse : this.reverse;
                }
              },
              watch: {
                internalIndex: function(c, h) {
                  this.isReverse = this.updateReverse(c, h);
                }
              },
              mounted: function() {
                var c = this;
                window.requestAnimationFrame(function() {
                  return c.isBooted = !0;
                });
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$slots.default;
                },
                genContainer: function() {
                  var c = [this.genDefaultSlot()];
                  return this.showArrows && c.push(this.genControlIcons()), this.$createElement("div", {
                    staticClass: "v-window__container",
                    class: {
                      "v-window__container--is-active": this.isActive
                    },
                    style: {
                      height: this.internalHeight || this.transitionHeight
                    }
                  }, c);
                },
                genIcon: function(c, h, p) {
                  var g = this, m, v, y, E = {
                    click: function(P) {
                      P.stopPropagation(), g.changedByDelimiters = !0, p();
                    }
                  }, C = {
                    "aria-label": this.$vuetify.lang.t("$vuetify.carousel." + c)
                  }, x = (y = (v = (m = this.$scopedSlots)[c]) === null || v === void 0 ? void 0 : v.call(m, {
                    on: E,
                    attrs: C
                  })) !== null && y !== void 0 ? y : [this.$createElement(o.default, {
                    props: {
                      icon: !0
                    },
                    attrs: C,
                    on: E
                  }, [this.$createElement(l.default, {
                    props: {
                      large: !0
                    }
                  }, h)])];
                  return this.$createElement("div", {
                    staticClass: "v-window__" + c
                  }, x);
                },
                genControlIcons: function() {
                  var c = [], h = this.$vuetify.rtl ? this.nextIcon : this.prevIcon;
                  if (this.hasPrev && h && typeof h == "string") {
                    var p = this.genIcon("prev", h, this.prev);
                    p && c.push(p);
                  }
                  var g = this.$vuetify.rtl ? this.prevIcon : this.nextIcon;
                  if (this.hasNext && g && typeof g == "string") {
                    var p = this.genIcon("next", g, this.next);
                    p && c.push(p);
                  }
                  return c;
                },
                getNextIndex: function(c) {
                  var h = (c + 1) % this.items.length, p = this.items[h];
                  return p.disabled ? this.getNextIndex(h) : h;
                },
                getPrevIndex: function(c) {
                  var h = (c + this.items.length - 1) % this.items.length, p = this.items[h];
                  return p.disabled ? this.getPrevIndex(h) : h;
                },
                next: function() {
                  if (!(!this.hasActiveItems || !this.hasNext)) {
                    var c = this.getNextIndex(this.internalIndex), h = this.items[c];
                    this.internalValue = this.getValue(h, c);
                  }
                },
                prev: function() {
                  if (!(!this.hasActiveItems || !this.hasPrev)) {
                    var c = this.getPrevIndex(this.internalIndex), h = this.items[c];
                    this.internalValue = this.getValue(h, c);
                  }
                },
                updateReverse: function(c, h) {
                  var p = this.items.length, g = p - 1;
                  return p <= 2 ? c < h : c === g && h === 0 ? !0 : c === 0 && h === g ? !1 : c < h;
                }
              },
              render: function(c) {
                var h = this, p = {
                  staticClass: "v-window",
                  class: this.classes,
                  directives: []
                };
                if (!this.touchless) {
                  var g = this.touch || {
                    left: function() {
                      h.$vuetify.rtl ? h.prev() : h.next();
                    },
                    right: function() {
                      h.$vuetify.rtl ? h.next() : h.prev();
                    },
                    end: function(v) {
                      v.stopPropagation();
                    },
                    start: function(v) {
                      v.stopPropagation();
                    }
                  };
                  p.directives.push({
                    name: "touch",
                    value: g
                  });
                }
                return c("div", p, [this.genContainer()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VWindow/VWindowItem.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VWindow/VWindowItem.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), o = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), l = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = Object(d.default)(a.default, Object(o.factory)("windowGroup", "v-window-item", "v-window"));
            r.default = u.extend().extend().extend({
              name: "v-window-item",
              directives: {
                Touch: l.default
              },
              props: {
                disabled: Boolean,
                reverseTransition: {
                  type: [Boolean, String],
                  default: void 0
                },
                transition: {
                  type: [Boolean, String],
                  default: void 0
                },
                value: {
                  required: !1
                }
              },
              data: function() {
                return {
                  isActive: !1,
                  inTransition: !1
                };
              },
              computed: {
                classes: function() {
                  return this.groupClasses;
                },
                computedTransition: function() {
                  return this.windowGroup.internalReverse ? typeof this.reverseTransition < "u" ? this.reverseTransition || "" : this.windowGroup.computedTransition : typeof this.transition < "u" ? this.transition || "" : this.windowGroup.computedTransition;
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$slots.default;
                },
                genWindowItem: function() {
                  return this.$createElement("div", {
                    staticClass: "v-window-item",
                    class: this.classes,
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }],
                    on: this.$listeners
                  }, this.genDefaultSlot());
                },
                onAfterTransition: function() {
                  this.inTransition && (this.inTransition = !1, this.windowGroup.transitionCount > 0 && (this.windowGroup.transitionCount--, this.windowGroup.transitionCount === 0 && (this.windowGroup.transitionHeight = void 0)));
                },
                onBeforeTransition: function() {
                  this.inTransition || (this.inTransition = !0, this.windowGroup.transitionCount === 0 && (this.windowGroup.transitionHeight = Object(f.convertToUnit)(this.windowGroup.$el.clientHeight)), this.windowGroup.transitionCount++);
                },
                onTransitionCancelled: function() {
                  this.onAfterTransition();
                },
                onEnter: function(h) {
                  var p = this;
                  this.inTransition && this.$nextTick(function() {
                    !p.computedTransition || !p.inTransition || (p.windowGroup.transitionHeight = Object(f.convertToUnit)(h.clientHeight));
                  });
                }
              },
              render: function(h) {
                var p = this;
                return h("transition", {
                  props: {
                    name: this.computedTransition
                  },
                  on: {
                    // Handlers for enter windows.
                    beforeEnter: this.onBeforeTransition,
                    afterEnter: this.onAfterTransition,
                    enterCancelled: this.onTransitionCancelled,
                    // Handlers for leave windows.
                    beforeLeave: this.onBeforeTransition,
                    afterLeave: this.onAfterTransition,
                    leaveCancelled: this.onTransitionCancelled,
                    // Enter handler for height transition.
                    enter: this.onEnter
                  }
                }, this.showLazyContent(function() {
                  return [p.genWindowItem()];
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VWindow/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VWindow/index.ts ***!
            \*****************************************/
          /*! exports provided: VWindow, VWindowItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VWindow */
              "./src/components/VWindow/VWindow.ts"
            );
            i.d(r, "VWindow", function() {
              return a.default;
            });
            var o = i(
              /*! ./VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            );
            i.d(r, "VWindowItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VWindow: a.default,
                VWindowItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/index.ts": (
          /*!*********************************!*\
            !*** ./src/components/index.ts ***!
            \*********************************/
          /*! exports provided: VApp, VAppBar, VAppBarNavIcon, VAppBarTitle, VAlert, VAutocomplete, VAvatar, VBadge, VBanner, VBottomNavigation, VBottomSheet, VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, VBtn, VBtnToggle, VCalendar, VCalendarCategory, VCalendarDaily, VCalendarWeekly, VCalendarMonthly, VCard, VCardActions, VCardSubtitle, VCardText, VCardTitle, VCarousel, VCarouselItem, VCheckbox, VSimpleCheckbox, VChip, VChipGroup, VColorPicker, VColorPickerSwatches, VColorPickerCanvas, VContent, VCombobox, VCounter, VData, VDataIterator, VDataFooter, VDataTable, VEditDialog, VTableOverflow, VDataTableHeader, VSimpleTable, VVirtualTable, VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, VDialog, VDivider, VExpansionPanels, VExpansionPanel, VExpansionPanelHeader, VExpansionPanelContent, VFileInput, VFooter, VForm, VContainer, VCol, VRow, VSpacer, VLayout, VFlex, VHover, VIcon, VImg, VInput, VItem, VItemGroup, VLabel, VLazy, VListItemActionText, VListItemContent, VListItemTitle, VListItemSubtitle, VList, VListGroup, VListItem, VListItemAction, VListItemAvatar, VListItemIcon, VListItemGroup, VMain, VMenu, VMessages, VNavigationDrawer, VOtpInput, VOverflowBtn, VOverlay, VPagination, VSheet, VParallax, VPicker, VProgressCircular, VProgressLinear, VRadioGroup, VRadio, VRangeSlider, VRating, VResponsive, VSelect, VSkeletonLoader, VSlider, VSlideGroup, VSlideItem, VSnackbar, VSparkline, VSpeedDial, VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, VSubheader, VSwitch, VSystemBar, VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, VTextarea, VTextField, VThemeProvider, VTimeline, VTimelineItem, VTimePicker, VTimePickerClock, VTimePickerTitle, VToolbar, VToolbarItems, VToolbarTitle, VTooltip, VTreeview, VTreeviewNode, VVirtualScroll, VWindow, VWindowItem, VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VDialogTopTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VExpandXTransition */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VApp */
              "./src/components/VApp/index.ts"
            );
            i.d(r, "VApp", function() {
              return a.VApp;
            });
            var o = i(
              /*! ./VAppBar */
              "./src/components/VAppBar/index.ts"
            );
            i.d(r, "VAppBar", function() {
              return o.VAppBar;
            }), i.d(r, "VAppBarNavIcon", function() {
              return o.VAppBarNavIcon;
            }), i.d(r, "VAppBarTitle", function() {
              return o.VAppBarTitle;
            });
            var l = i(
              /*! ./VAlert */
              "./src/components/VAlert/index.ts"
            );
            i.d(r, "VAlert", function() {
              return l.VAlert;
            });
            var f = i(
              /*! ./VAutocomplete */
              "./src/components/VAutocomplete/index.ts"
            );
            i.d(r, "VAutocomplete", function() {
              return f.VAutocomplete;
            });
            var d = i(
              /*! ./VAvatar */
              "./src/components/VAvatar/index.ts"
            );
            i.d(r, "VAvatar", function() {
              return d.VAvatar;
            });
            var u = i(
              /*! ./VBadge */
              "./src/components/VBadge/index.ts"
            );
            i.d(r, "VBadge", function() {
              return u.VBadge;
            });
            var c = i(
              /*! ./VBanner */
              "./src/components/VBanner/index.ts"
            );
            i.d(r, "VBanner", function() {
              return c.VBanner;
            });
            var h = i(
              /*! ./VBottomNavigation */
              "./src/components/VBottomNavigation/index.ts"
            );
            i.d(r, "VBottomNavigation", function() {
              return h.VBottomNavigation;
            });
            var p = i(
              /*! ./VBottomSheet */
              "./src/components/VBottomSheet/index.ts"
            );
            i.d(r, "VBottomSheet", function() {
              return p.VBottomSheet;
            });
            var g = i(
              /*! ./VBreadcrumbs */
              "./src/components/VBreadcrumbs/index.ts"
            );
            i.d(r, "VBreadcrumbs", function() {
              return g.VBreadcrumbs;
            }), i.d(r, "VBreadcrumbsItem", function() {
              return g.VBreadcrumbsItem;
            }), i.d(r, "VBreadcrumbsDivider", function() {
              return g.VBreadcrumbsDivider;
            });
            var m = i(
              /*! ./VBtn */
              "./src/components/VBtn/index.ts"
            );
            i.d(r, "VBtn", function() {
              return m.VBtn;
            });
            var v = i(
              /*! ./VBtnToggle */
              "./src/components/VBtnToggle/index.ts"
            );
            i.d(r, "VBtnToggle", function() {
              return v.VBtnToggle;
            });
            var y = i(
              /*! ./VCalendar */
              "./src/components/VCalendar/index.ts"
            );
            i.d(r, "VCalendar", function() {
              return y.VCalendar;
            }), i.d(r, "VCalendarCategory", function() {
              return y.VCalendarCategory;
            }), i.d(r, "VCalendarDaily", function() {
              return y.VCalendarDaily;
            }), i.d(r, "VCalendarWeekly", function() {
              return y.VCalendarWeekly;
            }), i.d(r, "VCalendarMonthly", function() {
              return y.VCalendarMonthly;
            });
            var E = i(
              /*! ./VCard */
              "./src/components/VCard/index.ts"
            );
            i.d(r, "VCard", function() {
              return E.VCard;
            }), i.d(r, "VCardActions", function() {
              return E.VCardActions;
            }), i.d(r, "VCardSubtitle", function() {
              return E.VCardSubtitle;
            }), i.d(r, "VCardText", function() {
              return E.VCardText;
            }), i.d(r, "VCardTitle", function() {
              return E.VCardTitle;
            });
            var C = i(
              /*! ./VCarousel */
              "./src/components/VCarousel/index.ts"
            );
            i.d(r, "VCarousel", function() {
              return C.VCarousel;
            }), i.d(r, "VCarouselItem", function() {
              return C.VCarouselItem;
            });
            var x = i(
              /*! ./VCheckbox */
              "./src/components/VCheckbox/index.ts"
            );
            i.d(r, "VCheckbox", function() {
              return x.VCheckbox;
            }), i.d(r, "VSimpleCheckbox", function() {
              return x.VSimpleCheckbox;
            });
            var b = i(
              /*! ./VChip */
              "./src/components/VChip/index.ts"
            );
            i.d(r, "VChip", function() {
              return b.VChip;
            });
            var P = i(
              /*! ./VChipGroup */
              "./src/components/VChipGroup/index.ts"
            );
            i.d(r, "VChipGroup", function() {
              return P.VChipGroup;
            });
            var T = i(
              /*! ./VColorPicker */
              "./src/components/VColorPicker/index.ts"
            );
            i.d(r, "VColorPicker", function() {
              return T.VColorPicker;
            }), i.d(r, "VColorPickerSwatches", function() {
              return T.VColorPickerSwatches;
            }), i.d(r, "VColorPickerCanvas", function() {
              return T.VColorPickerCanvas;
            });
            var O = i(
              /*! ./VContent */
              "./src/components/VContent/index.ts"
            );
            i.d(r, "VContent", function() {
              return O.VContent;
            });
            var S = i(
              /*! ./VCombobox */
              "./src/components/VCombobox/index.ts"
            );
            i.d(r, "VCombobox", function() {
              return S.VCombobox;
            });
            var L = i(
              /*! ./VCounter */
              "./src/components/VCounter/index.ts"
            );
            i.d(r, "VCounter", function() {
              return L.VCounter;
            });
            var A = i(
              /*! ./VData */
              "./src/components/VData/index.ts"
            );
            i.d(r, "VData", function() {
              return A.VData;
            });
            var D = i(
              /*! ./VDataIterator */
              "./src/components/VDataIterator/index.ts"
            );
            i.d(r, "VDataIterator", function() {
              return D.VDataIterator;
            }), i.d(r, "VDataFooter", function() {
              return D.VDataFooter;
            });
            var _ = i(
              /*! ./VDataTable */
              "./src/components/VDataTable/index.ts"
            );
            i.d(r, "VDataTable", function() {
              return _.VDataTable;
            }), i.d(r, "VEditDialog", function() {
              return _.VEditDialog;
            }), i.d(r, "VTableOverflow", function() {
              return _.VTableOverflow;
            }), i.d(r, "VDataTableHeader", function() {
              return _.VDataTableHeader;
            }), i.d(r, "VSimpleTable", function() {
              return _.VSimpleTable;
            }), i.d(r, "VVirtualTable", function() {
              return _.VVirtualTable;
            });
            var w = i(
              /*! ./VDatePicker */
              "./src/components/VDatePicker/index.ts"
            );
            i.d(r, "VDatePicker", function() {
              return w.VDatePicker;
            }), i.d(r, "VDatePickerTitle", function() {
              return w.VDatePickerTitle;
            }), i.d(r, "VDatePickerHeader", function() {
              return w.VDatePickerHeader;
            }), i.d(r, "VDatePickerDateTable", function() {
              return w.VDatePickerDateTable;
            }), i.d(r, "VDatePickerMonthTable", function() {
              return w.VDatePickerMonthTable;
            }), i.d(r, "VDatePickerYears", function() {
              return w.VDatePickerYears;
            });
            var B = i(
              /*! ./VDialog */
              "./src/components/VDialog/index.ts"
            );
            i.d(r, "VDialog", function() {
              return B.VDialog;
            });
            var j = i(
              /*! ./VDivider */
              "./src/components/VDivider/index.ts"
            );
            i.d(r, "VDivider", function() {
              return j.VDivider;
            });
            var k = i(
              /*! ./VExpansionPanel */
              "./src/components/VExpansionPanel/index.ts"
            );
            i.d(r, "VExpansionPanels", function() {
              return k.VExpansionPanels;
            }), i.d(r, "VExpansionPanel", function() {
              return k.VExpansionPanel;
            }), i.d(r, "VExpansionPanelHeader", function() {
              return k.VExpansionPanelHeader;
            }), i.d(r, "VExpansionPanelContent", function() {
              return k.VExpansionPanelContent;
            });
            var X = i(
              /*! ./VFileInput */
              "./src/components/VFileInput/index.ts"
            );
            i.d(r, "VFileInput", function() {
              return X.VFileInput;
            });
            var rt = i(
              /*! ./VFooter */
              "./src/components/VFooter/index.ts"
            );
            i.d(r, "VFooter", function() {
              return rt.VFooter;
            });
            var et = i(
              /*! ./VForm */
              "./src/components/VForm/index.ts"
            );
            i.d(r, "VForm", function() {
              return et.VForm;
            });
            var Z = i(
              /*! ./VGrid */
              "./src/components/VGrid/index.ts"
            );
            i.d(r, "VContainer", function() {
              return Z.VContainer;
            }), i.d(r, "VCol", function() {
              return Z.VCol;
            }), i.d(r, "VRow", function() {
              return Z.VRow;
            }), i.d(r, "VSpacer", function() {
              return Z.VSpacer;
            }), i.d(r, "VLayout", function() {
              return Z.VLayout;
            }), i.d(r, "VFlex", function() {
              return Z.VFlex;
            });
            var dt = i(
              /*! ./VHover */
              "./src/components/VHover/index.ts"
            );
            i.d(r, "VHover", function() {
              return dt.VHover;
            });
            var vt = i(
              /*! ./VIcon */
              "./src/components/VIcon/index.ts"
            );
            i.d(r, "VIcon", function() {
              return vt.VIcon;
            });
            var bt = i(
              /*! ./VImg */
              "./src/components/VImg/index.ts"
            );
            i.d(r, "VImg", function() {
              return bt.VImg;
            });
            var it = i(
              /*! ./VInput */
              "./src/components/VInput/index.ts"
            );
            i.d(r, "VInput", function() {
              return it.VInput;
            });
            var R = i(
              /*! ./VItemGroup */
              "./src/components/VItemGroup/index.ts"
            );
            i.d(r, "VItem", function() {
              return R.VItem;
            }), i.d(r, "VItemGroup", function() {
              return R.VItemGroup;
            });
            var V = i(
              /*! ./VLabel */
              "./src/components/VLabel/index.ts"
            );
            i.d(r, "VLabel", function() {
              return V.VLabel;
            });
            var tt = i(
              /*! ./VLazy */
              "./src/components/VLazy/index.ts"
            );
            i.d(r, "VLazy", function() {
              return tt.VLazy;
            });
            var Y = i(
              /*! ./VList */
              "./src/components/VList/index.ts"
            );
            i.d(r, "VListItemActionText", function() {
              return Y.VListItemActionText;
            }), i.d(r, "VListItemContent", function() {
              return Y.VListItemContent;
            }), i.d(r, "VListItemTitle", function() {
              return Y.VListItemTitle;
            }), i.d(r, "VListItemSubtitle", function() {
              return Y.VListItemSubtitle;
            }), i.d(r, "VList", function() {
              return Y.VList;
            }), i.d(r, "VListGroup", function() {
              return Y.VListGroup;
            }), i.d(r, "VListItem", function() {
              return Y.VListItem;
            }), i.d(r, "VListItemAction", function() {
              return Y.VListItemAction;
            }), i.d(r, "VListItemAvatar", function() {
              return Y.VListItemAvatar;
            }), i.d(r, "VListItemIcon", function() {
              return Y.VListItemIcon;
            }), i.d(r, "VListItemGroup", function() {
              return Y.VListItemGroup;
            });
            var $ = i(
              /*! ./VMain */
              "./src/components/VMain/index.ts"
            );
            i.d(r, "VMain", function() {
              return $.VMain;
            });
            var z = i(
              /*! ./VMenu */
              "./src/components/VMenu/index.ts"
            );
            i.d(r, "VMenu", function() {
              return z.VMenu;
            });
            var at = i(
              /*! ./VMessages */
              "./src/components/VMessages/index.ts"
            );
            i.d(r, "VMessages", function() {
              return at.VMessages;
            });
            var ct = i(
              /*! ./VNavigationDrawer */
              "./src/components/VNavigationDrawer/index.ts"
            );
            i.d(r, "VNavigationDrawer", function() {
              return ct.VNavigationDrawer;
            });
            var St = i(
              /*! ./VOtpInput */
              "./src/components/VOtpInput/index.ts"
            );
            i.d(r, "VOtpInput", function() {
              return St.VOtpInput;
            });
            var F = i(
              /*! ./VOverflowBtn */
              "./src/components/VOverflowBtn/index.ts"
            );
            i.d(r, "VOverflowBtn", function() {
              return F.VOverflowBtn;
            });
            var M = i(
              /*! ./VOverlay */
              "./src/components/VOverlay/index.ts"
            );
            i.d(r, "VOverlay", function() {
              return M.VOverlay;
            });
            var I = i(
              /*! ./VPagination */
              "./src/components/VPagination/index.ts"
            );
            i.d(r, "VPagination", function() {
              return I.VPagination;
            });
            var N = i(
              /*! ./VSheet */
              "./src/components/VSheet/index.ts"
            );
            i.d(r, "VSheet", function() {
              return N.VSheet;
            });
            var G = i(
              /*! ./VParallax */
              "./src/components/VParallax/index.ts"
            );
            i.d(r, "VParallax", function() {
              return G.VParallax;
            });
            var nt = i(
              /*! ./VPicker */
              "./src/components/VPicker/index.ts"
            );
            i.d(r, "VPicker", function() {
              return nt.VPicker;
            });
            var lt = i(
              /*! ./VProgressCircular */
              "./src/components/VProgressCircular/index.ts"
            );
            i.d(r, "VProgressCircular", function() {
              return lt.VProgressCircular;
            });
            var yt = i(
              /*! ./VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            );
            i.d(r, "VProgressLinear", function() {
              return yt.VProgressLinear;
            });
            var Lt = i(
              /*! ./VRadioGroup */
              "./src/components/VRadioGroup/index.ts"
            );
            i.d(r, "VRadioGroup", function() {
              return Lt.VRadioGroup;
            }), i.d(r, "VRadio", function() {
              return Lt.VRadio;
            });
            var Nt = i(
              /*! ./VRangeSlider */
              "./src/components/VRangeSlider/index.ts"
            );
            i.d(r, "VRangeSlider", function() {
              return Nt.VRangeSlider;
            });
            var Jt = i(
              /*! ./VRating */
              "./src/components/VRating/index.ts"
            );
            i.d(r, "VRating", function() {
              return Jt.VRating;
            });
            var J = i(
              /*! ./VResponsive */
              "./src/components/VResponsive/index.ts"
            );
            i.d(r, "VResponsive", function() {
              return J.VResponsive;
            });
            var ft = i(
              /*! ./VSelect */
              "./src/components/VSelect/index.ts"
            );
            i.d(r, "VSelect", function() {
              return ft.VSelect;
            });
            var Ct = i(
              /*! ./VSkeletonLoader */
              "./src/components/VSkeletonLoader/index.ts"
            );
            i.d(r, "VSkeletonLoader", function() {
              return Ct.VSkeletonLoader;
            });
            var Mt = i(
              /*! ./VSlider */
              "./src/components/VSlider/index.ts"
            );
            i.d(r, "VSlider", function() {
              return Mt.VSlider;
            });
            var Ot = i(
              /*! ./VSlideGroup */
              "./src/components/VSlideGroup/index.ts"
            );
            i.d(r, "VSlideGroup", function() {
              return Ot.VSlideGroup;
            }), i.d(r, "VSlideItem", function() {
              return Ot.VSlideItem;
            });
            var kt = i(
              /*! ./VSnackbar */
              "./src/components/VSnackbar/index.ts"
            );
            i.d(r, "VSnackbar", function() {
              return kt.VSnackbar;
            });
            var de = i(
              /*! ./VSparkline */
              "./src/components/VSparkline/index.ts"
            );
            i.d(r, "VSparkline", function() {
              return de.VSparkline;
            });
            var Pe = i(
              /*! ./VSpeedDial */
              "./src/components/VSpeedDial/index.ts"
            );
            i.d(r, "VSpeedDial", function() {
              return Pe.VSpeedDial;
            });
            var Me = i(
              /*! ./VStepper */
              "./src/components/VStepper/index.ts"
            );
            i.d(r, "VStepper", function() {
              return Me.VStepper;
            }), i.d(r, "VStepperContent", function() {
              return Me.VStepperContent;
            }), i.d(r, "VStepperStep", function() {
              return Me.VStepperStep;
            }), i.d(r, "VStepperHeader", function() {
              return Me.VStepperHeader;
            }), i.d(r, "VStepperItems", function() {
              return Me.VStepperItems;
            });
            var Ce = i(
              /*! ./VSubheader */
              "./src/components/VSubheader/index.ts"
            );
            i.d(r, "VSubheader", function() {
              return Ce.VSubheader;
            });
            var $e = i(
              /*! ./VSwitch */
              "./src/components/VSwitch/index.ts"
            );
            i.d(r, "VSwitch", function() {
              return $e.VSwitch;
            });
            var bn = i(
              /*! ./VSystemBar */
              "./src/components/VSystemBar/index.ts"
            );
            i.d(r, "VSystemBar", function() {
              return bn.VSystemBar;
            });
            var Ye = i(
              /*! ./VTabs */
              "./src/components/VTabs/index.ts"
            );
            i.d(r, "VTabs", function() {
              return Ye.VTabs;
            }), i.d(r, "VTab", function() {
              return Ye.VTab;
            }), i.d(r, "VTabItem", function() {
              return Ye.VTabItem;
            }), i.d(r, "VTabsItems", function() {
              return Ye.VTabsItems;
            }), i.d(r, "VTabsSlider", function() {
              return Ye.VTabsSlider;
            });
            var Hn = i(
              /*! ./VTextarea */
              "./src/components/VTextarea/index.ts"
            );
            i.d(r, "VTextarea", function() {
              return Hn.VTextarea;
            });
            var fn = i(
              /*! ./VTextField */
              "./src/components/VTextField/index.ts"
            );
            i.d(r, "VTextField", function() {
              return fn.VTextField;
            });
            var Fe = i(
              /*! ./VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            );
            i.d(r, "VThemeProvider", function() {
              return Fe.VThemeProvider;
            });
            var pn = i(
              /*! ./VTimeline */
              "./src/components/VTimeline/index.ts"
            );
            i.d(r, "VTimeline", function() {
              return pn.VTimeline;
            }), i.d(r, "VTimelineItem", function() {
              return pn.VTimelineItem;
            });
            var mn = i(
              /*! ./VTimePicker */
              "./src/components/VTimePicker/index.ts"
            );
            i.d(r, "VTimePicker", function() {
              return mn.VTimePicker;
            }), i.d(r, "VTimePickerClock", function() {
              return mn.VTimePickerClock;
            }), i.d(r, "VTimePickerTitle", function() {
              return mn.VTimePickerTitle;
            });
            var we = i(
              /*! ./VToolbar */
              "./src/components/VToolbar/index.ts"
            );
            i.d(r, "VToolbar", function() {
              return we.VToolbar;
            }), i.d(r, "VToolbarItems", function() {
              return we.VToolbarItems;
            }), i.d(r, "VToolbarTitle", function() {
              return we.VToolbarTitle;
            });
            var gn = i(
              /*! ./VTooltip */
              "./src/components/VTooltip/index.ts"
            );
            i.d(r, "VTooltip", function() {
              return gn.VTooltip;
            });
            var ze = i(
              /*! ./VTreeview */
              "./src/components/VTreeview/index.ts"
            );
            i.d(r, "VTreeview", function() {
              return ze.VTreeview;
            }), i.d(r, "VTreeviewNode", function() {
              return ze.VTreeviewNode;
            });
            var On = i(
              /*! ./VVirtualScroll */
              "./src/components/VVirtualScroll/index.ts"
            );
            i.d(r, "VVirtualScroll", function() {
              return On.VVirtualScroll;
            });
            var qe = i(
              /*! ./VWindow */
              "./src/components/VWindow/index.ts"
            );
            i.d(r, "VWindow", function() {
              return qe.VWindow;
            }), i.d(r, "VWindowItem", function() {
              return qe.VWindowItem;
            });
            var se = i(
              /*! ./transitions */
              "./src/components/transitions/index.ts"
            );
            i.d(r, "VCarouselTransition", function() {
              return se.VCarouselTransition;
            }), i.d(r, "VCarouselReverseTransition", function() {
              return se.VCarouselReverseTransition;
            }), i.d(r, "VTabTransition", function() {
              return se.VTabTransition;
            }), i.d(r, "VTabReverseTransition", function() {
              return se.VTabReverseTransition;
            }), i.d(r, "VMenuTransition", function() {
              return se.VMenuTransition;
            }), i.d(r, "VFabTransition", function() {
              return se.VFabTransition;
            }), i.d(r, "VDialogTransition", function() {
              return se.VDialogTransition;
            }), i.d(r, "VDialogBottomTransition", function() {
              return se.VDialogBottomTransition;
            }), i.d(r, "VDialogTopTransition", function() {
              return se.VDialogTopTransition;
            }), i.d(r, "VFadeTransition", function() {
              return se.VFadeTransition;
            }), i.d(r, "VScaleTransition", function() {
              return se.VScaleTransition;
            }), i.d(r, "VScrollXTransition", function() {
              return se.VScrollXTransition;
            }), i.d(r, "VScrollXReverseTransition", function() {
              return se.VScrollXReverseTransition;
            }), i.d(r, "VScrollYTransition", function() {
              return se.VScrollYTransition;
            }), i.d(r, "VScrollYReverseTransition", function() {
              return se.VScrollYReverseTransition;
            }), i.d(r, "VSlideXTransition", function() {
              return se.VSlideXTransition;
            }), i.d(r, "VSlideXReverseTransition", function() {
              return se.VSlideXReverseTransition;
            }), i.d(r, "VSlideYTransition", function() {
              return se.VSlideYTransition;
            }), i.d(r, "VSlideYReverseTransition", function() {
              return se.VSlideYReverseTransition;
            }), i.d(r, "VExpandTransition", function() {
              return se.VExpandTransition;
            }), i.d(r, "VExpandXTransition", function() {
              return se.VExpandXTransition;
            });
          }
        ),
        /***/
        "./src/components/transitions/createTransition.ts": (
          /*!********************************************************!*\
            !*** ./src/components/transitions/createTransition.ts ***!
            \********************************************************/
          /*! exports provided: createSimpleTransition, createJavascriptTransition */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createSimpleTransition", function() {
              return d;
            }), i.d(r, "createJavascriptTransition", function() {
              return u;
            });
            var a = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), o = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, l = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            function f(c) {
              var h;
              c === void 0 && (c = []);
              for (var p = [], g = 1; g < arguments.length; g++)
                p[g - 1] = arguments[g];
              return (h = Array()).concat.apply(h, l([c], o(p), !1));
            }
            function d(c, h, p) {
              return h === void 0 && (h = "top center 0"), {
                name: c,
                functional: !0,
                props: {
                  group: {
                    type: Boolean,
                    default: !1
                  },
                  hideOnLeave: {
                    type: Boolean,
                    default: !1
                  },
                  leaveAbsolute: {
                    type: Boolean,
                    default: !1
                  },
                  mode: {
                    type: String,
                    default: p
                  },
                  origin: {
                    type: String,
                    default: h
                  }
                },
                render: function(m, v) {
                  var y = "transition" + (v.props.group ? "-group" : ""), E = {
                    props: {
                      name: c,
                      mode: v.props.mode
                    },
                    on: {
                      beforeEnter: function(x) {
                        x.style.transformOrigin = v.props.origin, x.style.webkitTransformOrigin = v.props.origin;
                      }
                    }
                  };
                  return v.props.leaveAbsolute && (E.on.leave = f(E.on.leave, function(C) {
                    var x = C.offsetTop, b = C.offsetLeft, P = C.offsetWidth, T = C.offsetHeight;
                    C._transitionInitialStyles = {
                      position: C.style.position,
                      top: C.style.top,
                      left: C.style.left,
                      width: C.style.width,
                      height: C.style.height
                    }, C.style.position = "absolute", C.style.top = x + "px", C.style.left = b + "px", C.style.width = P + "px", C.style.height = T + "px";
                  }), E.on.afterLeave = f(E.on.afterLeave, function(C) {
                    if (C && C._transitionInitialStyles) {
                      var x = C._transitionInitialStyles, b = x.position, P = x.top, T = x.left, O = x.width, S = x.height;
                      delete C._transitionInitialStyles, C.style.position = b || "", C.style.top = P || "", C.style.left = T || "", C.style.width = O || "", C.style.height = S || "";
                    }
                  })), v.props.hideOnLeave && (E.on.leave = f(E.on.leave, function(C) {
                    C.style.setProperty("display", "none", "important");
                  })), m(y, Object(a.default)(v.data, E), v.children);
                }
              };
            }
            function u(c, h, p) {
              return p === void 0 && (p = "in-out"), {
                name: c,
                functional: !0,
                props: {
                  mode: {
                    type: String,
                    default: p
                  }
                },
                render: function(m, v) {
                  return m("transition", Object(a.default)(v.data, {
                    props: {
                      name: c
                    },
                    on: h
                  }), v.children);
                }
              };
            }
          }
        ),
        /***/
        "./src/components/transitions/expand-transition.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/transitions/expand-transition.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = function(o, l) {
              o === void 0 && (o = ""), l === void 0 && (l = !1);
              var f = l ? "width" : "height", d = "offset" + Object(a.upperFirst)(f);
              return {
                beforeEnter: function(p) {
                  var g;
                  p._parent = p.parentNode, p._initialStyle = (g = {
                    transition: p.style.transition,
                    overflow: p.style.overflow
                  }, g[f] = p.style[f], g);
                },
                enter: function(p) {
                  var g = p._initialStyle;
                  p.style.setProperty("transition", "none", "important"), p.style.overflow = "hidden";
                  var m = p[d] + "px";
                  p.style[f] = "0", p.offsetHeight, p.style.transition = g.transition, o && p._parent && p._parent.classList.add(o), requestAnimationFrame(function() {
                    p.style[f] = m;
                  });
                },
                afterEnter: c,
                enterCancelled: c,
                leave: function(p) {
                  var g;
                  p._initialStyle = (g = {
                    transition: "",
                    overflow: p.style.overflow
                  }, g[f] = p.style[f], g), p.style.overflow = "hidden", p.style[f] = p[d] + "px", p.offsetHeight, requestAnimationFrame(function() {
                    return p.style[f] = "0";
                  });
                },
                afterLeave: u,
                leaveCancelled: u
              };
              function u(h) {
                o && h._parent && h._parent.classList.remove(o), c(h);
              }
              function c(h) {
                var p = h._initialStyle[f];
                h.style.overflow = h._initialStyle.overflow, p != null && (h.style[f] = p), delete h._initialStyle;
              }
            };
          }
        ),
        /***/
        "./src/components/transitions/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/transitions/index.ts ***!
            \*********************************************/
          /*! exports provided: VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VDialogTopTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VExpandXTransition, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VCarouselTransition", function() {
              return l;
            }), i.d(r, "VCarouselReverseTransition", function() {
              return f;
            }), i.d(r, "VTabTransition", function() {
              return d;
            }), i.d(r, "VTabReverseTransition", function() {
              return u;
            }), i.d(r, "VMenuTransition", function() {
              return c;
            }), i.d(r, "VFabTransition", function() {
              return h;
            }), i.d(r, "VDialogTransition", function() {
              return p;
            }), i.d(r, "VDialogBottomTransition", function() {
              return g;
            }), i.d(r, "VDialogTopTransition", function() {
              return m;
            }), i.d(r, "VFadeTransition", function() {
              return v;
            }), i.d(r, "VScaleTransition", function() {
              return y;
            }), i.d(r, "VScrollXTransition", function() {
              return E;
            }), i.d(r, "VScrollXReverseTransition", function() {
              return C;
            }), i.d(r, "VScrollYTransition", function() {
              return x;
            }), i.d(r, "VScrollYReverseTransition", function() {
              return b;
            }), i.d(r, "VSlideXTransition", function() {
              return P;
            }), i.d(r, "VSlideXReverseTransition", function() {
              return T;
            }), i.d(r, "VSlideYTransition", function() {
              return O;
            }), i.d(r, "VSlideYReverseTransition", function() {
              return S;
            }), i.d(r, "VExpandTransition", function() {
              return L;
            }), i.d(r, "VExpandXTransition", function() {
              return A;
            });
            var a = i(
              /*! ./createTransition */
              "./src/components/transitions/createTransition.ts"
            ), o = i(
              /*! ./expand-transition */
              "./src/components/transitions/expand-transition.ts"
            ), l = Object(a.createSimpleTransition)("carousel-transition"), f = Object(a.createSimpleTransition)("carousel-reverse-transition"), d = Object(a.createSimpleTransition)("tab-transition"), u = Object(a.createSimpleTransition)("tab-reverse-transition"), c = Object(a.createSimpleTransition)("menu-transition"), h = Object(a.createSimpleTransition)("fab-transition", "center center", "out-in"), p = Object(a.createSimpleTransition)("dialog-transition"), g = Object(a.createSimpleTransition)("dialog-bottom-transition"), m = Object(a.createSimpleTransition)("dialog-top-transition"), v = Object(a.createSimpleTransition)("fade-transition"), y = Object(a.createSimpleTransition)("scale-transition"), E = Object(a.createSimpleTransition)("scroll-x-transition"), C = Object(a.createSimpleTransition)("scroll-x-reverse-transition"), x = Object(a.createSimpleTransition)("scroll-y-transition"), b = Object(a.createSimpleTransition)("scroll-y-reverse-transition"), P = Object(a.createSimpleTransition)("slide-x-transition"), T = Object(a.createSimpleTransition)("slide-x-reverse-transition"), O = Object(a.createSimpleTransition)("slide-y-transition"), S = Object(a.createSimpleTransition)("slide-y-reverse-transition"), L = Object(a.createJavascriptTransition)("expand-transition", Object(o.default)()), A = Object(a.createJavascriptTransition)("expand-x-transition", Object(o.default)("", !0));
            r.default = {
              $_vuetify_subcomponents: {
                VCarouselTransition: l,
                VCarouselReverseTransition: f,
                VDialogTransition: p,
                VDialogBottomTransition: g,
                VDialogTopTransition: m,
                VFabTransition: h,
                VFadeTransition: v,
                VMenuTransition: c,
                VScaleTransition: y,
                VScrollXTransition: E,
                VScrollXReverseTransition: C,
                VScrollYTransition: x,
                VScrollYReverseTransition: b,
                VSlideXTransition: P,
                VSlideXReverseTransition: T,
                VSlideYTransition: O,
                VSlideYReverseTransition: S,
                VTabReverseTransition: u,
                VTabTransition: d,
                VExpandTransition: L,
                VExpandXTransition: A
              }
            };
          }
        ),
        /***/
        "./src/directives/click-outside/index.ts": (
          /*!***********************************************!*\
            !*** ./src/directives/click-outside/index.ts ***!
            \***********************************************/
          /*! exports provided: ClickOutside, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "ClickOutside", function() {
              return h;
            });
            var a = i(
              /*! ../../util/dom */
              "./src/util/dom.ts"
            );
            function o(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(m) {
                return typeof m;
              } : o = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, o(p);
            }
            function l() {
              return !0;
            }
            function f(p, g, m) {
              if (!p || d(p, m) === !1)
                return !1;
              var v = Object(a.attachedRoot)(g);
              if (typeof ShadowRoot < "u" && v instanceof ShadowRoot && v.host === p.target)
                return !1;
              var y = (o(m.value) === "object" && m.value.include || function() {
                return [];
              })();
              return y.push(g), !y.some(function(E) {
                return E.contains(p.target);
              });
            }
            function d(p, g) {
              var m = o(g.value) === "object" && g.value.closeConditional || l;
              return m(p);
            }
            function u(p, g, m) {
              var v = typeof m.value == "function" ? m.value : m.value.handler;
              g._clickOutside.lastMousedownWasOutside && f(p, g, m) && setTimeout(function() {
                d(p, m) && v && v(p);
              }, 0);
            }
            function c(p, g) {
              var m = Object(a.attachedRoot)(p);
              g(document), typeof ShadowRoot < "u" && m instanceof ShadowRoot && g(m);
            }
            var h = {
              // [data-app] may not be found
              // if using bind, inserted makes
              // sure that the root element is
              // available, iOS does not support
              // clicks on body
              inserted: function(g, m, v) {
                var y = function(x) {
                  return u(x, g, m);
                }, E = function(x) {
                  g._clickOutside.lastMousedownWasOutside = f(x, g, m);
                };
                c(g, function(C) {
                  C.addEventListener("click", y, !0), C.addEventListener("mousedown", E, !0);
                }), g._clickOutside || (g._clickOutside = {
                  lastMousedownWasOutside: !0
                }), g._clickOutside[v.context._uid] = {
                  onClick: y,
                  onMousedown: E
                };
              },
              unbind: function(g, m, v) {
                g._clickOutside && (c(g, function(y) {
                  var E;
                  if (!(!y || !(!((E = g._clickOutside) === null || E === void 0) && E[v.context._uid]))) {
                    var C = g._clickOutside[v.context._uid], x = C.onClick, b = C.onMousedown;
                    y.removeEventListener("click", x, !0), y.removeEventListener("mousedown", b, !0);
                  }
                }), delete g._clickOutside[v.context._uid]);
              }
            };
            r.default = h;
          }
        ),
        /***/
        "./src/directives/index.ts": (
          /*!*********************************!*\
            !*** ./src/directives/index.ts ***!
            \*********************************/
          /*! exports provided: ClickOutside, Intersect, Mutate, Resize, Ripple, Scroll, Touch */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./click-outside */
              "./src/directives/click-outside/index.ts"
            );
            i.d(r, "ClickOutside", function() {
              return a.ClickOutside;
            });
            var o = i(
              /*! ./intersect */
              "./src/directives/intersect/index.ts"
            );
            i.d(r, "Intersect", function() {
              return o.Intersect;
            });
            var l = i(
              /*! ./mutate */
              "./src/directives/mutate/index.ts"
            );
            i.d(r, "Mutate", function() {
              return l.Mutate;
            });
            var f = i(
              /*! ./resize */
              "./src/directives/resize/index.ts"
            );
            i.d(r, "Resize", function() {
              return f.Resize;
            });
            var d = i(
              /*! ./ripple */
              "./src/directives/ripple/index.ts"
            );
            i.d(r, "Ripple", function() {
              return d.Ripple;
            });
            var u = i(
              /*! ./scroll */
              "./src/directives/scroll/index.ts"
            );
            i.d(r, "Scroll", function() {
              return u.Scroll;
            });
            var c = i(
              /*! ./touch */
              "./src/directives/touch/index.ts"
            );
            i.d(r, "Touch", function() {
              return c.Touch;
            });
          }
        ),
        /***/
        "./src/directives/intersect/index.ts": (
          /*!*******************************************!*\
            !*** ./src/directives/intersect/index.ts ***!
            \*******************************************/
          /*! exports provided: Intersect, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Intersect", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            function o(d, u, c) {
              if (!(typeof window > "u" || !("IntersectionObserver" in window))) {
                var h = u.modifiers || {}, p = u.value, g = a(p) === "object" ? p : {
                  handler: p,
                  options: {}
                }, m = g.handler, v = g.options, y = new IntersectionObserver(function(E, C) {
                  var x;
                  E === void 0 && (E = []);
                  var b = (x = d._observe) === null || x === void 0 ? void 0 : x[c.context._uid];
                  if (b) {
                    var P = E.some(function(T) {
                      return T.isIntersecting;
                    });
                    m && (!h.quiet || b.init) && (!h.once || P || b.init) && m(E, C, P), P && h.once ? l(d, u, c) : b.init = !0;
                  }
                }, v);
                d._observe = Object(d._observe), d._observe[c.context._uid] = {
                  init: !1,
                  observer: y
                }, y.observe(d);
              }
            }
            function l(d, u, c) {
              var h, p = (h = d._observe) === null || h === void 0 ? void 0 : h[c.context._uid];
              p && (p.observer.unobserve(d), delete d._observe[c.context._uid]);
            }
            var f = {
              inserted: o,
              unbind: l
            };
            r.default = f;
          }
        ),
        /***/
        "./src/directives/mutate/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/mutate/index.ts ***!
            \****************************************/
          /*! exports provided: Mutate, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Mutate", function() {
              return d;
            });
            function a(u) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(h) {
                return typeof h;
              } : a = function(h) {
                return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
              }, a(u);
            }
            var o = function(u, c) {
              var h = {};
              for (var p in u)
                Object.prototype.hasOwnProperty.call(u, p) && c.indexOf(p) < 0 && (h[p] = u[p]);
              if (u != null && typeof Object.getOwnPropertySymbols == "function")
                for (var g = 0, p = Object.getOwnPropertySymbols(u); g < p.length; g++)
                  c.indexOf(p[g]) < 0 && Object.prototype.propertyIsEnumerable.call(u, p[g]) && (h[p[g]] = u[p[g]]);
              return h;
            };
            function l(u, c, h) {
              var p = c.modifiers || {}, g = c.value, m = a(g) === "object" ? g.handler : g, v = p.once, y = o(p, ["once"]), E = Object.keys(y).length > 0, C = a(g) === "object" && g.options ? g.options : E ? {
                attributes: y.attr,
                childList: y.child,
                subtree: y.sub,
                characterData: y.char
              } : {
                attributes: !0,
                childList: !0,
                subtree: !0,
                characterData: !0
              }, x = new MutationObserver(function(b, P) {
                u._mutate && (m(b, P), v && f(u, c, h));
              });
              x.observe(u, C), u._mutate = Object(u._mutate), u._mutate[h.context._uid] = {
                observer: x
              };
            }
            function f(u, c, h) {
              var p;
              !((p = u._mutate) === null || p === void 0) && p[h.context._uid] && (u._mutate[h.context._uid].observer.disconnect(), delete u._mutate[h.context._uid]);
            }
            var d = {
              inserted: l,
              unbind: f
            };
            r.default = d;
          }
        ),
        /***/
        "./src/directives/resize/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/resize/index.ts ***!
            \****************************************/
          /*! exports provided: Resize, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Resize", function() {
              return l;
            });
            function a(f, d, u) {
              var c = d.value, h = d.options || {
                passive: !0
              };
              window.addEventListener("resize", c, h), f._onResize = Object(f._onResize), f._onResize[u.context._uid] = {
                callback: c,
                options: h
              }, (!d.modifiers || !d.modifiers.quiet) && c();
            }
            function o(f, d, u) {
              var c;
              if (!((c = f._onResize) === null || c === void 0) && c[u.context._uid]) {
                var h = f._onResize[u.context._uid], p = h.callback, g = h.options;
                window.removeEventListener("resize", p, g), delete f._onResize[u.context._uid];
              }
            }
            var l = {
              inserted: a,
              unbind: o
            };
            r.default = l;
          }
        ),
        /***/
        "./src/directives/ripple/VRipple.sass": (
          /*!********************************************!*\
            !*** ./src/directives/ripple/VRipple.sass ***!
            \********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/directives/ripple/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/ripple/index.ts ***!
            \****************************************/
          /*! exports provided: Ripple, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Ripple", function() {
              return D;
            }), i(
              /*! ./VRipple.sass */
              "./src/directives/ripple/VRipple.sass"
            );
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = function(_, w) {
              var B = typeof Symbol == "function" && _[Symbol.iterator];
              if (!B)
                return _;
              var j = B.call(_), k, X = [], rt;
              try {
                for (; (w === void 0 || w-- > 0) && !(k = j.next()).done; )
                  X.push(k.value);
              } catch (et) {
                rt = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (B = j.return) && B.call(j);
                } finally {
                  if (rt)
                    throw rt.error;
                }
              }
              return X;
            }, f = function(_, w, B) {
              if (B || arguments.length === 2)
                for (var j = 0, k = w.length, X; j < k; j++)
                  (X || !(j in w)) && (X || (X = Array.prototype.slice.call(w, 0, j)), X[j] = w[j]);
              return _.concat(X || Array.prototype.slice.call(w));
            }, d = 80;
            function u(_, w) {
              _.style.transform = w, _.style.webkitTransform = w;
            }
            function c(_) {
              return _.constructor.name === "TouchEvent";
            }
            function h(_) {
              return _.constructor.name === "KeyboardEvent";
            }
            var p = function(w, B, j) {
              j === void 0 && (j = {});
              var k = 0, X = 0;
              if (!h(w)) {
                var rt = B.getBoundingClientRect(), et = c(w) ? w.touches[w.touches.length - 1] : w;
                k = et.clientX - rt.left, X = et.clientY - rt.top;
              }
              var Z = 0, dt = 0.3;
              B._ripple && B._ripple.circle ? (dt = 0.15, Z = B.clientWidth / 2, Z = j.center ? Z : Z + Math.sqrt(Math.pow(k - Z, 2) + Math.pow(X - Z, 2)) / 4) : Z = Math.sqrt(Math.pow(B.clientWidth, 2) + Math.pow(B.clientHeight, 2)) / 2;
              var vt = (B.clientWidth - Z * 2) / 2 + "px", bt = (B.clientHeight - Z * 2) / 2 + "px", it = j.center ? vt : k - Z + "px", R = j.center ? bt : X - Z + "px";
              return {
                radius: Z,
                scale: dt,
                x: it,
                y: R,
                centerX: vt,
                centerY: bt
              };
            }, g = {
              /* eslint-disable max-statements */
              show: function(w, B, j) {
                if (j === void 0 && (j = {}), !(!B._ripple || !B._ripple.enabled)) {
                  var k = document.createElement("span"), X = document.createElement("span");
                  k.appendChild(X), k.className = "v-ripple__container", j.class && (k.className += " " + j.class);
                  var rt = p(w, B, j), et = rt.radius, Z = rt.scale, dt = rt.x, vt = rt.y, bt = rt.centerX, it = rt.centerY, R = et * 2 + "px";
                  X.className = "v-ripple__animation", X.style.width = R, X.style.height = R, B.appendChild(k);
                  var V = window.getComputedStyle(B);
                  V && V.position === "static" && (B.style.position = "relative", B.dataset.previousPosition = "static"), X.classList.add("v-ripple__animation--enter"), X.classList.add("v-ripple__animation--visible"), u(X, "translate(" + dt + ", " + vt + ") scale3d(" + Z + "," + Z + "," + Z + ")"), X.dataset.activated = String(performance.now()), setTimeout(function() {
                    X.classList.remove("v-ripple__animation--enter"), X.classList.add("v-ripple__animation--in"), u(X, "translate(" + bt + ", " + it + ") scale3d(1,1,1)");
                  }, 0);
                }
              },
              hide: function(w) {
                if (!(!w || !w._ripple || !w._ripple.enabled)) {
                  var B = w.getElementsByClassName("v-ripple__animation");
                  if (B.length !== 0) {
                    var j = B[B.length - 1];
                    if (!j.dataset.isHiding) {
                      j.dataset.isHiding = "true";
                      var k = performance.now() - Number(j.dataset.activated), X = Math.max(250 - k, 0);
                      setTimeout(function() {
                        j.classList.remove("v-ripple__animation--in"), j.classList.add("v-ripple__animation--out"), setTimeout(function() {
                          var rt, et = w.getElementsByClassName("v-ripple__animation");
                          et.length === 1 && w.dataset.previousPosition && (w.style.position = w.dataset.previousPosition, delete w.dataset.previousPosition), ((rt = j.parentNode) === null || rt === void 0 ? void 0 : rt.parentNode) === w && w.removeChild(j.parentNode);
                        }, 300);
                      }, X);
                    }
                  }
                }
              }
            };
            function m(_) {
              return typeof _ > "u" || !!_;
            }
            function v(_) {
              var w = {}, B = _.currentTarget;
              if (!(!B || !B._ripple || B._ripple.touched || _.rippleStop)) {
                if (_.rippleStop = !0, c(_))
                  B._ripple.touched = !0, B._ripple.isTouch = !0;
                else if (B._ripple.isTouch)
                  return;
                if (w.center = B._ripple.centered || h(_), B._ripple.class && (w.class = B._ripple.class), c(_)) {
                  if (B._ripple.showTimerCommit)
                    return;
                  B._ripple.showTimerCommit = function() {
                    g.show(_, B, w);
                  }, B._ripple.showTimer = window.setTimeout(function() {
                    B && B._ripple && B._ripple.showTimerCommit && (B._ripple.showTimerCommit(), B._ripple.showTimerCommit = null);
                  }, d);
                } else
                  g.show(_, B, w);
              }
            }
            function y(_) {
              var w = _.currentTarget;
              if (!(!w || !w._ripple)) {
                if (window.clearTimeout(w._ripple.showTimer), _.type === "touchend" && w._ripple.showTimerCommit) {
                  w._ripple.showTimerCommit(), w._ripple.showTimerCommit = null, w._ripple.showTimer = setTimeout(function() {
                    y(_);
                  });
                  return;
                }
                window.setTimeout(function() {
                  w._ripple && (w._ripple.touched = !1);
                }), g.hide(w);
              }
            }
            function E(_) {
              var w = _.currentTarget;
              !w || !w._ripple || (w._ripple.showTimerCommit && (w._ripple.showTimerCommit = null), window.clearTimeout(w._ripple.showTimer));
            }
            var C = !1;
            function x(_) {
              !C && (_.keyCode === o.keyCodes.enter || _.keyCode === o.keyCodes.space) && (C = !0, v(_));
            }
            function b(_) {
              C = !1, y(_);
            }
            function P(_) {
              C === !0 && (C = !1, y(_));
            }
            function T(_, w, B) {
              var j = m(w.value);
              j || g.hide(_), _._ripple = _._ripple || {}, _._ripple.enabled = j;
              var k = w.value || {};
              k.center && (_._ripple.centered = !0), k.class && (_._ripple.class = w.value.class), k.circle && (_._ripple.circle = k.circle), j && !B ? (_.addEventListener("touchstart", v, {
                passive: !0
              }), _.addEventListener("touchend", y, {
                passive: !0
              }), _.addEventListener("touchmove", E, {
                passive: !0
              }), _.addEventListener("touchcancel", y), _.addEventListener("mousedown", v), _.addEventListener("mouseup", y), _.addEventListener("mouseleave", y), _.addEventListener("keydown", x), _.addEventListener("keyup", b), _.addEventListener("blur", P), _.addEventListener("dragstart", y, {
                passive: !0
              })) : !j && B && O(_);
            }
            function O(_) {
              _.removeEventListener("mousedown", v), _.removeEventListener("touchstart", v), _.removeEventListener("touchend", y), _.removeEventListener("touchmove", E), _.removeEventListener("touchcancel", y), _.removeEventListener("mouseup", y), _.removeEventListener("mouseleave", y), _.removeEventListener("keydown", x), _.removeEventListener("keyup", b), _.removeEventListener("dragstart", y), _.removeEventListener("blur", P);
            }
            function S(_, w, B) {
              T(_, w, !1), B.context && B.context.$nextTick(function() {
                var j = window.getComputedStyle(_);
                if (j && j.display === "inline") {
                  var k = B.fnOptions ? [B.fnOptions, B.context] : [B.componentInstance];
                  a.consoleWarn.apply(void 0, f(["v-ripple can only be used on block-level elements"], l(k), !1));
                }
              });
            }
            function L(_) {
              delete _._ripple, O(_);
            }
            function A(_, w) {
              if (w.value !== w.oldValue) {
                var B = m(w.oldValue);
                T(_, w, B);
              }
            }
            var D = {
              bind: S,
              unbind: L,
              update: A
            };
            r.default = D;
          }
        ),
        /***/
        "./src/directives/scroll/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/scroll/index.ts ***!
            \****************************************/
          /*! exports provided: Scroll, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Scroll", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            function o(d, u, c) {
              var h = (u.modifiers || {}).self, p = h === void 0 ? !1 : h, g = u.value, m = a(g) === "object" && g.options || {
                passive: !0
              }, v = typeof g == "function" || "handleEvent" in g ? g : g.handler, y = p ? d : u.arg ? document.querySelector(u.arg) : window;
              y && (y.addEventListener("scroll", v, m), d._onScroll = Object(d._onScroll), d._onScroll[c.context._uid] = {
                handler: v,
                options: m,
                // Don't reference self
                target: p ? void 0 : y
              });
            }
            function l(d, u, c) {
              var h;
              if (!((h = d._onScroll) === null || h === void 0) && h[c.context._uid]) {
                var p = d._onScroll[c.context._uid], g = p.handler, m = p.options, v = p.target, y = v === void 0 ? d : v;
                y.removeEventListener("scroll", g, m), delete d._onScroll[c.context._uid];
              }
            }
            var f = {
              inserted: o,
              unbind: l
            };
            r.default = f;
          }
        ),
        /***/
        "./src/directives/touch/index.ts": (
          /*!***************************************!*\
            !*** ./src/directives/touch/index.ts ***!
            \***************************************/
          /*! exports provided: Touch, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Touch", function() {
              return p;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = function(m) {
              var v = m.touchstartX, y = m.touchendX, E = m.touchstartY, C = m.touchendY, x = 0.5, b = 16;
              m.offsetX = y - v, m.offsetY = C - E, Math.abs(m.offsetY) < x * Math.abs(m.offsetX) && (m.left && y < v - b && m.left(m), m.right && y > v + b && m.right(m)), Math.abs(m.offsetX) < x * Math.abs(m.offsetY) && (m.up && C < E - b && m.up(m), m.down && C > E + b && m.down(m));
            };
            function l(g, m) {
              var v = g.changedTouches[0];
              m.touchstartX = v.clientX, m.touchstartY = v.clientY, m.start && m.start(Object.assign(g, m));
            }
            function f(g, m) {
              var v = g.changedTouches[0];
              m.touchendX = v.clientX, m.touchendY = v.clientY, m.end && m.end(Object.assign(g, m)), o(m);
            }
            function d(g, m) {
              var v = g.changedTouches[0];
              m.touchmoveX = v.clientX, m.touchmoveY = v.clientY, m.move && m.move(Object.assign(g, m));
            }
            function u(g) {
              var m = {
                touchstartX: 0,
                touchstartY: 0,
                touchendX: 0,
                touchendY: 0,
                touchmoveX: 0,
                touchmoveY: 0,
                offsetX: 0,
                offsetY: 0,
                left: g.left,
                right: g.right,
                up: g.up,
                down: g.down,
                start: g.start,
                move: g.move,
                end: g.end
              };
              return {
                touchstart: function(y) {
                  return l(y, m);
                },
                touchend: function(y) {
                  return f(y, m);
                },
                touchmove: function(y) {
                  return d(y, m);
                }
              };
            }
            function c(g, m, v) {
              var y = m.value, E = y.parent ? g.parentElement : g, C = y.options || {
                passive: !0
              };
              if (E) {
                var x = u(m.value);
                E._touchHandlers = Object(E._touchHandlers), E._touchHandlers[v.context._uid] = x, Object(a.keys)(x).forEach(function(b) {
                  E.addEventListener(b, x[b], C);
                });
              }
            }
            function h(g, m, v) {
              var y = m.value.parent ? g.parentElement : g;
              if (!(!y || !y._touchHandlers)) {
                var E = y._touchHandlers[v.context._uid];
                Object(a.keys)(E).forEach(function(C) {
                  y.removeEventListener(C, E[C]);
                }), delete y._touchHandlers[v.context._uid];
              }
            }
            var p = {
              inserted: c,
              unbind: h
            };
            r.default = p;
          }
        ),
        /***/
        "./src/framework.ts": (
          /*!**************************!*\
            !*** ./src/framework.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./install */
              "./src/install.ts"
            ), o = i(
              /*! ./services */
              "./src/services/index.ts"
            ), l = (
              /** @class */
              function() {
                function f(d) {
                  d === void 0 && (d = {}), this.framework = {
                    isHydrating: !1
                  }, this.installed = [], this.preset = {}, this.userPreset = {}, this.userPreset = d, this.use(o.Presets), this.use(o.Application), this.use(o.Breakpoint), this.use(o.Goto), this.use(o.Icons), this.use(o.Lang), this.use(o.Theme);
                }
                return f.prototype.init = function(d, u) {
                  var c = this;
                  this.installed.forEach(function(h) {
                    var p = c.framework[h];
                    p.framework = c.framework, p.init(d, u);
                  }), this.framework.rtl = !!this.preset.rtl;
                }, f.prototype.use = function(d) {
                  var u = d.property;
                  this.installed.includes(u) || (this.framework[u] = new d(this.preset, this), this.installed.push(u));
                }, f.install = a.install, f.installed = !1, f.version = "2.7.1", f.config = {
                  silent: !1
                }, f;
              }()
            );
            r.default = l;
          }
        ),
        /***/
        "./src/index.ts": (
          /*!**********************!*\
            !*** ./src/index.ts ***!
            \**********************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./components */
              "./src/components/index.ts"
            ), o = i(
              /*! ./directives */
              "./src/directives/index.ts"
            ), l = i(
              /*! ./framework */
              "./src/framework.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            };
            r.default = l.default;
            var d = l.default.install;
            l.default.install = function(u, c) {
              d.call(l.default, u, f({
                components: a,
                directives: o
              }, c));
            }, typeof window < "u" && window.Vue && window.Vue.use(l.default);
          }
        ),
        /***/
        "./src/install.ts": (
          /*!************************!*\
            !*** ./src/install.ts ***!
            \************************/
          /*! exports provided: install */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "install", function() {
              return f;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ./util/console */
              "./src/util/console.ts"
            );
            function f(d, u) {
              if (u === void 0 && (u = {}), !f.installed) {
                f.installed = !0, o.a !== d && Object(l.consoleError)(`Multiple instances of Vue detected
See https://github.com/vuetifyjs/vuetify/issues/4068

If you're seeing "$attrs is readonly", it's caused by this`);
                var c = u.components || {}, h = u.directives || {};
                for (var p in h) {
                  var g = h[p];
                  d.directive(p, g);
                }
                (function m(v) {
                  if (v) {
                    for (var y in v) {
                      var E = v[y];
                      E && !m(E.$_vuetify_subcomponents) && d.component(y, E);
                    }
                    return !0;
                  }
                  return !1;
                })(c), !d.$_vuetify_installed && (d.$_vuetify_installed = !0, d.mixin({
                  beforeCreate: function() {
                    var v = this.$options;
                    v.vuetify ? (v.vuetify.init(this, this.$ssrContext), this.$vuetify = d.observable(v.vuetify.framework)) : this.$vuetify = v.parent && v.parent.$vuetify || this;
                  },
                  beforeMount: function() {
                    this.$options.vuetify && this.$el && this.$el.hasAttribute("data-server-rendered") && (this.$vuetify.isHydrating = !0, this.$vuetify.breakpoint.update(!0));
                  },
                  mounted: function() {
                    this.$options.vuetify && this.$vuetify.isHydrating && (this.$vuetify.isHydrating = !1, this.$vuetify.breakpoint.update());
                  }
                }));
              }
            }
          }
        ),
        /***/
        "./src/locale/af.ts": (
          /*!**************************!*\
            !*** ./src/locale/af.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "badge",
              close: "Close",
              dataIterator: {
                noResultsText: "Geen ooreenstemmende resultate is gevind nie",
                loadingText: "Loading item..."
              },
              dataTable: {
                itemsPerPageText: "Rye per bladsy:",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending..",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Aantal per bladsy:",
                itemsPerPageAll: "Alles",
                nextPage: "Volgende bladsy",
                prevPage: "Vorige bladsy",
                firstPage: "Eerste bladsy",
                lastPage: "Laaste bladsy",
                pageText: "{0}-{1} van {2}"
              },
              datePicker: {
                itemsSelected: "{0} gekies",
                nextMonthAriaLabel: "Volgende maand",
                nextYearAriaLabel: "Volgende jaar",
                prevMonthAriaLabel: "Vorige maand",
                prevYearAriaLabel: "Vorige jaar"
              },
              noDataText: "Geen data is beskikbaar nie",
              carousel: {
                prev: "Vorige visuele",
                next: "Volgende visuele",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} meer"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginasie-navigasie",
                  next: "Volgende bladsy",
                  previous: "Vorige bladsy",
                  page: "Gaan na bladsy {0}",
                  currentPage: "Huidige bladsy, Bladsy {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ar.ts": (
          /*!**************************!*\
            !*** ./src/locale/ar.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "شارة",
              close: "إغلاق",
              dataIterator: {
                noResultsText: "لم يتم إيجاد نتائج",
                loadingText: "يتم جلب العناصر..."
              },
              dataTable: {
                itemsPerPageText: "عدد الصفوف لكل صفحة:",
                ariaLabel: {
                  sortDescending: "مرتب تنازلياً.",
                  sortAscending: "مرتب تصاعدياً.",
                  sortNone: "غير مرتب.",
                  activateNone: "نشط لإزالة الترتيب.",
                  activateDescending: "نشط للترتيب تنازلياً.",
                  activateAscending: "نشط للترتيب تصاعدياً."
                },
                sortBy: "رتب حسب"
              },
              dataFooter: {
                itemsPerPageText: "عدد العناصر لكل صفحة:",
                itemsPerPageAll: "الكل",
                nextPage: "الصفحة التالية",
                prevPage: "الصفحة السابقة",
                firstPage: "الصفحة الأولى",
                lastPage: "الصفحة الأخيرة",
                pageText: "{0}-{1} من {2}"
              },
              datePicker: {
                itemsSelected: "تم تحديد {0}",
                nextMonthAriaLabel: "الشهر القادم",
                nextYearAriaLabel: "العام القادم",
                prevMonthAriaLabel: "الشهر الماضى",
                prevYearAriaLabel: "السنة الماضية"
              },
              noDataText: "لا توجد بيانات",
              carousel: {
                prev: "المعروض السابق",
                next: "المعروض التالي",
                ariaLabel: {
                  delimiter: "المعروض رقم {0} من {1}"
                }
              },
              calendar: {
                moreEvents: "{0} أكثر"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ملفات",
                counterSize: "{0} ملفات ({1} في المجموع)"
              },
              timePicker: {
                am: "صباحاً",
                pm: "مساءً"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "الإنتقال بين الصفحات",
                  next: "الصفحة التالية",
                  previous: "الصفحة السابقة",
                  page: "{0} انتقل إلى الصفحة",
                  currentPage: "{0} الصفحة الحالية رقمها"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "القييم {0} من {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/az.ts": (
          /*!**************************!*\
            !*** ./src/locale/az.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "nişan",
              close: "Bağla",
              dataIterator: {
                noResultsText: "Uyğun məlumat tapılmadı",
                loadingText: "Yüklənir... Zəhmət olmasa, gözləyin."
              },
              dataTable: {
                itemsPerPageText: "Səhifə başı sətir sayı:",
                ariaLabel: {
                  sortDescending: "Azalan sıra ilə düzülmüş.",
                  sortAscending: "Artan sıra ilə düzülmüş.",
                  sortNone: "Sıralanmamışdır. ",
                  activateNone: "Sıralamanı yığışdır.",
                  activateDescending: "Azalan sıra ilə düz.",
                  activateAscending: "Artan sıra ilə düz."
                },
                sortBy: "Sırala"
              },
              dataFooter: {
                itemsPerPageText: "Səhifə başı sətir sayı:",
                itemsPerPageAll: "Hamısı",
                nextPage: "Növbəti səhifə",
                prevPage: "Əvvəlki səhifə",
                firstPage: "İlk səhifə",
                lastPage: "Son səhifə",
                pageText: "{0} - {1} arası, Cəmi: {2} qeydiyyat"
              },
              datePicker: {
                itemsSelected: "{0} element seçildi",
                nextMonthAriaLabel: "Növbəti ay",
                nextYearAriaLabel: "Növbəti yıl",
                prevMonthAriaLabel: "Keçən ay",
                prevYearAriaLabel: "Keçən yıl"
              },
              noDataText: "Bu görüntüdə məlumat yoxdur.",
              carousel: {
                prev: "Əvvəlki görüntü",
                next: "Növbəti görüntü",
                ariaLabel: {
                  delimiter: "Galereya səhifə {0} / {1}"
                }
              },
              calendar: {
                moreEvents: "{0} ədad daha"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fayl",
                counterSize: "{0} fayl (cəmi {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Səhifələmə Naviqasiyası",
                  next: "Növbəti səhifə",
                  previous: "Əvəvlki səhifə",
                  page: "Səhifəyə get {0}",
                  currentPage: "Cari səhifə, Səhifə {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/bg.ts": (
          /*!**************************!*\
            !*** ./src/locale/bg.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Значка",
              close: "Затвори",
              dataIterator: {
                noResultsText: "Не са намерени записи",
                loadingText: "Зареждане на елементи..."
              },
              dataTable: {
                itemsPerPageText: "Редове на страница:",
                ariaLabel: {
                  sortDescending: "Подреди в намаляващ ред.",
                  sortAscending: "Подреди в нарастващ ред.",
                  sortNone: "Без подредба.",
                  activateNone: "Активирай за премахване на подредбата.",
                  activateDescending: "Активирай за подредба в намаляващ ред.",
                  activateAscending: "Активирай за подредба в нарастващ ред."
                },
                sortBy: "Сортирай по"
              },
              dataFooter: {
                itemsPerPageText: "Елементи на страница:",
                itemsPerPageAll: "Всички",
                nextPage: "Следваща страница",
                prevPage: "Предишна страница",
                firstPage: "Първа страница",
                lastPage: "Последна страница",
                pageText: "{0}-{1} от {2}"
              },
              datePicker: {
                itemsSelected: "{0} избрани",
                nextMonthAriaLabel: "Следващ месец",
                nextYearAriaLabel: "Следващата година",
                prevMonthAriaLabel: "Предишен месец",
                prevYearAriaLabel: "Предишна година"
              },
              noDataText: "Няма налични данни",
              carousel: {
                prev: "Предишна визуализация",
                next: "Следваща визуализация",
                ariaLabel: {
                  delimiter: "Кадър {0} от {1} на въртележката"
                }
              },
              calendar: {
                moreEvents: "Още {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} файла",
                counterSize: "{0} файла ({1} общо)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Странициране",
                  next: "Следваща страница",
                  previous: "Предишна страница",
                  page: "Отиди на страница {0}",
                  currentPage: "Текуща страница, Страница {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ca.ts": (
          /*!**************************!*\
            !*** ./src/locale/ca.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Insígnia",
              close: "Tancar",
              dataIterator: {
                noResultsText: "Sense dades per mostrar",
                loadingText: "Carregant..."
              },
              dataTable: {
                itemsPerPageText: "Files per pàgina:",
                ariaLabel: {
                  sortDescending: "Ordre descendent.",
                  sortAscending: "Ordre ascendent.",
                  sortNone: "Sense ordenar.",
                  activateNone: "Premi per treure la ordenació.",
                  activateDescending: "Premi per ordenar descendent.",
                  activateAscending: "Premi per ordenar ascendent."
                },
                sortBy: "Ordenat per"
              },
              dataFooter: {
                itemsPerPageText: "Elements per pàgina:",
                itemsPerPageAll: "Tot",
                nextPage: "Pàgina següent",
                prevPage: "Pàgina anterior",
                firstPage: "Primera pàgina",
                lastPage: "Última pàgina",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} seleccionats",
                nextMonthAriaLabel: "El mes que ve",
                nextYearAriaLabel: "L'any que ve",
                prevMonthAriaLabel: "Mes anterior",
                prevYearAriaLabel: "Any anterior"
              },
              noDataText: "Sense dades",
              carousel: {
                prev: "Visualització prèvia",
                next: "Visualització següent",
                ariaLabel: {
                  delimiter: "Diapositiva {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} més"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fitxers",
                counterSize: "{0} fitxers ({1} en total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegació de la pàgina",
                  next: "Pàgina següent",
                  previous: "Pàgina anterior",
                  page: "Ves a la pàgina {0}",
                  currentPage: "Pàgina actual, pàgina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Puntuació {0} de {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ckb.ts": (
          /*!***************************!*\
            !*** ./src/locale/ckb.ts ***!
            \***************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "باج",
              close: "داخستن",
              dataIterator: {
                noResultsText: "هیچ تۆمارێکی هاوتا نەدۆزرایەوە",
                loadingText: "بارکردنی ئایتمەکان..."
              },
              dataTable: {
                itemsPerPageText: "ڕیزەکان بۆ هەر پەڕەیەک:",
                ariaLabel: {
                  sortDescending: ".سەر بەرەو خوار ڕیزکراوە",
                  sortAscending: ".سەر بەرەو ژوور ڕیزکراوە",
                  sortNone: "ڕیزنەکراوە.",
                  activateNone: "چالاککردن بۆ لابردنی ڕیزکردن.",
                  activateDescending: "چالاککردن بۆ ڕیزکردنی سەربەرەوخوار.",
                  activateAscending: "چالاککردن بۆ ڕیزکردنی سەر بەرەو ژوور."
                },
                sortBy: "ڕیزکردن بەپێی"
              },
              dataFooter: {
                itemsPerPageText: "ئایتمەکان بۆ هەر پەڕەیەک:",
                itemsPerPageAll: "هەمووی",
                nextPage: "پەڕەی دواتر",
                prevPage: "پەڕەی پێشوو",
                firstPage: "پەڕەی یەکەم",
                lastPage: "پەڕەی کۆتایی",
                pageText: "{0}-{1} لە {2}"
              },
              datePicker: {
                itemsSelected: "{0} دەسنیشانکراوە",
                nextMonthAriaLabel: "مانگی داهاتوو",
                nextYearAriaLabel: "ساڵی داهاتوو",
                prevMonthAriaLabel: "مانگی پێشوو",
                prevYearAriaLabel: "ساڵی پێشوو"
              },
              noDataText: "هیچ داتایەک بەردەست نیە",
              carousel: {
                prev: "بینراوی پێشوو",
                next: "بینراوی داهاتوو",
                ariaLabel: {
                  delimiter: "سلایدی کارۆسێل {0} لە {1}"
                }
              },
              calendar: {
                moreEvents: "{0} زیاتر"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} فایل",
                counterSize: "{0} فایل ({1} لە کۆی گشتی)"
              },
              timePicker: {
                am: "پێش نیوەڕۆژ",
                pm: "دوای نیوەڕۆژ"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "ڕێنیشاندەری پەڕەگۆڕکێ",
                  next: "پەڕەی دواتر",
                  previous: "پەڕەی پێشوو",
                  page: "بڕۆ بۆ پەڕەی {0}",
                  currentPage: "پەڕەی ئێستا، پەڕە{0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/cs.ts": (
          /*!**************************!*\
            !*** ./src/locale/cs.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznak",
              close: "Zavřít",
              dataIterator: {
                noResultsText: "Nenalezeny žádné záznamy",
                loadingText: "Načítám položky..."
              },
              dataTable: {
                itemsPerPageText: "Řádků na stránku:",
                ariaLabel: {
                  sortDescending: "Řazeno sestupně.",
                  sortAscending: "Řazeno vzestupně.",
                  sortNone: "Neseřazeno.",
                  activateNone: "Aktivováním vypnete řazení.",
                  activateDescending: "Aktivováním se bude řadit sestupně.",
                  activateAscending: "Aktivováním se bude řadit vzestupně."
                },
                sortBy: "Řadit dle"
              },
              dataFooter: {
                itemsPerPageText: "Položek na stránku:",
                itemsPerPageAll: "Vše",
                nextPage: "Další strana",
                prevPage: "Předchozí strana",
                firstPage: "První strana",
                lastPage: "Poslední strana",
                pageText: "{0}-{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} vybráno",
                nextMonthAriaLabel: "Příští měsíc",
                nextYearAriaLabel: "Příští rok",
                prevMonthAriaLabel: "Předchozí měsíc",
                prevYearAriaLabel: "Předchozí rok"
              },
              noDataText: "Nejsou dostupná žádná data",
              carousel: {
                prev: "Předchozí obrázek",
                next: "Další obrázek",
                ariaLabel: {
                  delimiter: "Slide {0} z {1}"
                }
              },
              calendar: {
                moreEvents: "{0} dalších"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} souborů",
                counterSize: "{0} souborů ({1} celkem)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigace po stránkách",
                  next: "Další strana",
                  previous: "Předchozí strana",
                  page: "Přejít na stránku {0}",
                  currentPage: "Aktuální stránka, stránka {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Hodnocení {0} z {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/da.ts": (
          /*!**************************!*\
            !*** ./src/locale/da.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Emblem",
              close: "Luk",
              dataIterator: {
                noResultsText: "Ingen matchende data fundet",
                loadingText: "Indhenter data..."
              },
              dataTable: {
                itemsPerPageText: "Rækker pr. side:",
                ariaLabel: {
                  sortDescending: "Sorteret faldende.",
                  sortAscending: "Sorteret stigende.",
                  sortNone: "Ikke sorteret.",
                  activateNone: "Aktiver for at fjerne sortering.",
                  activateDescending: "Aktiver for at sortere faldende.",
                  activateAscending: "Aktiver for at sortere stigende."
                },
                sortBy: "Sorter efter"
              },
              dataFooter: {
                itemsPerPageText: "Rækker pr. side:",
                itemsPerPageAll: "Alle",
                nextPage: "Næste side",
                prevPage: "Forrige side",
                firstPage: "Første side",
                lastPage: "Sidste side",
                pageText: "{0}-{1} af {2}"
              },
              datePicker: {
                itemsSelected: "{0} valgt",
                nextMonthAriaLabel: "Næste måned",
                nextYearAriaLabel: "Næste år",
                prevMonthAriaLabel: "Forrige måned",
                prevYearAriaLabel: "Forrige år"
              },
              noDataText: "Ingen data tilgængelig",
              carousel: {
                prev: "Forrige visuelle",
                next: "Næste visuelle",
                ariaLabel: {
                  delimiter: "Karrusel dias {0} af {1}"
                }
              },
              calendar: {
                moreEvents: "{0} mere"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer ({1} total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagineringsnavigation",
                  next: "Næste side",
                  previous: "Forrige side",
                  page: "Gå til side {0}",
                  currentPage: "Nuværende side, Side {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Bedømmelse {0} af {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/de.ts": (
          /*!**************************!*\
            !*** ./src/locale/de.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Abzeichen",
              close: "Schließen",
              dataIterator: {
                noResultsText: "Keine Elemente gefunden",
                loadingText: "Lade Elemente..."
              },
              dataTable: {
                itemsPerPageText: "Zeilen pro Seite:",
                ariaLabel: {
                  sortDescending: "Absteigend sortiert.",
                  sortAscending: "Aufsteigend sortiert.",
                  sortNone: "Nicht sortiert.",
                  activateNone: "Aktivieren um Sortierung zu entfernen.",
                  activateDescending: "Aktivieren um absteigend zu sortieren.",
                  activateAscending: "Aktivieren um aufsteigend zu sortieren."
                },
                sortBy: "Sortiere nach"
              },
              dataFooter: {
                itemsPerPageText: "Elemente pro Seite:",
                itemsPerPageAll: "Alle",
                nextPage: "Nächste Seite",
                prevPage: "Vorherige Seite",
                firstPage: "Erste Seite",
                lastPage: "Letzte Seite",
                pageText: "{0}-{1} von {2}"
              },
              datePicker: {
                itemsSelected: "{0} ausgewählt",
                nextMonthAriaLabel: "Nächsten Monat",
                nextYearAriaLabel: "Nächstes Jahr",
                prevMonthAriaLabel: "Vorheriger Monat",
                prevYearAriaLabel: "Vorheriges Jahr"
              },
              noDataText: "Keine Daten vorhanden",
              carousel: {
                prev: "Vorheriges Bild",
                next: "Nächstes Bild",
                ariaLabel: {
                  delimiter: "Element {0} von {1}"
                }
              },
              calendar: {
                moreEvents: "{0} mehr"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} Dateien",
                counterSize: "{0} Dateien ({1} gesamt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Seitennavigation",
                  next: "Nächste Seite",
                  previous: "Vorherige Seite",
                  page: "Gehe zu Seite {0}",
                  currentPage: "Aktuelle Seite, Seite {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/el.ts": (
          /*!**************************!*\
            !*** ./src/locale/el.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Σήμα",
              close: "Close",
              dataIterator: {
                noResultsText: "Δε βρέθηκαν αποτελέσματα",
                loadingText: "Loading item..."
              },
              dataTable: {
                itemsPerPageText: "Γραμμές ανά σελίδα:",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending.",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Αντικείμενα ανά σελίδα:",
                itemsPerPageAll: "Όλα",
                nextPage: "Επόμενη σελίδα",
                prevPage: "Προηγούμενη σελίδα",
                firstPage: "Πρώτη σελίδα",
                lastPage: "Τελευταία σελίδα",
                pageText: "{0}-{1} από {2}"
              },
              datePicker: {
                itemsSelected: "{0} επιλεγμένα",
                nextMonthAriaLabel: "Τον επόμενο μήνα",
                nextYearAriaLabel: "Του χρόνου",
                prevMonthAriaLabel: "Προηγούμενος μήνας",
                prevYearAriaLabel: "Προηγούμενο έτος"
              },
              noDataText: "Χωρίς δεδομένα",
              carousel: {
                prev: "הקודם חזותי",
                next: "הבא חזותי",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} ακόμη"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Πλοήγηση με προορισμούς",
                  next: "Επόμενη σελίδα",
                  previous: "Προηγούμενη σελίδα",
                  page: "Πήγαινε στην σελίδα {0}",
                  currentPage: "Τρέχουσα σελίδα, σελίδα {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/en.ts": (
          /*!**************************!*\
            !*** ./src/locale/en.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Badge",
              close: "Close",
              dataIterator: {
                noResultsText: "No matching records found",
                loadingText: "Loading items..."
              },
              dataTable: {
                itemsPerPageText: "Rows per page:",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending.",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Items per page:",
                itemsPerPageAll: "All",
                nextPage: "Next page",
                prevPage: "Previous page",
                firstPage: "First page",
                lastPage: "Last page",
                pageText: "{0}-{1} of {2}"
              },
              datePicker: {
                itemsSelected: "{0} selected",
                nextMonthAriaLabel: "Next month",
                nextYearAriaLabel: "Next year",
                prevMonthAriaLabel: "Previous month",
                prevYearAriaLabel: "Previous year"
              },
              noDataText: "No data available",
              carousel: {
                prev: "Previous visual",
                next: "Next visual",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} more"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Next page",
                  previous: "Previous page",
                  page: "Goto Page {0}",
                  currentPage: "Current Page, Page {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/es.ts": (
          /*!**************************!*\
            !*** ./src/locale/es.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Placa",
              close: "Cerrar",
              dataIterator: {
                noResultsText: "Ningún elemento coincide con la búsqueda",
                loadingText: "Cargando..."
              },
              dataTable: {
                itemsPerPageText: "Filas por página:",
                ariaLabel: {
                  sortDescending: "Orden descendente.",
                  sortAscending: "Orden ascendente.",
                  sortNone: "Sin ordenar.",
                  activateNone: "Pulse para quitar orden.",
                  activateDescending: "Pulse para ordenar de forma descendente.",
                  activateAscending: "Pulse para ordenar de forma ascendente."
                },
                sortBy: "Ordenado por"
              },
              dataFooter: {
                itemsPerPageText: "Elementos por página:",
                itemsPerPageAll: "Todos",
                nextPage: "Página siguiente",
                prevPage: "Página anterior",
                firstPage: "Primera página",
                lastPage: "Última página",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} seleccionados",
                nextMonthAriaLabel: "Próximo mes",
                nextYearAriaLabel: "Próximo año",
                prevMonthAriaLabel: "Mes anterior",
                prevYearAriaLabel: "Año anterior"
              },
              noDataText: "No hay datos disponibles",
              carousel: {
                prev: "Visual anterior",
                next: "Visual siguiente",
                ariaLabel: {
                  delimiter: "Visual {0} de {1}"
                }
              },
              calendar: {
                moreEvents: "{0} más"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} archivos",
                counterSize: "{0} archivos ({1} en total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegación de paginación",
                  next: "Página siguiente",
                  previous: "Página anterior",
                  page: "Ir a la página {0}",
                  currentPage: "Página actual, página {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Puntuación {0} de {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/et.ts": (
          /*!**************************!*\
            !*** ./src/locale/et.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Märk",
              close: "Sulge",
              dataIterator: {
                noResultsText: "Vastavaid kirjeid ei leitud",
                loadingText: "Andmeid laaditakse..."
              },
              dataTable: {
                itemsPerPageText: "Ridu leheküljel:",
                ariaLabel: {
                  sortDescending: "Kahanevalt sorteeritud.",
                  sortAscending: "Kasvavalt sorteeritud.",
                  sortNone: "Ei ole sorteeritud.",
                  activateNone: "Vajuta uuesti sorteerimise eemaldamiseks.",
                  activateDescending: "Vajuta uuesti, et sorteerida kahanevalt.",
                  activateAscending: "Vajuta kasvavalt sorteerimiseks."
                },
                sortBy: "Sorteerimise alus"
              },
              dataFooter: {
                itemsPerPageText: "Kirjeid leheküljel:",
                itemsPerPageAll: "Kõik",
                nextPage: "Järgmine lehekülg",
                prevPage: "Eelmine lehekülg",
                firstPage: "Esimene lehekülg",
                lastPage: "Viimane lehekülg",
                pageText: "{0}-{1} {2}st"
              },
              datePicker: {
                itemsSelected: "{0} valitud",
                nextMonthAriaLabel: "Järgmine kuu",
                nextYearAriaLabel: "Järgmine aasta",
                prevMonthAriaLabel: "Eelmine kuu",
                prevYearAriaLabel: "Eelmine aasta"
              },
              noDataText: "Andmed puuduvad",
              carousel: {
                prev: "Eelmine visuaalne",
                next: "Järgmine visuaalne",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} veel"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} faili",
                counterSize: "{0} faili (kokku {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Järgmine lehekülg",
                  previous: "Eelmine lehekülg",
                  page: "Mine lehele {0}",
                  currentPage: "Praegune leht, leht {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fa.ts": (
          /*!**************************!*\
            !*** ./src/locale/fa.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "نشان",
              close: "بستن",
              dataIterator: {
                noResultsText: "نتیجه‌ای یافت نشد",
                loadingText: "در حال بارگذاری..."
              },
              dataTable: {
                itemsPerPageText: "ردیف در صفحه:",
                ariaLabel: {
                  sortDescending: "مرتب‌سازی نزولی",
                  sortAscending: "مرتب‌سازی صعودی",
                  sortNone: "بدون مرتب‌سازی",
                  activateNone: "غیرفعال‌سازی مرتب‌سازی",
                  activateDescending: "غیرفعال‌سازی مرتب‌سازی نزولی",
                  activateAscending: "غیرفعال‌سازی مرتب‌سازی صعودی"
                },
                sortBy: "مرتب‌سازی براساس"
              },
              dataFooter: {
                itemsPerPageText: "ردیف در صفحه:",
                itemsPerPageAll: "همه",
                nextPage: "صفحه‌ی بعد",
                prevPage: "صفحه‌ی قبل",
                firstPage: "صفحه‌ی یکم",
                lastPage: "صفحه‌ی آخر",
                pageText: "{0} تا {1} از {2}"
              },
              datePicker: {
                itemsSelected: "{0} انتخاب شده",
                nextMonthAriaLabel: "ماه بعد",
                nextYearAriaLabel: "سال بعد",
                prevMonthAriaLabel: "ماه قبل",
                prevYearAriaLabel: "سال قبل"
              },
              noDataText: "داده‌ای موجود نیست",
              carousel: {
                prev: "اسلاید قبلی",
                next: "اسلاید بعدی",
                ariaLabel: {
                  delimiter: "اسلاید {0} از {1}"
                }
              },
              calendar: {
                moreEvents: "{بیشتر {0"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} پرونده",
                counterSize: "{0} پرونده ({1} در کل)"
              },
              timePicker: {
                am: "قبل از ظهر",
                pm: "بعد از ظهر"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "جهت یابی صفحه",
                  next: "صفحه بعد",
                  previous: "صفحه قبلی",
                  page: "برو صفحه {0}",
                  currentPage: "{0} صفحه فعلی ، صفحه"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fi.ts": (
          /*!**************************!*\
            !*** ./src/locale/fi.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Infopiste",
              close: "Sulje",
              dataIterator: {
                noResultsText: "Ei osumia",
                loadingText: "Ladataan kohteita..."
              },
              dataTable: {
                itemsPerPageText: "Rivejä sivulla:",
                ariaLabel: {
                  sortDescending: ": Järjestetty laskevasti. Poista järjestäminen aktivoimalla.",
                  sortAscending: ": Järjestetty nousevasti. Järjestä laskevasti aktivoimalla.",
                  sortNone: ": Ei järjestetty. Järjestä nousevasti aktivoimalla.",
                  activateNone: "Aktivoi lajittelun poistamiseksi.",
                  activateDescending: "Aktivoi laskevien laskevien lajittelemiseksi.",
                  activateAscending: "Aktivoi lajitella nouseva."
                },
                sortBy: "Järjestä"
              },
              dataFooter: {
                itemsPerPageText: "Kohteita sivulla:",
                itemsPerPageAll: "Kaikki",
                nextPage: "Seuraava sivu",
                prevPage: "Edellinen sivu",
                firstPage: "Ensimmäinen sivu",
                lastPage: "Viimeinen sivu",
                pageText: "{0}-{1} ({2})"
              },
              datePicker: {
                itemsSelected: "{0} valittu",
                nextMonthAriaLabel: "Seuraava kuukausi",
                nextYearAriaLabel: "Ensi vuosi",
                prevMonthAriaLabel: "Edellinen kuukausi",
                prevYearAriaLabel: "Edellinen vuosi"
              },
              noDataText: "Ei dataa",
              carousel: {
                prev: "Edellinen kuva",
                next: "Seuraava kuva",
                ariaLabel: {
                  delimiter: "Karusellin kuva {0}/{1}"
                }
              },
              calendar: {
                moreEvents: "{0} lisää"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} tiedostoa",
                counterSize: "{0} tiedostoa ({1} yhteensä)"
              },
              timePicker: {
                am: "ap.",
                pm: "ip."
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Seuraava sivu",
                  previous: "Edellinen sivu",
                  page: "Mene sivulle {0}",
                  currentPage: "Nykyinen sivu, Sivu {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Luokitus {0}/{1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fr.ts": (
          /*!**************************!*\
            !*** ./src/locale/fr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Badge",
              close: "Fermer",
              dataIterator: {
                noResultsText: "Aucun enregistrement correspondant trouvé",
                loadingText: "Chargement de l'élément..."
              },
              dataTable: {
                itemsPerPageText: "Lignes par page :",
                ariaLabel: {
                  sortDescending: "Tri décroissant.",
                  sortAscending: "Tri croissant.",
                  sortNone: "Non trié.",
                  activateNone: "Activer pour supprimer le tri.",
                  activateDescending: "Activer pour trier par ordre décroissant.",
                  activateAscending: "Activer pour trier par ordre croissant."
                },
                sortBy: "Trier par"
              },
              dataFooter: {
                itemsPerPageText: "Élements par page :",
                itemsPerPageAll: "Tous",
                nextPage: "Page suivante",
                prevPage: "Page précédente",
                firstPage: "Première page",
                lastPage: "Dernière page",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} sélectionné(s)",
                nextMonthAriaLabel: "Le mois prochain",
                nextYearAriaLabel: "L'année prochaine",
                prevMonthAriaLabel: "Le mois précédent",
                prevYearAriaLabel: "Année précédente"
              },
              noDataText: "Aucune donnée disponible",
              carousel: {
                prev: "Visuel précédent",
                next: "Visuel suivant",
                ariaLabel: {
                  delimiter: "Diapositive {0} de {1}"
                }
              },
              calendar: {
                moreEvents: "{0} de plus"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fichier(s)",
                counterSize: "{0} fichier(s) ({1} au total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigation de pagination",
                  next: "Page suivante",
                  previous: "Page précédente",
                  page: "Aller à la page {0}",
                  currentPage: "Page actuelle, Page {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Note de {0} sur {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/he.ts": (
          /*!**************************!*\
            !*** ./src/locale/he.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "תג",
              close: "סגור",
              dataIterator: {
                noResultsText: "לא נמצאו תוצאות מתאימות",
                loadingText: "טוען פריט..."
              },
              dataTable: {
                itemsPerPageText: "שורות לעמוד:",
                ariaLabel: {
                  sortDescending: "ממוין לפי סדר עולה. לחץ להספקת המיון.",
                  sortAscending: "ממוין לפי סדר יורד. לחץ למיון לפי סדר עולה.",
                  sortNone: "לא ממוין. לחץ למיון לפי סדר עולה.",
                  activateNone: "הפעל להסרת המיון.",
                  activateDescending: "הפעל למיון יורד.",
                  activateAscending: "הפעל למיון עולה."
                },
                sortBy: "סדר לפי"
              },
              dataFooter: {
                itemsPerPageText: "פריטים לדף:",
                itemsPerPageAll: "הכל",
                nextPage: "עמוד הבא",
                prevPage: "עמוד הקודם",
                firstPage: "עמוד ראשון",
                lastPage: "עמוד אחרון",
                pageText: "{0}-{1} מתוך {2}"
              },
              datePicker: {
                itemsSelected: "{0} נבחרו",
                nextMonthAriaLabel: "חודש הבא",
                nextYearAriaLabel: "שנה הבאה",
                prevMonthAriaLabel: "חודש שעבר",
                prevYearAriaLabel: "שנה שעברה"
              },
              noDataText: "אין נתונים זמינים",
              carousel: {
                prev: "מצג קודם",
                next: "מצג הבא",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} נוספים"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} קבצים",
                counterSize: "{0} קבצים ({1} בסך הכל)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "ניווט עימוד",
                  next: "עמוד הבא",
                  previous: "עמוד הקודם",
                  page: "{0} לך לעמוד",
                  currentPage: "{0} עמוד נוכחי, עמוד"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/hr.ts": (
          /*!**************************!*\
            !*** ./src/locale/hr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Bedž",
              close: "Zatvori",
              dataIterator: {
                noResultsText: "Nisu pronađene odgovarajuće stavke",
                loadingText: "Učitavanje..."
              },
              dataTable: {
                itemsPerPageText: "Redaka po stranici:",
                ariaLabel: {
                  sortDescending: "Sortirano silazno.",
                  sortAscending: "Sortirano uzlazno.",
                  sortNone: "Nije sortirano.",
                  activateNone: "Odaberite za uklanjanje sortiranja.",
                  activateDescending: "Odaberite za silazno sortiranje.",
                  activateAscending: "Odaberite za uzlazno sortiranje."
                },
                sortBy: "Sortirajte po"
              },
              dataFooter: {
                itemsPerPageText: "Stavki po stranici:",
                itemsPerPageAll: "Sve",
                nextPage: "Sljedeća stranica",
                prevPage: "Prethodna stranica",
                firstPage: "Prva stranica",
                lastPage: "Posljednja stranica",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} odabrano",
                nextMonthAriaLabel: "Sljedeći mjesec",
                nextYearAriaLabel: "Slijedeće godine",
                prevMonthAriaLabel: "Prethodni mjesec",
                prevYearAriaLabel: "Prošla godina"
              },
              noDataText: "Nema dostupnih podataka",
              carousel: {
                prev: "Prethodno",
                next: "Sljedeće",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Još {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "Odabranih datoteka: {0}",
                counterSize: "Odabranih datoteka: {0} ({1} ukupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija stranicama",
                  next: "Sljedeća stranica",
                  previous: "Prethodna stranica",
                  page: "Idi na stranicu {0}",
                  currentPage: "Trenutna stranica, stranica {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/hu.ts": (
          /*!**************************!*\
            !*** ./src/locale/hu.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Jelvény",
              close: "Bezárás",
              dataIterator: {
                noResultsText: "Nincs egyező találat",
                loadingText: "Betöltés..."
              },
              dataTable: {
                itemsPerPageText: "Elem oldalanként:",
                ariaLabel: {
                  sortDescending: "Csökkenő sorrendbe rendezve.",
                  sortAscending: "Növekvő sorrendbe rendezve.",
                  sortNone: "Rendezetlen.",
                  activateNone: "Rendezés törlése.",
                  activateDescending: "Aktiváld a csökkenő rendezésért.",
                  activateAscending: "Aktiváld a növekvő rendezésért."
                },
                sortBy: "Rendezés"
              },
              dataFooter: {
                itemsPerPageText: "Elem oldalanként:",
                itemsPerPageAll: "Mind",
                nextPage: "Következő oldal",
                prevPage: "Előző oldal",
                firstPage: "Első oldal",
                lastPage: "Utolsó oldal",
                pageText: "{0}-{1} / {2}"
              },
              datePicker: {
                itemsSelected: "{0} kiválasztva",
                nextMonthAriaLabel: "Következő hónap",
                nextYearAriaLabel: "Következő év",
                prevMonthAriaLabel: "Előző hónap",
                prevYearAriaLabel: "Előző év"
              },
              noDataText: "Nincs elérhető adat",
              carousel: {
                prev: "Előző",
                next: "Következő",
                ariaLabel: {
                  delimiter: "Dia {0}/{1}"
                }
              },
              calendar: {
                moreEvents: "{0} további"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fájl",
                counterSize: "{0} fájl ({1} összesen)"
              },
              timePicker: {
                am: "de",
                pm: "du"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Oldal navigáció",
                  next: "Következő oldal",
                  previous: "Előző oldal",
                  page: "Menj a(z) {0}. oldalra",
                  currentPage: "Aktuális oldal: {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/id.ts": (
          /*!**************************!*\
            !*** ./src/locale/id.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Lencana",
              close: "Tutup",
              dataIterator: {
                noResultsText: "Tidak ditemukan catatan yang cocok",
                loadingText: "Memuat data..."
              },
              dataTable: {
                itemsPerPageText: "Baris per halaman:",
                ariaLabel: {
                  sortDescending: "Diurutkan kebawah.",
                  sortAscending: "Diurutkan keatas.",
                  sortNone: "Tidak diurutkan.",
                  activateNone: "Aktifkan untuk menghapus penyortiran.",
                  activateDescending: "Aktifkan untuk mengurutkan kebawah.",
                  activateAscending: "Aktifkan untuk mengurutkan keatas."
                },
                sortBy: "Urutkan berdasar"
              },
              dataFooter: {
                itemsPerPageText: "Item per halaman:",
                itemsPerPageAll: "Semua",
                nextPage: "Halaman selanjutnya",
                prevPage: "Halaman sebelumnya",
                firstPage: "Halaman pertama",
                lastPage: "Halaman terakhir",
                pageText: "{0}-{1} dari {2}"
              },
              datePicker: {
                itemsSelected: "{0} dipilih",
                nextMonthAriaLabel: "Bulan depan",
                nextYearAriaLabel: "Tahun depan",
                prevMonthAriaLabel: "Bulan sebelumnya",
                prevYearAriaLabel: "Tahun sebelumnya"
              },
              noDataText: "Tidak ada data tersedia",
              carousel: {
                prev: "Visual sebelumnya",
                next: "Visual selanjutnya",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} lagi"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} berkas",
                counterSize: "{0} berkas (dari total {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigasi Pagination",
                  next: "Halaman selanjutnya",
                  previous: "Halaman sebelumnya",
                  page: "Buka halaman {0}",
                  currentPage: "Halaman Saat Ini, Halaman {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/index.ts": (
          /*!*****************************!*\
            !*** ./src/locale/index.ts ***!
            \*****************************/
          /*! exports provided: af, ar, bg, ca, ckb, cs, da, de, el, en, es, et, fa, fi, fr, hr, hu, he, id, it, ja, ko, lv, lt, nl, no, pl, pt, ro, ru, sk, sl, srCyrl, srLatn, sv, th, tr, az, uk, vi, zhHans, zhHant */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./af */
              "./src/locale/af.ts"
            );
            i.d(r, "af", function() {
              return a.default;
            });
            var o = i(
              /*! ./ar */
              "./src/locale/ar.ts"
            );
            i.d(r, "ar", function() {
              return o.default;
            });
            var l = i(
              /*! ./bg */
              "./src/locale/bg.ts"
            );
            i.d(r, "bg", function() {
              return l.default;
            });
            var f = i(
              /*! ./ca */
              "./src/locale/ca.ts"
            );
            i.d(r, "ca", function() {
              return f.default;
            });
            var d = i(
              /*! ./ckb */
              "./src/locale/ckb.ts"
            );
            i.d(r, "ckb", function() {
              return d.default;
            });
            var u = i(
              /*! ./cs */
              "./src/locale/cs.ts"
            );
            i.d(r, "cs", function() {
              return u.default;
            });
            var c = i(
              /*! ./da */
              "./src/locale/da.ts"
            );
            i.d(r, "da", function() {
              return c.default;
            });
            var h = i(
              /*! ./de */
              "./src/locale/de.ts"
            );
            i.d(r, "de", function() {
              return h.default;
            });
            var p = i(
              /*! ./el */
              "./src/locale/el.ts"
            );
            i.d(r, "el", function() {
              return p.default;
            });
            var g = i(
              /*! ./en */
              "./src/locale/en.ts"
            );
            i.d(r, "en", function() {
              return g.default;
            });
            var m = i(
              /*! ./es */
              "./src/locale/es.ts"
            );
            i.d(r, "es", function() {
              return m.default;
            });
            var v = i(
              /*! ./et */
              "./src/locale/et.ts"
            );
            i.d(r, "et", function() {
              return v.default;
            });
            var y = i(
              /*! ./fa */
              "./src/locale/fa.ts"
            );
            i.d(r, "fa", function() {
              return y.default;
            });
            var E = i(
              /*! ./fi */
              "./src/locale/fi.ts"
            );
            i.d(r, "fi", function() {
              return E.default;
            });
            var C = i(
              /*! ./fr */
              "./src/locale/fr.ts"
            );
            i.d(r, "fr", function() {
              return C.default;
            });
            var x = i(
              /*! ./hr */
              "./src/locale/hr.ts"
            );
            i.d(r, "hr", function() {
              return x.default;
            });
            var b = i(
              /*! ./hu */
              "./src/locale/hu.ts"
            );
            i.d(r, "hu", function() {
              return b.default;
            });
            var P = i(
              /*! ./he */
              "./src/locale/he.ts"
            );
            i.d(r, "he", function() {
              return P.default;
            });
            var T = i(
              /*! ./id */
              "./src/locale/id.ts"
            );
            i.d(r, "id", function() {
              return T.default;
            });
            var O = i(
              /*! ./it */
              "./src/locale/it.ts"
            );
            i.d(r, "it", function() {
              return O.default;
            });
            var S = i(
              /*! ./ja */
              "./src/locale/ja.ts"
            );
            i.d(r, "ja", function() {
              return S.default;
            });
            var L = i(
              /*! ./ko */
              "./src/locale/ko.ts"
            );
            i.d(r, "ko", function() {
              return L.default;
            });
            var A = i(
              /*! ./lv */
              "./src/locale/lv.ts"
            );
            i.d(r, "lv", function() {
              return A.default;
            });
            var D = i(
              /*! ./lt */
              "./src/locale/lt.ts"
            );
            i.d(r, "lt", function() {
              return D.default;
            });
            var _ = i(
              /*! ./nl */
              "./src/locale/nl.ts"
            );
            i.d(r, "nl", function() {
              return _.default;
            });
            var w = i(
              /*! ./no */
              "./src/locale/no.ts"
            );
            i.d(r, "no", function() {
              return w.default;
            });
            var B = i(
              /*! ./pl */
              "./src/locale/pl.ts"
            );
            i.d(r, "pl", function() {
              return B.default;
            });
            var j = i(
              /*! ./pt */
              "./src/locale/pt.ts"
            );
            i.d(r, "pt", function() {
              return j.default;
            });
            var k = i(
              /*! ./ro */
              "./src/locale/ro.ts"
            );
            i.d(r, "ro", function() {
              return k.default;
            });
            var X = i(
              /*! ./ru */
              "./src/locale/ru.ts"
            );
            i.d(r, "ru", function() {
              return X.default;
            });
            var rt = i(
              /*! ./sk */
              "./src/locale/sk.ts"
            );
            i.d(r, "sk", function() {
              return rt.default;
            });
            var et = i(
              /*! ./sl */
              "./src/locale/sl.ts"
            );
            i.d(r, "sl", function() {
              return et.default;
            });
            var Z = i(
              /*! ./sr-Cyrl */
              "./src/locale/sr-Cyrl.ts"
            );
            i.d(r, "srCyrl", function() {
              return Z.default;
            });
            var dt = i(
              /*! ./sr-Latn */
              "./src/locale/sr-Latn.ts"
            );
            i.d(r, "srLatn", function() {
              return dt.default;
            });
            var vt = i(
              /*! ./sv */
              "./src/locale/sv.ts"
            );
            i.d(r, "sv", function() {
              return vt.default;
            });
            var bt = i(
              /*! ./th */
              "./src/locale/th.ts"
            );
            i.d(r, "th", function() {
              return bt.default;
            });
            var it = i(
              /*! ./tr */
              "./src/locale/tr.ts"
            );
            i.d(r, "tr", function() {
              return it.default;
            });
            var R = i(
              /*! ./az */
              "./src/locale/az.ts"
            );
            i.d(r, "az", function() {
              return R.default;
            });
            var V = i(
              /*! ./uk */
              "./src/locale/uk.ts"
            );
            i.d(r, "uk", function() {
              return V.default;
            });
            var tt = i(
              /*! ./vi */
              "./src/locale/vi.ts"
            );
            i.d(r, "vi", function() {
              return tt.default;
            });
            var Y = i(
              /*! ./zh-Hans */
              "./src/locale/zh-Hans.ts"
            );
            i.d(r, "zhHans", function() {
              return Y.default;
            });
            var $ = i(
              /*! ./zh-Hant */
              "./src/locale/zh-Hant.ts"
            );
            i.d(r, "zhHant", function() {
              return $.default;
            });
          }
        ),
        /***/
        "./src/locale/it.ts": (
          /*!**************************!*\
            !*** ./src/locale/it.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Distintivo",
              close: "Chiudi",
              dataIterator: {
                noResultsText: "Nessun risultato trovato",
                loadingText: "Caricamento in corso..."
              },
              dataTable: {
                itemsPerPageText: "Righe per pagina:",
                ariaLabel: {
                  sortDescending: "Ordinati in ordine decrescente.",
                  sortAscending: "Ordinati in ordine crescente.",
                  sortNone: "Non ordinato.",
                  activateNone: "Attiva per rimuovere l'ordinamento.",
                  activateDescending: "Attiva per ordinare in ordine decrescente.",
                  activateAscending: "Attiva per ordinare in ordine crescente."
                },
                sortBy: "Ordina per"
              },
              dataFooter: {
                itemsPerPageText: "Elementi per pagina:",
                itemsPerPageAll: "Tutti",
                nextPage: "Pagina seguente",
                prevPage: "Pagina precedente",
                firstPage: "Prima pagina",
                lastPage: "Ultima pagina",
                pageText: "{0}-{1} di {2}"
              },
              datePicker: {
                itemsSelected: "{0} selezionati",
                nextMonthAriaLabel: "Il prossimo mese",
                nextYearAriaLabel: "L'anno prossimo",
                prevMonthAriaLabel: "Il mese scorso",
                prevYearAriaLabel: "L'anno scorso"
              },
              noDataText: "Nessun elemento disponibile",
              carousel: {
                prev: "Vista precedente",
                next: "Prossima vista",
                ariaLabel: {
                  delimiter: "Carousel slide {0} di {1}"
                }
              },
              calendar: {
                moreEvents: "{0} di più"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} file",
                counterSize: "{0} file ({1} in totale)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigazione impaginazione",
                  next: "Pagina seguente",
                  previous: "Pagina precedente",
                  page: "Vai alla pagina {0}",
                  currentPage: "Pagina corrente, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Valutazione {0} di {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ja.ts": (
          /*!**************************!*\
            !*** ./src/locale/ja.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "バッジ",
              close: "閉じる",
              dataIterator: {
                noResultsText: "検索結果が見つかりません。",
                loadingText: "項目をロード中です..."
              },
              dataTable: {
                itemsPerPageText: "1ページあたりの行数：",
                ariaLabel: {
                  sortDescending: "降順の並び替え。",
                  sortAscending: "昇順の並び替え。",
                  sortNone: "ソートされていません。",
                  activateNone: "ソートを削除するには有効にしてください。",
                  activateDescending: "降順の並び替えのためには有効にしてください。",
                  activateAscending: "昇順のソートのためには有効にしてください。"
                },
                sortBy: "ソート方式"
              },
              dataFooter: {
                itemsPerPageText: "1ページあたりの件数：",
                itemsPerPageAll: "すべて",
                nextPage: "次のページ",
                prevPage: "前のページ",
                firstPage: "最初のページ",
                lastPage: "最後のページ",
                pageText: "{0}-{1} 件目 / {2}件"
              },
              datePicker: {
                itemsSelected: "{0}日付選択",
                nextMonthAriaLabel: "来月",
                nextYearAriaLabel: "来年",
                prevMonthAriaLabel: "前月",
                prevYearAriaLabel: "前年"
              },
              noDataText: "データはありません。",
              carousel: {
                prev: "前のビジュアル",
                next: "次のビジュアル",
                ariaLabel: {
                  delimiter: "カルーセルのスライド {0}件目 / {1}件"
                }
              },
              calendar: {
                moreEvents: "さらに{0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ファイル",
                counterSize: "{0} ファイル (合計 {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "ページネーションナビゲーション",
                  next: "次のページ",
                  previous: "前のページ",
                  page: "{0}ページ目に移動",
                  currentPage: "現在のページ、ページ {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "評価 {1} のうち {0}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ko.ts": (
          /*!**************************!*\
            !*** ./src/locale/ko.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "배지",
              close: "닫기",
              dataIterator: {
                noResultsText: "일치하는 항목이 없습니다.",
                loadingText: "불러오는 중..."
              },
              dataTable: {
                itemsPerPageText: "페이지 당 행 수:",
                ariaLabel: {
                  sortDescending: "내림차순 정렬.",
                  sortAscending: "오름차순 정렬.",
                  sortNone: "정렬하지 않음.",
                  activateNone: "정렬을 취소하려면 활성화하세요.",
                  activateDescending: "내림차순 정렬을 위해 활성화하세요.",
                  activateAscending: "오름차순 정렬을 위해 활성화하세요."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "페이지 당 항목 수:",
                itemsPerPageAll: "전체",
                nextPage: "다음 페이지",
                prevPage: "이전 페이지",
                firstPage: "첫 페이지",
                lastPage: "마지막 페이지",
                pageText: "{2} 중 {0}-{1}"
              },
              datePicker: {
                itemsSelected: "{0} 선택됨",
                nextMonthAriaLabel: "다음 달",
                nextYearAriaLabel: "내년",
                prevMonthAriaLabel: "지난달",
                prevYearAriaLabel: "전년도"
              },
              noDataText: "데이터가 없습니다.",
              carousel: {
                prev: "이전 화면",
                next: "다음 화면",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} 더보기"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "오전",
                pm: "오후"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "다음 페이지",
                  previous: "이전 페이지",
                  page: "고토 페이지 {0}",
                  currentPage: "현재 페이지, 페이지 {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/lt.ts": (
          /*!**************************!*\
            !*** ./src/locale/lt.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Ženklelis",
              close: "Uždaryti",
              dataIterator: {
                noResultsText: "Nerasta atitinkančių įrašų",
                loadingText: "Kraunama..."
              },
              dataTable: {
                itemsPerPageText: "Eilutės per puslapį:",
                ariaLabel: {
                  sortDescending: "Išrikiuota mažėjimo tvarka.",
                  sortAscending: "Išrikiuota didėjimo tvarka.",
                  sortNone: "Nerikiuota.",
                  activateNone: "Suaktyvinkite, jei norite rikiavimą pašalinti.",
                  activateDescending: "Suaktyvinkite, jei norite rikiuoti mažėjimo tvarka.",
                  activateAscending: "Suaktyvinkite, jei norite rikiuoti didėjimo tvarka."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Įrašai per puslapį:",
                itemsPerPageAll: "Visi",
                nextPage: "Kitas puslapis",
                prevPage: "Ankstesnis puslapis",
                firstPage: "Pirmas puslapis",
                lastPage: "Paskutinis puslapis",
                pageText: "{0}-{1} iš {2}"
              },
              datePicker: {
                itemsSelected: "{0} pasirinkta",
                nextMonthAriaLabel: "Kitą mėnesį",
                nextYearAriaLabel: "Kitais metais",
                prevMonthAriaLabel: "Praeita mėnesį",
                prevYearAriaLabel: "Praeiti metai"
              },
              noDataText: "Nėra duomenų",
              carousel: {
                prev: "Ankstesnioji skaidrė",
                next: "Kita skaidrė",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Daugiau {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} failų",
                counterSize: "{0} failų ({1} iš viso)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Puslapio naršymas",
                  next: "Kitas puslapis",
                  previous: "Ankstesnis puslapis",
                  page: "Eiti į puslapį {0}",
                  currentPage: "Dabartinis puslapis, puslapis {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/lv.ts": (
          /*!**************************!*\
            !*** ./src/locale/lv.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Žetons",
              close: "Aizvērt",
              dataIterator: {
                noResultsText: "Nekas netika atrasts",
                loadingText: "Ielādē..."
              },
              dataTable: {
                itemsPerPageText: "Rādīt lapā:",
                ariaLabel: {
                  sortDescending: "Sakārtots dilstošā secībā.",
                  sortAscending: "Sakārtots augošā secībā.",
                  sortNone: "Nav sakārtots.",
                  activateNone: "Aktivizēt, lai noņemtu kārtošanu.",
                  activateDescending: "Aktivizēt, lai sakārtotu dilstošā secībā.",
                  activateAscending: "Aktivizēt, lai sakārtotu augošā secībā."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Rādīt lapā:",
                itemsPerPageAll: "Visu",
                nextPage: "Nākamā lapa",
                prevPage: "Iepriekšējā lapa",
                firstPage: "Pirmā lapa",
                lastPage: "Pēdējā lapa",
                pageText: "{0}-{1} no {2}"
              },
              datePicker: {
                itemsSelected: "{0} izvēlēts",
                nextMonthAriaLabel: "Nākammēnes",
                nextYearAriaLabel: "Nākamgad",
                prevMonthAriaLabel: "Iepriekšējais mēnesis",
                prevYearAriaLabel: "Iepriekšējais gads"
              },
              noDataText: "Nav pieejamu datu",
              carousel: {
                prev: "Iepriekšējais slaids",
                next: "Nākamais slaids",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Vēl {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigācija paginationā",
                  next: "Nākamā lapa",
                  previous: "Iepriekšējā lapa",
                  page: "Iet uz lapu {0}",
                  currentPage: "Pašreizējā lapa, lapa {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/nl.ts": (
          /*!**************************!*\
            !*** ./src/locale/nl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "insigne",
              close: "Sluiten",
              dataIterator: {
                noResultsText: "Geen overeenkomende resultaten gevonden",
                loadingText: "Items aan het laden..."
              },
              dataTable: {
                itemsPerPageText: "Rijen per pagina:",
                ariaLabel: {
                  sortDescending: "Aflopend gesorteerd.",
                  sortAscending: "Oplopend gesorteerd.",
                  sortNone: "Niet gesorteerd.",
                  activateNone: "Activeer om de sortering te verwijderen.",
                  activateDescending: "Activeer om aflopend te sorteren.",
                  activateAscending: "Activeer om oplopend te sorteren."
                },
                sortBy: "Sorteer volgens"
              },
              dataFooter: {
                itemsPerPageText: "Aantal per pagina:",
                itemsPerPageAll: "Alles",
                nextPage: "Volgende pagina",
                prevPage: "Vorige pagina",
                firstPage: "Eerste pagina",
                lastPage: "Laatste pagina",
                pageText: "{0}-{1} van {2}"
              },
              datePicker: {
                itemsSelected: "{0} geselecteerd",
                nextMonthAriaLabel: "Volgende maand",
                nextYearAriaLabel: "Volgend jaar",
                prevMonthAriaLabel: "Vorige maand",
                prevYearAriaLabel: "Vorig jaar"
              },
              noDataText: "Geen gegevens beschikbaar",
              carousel: {
                prev: "Vorig beeld",
                next: "Volgend beeld",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} meer"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} bestanden",
                counterSize: "{0} bestanden ({1} in totaal)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginanavigatie",
                  next: "Volgende pagina",
                  previous: "Vorige pagina",
                  page: "Ga naar pagina {0}",
                  currentPage: "Huidige pagina, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/no.ts": (
          /*!**************************!*\
            !*** ./src/locale/no.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Skilt",
              close: "Lukk",
              dataIterator: {
                noResultsText: "Fant ingen matchende elementer.",
                loadingText: "Laster elementer..."
              },
              dataTable: {
                itemsPerPageText: "Rader per side:",
                ariaLabel: {
                  sortDescending: "Sortert synkende.",
                  sortAscending: "Sortert stigende.",
                  sortNone: "Ikke sortert.",
                  activateNone: "Aktiver for å fjerne sortering.",
                  activateDescending: "Aktiver for å sortere synkende.",
                  activateAscending: "Aktiver for å sortere stigende."
                },
                sortBy: "Sorter etter"
              },
              dataFooter: {
                itemsPerPageText: "Elementer per side:",
                itemsPerPageAll: "Alle",
                nextPage: "Neste side",
                prevPage: "Forrige side",
                firstPage: "Første side",
                lastPage: "Siste side",
                pageText: "{0}-{1} av {2}"
              },
              datePicker: {
                itemsSelected: "{0} valgt",
                nextMonthAriaLabel: "Neste måned",
                nextYearAriaLabel: "Neste år",
                prevMonthAriaLabel: "Forrige måned",
                prevYearAriaLabel: "Forrige år"
              },
              noDataText: "Ingen data er tilgjengelig",
              carousel: {
                prev: "Forrige bilde",
                next: "Neste bilde",
                ariaLabel: {
                  delimiter: "Karusellbilde {0} av {1}"
                }
              },
              calendar: {
                moreEvents: "{0} flere"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer ({1} totalt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginasjonsnavigasjon",
                  next: "Neste side",
                  previous: "Forrige side",
                  page: "Gå til side {0}",
                  currentPage: "Gjeldende side, side {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/pl.ts": (
          /*!**************************!*\
            !*** ./src/locale/pl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznaka",
              close: "Zamknij",
              dataIterator: {
                noResultsText: "Nie znaleziono danych odpowiadających wyszukiwaniu",
                loadingText: "Wczytywanie danych..."
              },
              dataTable: {
                itemsPerPageText: "Wierszy na stronie:",
                ariaLabel: {
                  sortDescending: "Sortowanie malejąco. Kliknij aby zmienić.",
                  sortAscending: "Sortowanie rosnąco. Kliknij aby zmienić.",
                  sortNone: "Bez sortowania. Kliknij aby posortować rosnąco.",
                  activateNone: "Kliknij aby usunąć sortowanie.",
                  activateDescending: "Kliknij aby posortować malejąco.",
                  activateAscending: "Kliknij aby posortować rosnąco."
                },
                sortBy: "Sortuj według"
              },
              dataFooter: {
                itemsPerPageText: "Pozycji na stronie:",
                itemsPerPageAll: "Wszystkie",
                nextPage: "Następna strona",
                prevPage: "Poprzednia strona",
                firstPage: "Pierwsza strona",
                lastPage: "Ostatnia strona",
                pageText: "{0}-{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} dat(y)",
                nextMonthAriaLabel: "Następny miesiąc",
                nextYearAriaLabel: "Następny rok",
                prevMonthAriaLabel: "Poprzedni miesiąc",
                prevYearAriaLabel: "Poprzedni rok"
              },
              noDataText: "Brak danych",
              carousel: {
                prev: "Poprzedni obraz",
                next: "Następny obraz",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} więcej"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "Liczba plików: {0}",
                counterSize: "Liczba plików: {0} (łącznie {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Nawigacja paginacyjna",
                  next: "Następna strona",
                  previous: "Poprzednia strona",
                  page: "Idź do strony {0}",
                  currentPage: "Bieżąca strona, strona {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/pt.ts": (
          /*!**************************!*\
            !*** ./src/locale/pt.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Distintivo",
              close: "Fechar",
              dataIterator: {
                noResultsText: "Nenhum dado encontrado",
                loadingText: "Carregando itens..."
              },
              dataTable: {
                itemsPerPageText: "Linhas por página:",
                ariaLabel: {
                  sortDescending: "Ordenado decrescente.",
                  sortAscending: "Ordenado crescente.",
                  sortNone: "Não ordenado.",
                  activateNone: "Ative para remover a ordenação.",
                  activateDescending: "Ative para ordenar decrescente.",
                  activateAscending: "Ative para ordenar crescente."
                },
                sortBy: "Ordenar por"
              },
              dataFooter: {
                itemsPerPageText: "Itens por página:",
                itemsPerPageAll: "Todos",
                nextPage: "Próxima página",
                prevPage: "Página anterior",
                firstPage: "Primeira página",
                lastPage: "Última página",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} selecionado(s)",
                nextMonthAriaLabel: "Próximo mês",
                nextYearAriaLabel: "Próximo ano",
                prevMonthAriaLabel: "Mês anterior",
                prevYearAriaLabel: "Ano anterior"
              },
              noDataText: "Não há dados disponíveis",
              carousel: {
                prev: "Visão anterior",
                next: "Próxima visão",
                ariaLabel: {
                  delimiter: "Slide {0} de {1} do carrossel"
                }
              },
              calendar: {
                moreEvents: "Mais {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} arquivo(s)",
                counterSize: "{0} arquivo(s) ({1} no total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegação de paginação",
                  next: "Próxima página",
                  previous: "Página anterior",
                  page: "Ir à página {0}",
                  currentPage: "Página atual, página {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ro.ts": (
          /*!**************************!*\
            !*** ./src/locale/ro.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Insignă",
              close: "Închideți",
              dataIterator: {
                noResultsText: "Nu s-au găsit înregistrări corespunzătoare",
                loadingText: "Se încarcă articolele..."
              },
              dataTable: {
                itemsPerPageText: "Rânduri pe pagină:",
                ariaLabel: {
                  sortDescending: "Sortate descendent.",
                  sortAscending: "Sortate ascendent.",
                  sortNone: "Nesortate.",
                  activateNone: "Activați pentru a elimina sortarea.",
                  activateDescending: "Activați pentru a sorta descendent.",
                  activateAscending: "Activați pentru a sorta ascendent."
                },
                sortBy: "Sortați după"
              },
              dataFooter: {
                itemsPerPageText: "Articole pe pagină:",
                itemsPerPageAll: "Toate",
                nextPage: "Pagina următoare",
                prevPage: "Pagina anterioară",
                firstPage: "Prima pagină",
                lastPage: "Ultima pagină",
                pageText: "{0}-{1} din {2}"
              },
              datePicker: {
                itemsSelected: "{0} selectate",
                nextMonthAriaLabel: "Luna următoare",
                nextYearAriaLabel: "Anul următor",
                prevMonthAriaLabel: "Luna anterioară",
                prevYearAriaLabel: "Anul anterior"
              },
              noDataText: "Nu există date disponibile",
              carousel: {
                prev: "Grafica anterioară",
                next: "Grafica următoare",
                ariaLabel: {
                  delimiter: "Slide carusel {0} din {1}"
                }
              },
              calendar: {
                moreEvents: "încă {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fișiere",
                counterSize: "{0} fișiere ({1} în total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigare prin paginare",
                  next: "Pagina următoare",
                  previous: "Pagina anterioară",
                  page: "Mergeți la pagina {0}",
                  currentPage: "Pagina curentă, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating de {0} din {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ru.ts": (
          /*!**************************!*\
            !*** ./src/locale/ru.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "знак",
              close: "Закрыть",
              dataIterator: {
                noResultsText: "Не найдено подходящих записей",
                loadingText: "Запись загружается..."
              },
              dataTable: {
                itemsPerPageText: "Строк на странице:",
                ariaLabel: {
                  sortDescending: "Упорядочено по убыванию.",
                  sortAscending: "Упорядочено по возрастанию.",
                  sortNone: "Не упорядочено.",
                  activateNone: "Активируйте, чтобы убрать сортировку.",
                  activateDescending: "Активируйте для упорядочивания убыванию.",
                  activateAscending: "Активируйте для упорядочивания по возрастанию."
                },
                sortBy: "Сортировать по"
              },
              dataFooter: {
                itemsPerPageText: "Записей на странице:",
                itemsPerPageAll: "Все",
                nextPage: "Следующая страница",
                prevPage: "Предыдущая страница",
                firstPage: "Первая страница",
                lastPage: "Последняя страница",
                pageText: "{0}-{1} из {2}"
              },
              datePicker: {
                itemsSelected: "{0} выбран",
                nextMonthAriaLabel: "Следующий месяц",
                nextYearAriaLabel: "Следующий год",
                prevMonthAriaLabel: "Прошлый месяц",
                prevYearAriaLabel: "Предыдущий год"
              },
              noDataText: "Отсутствуют данные",
              carousel: {
                prev: "Предыдущий слайд",
                next: "Следующий слайд",
                ariaLabel: {
                  delimiter: "Слайд {0} из {1}"
                }
              },
              calendar: {
                moreEvents: "Еще {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "Файлов: {0}",
                counterSize: "Файлов: {0} (всего {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Навигация по страницам",
                  next: "Следующая страница",
                  previous: "Предыдущая страница",
                  page: "Перейти на страницу {0}",
                  currentPage: "Текущая страница, Страница {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sk.ts": (
          /*!**************************!*\
            !*** ./src/locale/sk.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznak",
              close: "Zavrieť",
              dataIterator: {
                noResultsText: "Neboli nájdené žiadne záznamy",
                loadingText: "Načítavam položky..."
              },
              dataTable: {
                itemsPerPageText: "Počet riadkov na stránku:",
                ariaLabel: {
                  sortDescending: "Zoradené zostupne.",
                  sortAscending: "Zoradené vzostupne.",
                  sortNone: "Nezoradené.",
                  activateNone: "Aktivujte na zrušenie triedenia.",
                  activateDescending: "Aktivujte na zoradenie zostupne.",
                  activateAscending: "Aktivujte na zoradenie vzostupne."
                },
                sortBy: "Zoradiť podľa"
              },
              dataFooter: {
                itemsPerPageText: "Počet položiek na stránku:",
                itemsPerPageAll: "Všetko",
                nextPage: "Ďalšia stránka",
                prevPage: "Predchádzajúca stránka",
                firstPage: "Prvá stránka",
                lastPage: "Posledná stránka",
                pageText: "{0}–{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} vybrané",
                nextMonthAriaLabel: "Ďalší mesiac",
                nextYearAriaLabel: "Ďalší rok",
                prevMonthAriaLabel: "Predchádzajúci mesiac",
                prevYearAriaLabel: "Predchádzajúci rok"
              },
              noDataText: "Nie sú dostupné žiadne dáta",
              carousel: {
                prev: "Predchádzajúci obrázok",
                next: "Další obrázok",
                ariaLabel: {
                  delimiter: "Snímka {0} z {1}"
                }
              },
              calendar: {
                moreEvents: "{0} ďalších"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} súborov",
                counterSize: "{0} súborov ({1} celkom)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigácia stránkovania",
                  next: "Ďalšia stránka",
                  previous: "Predchádzajúca stránka",
                  page: "Ísť na stránku {0}",
                  currentPage: "Aktuálna stránka, stránka {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Hodnotenie {0} z {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sl.ts": (
          /*!**************************!*\
            !*** ./src/locale/sl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Značka",
              close: "Zapri",
              dataIterator: {
                noResultsText: "Ni iskanega zapisa",
                loadingText: "Nalaganje..."
              },
              dataTable: {
                itemsPerPageText: "Vrstic na stran:",
                ariaLabel: {
                  sortDescending: "Razvrščeno padajoče.",
                  sortAscending: "Razvrščeno naraščajoče.",
                  sortNone: "Ni razvrščeno.",
                  activateNone: "Aktivirajte za odstranitev razvrščanja.",
                  activateDescending: "Aktivirajte za padajoče razvrščanje.",
                  activateAscending: "Aktivirajte za naraščajoče razvrščanje."
                },
                sortBy: "Razvrsti po"
              },
              dataFooter: {
                itemsPerPageText: "Predmetov na stran:",
                itemsPerPageAll: "Vse",
                nextPage: "Naslednja stran",
                prevPage: "Prejšnja stran",
                firstPage: "Prva stran",
                lastPage: "Zadnja stran",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} izbrano/-ih",
                nextMonthAriaLabel: "Naslednji mesec",
                nextYearAriaLabel: "Naslednje leto",
                prevMonthAriaLabel: "Prejšnji mesec",
                prevYearAriaLabel: "Prejšnje leto"
              },
              noDataText: "Ni podatkov",
              carousel: {
                prev: "Prejšnji prikaz",
                next: "Naslednji prikaz",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Še {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} datotek",
                counterSize: "{0} datotek ({1} skupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija po strani po strani",
                  next: "Naslednja stran",
                  previous: "Prejšnja stran",
                  page: "Pojdi na stran {0}",
                  currentPage: "Trenutna stran, stran {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sr-Cyrl.ts": (
          /*!*******************************!*\
            !*** ./src/locale/sr-Cyrl.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Значка",
              close: "Затвори",
              dataIterator: {
                noResultsText: "Ни један запис није пронађен",
                loadingText: "Учитавање ставке..."
              },
              dataTable: {
                itemsPerPageText: "Редова по страници:",
                ariaLabel: {
                  sortDescending: "Сортирано опадајуће.",
                  sortAscending: "Сортирано растуће.",
                  sortNone: "Није сортирано.",
                  activateNone: "Кликни да уклониш сортирање.",
                  activateDescending: "Кликни да сортираш опадајуће.",
                  activateAscending: "Кликни да сортираш растуће."
                },
                sortBy: "Сортирај по"
              },
              dataFooter: {
                itemsPerPageText: "Ставки по страници:",
                itemsPerPageAll: "Све",
                nextPage: "Следећа страница",
                prevPage: "Претходна страница",
                firstPage: "Прва страница",
                lastPage: "Последња страница",
                pageText: "{0}-{1} од {2}"
              },
              datePicker: {
                itemsSelected: "{0} одабрано",
                nextMonthAriaLabel: "Следећег месеца",
                nextYearAriaLabel: "Следеће године",
                prevMonthAriaLabel: "Претходни месец",
                prevYearAriaLabel: "Претходна година"
              },
              noDataText: "Нема доступних података",
              carousel: {
                prev: "Претходна слика",
                next: "Следећа слика",
                ariaLabel: {
                  delimiter: "Слика {0} од {1}"
                }
              },
              calendar: {
                moreEvents: "{0} више"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} фајлова",
                counterSize: "{0} фајлова ({1} укупно)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Навигација страницама",
                  next: "Следећа страница",
                  previous: "Претходна страница",
                  page: "Иди на страну {0}",
                  currentPage: "Тренутна страница, страница {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Оцена {0} од {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sr-Latn.ts": (
          /*!*******************************!*\
            !*** ./src/locale/sr-Latn.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Značka",
              close: "Zatvori",
              dataIterator: {
                noResultsText: "Nijedan zapis nije pronađen",
                loadingText: "Učitavanje stavke..."
              },
              dataTable: {
                itemsPerPageText: "Redova po stranici:",
                ariaLabel: {
                  sortDescending: "Sortirano opadajuće.",
                  sortAscending: "Sortirano rastuće.",
                  sortNone: "Nije sortirano.",
                  activateNone: "Klikni da ukloniš sortiranje.",
                  activateDescending: "Klikni da sortiraš opadajuće.",
                  activateAscending: "Klikni da sortiraš rastuće."
                },
                sortBy: "Sortiraj po"
              },
              dataFooter: {
                itemsPerPageText: "Stavki po stranici:",
                itemsPerPageAll: "Sve",
                nextPage: "Sledeća stranica",
                prevPage: "Prethodna stranica",
                firstPage: "Prva stranica",
                lastPage: "Poslednja stranica",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} odabrano",
                nextMonthAriaLabel: "Sledećeg meseca",
                nextYearAriaLabel: "Sledeće godine",
                prevMonthAriaLabel: "Prethodni mesec",
                prevYearAriaLabel: "Prethodna godina"
              },
              noDataText: "Nema dostupnih podataka",
              carousel: {
                prev: "Prethodna slika",
                next: "Sledeća slika",
                ariaLabel: {
                  delimiter: "Slika {0} od {1}"
                }
              },
              calendar: {
                moreEvents: "{0} više"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fajlova",
                counterSize: "{0} fajlova ({1} ukupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija stranicama",
                  next: "Sledeća stranica",
                  previous: "Prethodna stranica",
                  page: "Idi na stranu {0}",
                  currentPage: "Trenutna stranica, stranica {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Ocena {0} od {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sv.ts": (
          /*!**************************!*\
            !*** ./src/locale/sv.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Bricka",
              close: "Stäng",
              dataIterator: {
                noResultsText: "Inga poster funna",
                loadingText: "Laddar data..."
              },
              dataTable: {
                itemsPerPageText: "Rader per sida:",
                ariaLabel: {
                  sortDescending: "Sorterat fallande.",
                  sortAscending: "Sorterat stigande.",
                  sortNone: "Osorterat.",
                  activateNone: "Aktivera för att ta bort sortering.",
                  activateDescending: "Aktivera för sortering fallande.",
                  activateAscending: "Aktivera för sortering stigande."
                },
                sortBy: "Sortera efter"
              },
              dataFooter: {
                itemsPerPageText: "Objekt per sida:",
                itemsPerPageAll: "Alla",
                nextPage: "Nästa sida",
                prevPage: "Föregående sida",
                firstPage: "Första sidan",
                lastPage: "Sista sidan",
                pageText: "{0}-{1} av {2}"
              },
              datePicker: {
                itemsSelected: "{0} markerade",
                nextMonthAriaLabel: "Nästa månad",
                nextYearAriaLabel: "Nästa år",
                prevMonthAriaLabel: "Förra månaden",
                prevYearAriaLabel: "Förra året"
              },
              noDataText: "Ingen data tillgänglig",
              carousel: {
                prev: "Föregående vy",
                next: "Nästa vy",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} fler"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer (av {1} totalt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Nästa sida",
                  previous: "Föregående sida",
                  page: "Gå till sidan {0}",
                  currentPage: "Aktuell sida, sida {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/th.ts": (
          /*!**************************!*\
            !*** ./src/locale/th.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "สัญลักษณ์",
              close: "ปิด",
              dataIterator: {
                noResultsText: "ไม่พบข้อมูลที่ค้นหา",
                loadingText: "กำลังโหลดข้อมูล..."
              },
              dataTable: {
                itemsPerPageText: "แถวต่อหน้า:",
                ariaLabel: {
                  sortDescending: "เรียงจากมากไปน้อยอยู่",
                  sortAscending: "เรียงจากน้อยไปมากอยู่",
                  sortNone: "ไม่ได้เรียงลำดับ",
                  activateNone: "กดเพื่อปิดการเรียงลำดับ",
                  activateDescending: "กดเพื่อเรียงจากมากไปน้อย",
                  activateAscending: "กดเพื่อเรียงจากน้อยไปมาก"
                },
                sortBy: "เรียงตาม"
              },
              dataFooter: {
                itemsPerPageText: "รายการต่อหน้า:",
                itemsPerPageAll: "ทั้งหมด",
                nextPage: "หน้าต่อไป",
                prevPage: "หน้าที่แล้ว",
                firstPage: "หน้าแรก",
                lastPage: "หน้าสุดท้าย",
                pageText: "{0}-{1} จาก {2}"
              },
              datePicker: {
                itemsSelected: "เลือก {0} วัน",
                nextMonthAriaLabel: "เดือนถัดไป",
                nextYearAriaLabel: "ปีถัดไป",
                prevMonthAriaLabel: "เดือนก่อนหน้า",
                prevYearAriaLabel: "ปีก่อนหน้า"
              },
              noDataText: "ไม่มีข้อมูล",
              carousel: {
                prev: "ภาพก่อนหน้า",
                next: "ภาพถัดไป",
                ariaLabel: {
                  delimiter: "ภาพสไลด์ที่ {0} จาก {1}"
                }
              },
              calendar: {
                moreEvents: "มีอีก {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ไฟล์",
                counterSize: "{0} ไฟล์ (รวม {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "การนำทางไปยังหน้า",
                  next: "หน้าต่อไป",
                  previous: "หน้าที่แล้ว",
                  page: "ไปที่หน้า {0}",
                  currentPage: "หน้าปัจจุบัน (หน้า {0})"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/tr.ts": (
          /*!**************************!*\
            !*** ./src/locale/tr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "rozet",
              close: "Kapat",
              dataIterator: {
                noResultsText: "Eşleşen veri bulunamadı",
                loadingText: "Yükleniyor... Lütfen bekleyin."
              },
              dataTable: {
                itemsPerPageText: "Sayfa başına satır:",
                ariaLabel: {
                  sortDescending: "Z den A ya sıralı.",
                  sortAscending: "A dan Z ye sıralı.",
                  sortNone: "Sıralı değil. ",
                  activateNone: "Sıralamayı kaldırmak için etkinleştir.",
                  activateDescending: "Z den A ya sıralamak için etkinleştir.",
                  activateAscending: "A dan Z ye sıralamak için etkinleştir."
                },
                sortBy: "Sırala"
              },
              dataFooter: {
                itemsPerPageText: "Sayfa başına satır:",
                itemsPerPageAll: "Hepsi",
                nextPage: "Sonraki sayfa",
                prevPage: "Önceki sayfa",
                firstPage: "İlk sayfa",
                lastPage: "Son sayfa",
                pageText: "{0} - {1} arası, Toplam: {2} kayıt"
              },
              datePicker: {
                itemsSelected: "{0} öge seçildi",
                nextMonthAriaLabel: "Gelecek ay",
                nextYearAriaLabel: "Gelecek yıl",
                prevMonthAriaLabel: "Geçtiğimiz ay",
                prevYearAriaLabel: "Geçen yıl"
              },
              noDataText: "Bu görünümde veri yok.",
              carousel: {
                prev: "Önceki görsel",
                next: "Sonraki görsel",
                ariaLabel: {
                  delimiter: "Galeri sayfa {0} / {1}"
                }
              },
              calendar: {
                moreEvents: "{0} tane daha"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} dosya",
                counterSize: "{0} dosya (toplamda {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Sayfalandırma Navigasyonu",
                  next: "Sonraki sayfa",
                  previous: "Önceki sayfa",
                  page: "Sayfaya git {0}",
                  currentPage: "Geçerli Sayfa, Sayfa {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/uk.ts": (
          /*!**************************!*\
            !*** ./src/locale/uk.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Знак",
              close: "Закрити",
              dataIterator: {
                noResultsText: "В результаті пошуку нічого не знайдено",
                loadingText: "Завантаження..."
              },
              dataTable: {
                itemsPerPageText: "Рядків на сторінці:",
                ariaLabel: {
                  sortDescending: "Відсортовано за спаданням.",
                  sortAscending: "Відсортовано за зростанням.",
                  sortNone: "Не відсортовано.",
                  activateNone: "Активувати, щоб видалити сортування.",
                  activateDescending: "Активувати, щоб відсортувати за спаданням.",
                  activateAscending: "Активувати, щоб відсортувати за зростанням."
                },
                sortBy: "Відсортувати за"
              },
              dataFooter: {
                itemsPerPageText: "Елементів на сторінці:",
                itemsPerPageAll: "Всі",
                nextPage: "Наступна сторінка",
                prevPage: "Попередня сторінка",
                firstPage: "Перша сторінка",
                lastPage: "Остання сторінка",
                pageText: "{0}-{1} з {2}"
              },
              datePicker: {
                itemsSelected: "{0} вибрано",
                nextMonthAriaLabel: "Наступного місяця",
                nextYearAriaLabel: "Наступного року",
                prevMonthAriaLabel: "Попередній місяць",
                prevYearAriaLabel: "Попередній рік"
              },
              noDataText: "Немає даних для відображення",
              carousel: {
                prev: "Попередній слайд",
                next: "Наступий слайд",
                ariaLabel: {
                  delimiter: "Слайд {0} з {1}"
                }
              },
              calendar: {
                moreEvents: "Ще {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} файлів",
                counterSize: "{0} файлів ({1} загалом)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Навігація по сторінках",
                  next: "Наступна сторінка",
                  previous: "Попередня сторінка",
                  page: "Перейти на сторінку {0}",
                  currentPage: "Поточна сторінка, Сторінка {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/vi.ts": (
          /*!**************************!*\
            !*** ./src/locale/vi.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Huy hiệu",
              close: "Đóng",
              dataIterator: {
                noResultsText: "Không tìm thấy kết quả nào",
                loadingText: "Đang tải..."
              },
              dataTable: {
                itemsPerPageText: "Số hàng mỗi trang:",
                ariaLabel: {
                  sortDescending: "Sắp xếp giảm dần.",
                  sortAscending: "Sắp xếp tăng dần.",
                  sortNone: "Không sắp xếp.",
                  activateNone: "Kích hoạt để bỏ sắp xếp.",
                  activateDescending: "Kích hoạt để sắp xếp giảm dần.",
                  activateAscending: "Kích hoạt để sắp xếp tăng dần."
                },
                sortBy: "Sắp xếp"
              },
              dataFooter: {
                itemsPerPageText: "Số mục mỗi trang:",
                itemsPerPageAll: "Toàn bộ",
                nextPage: "Trang tiếp theo",
                prevPage: "Trang trước",
                firstPage: "Trang đầu",
                lastPage: "Trang cuối",
                pageText: "{0}-{1} trên {2}"
              },
              datePicker: {
                itemsSelected: "{0} được chọn",
                nextMonthAriaLabel: "Tháng sau",
                nextYearAriaLabel: "Năm sau",
                prevMonthAriaLabel: "Tháng trước",
                prevYearAriaLabel: "Năm trước"
              },
              noDataText: "Không có dữ liệu",
              carousel: {
                prev: "Ảnh tiếp theo",
                next: "Ảnh trước",
                ariaLabel: {
                  delimiter: "Carousel slide {0} trên {1}"
                }
              },
              calendar: {
                moreEvents: "{0} nữa"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} tệp",
                counterSize: "{0} tệp (tổng cộng {1})"
              },
              timePicker: {
                am: "SA",
                pm: "CH"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Điều hướng phân trang",
                  next: "Trang tiếp theo",
                  previous: "Trang trước",
                  page: "Đến trang {0}",
                  currentPage: "Trang hiện tại, Trang {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Đánh giá {0} trên {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/zh-Hans.ts": (
          /*!*******************************!*\
            !*** ./src/locale/zh-Hans.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "徽章",
              close: "关闭",
              dataIterator: {
                noResultsText: "没有符合条件的结果",
                loadingText: "加载中……"
              },
              dataTable: {
                itemsPerPageText: "每页数目：",
                ariaLabel: {
                  sortDescending: "：降序排列。",
                  sortAscending: "：升序排列。",
                  sortNone: "：未排序。",
                  activateNone: "点击以移除排序。",
                  activateDescending: "点击以降序排列。",
                  activateAscending: "点击以升序排列。"
                },
                sortBy: "排序方式"
              },
              dataFooter: {
                itemsPerPageText: "每页数目：",
                itemsPerPageAll: "全部",
                nextPage: "下一页",
                prevPage: "上一页",
                firstPage: "首页",
                lastPage: "尾页",
                pageText: "{0}-{1} 共 {2}"
              },
              datePicker: {
                itemsSelected: "已选择 {0}",
                nextMonthAriaLabel: "下个月",
                nextYearAriaLabel: "明年",
                prevMonthAriaLabel: "前一个月",
                prevYearAriaLabel: "前一年"
              },
              noDataText: "没有数据",
              carousel: {
                prev: "上一张",
                next: "下一张",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "还有 {0} 项"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} 个文件",
                counterSize: "{0} 个文件（共 {1}）"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "分页导航",
                  next: "下一页",
                  previous: "上一页",
                  page: "转到页面 {0}",
                  currentPage: "当前页 {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/zh-Hant.ts": (
          /*!*******************************!*\
            !*** ./src/locale/zh-Hant.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "徽章",
              close: "關閉",
              dataIterator: {
                noResultsText: "沒有符合條件的結果",
                loadingText: "讀取中..."
              },
              dataTable: {
                itemsPerPageText: "每頁列數：",
                ariaLabel: {
                  sortDescending: "：降序排列。",
                  sortAscending: "：升序排列。",
                  sortNone: "無排序方式。點擊以升序排列。",
                  activateNone: "點擊以移除排序方式。",
                  activateDescending: "點擊以降序排列。",
                  activateAscending: "點擊以移除排序方式。"
                },
                sortBy: "排序方式"
              },
              dataFooter: {
                itemsPerPageText: "每頁項目：",
                itemsPerPageAll: "全部",
                nextPage: "下一頁",
                prevPage: "上一頁",
                firstPage: "第一頁",
                lastPage: "最後頁",
                pageText: "{2} 條中的 {0}~{1} 條"
              },
              datePicker: {
                itemsSelected: "已選擇 {0}",
                nextMonthAriaLabel: "下個月",
                nextYearAriaLabel: "明年",
                prevMonthAriaLabel: "前一個月",
                prevYearAriaLabel: "前一年"
              },
              noDataText: "沒有資料",
              carousel: {
                prev: "上一張",
                next: "下一張",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "還有其他 {0} 項"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} 個檔案",
                counterSize: "{0} 個檔案（共 {1}）"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "分頁導航",
                  next: "下一頁",
                  previous: "上一頁",
                  page: "轉到頁面 {0}",
                  currentPage: "當前頁 {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/mixins/activatable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/activatable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../delayable */
              "./src/mixins/delayable/index.ts"
            ), o = i(
              /*! ../toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function u(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function(m) {
                return typeof m;
              } : u = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, u(p);
            }
            var c = function(p) {
              var g = typeof Symbol == "function" && Symbol.iterator, m = g && p[g], v = 0;
              if (m)
                return m.call(p);
              if (p && typeof p.length == "number")
                return {
                  next: function() {
                    return p && v >= p.length && (p = void 0), {
                      value: p && p[v++],
                      done: !p
                    };
                  }
                };
              throw new TypeError(g ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, h = Object(l.default)(a.default, o.default);
            r.default = h.extend({
              name: "activatable",
              props: {
                activator: {
                  default: null,
                  validator: function(g) {
                    return ["string", "object"].includes(u(g));
                  }
                },
                disabled: Boolean,
                internalActivator: Boolean,
                openOnClick: {
                  type: Boolean,
                  default: !0
                },
                openOnHover: Boolean,
                openOnFocus: Boolean
              },
              data: function() {
                return {
                  // Do not use this directly, call getActivator() instead
                  activatorElement: null,
                  activatorNode: [],
                  events: ["click", "mouseenter", "mouseleave", "focus"],
                  listeners: {}
                };
              },
              watch: {
                activator: "resetActivator",
                openOnFocus: "resetActivator",
                openOnHover: "resetActivator"
              },
              mounted: function() {
                var g = Object(f.getSlotType)(this, "activator", !0);
                g && ["v-slot", "normal"].includes(g) && Object(d.consoleError)(`The activator slot must be bound, try '<template v-slot:activator="{ on }"><v-btn v-on="on">'`, this), this.addActivatorEvents();
              },
              beforeDestroy: function() {
                this.removeActivatorEvents();
              },
              methods: {
                addActivatorEvents: function() {
                  var g, m;
                  if (!(!this.activator || this.disabled || !this.getActivator())) {
                    this.listeners = this.genActivatorListeners();
                    var v = Object.keys(this.listeners);
                    try {
                      for (var y = c(v), E = y.next(); !E.done; E = y.next()) {
                        var C = E.value;
                        this.getActivator().addEventListener(C, this.listeners[C]);
                      }
                    } catch (x) {
                      g = {
                        error: x
                      };
                    } finally {
                      try {
                        E && !E.done && (m = y.return) && m.call(y);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                  }
                },
                genActivator: function() {
                  var g = Object(f.getSlot)(this, "activator", Object.assign(this.getValueProxy(), {
                    on: this.genActivatorListeners(),
                    attrs: this.genActivatorAttributes()
                  })) || [];
                  return this.activatorNode = g, g;
                },
                genActivatorAttributes: function() {
                  return {
                    role: this.openOnClick && !this.openOnHover ? "button" : void 0,
                    "aria-haspopup": !0,
                    "aria-expanded": String(this.isActive)
                  };
                },
                genActivatorListeners: function() {
                  var g = this;
                  if (this.disabled)
                    return {};
                  var m = {};
                  return this.openOnHover ? (m.mouseenter = function(v) {
                    g.getActivator(v), g.runDelay("open");
                  }, m.mouseleave = function(v) {
                    g.getActivator(v), g.runDelay("close");
                  }) : this.openOnClick && (m.click = function(v) {
                    var y = g.getActivator(v);
                    y && y.focus(), v.stopPropagation(), g.isActive = !g.isActive;
                  }), this.openOnFocus && (m.focus = function(v) {
                    g.getActivator(v), v.stopPropagation(), g.isActive = !g.isActive;
                  }), m;
                },
                getActivator: function(g) {
                  if (this.activatorElement)
                    return this.activatorElement;
                  var m = null;
                  if (this.activator) {
                    var v = this.internalActivator ? this.$el : document;
                    typeof this.activator == "string" ? m = v.querySelector(this.activator) : this.activator.$el ? m = this.activator.$el : m = this.activator;
                  } else if (this.activatorNode.length === 1 || this.activatorNode.length && !g) {
                    var y = this.activatorNode[0].componentInstance;
                    y && y.$options.mixins && //                         Activatable is indirectly used via Menuable
                    y.$options.mixins.some(function(E) {
                      return E.options && ["activatable", "menuable"].includes(E.options.name);
                    }) ? m = y.getActivator() : m = this.activatorNode[0].elm;
                  } else
                    g && (m = g.currentTarget || g.target);
                  return this.activatorElement = (m == null ? void 0 : m.nodeType) === Node.ELEMENT_NODE ? m : null, this.activatorElement;
                },
                getContentSlot: function() {
                  return Object(f.getSlot)(this, "default", this.getValueProxy(), !0);
                },
                getValueProxy: function() {
                  var g = this;
                  return {
                    get value() {
                      return g.isActive;
                    },
                    set value(m) {
                      g.isActive = m;
                    }
                  };
                },
                removeActivatorEvents: function() {
                  var g, m;
                  if (!(!this.activator || !this.activatorElement)) {
                    var v = Object.keys(this.listeners);
                    try {
                      for (var y = c(v), E = y.next(); !E.done; E = y.next()) {
                        var C = E.value;
                        this.activatorElement.removeEventListener(C, this.listeners[C]);
                      }
                    } catch (x) {
                      g = {
                        error: x
                      };
                    } finally {
                      try {
                        E && !E.done && (m = y.return) && m.call(y);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                    this.listeners = {};
                  }
                },
                resetActivator: function() {
                  this.removeActivatorEvents(), this.activatorElement = null, this.getActivator(), this.addActivatorEvents();
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/applicationable/index.ts": (
          /*!*********************************************!*\
            !*** ./src/mixins/applicationable/index.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! ../positionable */
              "./src/mixins/positionable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function l(f, d) {
              return d === void 0 && (d = []), Object(o.default)(Object(a.factory)(["absolute", "fixed"])).extend({
                name: "applicationable",
                props: {
                  app: Boolean
                },
                computed: {
                  applicationProperty: function() {
                    return f;
                  }
                },
                watch: {
                  // If previous value was app
                  // reset the provided prop
                  app: function(c, h) {
                    h ? this.removeApplication(!0) : this.callUpdate();
                  },
                  applicationProperty: function(c, h) {
                    this.$vuetify.application.unregister(this._uid, h);
                  }
                },
                activated: function() {
                  this.callUpdate();
                },
                created: function() {
                  for (var c = 0, h = d.length; c < h; c++)
                    this.$watch(d[c], this.callUpdate);
                  this.callUpdate();
                },
                mounted: function() {
                  this.callUpdate();
                },
                deactivated: function() {
                  this.removeApplication();
                },
                destroyed: function() {
                  this.removeApplication();
                },
                methods: {
                  callUpdate: function() {
                    this.app && this.$vuetify.application.register(this._uid, this.applicationProperty, this.updateApplication());
                  },
                  removeApplication: function(c) {
                    c === void 0 && (c = !1), !(!c && !this.app) && this.$vuetify.application.unregister(this._uid, this.applicationProperty);
                  },
                  updateApplication: function() {
                    return 0;
                  }
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/binds-attrs/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/binds-attrs/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(f) {
              return function(d, u) {
                for (var c in u)
                  Object.prototype.hasOwnProperty.call(d, c) || this.$delete(this.$data[f], c);
                for (var c in d)
                  this.$set(this.$data[f], c, d[c]);
              };
            }
            r.default = o.a.extend({
              data: function() {
                return {
                  attrs$: {},
                  listeners$: {}
                };
              },
              created: function() {
                this.$watch("$attrs", l("attrs$"), {
                  immediate: !0
                }), this.$watch("$listeners", l("listeners$"), {
                  immediate: !0
                });
              }
            });
          }
        ),
        /***/
        "./src/mixins/bootable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/bootable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend().extend({
              name: "bootable",
              props: {
                eager: Boolean
              },
              data: function() {
                return {
                  isBooted: !1
                };
              },
              computed: {
                hasContent: function() {
                  return this.isBooted || this.eager || this.isActive;
                }
              },
              watch: {
                isActive: function() {
                  this.isBooted = !0;
                }
              },
              created: function() {
                "lazy" in this.$attrs && Object(a.removed)("lazy", this);
              },
              methods: {
                showLazyContent: function(d) {
                  return this.hasContent && d ? d() : [this.$createElement()];
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/button-group/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/button-group/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            );
            r.default = a.BaseItemGroup.extend({
              name: "button-group",
              provide: function() {
                return {
                  btnToggle: this
                };
              },
              computed: {
                classes: function() {
                  return a.BaseItemGroup.options.computed.classes.call(this);
                }
              },
              methods: {
                // Isn't being passed down through types
                genData: a.BaseItemGroup.options.methods.genData
              }
            });
          }
        ),
        /***/
        "./src/mixins/colorable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/colorable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            };
            r.default = o.a.extend({
              name: "colorable",
              props: {
                color: String
              },
              methods: {
                setBackgroundColor: function(h, p) {
                  var g;
                  return p === void 0 && (p = {}), typeof p.style == "string" ? (Object(l.consoleError)("style must be an object", this), p) : typeof p.class == "string" ? (Object(l.consoleError)("class must be an object", this), p) : (Object(f.isCssColor)(h) ? p.style = d(d({}, p.style), {
                    "background-color": "" + h,
                    "border-color": "" + h
                  }) : h && (p.class = d(d({}, p.class), (g = {}, g[h] = !0, g))), p);
                },
                setTextColor: function(h, p) {
                  var g;
                  if (p === void 0 && (p = {}), typeof p.style == "string")
                    return Object(l.consoleError)("style must be an object", this), p;
                  if (typeof p.class == "string")
                    return Object(l.consoleError)("class must be an object", this), p;
                  if (Object(f.isCssColor)(h))
                    p.style = d(d({}, p.style), {
                      color: "" + h,
                      "caret-color": "" + h
                    });
                  else if (h) {
                    var m = u(h.toString().trim().split(" ", 2), 2), v = m[0], y = m[1];
                    p.class = d(d({}, p.class), (g = {}, g[v + "--text"] = !0, g)), y && (p.class["text--" + y] = !0);
                  }
                  return p;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/comparable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/comparable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = o.a.extend({
              name: "comparable",
              props: {
                valueComparator: {
                  type: Function,
                  default: l.deepEqual
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/delayable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/delayable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend().extend({
              name: "delayable",
              props: {
                openDelay: {
                  type: [Number, String],
                  default: 0
                },
                closeDelay: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  openTimeout: void 0,
                  closeTimeout: void 0
                };
              },
              methods: {
                /**
                 * Clear any pending delay timers from executing
                 */
                clearDelay: function() {
                  clearTimeout(this.openTimeout), clearTimeout(this.closeTimeout);
                },
                /**
                 * Runs callback after a specified delay
                 */
                runDelay: function(f, d) {
                  var u = this;
                  this.clearDelay();
                  var c = parseInt(this[f + "Delay"], 10);
                  this[f + "Timeout"] = setTimeout(d || function() {
                    u.isActive = {
                      open: !0,
                      close: !1
                    }[f];
                  }, c);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/dependent/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/dependent/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, l = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            function f(d) {
              for (var u = [], c = 0; c < d.length; c++) {
                var h = d[c];
                h.isActive && h.isDependent ? u.push(h) : u.push.apply(u, l([], o(f(h.$children)), !1));
              }
              return u;
            }
            r.default = Object(a.default)().extend({
              name: "dependent",
              data: function() {
                return {
                  closeDependents: !0,
                  isActive: !1,
                  isDependent: !0
                };
              },
              watch: {
                isActive: function(u) {
                  if (!u)
                    for (var c = this.getOpenDependents(), h = 0; h < c.length; h++)
                      c[h].isActive = !1;
                }
              },
              methods: {
                getOpenDependents: function() {
                  return this.closeDependents ? f(this.$children) : [];
                },
                getOpenDependentElements: function() {
                  for (var u = [], c = this.getOpenDependents(), h = 0; h < c.length; h++)
                    u.push.apply(u, l([], o(c[h].getClickableDependentElements()), !1));
                  return u;
                },
                getClickableDependentElements: function() {
                  var u = [this.$el];
                  return this.$refs.content && u.push(this.$refs.content), this.overlay && u.push(this.overlay.$el), u.push.apply(u, l([], o(this.getOpenDependentElements()), !1)), u;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/detachable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/detachable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../bootable */
              "./src/mixins/bootable/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function d(h) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(g) {
                return typeof g;
              } : d = function(g) {
                return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
              }, d(h);
            }
            function u(h) {
              var p = d(h);
              return p === "boolean" || p === "string" ? !0 : h.nodeType === Node.ELEMENT_NODE;
            }
            function c(h) {
              h.forEach(function(p) {
                p.elm && p.elm.parentNode && p.elm.parentNode.removeChild(p.elm);
              });
            }
            r.default = Object(l.default)(a.default).extend({
              name: "detachable",
              props: {
                attach: {
                  default: !1,
                  validator: u
                },
                contentClass: {
                  type: String,
                  default: ""
                }
              },
              data: function() {
                return {
                  activatorNode: null,
                  hasDetached: !1
                };
              },
              watch: {
                attach: function() {
                  this.hasDetached = !1, this.initDetach();
                },
                hasContent: function() {
                  this.$nextTick(this.initDetach);
                }
              },
              beforeMount: function() {
                var p = this;
                this.$nextTick(function() {
                  if (p.activatorNode) {
                    var g = Array.isArray(p.activatorNode) ? p.activatorNode : [p.activatorNode];
                    g.forEach(function(m) {
                      if (m.elm && p.$el.parentNode) {
                        var v = p.$el === p.$el.parentNode.firstChild ? p.$el : p.$el.nextSibling;
                        p.$el.parentNode.insertBefore(m.elm, v);
                      }
                    });
                  }
                });
              },
              mounted: function() {
                this.hasContent && this.initDetach();
              },
              deactivated: function() {
                this.isActive = !1;
              },
              beforeDestroy: function() {
                this.$refs.content && this.$refs.content.parentNode && this.$refs.content.parentNode.removeChild(this.$refs.content);
              },
              destroyed: function() {
                var p = this;
                if (this.activatorNode) {
                  var g = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];
                  if (this.$el.isConnected) {
                    var m = new MutationObserver(function(v) {
                      v.some(function(y) {
                        return Array.from(y.removedNodes).includes(p.$el);
                      }) && (m.disconnect(), c(g));
                    });
                    m.observe(this.$el.parentNode, {
                      subtree: !1,
                      childList: !0
                    });
                  } else
                    c(g);
                }
              },
              methods: {
                getScopeIdAttrs: function() {
                  var p, g = Object(o.getObjectValueByPath)(this.$vnode, "context.$options._scopeId");
                  return g && (p = {}, p[g] = "", p);
                },
                initDetach: function() {
                  if (!(this._isDestroyed || !this.$refs.content || this.hasDetached || // Leave menu in place if attached
                  // and dev has not changed target
                  this.attach === "" || // If used as a boolean prop (<v-menu attach>)
                  this.attach === !0 || // If bound to a boolean (<v-menu :attach="true">)
                  this.attach === "attach")) {
                    var p;
                    if (this.attach === !1 ? p = document.querySelector("[data-app]") : typeof this.attach == "string" ? p = document.querySelector(this.attach) : p = this.attach, !p) {
                      Object(f.consoleWarn)("Unable to locate target " + (this.attach || "[data-app]"), this);
                      return;
                    }
                    p.appendChild(this.$refs.content), this.hasDetached = !0;
                  }
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/elevatable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/elevatable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "elevatable",
              props: {
                elevation: [Number, String]
              },
              computed: {
                computedElevation: function() {
                  return this.elevation;
                },
                elevationClasses: function() {
                  var f, d = this.computedElevation;
                  return d == null ? {} : isNaN(parseInt(d)) ? {} : (f = {}, f["elevation-" + this.elevation] = !0, f);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/filterable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/filterable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "filterable",
              props: {
                noDataText: {
                  type: String,
                  default: "$vuetify.noDataText"
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/groupable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/groupable/index.ts ***!
            \***************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return o;
            });
            var a = i(
              /*! ../registrable */
              "./src/mixins/registrable/index.ts"
            );
            function o(f, d, u) {
              return Object(a.inject)(f, d, u).extend({
                name: "groupable",
                props: {
                  activeClass: {
                    type: String,
                    default: function() {
                      if (this[f])
                        return this[f].activeClass;
                    }
                  },
                  disabled: Boolean
                },
                data: function() {
                  return {
                    isActive: !1
                  };
                },
                computed: {
                  groupClasses: function() {
                    var h;
                    return this.activeClass ? (h = {}, h[this.activeClass] = this.isActive, h) : {};
                  }
                },
                created: function() {
                  this[f] && this[f].register(this);
                },
                beforeDestroy: function() {
                  this[f] && this[f].unregister(this);
                },
                methods: {
                  toggle: function(h) {
                    if (this.disabled && h) {
                      h.preventDefault();
                      return;
                    }
                    this.$emit("change");
                  }
                }
              });
            }
            var l = o("itemGroup");
            r.default = l;
          }
        ),
        /***/
        "./src/mixins/intersectable/index.ts": (
          /*!*******************************************!*\
            !*** ./src/mixins/intersectable/index.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return d;
            });
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            function d(u) {
              return f.a.extend({
                name: "intersectable",
                data: function() {
                  return {
                    isIntersecting: !1
                  };
                },
                mounted: function() {
                  a.default.inserted(this.$el, {
                    name: "intersect",
                    value: this.onObserve
                  }, this.$vnode);
                },
                destroyed: function() {
                  a.default.unbind(this.$el, {
                    name: "intersect",
                    value: this.onObserve
                  }, this.$vnode);
                },
                methods: {
                  onObserve: function(h, p, g) {
                    if (this.isIntersecting = g, !!g)
                      for (var m = 0, v = u.onVisible.length; m < v; m++) {
                        var y = this[u.onVisible[m]];
                        if (typeof y == "function") {
                          y();
                          continue;
                        }
                        Object(o.consoleWarn)(u.onVisible[m] + " method is not available on the instance but referenced in intersectable mixin options");
                      }
                  }
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/loadable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/loadable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../components/VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            );
            r.default = o.a.extend().extend({
              name: "loadable",
              props: {
                loading: {
                  type: [Boolean, String],
                  default: !1
                },
                loaderHeight: {
                  type: [Number, String],
                  default: 2
                }
              },
              methods: {
                genProgress: function() {
                  return this.loading === !1 ? null : this.$slots.progress || this.$createElement(l.default, {
                    props: {
                      absolute: !0,
                      color: this.loading === !0 || this.loading === "" ? this.color || "primary" : this.loading,
                      height: this.loaderHeight,
                      indeterminate: !0
                    }
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/localable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/localable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "localable",
              props: {
                locale: String
              },
              computed: {
                currentLocale: function() {
                  return this.locale || this.$vuetify.lang.current;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/measurable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/measurable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "measurable",
              props: {
                height: [Number, String],
                maxHeight: [Number, String],
                maxWidth: [Number, String],
                minHeight: [Number, String],
                minWidth: [Number, String],
                width: [Number, String]
              },
              computed: {
                measurableStyles: function() {
                  var d = {}, u = Object(a.convertToUnit)(this.height), c = Object(a.convertToUnit)(this.minHeight), h = Object(a.convertToUnit)(this.minWidth), p = Object(a.convertToUnit)(this.maxHeight), g = Object(a.convertToUnit)(this.maxWidth), m = Object(a.convertToUnit)(this.width);
                  return u && (d.height = u), c && (d.minHeight = c), h && (d.minWidth = h), p && (d.maxHeight = p), g && (d.maxWidth = g), m && (d.width = m), d;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/menuable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/menuable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../stackable */
              "./src/mixins/stackable/index.ts"
            ), o = i(
              /*! ../positionable */
              "./src/mixins/positionable/index.ts"
            ), l = i(
              /*! ../activatable */
              "./src/mixins/activatable/index.ts"
            ), f = i(
              /*! ../detachable */
              "./src/mixins/detachable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, c.apply(this, arguments);
            }, h = Object(d.default)(a.default, Object(o.factory)(["top", "right", "bottom", "left", "absolute"]), l.default, f.default);
            r.default = h.extend().extend({
              name: "menuable",
              props: {
                allowOverflow: Boolean,
                light: Boolean,
                dark: Boolean,
                maxWidth: {
                  type: [Number, String],
                  default: "auto"
                },
                minWidth: [Number, String],
                nudgeBottom: {
                  type: [Number, String],
                  default: 0
                },
                nudgeLeft: {
                  type: [Number, String],
                  default: 0
                },
                nudgeRight: {
                  type: [Number, String],
                  default: 0
                },
                nudgeTop: {
                  type: [Number, String],
                  default: 0
                },
                nudgeWidth: {
                  type: [Number, String],
                  default: 0
                },
                offsetOverflow: Boolean,
                positionX: {
                  type: Number,
                  default: null
                },
                positionY: {
                  type: Number,
                  default: null
                },
                zIndex: {
                  type: [Number, String],
                  default: null
                }
              },
              data: function() {
                return {
                  activatorNode: [],
                  absoluteX: 0,
                  absoluteY: 0,
                  activatedBy: null,
                  activatorFixed: !1,
                  dimensions: {
                    activator: {
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0,
                      width: 0,
                      height: 0,
                      offsetTop: 0,
                      scrollHeight: 0,
                      offsetLeft: 0
                    },
                    content: {
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0,
                      width: 0,
                      height: 0,
                      offsetTop: 0,
                      scrollHeight: 0
                    }
                  },
                  relativeYOffset: 0,
                  hasJustFocused: !1,
                  hasWindow: !1,
                  inputActivator: !1,
                  isContentActive: !1,
                  pageWidth: 0,
                  pageYOffset: 0,
                  stackClass: "v-menu__content--active",
                  stackMinZIndex: 6
                };
              },
              computed: {
                computedLeft: function() {
                  var g = this.dimensions.activator, m = this.dimensions.content, v = (this.attach !== !1 ? g.offsetLeft : g.left) || 0, y = Math.max(g.width, m.width), E = 0;
                  if (E += v, (this.left || this.$vuetify.rtl && !this.right) && (E -= y - g.width), this.offsetX) {
                    var C = isNaN(Number(this.maxWidth)) ? g.width : Math.min(g.width, Number(this.maxWidth));
                    E += this.left ? -C : g.width;
                  }
                  return this.nudgeLeft && (E -= parseInt(this.nudgeLeft)), this.nudgeRight && (E += parseInt(this.nudgeRight)), E;
                },
                computedTop: function() {
                  var g = this.dimensions.activator, m = this.dimensions.content, v = 0;
                  return this.top && (v += g.height - m.height), this.attach !== !1 ? v += g.offsetTop : v += g.top + this.pageYOffset, this.offsetY && (v += this.top ? -g.height : g.height), this.nudgeTop && (v -= parseInt(this.nudgeTop)), this.nudgeBottom && (v += parseInt(this.nudgeBottom)), v;
                },
                hasActivator: function() {
                  return !!this.$slots.activator || !!this.$scopedSlots.activator || !!this.activator || !!this.inputActivator;
                },
                absoluteYOffset: function() {
                  return this.pageYOffset - this.relativeYOffset;
                }
              },
              watch: {
                disabled: function(g) {
                  g && this.callDeactivate();
                },
                isActive: function(g) {
                  this.disabled || (g ? this.callActivate() : this.callDeactivate());
                },
                positionX: "updateDimensions",
                positionY: "updateDimensions"
              },
              beforeMount: function() {
                this.hasWindow = typeof window < "u", this.hasWindow && window.addEventListener("resize", this.updateDimensions, !1);
              },
              beforeDestroy: function() {
                this.hasWindow && window.removeEventListener("resize", this.updateDimensions, !1);
              },
              methods: {
                absolutePosition: function() {
                  return {
                    offsetTop: this.positionY || this.absoluteY,
                    offsetLeft: this.positionX || this.absoluteX,
                    scrollHeight: 0,
                    top: this.positionY || this.absoluteY,
                    bottom: this.positionY || this.absoluteY,
                    left: this.positionX || this.absoluteX,
                    right: this.positionX || this.absoluteX,
                    height: 0,
                    width: 0
                  };
                },
                activate: function() {
                },
                calcLeft: function(g) {
                  return Object(u.convertToUnit)(this.attach !== !1 ? this.computedLeft : this.calcXOverflow(this.computedLeft, g));
                },
                calcTop: function() {
                  return Object(u.convertToUnit)(this.attach !== !1 ? this.computedTop : this.calcYOverflow(this.computedTop));
                },
                calcXOverflow: function(g, m) {
                  var v = g + m - this.pageWidth + 12;
                  return (!this.left || this.right) && v > 0 ? g = Math.max(g - v, 0) : g = Math.max(g, 12), g + this.getOffsetLeft();
                },
                calcYOverflow: function(g) {
                  var m = this.getInnerHeight(), v = this.absoluteYOffset + m, y = this.dimensions.activator, E = this.dimensions.content.height, C = g + E, x = v < C;
                  return x && this.offsetOverflow && // If we don't have enough room to offset
                  // the overflow, don't offset
                  y.top > E ? g = this.pageYOffset + (y.top - E) : x && !this.allowOverflow ? g = v - E - 12 : g < this.absoluteYOffset && !this.allowOverflow && (g = this.absoluteYOffset + 12), g < 12 ? 12 : g;
                },
                callActivate: function() {
                  this.hasWindow && this.activate();
                },
                callDeactivate: function() {
                  this.isContentActive = !1, this.deactivate();
                },
                checkForPageYOffset: function() {
                  this.hasWindow && (this.pageYOffset = this.activatorFixed ? 0 : this.getOffsetTop());
                },
                checkActivatorFixed: function() {
                  if (this.attach !== !1) {
                    this.activatorFixed = !1;
                    return;
                  }
                  for (var g = this.getActivator(); g; ) {
                    if (window.getComputedStyle(g).position === "fixed") {
                      this.activatorFixed = !0;
                      return;
                    }
                    g = g.offsetParent;
                  }
                  this.activatorFixed = !1;
                },
                deactivate: function() {
                },
                genActivatorListeners: function() {
                  var g = this, m = l.default.options.methods.genActivatorListeners.call(this), v = m.click;
                  return v && (m.click = function(y) {
                    g.openOnClick && v && v(y), g.absoluteX = y.clientX, g.absoluteY = y.clientY;
                  }), m;
                },
                getInnerHeight: function() {
                  return this.hasWindow ? window.innerHeight || document.documentElement.clientHeight : 0;
                },
                getOffsetLeft: function() {
                  return this.hasWindow ? window.pageXOffset || document.documentElement.scrollLeft : 0;
                },
                getOffsetTop: function() {
                  return this.hasWindow ? window.pageYOffset || document.documentElement.scrollTop : 0;
                },
                getRoundedBoundedClientRect: function(g) {
                  var m = g.getBoundingClientRect();
                  return {
                    top: Math.round(m.top),
                    left: Math.round(m.left),
                    bottom: Math.round(m.bottom),
                    right: Math.round(m.right),
                    width: Math.round(m.width),
                    height: Math.round(m.height)
                  };
                },
                measure: function(g) {
                  if (!g || !this.hasWindow)
                    return null;
                  var m = this.getRoundedBoundedClientRect(g);
                  if (this.attach !== !1) {
                    var v = window.getComputedStyle(g);
                    m.left = parseInt(v.marginLeft), m.top = parseInt(v.marginTop);
                  }
                  return m;
                },
                sneakPeek: function(g) {
                  var m = this;
                  requestAnimationFrame(function() {
                    var v = m.$refs.content;
                    if (!v || v.style.display !== "none") {
                      g();
                      return;
                    }
                    v.style.display = "inline-block", g(), v.style.display = "none";
                  });
                },
                startTransition: function() {
                  var g = this;
                  return new Promise(function(m) {
                    return requestAnimationFrame(function() {
                      g.isContentActive = g.hasJustFocused = g.isActive, m();
                    });
                  });
                },
                updateDimensions: function() {
                  var g = this;
                  this.hasWindow = typeof window < "u", this.checkActivatorFixed(), this.checkForPageYOffset(), this.pageWidth = document.documentElement.clientWidth;
                  var m = {
                    activator: c({}, this.dimensions.activator),
                    content: c({}, this.dimensions.content)
                  };
                  if (!this.hasActivator || this.absolute)
                    m.activator = this.absolutePosition();
                  else {
                    var v = this.getActivator();
                    if (!v)
                      return;
                    m.activator = this.measure(v), m.activator.offsetLeft = v.offsetLeft, this.attach !== !1 ? m.activator.offsetTop = v.offsetTop : m.activator.offsetTop = 0;
                  }
                  this.sneakPeek(function() {
                    if (g.$refs.content) {
                      if (g.$refs.content.offsetParent) {
                        var y = g.getRoundedBoundedClientRect(g.$refs.content.offsetParent);
                        g.relativeYOffset = window.pageYOffset + y.top, m.activator.top -= g.relativeYOffset, m.activator.left -= window.pageXOffset + y.left;
                      }
                      m.content = g.measure(g.$refs.content);
                    }
                    g.dimensions = m;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/mobile/index.ts": (
          /*!************************************!*\
            !*** ./src/mixins/mobile/index.ts ***!
            \************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "mobile",
              props: {
                mobileBreakpoint: {
                  type: [Number, String],
                  default: function() {
                    return this.$vuetify ? this.$vuetify.breakpoint.mobileBreakpoint : void 0;
                  },
                  validator: function(d) {
                    return !isNaN(Number(d)) || ["xs", "sm", "md", "lg", "xl"].includes(String(d));
                  }
                }
              },
              computed: {
                isMobile: function() {
                  var d = this.$vuetify.breakpoint, u = d.mobile, c = d.width, h = d.name, p = d.mobileBreakpoint;
                  if (p === this.mobileBreakpoint)
                    return u;
                  var g = parseInt(this.mobileBreakpoint, 10), m = !isNaN(g);
                  return m ? c < g : h === this.mobileBreakpoint;
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("mobile-break-point") && Object(a.deprecate)("mobile-break-point", "mobile-breakpoint", this);
              }
            });
          }
        ),
        /***/
        "./src/mixins/mouse/index.ts": (
          /*!***********************************!*\
            !*** ./src/mixins/mouse/index.ts ***!
            \***********************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "mouse",
              methods: {
                getDefaultMouseEventHandlers: function(d, u, c) {
                  var h;
                  c === void 0 && (c = !1);
                  var p = Object.keys(this.$listeners).filter(function(g) {
                    return g.endsWith(d);
                  }).reduce(function(g, m) {
                    return g[m] = {
                      event: m.slice(0, -d.length)
                    }, g;
                  }, {});
                  return this.getMouseEventHandlers(l(l({}, p), (h = {}, h["contextmenu" + d] = {
                    event: "contextmenu",
                    prevent: !0,
                    result: !1
                  }, h)), u, c);
                },
                getMouseEventHandlers: function(d, u, c) {
                  var h = this;
                  c === void 0 && (c = !1);
                  var p = {}, g = function(E) {
                    var C = d[E];
                    if (!m.$listeners[E])
                      return "continue";
                    var x = C.passive ? "&" : (C.once ? "~" : "") + (C.capture ? "!" : ""), b = x + C.event, P = function(O) {
                      var S, L, A = O;
                      if (C.button === void 0 || A.buttons > 0 && A.button === C.button) {
                        if (C.prevent && O.preventDefault(), C.stop && O.stopPropagation(), O && "touches" in O) {
                          var D = " ", _ = (S = O.currentTarget) === null || S === void 0 ? void 0 : S.className.split(D), w = document.elementsFromPoint(O.changedTouches[0].clientX, O.changedTouches[0].clientY), B = w.find(function(j) {
                            return j.className.split(D).some(function(k) {
                              return _.includes(k);
                            });
                          });
                          if (B && !(!((L = O.target) === null || L === void 0) && L.isSameNode(B))) {
                            B.dispatchEvent(new TouchEvent(O.type, {
                              changedTouches: O.changedTouches,
                              targetTouches: O.targetTouches,
                              touches: O.touches
                            }));
                            return;
                          }
                        }
                        c ? h.$emit(E, O, u(O)) : h.$emit(E, u(O), O);
                      }
                      return C.result;
                    };
                    b in p ? Array.isArray(p[b]) ? p[b].push(P) : p[b] = [p[b], P] : p[b] = P;
                  }, m = this;
                  for (var v in d)
                    g(v);
                  return p;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/overlayable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/overlayable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VOverlay */
              "./src/components/VOverlay/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend().extend({
              name: "overlayable",
              props: {
                hideOverlay: Boolean,
                overlayColor: String,
                overlayOpacity: [Number, String]
              },
              data: function() {
                return {
                  animationFrame: 0,
                  overlay: null
                };
              },
              watch: {
                hideOverlay: function(u) {
                  this.isActive && (u ? this.removeOverlay() : this.genOverlay());
                }
              },
              beforeDestroy: function() {
                this.removeOverlay();
              },
              methods: {
                createOverlay: function() {
                  var u = new a.default({
                    propsData: {
                      absolute: this.absolute,
                      value: !1,
                      color: this.overlayColor,
                      opacity: this.overlayOpacity
                    }
                  });
                  u.$mount();
                  var c = this.absolute ? this.$el.parentNode : document.querySelector("[data-app]");
                  c && c.insertBefore(u.$el, c.firstChild), this.overlay = u;
                },
                genOverlay: function() {
                  var u = this;
                  if (this.hideScroll(), !this.hideOverlay)
                    return this.overlay || this.createOverlay(), this.animationFrame = requestAnimationFrame(function() {
                      u.overlay && (u.activeZIndex !== void 0 ? u.overlay.zIndex = String(u.activeZIndex - 1) : u.$el && (u.overlay.zIndex = Object(o.getZIndex)(u.$el)), u.overlay.value = !0);
                    }), !0;
                },
                /** removeOverlay(false) will not restore the scollbar afterwards */
                removeOverlay: function(u) {
                  var c = this;
                  u === void 0 && (u = !0), this.overlay && (Object(o.addOnceEventListener)(this.overlay.$el, "transitionend", function() {
                    !c.overlay || !c.overlay.$el || !c.overlay.$el.parentNode || c.overlay.value || c.isActive || (c.overlay.$el.parentNode.removeChild(c.overlay.$el), c.overlay.$destroy(), c.overlay = null);
                  }), cancelAnimationFrame(this.animationFrame), this.overlay.value = !1), u && this.showScroll();
                },
                scrollListener: function(u) {
                  if ("key" in u) {
                    if (["INPUT", "TEXTAREA", "SELECT"].includes(u.target.tagName) || // https://github.com/vuetifyjs/vuetify/issues/4715
                    u.target.isContentEditable)
                      return;
                    var c = [o.keyCodes.up, o.keyCodes.pageup], h = [o.keyCodes.down, o.keyCodes.pagedown];
                    if (c.includes(u.keyCode))
                      u.deltaY = -1;
                    else if (h.includes(u.keyCode))
                      u.deltaY = 1;
                    else
                      return;
                  }
                  (u.target === this.overlay || u.type !== "keydown" && u.target === document.body || this.checkPath(u)) && u.preventDefault();
                },
                hasScrollbar: function(u) {
                  if (!u || u.nodeType !== Node.ELEMENT_NODE)
                    return !1;
                  var c = window.getComputedStyle(u);
                  return (["auto", "scroll"].includes(c.overflowY) || u.tagName === "SELECT") && u.scrollHeight > u.clientHeight || ["auto", "scroll"].includes(c.overflowX) && u.scrollWidth > u.clientWidth;
                },
                shouldScroll: function(u, c) {
                  if (u.hasAttribute("data-app"))
                    return !1;
                  var h = c.shiftKey || c.deltaX ? "x" : "y", p = h === "y" ? c.deltaY : c.deltaX || c.deltaY, g, m;
                  h === "y" ? (g = u.scrollTop === 0, m = u.scrollTop + u.clientHeight === u.scrollHeight) : (g = u.scrollLeft === 0, m = u.scrollLeft + u.clientWidth === u.scrollWidth);
                  var v = p < 0, y = p > 0;
                  return !g && v || !m && y ? !0 : (g || m) && u.parentNode ? this.shouldScroll(u.parentNode, c) : !1;
                },
                isInside: function(u, c) {
                  return u === c ? !0 : u === null || u === document.body ? !1 : this.isInside(u.parentNode, c);
                },
                checkPath: function(u) {
                  var c = Object(o.composedPath)(u);
                  if (u.type === "keydown" && c[0] === document.body) {
                    var h = this.$refs.dialog, p = window.getSelection().anchorNode;
                    return h && this.hasScrollbar(h) && this.isInside(p, h) ? !this.shouldScroll(h, u) : !0;
                  }
                  for (var g = 0; g < c.length; g++) {
                    var m = c[g];
                    if (m === document || m === document.documentElement || m === this.$refs.content)
                      return !0;
                    if (this.hasScrollbar(m))
                      return !this.shouldScroll(m, u);
                  }
                  return !0;
                },
                hideScroll: function() {
                  this.$vuetify.breakpoint.smAndDown ? document.documentElement.classList.add("overflow-y-hidden") : (Object(o.addPassiveEventListener)(window, "wheel", this.scrollListener, {
                    passive: !1
                  }), window.addEventListener("keydown", this.scrollListener));
                },
                showScroll: function() {
                  document.documentElement.classList.remove("overflow-y-hidden"), window.removeEventListener("wheel", this.scrollListener), window.removeEventListener("keydown", this.scrollListener);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/picker-button/index.ts": (
          /*!*******************************************!*\
            !*** ./src/mixins/picker-button/index.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              methods: {
                genPickerButton: function(d, u, c, h, p) {
                  var g = this;
                  h === void 0 && (h = !1), p === void 0 && (p = "");
                  var m = this[d] === u, v = function(E) {
                    E.stopPropagation(), g.$emit("update:" + Object(l.kebabCase)(d), u);
                  };
                  return this.$createElement("div", {
                    staticClass: ("v-picker__title__btn " + p).trim(),
                    class: {
                      "v-picker__title__btn--active": m,
                      "v-picker__title__btn--readonly": h
                    },
                    on: m || h ? void 0 : {
                      click: v
                    }
                  }, Array.isArray(c) ? c : [c]);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/picker/index.ts": (
          /*!************************************!*\
            !*** ./src/mixins/picker/index.ts ***!
            \************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VPicker */
              "./src/components/VPicker/index.ts"
            ), o = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), f = i(
              /*! ../themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "picker",
              props: {
                flat: Boolean,
                fullWidth: Boolean,
                headerColor: String,
                landscape: Boolean,
                noTitle: Boolean,
                width: {
                  type: [Number, String],
                  default: 290
                }
              },
              methods: {
                genPickerTitle: function() {
                  return null;
                },
                genPickerBody: function() {
                  return null;
                },
                genPickerActionsSlot: function() {
                  return this.$scopedSlots.default ? this.$scopedSlots.default({
                    save: this.save,
                    cancel: this.cancel
                  }) : this.$slots.default;
                },
                genPicker: function(c) {
                  var h = [];
                  if (!this.noTitle) {
                    var p = this.genPickerTitle();
                    p && h.push(p);
                  }
                  var g = this.genPickerBody();
                  return g && h.push(g), h.push(this.$createElement("template", {
                    slot: "actions"
                  }, [this.genPickerActionsSlot()])), this.$createElement(a.default, {
                    staticClass: c,
                    props: {
                      color: this.headerColor || this.color,
                      dark: this.dark,
                      elevation: this.elevation,
                      flat: this.flat,
                      fullWidth: this.fullWidth,
                      landscape: this.landscape,
                      light: this.light,
                      width: this.width,
                      noTitle: this.noTitle
                    }
                  }, h);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/positionable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/positionable/index.ts ***!
            \******************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return d;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = {
              absolute: Boolean,
              bottom: Boolean,
              fixed: Boolean,
              left: Boolean,
              right: Boolean,
              top: Boolean
            };
            function d(u) {
              return u === void 0 && (u = []), o.a.extend({
                name: "positionable",
                props: u.length ? Object(l.filterObjectOnKeys)(f, u) : f
              });
            }
            r.default = d();
          }
        ),
        /***/
        "./src/mixins/proxyable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/proxyable/index.ts ***!
            \***************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(d, u) {
              var c, h;
              return d === void 0 && (d = "value"), u === void 0 && (u = "change"), o.a.extend({
                name: "proxyable",
                model: {
                  prop: d,
                  event: u
                },
                props: (c = {}, c[d] = {
                  required: !1
                }, c),
                data: function() {
                  return {
                    internalLazyValue: this[d]
                  };
                },
                computed: {
                  internalValue: {
                    get: function() {
                      return this.internalLazyValue;
                    },
                    set: function(g) {
                      g !== this.internalLazyValue && (this.internalLazyValue = g, this.$emit(u, g));
                    }
                  }
                },
                watch: (h = {}, h[d] = function(p) {
                  this.internalLazyValue = p;
                }, h)
              });
            }
            var f = l();
            r.default = f;
          }
        ),
        /***/
        "./src/mixins/registrable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/registrable/index.ts ***!
            \*****************************************/
          /*! exports provided: inject, provide */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "inject", function() {
              return d;
            }), i.d(r, "provide", function() {
              return u;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function f(c, h) {
              return function() {
                return Object(l.consoleWarn)("The " + c + " component must be used inside a " + h);
              };
            }
            function d(c, h, p) {
              var g, m = h && p ? {
                register: f(h, p),
                unregister: f(h, p)
              } : null;
              return o.a.extend({
                name: "registrable-inject",
                inject: (g = {}, g[c] = {
                  default: m
                }, g)
              });
            }
            function u(c, h) {
              return h === void 0 && (h = !1), o.a.extend({
                name: "registrable-provide",
                provide: function() {
                  var g;
                  return g = {}, g[c] = h ? this : {
                    register: this.register,
                    unregister: this.unregister
                  }, g;
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/returnable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/returnable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "returnable",
              props: {
                returnValue: null
              },
              data: function() {
                return {
                  isActive: !1,
                  originalValue: null
                };
              },
              watch: {
                isActive: function(f) {
                  f ? this.originalValue = this.returnValue : this.$emit("update:return-value", this.originalValue);
                }
              },
              methods: {
                save: function(f) {
                  var d = this;
                  this.originalValue = f, setTimeout(function() {
                    d.isActive = !1;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/rippleable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/rippleable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "rippleable",
              directives: {
                ripple: a.default
              },
              props: {
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                }
              },
              methods: {
                genRipple: function(d) {
                  return d === void 0 && (d = {}), this.ripple ? (d.staticClass = "v-input--selection-controls__ripple", d.directives = d.directives || [], d.directives.push({
                    name: "ripple",
                    value: {
                      center: !0
                    }
                  }), this.$createElement("div", d)) : null;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/roundable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/roundable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function(f) {
              var d = typeof Symbol == "function" && Symbol.iterator, u = d && f[d], c = 0;
              if (u)
                return u.call(f);
              if (f && typeof f.length == "number")
                return {
                  next: function() {
                    return f && c >= f.length && (f = void 0), {
                      value: f && f[c++],
                      done: !f
                    };
                  }
                };
              throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = o.a.extend({
              name: "roundable",
              props: {
                rounded: [Boolean, String],
                tile: Boolean
              },
              computed: {
                roundedClasses: function() {
                  var d, u, c, h = [], p = typeof this.rounded == "string" ? String(this.rounded) : this.rounded === !0;
                  if (this.tile)
                    h.push("rounded-0");
                  else if (typeof p == "string") {
                    var g = p.split(" ");
                    try {
                      for (var m = l(g), v = m.next(); !v.done; v = m.next()) {
                        var y = v.value;
                        h.push("rounded-" + y);
                      }
                    } catch (E) {
                      d = {
                        error: E
                      };
                    } finally {
                      try {
                        v && !v.done && (u = m.return) && u.call(m);
                      } finally {
                        if (d)
                          throw d.error;
                      }
                    }
                  } else
                    p && h.push("rounded");
                  return h.length > 0 ? (c = {}, c[h.join(" ")] = !0, c) : {};
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/routable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/routable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "routable",
              directives: {
                Ripple: l.default
              },
              props: {
                activeClass: String,
                append: Boolean,
                disabled: Boolean,
                exact: {
                  type: Boolean,
                  default: void 0
                },
                exactPath: Boolean,
                exactActiveClass: String,
                link: Boolean,
                href: [String, Object],
                to: [String, Object],
                nuxt: Boolean,
                replace: Boolean,
                ripple: {
                  type: [Boolean, Object],
                  default: null
                },
                tag: String,
                target: String
              },
              data: function() {
                return {
                  isActive: !1,
                  proxyClass: ""
                };
              },
              computed: {
                classes: function() {
                  var c = {};
                  return this.to || (this.activeClass && (c[this.activeClass] = this.isActive), this.proxyClass && (c[this.proxyClass] = this.isActive)), c;
                },
                computedRipple: function() {
                  var c;
                  return (c = this.ripple) !== null && c !== void 0 ? c : !this.disabled && this.isClickable;
                },
                isClickable: function() {
                  return this.disabled ? !1 : !!(this.isLink || this.$listeners.click || this.$listeners["!click"] || this.$attrs.tabindex);
                },
                isLink: function() {
                  return this.to || this.href || this.link;
                },
                styles: function() {
                  return {};
                }
              },
              watch: {
                $route: "onRouteChange"
              },
              mounted: function() {
                this.onRouteChange();
              },
              methods: {
                generateRouteLink: function() {
                  var c, h = this.exact, p, g = (c = {
                    attrs: {
                      tabindex: "tabindex" in this.$attrs ? this.$attrs.tabindex : void 0
                    },
                    class: this.classes,
                    style: this.styles,
                    props: {},
                    directives: [{
                      name: "ripple",
                      value: this.computedRipple
                    }]
                  }, c[this.to ? "nativeOn" : "on"] = d(d({}, this.$listeners), "click" in this ? {
                    click: this.click
                  } : void 0), c.ref = "link", c);
                  if (typeof this.exact > "u" && (h = this.to === "/" || this.to === Object(this.to) && this.to.path === "/"), this.to) {
                    var m = this.activeClass, v = this.exactActiveClass || m;
                    this.proxyClass && (m = (m + " " + this.proxyClass).trim(), v = (v + " " + this.proxyClass).trim()), p = this.nuxt ? "nuxt-link" : "router-link", Object.assign(g.props, {
                      to: this.to,
                      exact: h,
                      exactPath: this.exactPath,
                      activeClass: m,
                      exactActiveClass: v,
                      append: this.append,
                      replace: this.replace
                    });
                  } else
                    p = this.href && "a" || this.tag || "div", p === "a" && this.href && (g.attrs.href = this.href);
                  return this.target && (g.attrs.target = this.target), {
                    tag: p,
                    data: g
                  };
                },
                onRouteChange: function() {
                  var c = this;
                  if (!(!this.to || !this.$refs.link || !this.$route)) {
                    var h = ((this.activeClass || "") + " " + (this.proxyClass || "")).trim(), p = ((this.exactActiveClass || "") + " " + (this.proxyClass || "")).trim() || h, g = "_vnode.data.class." + (this.exact ? p : h);
                    this.$nextTick(function() {
                      !Object(f.getObjectValueByPath)(c.$refs.link, g) === c.isActive && c.toggle();
                    });
                  }
                },
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/scrollable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/scrollable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../directives */
              "./src/directives/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend({
              name: "scrollable",
              directives: {
                Scroll: a.Scroll
              },
              props: {
                scrollTarget: String,
                scrollThreshold: [String, Number]
              },
              data: function() {
                return {
                  currentScroll: 0,
                  currentThreshold: 0,
                  isActive: !1,
                  isScrollingUp: !1,
                  previousScroll: 0,
                  savedScroll: 0,
                  target: null
                };
              },
              computed: {
                /**
                 * A computed property that returns
                 * whether scrolling features are
                 * enabled or disabled
                 */
                canScroll: function() {
                  return typeof window < "u";
                },
                /**
                 * The threshold that must be met before
                 * thresholdMet function is invoked
                 */
                computedScrollThreshold: function() {
                  return this.scrollThreshold ? Number(this.scrollThreshold) : 300;
                }
              },
              watch: {
                isScrollingUp: function() {
                  this.savedScroll = this.savedScroll || this.currentScroll;
                },
                isActive: function() {
                  this.savedScroll = 0;
                }
              },
              mounted: function() {
                this.scrollTarget && (this.target = document.querySelector(this.scrollTarget), this.target || Object(o.consoleWarn)("Unable to locate element with identifier " + this.scrollTarget, this));
              },
              methods: {
                onScroll: function() {
                  var u = this;
                  this.canScroll && (this.previousScroll = this.currentScroll, this.currentScroll = this.target ? this.target.scrollTop : window.pageYOffset, this.isScrollingUp = this.currentScroll < this.previousScroll, this.currentThreshold = Math.abs(this.currentScroll - this.computedScrollThreshold), this.$nextTick(function() {
                    Math.abs(u.currentScroll - u.savedScroll) > u.computedScrollThreshold && u.thresholdMet();
                  }));
                },
                /**
                 * The method invoked when
                 * scrolling in any direction
                 * has exceeded the threshold
                 */
                thresholdMet: function() {
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/selectable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/selectable/index.ts ***!
            \****************************************/
          /*! exports provided: prevent, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "prevent", function() {
              return d;
            });
            var a = i(
              /*! ../../components/VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../rippleable */
              "./src/mixins/rippleable/index.ts"
            ), l = i(
              /*! ../comparable */
              "./src/mixins/comparable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function d(u) {
              u.preventDefault();
            }
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "selectable",
              model: {
                prop: "inputValue",
                event: "change"
              },
              props: {
                id: String,
                inputValue: null,
                falseValue: null,
                trueValue: null,
                multiple: {
                  type: Boolean,
                  default: null
                },
                label: String
              },
              data: function() {
                return {
                  hasColor: this.inputValue,
                  lazyValue: this.inputValue
                };
              },
              computed: {
                computedColor: function() {
                  if (this.isActive)
                    return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                },
                isMultiple: function() {
                  return this.multiple === !0 || this.multiple === null && Array.isArray(this.internalValue);
                },
                isActive: function() {
                  var c = this, h = this.value, p = this.internalValue;
                  return this.isMultiple ? Array.isArray(p) ? p.some(function(g) {
                    return c.valueComparator(g, h);
                  }) : !1 : this.trueValue === void 0 || this.falseValue === void 0 ? h ? this.valueComparator(h, p) : !!p : this.valueComparator(p, this.trueValue);
                },
                isDirty: function() {
                  return this.isActive;
                },
                rippleState: function() {
                  return !this.isDisabled && !this.validationState ? void 0 : this.validationState;
                }
              },
              watch: {
                inputValue: function(c) {
                  this.lazyValue = c, this.hasColor = c;
                }
              },
              methods: {
                genLabel: function() {
                  var c = a.default.options.methods.genLabel.call(this);
                  return c && (c.data.on = {
                    // Label shouldn't cause the input to focus
                    click: d
                  }, c);
                },
                genInput: function(c, h) {
                  return this.$createElement("input", {
                    attrs: Object.assign({
                      "aria-checked": this.isActive.toString(),
                      disabled: this.isDisabled,
                      id: this.computedId,
                      role: c,
                      type: c
                    }, h),
                    domProps: {
                      value: this.value,
                      checked: this.isActive
                    },
                    on: {
                      blur: this.onBlur,
                      change: this.onChange,
                      focus: this.onFocus,
                      keydown: this.onKeydown,
                      click: d
                    },
                    ref: "input"
                  });
                },
                onClick: function(c) {
                  this.onChange(), this.$emit("click", c);
                },
                onChange: function() {
                  var c = this;
                  if (this.isInteractive) {
                    var h = this.value, p = this.internalValue;
                    if (this.isMultiple) {
                      Array.isArray(p) || (p = []);
                      var g = p.length;
                      p = p.filter(function(m) {
                        return !c.valueComparator(m, h);
                      }), p.length === g && p.push(h);
                    } else
                      this.trueValue !== void 0 && this.falseValue !== void 0 ? p = this.valueComparator(p, this.trueValue) ? this.falseValue : this.trueValue : h ? p = this.valueComparator(p, h) ? null : h : p = !p;
                    this.validate(!0, p), this.internalValue = p, this.hasColor = p;
                  }
                },
                onFocus: function(c) {
                  this.isFocused = !0, this.$emit("focus", c);
                },
                onBlur: function(c) {
                  this.isFocused = !1, this.$emit("blur", c);
                },
                /** @abstract */
                onKeydown: function(c) {
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/sizeable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/sizeable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "sizeable",
              props: {
                large: Boolean,
                small: Boolean,
                xLarge: Boolean,
                xSmall: Boolean
              },
              computed: {
                medium: function() {
                  return !this.xSmall && !this.small && !this.large && !this.xLarge;
                },
                sizeableClasses: function() {
                  return {
                    "v-size--x-small": this.xSmall,
                    "v-size--small": this.small,
                    "v-size--default": this.medium,
                    "v-size--large": this.large,
                    "v-size--x-large": this.xLarge
                  };
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/ssr-bootable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/ssr-bootable/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "ssr-bootable",
              data: function() {
                return {
                  isBooted: !1
                };
              },
              mounted: function() {
                var f = this;
                window.requestAnimationFrame(function() {
                  f.$el.setAttribute("data-booted", "true"), f.isBooted = !0;
                });
              }
            });
          }
        ),
        /***/
        "./src/mixins/stackable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/stackable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = o.a.extend().extend({
              name: "stackable",
              data: function() {
                return {
                  stackElement: null,
                  stackExclude: null,
                  stackMinZIndex: 0,
                  isActive: !1
                };
              },
              computed: {
                activeZIndex: function() {
                  if (typeof window > "u")
                    return 0;
                  var c = this.stackElement || this.$refs.content, h = this.isActive ? this.getMaxZIndex(this.stackExclude || [c]) + 2 : Object(l.getZIndex)(c);
                  return h == null ? h : parseInt(h);
                }
              },
              methods: {
                getMaxZIndex: function(c) {
                  c === void 0 && (c = []);
                  for (var h = this.$el, p = [this.stackMinZIndex, Object(l.getZIndex)(h)], g = d(d([], f(document.getElementsByClassName("v-menu__content--active")), !1), f(document.getElementsByClassName("v-dialog__content--active")), !1), m = 0; m < g.length; m++)
                    c.includes(g[m]) || p.push(Object(l.getZIndex)(g[m]));
                  return Math.max.apply(Math, d([], f(p), !1));
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/themeable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/themeable/index.ts ***!
            \***************************************/
          /*! exports provided: default, functionalThemeClasses */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "functionalThemeClasses", function() {
              return d;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function() {
              return l = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, l.apply(this, arguments);
            }, f = o.a.extend().extend({
              name: "themeable",
              provide: function() {
                return {
                  theme: this.themeableProvide
                };
              },
              inject: {
                theme: {
                  default: {
                    isDark: !1
                  }
                }
              },
              props: {
                dark: {
                  type: Boolean,
                  default: null
                },
                light: {
                  type: Boolean,
                  default: null
                }
              },
              data: function() {
                return {
                  themeableProvide: {
                    isDark: !1
                  }
                };
              },
              computed: {
                appIsDark: function() {
                  return this.$vuetify.theme.dark || !1;
                },
                isDark: function() {
                  return this.dark === !0 ? !0 : this.light === !0 ? !1 : this.theme.isDark;
                },
                themeClasses: function() {
                  return {
                    "theme--dark": this.isDark,
                    "theme--light": !this.isDark
                  };
                },
                /** Used by menus and dialogs, inherits from v-app instead of the parent */
                rootIsDark: function() {
                  return this.dark === !0 ? !0 : this.light === !0 ? !1 : this.appIsDark;
                },
                rootThemeClasses: function() {
                  return {
                    "theme--dark": this.rootIsDark,
                    "theme--light": !this.rootIsDark
                  };
                }
              },
              watch: {
                isDark: {
                  handler: function(c, h) {
                    c !== h && (this.themeableProvide.isDark = this.isDark);
                  },
                  immediate: !0
                }
              }
            });
            r.default = f;
            function d(u) {
              var c = l(l({}, u.props), u.injections), h = f.options.computed.isDark.call(c);
              return f.options.computed.themeClasses.call({
                isDark: h
              });
            }
          }
        ),
        /***/
        "./src/mixins/toggleable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/toggleable/index.ts ***!
            \****************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(d, u) {
              var c, h;
              return d === void 0 && (d = "value"), u === void 0 && (u = "input"), o.a.extend({
                name: "toggleable",
                model: {
                  prop: d,
                  event: u
                },
                props: (c = {}, c[d] = {
                  required: !1
                }, c),
                data: function() {
                  return {
                    isActive: !!this[d]
                  };
                },
                watch: (h = {}, h[d] = function(p) {
                  this.isActive = !!p;
                }, h.isActive = function(p) {
                  !!p !== this[d] && this.$emit(u, p);
                }, h)
              });
            }
            var f = l();
            r.default = f;
          }
        ),
        /***/
        "./src/mixins/transitionable/index.ts": (
          /*!********************************************!*\
            !*** ./src/mixins/transitionable/index.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "transitionable",
              props: {
                mode: String,
                origin: String,
                transition: String
              }
            });
          }
        ),
        /***/
        "./src/mixins/translatable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/translatable/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "translatable",
              props: {
                height: Number
              },
              data: function() {
                return {
                  elOffsetTop: 0,
                  parallax: 0,
                  parallaxDist: 0,
                  percentScrolled: 0,
                  scrollTop: 0,
                  windowHeight: 0,
                  windowBottom: 0
                };
              },
              computed: {
                imgHeight: function() {
                  return this.objHeight();
                }
              },
              beforeDestroy: function() {
                window.removeEventListener("scroll", this.translate, !1), window.removeEventListener("resize", this.translate, !1);
              },
              methods: {
                calcDimensions: function() {
                  var f = this.$el.getBoundingClientRect();
                  this.scrollTop = window.pageYOffset, this.parallaxDist = this.imgHeight - this.height, this.elOffsetTop = f.top + this.scrollTop, this.windowHeight = window.innerHeight, this.windowBottom = this.scrollTop + this.windowHeight;
                },
                listeners: function() {
                  window.addEventListener("scroll", this.translate, !1), window.addEventListener("resize", this.translate, !1);
                },
                /** @abstract **/
                objHeight: function() {
                  throw new Error("Not implemented !");
                },
                translate: function() {
                  this.calcDimensions(), this.percentScrolled = (this.windowBottom - this.elOffsetTop) / (parseInt(this.height) + this.windowHeight), this.parallax = Math.round(this.parallaxDist * this.percentScrolled);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/validatable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/validatable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function c(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(m) {
                return typeof m;
              } : c = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, c(p);
            }
            var h = Object(u.default)(a.default, Object(l.inject)("form"), o.default);
            r.default = h.extend({
              name: "validatable",
              props: {
                disabled: {
                  type: Boolean,
                  default: null
                },
                error: Boolean,
                errorCount: {
                  type: [Number, String],
                  default: 1
                },
                errorMessages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                messages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                readonly: {
                  type: Boolean,
                  default: null
                },
                rules: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                success: Boolean,
                successMessages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                validateOnBlur: Boolean,
                value: {
                  required: !1
                }
              },
              data: function() {
                return {
                  errorBucket: [],
                  hasColor: !1,
                  hasFocused: !1,
                  hasInput: !1,
                  isFocused: !1,
                  isResetting: !1,
                  lazyValue: this.value,
                  valid: !1
                };
              },
              computed: {
                computedColor: function() {
                  if (!this.isDisabled)
                    return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                },
                hasError: function() {
                  return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error;
                },
                // TODO: Add logic that allows the user to enable based
                // upon a good validation
                hasSuccess: function() {
                  return this.internalSuccessMessages.length > 0 || this.success;
                },
                externalError: function() {
                  return this.internalErrorMessages.length > 0 || this.error;
                },
                hasMessages: function() {
                  return this.validationTarget.length > 0;
                },
                hasState: function() {
                  return this.isDisabled ? !1 : this.hasSuccess || this.shouldValidate && this.hasError;
                },
                internalErrorMessages: function() {
                  return this.genInternalMessages(this.errorMessages);
                },
                internalMessages: function() {
                  return this.genInternalMessages(this.messages);
                },
                internalSuccessMessages: function() {
                  return this.genInternalMessages(this.successMessages);
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(g) {
                    this.lazyValue = g, this.$emit("input", g);
                  }
                },
                isDisabled: function() {
                  var g;
                  return (g = this.disabled) !== null && g !== void 0 ? g : !!this.form && this.form.disabled;
                },
                isInteractive: function() {
                  return !this.isDisabled && !this.isReadonly;
                },
                isReadonly: function() {
                  var g;
                  return (g = this.readonly) !== null && g !== void 0 ? g : !!this.form && this.form.readonly;
                },
                shouldValidate: function() {
                  return this.externalError ? !0 : this.isResetting ? !1 : this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused;
                },
                validations: function() {
                  return this.validationTarget.slice(0, Number(this.errorCount));
                },
                validationState: function() {
                  if (!this.isDisabled) {
                    if (this.hasError && this.shouldValidate)
                      return "error";
                    if (this.hasSuccess)
                      return "success";
                    if (this.hasColor)
                      return this.computedColor;
                  }
                },
                validationTarget: function() {
                  return this.internalErrorMessages.length > 0 ? this.internalErrorMessages : this.successMessages && this.successMessages.length > 0 ? this.internalSuccessMessages : this.messages && this.messages.length > 0 ? this.internalMessages : this.shouldValidate ? this.errorBucket : [];
                }
              },
              watch: {
                rules: {
                  handler: function(g, m) {
                    Object(f.deepEqual)(g, m) || this.validate();
                  },
                  deep: !0
                },
                internalValue: function() {
                  this.hasInput = !0, this.validateOnBlur || this.$nextTick(this.validate);
                },
                isFocused: function(g) {
                  !g && !this.isDisabled && (this.hasFocused = !0, this.validateOnBlur && this.$nextTick(this.validate));
                },
                isResetting: function() {
                  var g = this;
                  setTimeout(function() {
                    g.hasInput = !1, g.hasFocused = !1, g.isResetting = !1, g.validate();
                  }, 0);
                },
                hasError: function(g) {
                  this.shouldValidate && this.$emit("update:error", g);
                },
                value: function(g) {
                  this.lazyValue = g;
                }
              },
              beforeMount: function() {
                this.validate();
              },
              created: function() {
                this.form && this.form.register(this);
              },
              beforeDestroy: function() {
                this.form && this.form.unregister(this);
              },
              methods: {
                genInternalMessages: function(g) {
                  return g ? Array.isArray(g) ? g : [g] : [];
                },
                /** @public */
                reset: function() {
                  this.isResetting = !0, this.internalValue = Array.isArray(this.internalValue) ? [] : null;
                },
                /** @public */
                resetValidation: function() {
                  this.isResetting = !0;
                },
                /** @public */
                validate: function(g, m) {
                  g === void 0 && (g = !1);
                  var v = [];
                  m = m || this.internalValue, g && (this.hasInput = this.hasFocused = !0);
                  for (var y = 0; y < this.rules.length; y++) {
                    var E = this.rules[y], C = typeof E == "function" ? E(m) : E;
                    C === !1 || typeof C == "string" ? v.push(C || "") : typeof C != "boolean" && Object(d.consoleError)("Rules should return a string or boolean, received '" + c(C) + "' instead", this);
                  }
                  return this.errorBucket = v, this.valid = v.length === 0, this.valid;
                }
              }
            });
          }
        ),
        /***/
        "./src/presets/default/index.ts": (
          /*!**************************************!*\
            !*** ./src/presets/default/index.ts ***!
            \**************************************/
          /*! exports provided: preset */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "preset", function() {
              return o;
            }), i(
              /*! ../../styles/main.sass */
              "./src/styles/main.sass"
            );
            var a = i(
              /*! ../../locale */
              "./src/locale/index.ts"
            ), o = {
              breakpoint: {
                // TODO: update to MD2 spec in v3 - 1280
                mobileBreakpoint: 1264,
                scrollBarWidth: 16,
                thresholds: {
                  xs: 600,
                  sm: 960,
                  md: 1280,
                  lg: 1920
                }
              },
              icons: {
                // TODO: remove v3
                iconfont: "mdi",
                values: {}
              },
              lang: {
                current: "en",
                locales: {
                  en: a.en
                },
                // Default translator exists in lang service
                t: void 0
              },
              rtl: !1,
              theme: {
                dark: !1,
                default: "light",
                disable: !1,
                options: {
                  cspNonce: void 0,
                  customProperties: void 0,
                  minifyTheme: void 0,
                  themeCache: void 0,
                  variations: !0
                },
                themes: {
                  light: {
                    primary: "#1976D2",
                    secondary: "#424242",
                    accent: "#82B1FF",
                    error: "#FF5252",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                  },
                  dark: {
                    primary: "#2196F3",
                    secondary: "#424242",
                    accent: "#FF4081",
                    error: "#FF5252",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                  }
                }
              }
            };
          }
        ),
        /***/
        "./src/services/application/index.ts": (
          /*!*******************************************!*\
            !*** ./src/services/application/index.ts ***!
            \*******************************************/
          /*! exports provided: Application */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Application", function() {
              return l;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = function() {
              var f = function(u, c) {
                return f = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(h, p) {
                  h.__proto__ = p;
                } || function(h, p) {
                  for (var g in p)
                    Object.prototype.hasOwnProperty.call(p, g) && (h[g] = p[g]);
                }, f(u, c);
              };
              return function(d, u) {
                if (typeof u != "function" && u !== null)
                  throw new TypeError("Class extends value " + String(u) + " is not a constructor or null");
                f(d, u);
                function c() {
                  this.constructor = d;
                }
                d.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
              };
            }(), l = (
              /** @class */
              function(f) {
                o(d, f);
                function d() {
                  var u = f !== null && f.apply(this, arguments) || this;
                  return u.bar = 0, u.top = 0, u.left = 0, u.insetFooter = 0, u.right = 0, u.bottom = 0, u.footer = 0, u.application = {
                    bar: {},
                    top: {},
                    left: {},
                    insetFooter: {},
                    right: {},
                    bottom: {},
                    footer: {}
                  }, u;
                }
                return d.prototype.register = function(u, c, h) {
                  this.application[c][u] = h, this.update(c);
                }, d.prototype.unregister = function(u, c) {
                  this.application[c][u] != null && (delete this.application[c][u], this.update(c));
                }, d.prototype.update = function(u) {
                  this[u] = Object.values(this.application[u]).reduce(function(c, h) {
                    return c + h;
                  }, 0);
                }, d.property = "application", d;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/breakpoint/index.ts": (
          /*!******************************************!*\
            !*** ./src/services/breakpoint/index.ts ***!
            \******************************************/
          /*! exports provided: Breakpoint */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Breakpoint", function() {
              return l;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = function() {
              var f = function(u, c) {
                return f = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(h, p) {
                  h.__proto__ = p;
                } || function(h, p) {
                  for (var g in p)
                    Object.prototype.hasOwnProperty.call(p, g) && (h[g] = p[g]);
                }, f(u, c);
              };
              return function(d, u) {
                if (typeof u != "function" && u !== null)
                  throw new TypeError("Class extends value " + String(u) + " is not a constructor or null");
                f(d, u);
                function c() {
                  this.constructor = d;
                }
                d.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
              };
            }(), l = (
              /** @class */
              function(f) {
                o(d, f);
                function d(u) {
                  var c = f.call(this) || this;
                  c.xs = !1, c.sm = !1, c.md = !1, c.lg = !1, c.xl = !1, c.xsOnly = !1, c.smOnly = !1, c.smAndDown = !1, c.smAndUp = !1, c.mdOnly = !1, c.mdAndDown = !1, c.mdAndUp = !1, c.lgOnly = !1, c.lgAndDown = !1, c.lgAndUp = !1, c.xlOnly = !1, c.name = "xs", c.height = 0, c.width = 0, c.mobile = !0, c.resizeTimeout = 0;
                  var h = u[d.property], p = h.mobileBreakpoint, g = h.scrollBarWidth, m = h.thresholds;
                  return c.mobileBreakpoint = p, c.scrollBarWidth = g, c.thresholds = m, c;
                }
                return d.prototype.init = function() {
                  this.update(), !(typeof window > "u") && window.addEventListener("resize", this.onResize.bind(this), {
                    passive: !0
                  });
                }, d.prototype.update = function(u) {
                  u === void 0 && (u = !1);
                  var c = u ? 0 : this.getClientHeight(), h = u ? 0 : this.getClientWidth(), p = h < this.thresholds.xs, g = h < this.thresholds.sm && !p, m = h < this.thresholds.md - this.scrollBarWidth && !(g || p), v = h < this.thresholds.lg - this.scrollBarWidth && !(m || g || p), y = h >= this.thresholds.lg - this.scrollBarWidth;
                  switch (this.height = c, this.width = h, this.xs = p, this.sm = g, this.md = m, this.lg = v, this.xl = y, this.xsOnly = p, this.smOnly = g, this.smAndDown = (p || g) && !(m || v || y), this.smAndUp = !p && (g || m || v || y), this.mdOnly = m, this.mdAndDown = (p || g || m) && !(v || y), this.mdAndUp = !(p || g) && (m || v || y), this.lgOnly = v, this.lgAndDown = (p || g || m || v) && !y, this.lgAndUp = !(p || g || m) && (v || y), this.xlOnly = y, !0) {
                    case p:
                      this.name = "xs";
                      break;
                    case g:
                      this.name = "sm";
                      break;
                    case m:
                      this.name = "md";
                      break;
                    case v:
                      this.name = "lg";
                      break;
                    default:
                      this.name = "xl";
                      break;
                  }
                  if (typeof this.mobileBreakpoint == "number") {
                    this.mobile = h < parseInt(this.mobileBreakpoint, 10);
                    return;
                  }
                  var E = {
                    xs: 0,
                    sm: 1,
                    md: 2,
                    lg: 3,
                    xl: 4
                  }, C = E[this.name], x = E[this.mobileBreakpoint];
                  this.mobile = C <= x;
                }, d.prototype.onResize = function() {
                  clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.update.bind(this), 200);
                }, d.prototype.getClientWidth = function() {
                  return typeof document > "u" ? 0 : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                }, d.prototype.getClientHeight = function() {
                  return typeof document > "u" ? 0 : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                }, d.property = "breakpoint", d;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/goto/easing-patterns.ts": (
          /*!**********************************************!*\
            !*** ./src/services/goto/easing-patterns.ts ***!
            \**********************************************/
          /*! exports provided: linear, easeInQuad, easeOutQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, easeInQuint, easeOutQuint, easeInOutQuint */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "linear", function() {
              return a;
            }), i.d(r, "easeInQuad", function() {
              return o;
            }), i.d(r, "easeOutQuad", function() {
              return l;
            }), i.d(r, "easeInOutQuad", function() {
              return f;
            }), i.d(r, "easeInCubic", function() {
              return d;
            }), i.d(r, "easeOutCubic", function() {
              return u;
            }), i.d(r, "easeInOutCubic", function() {
              return c;
            }), i.d(r, "easeInQuart", function() {
              return h;
            }), i.d(r, "easeOutQuart", function() {
              return p;
            }), i.d(r, "easeInOutQuart", function() {
              return g;
            }), i.d(r, "easeInQuint", function() {
              return m;
            }), i.d(r, "easeOutQuint", function() {
              return v;
            }), i.d(r, "easeInOutQuint", function() {
              return y;
            });
            var a = function(C) {
              return C;
            }, o = function(C) {
              return Math.pow(C, 2);
            }, l = function(C) {
              return C * (2 - C);
            }, f = function(C) {
              return C < 0.5 ? 2 * Math.pow(C, 2) : -1 + (4 - 2 * C) * C;
            }, d = function(C) {
              return Math.pow(C, 3);
            }, u = function(C) {
              return Math.pow(--C, 3) + 1;
            }, c = function(C) {
              return C < 0.5 ? 4 * Math.pow(C, 3) : (C - 1) * (2 * C - 2) * (2 * C - 2) + 1;
            }, h = function(C) {
              return Math.pow(C, 4);
            }, p = function(C) {
              return 1 - Math.pow(--C, 4);
            }, g = function(C) {
              return C < 0.5 ? 8 * C * C * C * C : 1 - 8 * --C * C * C * C;
            }, m = function(C) {
              return Math.pow(C, 5);
            }, v = function(C) {
              return 1 + Math.pow(--C, 5);
            }, y = function(C) {
              return C < 0.5 ? 16 * Math.pow(C, 5) : 1 + 16 * Math.pow(--C, 5);
            };
          }
        ),
        /***/
        "./src/services/goto/index.ts": (
          /*!************************************!*\
            !*** ./src/services/goto/index.ts ***!
            \************************************/
          /*! exports provided: default, Goto */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return u;
            }), i.d(r, "Goto", function() {
              return c;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ./easing-patterns */
              "./src/services/goto/easing-patterns.ts"
            ), l = i(
              /*! ./util */
              "./src/services/goto/util.ts"
            ), f = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), d = function() {
              return d = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, d.apply(this, arguments);
            };
            function u(h, p) {
              p === void 0 && (p = {});
              var g = d({
                container: document.scrollingElement || document.body || document.documentElement,
                duration: 500,
                offset: 0,
                easing: "easeInOutCubic",
                appOffset: !0
              }, p), m = Object(l.getContainer)(g.container);
              if (g.appOffset && u.framework.application) {
                var v = m.classList.contains("v-navigation-drawer"), y = m.classList.contains("v-navigation-drawer--clipped"), E = u.framework.application, C = E.bar, x = E.top;
                g.offset += C, (!v || y) && (g.offset += x);
              }
              var b = performance.now(), P;
              typeof h == "number" ? P = Object(l.getOffset)(h) - g.offset : P = Object(l.getOffset)(h) - Object(l.getOffset)(m) - g.offset;
              var T = m.scrollTop;
              if (P === T)
                return Promise.resolve(P);
              var O = typeof g.easing == "function" ? g.easing : o[g.easing];
              if (!O)
                throw new TypeError('Easing function "' + g.easing + '" not found.');
              return new Promise(function(S) {
                return requestAnimationFrame(function L(A) {
                  var D = A - b, _ = Math.abs(g.duration ? Math.min(D / g.duration, 1) : 1);
                  m.scrollTop = Math.floor(T + (P - T) * O(_));
                  var w = m === document.body ? document.documentElement.clientHeight : m.clientHeight, B = w + m.scrollTop >= m.scrollHeight;
                  if (_ === 1 || // Need to go lower but reach bottom
                  P > m.scrollTop && B)
                    return S(P);
                  requestAnimationFrame(L);
                });
              });
            }
            u.framework = {}, u.init = function() {
            };
            var c = (
              /** @class */
              function(h) {
                f(p, h);
                function p() {
                  return h.call(this), u;
                }
                return p.property = "goTo", p;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/goto/util.ts": (
          /*!***********************************!*\
            !*** ./src/services/goto/util.ts ***!
            \***********************************/
          /*! exports provided: getOffset, getContainer */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "getOffset", function() {
              return a;
            }), i.d(r, "getContainer", function() {
              return o;
            });
            function a(d) {
              if (typeof d == "number")
                return d;
              var u = f(d);
              if (!u)
                throw typeof d == "string" ? new Error('Target element "' + d + '" not found.') : new TypeError("Target must be a Number/Selector/HTMLElement/VueComponent, received " + l(d) + " instead.");
              for (var c = 0; u; )
                c += u.offsetTop, u = u.offsetParent;
              return c;
            }
            function o(d) {
              var u = f(d);
              if (u)
                return u;
              throw typeof d == "string" ? new Error('Container element "' + d + '" not found.') : new TypeError("Container must be a Selector/HTMLElement/VueComponent, received " + l(d) + " instead.");
            }
            function l(d) {
              return d == null ? d : d.constructor.name;
            }
            function f(d) {
              return typeof d == "string" ? document.querySelector(d) : d && d._isVue ? d.$el : d instanceof HTMLElement ? d : null;
            }
          }
        ),
        /***/
        "./src/services/icons/index.ts": (
          /*!*************************************!*\
            !*** ./src/services/icons/index.ts ***!
            \*************************************/
          /*! exports provided: Icons */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Icons", function() {
              return d;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./presets */
              "./src/services/icons/presets/index.ts"
            ), f = function() {
              var u = function(h, p) {
                return u = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(g, m) {
                  g.__proto__ = m;
                } || function(g, m) {
                  for (var v in m)
                    Object.prototype.hasOwnProperty.call(m, v) && (g[v] = m[v]);
                }, u(h, p);
              };
              return function(c, h) {
                if (typeof h != "function" && h !== null)
                  throw new TypeError("Class extends value " + String(h) + " is not a constructor or null");
                u(c, h);
                function p() {
                  this.constructor = c;
                }
                c.prototype = h === null ? Object.create(h) : (p.prototype = h.prototype, new p());
              };
            }(), d = (
              /** @class */
              function(u) {
                f(c, u);
                function c(h) {
                  var p = u.call(this) || this, g = h[c.property], m = g.iconfont, v = g.values, y = g.component;
                  return p.component = y, p.iconfont = m, p.values = Object(o.mergeDeep)(l.default[m], v), p;
                }
                return c.property = "icons", c;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/icons/presets/fa-svg.ts": (
          /*!**********************************************!*\
            !*** ./src/services/icons/presets/fa-svg.ts ***!
            \**********************************************/
          /*! exports provided: convertToComponentDeclarations, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "convertToComponentDeclarations", function() {
              return o;
            });
            var a = i(
              /*! ./fa */
              "./src/services/icons/presets/fa.ts"
            );
            function o(l, f) {
              var d = {};
              for (var u in f)
                d[u] = {
                  component: l,
                  props: {
                    icon: f[u].split(" fa-")
                  }
                };
              return d;
            }
            r.default = o("font-awesome-icon", a.default);
          }
        ),
        /***/
        "./src/services/icons/presets/fa.ts": (
          /*!******************************************!*\
            !*** ./src/services/icons/presets/fa.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "fas fa-check",
              cancel: "fas fa-times-circle",
              close: "fas fa-times",
              delete: "fas fa-times-circle",
              clear: "fas fa-times-circle",
              success: "fas fa-check-circle",
              info: "fas fa-info-circle",
              warning: "fas fa-exclamation-circle",
              error: "fas fa-exclamation-triangle",
              prev: "fas fa-chevron-left",
              next: "fas fa-chevron-right",
              checkboxOn: "fas fa-check-square",
              checkboxOff: "far fa-square",
              checkboxIndeterminate: "fas fa-minus-square",
              delimiter: "fas fa-circle",
              sort: "fas fa-sort-up",
              expand: "fas fa-chevron-down",
              menu: "fas fa-bars",
              subgroup: "fas fa-caret-down",
              dropdown: "fas fa-caret-down",
              radioOn: "far fa-dot-circle",
              radioOff: "far fa-circle",
              edit: "fas fa-edit",
              ratingEmpty: "far fa-star",
              ratingFull: "fas fa-star",
              ratingHalf: "fas fa-star-half",
              loading: "fas fa-sync",
              first: "fas fa-step-backward",
              last: "fas fa-step-forward",
              unfold: "fas fa-arrows-alt-v",
              file: "fas fa-paperclip",
              plus: "fas fa-plus",
              minus: "fas fa-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/fa4.ts": (
          /*!*******************************************!*\
            !*** ./src/services/icons/presets/fa4.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "fa fa-check",
              cancel: "fa fa-times-circle",
              close: "fa fa-times",
              delete: "fa fa-times-circle",
              clear: "fa fa-times-circle",
              success: "fa fa-check-circle",
              info: "fa fa-info-circle",
              warning: "fa fa-exclamation",
              error: "fa fa-exclamation-triangle",
              prev: "fa fa-chevron-left",
              next: "fa fa-chevron-right",
              checkboxOn: "fa fa-check-square",
              checkboxOff: "fa fa-square-o",
              checkboxIndeterminate: "fa fa-minus-square",
              delimiter: "fa fa-circle",
              sort: "fa fa-sort-up",
              expand: "fa fa-chevron-down",
              menu: "fa fa-bars",
              subgroup: "fa fa-caret-down",
              dropdown: "fa fa-caret-down",
              radioOn: "fa fa-dot-circle-o",
              radioOff: "fa fa-circle-o",
              edit: "fa fa-pencil",
              ratingEmpty: "fa fa-star-o",
              ratingFull: "fa fa-star",
              ratingHalf: "fa fa-star-half-o",
              loading: "fa fa-refresh",
              first: "fa fa-step-backward",
              last: "fa fa-step-forward",
              unfold: "fa fa-angle-double-down",
              file: "fa fa-paperclip",
              plus: "fa fa-plus",
              minus: "fa fa-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/index.ts": (
          /*!*********************************************!*\
            !*** ./src/services/icons/presets/index.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mdi-svg */
              "./src/services/icons/presets/mdi-svg.ts"
            ), o = i(
              /*! ./md */
              "./src/services/icons/presets/md.ts"
            ), l = i(
              /*! ./mdi */
              "./src/services/icons/presets/mdi.ts"
            ), f = i(
              /*! ./fa */
              "./src/services/icons/presets/fa.ts"
            ), d = i(
              /*! ./fa4 */
              "./src/services/icons/presets/fa4.ts"
            ), u = i(
              /*! ./fa-svg */
              "./src/services/icons/presets/fa-svg.ts"
            );
            r.default = Object.freeze({
              mdiSvg: a.default,
              md: o.default,
              mdi: l.default,
              fa: f.default,
              fa4: d.default,
              faSvg: u.default
            });
          }
        ),
        /***/
        "./src/services/icons/presets/md.ts": (
          /*!******************************************!*\
            !*** ./src/services/icons/presets/md.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "check",
              cancel: "cancel",
              close: "close",
              delete: "cancel",
              clear: "clear",
              success: "check_circle",
              info: "info",
              warning: "priority_high",
              error: "warning",
              prev: "chevron_left",
              next: "chevron_right",
              checkboxOn: "check_box",
              checkboxOff: "check_box_outline_blank",
              checkboxIndeterminate: "indeterminate_check_box",
              delimiter: "fiber_manual_record",
              sort: "arrow_upward",
              expand: "keyboard_arrow_down",
              menu: "menu",
              subgroup: "arrow_drop_down",
              dropdown: "arrow_drop_down",
              radioOn: "radio_button_checked",
              radioOff: "radio_button_unchecked",
              edit: "edit",
              ratingEmpty: "star_border",
              ratingFull: "star",
              ratingHalf: "star_half",
              loading: "cached",
              first: "first_page",
              last: "last_page",
              unfold: "unfold_more",
              file: "attach_file",
              plus: "add",
              minus: "remove"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/mdi-svg.ts": (
          /*!***********************************************!*\
            !*** ./src/services/icons/presets/mdi-svg.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z",
              cancel: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              close: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
              delete: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              clear: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              success: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z",
              info: "M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
              warning: "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
              error: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              prev: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z",
              next: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z",
              checkboxOn: "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
              checkboxOff: "M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
              checkboxIndeterminate: "M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
              delimiter: "M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
              sort: "M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z",
              expand: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z",
              menu: "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z",
              subgroup: "M7,10L12,15L17,10H7Z",
              dropdown: "M7,10L12,15L17,10H7Z",
              radioOn: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z",
              radioOff: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
              edit: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
              ratingEmpty: "M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
              ratingFull: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z",
              ratingHalf: "M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
              loading: "M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12",
              first: "M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z",
              last: "M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z",
              unfold: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z",
              file: "M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z",
              plus: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z",
              minus: "M19,13H5V11H19V13Z"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/mdi.ts": (
          /*!*******************************************!*\
            !*** ./src/services/icons/presets/mdi.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "mdi-check",
              cancel: "mdi-close-circle",
              close: "mdi-close",
              delete: "mdi-close-circle",
              clear: "mdi-close",
              success: "mdi-check-circle",
              info: "mdi-information",
              warning: "mdi-exclamation",
              error: "mdi-alert",
              prev: "mdi-chevron-left",
              next: "mdi-chevron-right",
              checkboxOn: "mdi-checkbox-marked",
              checkboxOff: "mdi-checkbox-blank-outline",
              checkboxIndeterminate: "mdi-minus-box",
              delimiter: "mdi-circle",
              sort: "mdi-arrow-up",
              expand: "mdi-chevron-down",
              menu: "mdi-menu",
              subgroup: "mdi-menu-down",
              dropdown: "mdi-menu-down",
              radioOn: "mdi-radiobox-marked",
              radioOff: "mdi-radiobox-blank",
              edit: "mdi-pencil",
              ratingEmpty: "mdi-star-outline",
              ratingFull: "mdi-star",
              ratingHalf: "mdi-star-half-full",
              loading: "mdi-cached",
              first: "mdi-page-first",
              last: "mdi-page-last",
              unfold: "mdi-unfold-more-horizontal",
              file: "mdi-paperclip",
              plus: "mdi-plus",
              minus: "mdi-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/index.ts": (
          /*!*******************************!*\
            !*** ./src/services/index.ts ***!
            \*******************************/
          /*! exports provided: Application, Breakpoint, Goto, Icons, Lang, Presets, Theme */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./application */
              "./src/services/application/index.ts"
            );
            i.d(r, "Application", function() {
              return a.Application;
            });
            var o = i(
              /*! ./breakpoint */
              "./src/services/breakpoint/index.ts"
            );
            i.d(r, "Breakpoint", function() {
              return o.Breakpoint;
            });
            var l = i(
              /*! ./goto */
              "./src/services/goto/index.ts"
            );
            i.d(r, "Goto", function() {
              return l.Goto;
            });
            var f = i(
              /*! ./icons */
              "./src/services/icons/index.ts"
            );
            i.d(r, "Icons", function() {
              return f.Icons;
            });
            var d = i(
              /*! ./lang */
              "./src/services/lang/index.ts"
            );
            i.d(r, "Lang", function() {
              return d.Lang;
            });
            var u = i(
              /*! ./presets */
              "./src/services/presets/index.ts"
            );
            i.d(r, "Presets", function() {
              return u.Presets;
            });
            var c = i(
              /*! ./theme */
              "./src/services/theme/index.ts"
            );
            i.d(r, "Theme", function() {
              return c.Theme;
            });
          }
        ),
        /***/
        "./src/services/lang/index.ts": (
          /*!************************************!*\
            !*** ./src/services/lang/index.ts ***!
            \************************************/
          /*! exports provided: Lang */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Lang", function() {
              return g;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = function() {
              var m = function(y, E) {
                return m = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(C, x) {
                  C.__proto__ = x;
                } || function(C, x) {
                  for (var b in x)
                    Object.prototype.hasOwnProperty.call(x, b) && (C[b] = x[b]);
                }, m(y, E);
              };
              return function(v, y) {
                if (typeof y != "function" && y !== null)
                  throw new TypeError("Class extends value " + String(y) + " is not a constructor or null");
                m(v, y);
                function E() {
                  this.constructor = v;
                }
                v.prototype = y === null ? Object.create(y) : (E.prototype = y.prototype, new E());
              };
            }(), d = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, u = function(m, v, y) {
              if (y || arguments.length === 2)
                for (var E = 0, C = v.length, x; E < C; E++)
                  (x || !(E in v)) && (x || (x = Array.prototype.slice.call(v, 0, E)), x[E] = v[E]);
              return m.concat(x || Array.prototype.slice.call(v));
            }, c = "$vuetify.", h = Symbol("Lang fallback");
            function p(m, v, y, E) {
              y === void 0 && (y = !1);
              var C = v.replace(c, ""), x = Object(o.getObjectValueByPath)(m, C, h);
              return x === h && (y ? (Object(l.consoleError)('Translation key "' + C + '" not found in fallback'), x = v) : (Object(l.consoleWarn)('Translation key "' + C + '" not found, falling back to default'), x = p(E, v, !0, E))), x;
            }
            var g = (
              /** @class */
              function(m) {
                f(v, m);
                function v(y) {
                  var E = m.call(this) || this;
                  E.defaultLocale = "en";
                  var C = y[v.property], x = C.current, b = C.locales, P = C.t;
                  return E.current = x, E.locales = b, E.translator = P || E.defaultTranslator, E;
                }
                return v.prototype.currentLocale = function(y) {
                  var E = this.locales[this.current], C = this.locales[this.defaultLocale];
                  return p(E, y, !1, C);
                }, v.prototype.t = function(y) {
                  for (var E = [], C = 1; C < arguments.length; C++)
                    E[C - 1] = arguments[C];
                  return y.startsWith(c) ? this.translator.apply(this, u([y], d(E), !1)) : this.replace(y, E);
                }, v.prototype.defaultTranslator = function(y) {
                  for (var E = [], C = 1; C < arguments.length; C++)
                    E[C - 1] = arguments[C];
                  return this.replace(this.currentLocale(y), E);
                }, v.prototype.replace = function(y, E) {
                  return y.replace(/\{(\d+)\}/g, function(C, x) {
                    return String(E[+x]);
                  });
                }, v.property = "lang", v;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/presets/index.ts": (
          /*!***************************************!*\
            !*** ./src/services/presets/index.ts ***!
            \***************************************/
          /*! exports provided: Presets */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Presets", function() {
              return c;
            });
            var a = i(
              /*! ../../presets/default */
              "./src/presets/default/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), d = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), u = function(h, p) {
              var g = {};
              for (var m in h)
                Object.prototype.hasOwnProperty.call(h, m) && p.indexOf(m) < 0 && (g[m] = h[m]);
              if (h != null && typeof Object.getOwnPropertySymbols == "function")
                for (var v = 0, m = Object.getOwnPropertySymbols(h); v < m.length; v++)
                  p.indexOf(m[v]) < 0 && Object.prototype.propertyIsEnumerable.call(h, m[v]) && (g[m[v]] = h[m[v]]);
              return g;
            }, c = (
              /** @class */
              function(h) {
                d(p, h);
                function p(g, m) {
                  var v = h.call(this) || this, y = Object(l.mergeDeep)({}, a.preset), E = m.userPreset, C = E.preset, x = C === void 0 ? {} : C, b = u(E, ["preset"]);
                  return x.preset != null && Object(o.consoleWarn)("Global presets do not support the **preset** option, it can be safely omitted"), m.preset = Object(l.mergeDeep)(Object(l.mergeDeep)(y, x), b), v;
                }
                return p.property = "presets", p;
              }(f.Service)
            );
          }
        ),
        /***/
        "./src/services/service/index.ts": (
          /*!***************************************!*\
            !*** ./src/services/service/index.ts ***!
            \***************************************/
          /*! exports provided: Service */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Service", function() {
              return a;
            });
            var a = (
              /** @class */
              function() {
                function o() {
                  this.framework = {};
                }
                return o.prototype.init = function(l, f) {
                }, o;
              }()
            );
          }
        ),
        /***/
        "./src/services/theme/index.ts": (
          /*!*************************************!*\
            !*** ./src/services/theme/index.ts ***!
            \*************************************/
          /*! exports provided: Theme */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Theme", function() {
              return c;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ./utils */
              "./src/services/theme/utils.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), c = (
              /** @class */
              function(h) {
                u(p, h);
                function p(g) {
                  var m = h.call(this) || this;
                  m.disabled = !1, m.isDark = null, m.unwatch = null, m.vueMeta = null;
                  var v = g[p.property], y = v.dark, E = v.disable, C = v.options, x = v.themes;
                  return m.dark = !!y, m.defaults = m.themes = x, m.options = C, E ? (m.disabled = !0, m) : (m.themes = {
                    dark: m.fillVariant(x.dark, !0),
                    light: m.fillVariant(x.light, !1)
                  }, m);
                }
                return Object.defineProperty(p.prototype, "css", {
                  // When setting css, check for element and apply new values
                  /* eslint-disable-next-line accessor-pairs */
                  set: function(m) {
                    if (this.vueMeta) {
                      this.isVueMeta23 && this.applyVueMeta23();
                      return;
                    }
                    this.checkOrCreateStyleElement() && (this.styleEl.innerHTML = m);
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "dark", {
                  get: function() {
                    return !!this.isDark;
                  },
                  set: function(m) {
                    var v = this.isDark;
                    this.isDark = m, v != null && this.applyTheme();
                  },
                  enumerable: !1,
                  configurable: !0
                }), p.prototype.applyTheme = function() {
                  if (this.disabled)
                    return this.clearCss();
                  this.css = this.generatedStyles;
                }, p.prototype.clearCss = function() {
                  this.css = "";
                }, p.prototype.init = function(g, m) {
                  this.disabled || (g.$meta ? this.initVueMeta(g) : m && this.initSSR(m), this.initTheme(g));
                }, p.prototype.setTheme = function(g, m) {
                  this.themes[g] = Object.assign(this.themes[g], m), this.applyTheme();
                }, p.prototype.resetThemes = function() {
                  this.themes.light = Object.assign({}, this.defaults.light), this.themes.dark = Object.assign({}, this.defaults.dark), this.applyTheme();
                }, p.prototype.checkOrCreateStyleElement = function() {
                  return this.styleEl = document.getElementById("vuetify-theme-stylesheet"), this.styleEl ? !0 : (this.genStyleElement(), !!this.styleEl);
                }, p.prototype.fillVariant = function(g, m) {
                  g === void 0 && (g = {});
                  var v = this.themes[m ? "dark" : "light"];
                  return Object.assign({}, v, g);
                }, p.prototype.genStyleElement = function() {
                  typeof document > "u" || (this.styleEl = document.createElement("style"), this.styleEl.type = "text/css", this.styleEl.id = "vuetify-theme-stylesheet", this.options.cspNonce && this.styleEl.setAttribute("nonce", this.options.cspNonce), document.head.appendChild(this.styleEl));
                }, p.prototype.initVueMeta = function(g) {
                  var m = this;
                  if (this.vueMeta = g.$meta(), this.isVueMeta23) {
                    g.$nextTick(function() {
                      m.applyVueMeta23();
                    });
                    return;
                  }
                  var v = typeof this.vueMeta.getOptions == "function" ? this.vueMeta.getOptions().keyName : "metaInfo", y = g.$options[v] || {};
                  g.$options[v] = function() {
                    y.style = y.style || [];
                    var E = y.style.find(function(C) {
                      return C.id === "vuetify-theme-stylesheet";
                    });
                    return E ? E.cssText = m.generatedStyles : y.style.push({
                      cssText: m.generatedStyles,
                      type: "text/css",
                      id: "vuetify-theme-stylesheet",
                      nonce: (m.options || {}).cspNonce
                    }), y;
                  };
                }, p.prototype.applyVueMeta23 = function() {
                  var g = this.vueMeta.addApp("vuetify").set;
                  g({
                    style: [{
                      cssText: this.generatedStyles,
                      type: "text/css",
                      id: "vuetify-theme-stylesheet",
                      nonce: this.options.cspNonce
                    }]
                  });
                }, p.prototype.initSSR = function(g) {
                  var m = this.options.cspNonce ? ' nonce="' + this.options.cspNonce + '"' : "";
                  g.head = g.head || "", g.head += '<style type="text/css" id="vuetify-theme-stylesheet"' + m + ">" + this.generatedStyles + "</style>";
                }, p.prototype.initTheme = function(g) {
                  var m = this;
                  typeof document > "u" || (this.unwatch && (this.unwatch(), this.unwatch = null), g.$once("hook:created", function() {
                    var v = d.a.observable({
                      themes: m.themes
                    });
                    m.unwatch = g.$watch(function() {
                      return v.themes;
                    }, function() {
                      return m.applyTheme();
                    }, {
                      deep: !0
                    });
                  }), this.applyTheme());
                }, Object.defineProperty(p.prototype, "currentTheme", {
                  get: function() {
                    var m = this.dark ? "dark" : "light";
                    return this.themes[m];
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "generatedStyles", {
                  get: function() {
                    var m = this.parsedTheme, v = this.options || {}, y;
                    return v.themeCache != null && (y = v.themeCache.get(m), y != null) || (y = o.genStyles(m, v.customProperties), v.minifyTheme != null && (y = v.minifyTheme(y)), v.themeCache != null && v.themeCache.set(m, y)), y;
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "parsedTheme", {
                  get: function() {
                    return o.parse(this.currentTheme || {}, void 0, Object(l.getNestedValue)(this.options, ["variations"], !0));
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "isVueMeta23", {
                  // Is using v2.3 of vue-meta
                  // https://github.com/nuxt/vue-meta/releases/tag/v2.3.0
                  get: function() {
                    return typeof this.vueMeta.addApp == "function";
                  },
                  enumerable: !1,
                  configurable: !0
                }), p.property = "theme", p;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/theme/utils.ts": (
          /*!*************************************!*\
            !*** ./src/services/theme/utils.ts ***!
            \*************************************/
          /*! exports provided: parse, genStyles, genVariations, lighten, darken */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parse", function() {
              return h;
            }), i.d(r, "genStyles", function() {
              return y;
            }), i.d(r, "genVariations", function() {
              return E;
            }), i.d(r, "lighten", function() {
              return C;
            }), i.d(r, "darken", function() {
              return x;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), l = i(
              /*! ../../util/color/transformSRGB */
              "./src/util/color/transformSRGB.ts"
            ), f = i(
              /*! ../../util/color/transformCIELAB */
              "./src/util/color/transformCIELAB.ts"
            );
            function d(b) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(T) {
                return typeof T;
              } : d = function(T) {
                return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
              }, d(b);
            }
            var u = function(b, P) {
              var T = {};
              for (var O in b)
                Object.prototype.hasOwnProperty.call(b, O) && P.indexOf(O) < 0 && (T[O] = b[O]);
              if (b != null && typeof Object.getOwnPropertySymbols == "function")
                for (var S = 0, O = Object.getOwnPropertySymbols(b); S < O.length; S++)
                  P.indexOf(O[S]) < 0 && Object.prototype.propertyIsEnumerable.call(b, O[S]) && (T[O[S]] = b[O[S]]);
              return T;
            }, c = function(b, P) {
              var T = typeof Symbol == "function" && b[Symbol.iterator];
              if (!T)
                return b;
              var O = T.call(b), S, L = [], A;
              try {
                for (; (P === void 0 || P-- > 0) && !(S = O.next()).done; )
                  L.push(S.value);
              } catch (D) {
                A = {
                  error: D
                };
              } finally {
                try {
                  S && !S.done && (T = O.return) && T.call(O);
                } finally {
                  if (A)
                    throw A.error;
                }
              }
              return L;
            };
            function h(b, P, T) {
              P === void 0 && (P = !1), T === void 0 && (T = !0);
              for (var O = b.anchor, S = u(b, ["anchor"]), L = Object.keys(S), A = {}, D = 0; D < L.length; ++D) {
                var _ = L[D], w = b[_];
                w != null && (T ? P ? (_ === "base" || _.startsWith("lighten") || _.startsWith("darken")) && (A[_] = Object(o.colorToHex)(w)) : d(w) === "object" ? A[_] = h(w, !0, T) : A[_] = E(_, Object(o.colorToInt)(w)) : A[_] = {
                  base: Object(o.intToHex)(Object(o.colorToInt)(w))
                });
              }
              return P || (A.anchor = O || A.base || A.primary.base), A;
            }
            var p = function(P, T) {
              return `
.v-application .` + P + ` {
  background-color: ` + T + ` !important;
  border-color: ` + T + ` !important;
}
.v-application .` + P + `--text {
  color: ` + T + ` !important;
  caret-color: ` + T + ` !important;
}`;
            }, g = function(P, T, O) {
              var S = c(T.split(/(\d)/, 2), 2), L = S[0], A = S[1];
              return `
.v-application .` + P + "." + L + "-" + A + ` {
  background-color: ` + O + ` !important;
  border-color: ` + O + ` !important;
}
.v-application .` + P + "--text.text--" + L + "-" + A + ` {
  color: ` + O + ` !important;
  caret-color: ` + O + ` !important;
}`;
            }, m = function(P, T) {
              return T === void 0 && (T = "base"), "--v-" + P + "-" + T;
            }, v = function(P, T) {
              return T === void 0 && (T = "base"), "var(" + m(P, T) + ")";
            };
            function y(b, P) {
              P === void 0 && (P = !1);
              var T = b.anchor, O = u(b, ["anchor"]), S = Object.keys(O);
              if (!S.length)
                return "";
              var L = "", A = "", D = P ? v("anchor") : T;
              A += ".v-application a { color: " + D + "; }", P && (L += "  " + m("anchor") + ": " + T + `;
`);
              for (var _ = 0; _ < S.length; ++_) {
                var w = S[_], B = b[w];
                A += p(w, P ? v(w) : B.base), P && (L += "  " + m(w) + ": " + B.base + `;
`);
                for (var j = Object(a.keys)(B), k = 0; k < j.length; ++k) {
                  var X = j[k], rt = B[X];
                  X !== "base" && (A += g(w, X, P ? v(w, X) : rt), P && (L += "  " + m(w, X) + ": " + rt + `;
`));
                }
              }
              return P && (L = `:root {
` + L + `}

`), L + A;
            }
            function E(b, P) {
              for (var T = {
                base: Object(o.intToHex)(P)
              }, O = 5; O > 0; --O)
                T["lighten" + O] = Object(o.intToHex)(C(P, O));
              for (var O = 1; O <= 4; ++O)
                T["darken" + O] = Object(o.intToHex)(x(P, O));
              return T;
            }
            function C(b, P) {
              var T = f.fromXYZ(l.toXYZ(b));
              return T[0] = T[0] + P * 10, l.fromXYZ(f.toXYZ(T));
            }
            function x(b, P) {
              var T = f.fromXYZ(l.toXYZ(b));
              return T[0] = T[0] - P * 10, l.fromXYZ(f.toXYZ(T));
            }
          }
        ),
        /***/
        "./src/styles/components/_selection-controls.sass": (
          /*!********************************************************!*\
            !*** ./src/styles/components/_selection-controls.sass ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/styles/main.sass": (
          /*!******************************!*\
            !*** ./src/styles/main.sass ***!
            \******************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/util/color/transformCIELAB.ts": (
          /*!*******************************************!*\
            !*** ./src/util/color/transformCIELAB.ts ***!
            \*******************************************/
          /*! exports provided: fromXYZ, toXYZ */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromXYZ", function() {
              return f;
            }), i.d(r, "toXYZ", function() {
              return d;
            });
            var a = 0.20689655172413793, o = function(c) {
              return c > Math.pow(a, 3) ? Math.cbrt(c) : c / (3 * Math.pow(a, 2)) + 4 / 29;
            }, l = function(c) {
              return c > a ? Math.pow(c, 3) : 3 * Math.pow(a, 2) * (c - 4 / 29);
            };
            function f(u) {
              var c = o, h = c(u[1]);
              return [116 * h - 16, 500 * (c(u[0] / 0.95047) - h), 200 * (h - c(u[2] / 1.08883))];
            }
            function d(u) {
              var c = l, h = (u[0] + 16) / 116;
              return [c(h + u[1] / 500) * 0.95047, c(h), c(h - u[2] / 200) * 1.08883];
            }
          }
        ),
        /***/
        "./src/util/color/transformSRGB.ts": (
          /*!*****************************************!*\
            !*** ./src/util/color/transformSRGB.ts ***!
            \*****************************************/
          /*! exports provided: fromXYZ, toXYZ */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromXYZ", function() {
              return u;
            }), i.d(r, "toXYZ", function() {
              return c;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], l = function(p) {
              return p <= 31308e-7 ? p * 12.92 : 1.055 * Math.pow(p, 1 / 2.4) - 0.055;
            }, f = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], d = function(p) {
              return p <= 0.04045 ? p / 12.92 : Math.pow((p + 0.055) / 1.055, 2.4);
            };
            function u(h) {
              for (var p = Array(3), g = l, m = o, v = 0; v < 3; ++v)
                p[v] = Math.round(Object(a.clamp)(g(m[v][0] * h[0] + m[v][1] * h[1] + m[v][2] * h[2])) * 255);
              return (p[0] << 16) + (p[1] << 8) + (p[2] << 0);
            }
            function c(h) {
              for (var p = [0, 0, 0], g = d, m = f, v = g((h >> 16 & 255) / 255), y = g((h >> 8 & 255) / 255), E = g((h >> 0 & 255) / 255), C = 0; C < 3; ++C)
                p[C] = m[C][0] * v + m[C][1] * y + m[C][2] * E;
              return p;
            }
          }
        ),
        /***/
        "./src/util/colorUtils.ts": (
          /*!********************************!*\
            !*** ./src/util/colorUtils.ts ***!
            \********************************/
          /*! exports provided: isCssColor, colorToInt, classToHex, intToHex, colorToHex, HSVAtoRGBA, RGBAtoHSVA, HSVAtoHSLA, HSLAtoHSVA, RGBAtoCSS, RGBtoCSS, RGBAtoHex, HexToRGBA, HexToHSVA, HSVAtoHex, parseHex, parseGradient, RGBtoInt, contrastRatio */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "isCssColor", function() {
              return u;
            }), i.d(r, "colorToInt", function() {
              return c;
            }), i.d(r, "classToHex", function() {
              return h;
            }), i.d(r, "intToHex", function() {
              return p;
            }), i.d(r, "colorToHex", function() {
              return g;
            }), i.d(r, "HSVAtoRGBA", function() {
              return m;
            }), i.d(r, "RGBAtoHSVA", function() {
              return v;
            }), i.d(r, "HSVAtoHSLA", function() {
              return y;
            }), i.d(r, "HSLAtoHSVA", function() {
              return E;
            }), i.d(r, "RGBAtoCSS", function() {
              return C;
            }), i.d(r, "RGBtoCSS", function() {
              return x;
            }), i.d(r, "RGBAtoHex", function() {
              return b;
            }), i.d(r, "HexToRGBA", function() {
              return P;
            }), i.d(r, "HexToHSVA", function() {
              return T;
            }), i.d(r, "HSVAtoHex", function() {
              return O;
            }), i.d(r, "parseHex", function() {
              return S;
            }), i.d(r, "parseGradient", function() {
              return L;
            }), i.d(r, "RGBtoInt", function() {
              return A;
            }), i.d(r, "contrastRatio", function() {
              return D;
            });
            var a = i(
              /*! ./console */
              "./src/util/console.ts"
            ), o = i(
              /*! ./helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./color/transformSRGB */
              "./src/util/color/transformSRGB.ts"
            ), f = function() {
              return f = Object.assign || function(_) {
                for (var w, B = 1, j = arguments.length; B < j; B++) {
                  w = arguments[B];
                  for (var k in w)
                    Object.prototype.hasOwnProperty.call(w, k) && (_[k] = w[k]);
                }
                return _;
              }, f.apply(this, arguments);
            }, d = function(_, w) {
              var B = typeof Symbol == "function" && _[Symbol.iterator];
              if (!B)
                return _;
              var j = B.call(_), k, X = [], rt;
              try {
                for (; (w === void 0 || w-- > 0) && !(k = j.next()).done; )
                  X.push(k.value);
              } catch (et) {
                rt = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (B = j.return) && B.call(j);
                } finally {
                  if (rt)
                    throw rt.error;
                }
              }
              return X;
            };
            function u(_) {
              return !!_ && !!_.match(/^(#|var\(--|(rgb|hsl)a?\()/);
            }
            function c(_) {
              var w;
              if (typeof _ == "number")
                w = _;
              else if (typeof _ == "string") {
                var B = _[0] === "#" ? _.substring(1) : _;
                B.length === 3 && (B = B.split("").map(function(j) {
                  return j + j;
                }).join("")), B.length !== 6 && Object(a.consoleWarn)("'" + _ + "' is not a valid rgb color"), w = parseInt(B, 16);
              } else
                throw new TypeError("Colors can only be numbers or strings, recieved " + (_ == null ? _ : _.constructor.name) + " instead");
              return w < 0 ? (Object(a.consoleWarn)("Colors cannot be negative: '" + _ + "'"), w = 0) : (w > 16777215 || isNaN(w)) && (Object(a.consoleWarn)("'" + _ + "' is not a valid rgb color"), w = 16777215), w;
            }
            function h(_, w, B) {
              var j = d(_.toString().trim().replace("-", "").split(" ", 2), 2), k = j[0], X = j[1], rt = "";
              return k && k in w ? X && X in w[k] ? rt = w[k][X] : "base" in w[k] && (rt = w[k].base) : k && k in B && (rt = B[k]), rt;
            }
            function p(_) {
              var w = _.toString(16);
              return w.length < 6 && (w = "0".repeat(6 - w.length) + w), "#" + w;
            }
            function g(_) {
              return p(c(_));
            }
            function m(_) {
              var w = _.h, B = _.s, j = _.v, k = _.a, X = function(Z) {
                var dt = (Z + w / 60) % 6;
                return j - j * B * Math.max(Math.min(dt, 4 - dt, 1), 0);
              }, rt = [X(5), X(3), X(1)].map(function(et) {
                return Math.round(et * 255);
              });
              return {
                r: rt[0],
                g: rt[1],
                b: rt[2],
                a: k
              };
            }
            function v(_) {
              if (!_)
                return {
                  h: 0,
                  s: 1,
                  v: 1,
                  a: 1
                };
              var w = _.r / 255, B = _.g / 255, j = _.b / 255, k = Math.max(w, B, j), X = Math.min(w, B, j), rt = 0;
              k !== X && (k === w ? rt = 60 * (0 + (B - j) / (k - X)) : k === B ? rt = 60 * (2 + (j - w) / (k - X)) : k === j && (rt = 60 * (4 + (w - B) / (k - X)))), rt < 0 && (rt = rt + 360);
              var et = k === 0 ? 0 : (k - X) / k, Z = [rt, et, k];
              return {
                h: Z[0],
                s: Z[1],
                v: Z[2],
                a: _.a
              };
            }
            function y(_) {
              var w = _.h, B = _.s, j = _.v, k = _.a, X = j - j * B / 2, rt = X === 1 || X === 0 ? 0 : (j - X) / Math.min(X, 1 - X);
              return {
                h: w,
                s: rt,
                l: X,
                a: k
              };
            }
            function E(_) {
              var w = _.h, B = _.s, j = _.l, k = _.a, X = j + B * Math.min(j, 1 - j), rt = X === 0 ? 0 : 2 - 2 * j / X;
              return {
                h: w,
                s: rt,
                v: X,
                a: k
              };
            }
            function C(_) {
              return "rgba(" + _.r + ", " + _.g + ", " + _.b + ", " + _.a + ")";
            }
            function x(_) {
              return C(f(f({}, _), {
                a: 1
              }));
            }
            function b(_) {
              var w = function(j) {
                var k = Math.round(j).toString(16);
                return ("00".substr(0, 2 - k.length) + k).toUpperCase();
              };
              return "#" + [w(_.r), w(_.g), w(_.b), w(Math.round(_.a * 255))].join("");
            }
            function P(_) {
              var w = Object(o.chunk)(_.slice(1), 2).map(function(B) {
                return parseInt(B, 16);
              });
              return {
                r: w[0],
                g: w[1],
                b: w[2],
                a: Math.round(w[3] / 255 * 100) / 100
              };
            }
            function T(_) {
              var w = P(_);
              return v(w);
            }
            function O(_) {
              return b(m(_));
            }
            function S(_) {
              return _.startsWith("#") && (_ = _.slice(1)), _ = _.replace(/([^0-9a-f])/gi, "F"), (_.length === 3 || _.length === 4) && (_ = _.split("").map(function(w) {
                return w + w;
              }).join("")), _.length === 6 ? _ = Object(o.padEnd)(_, 8, "F") : _ = Object(o.padEnd)(Object(o.padEnd)(_, 6), 8, "F"), ("#" + _).toUpperCase().substr(0, 9);
            }
            function L(_, w, B) {
              return _.replace(/([a-z]+(\s[a-z]+-[1-5])?)(?=$|,)/gi, function(j) {
                return h(j, w, B) || j;
              }).replace(/(rgba\()#[0-9a-f]+(?=,)/gi, function(j) {
                return "rgba(" + Object.values(P(S(j.replace(/rgba\(/, "")))).slice(0, 3).join(",");
              });
            }
            function A(_) {
              return (_.r << 16) + (_.g << 8) + _.b;
            }
            function D(_, w) {
              var B = d(Object(l.toXYZ)(A(_)), 2), j = B[1], k = d(Object(l.toXYZ)(A(w)), 2), X = k[1];
              return (Math.max(j, X) + 0.05) / (Math.min(j, X) + 0.05);
            }
          }
        ),
        /***/
        "./src/util/colors.ts": (
          /*!****************************!*\
            !*** ./src/util/colors.ts ***!
            \****************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = Object.freeze({
              base: "#f44336",
              lighten5: "#ffebee",
              lighten4: "#ffcdd2",
              lighten3: "#ef9a9a",
              lighten2: "#e57373",
              lighten1: "#ef5350",
              darken1: "#e53935",
              darken2: "#d32f2f",
              darken3: "#c62828",
              darken4: "#b71c1c",
              accent1: "#ff8a80",
              accent2: "#ff5252",
              accent3: "#ff1744",
              accent4: "#d50000"
            }), o = Object.freeze({
              base: "#e91e63",
              lighten5: "#fce4ec",
              lighten4: "#f8bbd0",
              lighten3: "#f48fb1",
              lighten2: "#f06292",
              lighten1: "#ec407a",
              darken1: "#d81b60",
              darken2: "#c2185b",
              darken3: "#ad1457",
              darken4: "#880e4f",
              accent1: "#ff80ab",
              accent2: "#ff4081",
              accent3: "#f50057",
              accent4: "#c51162"
            }), l = Object.freeze({
              base: "#9c27b0",
              lighten5: "#f3e5f5",
              lighten4: "#e1bee7",
              lighten3: "#ce93d8",
              lighten2: "#ba68c8",
              lighten1: "#ab47bc",
              darken1: "#8e24aa",
              darken2: "#7b1fa2",
              darken3: "#6a1b9a",
              darken4: "#4a148c",
              accent1: "#ea80fc",
              accent2: "#e040fb",
              accent3: "#d500f9",
              accent4: "#aa00ff"
            }), f = Object.freeze({
              base: "#673ab7",
              lighten5: "#ede7f6",
              lighten4: "#d1c4e9",
              lighten3: "#b39ddb",
              lighten2: "#9575cd",
              lighten1: "#7e57c2",
              darken1: "#5e35b1",
              darken2: "#512da8",
              darken3: "#4527a0",
              darken4: "#311b92",
              accent1: "#b388ff",
              accent2: "#7c4dff",
              accent3: "#651fff",
              accent4: "#6200ea"
            }), d = Object.freeze({
              base: "#3f51b5",
              lighten5: "#e8eaf6",
              lighten4: "#c5cae9",
              lighten3: "#9fa8da",
              lighten2: "#7986cb",
              lighten1: "#5c6bc0",
              darken1: "#3949ab",
              darken2: "#303f9f",
              darken3: "#283593",
              darken4: "#1a237e",
              accent1: "#8c9eff",
              accent2: "#536dfe",
              accent3: "#3d5afe",
              accent4: "#304ffe"
            }), u = Object.freeze({
              base: "#2196f3",
              lighten5: "#e3f2fd",
              lighten4: "#bbdefb",
              lighten3: "#90caf9",
              lighten2: "#64b5f6",
              lighten1: "#42a5f5",
              darken1: "#1e88e5",
              darken2: "#1976d2",
              darken3: "#1565c0",
              darken4: "#0d47a1",
              accent1: "#82b1ff",
              accent2: "#448aff",
              accent3: "#2979ff",
              accent4: "#2962ff"
            }), c = Object.freeze({
              base: "#03a9f4",
              lighten5: "#e1f5fe",
              lighten4: "#b3e5fc",
              lighten3: "#81d4fa",
              lighten2: "#4fc3f7",
              lighten1: "#29b6f6",
              darken1: "#039be5",
              darken2: "#0288d1",
              darken3: "#0277bd",
              darken4: "#01579b",
              accent1: "#80d8ff",
              accent2: "#40c4ff",
              accent3: "#00b0ff",
              accent4: "#0091ea"
            }), h = Object.freeze({
              base: "#00bcd4",
              lighten5: "#e0f7fa",
              lighten4: "#b2ebf2",
              lighten3: "#80deea",
              lighten2: "#4dd0e1",
              lighten1: "#26c6da",
              darken1: "#00acc1",
              darken2: "#0097a7",
              darken3: "#00838f",
              darken4: "#006064",
              accent1: "#84ffff",
              accent2: "#18ffff",
              accent3: "#00e5ff",
              accent4: "#00b8d4"
            }), p = Object.freeze({
              base: "#009688",
              lighten5: "#e0f2f1",
              lighten4: "#b2dfdb",
              lighten3: "#80cbc4",
              lighten2: "#4db6ac",
              lighten1: "#26a69a",
              darken1: "#00897b",
              darken2: "#00796b",
              darken3: "#00695c",
              darken4: "#004d40",
              accent1: "#a7ffeb",
              accent2: "#64ffda",
              accent3: "#1de9b6",
              accent4: "#00bfa5"
            }), g = Object.freeze({
              base: "#4caf50",
              lighten5: "#e8f5e9",
              lighten4: "#c8e6c9",
              lighten3: "#a5d6a7",
              lighten2: "#81c784",
              lighten1: "#66bb6a",
              darken1: "#43a047",
              darken2: "#388e3c",
              darken3: "#2e7d32",
              darken4: "#1b5e20",
              accent1: "#b9f6ca",
              accent2: "#69f0ae",
              accent3: "#00e676",
              accent4: "#00c853"
            }), m = Object.freeze({
              base: "#8bc34a",
              lighten5: "#f1f8e9",
              lighten4: "#dcedc8",
              lighten3: "#c5e1a5",
              lighten2: "#aed581",
              lighten1: "#9ccc65",
              darken1: "#7cb342",
              darken2: "#689f38",
              darken3: "#558b2f",
              darken4: "#33691e",
              accent1: "#ccff90",
              accent2: "#b2ff59",
              accent3: "#76ff03",
              accent4: "#64dd17"
            }), v = Object.freeze({
              base: "#cddc39",
              lighten5: "#f9fbe7",
              lighten4: "#f0f4c3",
              lighten3: "#e6ee9c",
              lighten2: "#dce775",
              lighten1: "#d4e157",
              darken1: "#c0ca33",
              darken2: "#afb42b",
              darken3: "#9e9d24",
              darken4: "#827717",
              accent1: "#f4ff81",
              accent2: "#eeff41",
              accent3: "#c6ff00",
              accent4: "#aeea00"
            }), y = Object.freeze({
              base: "#ffeb3b",
              lighten5: "#fffde7",
              lighten4: "#fff9c4",
              lighten3: "#fff59d",
              lighten2: "#fff176",
              lighten1: "#ffee58",
              darken1: "#fdd835",
              darken2: "#fbc02d",
              darken3: "#f9a825",
              darken4: "#f57f17",
              accent1: "#ffff8d",
              accent2: "#ffff00",
              accent3: "#ffea00",
              accent4: "#ffd600"
            }), E = Object.freeze({
              base: "#ffc107",
              lighten5: "#fff8e1",
              lighten4: "#ffecb3",
              lighten3: "#ffe082",
              lighten2: "#ffd54f",
              lighten1: "#ffca28",
              darken1: "#ffb300",
              darken2: "#ffa000",
              darken3: "#ff8f00",
              darken4: "#ff6f00",
              accent1: "#ffe57f",
              accent2: "#ffd740",
              accent3: "#ffc400",
              accent4: "#ffab00"
            }), C = Object.freeze({
              base: "#ff9800",
              lighten5: "#fff3e0",
              lighten4: "#ffe0b2",
              lighten3: "#ffcc80",
              lighten2: "#ffb74d",
              lighten1: "#ffa726",
              darken1: "#fb8c00",
              darken2: "#f57c00",
              darken3: "#ef6c00",
              darken4: "#e65100",
              accent1: "#ffd180",
              accent2: "#ffab40",
              accent3: "#ff9100",
              accent4: "#ff6d00"
            }), x = Object.freeze({
              base: "#ff5722",
              lighten5: "#fbe9e7",
              lighten4: "#ffccbc",
              lighten3: "#ffab91",
              lighten2: "#ff8a65",
              lighten1: "#ff7043",
              darken1: "#f4511e",
              darken2: "#e64a19",
              darken3: "#d84315",
              darken4: "#bf360c",
              accent1: "#ff9e80",
              accent2: "#ff6e40",
              accent3: "#ff3d00",
              accent4: "#dd2c00"
            }), b = Object.freeze({
              base: "#795548",
              lighten5: "#efebe9",
              lighten4: "#d7ccc8",
              lighten3: "#bcaaa4",
              lighten2: "#a1887f",
              lighten1: "#8d6e63",
              darken1: "#6d4c41",
              darken2: "#5d4037",
              darken3: "#4e342e",
              darken4: "#3e2723"
            }), P = Object.freeze({
              base: "#607d8b",
              lighten5: "#eceff1",
              lighten4: "#cfd8dc",
              lighten3: "#b0bec5",
              lighten2: "#90a4ae",
              lighten1: "#78909c",
              darken1: "#546e7a",
              darken2: "#455a64",
              darken3: "#37474f",
              darken4: "#263238"
            }), T = Object.freeze({
              base: "#9e9e9e",
              lighten5: "#fafafa",
              lighten4: "#f5f5f5",
              lighten3: "#eeeeee",
              lighten2: "#e0e0e0",
              lighten1: "#bdbdbd",
              darken1: "#757575",
              darken2: "#616161",
              darken3: "#424242",
              darken4: "#212121"
            }), O = Object.freeze({
              black: "#000000",
              white: "#ffffff",
              transparent: "transparent"
            });
            r.default = Object.freeze({
              red: a,
              pink: o,
              purple: l,
              deepPurple: f,
              indigo: d,
              blue: u,
              lightBlue: c,
              cyan: h,
              teal: p,
              green: g,
              lightGreen: m,
              lime: v,
              yellow: y,
              amber: E,
              orange: C,
              deepOrange: x,
              brown: b,
              blueGrey: P,
              grey: T,
              shades: O
            });
          }
        ),
        /***/
        "./src/util/console.ts": (
          /*!*****************************!*\
            !*** ./src/util/console.ts ***!
            \*****************************/
          /*! exports provided: consoleInfo, consoleWarn, consoleError, deprecate, breaking, removed */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "consoleInfo", function() {
              return l;
            }), i.d(r, "consoleWarn", function() {
              return f;
            }), i.d(r, "consoleError", function() {
              return d;
            }), i.d(r, "deprecate", function() {
              return u;
            }), i.d(r, "breaking", function() {
              return c;
            }), i.d(r, "removed", function() {
              return h;
            });
            var a = i(
              /*! ../framework */
              "./src/framework.ts"
            );
            function o(y, E, C) {
              if (!a.default.config.silent) {
                if (C && (E = {
                  _isVue: !0,
                  $parent: C,
                  $options: E
                }), E) {
                  if (E.$_alreadyWarned = E.$_alreadyWarned || [], E.$_alreadyWarned.includes(y))
                    return;
                  E.$_alreadyWarned.push(y);
                }
                return "[Vuetify] " + y + (E ? v(E) : "");
              }
            }
            function l(y, E, C) {
              var x = o(y, E, C);
              x != null && console.info(x);
            }
            function f(y, E, C) {
              var x = o(y, E, C);
              x != null && console.warn(x);
            }
            function d(y, E, C) {
              var x = o(y, E, C);
              x != null && console.error(x);
            }
            function u(y, E, C, x) {
              f("[UPGRADE] '" + y + "' is deprecated, use '" + E + "' instead.", C, x);
            }
            function c(y, E, C, x) {
              d("[BREAKING] '" + y + "' has been removed, use '" + E + "' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide", C, x);
            }
            function h(y, E, C) {
              f("[REMOVED] '" + y + "' has been removed. You can safely omit it.", E, C);
            }
            var p = /(?:^|[-_])(\w)/g, g = function(E) {
              return E.replace(p, function(C) {
                return C.toUpperCase();
              }).replace(/[-_]/g, "");
            };
            function m(y, E) {
              if (y.$root === y)
                return "<Root>";
              var C = typeof y == "function" && y.cid != null ? y.options : y._isVue ? y.$options || y.constructor.options : y || {}, x = C.name || C._componentTag, b = C.__file;
              if (!x && b) {
                var P = b.match(/([^/\\]+)\.vue$/);
                x = P && P[1];
              }
              return (x ? "<" + g(x) + ">" : "<Anonymous>") + (b && E !== !1 ? " at " + b : "");
            }
            function v(y) {
              if (y._isVue && y.$parent) {
                for (var E = [], C = 0; y; ) {
                  if (E.length > 0) {
                    var x = E[E.length - 1];
                    if (x.constructor === y.constructor) {
                      C++, y = y.$parent;
                      continue;
                    } else
                      C > 0 && (E[E.length - 1] = [x, C], C = 0);
                  }
                  E.push(y), y = y.$parent;
                }
                return `

found in

` + E.map(function(b, P) {
                  return "" + (P === 0 ? "---> " : " ".repeat(5 + P * 2)) + (Array.isArray(b) ? m(b[0]) + "... (" + b[1] + " recursive calls)" : m(b));
                }).join(`
`);
              } else
                return `

(found in ` + m(y) + ")";
            }
          }
        ),
        /***/
        "./src/util/dateTimeUtils.ts": (
          /*!***********************************!*\
            !*** ./src/util/dateTimeUtils.ts ***!
            \***********************************/
          /*! exports provided: weekNumber, isLeapYear */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "weekNumber", function() {
              return d;
            }), i.d(r, "isLeapYear", function() {
              return u;
            });
            function a(c, h, p) {
              h === void 0 && (h = 0), p === void 0 && (p = 1);
              var g;
              return c < 100 && c >= 0 ? (g = new Date(Date.UTC(c, h, p)), isFinite(g.getUTCFullYear()) && g.setUTCFullYear(c)) : g = new Date(Date.UTC(c, h, p)), g;
            }
            function o(c, h, p) {
              var g = 7 + h - p, m = (7 + a(c, 0, g).getUTCDay() - h) % 7;
              return -m + g - 1;
            }
            function l(c, h, p, g) {
              var m = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][h];
              return h > 1 && u(c) && m++, m + p;
            }
            function f(c, h, p) {
              var g = o(c, h, p), m = o(c + 1, h, p), v = u(c) ? 366 : 365;
              return (v - g + m) / 7;
            }
            function d(c, h, p, g, m) {
              var v = o(c, g, m), y = Math.ceil((l(c, h, p) - v) / 7);
              return y < 1 ? y + f(c - 1, g, m) : y > f(c, g, m) ? y - f(c, g, m) : y;
            }
            function u(c) {
              return c % 4 === 0 && c % 100 !== 0 || c % 400 === 0;
            }
          }
        ),
        /***/
        "./src/util/dedupeModelListeners.ts": (
          /*!******************************************!*\
            !*** ./src/util/dedupeModelListeners.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o) {
              if (o.model && o.on && o.on.input)
                if (Array.isArray(o.on.input)) {
                  var l = o.on.input.indexOf(o.model.callback);
                  l > -1 && o.on.input.splice(l, 1);
                } else
                  delete o.on.input;
            }
          }
        ),
        /***/
        "./src/util/dom.ts": (
          /*!*************************!*\
            !*** ./src/util/dom.ts ***!
            \*************************/
          /*! exports provided: attachedRoot */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "attachedRoot", function() {
              return a;
            });
            function a(o) {
              if (typeof o.getRootNode != "function") {
                for (; o.parentNode; )
                  o = o.parentNode;
                return o !== document ? null : document;
              }
              var l = o.getRootNode();
              return l !== document && l.getRootNode({
                composed: !0
              }) !== document ? null : l;
            }
          }
        ),
        /***/
        "./src/util/helpers.ts": (
          /*!*****************************!*\
            !*** ./src/util/helpers.ts ***!
            \*****************************/
          /*! exports provided: createSimpleFunctional, directiveConfig, addOnceEventListener, passiveSupported, addPassiveEventListener, getNestedValue, deepEqual, getObjectValueByPath, getPropertyFromItem, createRange, getZIndex, filterObjectOnKeys, convertToUnit, kebabCase, isObject, keyCodes, remapInternalIcon, keys, camelize, arrayDiff, upperFirst, groupItems, wrapInArray, sortItems, defaultFilter, searchItems, getSlotType, debounce, throttle, getPrefixedScopedSlots, getSlot, clamp, padEnd, chunk, humanReadableFileSize, camelizeObjectKeys, mergeDeep, fillArray, composedPath */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createSimpleFunctional", function() {
              return c;
            }), i.d(r, "directiveConfig", function() {
              return h;
            }), i.d(r, "addOnceEventListener", function() {
              return p;
            }), i.d(r, "passiveSupported", function() {
              return g;
            }), i.d(r, "addPassiveEventListener", function() {
              return v;
            }), i.d(r, "getNestedValue", function() {
              return y;
            }), i.d(r, "deepEqual", function() {
              return E;
            }), i.d(r, "getObjectValueByPath", function() {
              return C;
            }), i.d(r, "getPropertyFromItem", function() {
              return x;
            }), i.d(r, "createRange", function() {
              return b;
            }), i.d(r, "getZIndex", function() {
              return P;
            }), i.d(r, "filterObjectOnKeys", function() {
              return T;
            }), i.d(r, "convertToUnit", function() {
              return O;
            }), i.d(r, "kebabCase", function() {
              return S;
            }), i.d(r, "isObject", function() {
              return L;
            }), i.d(r, "keyCodes", function() {
              return A;
            }), i.d(r, "remapInternalIcon", function() {
              return D;
            }), i.d(r, "keys", function() {
              return _;
            }), i.d(r, "camelize", function() {
              return B;
            }), i.d(r, "arrayDiff", function() {
              return j;
            }), i.d(r, "upperFirst", function() {
              return k;
            }), i.d(r, "groupItems", function() {
              return X;
            }), i.d(r, "wrapInArray", function() {
              return rt;
            }), i.d(r, "sortItems", function() {
              return et;
            }), i.d(r, "defaultFilter", function() {
              return Z;
            }), i.d(r, "searchItems", function() {
              return dt;
            }), i.d(r, "getSlotType", function() {
              return vt;
            }), i.d(r, "debounce", function() {
              return bt;
            }), i.d(r, "throttle", function() {
              return it;
            }), i.d(r, "getPrefixedScopedSlots", function() {
              return R;
            }), i.d(r, "getSlot", function() {
              return V;
            }), i.d(r, "clamp", function() {
              return tt;
            }), i.d(r, "padEnd", function() {
              return Y;
            }), i.d(r, "chunk", function() {
              return $;
            }), i.d(r, "humanReadableFileSize", function() {
              return z;
            }), i.d(r, "camelizeObjectKeys", function() {
              return at;
            }), i.d(r, "mergeDeep", function() {
              return ct;
            }), i.d(r, "fillArray", function() {
              return St;
            }), i.d(r, "composedPath", function() {
              return F;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(M) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? l = function(N) {
                return typeof N;
              } : l = function(N) {
                return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
              }, l(M);
            }
            var f = function() {
              return f = Object.assign || function(M) {
                for (var I, N = 1, G = arguments.length; N < G; N++) {
                  I = arguments[N];
                  for (var nt in I)
                    Object.prototype.hasOwnProperty.call(I, nt) && (M[nt] = I[nt]);
                }
                return M;
              }, f.apply(this, arguments);
            }, d = function(M, I) {
              var N = typeof Symbol == "function" && M[Symbol.iterator];
              if (!N)
                return M;
              var G = N.call(M), nt, lt = [], yt;
              try {
                for (; (I === void 0 || I-- > 0) && !(nt = G.next()).done; )
                  lt.push(nt.value);
              } catch (Lt) {
                yt = {
                  error: Lt
                };
              } finally {
                try {
                  nt && !nt.done && (N = G.return) && N.call(G);
                } finally {
                  if (yt)
                    throw yt.error;
                }
              }
              return lt;
            }, u = function(M, I, N) {
              if (N || arguments.length === 2)
                for (var G = 0, nt = I.length, lt; G < nt; G++)
                  (lt || !(G in I)) && (lt || (lt = Array.prototype.slice.call(I, 0, G)), lt[G] = I[G]);
              return M.concat(lt || Array.prototype.slice.call(I));
            };
            function c(M, I, N) {
              return I === void 0 && (I = "div"), o.a.extend({
                name: N || M.replace(/__/g, "-"),
                functional: !0,
                props: {
                  tag: {
                    type: String,
                    default: I
                  }
                },
                render: function(nt, lt) {
                  var yt = lt.data, Lt = lt.props, Nt = lt.children;
                  return yt.staticClass = (M + " " + (yt.staticClass || "")).trim(), nt(Lt.tag, yt, Nt);
                }
              });
            }
            function h(M, I) {
              return I === void 0 && (I = {}), f(f(f(f({}, I), M.modifiers), {
                value: M.arg
              }), M.value || {});
            }
            function p(M, I, N, G) {
              G === void 0 && (G = !1);
              var nt = function lt(yt) {
                N(yt), M.removeEventListener(I, lt, G);
              };
              M.addEventListener(I, nt, G);
            }
            var g = !1;
            try {
              if (typeof window < "u") {
                var m = Object.defineProperty({}, "passive", {
                  get: function() {
                    g = !0;
                  }
                });
                window.addEventListener("testListener", m, m), window.removeEventListener("testListener", m, m);
              }
            } catch (M) {
              console.warn(M);
            }
            function v(M, I, N, G) {
              M.addEventListener(I, N, g ? G : !1);
            }
            function y(M, I, N) {
              var G = I.length - 1;
              if (G < 0)
                return M === void 0 ? N : M;
              for (var nt = 0; nt < G; nt++) {
                if (M == null)
                  return N;
                M = M[I[nt]];
              }
              return M == null || M[I[G]] === void 0 ? N : M[I[G]];
            }
            function E(M, I) {
              if (M === I)
                return !0;
              if (M instanceof Date && I instanceof Date && M.getTime() !== I.getTime() || M !== Object(M) || I !== Object(I))
                return !1;
              var N = Object.keys(M);
              return N.length !== Object.keys(I).length ? !1 : N.every(function(G) {
                return E(M[G], I[G]);
              });
            }
            function C(M, I, N) {
              return M == null || !I || typeof I != "string" ? N : M[I] !== void 0 ? M[I] : (I = I.replace(/\[(\w+)\]/g, ".$1"), I = I.replace(/^\./, ""), y(M, I.split("."), N));
            }
            function x(M, I, N) {
              if (I == null)
                return M === void 0 ? N : M;
              if (M !== Object(M))
                return N === void 0 ? M : N;
              if (typeof I == "string")
                return C(M, I, N);
              if (Array.isArray(I))
                return y(M, I, N);
              if (typeof I != "function")
                return N;
              var G = I(M, N);
              return typeof G > "u" ? N : G;
            }
            function b(M) {
              return Array.from({
                length: M
              }, function(I, N) {
                return N;
              });
            }
            function P(M) {
              if (!M || M.nodeType !== Node.ELEMENT_NODE)
                return 0;
              var I = +window.getComputedStyle(M).getPropertyValue("z-index");
              return I || P(M.parentNode);
            }
            function T(M, I) {
              for (var N = {}, G = 0; G < I.length; G++) {
                var nt = I[G];
                typeof M[nt] < "u" && (N[nt] = M[nt]);
              }
              return N;
            }
            function O(M, I) {
              if (I === void 0 && (I = "px"), !(M == null || M === ""))
                return isNaN(+M) ? String(M) : "" + Number(M) + I;
            }
            function S(M) {
              return (M || "").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            }
            function L(M) {
              return M !== null && l(M) === "object";
            }
            var A = Object.freeze({
              enter: 13,
              tab: 9,
              delete: 46,
              esc: 27,
              space: 32,
              up: 38,
              down: 40,
              left: 37,
              right: 39,
              end: 35,
              home: 36,
              del: 46,
              backspace: 8,
              insert: 45,
              pageup: 33,
              pagedown: 34,
              shift: 16
            });
            function D(M, I) {
              var N = M.$vuetify.icons.component;
              if (I.startsWith("$")) {
                var G = "$vuetify.icons.values." + I.split("$").pop().split(".").pop(), nt = C(M, G, I);
                if (typeof nt == "string")
                  I = nt;
                else
                  return nt;
              }
              return N == null ? I : {
                component: N,
                props: {
                  icon: I
                }
              };
            }
            function _(M) {
              return Object.keys(M);
            }
            var w = /-(\w)/g, B = function(I) {
              return I.replace(w, function(N, G) {
                return G ? G.toUpperCase() : "";
              });
            };
            function j(M, I) {
              for (var N = [], G = 0; G < I.length; G++)
                M.indexOf(I[G]) < 0 && N.push(I[G]);
              return N;
            }
            function k(M) {
              return M.charAt(0).toUpperCase() + M.slice(1);
            }
            function X(M, I, N) {
              for (var G = I[0], nt = [], lt, yt = 0; yt < M.length; yt++) {
                var Lt = M[yt], Nt = C(Lt, G, null);
                lt !== Nt && (lt = Nt, nt.push({
                  name: Nt ?? "",
                  items: []
                })), nt[nt.length - 1].items.push(Lt);
              }
              return nt;
            }
            function rt(M) {
              return M != null ? Array.isArray(M) ? M : [M] : [];
            }
            function et(M, I, N, G, nt) {
              if (I === null || !I.length)
                return M;
              var lt = new Intl.Collator(G, {
                sensitivity: "accent",
                usage: "sort"
              });
              return M.sort(function(yt, Lt) {
                for (var Nt, Jt, J = 0; J < I.length; J++) {
                  var ft = I[J], Ct = C(yt, ft), Mt = C(Lt, ft);
                  if (N[J] && (Nt = d([Mt, Ct], 2), Ct = Nt[0], Mt = Nt[1]), nt && nt[ft]) {
                    var Ot = nt[ft](Ct, Mt);
                    if (!Ot)
                      continue;
                    return Ot;
                  }
                  if (!(Ct === null && Mt === null)) {
                    if (Ct instanceof Date && Mt instanceof Date)
                      return Ct.getTime() - Mt.getTime();
                    if (Jt = d([Ct, Mt].map(function(kt) {
                      return (kt || "").toString().toLocaleLowerCase();
                    }), 2), Ct = Jt[0], Mt = Jt[1], Ct !== Mt)
                      return !isNaN(Ct) && !isNaN(Mt) ? Number(Ct) - Number(Mt) : lt.compare(Ct, Mt);
                  }
                }
                return 0;
              });
            }
            function Z(M, I, N) {
              return M != null && I != null && typeof M != "boolean" && M.toString().toLocaleLowerCase().indexOf(I.toLocaleLowerCase()) !== -1;
            }
            function dt(M, I) {
              return !I || (I = I.toString().toLowerCase(), I.trim() === "") ? M : M.filter(function(N) {
                return Object.keys(N).some(function(G) {
                  return Z(C(N, G), I);
                });
              });
            }
            function vt(M, I, N) {
              if (M.$slots.hasOwnProperty(I) && M.$scopedSlots.hasOwnProperty(I) && M.$scopedSlots[I].name)
                return N ? "v-slot" : "scoped";
              if (M.$slots.hasOwnProperty(I))
                return "normal";
              if (M.$scopedSlots.hasOwnProperty(I))
                return "scoped";
            }
            function bt(M, I) {
              var N = 0;
              return function() {
                for (var G = [], nt = 0; nt < arguments.length; nt++)
                  G[nt] = arguments[nt];
                clearTimeout(N), N = setTimeout(function() {
                  return M.apply(void 0, u([], d(G), !1));
                }, I);
              };
            }
            function it(M, I) {
              var N = !1;
              return function() {
                for (var G = [], nt = 0; nt < arguments.length; nt++)
                  G[nt] = arguments[nt];
                if (!N)
                  return N = !0, setTimeout(function() {
                    return N = !1;
                  }, I), M.apply(void 0, u([], d(G), !1));
              };
            }
            function R(M, I) {
              return Object.keys(I).filter(function(N) {
                return N.startsWith(M);
              }).reduce(function(N, G) {
                return N[G.replace(M, "")] = I[G], N;
              }, {});
            }
            function V(M, I, N, G) {
              if (I === void 0 && (I = "default"), G === void 0 && (G = !1), M.$scopedSlots.hasOwnProperty(I))
                return M.$scopedSlots[I](N instanceof Function ? N() : N);
              if (M.$slots.hasOwnProperty(I) && (!N || G))
                return M.$slots[I];
            }
            function tt(M, I, N) {
              return I === void 0 && (I = 0), N === void 0 && (N = 1), Math.max(I, Math.min(N, M));
            }
            function Y(M, I, N) {
              return N === void 0 && (N = "0"), M + N.repeat(Math.max(0, I - M.length));
            }
            function $(M, I) {
              I === void 0 && (I = 1);
              for (var N = [], G = 0; G < M.length; )
                N.push(M.substr(G, I)), G += I;
              return N;
            }
            function z(M, I) {
              I === void 0 && (I = !1);
              var N = I ? 1024 : 1e3;
              if (M < N)
                return M + " B";
              for (var G = I ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"], nt = -1; Math.abs(M) >= N && nt < G.length - 1; )
                M /= N, ++nt;
              return M.toFixed(1) + " " + G[nt] + "B";
            }
            function at(M) {
              return M ? Object.keys(M).reduce(function(I, N) {
                return I[B(N)] = M[N], I;
              }, {}) : {};
            }
            function ct(M, I) {
              M === void 0 && (M = {}), I === void 0 && (I = {});
              for (var N in I) {
                var G = M[N], nt = I[N];
                if (L(G) && L(nt)) {
                  M[N] = ct(G, nt);
                  continue;
                }
                M[N] = nt;
              }
              return M;
            }
            function St(M, I) {
              return Array(M).fill(I);
            }
            function F(M) {
              if (M.composedPath)
                return M.composedPath();
              for (var I = [], N = M.target; N; ) {
                if (I.push(N), N.tagName === "HTML")
                  return I.push(document), I.push(window), I;
                N = N.parentElement;
              }
              return I;
            }
          }
        ),
        /***/
        "./src/util/mergeData.ts": (
          /*!*******************************!*\
            !*** ./src/util/mergeData.ts ***!
            \*******************************/
          /*! exports provided: default, mergeStyles, mergeClasses, mergeListeners */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return c;
            }), i.d(r, "mergeStyles", function() {
              return h;
            }), i.d(r, "mergeClasses", function() {
              return p;
            }), i.d(r, "mergeListeners", function() {
              return g;
            });
            var a = i(
              /*! ./helpers */
              "./src/util/helpers.ts"
            ), o = function() {
              return o = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, o.apply(this, arguments);
            }, l = function(m) {
              var v = typeof Symbol == "function" && Symbol.iterator, y = v && m[v], E = 0;
              if (y)
                return y.call(m);
              if (m && typeof m.length == "number")
                return {
                  next: function() {
                    return m && E >= m.length && (m = void 0), {
                      value: m && m[E++],
                      done: !m
                    };
                  }
                };
              throw new TypeError(v ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, f = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, d = {
              styleList: /;(?![^(]*\))/g,
              styleProp: /:(.*)/
            };
            function u(m) {
              var v, y, E = {};
              try {
                for (var C = l(m.split(d.styleList)), x = C.next(); !x.done; x = C.next()) {
                  var b = x.value, P = f(b.split(d.styleProp), 2), T = P[0], O = P[1];
                  T = T.trim(), T && (typeof O == "string" && (O = O.trim()), E[Object(a.camelize)(T)] = O);
                }
              } catch (S) {
                v = {
                  error: S
                };
              } finally {
                try {
                  x && !x.done && (y = C.return) && y.call(C);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return E;
            }
            function c() {
              for (var m, v, y = {}, E = arguments.length, C; E--; )
                try {
                  for (var x = (m = void 0, l(Object.keys(arguments[E]))), b = x.next(); !b.done; b = x.next())
                    switch (C = b.value, C) {
                      case "class":
                      case "directives":
                        arguments[E][C] && (y[C] = p(y[C], arguments[E][C]));
                        break;
                      case "style":
                        arguments[E][C] && (y[C] = h(y[C], arguments[E][C]));
                        break;
                      case "staticClass":
                        if (!arguments[E][C])
                          break;
                        y[C] === void 0 && (y[C] = ""), y[C] && (y[C] += " "), y[C] += arguments[E][C].trim();
                        break;
                      case "on":
                      case "nativeOn":
                        arguments[E][C] && (y[C] = g(y[C], arguments[E][C]));
                        break;
                      case "attrs":
                      case "props":
                      case "domProps":
                      case "scopedSlots":
                      case "staticStyle":
                      case "hook":
                      case "transition":
                        if (!arguments[E][C])
                          break;
                        y[C] || (y[C] = {}), y[C] = o(o({}, arguments[E][C]), y[C]);
                        break;
                      default:
                        y[C] || (y[C] = arguments[E][C]);
                    }
                } catch (P) {
                  m = {
                    error: P
                  };
                } finally {
                  try {
                    b && !b.done && (v = x.return) && v.call(x);
                  } finally {
                    if (m)
                      throw m.error;
                  }
                }
              return y;
            }
            function h(m, v) {
              return m ? v ? (m = Object(a.wrapInArray)(typeof m == "string" ? u(m) : m), m.concat(typeof v == "string" ? u(v) : v)) : m : v;
            }
            function p(m, v) {
              return v ? m && m ? Object(a.wrapInArray)(m).concat(v) : v : m;
            }
            function g() {
              for (var m = [], v = 0; v < arguments.length; v++)
                m[v] = arguments[v];
              if (!m[0])
                return m[1];
              if (!m[1])
                return m[0];
              for (var y = {}, E = 2; E--; ) {
                var C = m[E];
                for (var x in C)
                  C[x] && (y[x] ? y[x] = [].concat(C[x], y[x]) : y[x] = C[x]);
              }
              return y;
            }
          }
        ),
        /***/
        "./src/util/mixins.ts": (
          /*!****************************!*\
            !*** ./src/util/mixins.ts ***!
            \****************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l() {
              for (var f = [], d = 0; d < arguments.length; d++)
                f[d] = arguments[d];
              return o.a.extend({
                mixins: f
              });
            }
          }
        ),
        /***/
        "./src/util/rebuildFunctionalSlots.ts": (
          /*!********************************************!*\
            !*** ./src/util/rebuildFunctionalSlots.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o, l) {
              var f = [];
              for (var d in o)
                o.hasOwnProperty(d) && f.push(l("template", {
                  slot: d
                }, o[d]));
              return f;
            }
          }
        ),
        /***/
        vue: (
          /*!******************************************************************************!*\
            !*** external {"commonjs":"vue","commonjs2":"vue","amd":"vue","root":"Vue"} ***!
            \******************************************************************************/
          /*! no static exports found */
          /***/
          function(s, r) {
            s.exports = n;
          }
        )
        /******/
      }).default
    );
  });
})(MI);
var M8 = MI.exports;
const SI = /* @__PURE__ */ qo(M8);
var lf = { exports: {} };
lf.exports;
(function(e, t) {
  var n = 200, s = "__lodash_hash_undefined__", r = 800, i = 16, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", f = "[object AsyncFunction]", d = "[object Boolean]", u = "[object Date]", c = "[object Error]", h = "[object Function]", p = "[object GeneratorFunction]", g = "[object Map]", m = "[object Number]", v = "[object Null]", y = "[object Object]", E = "[object Proxy]", C = "[object RegExp]", x = "[object Set]", b = "[object String]", P = "[object Undefined]", T = "[object WeakMap]", O = "[object ArrayBuffer]", S = "[object DataView]", L = "[object Float32Array]", A = "[object Float64Array]", D = "[object Int8Array]", _ = "[object Int16Array]", w = "[object Int32Array]", B = "[object Uint8Array]", j = "[object Uint8ClampedArray]", k = "[object Uint16Array]", X = "[object Uint32Array]", rt = /[\\^$.*+?()[\]{}|]/g, et = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, dt = {};
  dt[L] = dt[A] = dt[D] = dt[_] = dt[w] = dt[B] = dt[j] = dt[k] = dt[X] = !0, dt[o] = dt[l] = dt[O] = dt[d] = dt[S] = dt[u] = dt[c] = dt[h] = dt[g] = dt[m] = dt[y] = dt[C] = dt[x] = dt[b] = dt[T] = !1;
  var vt = typeof _t == "object" && _t && _t.Object === Object && _t, bt = typeof self == "object" && self && self.Object === Object && self, it = vt || bt || Function("return this")(), R = t && !t.nodeType && t, V = R && !0 && e && !e.nodeType && e, tt = V && V.exports === R, Y = tt && vt.process, $ = function() {
    try {
      var H = V && V.require && V.require("util").types;
      return H || Y && Y.binding && Y.binding("util");
    } catch {
    }
  }(), z = $ && $.isTypedArray;
  function at(H, st, ut) {
    switch (ut.length) {
      case 0:
        return H.call(st);
      case 1:
        return H.call(st, ut[0]);
      case 2:
        return H.call(st, ut[0], ut[1]);
      case 3:
        return H.call(st, ut[0], ut[1], ut[2]);
    }
    return H.apply(st, ut);
  }
  function ct(H, st) {
    for (var ut = -1, wt = Array(H); ++ut < H; )
      wt[ut] = st(ut);
    return wt;
  }
  function St(H) {
    return function(st) {
      return H(st);
    };
  }
  function F(H, st) {
    return H == null ? void 0 : H[st];
  }
  function M(H, st) {
    return function(ut) {
      return H(st(ut));
    };
  }
  var I = Array.prototype, N = Function.prototype, G = Object.prototype, nt = it["__core-js_shared__"], lt = N.toString, yt = G.hasOwnProperty, Lt = function() {
    var H = /[^.]+$/.exec(nt && nt.keys && nt.keys.IE_PROTO || "");
    return H ? "Symbol(src)_1." + H : "";
  }(), Nt = G.toString, Jt = lt.call(Object), J = RegExp(
    "^" + lt.call(yt).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ft = tt ? it.Buffer : void 0, Ct = it.Symbol, Mt = it.Uint8Array, Ot = ft ? ft.allocUnsafe : void 0, kt = M(Object.getPrototypeOf, Object), de = Object.create, Pe = G.propertyIsEnumerable, Me = I.splice, Ce = Ct ? Ct.toStringTag : void 0, $e = function() {
    try {
      var H = Os(Object, "defineProperty");
      return H({}, "", {}), H;
    } catch {
    }
  }(), bn = ft ? ft.isBuffer : void 0, Ye = Math.max, Hn = Date.now, fn = Os(it, "Map"), Fe = Os(Object, "create"), pn = function() {
    function H() {
    }
    return function(st) {
      if (!Ts(st))
        return {};
      if (de)
        return de(st);
      H.prototype = st;
      var ut = new H();
      return H.prototype = void 0, ut;
    };
  }();
  function mn(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function we() {
    this.__data__ = Fe ? Fe(null) : {}, this.size = 0;
  }
  function gn(H) {
    var st = this.has(H) && delete this.__data__[H];
    return this.size -= st ? 1 : 0, st;
  }
  function ze(H) {
    var st = this.__data__;
    if (Fe) {
      var ut = st[H];
      return ut === s ? void 0 : ut;
    }
    return yt.call(st, H) ? st[H] : void 0;
  }
  function On(H) {
    var st = this.__data__;
    return Fe ? st[H] !== void 0 : yt.call(st, H);
  }
  function qe(H, st) {
    var ut = this.__data__;
    return this.size += this.has(H) ? 0 : 1, ut[H] = Fe && st === void 0 ? s : st, this;
  }
  mn.prototype.clear = we, mn.prototype.delete = gn, mn.prototype.get = ze, mn.prototype.has = On, mn.prototype.set = qe;
  function se(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function mi() {
    this.__data__ = [], this.size = 0;
  }
  function Xe(H) {
    var st = this.__data__, ut = Nn(st, H);
    if (ut < 0)
      return !1;
    var wt = st.length - 1;
    return ut == wt ? st.pop() : Me.call(st, ut, 1), --this.size, !0;
  }
  function sn(H) {
    var st = this.__data__, ut = Nn(st, H);
    return ut < 0 ? void 0 : st[ut][1];
  }
  function Ue(H) {
    return Nn(this.__data__, H) > -1;
  }
  function wn(H, st) {
    var ut = this.__data__, wt = Nn(ut, H);
    return wt < 0 ? (++this.size, ut.push([H, st])) : ut[wt][1] = st, this;
  }
  se.prototype.clear = mi, se.prototype.delete = Xe, se.prototype.get = sn, se.prototype.has = Ue, se.prototype.set = wn;
  function ii(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function oa() {
    this.size = 0, this.__data__ = {
      hash: new mn(),
      map: new (fn || se)(),
      string: new mn()
    };
  }
  function Cs(H) {
    var st = Zn(this, H).delete(H);
    return this.size -= st ? 1 : 0, st;
  }
  function xs(H) {
    return Zn(this, H).get(H);
  }
  function kr(H) {
    return Zn(this, H).has(H);
  }
  function Bn(H, st) {
    var ut = Zn(this, H), wt = ut.size;
    return ut.set(H, st), this.size += ut.size == wt ? 0 : 1, this;
  }
  ii.prototype.clear = oa, ii.prototype.delete = Cs, ii.prototype.get = xs, ii.prototype.has = kr, ii.prototype.set = Bn;
  function gi(H) {
    var st = this.__data__ = new se(H);
    this.size = st.size;
  }
  function Hr() {
    this.__data__ = new se(), this.size = 0;
  }
  function Ve(H) {
    var st = this.__data__, ut = st.delete(H);
    return this.size = st.size, ut;
  }
  function vi(H) {
    return this.__data__.get(H);
  }
  function yi(H) {
    return this.__data__.has(H);
  }
  function Ze(H, st) {
    var ut = this.__data__;
    if (ut instanceof se) {
      var wt = ut.__data__;
      if (!fn || wt.length < n - 1)
        return wt.push([H, st]), this.size = ++ut.size, this;
      ut = this.__data__ = new ii(wt);
    }
    return ut.set(H, st), this.size = ut.size, this;
  }
  gi.prototype.clear = Hr, gi.prototype.delete = Ve, gi.prototype.get = vi, gi.prototype.has = yi, gi.prototype.set = Ze;
  function Gi(H, st) {
    var ut = ar(H), wt = !ut && ts(H), fe = !ut && !wt && so(H), xe = !ut && !wt && !fe && ah(H), je = ut || wt || fe || xe, me = je ? ct(H.length, String) : [], Ke = me.length;
    for (var Ai in H)
      (st || yt.call(H, Ai)) && !(je && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ai == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      fe && (Ai == "offset" || Ai == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      xe && (Ai == "buffer" || Ai == "byteLength" || Ai == "byteOffset") || // Skip index properties.
      Hi(Ai, Ke))) && me.push(Ai);
    return me;
  }
  function Or(H, st, ut) {
    (ut !== void 0 && !Jn(H[st], ut) || ut === void 0 && !(st in H)) && Tn(H, st, ut);
  }
  function bs(H, st, ut) {
    var wt = H[st];
    (!(yt.call(H, st) && Jn(wt, ut)) || ut === void 0 && !(st in H)) && Tn(H, st, ut);
  }
  function Nn(H, st) {
    for (var ut = H.length; ut--; )
      if (Jn(H[ut][0], st))
        return ut;
    return -1;
  }
  function Tn(H, st, ut) {
    st == "__proto__" && $e ? $e(H, st, {
      configurable: !0,
      enumerable: !0,
      value: ut,
      writable: !0
    }) : H[st] = ut;
  }
  var ri = Se();
  function Dn(H) {
    return H == null ? H === void 0 ? P : v : Ce && Ce in Object(H) ? Jr(H) : Et(H);
  }
  function Fn(H) {
    return la(H) && Dn(H) == o;
  }
  function Je(H) {
    if (!Ts(H) || K(H))
      return !1;
    var st = Iu(H) ? J : et;
    return st.test(yn(H));
  }
  function Yn(H) {
    return la(H) && rh(H.length) && !!dt[Dn(H)];
  }
  function si(H) {
    if (!Ts(H))
      return ot(H);
    var st = q(H), ut = [];
    for (var wt in H)
      wt == "constructor" && (st || !yt.call(H, wt)) || ut.push(wt);
    return ut;
  }
  function Tr(H, st, ut, wt, fe) {
    H !== st && ri(st, function(xe, je) {
      if (fe || (fe = new gi()), Ts(xe))
        Yr(H, st, je, ut, Tr, wt, fe);
      else {
        var me = wt ? wt(ne(H, je), xe, je + "", H, st, fe) : void 0;
        me === void 0 && (me = xe), Or(H, je, me);
      }
    }, es);
  }
  function Yr(H, st, ut, wt, fe, xe, je) {
    var me = ne(H, ut), Ke = ne(st, ut), Ai = je.get(Ke);
    if (Ai) {
      Or(H, ut, Ai);
      return;
    }
    var Ci = xe ? xe(me, Ke, ut + "", H, st, je) : void 0, ns = Ci === void 0;
    if (ns) {
      var Au = ar(Ke), Lu = !Au && so(Ke), lh = !Au && !Lu && ah(Ke);
      Ci = Ke, Au || Lu || lh ? ar(me) ? Ci = me : ih(me) ? Ci = Pr(me) : Lu ? (ns = !1, Ci = Ei(Ke, !0)) : lh ? (ns = !1, Ci = Zr(Ke, !0)) : Ci = [] : sh(Ke) || ts(Ke) ? (Ci = me, ts(me) ? Ci = il(me) : (!Ts(me) || Iu(me)) && (Ci = Qr(Ke))) : ns = !1;
    }
    ns && (je.set(Ke, Ci), fe(Ci, Ke, wt, xe, je), je.delete(Ke)), Or(H, ut, Ci);
  }
  function sr(H, st) {
    return vn(Rt(H, st, Du), H + "");
  }
  var Xn = $e ? function(H, st) {
    return $e(H, "toString", {
      configurable: !0,
      enumerable: !1,
      value: oh(st),
      writable: !0
    });
  } : Du;
  function Ei(H, st) {
    if (st)
      return H.slice();
    var ut = H.length, wt = Ot ? Ot(ut) : new H.constructor(ut);
    return H.copy(wt), wt;
  }
  function Xr(H) {
    var st = new H.constructor(H.byteLength);
    return new Mt(st).set(new Mt(H)), st;
  }
  function Zr(H, st) {
    var ut = st ? Xr(H.buffer) : H.buffer;
    return new H.constructor(ut, H.byteOffset, H.length);
  }
  function Pr(H, st) {
    var ut = -1, wt = H.length;
    for (st || (st = Array(wt)); ++ut < wt; )
      st[ut] = H[ut];
    return st;
  }
  function ki(H, st, ut, wt) {
    var fe = !ut;
    ut || (ut = {});
    for (var xe = -1, je = st.length; ++xe < je; ) {
      var me = st[xe], Ke = wt ? wt(ut[me], H[me], me, ut, H) : void 0;
      Ke === void 0 && (Ke = H[me]), fe ? Tn(ut, me, Ke) : bs(ut, me, Ke);
    }
    return ut;
  }
  function Di(H) {
    return sr(function(st, ut) {
      var wt = -1, fe = ut.length, xe = fe > 1 ? ut[fe - 1] : void 0, je = fe > 2 ? ut[2] : void 0;
      for (xe = H.length > 3 && typeof xe == "function" ? (fe--, xe) : void 0, je && qr(ut[0], ut[1], je) && (xe = fe < 3 ? void 0 : xe, fe = 1), st = Object(st); ++wt < fe; ) {
        var me = ut[wt];
        me && H(st, me, wt, xe);
      }
      return st;
    });
  }
  function Se(H) {
    return function(st, ut, wt) {
      for (var fe = -1, xe = Object(st), je = wt(st), me = je.length; me--; ) {
        var Ke = je[H ? me : ++fe];
        if (ut(xe[Ke], Ke, xe) === !1)
          break;
      }
      return st;
    };
  }
  function Zn(H, st) {
    var ut = H.__data__;
    return U(st) ? ut[typeof st == "string" ? "string" : "hash"] : ut.map;
  }
  function Os(H, st) {
    var ut = F(H, st);
    return Je(ut) ? ut : void 0;
  }
  function Jr(H) {
    var st = yt.call(H, Ce), ut = H[Ce];
    try {
      H[Ce] = void 0;
      var wt = !0;
    } catch {
    }
    var fe = Nt.call(H);
    return wt && (st ? H[Ce] = ut : delete H[Ce]), fe;
  }
  function Qr(H) {
    return typeof H.constructor == "function" && !q(H) ? pn(kt(H)) : {};
  }
  function Hi(H, st) {
    var ut = typeof H;
    return st = st ?? a, !!st && (ut == "number" || ut != "symbol" && Z.test(H)) && H > -1 && H % 1 == 0 && H < st;
  }
  function qr(H, st, ut) {
    if (!Ts(ut))
      return !1;
    var wt = typeof st;
    return (wt == "number" ? Su(ut) && Hi(st, ut.length) : wt == "string" && st in ut) ? Jn(ut[st], H) : !1;
  }
  function U(H) {
    var st = typeof H;
    return st == "string" || st == "number" || st == "symbol" || st == "boolean" ? H !== "__proto__" : H === null;
  }
  function K(H) {
    return !!Lt && Lt in H;
  }
  function q(H) {
    var st = H && H.constructor, ut = typeof st == "function" && st.prototype || G;
    return H === ut;
  }
  function ot(H) {
    var st = [];
    if (H != null)
      for (var ut in Object(H))
        st.push(ut);
    return st;
  }
  function Et(H) {
    return Nt.call(H);
  }
  function Rt(H, st, ut) {
    return st = Ye(st === void 0 ? H.length - 1 : st, 0), function() {
      for (var wt = arguments, fe = -1, xe = Ye(wt.length - st, 0), je = Array(xe); ++fe < xe; )
        je[fe] = wt[st + fe];
      fe = -1;
      for (var me = Array(st + 1); ++fe < st; )
        me[fe] = wt[fe];
      return me[st] = ut(je), at(H, this, me);
    };
  }
  function ne(H, st) {
    if (!(st === "constructor" && typeof H[st] == "function") && st != "__proto__")
      return H[st];
  }
  var vn = Pn(Xn);
  function Pn(H) {
    var st = 0, ut = 0;
    return function() {
      var wt = Hn(), fe = i - (wt - ut);
      if (ut = wt, fe > 0) {
        if (++st >= r)
          return arguments[0];
      } else
        st = 0;
      return H.apply(void 0, arguments);
    };
  }
  function yn(H) {
    if (H != null) {
      try {
        return lt.call(H);
      } catch {
      }
      try {
        return H + "";
      } catch {
      }
    }
    return "";
  }
  function Jn(H, st) {
    return H === st || H !== H && st !== st;
  }
  var ts = Fn(function() {
    return arguments;
  }()) ? Fn : function(H) {
    return la(H) && yt.call(H, "callee") && !Pe.call(H, "callee");
  }, ar = Array.isArray;
  function Su(H) {
    return H != null && rh(H.length) && !Iu(H);
  }
  function ih(H) {
    return la(H) && Su(H);
  }
  var so = bn || Ps;
  function Iu(H) {
    if (!Ts(H))
      return !1;
    var st = Dn(H);
    return st == h || st == p || st == f || st == E;
  }
  function rh(H) {
    return typeof H == "number" && H > -1 && H % 1 == 0 && H <= a;
  }
  function Ts(H) {
    var st = typeof H;
    return H != null && (st == "object" || st == "function");
  }
  function la(H) {
    return H != null && typeof H == "object";
  }
  function sh(H) {
    if (!la(H) || Dn(H) != y)
      return !1;
    var st = kt(H);
    if (st === null)
      return !0;
    var ut = yt.call(st, "constructor") && st.constructor;
    return typeof ut == "function" && ut instanceof ut && lt.call(ut) == Jt;
  }
  var ah = z ? St(z) : Yn;
  function il(H) {
    return ki(H, es(H));
  }
  function es(H) {
    return Su(H) ? Gi(H, !0) : si(H);
  }
  var _u = Di(function(H, st, ut) {
    Tr(H, st, ut);
  });
  function oh(H) {
    return function() {
      return H;
    };
  }
  function Du(H) {
    return H;
  }
  function Ps() {
    return !1;
  }
  e.exports = _u;
})(lf, lf.exports);
var S8 = lf.exports;
const Lc = /* @__PURE__ */ qo(S8);
var I8 = 1 / 0, _8 = "[object Symbol]", D8 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, A8 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, II = "\\ud800-\\udfff", L8 = "\\u0300-\\u036f\\ufe20-\\ufe23", R8 = "\\u20d0-\\u20f0", _I = "\\u2700-\\u27bf", DI = "a-z\\xdf-\\xf6\\xf8-\\xff", w8 = "\\xac\\xb1\\xd7\\xf7", V8 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", B8 = "\\u2000-\\u206f", N8 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", AI = "A-Z\\xc0-\\xd6\\xd8-\\xde", F8 = "\\ufe0e\\ufe0f", LI = w8 + V8 + B8 + N8, dE = "['’]", DO = "[" + LI + "]", RI = "[" + L8 + R8 + "]", wI = "\\d+", j8 = "[" + _I + "]", VI = "[" + DI + "]", BI = "[^" + II + LI + wI + _I + DI + AI + "]", U8 = "\\ud83c[\\udffb-\\udfff]", W8 = "(?:" + RI + "|" + U8 + ")", $8 = "[^" + II + "]", NI = "(?:\\ud83c[\\udde6-\\uddff]){2}", FI = "[\\ud800-\\udbff][\\udc00-\\udfff]", xl = "[" + AI + "]", z8 = "\\u200d", AO = "(?:" + VI + "|" + BI + ")", K8 = "(?:" + xl + "|" + BI + ")", LO = "(?:" + dE + "(?:d|ll|m|re|s|t|ve))?", RO = "(?:" + dE + "(?:D|LL|M|RE|S|T|VE))?", jI = W8 + "?", UI = "[" + F8 + "]?", G8 = "(?:" + z8 + "(?:" + [$8, NI, FI].join("|") + ")" + UI + jI + ")*", k8 = UI + jI + G8, H8 = "(?:" + [j8, NI, FI].join("|") + ")" + k8, Y8 = RegExp(dE, "g"), X8 = RegExp(RI, "g"), Z8 = RegExp([
  xl + "?" + VI + "+" + LO + "(?=" + [DO, xl, "$"].join("|") + ")",
  K8 + "+" + RO + "(?=" + [DO, xl + AO, "$"].join("|") + ")",
  xl + "?" + AO + "+" + LO,
  xl + "+" + RO,
  wI,
  H8
].join("|"), "g"), J8 = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Q8 = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "ss"
}, q8 = typeof _t == "object" && _t && _t.Object === Object && _t, tG = typeof self == "object" && self && self.Object === Object && self, eG = q8 || tG || Function("return this")();
function nG(e, t, n, s) {
  var r = -1, i = e ? e.length : 0;
  for (s && i && (n = e[++r]); ++r < i; )
    n = t(n, e[r], r, e);
  return n;
}
function iG(e) {
  return e.match(D8) || [];
}
function rG(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var sG = rG(Q8);
function aG(e) {
  return J8.test(e);
}
function oG(e) {
  return e.match(Z8) || [];
}
var lG = Object.prototype, uG = lG.toString, wO = eG.Symbol, VO = wO ? wO.prototype : void 0, BO = VO ? VO.toString : void 0;
function cG(e) {
  if (typeof e == "string")
    return e;
  if (fG(e))
    return BO ? BO.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -I8 ? "-0" : t;
}
function hG(e) {
  return function(t) {
    return nG(gG(pG(t).replace(Y8, "")), e, "");
  };
}
function dG(e) {
  return !!e && typeof e == "object";
}
function fG(e) {
  return typeof e == "symbol" || dG(e) && uG.call(e) == _8;
}
function WI(e) {
  return e == null ? "" : cG(e);
}
function pG(e) {
  return e = WI(e), e && e.replace(A8, sG).replace(X8, "");
}
var mG = hG(function(e, t, n) {
  return e + (n ? "-" : "") + t.toLowerCase();
});
function gG(e, t, n) {
  return e = WI(e), t = n ? void 0 : t, t === void 0 ? aG(e) ? oG(e) : iG(e) : e.match(t) || [];
}
var vG = mG;
const yG = /* @__PURE__ */ qo(vG);
$t.use(SI);
const NO = {
  theme: {
    themes: {
      light: {
        primary: "#003064",
        primaryContrast: "#FFFFFF",
        secondary: "#FFFFFF",
        secondaryContrast: "#003064"
      }
    }
  },
  icons: {
    iconfont: "fa"
  }
};
function EG(e = {}) {
  var s, r;
  const t = Lc({}, NO, e);
  return Object.entries(
    (r = (s = t.theme) == null ? void 0 : s.themes) == null ? void 0 : r.light
  ).forEach(
    ([i, a]) => document.documentElement.style.setProperty(
      "--polar-" + yG(i),
      a
    )
  ), new SI(Lc({}, NO, e));
}
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function CG(e) {
  var t = Number(e.version.split(".")[0]);
  if (t >= 2)
    e.mixin({ beforeCreate: s });
  else {
    var n = e.prototype._init;
    e.prototype._init = function(r) {
      r === void 0 && (r = {}), r.init = r.init ? [s].concat(r.init) : s, n.call(this, r);
    };
  }
  function s() {
    var r = this.$options;
    r.store ? this.$store = typeof r.store == "function" ? r.store() : r.store : r.parent && r.parent.$store && (this.$store = r.parent.$store);
  }
}
var xG = typeof window < "u" ? window : typeof global < "u" ? global : {}, cl = xG.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function bG(e) {
  cl && (e._devtoolHook = cl, cl.emit("vuex:init", e), cl.on("vuex:travel-to-state", function(t) {
    e.replaceState(t);
  }), e.subscribe(function(t, n) {
    cl.emit("vuex:mutation", t, n);
  }, { prepend: !0 }), e.subscribeAction(function(t, n) {
    cl.emit("vuex:action", t, n);
  }, { prepend: !0 }));
}
function OG(e, t) {
  return e.filter(t)[0];
}
function Lv(e, t) {
  if (t === void 0 && (t = []), e === null || typeof e != "object")
    return e;
  var n = OG(t, function(r) {
    return r.original === e;
  });
  if (n)
    return n.copy;
  var s = Array.isArray(e) ? [] : {};
  return t.push({
    original: e,
    copy: s
  }), Object.keys(e).forEach(function(r) {
    s[r] = Lv(e[r], t);
  }), s;
}
function Mu(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function $I(e) {
  return e !== null && typeof e == "object";
}
function TG(e) {
  return e && typeof e.then == "function";
}
function PG(e, t) {
  return function() {
    return e(t);
  };
}
var Wr = function(t, n) {
  this.runtime = n, this._children = /* @__PURE__ */ Object.create(null), this._rawModule = t;
  var s = t.state;
  this.state = (typeof s == "function" ? s() : s) || {};
}, zI = { namespaced: { configurable: !0 } };
zI.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Wr.prototype.addChild = function(t, n) {
  this._children[t] = n;
};
Wr.prototype.removeChild = function(t) {
  delete this._children[t];
};
Wr.prototype.getChild = function(t) {
  return this._children[t];
};
Wr.prototype.hasChild = function(t) {
  return t in this._children;
};
Wr.prototype.update = function(t) {
  this._rawModule.namespaced = t.namespaced, t.actions && (this._rawModule.actions = t.actions), t.mutations && (this._rawModule.mutations = t.mutations), t.getters && (this._rawModule.getters = t.getters);
};
Wr.prototype.forEachChild = function(t) {
  Mu(this._children, t);
};
Wr.prototype.forEachGetter = function(t) {
  this._rawModule.getters && Mu(this._rawModule.getters, t);
};
Wr.prototype.forEachAction = function(t) {
  this._rawModule.actions && Mu(this._rawModule.actions, t);
};
Wr.prototype.forEachMutation = function(t) {
  this._rawModule.mutations && Mu(this._rawModule.mutations, t);
};
Object.defineProperties(Wr.prototype, zI);
var nl = function(t) {
  this.register([], t, !1);
};
nl.prototype.get = function(t) {
  return t.reduce(function(n, s) {
    return n.getChild(s);
  }, this.root);
};
nl.prototype.getNamespace = function(t) {
  var n = this.root;
  return t.reduce(function(s, r) {
    return n = n.getChild(r), s + (n.namespaced ? r + "/" : "");
  }, "");
};
nl.prototype.update = function(t) {
  KI([], this.root, t);
};
nl.prototype.register = function(t, n, s) {
  var r = this;
  s === void 0 && (s = !0);
  var i = new Wr(n, s);
  if (t.length === 0)
    this.root = i;
  else {
    var a = this.get(t.slice(0, -1));
    a.addChild(t[t.length - 1], i);
  }
  n.modules && Mu(n.modules, function(o, l) {
    r.register(t.concat(l), o, s);
  });
};
nl.prototype.unregister = function(t) {
  var n = this.get(t.slice(0, -1)), s = t[t.length - 1], r = n.getChild(s);
  r && r.runtime && n.removeChild(s);
};
nl.prototype.isRegistered = function(t) {
  var n = this.get(t.slice(0, -1)), s = t[t.length - 1];
  return n ? n.hasChild(s) : !1;
};
function KI(e, t, n) {
  if (t.update(n), n.modules)
    for (var s in n.modules) {
      if (!t.getChild(s))
        return;
      KI(
        e.concat(s),
        t.getChild(s),
        n.modules[s]
      );
    }
}
var wi, Ki = function(t) {
  var n = this;
  t === void 0 && (t = {}), !wi && typeof window < "u" && window.Vue && HI(window.Vue);
  var s = t.plugins;
  s === void 0 && (s = []);
  var r = t.strict;
  r === void 0 && (r = !1), this._committing = !1, this._actions = /* @__PURE__ */ Object.create(null), this._actionSubscribers = [], this._mutations = /* @__PURE__ */ Object.create(null), this._wrappedGetters = /* @__PURE__ */ Object.create(null), this._modules = new nl(t), this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null), this._subscribers = [], this._watcherVM = new wi(), this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var i = this, a = this, o = a.dispatch, l = a.commit;
  this.dispatch = function(c, h) {
    return o.call(i, c, h);
  }, this.commit = function(c, h, p) {
    return l.call(i, c, h, p);
  }, this.strict = r;
  var f = this._modules.root.state;
  ep(this, f, [], this._modules.root), pE(this, f), s.forEach(function(u) {
    return u(n);
  });
  var d = t.devtools !== void 0 ? t.devtools : wi.config.devtools;
  d && bG(this);
}, fE = { state: { configurable: !0 } };
fE.state.get = function() {
  return this._vm._data.$$state;
};
fE.state.set = function(e) {
};
Ki.prototype.commit = function(t, n, s) {
  var r = this, i = uf(t, n, s), a = i.type, o = i.payload, l = { type: a, payload: o }, f = this._mutations[a];
  f && (this._withCommit(function() {
    f.forEach(function(u) {
      u(o);
    });
  }), this._subscribers.slice().forEach(function(d) {
    return d(l, r.state);
  }));
};
Ki.prototype.dispatch = function(t, n) {
  var s = this, r = uf(t, n), i = r.type, a = r.payload, o = { type: i, payload: a }, l = this._actions[i];
  if (l) {
    try {
      this._actionSubscribers.slice().filter(function(d) {
        return d.before;
      }).forEach(function(d) {
        return d.before(o, s.state);
      });
    } catch {
    }
    var f = l.length > 1 ? Promise.all(l.map(function(d) {
      return d(a);
    })) : l[0](a);
    return new Promise(function(d, u) {
      f.then(function(c) {
        try {
          s._actionSubscribers.filter(function(h) {
            return h.after;
          }).forEach(function(h) {
            return h.after(o, s.state);
          });
        } catch {
        }
        d(c);
      }, function(c) {
        try {
          s._actionSubscribers.filter(function(h) {
            return h.error;
          }).forEach(function(h) {
            return h.error(o, s.state, c);
          });
        } catch {
        }
        u(c);
      });
    });
  }
};
Ki.prototype.subscribe = function(t, n) {
  return GI(t, this._subscribers, n);
};
Ki.prototype.subscribeAction = function(t, n) {
  var s = typeof t == "function" ? { before: t } : t;
  return GI(s, this._actionSubscribers, n);
};
Ki.prototype.watch = function(t, n, s) {
  var r = this;
  return this._watcherVM.$watch(function() {
    return t(r.state, r.getters);
  }, n, s);
};
Ki.prototype.replaceState = function(t) {
  var n = this;
  this._withCommit(function() {
    n._vm._data.$$state = t;
  });
};
Ki.prototype.registerModule = function(t, n, s) {
  s === void 0 && (s = {}), typeof t == "string" && (t = [t]), this._modules.register(t, n), ep(this, this.state, t, this._modules.get(t), s.preserveState), pE(this, this.state);
};
Ki.prototype.unregisterModule = function(t) {
  var n = this;
  typeof t == "string" && (t = [t]), this._modules.unregister(t), this._withCommit(function() {
    var s = mE(n.state, t.slice(0, -1));
    wi.delete(s, t[t.length - 1]);
  }), kI(this);
};
Ki.prototype.hasModule = function(t) {
  return typeof t == "string" && (t = [t]), this._modules.isRegistered(t);
};
Ki.prototype.hotUpdate = function(t) {
  this._modules.update(t), kI(this, !0);
};
Ki.prototype._withCommit = function(t) {
  var n = this._committing;
  this._committing = !0, t(), this._committing = n;
};
Object.defineProperties(Ki.prototype, fE);
function GI(e, t, n) {
  return t.indexOf(e) < 0 && (n && n.prepend ? t.unshift(e) : t.push(e)), function() {
    var s = t.indexOf(e);
    s > -1 && t.splice(s, 1);
  };
}
function kI(e, t) {
  e._actions = /* @__PURE__ */ Object.create(null), e._mutations = /* @__PURE__ */ Object.create(null), e._wrappedGetters = /* @__PURE__ */ Object.create(null), e._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var n = e.state;
  ep(e, n, [], e._modules.root, !0), pE(e, n, t);
}
function pE(e, t, n) {
  var s = e._vm;
  e.getters = {}, e._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var r = e._wrappedGetters, i = {};
  Mu(r, function(o, l) {
    i[l] = PG(o, e), Object.defineProperty(e.getters, l, {
      get: function() {
        return e._vm[l];
      },
      enumerable: !0
      // for local getters
    });
  });
  var a = wi.config.silent;
  wi.config.silent = !0, e._vm = new wi({
    data: {
      $$state: t
    },
    computed: i
  }), wi.config.silent = a, e.strict && AG(e), s && (n && e._withCommit(function() {
    s._data.$$state = null;
  }), wi.nextTick(function() {
    return s.$destroy();
  }));
}
function ep(e, t, n, s, r) {
  var i = !n.length, a = e._modules.getNamespace(n);
  if (s.namespaced && (e._modulesNamespaceMap[a], e._modulesNamespaceMap[a] = s), !i && !r) {
    var o = mE(t, n.slice(0, -1)), l = n[n.length - 1];
    e._withCommit(function() {
      wi.set(o, l, s.state);
    });
  }
  var f = s.context = MG(e, a, n);
  s.forEachMutation(function(d, u) {
    var c = a + u;
    IG(e, c, d, f);
  }), s.forEachAction(function(d, u) {
    var c = d.root ? u : a + u, h = d.handler || d;
    _G(e, c, h, f);
  }), s.forEachGetter(function(d, u) {
    var c = a + u;
    DG(e, c, d, f);
  }), s.forEachChild(function(d, u) {
    ep(e, t, n.concat(u), d, r);
  });
}
function MG(e, t, n) {
  var s = t === "", r = {
    dispatch: s ? e.dispatch : function(i, a, o) {
      var l = uf(i, a, o), f = l.payload, d = l.options, u = l.type;
      return (!d || !d.root) && (u = t + u), e.dispatch(u, f);
    },
    commit: s ? e.commit : function(i, a, o) {
      var l = uf(i, a, o), f = l.payload, d = l.options, u = l.type;
      (!d || !d.root) && (u = t + u), e.commit(u, f, d);
    }
  };
  return Object.defineProperties(r, {
    getters: {
      get: s ? function() {
        return e.getters;
      } : function() {
        return SG(e, t);
      }
    },
    state: {
      get: function() {
        return mE(e.state, n);
      }
    }
  }), r;
}
function SG(e, t) {
  if (!e._makeLocalGettersCache[t]) {
    var n = {}, s = t.length;
    Object.keys(e.getters).forEach(function(r) {
      if (r.slice(0, s) === t) {
        var i = r.slice(s);
        Object.defineProperty(n, i, {
          get: function() {
            return e.getters[r];
          },
          enumerable: !0
        });
      }
    }), e._makeLocalGettersCache[t] = n;
  }
  return e._makeLocalGettersCache[t];
}
function IG(e, t, n, s) {
  var r = e._mutations[t] || (e._mutations[t] = []);
  r.push(function(a) {
    n.call(e, s.state, a);
  });
}
function _G(e, t, n, s) {
  var r = e._actions[t] || (e._actions[t] = []);
  r.push(function(a) {
    var o = n.call(e, {
      dispatch: s.dispatch,
      commit: s.commit,
      getters: s.getters,
      state: s.state,
      rootGetters: e.getters,
      rootState: e.state
    }, a);
    return TG(o) || (o = Promise.resolve(o)), e._devtoolHook ? o.catch(function(l) {
      throw e._devtoolHook.emit("vuex:error", l), l;
    }) : o;
  });
}
function DG(e, t, n, s) {
  e._wrappedGetters[t] || (e._wrappedGetters[t] = function(i) {
    return n(
      s.state,
      // local state
      s.getters,
      // local getters
      i.state,
      // root state
      i.getters
      // root getters
    );
  });
}
function AG(e) {
  e._vm.$watch(function() {
    return this._data.$$state;
  }, function() {
  }, { deep: !0, sync: !0 });
}
function mE(e, t) {
  return t.reduce(function(n, s) {
    return n[s];
  }, e);
}
function uf(e, t, n) {
  return $I(e) && e.type && (n = t, t = e, e = e.type), { type: e, payload: t, options: n };
}
function HI(e) {
  wi && e === wi || (wi = e, CG(wi));
}
var YI = ip(function(e, t) {
  var n = {};
  return np(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      var o = this.$store.state, l = this.$store.getters;
      if (e) {
        var f = rp(this.$store, "mapState", e);
        if (!f)
          return;
        o = f.context.state, l = f.context.getters;
      }
      return typeof i == "function" ? i.call(this, o, l) : o[i];
    }, n[r].vuex = !0;
  }), n;
}), $r = ip(function(e, t) {
  var n = {};
  return np(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      for (var o = [], l = arguments.length; l--; )
        o[l] = arguments[l];
      var f = this.$store.commit;
      if (e) {
        var d = rp(this.$store, "mapMutations", e);
        if (!d)
          return;
        f = d.context.commit;
      }
      return typeof i == "function" ? i.apply(this, [f].concat(o)) : f.apply(this.$store, [i].concat(o));
    };
  }), n;
}), Ee = ip(function(e, t) {
  var n = {};
  return np(t).forEach(function(s) {
    var r = s.key, i = s.val;
    i = e + i, n[r] = function() {
      if (!(e && !rp(this.$store, "mapGetters", e)))
        return this.$store.getters[i];
    }, n[r].vuex = !0;
  }), n;
}), br = ip(function(e, t) {
  var n = {};
  return np(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      for (var o = [], l = arguments.length; l--; )
        o[l] = arguments[l];
      var f = this.$store.dispatch;
      if (e) {
        var d = rp(this.$store, "mapActions", e);
        if (!d)
          return;
        f = d.context.dispatch;
      }
      return typeof i == "function" ? i.apply(this, [f].concat(o)) : f.apply(this.$store, [i].concat(o));
    };
  }), n;
}), LG = function(e) {
  return {
    mapState: YI.bind(null, e),
    mapGetters: Ee.bind(null, e),
    mapMutations: $r.bind(null, e),
    mapActions: br.bind(null, e)
  };
};
function np(e) {
  return RG(e) ? Array.isArray(e) ? e.map(function(t) {
    return { key: t, val: t };
  }) : Object.keys(e).map(function(t) {
    return { key: t, val: e[t] };
  }) : [];
}
function RG(e) {
  return Array.isArray(e) || $I(e);
}
function ip(e) {
  return function(t, n) {
    return typeof t != "string" ? (n = t, t = "") : t.charAt(t.length - 1) !== "/" && (t += "/"), e(t, n);
  };
}
function rp(e, t, n) {
  var s = e._modulesNamespaceMap[n];
  return s;
}
function wG(e) {
  e === void 0 && (e = {});
  var t = e.collapsed;
  t === void 0 && (t = !0);
  var n = e.filter;
  n === void 0 && (n = function(d, u, c) {
    return !0;
  });
  var s = e.transformer;
  s === void 0 && (s = function(d) {
    return d;
  });
  var r = e.mutationTransformer;
  r === void 0 && (r = function(d) {
    return d;
  });
  var i = e.actionFilter;
  i === void 0 && (i = function(d, u) {
    return !0;
  });
  var a = e.actionTransformer;
  a === void 0 && (a = function(d) {
    return d;
  });
  var o = e.logMutations;
  o === void 0 && (o = !0);
  var l = e.logActions;
  l === void 0 && (l = !0);
  var f = e.logger;
  return f === void 0 && (f = console), function(d) {
    var u = Lv(d.state);
    typeof f > "u" || (o && d.subscribe(function(c, h) {
      var p = Lv(h);
      if (n(c, u, p)) {
        var g = UO(), m = r(c), v = "mutation " + c.type + g;
        FO(f, v, t), f.log("%c prev state", "color: #9E9E9E; font-weight: bold", s(u)), f.log("%c mutation", "color: #03A9F4; font-weight: bold", m), f.log("%c next state", "color: #4CAF50; font-weight: bold", s(p)), jO(f);
      }
      u = p;
    }), l && d.subscribeAction(function(c, h) {
      if (i(c, h)) {
        var p = UO(), g = a(c), m = "action " + c.type + p;
        FO(f, m, t), f.log("%c action", "color: #03A9F4; font-weight: bold", g), jO(f);
      }
    }));
  };
}
function FO(e, t, n) {
  var s = n ? e.groupCollapsed : e.group;
  try {
    s.call(e, t);
  } catch {
    e.log(t);
  }
}
function jO(e) {
  try {
    e.groupEnd();
  } catch {
    e.log("—— log end ——");
  }
}
function UO() {
  var e = /* @__PURE__ */ new Date();
  return " @ " + zh(e.getHours(), 2) + ":" + zh(e.getMinutes(), 2) + ":" + zh(e.getSeconds(), 2) + "." + zh(e.getMilliseconds(), 3);
}
function VG(e, t) {
  return new Array(t + 1).join(e);
}
function zh(e, t) {
  return VG("0", t - e.toString().length) + e;
}
var BG = {
  Store: Ki,
  install: HI,
  version: "3.6.2",
  mapState: YI,
  mapMutations: $r,
  mapGetters: Ee,
  mapActions: br,
  createNamespacedHelpers: LG,
  createLogger: wG
};
const NG = BG;
function FG(e) {
  return `set${e[0].toUpperCase()}${e.slice(1)}`;
}
function zr(e) {
  return Object.keys(e).reduce((t, n) => ({
    ...t,
    [FG(n)]: (s, r) => {
      s[n] = r;
    }
  }), {});
}
function rr(e) {
  return Object.keys(e).reduce((t, n) => ({
    ...t,
    [n]: (s) => s[n]
  }), {});
}
const WO = () => {
};
function Nr(e) {
  "@babel/helpers - typeof";
  return Nr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nr(e);
}
function Kr(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jG(e, t) {
  if (Nr(e) !== "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var s = n.call(e, t || "default");
    if (Nr(s) !== "object")
      return s;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XI(e) {
  var t = jG(e, "string");
  return Nr(t) === "symbol" ? t : String(t);
}
function $O(e, t) {
  for (var n = 0; n < t.length; n++) {
    var s = t[n];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, XI(s.key), s);
  }
}
function Gr(e, t, n) {
  return t && $O(e.prototype, t), n && $O(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Ba(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Rv(e, t) {
  return Rv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, r) {
    return s.__proto__ = r, s;
  }, Rv(e, t);
}
function sp(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Rv(e, t);
}
function nh(e, t) {
  if (t && (Nr(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ba(e);
}
function ys(e) {
  return ys = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, ys(e);
}
function ro(e, t, n) {
  return t = XI(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function UG(e) {
  if (Array.isArray(e))
    return e;
}
function WG(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function zO(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, s = new Array(t); n < t; n++)
    s[n] = e[n];
  return s;
}
function $G(e, t) {
  if (e) {
    if (typeof e == "string")
      return zO(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return zO(e, t);
  }
}
function zG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function KG(e) {
  return UG(e) || WG(e) || $G(e) || zG();
}
function KO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function GO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KO(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
var GG = {
  type: "logger",
  log: function(t) {
    this.output("log", t);
  },
  warn: function(t) {
    this.output("warn", t);
  },
  error: function(t) {
    this.output("error", t);
  },
  output: function(t, n) {
    console && console[t] && console[t].apply(console, n);
  }
}, kG = function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Kr(this, e), this.init(t, n);
  }
  return Gr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = s.prefix || "i18next:", this.logger = n || GG, this.options = s, this.debug = s.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, s, r, i) {
      return i && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(r).concat(this.prefix, " ").concat(n[0])), this.logger[s](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new e(this.logger, GO(GO({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new e(this.logger, n);
    }
  }]), e;
}(), cs = new kG(), eo = function() {
  function e() {
    Kr(this, e), this.observers = {};
  }
  return Gr(e, [{
    key: "on",
    value: function(n, s) {
      var r = this;
      return n.split(" ").forEach(function(i) {
        r.observers[i] = r.observers[i] || [], r.observers[i].push(s);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, s) {
      if (this.observers[n]) {
        if (!s) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(r) {
          return r !== s;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
        r[i - 1] = arguments[i];
      if (this.observers[n]) {
        var a = [].concat(this.observers[n]);
        a.forEach(function(l) {
          l.apply(void 0, r);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(l) {
          l.apply(l, [n].concat(r));
        });
      }
    }
  }]), e;
}();
function Wu() {
  var e, t, n = new Promise(function(s, r) {
    e = s, t = r;
  });
  return n.resolve = e, n.reject = t, n;
}
function kO(e) {
  return e == null ? "" : "" + e;
}
function HG(e, t, n) {
  e.forEach(function(s) {
    t[s] && (n[s] = t[s]);
  });
}
function gE(e, t, n) {
  function s(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function r() {
    return !e || typeof e == "string";
  }
  for (var i = typeof t != "string" ? [].concat(t) : t.split("."); i.length > 1; ) {
    if (r())
      return {};
    var a = s(i.shift());
    !e[a] && n && (e[a] = new n()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {};
  }
  return r() ? {} : {
    obj: e,
    k: s(i.shift())
  };
}
function HO(e, t, n) {
  var s = gE(e, t, Object), r = s.obj, i = s.k;
  r[i] = n;
}
function YG(e, t, n, s) {
  var r = gE(e, t, Object), i = r.obj, a = r.k;
  i[a] = i[a] || [], s && (i[a] = i[a].concat(n)), s || i[a].push(n);
}
function cf(e, t) {
  var n = gE(e, t), s = n.obj, r = n.k;
  if (s)
    return s[r];
}
function YO(e, t, n) {
  var s = cf(e, n);
  return s !== void 0 ? s : cf(t, n);
}
function ZI(e, t, n) {
  for (var s in t)
    s !== "__proto__" && s !== "constructor" && (s in e ? typeof e[s] == "string" || e[s] instanceof String || typeof t[s] == "string" || t[s] instanceof String ? n && (e[s] = t[s]) : ZI(e[s], t[s], n) : e[s] = t[s]);
  return e;
}
function hl(e) {
  return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var XG = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function ZG(e) {
  return typeof e == "string" ? e.replace(/[&<>"'\/]/g, function(t) {
    return XG[t];
  }) : e;
}
var ap = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, JG = [" ", ",", "?", "!", ";"];
function QG(e, t, n) {
  t = t || "", n = n || "";
  var s = JG.filter(function(o) {
    return t.indexOf(o) < 0 && n.indexOf(o) < 0;
  });
  if (s.length === 0)
    return !0;
  var r = new RegExp("(".concat(s.map(function(o) {
    return o === "?" ? "\\?" : o;
  }).join("|"), ")")), i = !r.test(e);
  if (!i) {
    var a = e.indexOf(n);
    a > 0 && !r.test(e.substring(0, a)) && (i = !0);
  }
  return i;
}
function XO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Kh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XO(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function qG(e) {
  var t = tk();
  return function() {
    var s = ys(e), r;
    if (t) {
      var i = ys(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return nh(this, r);
  };
}
function tk() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function JI(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (e) {
    if (e[t])
      return e[t];
    for (var s = t.split(n), r = e, i = 0; i < s.length; ++i) {
      if (!r || typeof r[s[i]] == "string" && i + 1 < s.length)
        return;
      if (r[s[i]] === void 0) {
        for (var a = 2, o = s.slice(i, i + a).join(n), l = r[o]; l === void 0 && s.length > i + a; )
          a++, o = s.slice(i, i + a).join(n), l = r[o];
        if (l === void 0)
          return;
        if (l === null)
          return null;
        if (t.endsWith(o)) {
          if (typeof l == "string")
            return l;
          if (o && typeof l[o] == "string")
            return l[o];
        }
        var f = s.slice(i + a).join(n);
        return f ? JI(l, f, n) : void 0;
      }
      r = r[s[i]];
    }
    return r;
  }
}
var ek = function(e) {
  sp(n, e);
  var t = qG(n);
  function n(s) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return Kr(this, n), r = t.call(this), ap && eo.call(Ba(r)), r.data = s || {}, r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.options.ignoreJSONStructure === void 0 && (r.options.ignoreJSONStructure = !0), r;
  }
  return Gr(n, [{
    key: "addNamespaces",
    value: function(r) {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }
  }, {
    key: "removeNamespaces",
    value: function(r) {
      var i = this.options.ns.indexOf(r);
      i > -1 && this.options.ns.splice(i, 1);
    }
  }, {
    key: "getResource",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, l = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator, f = o.ignoreJSONStructure !== void 0 ? o.ignoreJSONStructure : this.options.ignoreJSONStructure, d = [r, i];
      a && typeof a != "string" && (d = d.concat(a)), a && typeof a == "string" && (d = d.concat(l ? a.split(l) : a)), r.indexOf(".") > -1 && (d = r.split("."));
      var u = cf(this.data, d);
      return u || !f || typeof a != "string" ? u : JI(this.data && this.data[r] && this.data[r][i], a, l);
    }
  }, {
    key: "addResource",
    value: function(r, i, a, o) {
      var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, f = this.options.keySeparator;
      f === void 0 && (f = ".");
      var d = [r, i];
      a && (d = d.concat(f ? a.split(f) : a)), r.indexOf(".") > -1 && (d = r.split("."), o = i, i = d[1]), this.addNamespaces(i), HO(this.data, d, o), l.silent || this.emit("added", r, i, a, o);
    }
  }, {
    key: "addResources",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var l in a)
        (typeof a[l] == "string" || Object.prototype.toString.apply(a[l]) === "[object Array]") && this.addResource(r, i, l, a[l], {
          silent: !0
        });
      o.silent || this.emit("added", r, i, a);
    }
  }, {
    key: "addResourceBundle",
    value: function(r, i, a, o, l) {
      var f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, d = [r, i];
      r.indexOf(".") > -1 && (d = r.split("."), o = a, a = i, i = d[1]), this.addNamespaces(i);
      var u = cf(this.data, d) || {};
      o ? ZI(u, a, l) : u = Kh(Kh({}, u), a), HO(this.data, d, u), f.silent || this.emit("added", r, i, a);
    }
  }, {
    key: "removeResourceBundle",
    value: function(r, i) {
      this.hasResourceBundle(r, i) && delete this.data[r][i], this.removeNamespaces(i), this.emit("removed", r, i);
    }
  }, {
    key: "hasResourceBundle",
    value: function(r, i) {
      return this.getResource(r, i) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(r, i) {
      return i || (i = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Kh(Kh({}, {}), this.getResource(r, i)) : this.getResource(r, i);
    }
  }, {
    key: "getDataByLanguage",
    value: function(r) {
      return this.data[r];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(r) {
      var i = this.getDataByLanguage(r), a = i && Object.keys(i) || [];
      return !!a.find(function(o) {
        return i[o] && Object.keys(i[o]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(eo), QI = {
  processors: {},
  addPostProcessor: function(t) {
    this.processors[t.name] = t;
  },
  handle: function(t, n, s, r, i) {
    var a = this;
    return t.forEach(function(o) {
      a.processors[o] && (n = a.processors[o].process(n, s, r, i));
    }), n;
  }
};
function ZO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function bi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZO(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function nk(e) {
  var t = ik();
  return function() {
    var s = ys(e), r;
    if (t) {
      var i = ys(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return nh(this, r);
  };
}
function ik() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var JO = {}, QO = function(e) {
  sp(n, e);
  var t = nk(n);
  function n(s) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Kr(this, n), r = t.call(this), ap && eo.call(Ba(r)), HG(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], s, Ba(r)), r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.logger = cs.create("translator"), r;
  }
  return Gr(n, [{
    key: "changeLanguage",
    value: function(r) {
      r && (this.language = r);
    }
  }, {
    key: "exists",
    value: function(r) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (r == null)
        return !1;
      var a = this.resolve(r, i);
      return a && a.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(r, i) {
      var a = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator;
      a === void 0 && (a = ":");
      var o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, l = i.ns || this.options.defaultNS || [], f = a && r.indexOf(a) > -1, d = !this.options.userDefinedKeySeparator && !i.keySeparator && !this.options.userDefinedNsSeparator && !i.nsSeparator && !QG(r, a, o);
      if (f && !d) {
        var u = r.match(this.interpolator.nestingRegexp);
        if (u && u.length > 0)
          return {
            key: r,
            namespaces: l
          };
        var c = r.split(a);
        (a !== o || a === o && this.options.ns.indexOf(c[0]) > -1) && (l = c.shift()), r = c.join(o);
      }
      return typeof l == "string" && (l = [l]), {
        key: r,
        namespaces: l
      };
    }
  }, {
    key: "translate",
    value: function(r, i, a) {
      var o = this;
      if (Nr(i) !== "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), i || (i = {}), r == null)
        return "";
      Array.isArray(r) || (r = [String(r)]);
      var l = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, f = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, d = this.extractFromKey(r[r.length - 1], i), u = d.key, c = d.namespaces, h = c[c.length - 1], p = i.lng || this.language, g = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (p && p.toLowerCase() === "cimode") {
        if (g) {
          var m = i.nsSeparator || this.options.nsSeparator;
          return l ? (v.res = "".concat(h).concat(m).concat(u), v) : "".concat(h).concat(m).concat(u);
        }
        return l ? (v.res = u, v) : u;
      }
      var v = this.resolve(r, i), y = v && v.res, E = v && v.usedKey || u, C = v && v.exactUsedKey || u, x = Object.prototype.toString.apply(y), b = ["[object Number]", "[object Function]", "[object RegExp]"], P = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, T = !this.i18nFormat || this.i18nFormat.handleAsObject, O = typeof y != "string" && typeof y != "boolean" && typeof y != "number";
      if (T && y && O && b.indexOf(x) < 0 && !(typeof P == "string" && x === "[object Array]")) {
        if (!i.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var S = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(E, y, bi(bi({}, i), {}, {
            ns: c
          })) : "key '".concat(u, " (").concat(this.language, ")' returned an object instead of string.");
          return l ? (v.res = S, v) : S;
        }
        if (f) {
          var L = x === "[object Array]", A = L ? [] : {}, D = L ? C : E;
          for (var _ in y)
            if (Object.prototype.hasOwnProperty.call(y, _)) {
              var w = "".concat(D).concat(f).concat(_);
              A[_] = this.translate(w, bi(bi({}, i), {
                joinArrays: !1,
                ns: c
              })), A[_] === w && (A[_] = y[_]);
            }
          y = A;
        }
      } else if (T && typeof P == "string" && x === "[object Array]")
        y = y.join(P), y && (y = this.extendTranslation(y, r, i, a));
      else {
        var B = !1, j = !1, k = i.count !== void 0 && typeof i.count != "string", X = n.hasDefaultValue(i), rt = k ? this.pluralResolver.getSuffix(p, i.count, i) : "", et = i["defaultValue".concat(rt)] || i.defaultValue;
        !this.isValidLookup(y) && X && (B = !0, y = et), this.isValidLookup(y) || (j = !0, y = u);
        var Z = i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, dt = Z && j ? void 0 : y, vt = X && et !== y && this.options.updateMissing;
        if (j || B || vt) {
          if (this.logger.log(vt ? "updateKey" : "missingKey", p, h, u, vt ? et : y), f) {
            var bt = this.resolve(u, bi(bi({}, i), {}, {
              keySeparator: !1
            }));
            bt && bt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var it = [], R = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && R && R[0])
            for (var V = 0; V < R.length; V++)
              it.push(R[V]);
          else
            this.options.saveMissingTo === "all" ? it = this.languageUtils.toResolveHierarchy(i.lng || this.language) : it.push(i.lng || this.language);
          var tt = function($, z, at) {
            var ct = X && at !== y ? at : dt;
            o.options.missingKeyHandler ? o.options.missingKeyHandler($, h, z, ct, vt, i) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing($, h, z, ct, vt, i), o.emit("missingKey", $, h, z, y);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && k ? it.forEach(function(Y) {
            o.pluralResolver.getSuffixes(Y, i).forEach(function($) {
              tt([Y], u + $, i["defaultValue".concat($)] || et);
            });
          }) : tt(it, u, et));
        }
        y = this.extendTranslation(y, r, i, v, a), j && y === u && this.options.appendNamespaceToMissingKey && (y = "".concat(h, ":").concat(u)), (j || B) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? y = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(h, ":").concat(u) : u, B ? y : void 0) : y = this.options.parseMissingKeyHandler(y));
      }
      return l ? (v.res = y, v) : y;
    }
  }, {
    key: "extendTranslation",
    value: function(r, i, a, o, l) {
      var f = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        r = this.i18nFormat.parse(r, bi(bi({}, this.options.interpolation.defaultVariables), a), o.usedLng, o.usedNS, o.usedKey, {
          resolved: o
        });
      else if (!a.skipInterpolation) {
        a.interpolation && this.interpolator.init(bi(bi({}, a), {
          interpolation: bi(bi({}, this.options.interpolation), a.interpolation)
        }));
        var d = typeof r == "string" && (a && a.interpolation && a.interpolation.skipOnVariables !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), u;
        if (d) {
          var c = r.match(this.interpolator.nestingRegexp);
          u = c && c.length;
        }
        var h = a.replace && typeof a.replace != "string" ? a.replace : a;
        if (this.options.interpolation.defaultVariables && (h = bi(bi({}, this.options.interpolation.defaultVariables), h)), r = this.interpolator.interpolate(r, h, a.lng || this.language, a), d) {
          var p = r.match(this.interpolator.nestingRegexp), g = p && p.length;
          u < g && (a.nest = !1);
        }
        a.nest !== !1 && (r = this.interpolator.nest(r, function() {
          for (var y = arguments.length, E = new Array(y), C = 0; C < y; C++)
            E[C] = arguments[C];
          return l && l[0] === E[0] && !a.context ? (f.logger.warn("It seems you are nesting recursively key: ".concat(E[0], " in key: ").concat(i[0])), null) : f.translate.apply(f, E.concat([i]));
        }, a)), a.interpolation && this.interpolator.reset();
      }
      var m = a.postProcess || this.options.postProcess, v = typeof m == "string" ? [m] : m;
      return r != null && v && v.length && a.applyPostProcessor !== !1 && (r = QI.handle(v, r, i, this.options && this.options.postProcessPassResolved ? bi({
        i18nResolved: o
      }, a) : a, this)), r;
    }
  }, {
    key: "resolve",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o, l, f, d, u;
      return typeof r == "string" && (r = [r]), r.forEach(function(c) {
        if (!i.isValidLookup(o)) {
          var h = i.extractFromKey(c, a), p = h.key;
          l = p;
          var g = h.namespaces;
          i.options.fallbackNS && (g = g.concat(i.options.fallbackNS));
          var m = a.count !== void 0 && typeof a.count != "string", v = m && !a.ordinal && a.count === 0 && i.pluralResolver.shouldUseIntlApi(), y = a.context !== void 0 && (typeof a.context == "string" || typeof a.context == "number") && a.context !== "", E = a.lngs ? a.lngs : i.languageUtils.toResolveHierarchy(a.lng || i.language, a.fallbackLng);
          g.forEach(function(C) {
            i.isValidLookup(o) || (u = C, !JO["".concat(E[0], "-").concat(C)] && i.utils && i.utils.hasLoadedNamespace && !i.utils.hasLoadedNamespace(u) && (JO["".concat(E[0], "-").concat(C)] = !0, i.logger.warn('key "'.concat(l, '" for languages "').concat(E.join(", "), `" won't get resolved as namespace "`).concat(u, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), E.forEach(function(x) {
              if (!i.isValidLookup(o)) {
                d = x;
                var b = [p];
                if (i.i18nFormat && i.i18nFormat.addLookupKeys)
                  i.i18nFormat.addLookupKeys(b, p, x, C, a);
                else {
                  var P;
                  m && (P = i.pluralResolver.getSuffix(x, a.count, a));
                  var T = "".concat(i.options.pluralSeparator, "zero");
                  if (m && (b.push(p + P), v && b.push(p + T)), y) {
                    var O = "".concat(p).concat(i.options.contextSeparator).concat(a.context);
                    b.push(O), m && (b.push(O + P), v && b.push(O + T));
                  }
                }
                for (var S; S = b.pop(); )
                  i.isValidLookup(o) || (f = S, o = i.getResource(x, C, S, a));
              }
            }));
          });
        }
      }), {
        res: o,
        usedKey: l,
        exactUsedKey: f,
        usedLng: d,
        usedNS: u
      };
    }
  }, {
    key: "isValidLookup",
    value: function(r) {
      return r !== void 0 && !(!this.options.returnNull && r === null) && !(!this.options.returnEmptyString && r === "");
    }
  }, {
    key: "getResource",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(r, i, a, o) : this.resourceStore.getResource(r, i, a, o);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(r) {
      var i = "defaultValue";
      for (var a in r)
        if (Object.prototype.hasOwnProperty.call(r, a) && i === a.substring(0, i.length) && r[a] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(eo);
function Xm(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var rk = function() {
  function e(t) {
    Kr(this, e), this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = cs.create("languageUtils");
  }
  return Gr(e, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var s = n.split("-");
      return s.length === 2 || (s.pop(), s[s.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(s.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var s = n.split("-");
      return this.formatLanguageCode(s[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var s = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], r = n.split("-");
        return this.options.lowerCaseLng ? r = r.map(function(i) {
          return i.toLowerCase();
        }) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), s.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Xm(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), s.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Xm(r[1].toLowerCase())), s.indexOf(r[2].toLowerCase()) > -1 && (r[2] = Xm(r[2].toLowerCase()))), r.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var s = this;
      if (!n)
        return null;
      var r;
      return n.forEach(function(i) {
        if (!r) {
          var a = s.formatLanguageCode(i);
          (!s.options.supportedLngs || s.isSupportedCode(a)) && (r = a);
        }
      }), !r && this.options.supportedLngs && n.forEach(function(i) {
        if (!r) {
          var a = s.getLanguagePartFromCode(i);
          if (s.isSupportedCode(a))
            return r = a;
          r = s.options.supportedLngs.find(function(o) {
            if (o.indexOf(a) === 0)
              return o;
          });
        }
      }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, s) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(s)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!s)
        return n.default || [];
      var r = n[s];
      return r || (r = n[this.getScriptPartFromCode(s)]), r || (r = n[this.formatLanguageCode(s)]), r || (r = n[this.getLanguagePartFromCode(s)]), r || (r = n.default), r || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, s) {
      var r = this, i = this.getFallbackCodes(s || this.options.fallbackLng || [], n), a = [], o = function(f) {
        f && (r.isSupportedCode(f) ? a.push(f) : r.logger.warn("rejecting language code not found in supportedLngs: ".concat(f)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(n))) : typeof n == "string" && o(this.formatLanguageCode(n)), i.forEach(function(l) {
        a.indexOf(l) < 0 && o(r.formatLanguageCode(l));
      }), a;
    }
  }]), e;
}(), sk = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], ak = {
  1: function(t) {
    return +(t > 1);
  },
  2: function(t) {
    return +(t != 1);
  },
  3: function(t) {
    return 0;
  },
  4: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  5: function(t) {
    return t == 0 ? 0 : t == 1 ? 1 : t == 2 ? 2 : t % 100 >= 3 && t % 100 <= 10 ? 3 : t % 100 >= 11 ? 4 : 5;
  },
  6: function(t) {
    return t == 1 ? 0 : t >= 2 && t <= 4 ? 1 : 2;
  },
  7: function(t) {
    return t == 1 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  8: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t != 8 && t != 11 ? 2 : 3;
  },
  9: function(t) {
    return +(t >= 2);
  },
  10: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t < 7 ? 2 : t < 11 ? 3 : 4;
  },
  11: function(t) {
    return t == 1 || t == 11 ? 0 : t == 2 || t == 12 ? 1 : t > 2 && t < 20 ? 2 : 3;
  },
  12: function(t) {
    return +(t % 10 != 1 || t % 100 == 11);
  },
  13: function(t) {
    return +(t !== 0);
  },
  14: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t == 3 ? 2 : 3;
  },
  15: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  16: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t !== 0 ? 1 : 2;
  },
  17: function(t) {
    return t == 1 || t % 10 == 1 && t % 100 != 11 ? 0 : 1;
  },
  18: function(t) {
    return t == 0 ? 0 : t == 1 ? 1 : 2;
  },
  19: function(t) {
    return t == 1 ? 0 : t == 0 || t % 100 > 1 && t % 100 < 11 ? 1 : t % 100 > 10 && t % 100 < 20 ? 2 : 3;
  },
  20: function(t) {
    return t == 1 ? 0 : t == 0 || t % 100 > 0 && t % 100 < 20 ? 1 : 2;
  },
  21: function(t) {
    return t % 100 == 1 ? 1 : t % 100 == 2 ? 2 : t % 100 == 3 || t % 100 == 4 ? 3 : 0;
  },
  22: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : (t < 0 || t > 10) && t % 10 == 0 ? 2 : 3;
  }
}, ok = ["v1", "v2", "v3"], qO = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function lk() {
  var e = {};
  return sk.forEach(function(t) {
    t.lngs.forEach(function(n) {
      e[n] = {
        numbers: t.nr,
        plurals: ak[t.fc]
      };
    });
  }), e;
}
var uk = function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Kr(this, e), this.languageUtils = t, this.options = n, this.logger = cs.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = lk();
  }
  return Gr(e, [{
    key: "addRule",
    value: function(n, s) {
      this.rules[n] = s;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: s.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = this.getRule(n, s);
      return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, s) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, r).map(function(i) {
        return "".concat(s).concat(i);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var s = this, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(n, r);
      return i ? this.shouldUseIntlApi() ? i.resolvedOptions().pluralCategories.sort(function(a, o) {
        return qO[a] - qO[o];
      }).map(function(a) {
        return "".concat(s.options.prepend).concat(a);
      }) : i.numbers.map(function(a) {
        return s.getSuffix(n, a, r);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, s) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = this.getRule(n, r);
      return i ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(i.select(s)) : this.getSuffixRetroCompatible(i, s) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, s) {
      var r = this, i = n.noAbs ? n.plurals(s) : n.plurals(Math.abs(s)), a = n.numbers[i];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (a === 2 ? a = "plural" : a === 1 && (a = ""));
      var o = function() {
        return r.options.prepend && a.toString() ? r.options.prepend + a.toString() : a.toString();
      };
      return this.options.compatibilityJSON === "v1" ? a === 1 ? "" : typeof a == "number" ? "_plural_".concat(a.toString()) : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? o() : this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !ok.includes(this.options.compatibilityJSON);
    }
  }]), e;
}();
function tT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Ir(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tT(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tT(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
var ck = function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Kr(this, e), this.logger = cs.create("interpolator"), this.options = t, this.format = t.interpolation && t.interpolation.format || function(n) {
      return n;
    }, this.init(t);
  }
  return Gr(e, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var s = n.interpolation;
      this.escape = s.escape !== void 0 ? s.escape : ZG, this.escapeValue = s.escapeValue !== void 0 ? s.escapeValue : !0, this.useRawValueToEscape = s.useRawValueToEscape !== void 0 ? s.useRawValueToEscape : !1, this.prefix = s.prefix ? hl(s.prefix) : s.prefixEscaped || "{{", this.suffix = s.suffix ? hl(s.suffix) : s.suffixEscaped || "}}", this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",", this.unescapePrefix = s.unescapeSuffix ? "" : s.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : s.unescapeSuffix || "", this.nestingPrefix = s.nestingPrefix ? hl(s.nestingPrefix) : s.nestingPrefixEscaped || hl("$t("), this.nestingSuffix = s.nestingSuffix ? hl(s.nestingSuffix) : s.nestingSuffixEscaped || hl(")"), this.nestingOptionsSeparator = s.nestingOptionsSeparator ? s.nestingOptionsSeparator : s.nestingOptionsSeparator || ",", this.maxReplaces = s.maxReplaces ? s.maxReplaces : 1e3, this.alwaysFormat = s.alwaysFormat !== void 0 ? s.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var s = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(s, "g");
      var r = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(r, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, s, r, i) {
      var a = this, o, l, f, d = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function u(m) {
        return m.replace(/\$/g, "$$$$");
      }
      var c = function(v) {
        if (v.indexOf(a.formatSeparator) < 0) {
          var y = YO(s, d, v);
          return a.alwaysFormat ? a.format(y, void 0, r, Ir(Ir(Ir({}, i), s), {}, {
            interpolationkey: v
          })) : y;
        }
        var E = v.split(a.formatSeparator), C = E.shift().trim(), x = E.join(a.formatSeparator).trim();
        return a.format(YO(s, d, C), x, r, Ir(Ir(Ir({}, i), s), {}, {
          interpolationkey: C
        }));
      };
      this.resetRegExp();
      var h = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, g = [{
        regex: this.regexpUnescape,
        safeValue: function(v) {
          return u(v);
        }
      }, {
        regex: this.regexp,
        safeValue: function(v) {
          return a.escapeValue ? u(a.escape(v)) : u(v);
        }
      }];
      return g.forEach(function(m) {
        for (f = 0; o = m.regex.exec(n); ) {
          var v = o[1].trim();
          if (l = c(v), l === void 0)
            if (typeof h == "function") {
              var y = h(n, o, i);
              l = typeof y == "string" ? y : "";
            } else if (i && i.hasOwnProperty(v))
              l = "";
            else if (p) {
              l = o[0];
              continue;
            } else
              a.logger.warn("missed to pass in variable ".concat(v, " for interpolating ").concat(n)), l = "";
          else
            typeof l != "string" && !a.useRawValueToEscape && (l = kO(l));
          var E = m.safeValue(l);
          if (n = n.replace(o[0], E), p ? (m.regex.lastIndex += l.length, m.regex.lastIndex -= o[0].length) : m.regex.lastIndex = 0, f++, f >= a.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, s) {
      var r = this, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a, o, l = Ir({}, i);
      l.applyPostProcessor = !1, delete l.defaultValue;
      function f(h, p) {
        var g = this.nestingOptionsSeparator;
        if (h.indexOf(g) < 0)
          return h;
        var m = h.split(new RegExp("".concat(g, "[ ]*{"))), v = "{".concat(m[1]);
        h = m[0], v = this.interpolate(v, l);
        var y = v.match(/'/g), E = v.match(/"/g);
        (y && y.length % 2 === 0 && !E || E.length % 2 !== 0) && (v = v.replace(/'/g, '"'));
        try {
          l = JSON.parse(v), p && (l = Ir(Ir({}, p), l));
        } catch (C) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(h), C), "".concat(h).concat(g).concat(v);
        }
        return delete l.defaultValue, h;
      }
      for (; a = this.nestingRegexp.exec(n); ) {
        var d = [], u = !1;
        if (a[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(a[1])) {
          var c = a[1].split(this.formatSeparator).map(function(h) {
            return h.trim();
          });
          a[1] = c.shift(), d = c, u = !0;
        }
        if (o = s(f.call(this, a[1].trim(), l), l), o && a[0] === n && typeof o != "string")
          return o;
        typeof o != "string" && (o = kO(o)), o || (this.logger.warn("missed to resolve ".concat(a[1], " for nesting ").concat(n)), o = ""), u && (o = d.reduce(function(h, p) {
          return r.format(h, p, i.lng, Ir(Ir({}, i), {}, {
            interpolationkey: a[1].trim()
          }));
        }, o.trim())), n = n.replace(a[0], o), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), e;
}();
function eT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function ma(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eT(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eT(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function hk(e) {
  var t = e.toLowerCase().trim(), n = {};
  if (e.indexOf("(") > -1) {
    var s = e.split("(");
    t = s[0].toLowerCase().trim();
    var r = s[1].substring(0, s[1].length - 1);
    if (t === "currency" && r.indexOf(":") < 0)
      n.currency || (n.currency = r.trim());
    else if (t === "relativetime" && r.indexOf(":") < 0)
      n.range || (n.range = r.trim());
    else {
      var i = r.split(";");
      i.forEach(function(a) {
        if (a) {
          var o = a.split(":"), l = KG(o), f = l[0], d = l.slice(1), u = d.join(":").trim().replace(/^'+|'+$/g, "");
          n[f.trim()] || (n[f.trim()] = u), u === "false" && (n[f.trim()] = !1), u === "true" && (n[f.trim()] = !0), isNaN(u) || (n[f.trim()] = parseInt(u, 10));
        }
      });
    }
  }
  return {
    formatName: t,
    formatOptions: n
  };
}
function dl(e) {
  var t = {};
  return function(s, r, i) {
    var a = r + JSON.stringify(i), o = t[a];
    return o || (o = e(r, i), t[a] = o), o(s);
  };
}
var dk = function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Kr(this, e), this.logger = cs.create("formatter"), this.options = t, this.formats = {
      number: dl(function(n, s) {
        var r = new Intl.NumberFormat(n, s);
        return function(i) {
          return r.format(i);
        };
      }),
      currency: dl(function(n, s) {
        var r = new Intl.NumberFormat(n, ma(ma({}, s), {}, {
          style: "currency"
        }));
        return function(i) {
          return r.format(i);
        };
      }),
      datetime: dl(function(n, s) {
        var r = new Intl.DateTimeFormat(n, ma({}, s));
        return function(i) {
          return r.format(i);
        };
      }),
      relativetime: dl(function(n, s) {
        var r = new Intl.RelativeTimeFormat(n, ma({}, s));
        return function(i) {
          return r.format(i, s.range || "day");
        };
      }),
      list: dl(function(n, s) {
        var r = new Intl.ListFormat(n, ma({}, s));
        return function(i) {
          return r.format(i);
        };
      })
    }, this.init(t);
  }
  return Gr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, r = s.interpolation;
      this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, s) {
      this.formats[n.toLowerCase().trim()] = s;
    }
  }, {
    key: "addCached",
    value: function(n, s) {
      this.formats[n.toLowerCase().trim()] = dl(s);
    }
  }, {
    key: "format",
    value: function(n, s, r, i) {
      var a = this, o = s.split(this.formatSeparator), l = o.reduce(function(f, d) {
        var u = hk(d), c = u.formatName, h = u.formatOptions;
        if (a.formats[c]) {
          var p = f;
          try {
            var g = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, m = g.locale || g.lng || i.locale || i.lng || r;
            p = a.formats[c](f, m, ma(ma(ma({}, h), i), g));
          } catch (v) {
            a.logger.warn(v);
          }
          return p;
        } else
          a.logger.warn("there was no format function for ".concat(c));
        return f;
      }, n);
      return l;
    }
  }]), e;
}();
function nT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function iT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nT(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nT(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function fk(e) {
  var t = pk();
  return function() {
    var s = ys(e), r;
    if (t) {
      var i = ys(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return nh(this, r);
  };
}
function pk() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function mk(e, t) {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
}
var gk = function(e) {
  sp(n, e);
  var t = fk(n);
  function n(s, r, i) {
    var a, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Kr(this, n), a = t.call(this), ap && eo.call(Ba(a)), a.backend = s, a.store = r, a.services = i, a.languageUtils = i.languageUtils, a.options = o, a.logger = cs.create("backendConnector"), a.waitingReads = [], a.maxParallelReads = o.maxParallelReads || 10, a.readingCalls = 0, a.maxRetries = o.maxRetries >= 0 ? o.maxRetries : 5, a.retryTimeout = o.retryTimeout >= 1 ? o.retryTimeout : 350, a.state = {}, a.queue = [], a.backend && a.backend.init && a.backend.init(i, o.backend, o), a;
  }
  return Gr(n, [{
    key: "queueLoad",
    value: function(r, i, a, o) {
      var l = this, f = {}, d = {}, u = {}, c = {};
      return r.forEach(function(h) {
        var p = !0;
        i.forEach(function(g) {
          var m = "".concat(h, "|").concat(g);
          !a.reload && l.store.hasResourceBundle(h, g) ? l.state[m] = 2 : l.state[m] < 0 || (l.state[m] === 1 ? d[m] === void 0 && (d[m] = !0) : (l.state[m] = 1, p = !1, d[m] === void 0 && (d[m] = !0), f[m] === void 0 && (f[m] = !0), c[g] === void 0 && (c[g] = !0)));
        }), p || (u[h] = !0);
      }), (Object.keys(f).length || Object.keys(d).length) && this.queue.push({
        pending: d,
        pendingCount: Object.keys(d).length,
        loaded: {},
        errors: [],
        callback: o
      }), {
        toLoad: Object.keys(f),
        pending: Object.keys(d),
        toLoadLanguages: Object.keys(u),
        toLoadNamespaces: Object.keys(c)
      };
    }
  }, {
    key: "loaded",
    value: function(r, i, a) {
      var o = r.split("|"), l = o[0], f = o[1];
      i && this.emit("failedLoading", l, f, i), a && this.store.addResourceBundle(l, f, a), this.state[r] = i ? -1 : 2;
      var d = {};
      this.queue.forEach(function(u) {
        YG(u.loaded, [l], f), mk(u, r), i && u.errors.push(i), u.pendingCount === 0 && !u.done && (Object.keys(u.loaded).forEach(function(c) {
          d[c] || (d[c] = {});
          var h = u.loaded[c];
          h.length && h.forEach(function(p) {
            d[c][p] === void 0 && (d[c][p] = !0);
          });
        }), u.done = !0, u.errors.length ? u.callback(u.errors) : u.callback());
      }), this.emit("loaded", d), this.queue = this.queue.filter(function(u) {
        return !u.done;
      });
    }
  }, {
    key: "read",
    value: function(r, i, a) {
      var o = this, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, d = arguments.length > 5 ? arguments[5] : void 0;
      if (!r.length)
        return d(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: r,
          ns: i,
          fcName: a,
          tried: l,
          wait: f,
          callback: d
        });
        return;
      }
      return this.readingCalls++, this.backend[a](r, i, function(u, c) {
        if (o.readingCalls--, o.waitingReads.length > 0) {
          var h = o.waitingReads.shift();
          o.read(h.lng, h.ns, h.fcName, h.tried, h.wait, h.callback);
        }
        if (u && c && l < o.maxRetries) {
          setTimeout(function() {
            o.read.call(o, r, i, a, l + 1, f * 2, d);
          }, f);
          return;
        }
        d(u, c);
      });
    }
  }, {
    key: "prepareLoading",
    value: function(r, i) {
      var a = this, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), l && l();
      typeof r == "string" && (r = this.languageUtils.toResolveHierarchy(r)), typeof i == "string" && (i = [i]);
      var f = this.queueLoad(r, i, o, l);
      if (!f.toLoad.length)
        return f.pending.length || l(), null;
      f.toLoad.forEach(function(d) {
        a.loadOne(d);
      });
    }
  }, {
    key: "load",
    value: function(r, i, a) {
      this.prepareLoading(r, i, {}, a);
    }
  }, {
    key: "reload",
    value: function(r, i, a) {
      this.prepareLoading(r, i, {
        reload: !0
      }, a);
    }
  }, {
    key: "loadOne",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = r.split("|"), l = o[0], f = o[1];
      this.read(l, f, "read", void 0, void 0, function(d, u) {
        d && i.logger.warn("".concat(a, "loading namespace ").concat(f, " for language ").concat(l, " failed"), d), !d && u && i.logger.log("".concat(a, "loaded namespace ").concat(f, " for language ").concat(l), u), i.loaded(r, d, u);
      });
    }
  }, {
    key: "saveMissing",
    value: function(r, i, a, o, l) {
      var f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(i)) {
        this.logger.warn('did not save key "'.concat(a, '" as the namespace "').concat(i, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      a == null || a === "" || (this.backend && this.backend.create && this.backend.create(r, i, a, o, null, iT(iT({}, f), {}, {
        isUpdate: l
      })), !(!r || !r[0]) && this.store.addResource(r[0], i, a, o));
    }
  }]), n;
}(eo);
function vk() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(t) {
      var n = {};
      if (Nr(t[1]) === "object" && (n = t[1]), typeof t[1] == "string" && (n.defaultValue = t[1]), typeof t[2] == "string" && (n.tDescription = t[2]), Nr(t[2]) === "object" || Nr(t[3]) === "object") {
        var s = t[3] || t[2];
        Object.keys(s).forEach(function(r) {
          n[r] = s[r];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(t, n, s, r) {
        return t;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function rT(e) {
  return typeof e.ns == "string" && (e.ns = [e.ns]), typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), e;
}
function sT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function rs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sT(Object(n), !0).forEach(function(s) {
      ro(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sT(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function yk(e) {
  var t = Ek();
  return function() {
    var s = ys(e), r;
    if (t) {
      var i = ys(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return nh(this, r);
  };
}
function Ek() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Gh() {
}
function Ck(e) {
  var t = Object.getOwnPropertyNames(Object.getPrototypeOf(e));
  t.forEach(function(n) {
    typeof e[n] == "function" && (e[n] = e[n].bind(e));
  });
}
var hf = function(e) {
  sp(n, e);
  var t = yk(n);
  function n() {
    var s, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    if (Kr(this, n), s = t.call(this), ap && eo.call(Ba(s)), s.options = rT(r), s.services = {}, s.logger = cs, s.modules = {
      external: []
    }, Ck(Ba(s)), i && !s.isInitialized && !r.isClone) {
      if (!s.options.initImmediate)
        return s.init(r, i), nh(s, Ba(s));
      setTimeout(function() {
        s.init(r, i);
      }, 0);
    }
    return s;
  }
  return Gr(n, [{
    key: "init",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0;
      typeof i == "function" && (a = i, i = {}), !i.defaultNS && i.defaultNS !== !1 && i.ns && (typeof i.ns == "string" ? i.defaultNS = i.ns : i.ns.indexOf("translation") < 0 && (i.defaultNS = i.ns[0]));
      var o = vk();
      this.options = rs(rs(rs({}, o), this.options), rT(i)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = rs(rs({}, o.interpolation), this.options.interpolation)), i.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = i.keySeparator), i.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = i.nsSeparator);
      function l(v) {
        return v ? typeof v == "function" ? new v() : v : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? cs.init(l(this.modules.logger), this.options) : cs.init(null, this.options);
        var f;
        this.modules.formatter ? f = this.modules.formatter : typeof Intl < "u" && (f = dk);
        var d = new rk(this.options);
        this.store = new ek(this.options.resources, this.options);
        var u = this.services;
        u.logger = cs, u.resourceStore = this.store, u.languageUtils = d, u.pluralResolver = new uk(d, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), f && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (u.formatter = l(f), u.formatter.init(u, this.options), this.options.interpolation.format = u.formatter.format.bind(u.formatter)), u.interpolator = new ck(this.options), u.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, u.backendConnector = new gk(l(this.modules.backend), u.resourceStore, u, this.options), u.backendConnector.on("*", function(v) {
          for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), C = 1; C < y; C++)
            E[C - 1] = arguments[C];
          r.emit.apply(r, [v].concat(E));
        }), this.modules.languageDetector && (u.languageDetector = l(this.modules.languageDetector), u.languageDetector.init(u, this.options.detection, this.options)), this.modules.i18nFormat && (u.i18nFormat = l(this.modules.i18nFormat), u.i18nFormat.init && u.i18nFormat.init(this)), this.translator = new QO(this.services, this.options), this.translator.on("*", function(v) {
          for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), C = 1; C < y; C++)
            E[C - 1] = arguments[C];
          r.emit.apply(r, [v].concat(E));
        }), this.modules.external.forEach(function(v) {
          v.init && v.init(r);
        });
      }
      if (this.format = this.options.interpolation.format, a || (a = Gh), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var h = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      h.forEach(function(v) {
        r[v] = function() {
          var y;
          return (y = r.store)[v].apply(y, arguments);
        };
      });
      var p = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      p.forEach(function(v) {
        r[v] = function() {
          var y;
          return (y = r.store)[v].apply(y, arguments), r;
        };
      });
      var g = Wu(), m = function() {
        var y = function(C, x) {
          r.isInitialized && !r.initializedStoreOnce && r.logger.warn("init: i18next is already initialized. You should call init just once!"), r.isInitialized = !0, r.options.isClone || r.logger.log("initialized", r.options), r.emit("initialized", r.options), g.resolve(x), a(C, x);
        };
        if (r.languages && r.options.compatibilityAPI !== "v1" && !r.isInitialized)
          return y(null, r.t.bind(r));
        r.changeLanguage(r.options.lng, y);
      };
      return this.options.resources || !this.options.initImmediate ? m() : setTimeout(m, 0), g;
    }
  }, {
    key: "loadResources",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Gh, o = a, l = typeof r == "string" ? r : this.language;
      if (typeof r == "function" && (o = r), !this.options.resources || this.options.partialBundledLanguages) {
        if (l && l.toLowerCase() === "cimode")
          return o();
        var f = [], d = function(h) {
          if (h) {
            var p = i.services.languageUtils.toResolveHierarchy(h);
            p.forEach(function(g) {
              f.indexOf(g) < 0 && f.push(g);
            });
          }
        };
        if (l)
          d(l);
        else {
          var u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          u.forEach(function(c) {
            return d(c);
          });
        }
        this.options.preload && this.options.preload.forEach(function(c) {
          return d(c);
        }), this.services.backendConnector.load(f, this.options.ns, function(c) {
          !c && !i.resolvedLanguage && i.language && i.setResolvedLanguage(i.language), o(c);
        });
      } else
        o(null);
    }
  }, {
    key: "reloadResources",
    value: function(r, i, a) {
      var o = Wu();
      return r || (r = this.languages), i || (i = this.options.ns), a || (a = Gh), this.services.backendConnector.reload(r, i, function(l) {
        o.resolve(), a(l);
      }), o;
    }
  }, {
    key: "use",
    value: function(r) {
      if (!r)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!r.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return r.type === "backend" && (this.modules.backend = r), (r.type === "logger" || r.log && r.warn && r.error) && (this.modules.logger = r), r.type === "languageDetector" && (this.modules.languageDetector = r), r.type === "i18nFormat" && (this.modules.i18nFormat = r), r.type === "postProcessor" && QI.addPostProcessor(r), r.type === "formatter" && (this.modules.formatter = r), r.type === "3rdParty" && this.modules.external.push(r), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(r) {
      if (!(!r || !this.languages) && !(["cimode", "dev"].indexOf(r) > -1))
        for (var i = 0; i < this.languages.length; i++) {
          var a = this.languages[i];
          if (!(["cimode", "dev"].indexOf(a) > -1) && this.store.hasLanguageSomeTranslations(a)) {
            this.resolvedLanguage = a;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(r, i) {
      var a = this;
      this.isLanguageChangingTo = r;
      var o = Wu();
      this.emit("languageChanging", r);
      var l = function(c) {
        a.language = c, a.languages = a.services.languageUtils.toResolveHierarchy(c), a.resolvedLanguage = void 0, a.setResolvedLanguage(c);
      }, f = function(c, h) {
        h ? (l(h), a.translator.changeLanguage(h), a.isLanguageChangingTo = void 0, a.emit("languageChanged", h), a.logger.log("languageChanged", h)) : a.isLanguageChangingTo = void 0, o.resolve(function() {
          return a.t.apply(a, arguments);
        }), i && i(c, function() {
          return a.t.apply(a, arguments);
        });
      }, d = function(c) {
        !r && !c && a.services.languageDetector && (c = []);
        var h = typeof c == "string" ? c : a.services.languageUtils.getBestMatchFromCodes(c);
        h && (a.language || l(h), a.translator.language || a.translator.changeLanguage(h), a.services.languageDetector && a.services.languageDetector.cacheUserLanguage(h)), a.loadResources(h, function(p) {
          f(p, h);
        });
      };
      return !r && this.services.languageDetector && !this.services.languageDetector.async ? d(this.services.languageDetector.detect()) : !r && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(d) : d(r), o;
    }
  }, {
    key: "getFixedT",
    value: function(r, i, a) {
      var o = this, l = function f(d, u) {
        var c;
        if (Nr(u) !== "object") {
          for (var h = arguments.length, p = new Array(h > 2 ? h - 2 : 0), g = 2; g < h; g++)
            p[g - 2] = arguments[g];
          c = o.options.overloadTranslationOptionHandler([d, u].concat(p));
        } else
          c = rs({}, u);
        c.lng = c.lng || f.lng, c.lngs = c.lngs || f.lngs, c.ns = c.ns || f.ns, c.keyPrefix = c.keyPrefix || a || f.keyPrefix;
        var m = o.options.keySeparator || ".", v = c.keyPrefix ? "".concat(c.keyPrefix).concat(m).concat(d) : d;
        return o.t(v, c);
      };
      return typeof r == "string" ? l.lng = r : l.lngs = r, l.ns = i, l.keyPrefix = a, l;
    }
  }, {
    key: "t",
    value: function() {
      var r;
      return this.translator && (r = this.translator).translate.apply(r, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var r;
      return this.translator && (r = this.translator).exists.apply(r, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(r) {
      this.options.defaultNS = r;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var o = this.resolvedLanguage || this.languages[0], l = this.options ? this.options.fallbackLng : !1, f = this.languages[this.languages.length - 1];
      if (o.toLowerCase() === "cimode")
        return !0;
      var d = function(h, p) {
        var g = i.services.backendConnector.state["".concat(h, "|").concat(p)];
        return g === -1 || g === 2;
      };
      if (a.precheck) {
        var u = a.precheck(this, d);
        if (u !== void 0)
          return u;
      }
      return !!(this.hasResourceBundle(o, r) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || d(o, r) && (!l || d(f, r)));
    }
  }, {
    key: "loadNamespaces",
    value: function(r, i) {
      var a = this, o = Wu();
      return this.options.ns ? (typeof r == "string" && (r = [r]), r.forEach(function(l) {
        a.options.ns.indexOf(l) < 0 && a.options.ns.push(l);
      }), this.loadResources(function(l) {
        o.resolve(), i && i(l);
      }), o) : (i && i(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(r, i) {
      var a = Wu();
      typeof r == "string" && (r = [r]);
      var o = this.options.preload || [], l = r.filter(function(f) {
        return o.indexOf(f) < 0;
      });
      return l.length ? (this.options.preload = o.concat(l), this.loadResources(function(f) {
        a.resolve(), i && i(f);
      }), a) : (i && i(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(r) {
      if (r || (r = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !r)
        return "rtl";
      var i = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(r)) > -1 || r.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Gh, o = rs(rs(rs({}, this.options), i), {
        isClone: !0
      }), l = new n(o);
      (i.debug !== void 0 || i.prefix !== void 0) && (l.logger = l.logger.clone(i));
      var f = ["store", "services", "language"];
      return f.forEach(function(d) {
        l[d] = r[d];
      }), l.services = rs({}, this.services), l.services.utils = {
        hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
      }, l.translator = new QO(l.services, l.options), l.translator.on("*", function(d) {
        for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), h = 1; h < u; h++)
          c[h - 1] = arguments[h];
        l.emit.apply(l, [d].concat(c));
      }), l.init(o, a), l.translator.options = l.options, l.translator.backendConnector.services.utils = {
        hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
      }, l;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(eo);
ro(hf, "createInstance", function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
  return new hf(e, t);
});
var xn = hf.createInstance();
xn.createInstance = hf.createInstance;
xn.createInstance;
var xk = xn.init;
xn.loadResources;
xn.reloadResources;
var bk = xn.use;
xn.changeLanguage;
xn.getFixedT;
var qI = xn.t;
xn.exists;
xn.setDefaultNamespace;
xn.hasLoadedNamespace;
xn.loadNamespaces;
xn.loadLanguages;
const Ok = new cW(), aT = () => ({
  capabilities: {}
}), Tk = {
  namespaced: !0,
  state: aT(),
  actions: {
    loadCapabilities({ commit: e, getters: t }, n) {
      const s = t.capabilities[n];
      if (typeof s < "u" && s !== null) {
        console.warn(
          `Re-fired loadCapabilities on id '${n}' albeit the GetCapabilities have already been successfully fetched. No re-fetch will occur.`
        );
        return;
      }
      e("addCapabilities", { id: n, string: null });
      const r = Ka({ id: n });
      if (!r || !r.url || !r.version || !r.typ) {
        console.error(`Missing data for service with id '${n}': ${r}`);
        return;
      }
      const i = `${r.url}?service=${r.typ}&version=${r.version}&request=GetCapabilities`;
      fetch(i).then((a) => a.text()).then((a) => e("addCapabilities", { id: n, string: a })).catch((a) => {
        console.error(
          a,
          `Capabilities from ${i} could not be fetched.`
        ), e("addCapabilities", { id: n, string: null });
      });
    }
  },
  mutations: {
    addCapabilities(e, { id: t, string: n }) {
      e.capabilities[t] = n;
    }
  },
  getters: {
    ...rr(aT()),
    wmsCapabilitiesAsJsonById: (e) => (t) => {
      const n = e.capabilities[t];
      if (n)
        try {
          return Ok.read(n);
        } catch (s) {
          console.error(s, `Error reading xml for id '${t}': ${n}`);
        }
      return null;
    }
  }
}, kh = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Hh extends Ui {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(t, n) {
    super(t), this.feature = n;
  }
}
function Pk(e, t) {
  const n = [];
  for (let s = 0; s < t.length; ++s) {
    const i = t[s].getGeometry();
    t_(e, i, n);
  }
  return n;
}
function Yh(e, t) {
  return Ks(e[0], e[1], t[0], t[1]);
}
function Rl(e, t) {
  const n = e.length;
  return t < 0 ? e[t + n] : t >= n ? e[t - n] : e[t];
}
function Xh(e, t, n) {
  let s, r;
  t < n ? (s = t, r = n) : (s = n, r = t);
  const i = Math.ceil(s), a = Math.floor(r);
  if (i > a) {
    const l = wl(e, s), f = wl(e, r);
    return Yh(l, f);
  }
  let o = 0;
  if (s < i) {
    const l = wl(e, s), f = Rl(e, i);
    o += Yh(l, f);
  }
  if (a < r) {
    const l = Rl(e, a), f = wl(e, r);
    o += Yh(l, f);
  }
  for (let l = i; l < a - 1; ++l) {
    const f = Rl(e, l), d = Rl(e, l + 1);
    o += Yh(f, d);
  }
  return o;
}
function t_(e, t, n) {
  if (t instanceof qi) {
    Zh(e, t.getCoordinates(), !1, n);
    return;
  }
  if (t instanceof Zs) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r)
      Zh(e, s[r], !1, n);
    return;
  }
  if (t instanceof nr) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r)
      Zh(e, s[r], !0, n);
    return;
  }
  if (t instanceof Js) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r) {
      const a = s[r];
      for (let o = 0, l = a.length; o < l; ++o)
        Zh(e, a[o], !0, n);
    }
    return;
  }
  if (t instanceof Q1) {
    const s = t.getGeometries();
    for (let r = 0; r < s.length; ++r)
      t_(e, s[r], n);
    return;
  }
}
const Zm = { index: -1, endIndex: NaN };
function Mk(e, t, n, s) {
  const r = e[0], i = e[1];
  let a = 1 / 0, o = -1, l = NaN;
  for (let u = 0; u < t.targets.length; ++u) {
    const c = t.targets[u], h = c.coordinates;
    let p = 1 / 0, g;
    for (let m = 0; m < h.length - 1; ++m) {
      const v = h[m], y = h[m + 1], E = e_(r, i, v, y);
      E.squaredDistance < p && (p = E.squaredDistance, g = m + E.along);
    }
    p < a && (a = p, c.ring && t.targetIndex === u && (c.endIndex > c.startIndex ? g < c.startIndex && (g += h.length) : c.endIndex < c.startIndex && g > c.startIndex && (g -= h.length)), l = g, o = u);
  }
  const f = t.targets[o];
  let d = f.ring;
  if (t.targetIndex === o && d) {
    const u = wl(
      f.coordinates,
      l
    ), c = n.getPixelFromCoordinate(u);
    YT(c, t.startPx) > s && (d = !1);
  }
  if (d) {
    const u = f.coordinates, c = u.length, h = f.startIndex, p = l;
    if (h < p) {
      const g = Xh(
        u,
        h,
        p
      );
      Xh(
        u,
        h,
        p - c
      ) < g && (l -= c);
    } else {
      const g = Xh(
        u,
        h,
        p
      );
      Xh(
        u,
        h,
        p + c
      ) < g && (l += c);
    }
  }
  return Zm.index = o, Zm.endIndex = l, Zm;
}
function Zh(e, t, n, s) {
  const r = e[0], i = e[1];
  for (let a = 0, o = t.length - 1; a < o; ++a) {
    const l = t[a], f = t[a + 1], d = e_(r, i, l, f);
    if (d.squaredDistance === 0) {
      const u = a + d.along;
      s.push({
        coordinates: t,
        ring: n,
        startIndex: u,
        endIndex: u
      });
      return;
    }
  }
}
const Jm = { along: 0, squaredDistance: 0 };
function e_(e, t, n, s) {
  const r = n[0], i = n[1], a = s[0], o = s[1], l = a - r, f = o - i;
  let d = 0, u = r, c = i;
  return (l !== 0 || f !== 0) && (d = hn(((e - r) * l + (t - i) * f) / (l * l + f * f), 0, 1), u += l * d, c += f * d), Jm.along = d, Jm.squaredDistance = Tf(Ks(e, t, u, c), 10), Jm;
}
function wl(e, t) {
  const n = e.length;
  let s = Math.floor(t);
  const r = t - s;
  s >= n ? s -= n : s < 0 && (s += n);
  let i = s + 1;
  i >= n && (i -= n);
  const a = e[s], o = a[0], l = a[1], f = e[i], d = f[0] - o, u = f[1] - l;
  return [o + d * r, l + u * r];
}
class Sk extends Jo {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = au), super(n), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    t.type, this.mode_ = _k(this.type_), this.stopClick_ = !!t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : ds, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
    let s = t.geometryFunction;
    if (!s) {
      const r = this.mode_;
      if (r === "Circle")
        s = function(i, a, o) {
          const l = a || new iM([NaN, NaN]), f = _r(i[0]), d = HT(
            f,
            _r(i[i.length - 1])
          );
          return l.setCenterAndRadius(
            f,
            Math.sqrt(d),
            this.geometryLayout_
          ), l;
        };
      else {
        let i;
        r === "Point" ? i = hi : r === "LineString" ? i = qi : r === "Polygon" && (i = nr), s = function(a, o, l) {
          return o ? r === "Polygon" ? a[0].length ? o.setCoordinates(
            [a[0].concat([a[0][0]])],
            this.geometryLayout_
          ) : o.setCoordinates([], this.geometryLayout_) : o.setCoordinates(a, this.geometryLayout_) : o = new i(a, this.geometryLayout_), o;
        };
      }
    }
    this.geometryFunction_ = s, this.dragVertexDelay_ = t.dragVertexDelay !== void 0 ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new vr({
      source: new jr({
        useSpatialIndex: !1,
        wrapX: t.wrapX ? t.wrapX : !1
      }),
      style: t.style ? t.style : Ik(),
      updateWhileInteracting: !0
    }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : wy, this.freehandCondition_, t.freehand ? this.freehandCondition_ = Ad : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : Vy, this.traceCondition_, this.setTrace(t.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(Dd.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(t) {
    let n;
    t ? t === !0 ? n = Ad : n = t : n = Ng, this.traceCondition_ = n;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(t) {
    super.setMap(t), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    t.originalEvent.type === Kt.CONTEXTMENU && t.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(t);
    let n = t.type === Te.POINTERMOVE, s = !0;
    return !this.freehand_ && this.lastDragTime_ && t.type === Te.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, n = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && t.type === Te.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(t.coordinate), s = !1) : this.freehand_ && t.type === Te.POINTERDOWN ? s = !1 : n && this.getPointerCount() < 2 ? (s = t.type === Te.POINTERMOVE, s && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : (t.originalEvent.pointerType === "mouse" || t.type === Te.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(t)) : t.type === Te.DBLCLICK && (s = !1), super.handleEvent(t) && s;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(
      (function() {
        this.handlePointerMove_(
          new ws(
            Te.POINTERMOVE,
            t.map,
            t.originalEvent,
            !1,
            t.frameState
          )
        );
      }).bind(this),
      this.dragVertexDelay_
    ), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(t) {
    if (!this.traceSource_ || !this.traceCondition_(t))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const n = this.getMap(), s = n.getCoordinateFromPixel([
      t.pixel[0] - this.snapTolerance_,
      t.pixel[1] + this.snapTolerance_
    ]), r = n.getCoordinateFromPixel([
      t.pixel[0] + this.snapTolerance_,
      t.pixel[1] - this.snapTolerance_
    ]), i = Yl([s, r]), a = this.traceSource_.getFeaturesInExtent(i);
    if (a.length === 0)
      return;
    const o = Pk(t.coordinate, a);
    o.length && (this.traceState_ = {
      active: !0,
      startPx: t.pixel.slice(),
      targets: o,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(t, n) {
    const s = t.startIndex <= t.endIndex, r = t.startIndex <= n;
    s === r ? s && n > t.endIndex || !s && n < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, n) : (s && n < t.endIndex || !s && n > t.endIndex) && this.removeTracedCoordinates_(n, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, n));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(t, n) {
    if (t === n)
      return;
    let s = 0;
    if (t < n) {
      const r = Math.ceil(t);
      let i = Math.floor(n);
      i === n && (i -= 1), s = i - r + 1;
    } else {
      const r = Math.floor(t);
      let i = Math.ceil(n);
      i === n && (i += 1), s = r - i + 1;
    }
    s > 0 && this.removeLastPoints_(s);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(t, n, s) {
    if (n === s)
      return;
    const r = [];
    if (n < s) {
      const i = Math.ceil(n);
      let a = Math.floor(s);
      a === s && (a -= 1);
      for (let o = i; o <= a; ++o)
        r.push(Rl(t.coordinates, o));
    } else {
      const i = Math.floor(n);
      let a = Math.ceil(s);
      a === s && (a += 1);
      for (let o = i; o >= a; --o)
        r.push(Rl(t.coordinates, o));
    }
    r.length && this.appendCoordinates(r);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(t) {
    const n = this.traceState_;
    if (!n.active || n.targetIndex === -1 && YT(n.startPx, t.pixel) < this.snapTolerance_)
      return;
    const s = Mk(
      t.coordinate,
      n,
      this.getMap(),
      this.snapTolerance_
    );
    if (n.targetIndex !== s.index) {
      if (n.targetIndex !== -1) {
        const l = n.targets[n.targetIndex];
        this.removeTracedCoordinates_(l.startIndex, l.endIndex);
      }
      const o = n.targets[s.index];
      this.addTracedCoordinates_(
        o,
        o.startIndex,
        s.endIndex
      );
    } else {
      const o = n.targets[n.targetIndex];
      this.addOrRemoveTracedCoordinates_(o, s.endIndex);
    }
    n.targetIndex = s.index;
    const r = n.targets[n.targetIndex];
    r.endIndex = s.endIndex;
    const i = wl(
      r.coordinates,
      r.endIndex
    ), a = this.getMap().getPixelFromCoordinate(i);
    t.coordinate = i, t.pixel = [Math.round(a[0]), Math.round(a[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    let n = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t);
      const s = this.traceState_.active;
      if (this.toggleTraceState_(t), this.shouldHandle_) {
        const r = !this.finishCoordinate_;
        r && this.startDrawing_(t.coordinate), !r && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!r || this.mode_ === "Point") && (this.atFinish_(t.pixel, s) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), n = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !n && this.stopClick_ && t.preventDefault(), n;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const n = this.downPx_, s = t.pixel, r = n[0] - s[0], i = n[1] - s[1], a = r * r + i * i;
      if (this.shouldHandle_ = this.freehand_ ? a > this.squaredClickTolerance_ : a <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(t.coordinate.slice());
      return;
    }
    this.updateTrace_(t), this.modifyDrawing_(t.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(t, n) {
    let s = !1;
    if (this.sketchFeature_) {
      let r = !1, i = [this.finishCoordinate_];
      const a = this.mode_;
      if (a === "Point")
        s = !0;
      else if (a === "Circle")
        s = this.sketchCoords_.length === 2;
      else if (a === "LineString")
        r = !n && this.sketchCoords_.length > this.minPoints_;
      else if (a === "Polygon") {
        const o = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        r = o[0].length > this.minPoints_, i = [
          o[0][0],
          o[0][o[0].length - 2]
        ], n ? i = [o[0][0]] : i = [
          o[0][0],
          o[0][o[0].length - 2]
        ];
      }
      if (r) {
        const o = this.getMap();
        for (let l = 0, f = i.length; l < f; l++) {
          const d = i[l], u = o.getPixelFromCoordinate(d), c = t[0] - u[0], h = t[1] - u[1], p = this.freehand_ ? 1 : this.snapTolerance_;
          if (s = Math.sqrt(c * c + h * h) <= p, s) {
            this.finishCoordinate_ = d;
            break;
          }
        }
      }
    }
    return s;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(t) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new Xi(new hi(t)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(t) {
    this.sketchLine_ || (this.sketchLine_ = new Xi());
    const n = t.getLinearRing(0);
    let s = this.sketchLine_.getGeometry();
    s ? (s.setFlatCoordinates(
      n.getLayout(),
      n.getFlatCoordinates()
    ), s.changed()) : (s = new qi(
      n.getFlatCoordinates(),
      n.getLayout()
    ), this.sketchLine_.setGeometry(s));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(t) {
    const n = this.getMap().getView().getProjection(), s = md(this.geometryLayout_);
    for (; t.length < s; )
      t.push(0);
    this.finishCoordinate_ = t, this.mode_ === "Point" ? this.sketchCoords_ = t.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Xi(new qi(this.sketchLineCoords_)));
    const r = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      n
    );
    this.sketchFeature_ = new Xi(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(r), this.updateSketchFeatures_(), this.dispatchEvent(
      new Hh(kh.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(t) {
    const n = this.getMap(), s = this.sketchFeature_.getGeometry(), r = n.getView().getProjection(), i = md(this.geometryLayout_);
    let a, o;
    for (; t.length < i; )
      t.push(0);
    this.mode_ === "Point" ? o = this.sketchCoords_ : this.mode_ === "Polygon" ? (a = /** @type {PolyCoordType} */
    this.sketchCoords_[0], o = a[a.length - 1], this.atFinish_(n.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (a = this.sketchCoords_, o = a[a.length - 1]), o[0] = t[0], o[1] = t[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      s,
      r
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t), s.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      s
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(t) {
    const n = this.sketchFeature_.getGeometry(), s = this.getMap().getView().getProjection();
    let r, i;
    const a = this.mode_;
    a === "LineString" || a === "Circle" ? (this.finishCoordinate_ = t.slice(), i = /** @type {LineCoordType} */
    this.sketchCoords_, i.length >= this.maxPoints_ && (this.freehand_ ? i.pop() : r = !0), i.push(t.slice()), this.geometryFunction_(i, n, s)) : a === "Polygon" && (i = /** @type {PolyCoordType} */
    this.sketchCoords_[0], i.length >= this.maxPoints_ && (this.freehand_ ? i.pop() : r = !0), i.push(t.slice()), r && (this.finishCoordinate_ = i[0]), this.geometryFunction_(this.sketchCoords_, n, s)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), r && this.finishDrawing();
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(t) {
    if (!this.sketchFeature_)
      return;
    const n = this.sketchFeature_.getGeometry(), s = this.getMap().getView().getProjection(), r = this.mode_;
    for (let i = 0; i < t; ++i) {
      let a;
      if (r === "LineString" || r === "Circle") {
        if (a = /** @type {LineCoordType} */
        this.sketchCoords_, a.splice(-2, 1), a.length >= 2) {
          this.finishCoordinate_ = a[a.length - 2].slice();
          const o = this.finishCoordinate_.slice();
          a[a.length - 1] = o, this.createOrUpdateSketchPoint_(o);
        }
        this.geometryFunction_(a, n, s), n.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          n
        );
      } else if (r === "Polygon") {
        a = /** @type {PolyCoordType} */
        this.sketchCoords_[0], a.splice(-2, 1);
        const o = this.sketchLine_.getGeometry();
        if (a.length >= 2) {
          const l = a[a.length - 2].slice();
          a[a.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        o.setCoordinates(a), this.geometryFunction_(this.sketchCoords_, n, s);
      }
      if (a.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const t = this.abortDrawing_();
    if (!t)
      return;
    let n = this.sketchCoords_;
    const s = t.getGeometry(), r = this.getMap().getView().getProjection();
    this.mode_ === "LineString" ? (n.pop(), this.geometryFunction_(n, s, r)) : this.mode_ === "Polygon" && (n[0].pop(), this.geometryFunction_(n, s, r), n = s.getCoordinates()), this.type_ === "MultiPoint" ? t.setGeometry(
      new gu([
        /** @type {PointCoordType} */
        n
      ])
    ) : this.type_ === "MultiLineString" ? t.setGeometry(
      new Zs([
        /** @type {LineCoordType} */
        n
      ])
    ) : this.type_ === "MultiPolygon" && t.setGeometry(
      new Js([
        /** @type {PolyCoordType} */
        n
      ])
    ), this.dispatchEvent(new Hh(kh.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t);
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const t = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), t;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const t = this.abortDrawing_();
    t && this.dispatchEvent(new Hh(kh.DRAWABORT, t));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(t) {
    const n = this.mode_, s = !this.sketchFeature_;
    s && this.startDrawing_(t[0]);
    let r;
    if (n === "LineString" || n === "Circle")
      r = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (n === "Polygon")
      r = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    s && r.shift(), r.pop();
    for (let a = 0; a < t.length; a++)
      this.addToDrawing_(t[a]);
    const i = t[t.length - 1];
    this.addToDrawing_(i), this.modifyDrawing_(i);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(t) {
    const s = t.getGeometry();
    this.sketchFeature_ = t, this.sketchCoords_ = s.getCoordinates();
    const r = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = r.slice(), this.sketchCoords_.push(r.slice()), this.sketchPoint_ = new Xi(new hi(r)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Hh(kh.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const t = [];
    this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
    const n = this.overlay_.getSource();
    n.clear(!0), n.addFeatures(t);
  }
  /**
   * @private
   */
  updateState_() {
    const t = this.getMap(), n = this.getActive();
    (!t || !n) && this.abortDrawing(), this.overlay_.setMap(n ? t : null);
  }
}
function Ik() {
  const e = CP();
  return function(t, n) {
    return e[t.getGeometry().getType()];
  };
}
function _k(e) {
  switch (e) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + e);
  }
}
const Dk = Sk, Ak = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class Lk extends Ui {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(t, n, s, r) {
    super(t), this.selected = n, this.deselected = s, this.mapBrowserEvent = r;
  }
}
const Jh = {};
class vE extends uu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = t.condition ? t.condition : aR, this.addCondition_ = t.addCondition ? t.addCondition : Ng, this.removeCondition_ = t.removeCondition ? t.removeCondition : Ng, this.toggleCondition_ = t.toggleCondition ? t.toggleCondition : Vy, this.multi_ = t.multi ? t.multi : !1, this.filter_ = t.filter ? t.filter : ds, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.style_ = t.style !== void 0 ? t.style : Rk(), this.features_ = t.features || new Vi();
    let n;
    if (t.layers)
      if (typeof t.layers == "function")
        n = t.layers;
      else {
        const s = t.layers;
        n = function(r) {
          return s.includes(r);
        };
      }
    else
      n = ds;
    this.layerFilter_ = n, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(t, n) {
    this.featureLayerAssociation_[Xt(t)] = n;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(t) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[Xt(t)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(t) {
    this.hitTolerance_ = t;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(t), t ? (this.features_.addEventListener(
      $n.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      $n.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      $n.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      $n.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(t) {
    const n = t.element;
    if (this.style_ && this.applySelectedStyle_(n), !this.getLayer(n)) {
      const s = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(r) {
          if (r instanceof vr && r.getSource() && r.getSource().hasFeature(n))
            return r;
        })
      );
      s && this.addFeatureLayerAssociation_(n, s);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(t) {
    this.style_ && this.restorePreviousStyle_(t.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(t) {
    const n = Xt(t);
    n in Jh || (Jh[n] = t.getStyle()), t.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(t) {
    const n = this.getMap().getInteractions().getArray();
    for (let r = n.length - 1; r >= 0; --r) {
      const i = n[r];
      if (i !== this && i instanceof vE && i.getStyle() && i.getFeatures().getArray().lastIndexOf(t) !== -1) {
        t.setStyle(i.getStyle());
        return;
      }
    }
    const s = Xt(t);
    t.setStyle(Jh[s]), delete Jh[s];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(t) {
    delete this.featureLayerAssociation_[Xt(t)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {Select}
   */
  handleEvent(t) {
    if (!this.condition_(t))
      return !0;
    const n = this.addCondition_(t), s = this.removeCondition_(t), r = this.toggleCondition_(t), i = !n && !s && !r, a = t.map, o = this.getFeatures(), l = [], f = [];
    if (i) {
      ou(this.featureLayerAssociation_), a.forEachFeatureAtPixel(
        t.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (function(d, u) {
          if (!(!(d instanceof Xi) || !this.filter_(d, u)))
            return this.addFeatureLayerAssociation_(d, u), f.push(d), !this.multi_;
        }).bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = o.getLength() - 1; d >= 0; --d) {
        const u = o.item(d), c = f.indexOf(u);
        c > -1 ? f.splice(c, 1) : (o.remove(u), l.push(u));
      }
      f.length !== 0 && o.extend(f);
    } else {
      a.forEachFeatureAtPixel(
        t.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (function(d, u) {
          if (!(!(d instanceof Xi) || !this.filter_(d, u)))
            return (n || r) && !o.getArray().includes(d) ? (this.addFeatureLayerAssociation_(d, u), f.push(d)) : (s || r) && o.getArray().includes(d) && (l.push(d), this.removeFeatureLayerAssociation_(d)), !this.multi_;
        }).bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = l.length - 1; d >= 0; --d)
        o.remove(l[d]);
      o.extend(f);
    }
    return (f.length > 0 || l.length > 0) && this.dispatchEvent(
      new Lk(
        Ak.SELECT,
        f,
        l,
        t
      )
    ), !0;
  }
}
function Rk() {
  const e = CP();
  return Kn(e.Polygon, e.LineString), Kn(e.GeometryCollection, e.LineString), function(t) {
    return t.getGeometry() ? e[t.getGeometry().getType()] : null;
  };
}
const wk = vE, Qm = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: "translatestart",
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: "translating",
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: "translateend"
};
class qm extends Ui {
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<import("../Feature.js").default>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */
  constructor(t, n, s, r, i) {
    super(t), this.features = n, this.coordinate = s, this.startCoordinate = r, this.mapBrowserEvent = i;
  }
}
class Vk extends Jo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Pointer.js").Options} */
      t
    ), this.on, this.once, this.un, this.lastCoordinate_ = null, this.startCoordinate_ = null, this.features_ = t.features !== void 0 ? t.features : null;
    let n;
    if (t.layers && !this.features_)
      if (typeof t.layers == "function")
        n = t.layers;
      else {
        const s = t.layers;
        n = function(r) {
          return s.includes(r);
        };
      }
    else
      n = ds;
    this.layerFilter_ = n, this.filter_ = t.filter && !this.features_ ? t.filter : ds, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.condition_ = t.condition ? t.condition : Ad, this.lastFeature_ = null, this.addChangeListener(
      Dd.ACTIVE,
      this.handleActiveChanged_
    );
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (!t.originalEvent || !this.condition_(t))
      return !1;
    if (this.lastFeature_ = this.featuresAtPixel_(t.pixel, t.map), !this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = t.coordinate, this.lastCoordinate_ = t.coordinate, this.handleMoveEvent(t);
      const n = this.features_ || new Vi([this.lastFeature_]);
      return this.dispatchEvent(
        new qm(
          Qm.TRANSLATESTART,
          n,
          t.coordinate,
          this.startCoordinate_,
          t
        )
      ), !0;
    }
    return !1;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null, this.handleMoveEvent(t);
      const n = this.features_ || new Vi([this.lastFeature_]);
      return this.dispatchEvent(
        new qm(
          Qm.TRANSLATEEND,
          n,
          t.coordinate,
          this.startCoordinate_,
          t
        )
      ), this.startCoordinate_ = null, !0;
    }
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleDragEvent(t) {
    if (this.lastCoordinate_) {
      const n = t.coordinate, s = n[0] - this.lastCoordinate_[0], r = n[1] - this.lastCoordinate_[1], i = this.features_ || new Vi([this.lastFeature_]);
      i.forEach(function(a) {
        const o = a.getGeometry();
        o.translate(s, r), a.setGeometry(o);
      }), this.lastCoordinate_ = n, this.dispatchEvent(
        new qm(
          Qm.TRANSLATING,
          i,
          n,
          this.startCoordinate_,
          t
        )
      );
    }
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleMoveEvent(t) {
    const n = t.map.getViewport();
    this.featuresAtPixel_(t.pixel, t.map) ? (n.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), n.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : n.classList.remove("ol-grab", "ol-grabbing");
  }
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../Map.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  featuresAtPixel_(t, n) {
    return n.forEachFeatureAtPixel(
      t,
      (function(s, r) {
        if (this.filter_(s, r) && (!this.features_ || this.features_.getArray().includes(s)))
          return s;
      }).bind(this),
      {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      }
    );
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(t) {
    this.hitTolerance_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(t) {
    const n = this.getMap();
    super.setMap(t), this.updateState_(n);
  }
  /**
   * @private
   */
  handleActiveChanged_() {
    this.updateState_(null);
  }
  /**
   * @param {import("../Map.js").default} oldMap Old map.
   * @private
   */
  updateState_(t) {
    let n = this.getMap();
    const s = this.getActive();
    (!n || !s) && (n = n || t, n && n.getViewport().classList.remove("ol-grab", "ol-grabbing"));
  }
}
const Bk = Vk;
function Nk(e, t) {
  return e ? [new Fg(), new jg()] : [
    new Fg({
      condition: function() {
        return t ? this.getPointerCount() > 1 : !0;
      }
    }),
    new jg({
      condition: oR
    })
  ];
}
const wv = 480, Vv = 768;
let fl = null, tg = [], eg = [];
const Fk = (e) => {
};
$t.use(NG);
const ng = () => ({
  map: 1,
  clientHeight: 0,
  clientWidth: 0,
  components: 1,
  center: null,
  // TODO: Add default values for epsg, layers, namedProjections, options and remove @ts-ignore for configuration
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  configuration: {},
  errors: []
}), oT = ({ map: e }) => n_.commit("setCenter", e.getView().getCenter()), n_ = new Ki({
  state: ng(),
  plugins: [Fk],
  // vuex plugins, not polar plugins
  modules: {
    capabilities: Tk,
    /* reserved for plugins */
    plugin: {
      namespaced: !0
    }
  },
  getters: {
    ...rr(ng()),
    // hack: deliver map (outside vuex) based on counter; see NOTE above
    map: (e) => (WO(e.map), fl),
    // hack: deliver components (outside vuex) based on counter; see NOTE above
    components: (e) => (WO(e.components), tg),
    // TODO: Both will possibly be updated with different breakpoints
    hasSmallHeight: (e) => e.clientHeight <= wv,
    hasSmallWidth: (e) => e.clientWidth <= Vv,
    hasWindowSize(e) {
      return window.innerHeight === e.clientHeight && window.innerWidth === e.clientWidth;
    }
  },
  mutations: {
    ...zr(ng()),
    setMap: (e, t) => {
      fl && fl.un("moveend", oT), fl = t, fl && fl.on("moveend", oT), e.map = e.map + 1;
    },
    setComponents: (e, t) => {
      tg = t, e.components = e.components + 1;
    },
    addError: (e, t) => {
      e.errors.push(t);
    }
  },
  actions: {
    addComponent({ state: e, commit: t, dispatch: n }, s) {
      const { language: r, name: i, options: a, storeModule: o } = s;
      if (t("setConfiguration", {
        ...e.configuration,
        [i]: Lc({}, a, e.configuration[i] || {})
      }), o) {
        this.registerModule(["plugin", i], o);
        const l = `plugin/${i}/setupModule`;
        Object.keys(this._actions).includes(
          l
        ) && n(l, a);
      }
      r && r.forEach((l) => {
        xn.addResourceBundle(l.type, "common", l.resources, !0);
      }), e.configuration[i].displayComponent && t("setComponents", [...tg, s]);
    },
    updateDragAndZoomInteractions({ getters: e }) {
      eg.forEach((t) => e.map.removeInteraction(t)), eg = Nk(
        e.hasWindowSize,
        window.innerHeight <= wv || window.innerWidth <= Vv
      ), eg.forEach((t) => e.map.addInteraction(t));
    }
  }
});
var i_ = [], jk = i_.forEach, Uk = i_.slice;
function Wk(e) {
  return jk.call(Uk.call(arguments, 1), function(t) {
    if (t)
      for (var n in t)
        e[n] === void 0 && (e[n] = t[n]);
  }), e;
}
var lT = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, $k = function(t, n, s) {
  var r = s || {};
  r.path = r.path || "/";
  var i = encodeURIComponent(n), a = "".concat(t, "=").concat(i);
  if (r.maxAge > 0) {
    var o = r.maxAge - 0;
    if (Number.isNaN(o))
      throw new Error("maxAge should be a Number");
    a += "; Max-Age=".concat(Math.floor(o));
  }
  if (r.domain) {
    if (!lT.test(r.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=".concat(r.domain);
  }
  if (r.path) {
    if (!lT.test(r.path))
      throw new TypeError("option path is invalid");
    a += "; Path=".concat(r.path);
  }
  if (r.expires) {
    if (typeof r.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    a += "; Expires=".concat(r.expires.toUTCString());
  }
  if (r.httpOnly && (a += "; HttpOnly"), r.secure && (a += "; Secure"), r.sameSite) {
    var l = typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite;
    switch (l) {
      case !0:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}, uT = {
  create: function(t, n, s, r) {
    var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    s && (i.expires = /* @__PURE__ */ new Date(), i.expires.setTime(i.expires.getTime() + s * 60 * 1e3)), r && (i.domain = r), document.cookie = $k(t, encodeURIComponent(n), i);
  },
  read: function(t) {
    for (var n = "".concat(t, "="), s = document.cookie.split(";"), r = 0; r < s.length; r++) {
      for (var i = s[r]; i.charAt(0) === " "; )
        i = i.substring(1, i.length);
      if (i.indexOf(n) === 0)
        return i.substring(n.length, i.length);
    }
    return null;
  },
  remove: function(t) {
    this.create(t, "", -1);
  }
}, zk = {
  name: "cookie",
  lookup: function(t) {
    var n;
    if (t.lookupCookie && typeof document < "u") {
      var s = uT.read(t.lookupCookie);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupCookie && typeof document < "u" && uT.create(n.lookupCookie, t, n.cookieMinutes, n.cookieDomain, n.cookieOptions);
  }
}, Kk = {
  name: "querystring",
  lookup: function(t) {
    var n;
    if (typeof window < "u") {
      var s = window.location.search;
      !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (s = window.location.hash.substring(window.location.hash.indexOf("?")));
      for (var r = s.substring(1), i = r.split("&"), a = 0; a < i.length; a++) {
        var o = i[a].indexOf("=");
        if (o > 0) {
          var l = i[a].substring(0, o);
          l === t.lookupQuerystring && (n = i[a].substring(o + 1));
        }
      }
    }
    return n;
  }
}, $u = null, cT = function() {
  if ($u !== null)
    return $u;
  try {
    $u = window !== "undefined" && window.localStorage !== null;
    var t = "i18next.translate.boo";
    window.localStorage.setItem(t, "foo"), window.localStorage.removeItem(t);
  } catch {
    $u = !1;
  }
  return $u;
}, Gk = {
  name: "localStorage",
  lookup: function(t) {
    var n;
    if (t.lookupLocalStorage && cT()) {
      var s = window.localStorage.getItem(t.lookupLocalStorage);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupLocalStorage && cT() && window.localStorage.setItem(n.lookupLocalStorage, t);
  }
}, zu = null, hT = function() {
  if (zu !== null)
    return zu;
  try {
    zu = window !== "undefined" && window.sessionStorage !== null;
    var t = "i18next.translate.boo";
    window.sessionStorage.setItem(t, "foo"), window.sessionStorage.removeItem(t);
  } catch {
    zu = !1;
  }
  return zu;
}, kk = {
  name: "sessionStorage",
  lookup: function(t) {
    var n;
    if (t.lookupSessionStorage && hT()) {
      var s = window.sessionStorage.getItem(t.lookupSessionStorage);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupSessionStorage && hT() && window.sessionStorage.setItem(n.lookupSessionStorage, t);
  }
}, Hk = {
  name: "navigator",
  lookup: function(t) {
    var n = [];
    if (typeof navigator < "u") {
      if (navigator.languages)
        for (var s = 0; s < navigator.languages.length; s++)
          n.push(navigator.languages[s]);
      navigator.userLanguage && n.push(navigator.userLanguage), navigator.language && n.push(navigator.language);
    }
    return n.length > 0 ? n : void 0;
  }
}, Yk = {
  name: "htmlTag",
  lookup: function(t) {
    var n, s = t.htmlTag || (typeof document < "u" ? document.documentElement : null);
    return s && typeof s.getAttribute == "function" && (n = s.getAttribute("lang")), n;
  }
}, Xk = {
  name: "path",
  lookup: function(t) {
    var n;
    if (typeof window < "u") {
      var s = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (s instanceof Array)
        if (typeof t.lookupFromPathIndex == "number") {
          if (typeof s[t.lookupFromPathIndex] != "string")
            return;
          n = s[t.lookupFromPathIndex].replace("/", "");
        } else
          n = s[0].replace("/", "");
    }
    return n;
  }
}, Zk = {
  name: "subdomain",
  lookup: function(t) {
    var n = typeof t.lookupFromSubdomainIndex == "number" ? t.lookupFromSubdomainIndex + 1 : 1, s = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (s)
      return s[n];
  }
};
function Jk() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
  };
}
var r_ = /* @__PURE__ */ function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Kr(this, e), this.type = "languageDetector", this.detectors = {}, this.init(t, n);
  }
  return Gr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = Wk(s, this.options || {}, Jk()), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = r, this.addDetector(zk), this.addDetector(Kk), this.addDetector(Gk), this.addDetector(kk), this.addDetector(Hk), this.addDetector(Yk), this.addDetector(Xk), this.addDetector(Zk);
    }
  }, {
    key: "addDetector",
    value: function(n) {
      this.detectors[n.name] = n;
    }
  }, {
    key: "detect",
    value: function(n) {
      var s = this;
      n || (n = this.options.order);
      var r = [];
      return n.forEach(function(i) {
        if (s.detectors[i]) {
          var a = s.detectors[i].lookup(s.options);
          a && typeof a == "string" && (a = [a]), a && (r = r.concat(a));
        }
      }), this.services.languageUtils.getBestMatchFromCodes ? r : r.length > 0 ? r[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function(n, s) {
      var r = this;
      s || (s = this.options.caches), s && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(n) > -1 || s.forEach(function(i) {
        r.detectors[i] && r.detectors[i].cacheUserLanguage(n, r.options);
      }));
    }
  }]), e;
}();
r_.type = "languageDetector";
var Qk = function(t) {
  return qk(t) && !t6(t);
};
function qk(e) {
  return !!e && typeof e == "object";
}
function t6(e) {
  var t = Object.prototype.toString.call(e);
  return t === "[object RegExp]" || t === "[object Date]" || i6(e);
}
var e6 = typeof Symbol == "function" && Symbol.for, n6 = e6 ? Symbol.for("react.element") : 60103;
function i6(e) {
  return e.$$typeof === n6;
}
function r6(e) {
  return Array.isArray(e) ? [] : {};
}
function df(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? Rc(r6(e), e, t) : e;
}
function s6(e, t, n) {
  return e.concat(t).map(function(s) {
    return df(s, n);
  });
}
function a6(e, t, n) {
  var s = {};
  return n.isMergeableObject(e) && Object.keys(e).forEach(function(r) {
    s[r] = df(e[r], n);
  }), Object.keys(t).forEach(function(r) {
    !n.isMergeableObject(t[r]) || !e[r] ? s[r] = df(t[r], n) : s[r] = Rc(e[r], t[r], n);
  }), s;
}
function Rc(e, t, n) {
  n = n || {}, n.arrayMerge = n.arrayMerge || s6, n.isMergeableObject = n.isMergeableObject || Qk;
  var s = Array.isArray(t), r = Array.isArray(e), i = s === r;
  return i ? s ? n.arrayMerge(e, t, n) : a6(e, t, n) : df(t, n);
}
Rc.all = function(t, n) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(s, r) {
    return Rc(s, r, n);
  }, {});
};
var dT = Rc, fT = {
  name: "i18next",
  functional: !0,
  props: {
    tag: {
      type: String,
      default: "span"
    },
    path: {
      type: String,
      required: !0
    },
    options: {
      type: Object
    }
  },
  render: function(t, n) {
    var s = n.props, r = n.data, i = n.children, a = n.parent, o = a.$i18n, l = a.$t.bind(a);
    if (!o || !l)
      return t(s.tag, r, i);
    var f = s.path, d = s.options || {}, u = o.i18next.services.interpolator.regexp, c = Object.assign(
      {},
      d,
      { interpolation: { prefix: "#$?", suffix: "?$#" } }
    ), h = l(f, c), p = [];
    return h.split(u).reduce(function(g, m, v) {
      var y;
      if (v % 2 === 0) {
        if (m.length === 0)
          return g;
        y = m;
      } else {
        var E = m.trim();
        isNaN(parseFloat(E)) || !isFinite(E) ? i.forEach(function(C) {
          !y && C.data.attrs && C.data.attrs.place && C.data.attrs.place === E && (y = C);
        }) : y = i[parseInt(m, 10)];
      }
      return g.push(y), g;
    }, p), t(s.tag, r, p);
  }
};
function s_(e) {
  typeof console < "u" && console.warn(e);
}
function ff(e) {
  s_("[vue-i18next warn]: " + e);
}
function o6(e) {
  s_("[vue-i18next deprecated]: " + e);
}
function l6(e, t) {
  var n = t.context;
  return e._i18nLanguage === n.$i18n.i18next.language;
}
function u6(e, t) {
  if (e === t)
    return !0;
  if (e && t)
    return e.path === t.path && e.language === t.language && e.args === t.args;
}
function c6(e) {
  var t = e.context;
  return t.$i18n ? !0 : (ff("No VueI18Next instance found in the Vue instance"), !1);
}
function h6(e) {
  var t, n, s, r;
  return typeof e == "string" ? n = e : toString.call(e) === "[object Object]" && (t = e, n = t.path, s = t.language, r = t.args), { path: n, language: s, args: r };
}
function a_(e, t, n) {
  var s = t.value, r = h6(s), i = r.path, a = r.language, o = r.args;
  if (!i && !a && !o) {
    ff("v-t: invalid value");
    return;
  }
  if (!i) {
    ff('v-t: "path" is required');
    return;
  }
  a && o6(`v-t: "language" is deprecated.Use the "lng" property in args.
      https://www.i18next.com/overview/configuration-options#configuration-options`);
  var l = n.context;
  e.textContent = l.$i18n.i18next.t(i, Object.assign(
    {},
    a ? { lng: a } : {},
    o
  )), e._i18nLanguage = l.$i18n.i18next.language;
}
function d6(e, t, n) {
  c6(n) && a_(e, t, n);
}
function f6(e, t, n, s) {
  l6(e, n) && u6(t.value, t.oldValue) || a_(e, t, n);
}
var p6 = {
  bind: d6,
  update: f6
};
function m6(e) {
  var t = e.context;
  return t.$i18n ? !0 : (ff("No VueI18Next instance found in the Vue instance"), !1);
}
function g6(e, t) {
  if (t.context.$i18n.i18next.isInitialized)
    e.hidden = !1;
  else {
    e.hidden = !0;
    var n = function() {
      t.context.$forceUpdate(), setTimeout(function() {
        t.context && t.context.$i18n && t.context.$i18n.i18next.off("initialized", n);
      }, 1e3);
    };
    t.context.$i18n.i18next.on("initialized", n);
  }
}
function v6(e, t, n) {
  m6(n) && g6(e, n);
}
function y6(e, t, n, s) {
  n.context.$i18n.i18next.isInitialized && (e.hidden = !1);
}
var E6 = {
  bind: v6,
  update: y6
}, Yi;
function Bv(e) {
  if (!Bv.installed) {
    Bv.installed = !0, Yi = e;
    var t = function(s, r) {
      return function(i) {
        return s && s.keyPrefix && !i.includes(r.nsSeparator) ? s.keyPrefix + "." + i : i;
      };
    }, n = function(s) {
      var r = s.$options.name || s.$options._componentTag;
      return r ? {
        namespace: r,
        loadNamespace: !0
      } : {
        namespace: "" + Math.random()
      };
    };
    Yi.mixin({
      beforeCreate: function() {
        var r = this, i = this.$options;
        i.i18n ? this._i18n = i.i18n : i.parent && i.parent.$i18n && (this._i18n = i.parent.$i18n);
        var a = {};
        if (this._i18n) {
          var o = this._i18n.options.getComponentNamespace || n, l = o(this), f = l.namespace, d = l.loadNamespace;
          if (i.__i18n && i.__i18n.forEach(function(T) {
            a = dT(
              a,
              JSON.parse(T)
            );
          }), i.i18nOptions) {
            var u = this.$options.i18nOptions, c = u.lng;
            c === void 0 && (c = null);
            var h = u.keyPrefix;
            h === void 0 && (h = null);
            var p = u.messages, g = this.$options.i18nOptions, m = g.namespaces;
            m = m || this._i18n.i18next.options.defaultNS, typeof m == "string" && (m = [m]);
            var v = m.concat([f]);
            p && (a = dT(a, p)), this._i18nOptions = { lng: c, namespaces: v, keyPrefix: h }, this._i18n.i18next.loadNamespaces(m);
          } else
            i.parent && i.parent._i18nOptions ? (this._i18nOptions = Object.assign({}, i.parent._i18nOptions), this._i18nOptions.namespaces = [
              f
            ].concat(
              this._i18nOptions.namespaces
            )) : i.__i18n && (this._i18nOptions = { namespaces: [f] });
          d && this._i18n.options.loadComponentNamespace && this._i18n.i18next.loadNamespaces([f]);
          var y = Object.keys(a);
          y.forEach(function(T) {
            r._i18n.i18next.addResourceBundle(
              T,
              f,
              Object.assign({}, a[T]),
              !0,
              !1
            );
          });
        }
        var E = t(
          this._i18nOptions,
          this._i18n ? this._i18n.i18next.options : {}
        );
        if (this._i18nOptions && this._i18nOptions.namespaces) {
          var C = this._i18nOptions, x = C.lng, b = C.namespaces, P = this._i18n.i18next.getFixedT(x, b);
          this._getI18nKey = function(T, O) {
            return P(E(T), O, r._i18n.i18nLoadedAt);
          };
        } else
          this._getI18nKey = function(T, O) {
            return r._i18n.t(E(T), O, r._i18n.i18nLoadedAt);
          };
      }
    }), Object.prototype.hasOwnProperty.call(Yi.prototype, "$i18n") || Object.defineProperty(Yi.prototype, "$i18n", {
      get: function() {
        return this._i18n;
      }
    }), Yi.prototype.$t = function(r, i) {
      return this._getI18nKey(r, i);
    }, Yi.component(fT.name, fT), Yi.directive("t", p6), Yi.directive("waitForT", E6);
  }
}
var aa = function(t, n) {
  n === void 0 && (n = {});
  var s = Object.assign(
    {},
    {
      bindI18n: "languageChanged loaded",
      bindStore: "added removed",
      loadComponentNamespace: !1
    },
    n
  );
  this._vm = null, this.i18next = t, this.options = s, this.onI18nChanged = this.onI18nChanged.bind(this), s.bindI18n && this.i18next.on(s.bindI18n, this.onI18nChanged), s.bindStore && this.i18next.store && this.i18next.store.on(s.bindStore, this.onI18nChanged), this.resetVM({ i18nLoadedAt: /* @__PURE__ */ new Date() });
}, yE = { i18nLoadedAt: { configurable: !0 } };
aa.prototype.resetVM = function(t) {
  var n = this._vm, s = Yi.config, r = s.silent;
  Yi.config.silent = !0, this._vm = new Yi({ data: t }), Yi.config.silent = r, n && Yi.nextTick(function() {
    return n.$destroy();
  });
};
yE.i18nLoadedAt.get = function() {
  return this._vm.$data.i18nLoadedAt;
};
yE.i18nLoadedAt.set = function(e) {
  this._vm.$set(this._vm, "i18nLoadedAt", e);
};
aa.prototype.t = function(t, n) {
  return this.i18next.t(t, n);
};
aa.prototype.onI18nChanged = function() {
  this.i18nLoadedAt = /* @__PURE__ */ new Date();
};
Object.defineProperties(aa.prototype, yE);
aa.install = Bv;
aa.version = "0.15.2";
typeof window < "u" && window.Vue && window.Vue.use(aa);
const C6 = {
  common: {
    canvas: {
      label: "Kartenanwendung"
    },
    error: {
      serviceUnavailable: 'Der Kartendienst "{{serviceName}}" (ID: {{serviceId}}) ist derzeit nicht verfügbar. Dies kann die Funktionalität der Karte einschränken.'
    },
    overlay: {
      noControlOnZoom: "Verwenden Sie Strg+Scrollen zum Zoomen der Karte",
      oneFingerPan: "Verwenden Sie mindestens zwei Finger zum Verschieben der Karte"
    }
  }
}, x6 = {
  common: {
    canvas: {
      label: "Map application"
    },
    error: {
      serviceUnavailable: `Service  "{{serviceName}}" (ID: {{serviceId}}) is unavailable. This may limit the map's functionality.`
    },
    overlay: {
      noControlOnZoom: "Use Ctrl+Mousewheel to zoom into the map",
      oneFingerPan: "Use at least two fingers to pan the map"
    }
  }
};
bk(r_);
$t.use(aa);
function b6(e) {
  return xk({
    resources: { de: C6, en: x6 },
    detection: {
      lookupQuerystring: "lng",
      order: ["querystring", "navigator", "htmlTag"]
    },
    load: "languageOnly",
    fallbackLng: "de",
    fallbackNS: "common",
    ns: ["common"],
    supportedLngs: ["de", "en"],
    ...e ? { lng: e } : {}
  }).then(() => {
    console.info("i18next: Successfully initialized.");
  }).catch((t) => {
    console.error("i18next: Error while initializing.", t);
  }), new aa(xn);
}
function O6(e) {
  return Array.isArray(e.layers) ? e.layers : typeof e.layerConf > "u" || e.layerConf === fi.layerConf ? fi.layers : [];
}
let T6 = 0;
const P6 = {
  wms: j1,
  wmts: Z1,
  wfs: gM,
  geojson: xM,
  vectorBase: bM,
  vectortile: YM,
  oaf: JM
}, pT = Xs.prototype.addLayer;
function o_(e) {
  return e.getLayers ? e.getLayers().getArray().map((t) => o_(t)).flat(1) : [e];
}
function mT(e, t) {
  o_(e).forEach((s) => {
    var i, a, o, l, f;
    const r = (i = s.getSource) == null ? void 0 : i.call(s);
    r ? ((a = r.on) == null || a.call(r, "tileloaderror", t), (o = r.on) == null || o.call(r, "imageloaderror", t), (l = r.on) == null || l.call(r, "featuresloaderror", t), (f = r.on) == null || f.call(r, "error", t)) : console.error("Could not register error callback on layer:", s);
  });
}
function M6(e, t = { visibility: !0, transparency: 0, errorCallback: console.error }) {
  const n = typeof t.errorCallback == "function" ? t.errorCallback : console.error;
  let s, r;
  if (typeof e == "string") {
    const i = Ka({ id: e });
    return i ? (r = P6[i.typ.toLowerCase()], r ? (s = r.createLayer(i, {}, { map: this }), s.setVisible(typeof t.visibility == "boolean" ? t.visibility : !0), s.setOpacity(typeof t.transparency == "number" ? (100 - t.transparency) / 100 : 1), mT(s, n), pT.call(this, s), s) : (console.error("Layer with id '" + e + "' has unknown type '" + i.typ + "'. No layer added to map."), null)) : (console.error("Layer with id '" + e + "' not found. No layer added to map."), null);
  }
  return mT(e, n), pT.call(this, e);
}
Xs.prototype.addLayer = M6;
function S6(e = fi, { mapParams: t, callback: n, errorCallback: s } = {}) {
  O1(e.namedProjections), yS(e), z0(e.gazetteerUrl);
  const r = new Xs(Object.assign({
    target: e.target || fi.target,
    interactions: By({ altShiftDragRotate: !1, pinchRotate: !1 }),
    controls: [],
    view: QP(e)
  }, t));
  return r.set("mapMode", "2D"), r.set("id", `map2D_${T6++}`), T1(e.layerConf, (i, a) => (O6(e).forEach((o) => {
    r.addLayer(o.id, { errorCallback: s });
  }), typeof n == "function" ? n(i, a) : null)), r;
}
const en = {};
en.obj = function(e) {
  return e;
};
en.supportsImageRenderingPixelatedResult_ = void 0;
en.imageRenderingValueResult_ = void 0;
en.supportsImageRenderingPixelated = function() {
  if (en.supportsImageRenderingPixelatedResult_ === void 0) {
    const e = document.createElement("canvas");
    e.setAttribute("style", "image-rendering: -moz-crisp-edges; image-rendering: pixelated;");
    const t = e.style.imageRendering;
    en.supportsImageRenderingPixelatedResult_ = !!t, en.supportsImageRenderingPixelatedResult_ && (en.imageRenderingValueResult_ = t);
  }
  return en.supportsImageRenderingPixelatedResult_;
};
en.imageRenderingValue = function() {
  return en.supportsImageRenderingPixelated(), en.imageRenderingValueResult_ || "";
};
en.getSourceProjection = function(e) {
  return (
    /** @type {ol.proj.Projection} */
    e.get("olcs.projection") || e.getProjection()
  );
};
function Vl(e, t, n) {
  return (
    /** @type {!ol.events.EventsKey} */
    e.on(t, n)
  );
}
let I6 = 0;
function Qe(e) {
  return e.olcs_uid || (e.olcs_uid = ++I6);
}
function _6(e, t) {
  const n = e.length, s = Array(e.length);
  for (let r = 0; r < n; r++)
    s[r] = { index: r, value: e[r] };
  s.sort((r, i) => t(r.value, i.value) || r.index - i.index);
  for (let r = 0; r < e.length; r++)
    e[r] = s[r].value;
}
function D6(e) {
  return e && e.parentNode ? e.parentNode.removeChild(e) : null;
}
function A6(e) {
  for (; e.lastChild; )
    e.removeChild(e.lastChild);
}
function ig(e) {
  const t = Cesium.GroundPolylinePrimitive;
  return t && t.isSupported(e);
}
class L6 extends V1 {
  /**
   * @param {Options} options ImageStatic options.
   */
  constructor(t) {
    const n = t.crossOrigin !== void 0 ? t.crossOrigin : null, s = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : Zy;
    super({
      attributions: t.attributions,
      interpolate: t.interpolate,
      projection: Wt(t.projection)
    }), this.url_ = t.url, this.imageExtent_ = t.imageExtent, this.image_ = new MP(
      this.imageExtent_,
      void 0,
      1,
      this.url_,
      n,
      s
    ), this.imageSize_ = t.imageSize ? t.imageSize : null, this.image_.addEventListener(
      Kt.CHANGE,
      this.handleImageChange.bind(this)
    );
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  getImageExtent() {
    return this.imageExtent_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(t, n, s, r) {
    return cn(t, this.image_.getExtent()) ? this.image_ : null;
  }
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */
  handleImageChange(t) {
    if (this.image_.getState() == ce.LOADED) {
      const n = this.image_.getExtent(), s = this.image_.getImage();
      let r, i;
      this.imageSize_ ? (r = this.imageSize_[0], i = this.imageSize_[1]) : (r = s.width, i = s.height);
      const a = ye(n), o = In(n), l = a / r, f = o / i;
      let d = r, u = i;
      if (l > f ? d = Math.round(a / f) : u = Math.round(o / l), d !== r || u !== i) {
        const c = Ii(d, u);
        this.getInterpolate() || (c.imageSmoothingEnabled = !1);
        const h = c.canvas;
        c.drawImage(
          s,
          0,
          0,
          r,
          i,
          0,
          0,
          h.width,
          h.height
        ), this.image_.setImage(h);
      }
    }
    super.handleImageChange(t);
  }
}
const l_ = L6, R6 = function() {
  const t = new A1({
    projection: "EPSG:3857",
    wrapX: !0
  }).getTileCoordForTileUrlFunction([6, -31, 22]);
  return t && t[1] === 33 && t[2] === 22;
}();
class u_ {
  /**
   * Special class derived from Cesium.ImageryProvider
   * that is connected to the given ol.source.TileImage.
   * @param {!ol.Map} olMap
   * @param {!ol.source.TileImage} source
   * @param {ol.proj.Projection=} opt_fallbackProj Projection to assume if the
   *                                               projection of the source is not defined.
   * @constructor
   * @extends {Cesium.ImageryProvider}
   */
  constructor(t, n, s) {
    this.source_ = n, this.projection_ = null, this.fallbackProj_ = s || null, this.ready_ = !1, this.tilingScheme_ = null, this.rectangle_ = null, this.map_ = t, this.shouldRequestNextLevel = !1;
    const r = this.source_.get("olcs.proxy");
    r && (typeof r == "function" ? this.proxy_ = {
      getURL: r
    } : typeof r == "string" && (this.proxy_ = new Cesium.DefaultProxy(r))), this.errorEvent_ = new Cesium.Event(), this.emptyCanvas_ = document.createElement("canvas"), this.emptyCanvas_.width = 1, this.emptyCanvas_.height = 1, this.source_.on("change", (i) => {
      this.handleSourceChanged_();
    }), this.handleSourceChanged_();
  }
  /**
   * Checks if the underlying source is ready and cached required data.
   * @private
   */
  handleSourceChanged_(t) {
    if (!this.ready_ && this.source_.getState() == "ready") {
      this.projection_ = en.getSourceProjection(this.source_) || this.fallbackProj_;
      const n = { numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1 };
      if (this.source_.tileGrid !== null && this.source_.tileGrid.forEachTileCoord(this.projection_.getExtent(), 0, ([s, r, i]) => {
        n.numberOfLevelZeroTilesX = r + 1, n.numberOfLevelZeroTilesY = i + 1;
      }), this.projection_.getCode() === "EPSG:4326")
        this.shouldRequestNextLevel = n.numberOfLevelZeroTilesX === 1 && n.numberOfLevelZeroTilesY === 1, this.tilingScheme_ = new Cesium.GeographicTilingScheme(n);
      else if (this.projection_.getCode() === "EPSG:3857")
        this.shouldRequestNextLevel = !1, this.tilingScheme_ = new Cesium.WebMercatorTilingScheme(n);
      else
        return;
      this.rectangle_ = this.tilingScheme_.rectangle, this.ready_ = !0;
    }
  }
  /**
   * Generates the proper attributions for a given position and zoom
   * level.
   * @export
   * @override
   */
  getTileCredits(t, n, s) {
    const r = this.source_.getAttributions();
    if (!r)
      return [];
    const i = this.map_.getView().calculateExtent(this.map_.getSize()), a = this.map_.getView().getCenter(), o = this.shouldRequestNextLevel ? s + 1 : s;
    return c_(r, o, a, i);
  }
  /**
   * @export
   * @override
   */
  requestImage(t, n, s) {
    const r = this.source_.getTileUrlFunction();
    if (r && this.projection_) {
      const i = this.shouldRequestNextLevel ? s + 1 : s;
      let a = n;
      R6 || (a = -n - 1);
      let o = r.call(this.source_, [i, t, a], 1, this.projection_);
      return this.proxy_ && (o = this.proxy_.getURL(o)), o ? Cesium.ImageryProvider.loadImage(this, o) : this.emptyCanvas_;
    } else
      return this.emptyCanvas_;
  }
}
Object.defineProperties(u_.prototype, {
  ready: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.ready_;
      }
    )
  },
  rectangle: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.rectangle_;
      }
    )
  },
  tileWidth: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? Array.isArray(e.getTileSize(0)) ? e.getTileSize(0)[0] : e.getTileSize(0) : 256;
      }
    )
  },
  tileHeight: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? Array.isArray(e.getTileSize(0)) ? e.getTileSize(0)[1] : e.getTileSize(0) : 256;
      }
    )
  },
  maximumLevel: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? e.getMaxZoom() : 18;
      }
    )
  },
  minimumLevel: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return 0;
      }
    )
  },
  tilingScheme: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.tilingScheme_;
      }
    )
  },
  tileDiscardPolicy: {
    get: function() {
    }
  },
  errorEvent: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.errorEvent_;
      }
    )
  },
  proxy: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.proxy_;
      }
    )
  },
  hasAlphaChannel: {
    get: function() {
      return !0;
    }
  },
  pickFeatures: {
    get: function() {
    }
  }
});
const w6 = new rM(), V6 = [new zn({
  stroke: new pr({
    color: "blue",
    width: 2
  })
})];
class B6 {
  constructor(t) {
    this.urls = t.urls, this.ready = !0, this.readyPromise = Promise.resolve(!0), this.tileWidth = 256, this.tileHeight = 256, this.maximumLevel = t.maximumLevel || 20, this.minimumLevel = t.minimumLevel || 0, this.tilingScheme = new Cesium.WebMercatorTilingScheme(), this.rectangle = t.rectangle || this.tilingScheme.rectangle, this.errorEvent = new Cesium.Event(), this.credit = t.credit, this.hasAlphaChannel = !0, this.styleFunction_ = t.styleFunction || (() => V6), this.projection_ = Wt("EPSG:3857"), this.emptyCanvas_ = document.createElement("canvas"), this.emptyCanvas_.width = 1, this.emptyCanvas_.height = 1, this.tileRectangle_ = new Cesium.Rectangle();
    const n = t.cacheSize !== void 0 ? t.cacheSize : 50;
    this.tileCache = new Ug(n), this.featureCache = t.featureCache || new Ug(n);
    const s = ky(this.projection_);
    this.tileFunction_ = L1(this.urls, s);
  }
  getTileCredits() {
    return [];
  }
  pickFeatures() {
  }
  getTileFeatures(t, n, s) {
    const r = this.getCacheKey_(t, n, s);
    let i;
    if (this.featureCache.containsKey(r) && (i = this.featureCache.get(r)), !i) {
      const a = this.getUrl_(t, n, s);
      if (i = fetch(a).then((o) => o.ok ? o : Promise.reject(o)).then((o) => o.arrayBuffer()).then((o) => this.readFeaturesFromBuffer(o)), this.featureCache.set(r, i), this.featureCache.getCount() > 2 * this.featureCache.highWaterMark)
        for (; this.featureCache.canExpireCache(); )
          this.featureCache.pop();
    }
    return i;
  }
  readFeaturesFromBuffer(t) {
    let n;
    const s = w6.readFeatures(t, n), r = this.tileWidth / 4096;
    return s.forEach((i) => {
      const a = i.getFlatCoordinates();
      for (let o = 0; o < a.length; ++o)
        a[o] *= r;
    }), s;
  }
  getUrl_(t, n, s) {
    return this.tileFunction_([t, n, s]);
  }
  getCacheKey_(t, n, s) {
    return `${t}_${n}_${s}`;
  }
  requestImage(t, n, s, r) {
    if (s < this.minimumLevel)
      return this.emptyCanvas_;
    try {
      const i = this.getCacheKey_(s, t, n);
      let a;
      if (this.tileCache.containsKey(i) && (a = this.tileCache.get(i)), !a && (a = this.getTileFeatures(s, t, n).then((o) => {
        this.tilingScheme.tileXYToNativeRectangle(t, n, s, this.tileRectangle_);
        const l = (this.tileRectangle_.east - this.tileRectangle_.west) / this.tileWidth;
        return this.rasterizeFeatures(o, this.styleFunction_, l);
      }), this.tileCache.set(i, a), this.tileCache.getCount() > 2 * this.tileCache.highWaterMark))
        for (; this.tileCache.canExpireCache(); )
          this.tileCache.pop();
      return a;
    } catch (i) {
      console.trace(i), this.raiseEvent("could not render pbf to tile", i);
    }
  }
  rasterizeFeatures(t, n, s) {
    const r = document.createElement("canvas"), i = fL(r.getContext("2d"), { size: [this.tileWidth, this.tileHeight] });
    return t.forEach((a) => {
      const o = n(a, s);
      o && o.forEach((l) => {
        i.setStyle(l), i.drawGeometry(a);
      });
    }), r;
  }
}
const Vt = {};
Vt.computePixelSizeAtCoordinate = function(e, t) {
  const n = e.camera, s = e.canvas, r = n.frustum, i = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(
    n.position,
    t,
    new Cesium.Cartesian3()
  ));
  return r.getPixelDimensions(
    s.clientWidth,
    s.clientHeight,
    i,
    e.pixelRatio,
    new Cesium.Cartesian2()
  );
};
Vt.computeBoundingBoxAtTarget = function(e, t, n) {
  const s = Vt.computePixelSizeAtCoordinate(e, t), r = Cesium.Transforms.eastNorthUpToFixedFrame(t), i = Cesium.Matrix4.multiplyByPoint(
    r,
    new Cesium.Cartesian3(-s.x * n, -s.y * n, 0),
    new Cesium.Cartesian3()
  ), a = Cesium.Matrix4.multiplyByPoint(
    r,
    new Cesium.Cartesian3(s.x * n, s.y * n, 0),
    new Cesium.Cartesian3()
  );
  return Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(
    [i, a]
  );
};
Vt.applyHeightOffsetToGeometry = function(e, t) {
  e.applyTransform((n, s, r) => {
    if (console.assert(n === s), r !== void 0 && r >= 3)
      for (let i = 0; i < s.length; i += r)
        s[i + 2] = s[i + 2] + t;
    return s;
  });
};
Vt.createMatrixAtCoordinates = function(e, t = 0, n = Cesium.Cartesian3.ZERO, s = new Cesium.Cartesian3(1, 1, 1)) {
  const r = Vt.ol4326CoordinateToCesiumCartesian(e), i = Cesium.Transforms.eastNorthUpToFixedFrame(r), a = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -t), o = Cesium.Matrix4.fromTranslationQuaternionRotationScale(n, a, s);
  return Cesium.Matrix4.multiply(i, o, new Cesium.Matrix4());
};
Vt.rotateAroundAxis = function(e, t, n, s, r) {
  const i = Cesium.Math.clamp, a = Cesium.defaultValue, o = r || {}, l = a(o.duration, 500), f = a(o.easing, FP), d = o.callback;
  let u = 0;
  const c = new Cesium.Matrix4(), h = Date.now(), p = function() {
    const m = Date.now() - h, v = f(i(m / l, 0, 1));
    console.assert(v >= u), e.transform.clone(c);
    const y = (v - u) * t;
    u = v, e.lookAtTransform(s), e.rotate(n, y), e.lookAtTransform(c), v < 1 ? window.requestAnimationFrame(p) : d && d();
  };
  window.requestAnimationFrame(p);
};
Vt.setHeadingUsingBottomCenter = function(e, t, n, s) {
  const r = e.camera, i = Vt.computeAngleToZenith(e, n), a = r.right, o = Cesium.Quaternion.fromAxisAngle(a, i), l = Cesium.Matrix3.fromQuaternion(o), f = new Cesium.Cartesian3();
  Cesium.Cartesian3.subtract(r.position, n, f);
  const d = new Cesium.Cartesian3();
  Cesium.Matrix3.multiplyByVector(l, f, d), Cesium.Cartesian3.add(d, n, d);
  const u = Cesium.Matrix4.fromTranslation(d), c = Vt.rotateAroundAxis;
  c(r, t, d, u, s);
};
Vt.pickOnTerrainOrEllipsoid = function(e, t) {
  const n = e.camera.getPickRay(t);
  return e.globe.pick(n, e) || e.camera.pickEllipsoid(t);
};
Vt.pickBottomPoint = function(e) {
  const t = e.canvas, n = new Cesium.Cartesian2(
    t.clientWidth / 2,
    t.clientHeight
  );
  return Vt.pickOnTerrainOrEllipsoid(e, n);
};
Vt.pickCenterPoint = function(e) {
  const t = e.canvas, n = new Cesium.Cartesian2(
    t.clientWidth / 2,
    t.clientHeight / 2
  );
  return Vt.pickOnTerrainOrEllipsoid(e, n);
};
Vt.computeSignedTiltAngleOnGlobe = function(e) {
  const t = e.camera, n = new Cesium.Ray(t.position, t.direction);
  let s = e.globe.pick(n, e);
  if (!s) {
    const o = Cesium.Ellipsoid.WGS84, l = Cesium.IntersectionTests.rayEllipsoid(n, o);
    l && (s = Cesium.Ray.getPoint(n, l.start));
  }
  if (!s)
    return;
  const r = new Cesium.Cartesian3();
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(s, r);
  const i = Vt.signedAngleBetween, a = i(t.direction, r, t.right) - Math.PI;
  return Cesium.Math.convertLongitudeRange(a);
};
Vt.bottomFovRay = function(e) {
  const t = e.camera, n = t.frustum.fovy / 2, s = t.direction, r = Cesium.Quaternion.fromAxisAngle(t.right, n), i = Cesium.Matrix3.fromQuaternion(r), a = new Cesium.Cartesian3();
  return Cesium.Matrix3.multiplyByVector(i, s, a), new Cesium.Ray(t.position, a);
};
Vt.signedAngleBetween = function(e, t, n) {
  const s = new Cesium.Cartesian3(), r = new Cesium.Cartesian3(), i = new Cesium.Cartesian3();
  Cesium.Cartesian3.normalize(e, s), Cesium.Cartesian3.normalize(t, r), Cesium.Cartesian3.cross(s, r, i);
  const a = Cesium.Cartesian3.dot(s, r), o = Cesium.Cartesian3.magnitude(i), l = Cesium.Cartesian3.dot(n, i), f = Math.atan2(o, a);
  return l >= 0 ? f : -f;
};
Vt.computeAngleToZenith = function(e, t) {
  const n = e.camera, s = n.frustum.fovy / 2, r = Vt.bottomFovRay(e), i = Cesium.Cartesian3.clone(r.direction);
  Cesium.Cartesian3.negate(i, i);
  const a = new Cesium.Cartesian3();
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(t, a);
  const o = new Cesium.Cartesian3();
  return Cesium.Cartesian3.negate(n.right, o), Vt.signedAngleBetween(a, i, o) + s;
};
Vt.extentToRectangle = function(e, t) {
  if (e && t) {
    const n = Fc(e, t, "EPSG:4326");
    return Cesium.Rectangle.fromDegrees(n[0], n[1], n[2], n[3]);
  } else
    return null;
};
Vt.sourceToImageryProvider = function(e, t, n, s) {
  const r = t.get("olcs_skip");
  if (r)
    return null;
  let i = null;
  if (t instanceof Jy && t.getUrl() && t.getImageLoadFunction() === Zy) {
    const a = {
      "olcs.proxy": t.get("olcs.proxy"),
      "olcs.extent": t.get("olcs.extent"),
      "olcs.projection": t.get("olcs.projection"),
      "olcs.imagesource": t
    };
    t = new Xy({
      url: t.getUrl(),
      attributions: t.getAttributions(),
      projection: t.getProjection(),
      params: t.getParams()
    }), t.setProperties(a);
  }
  if (t instanceof Yy) {
    let a = en.getSourceProjection(t);
    if (a || (a = n), Vt.isCesiumProjection(a))
      i = new u_(e, t, n);
    else
      return null;
  } else if (t instanceof l_) {
    let a = en.getSourceProjection(t);
    if (a || (a = n), Vt.isCesiumProjection(a))
      i = new Cesium.SingleTileImageryProvider({
        url: t.getUrl(),
        rectangle: new Cesium.Rectangle.fromDegrees(
          t.getImageExtent()[0],
          t.getImageExtent()[1],
          t.getImageExtent()[2],
          t.getImageExtent()[3]
        )
      });
    else
      return null;
  } else if (t instanceof OM) {
    let a = en.getSourceProjection(t);
    if (a || (a = n), r === !1) {
      const o = a.getCode().split(":")[1], l = t.urls.map((g) => g.replace(o, "3857")), f = s.getExtent(), d = Vt.extentToRectangle(f, a), u = t.get("olcs_minimumLevel"), c = t.getAttributions(), h = s.getStyleFunction();
      let p;
      if (f && c) {
        const g = Fi(f);
        p = c_(c, 0, g, f)[0];
      }
      return i = new B6({
        credit: p,
        rectangle: d,
        minimumLevel: u,
        styleFunction: h,
        urls: l
      }), i;
    }
    return null;
  } else
    return null;
  return i;
};
Vt.tileLayerToImageryLayer = function(e, t, n) {
  if (!(t instanceof kc) && !(t instanceof Rf) && !(t instanceof p0))
    return null;
  const s = t.getSource();
  if (!s)
    return null;
  let r = s.get("olcs_provider");
  if (r || (r = this.sourceToImageryProvider(e, s, n, t)), !r)
    return null;
  const i = {}, o = /** @type {ol.Extent} */ t.get("olcs.extent") || t.getExtent();
  return o && (i.rectangle = Vt.extentToRectangle(o, n)), new Cesium.ImageryLayer(r, i);
};
Vt.updateCesiumLayerProperties = function(e, t) {
  let n = 1, s = !0;
  [e.layer].concat(e.parents).forEach((r) => {
    const i = r.getOpacity();
    i !== void 0 && (n *= i);
    const a = r.getVisible();
    a !== void 0 && (s &= a);
  }), t.alpha = n, t.show = s;
};
Vt.ol4326CoordinateToCesiumCartesian = function(e) {
  const t = e;
  return t.length > 2 ? Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2]) : Cesium.Cartesian3.fromDegrees(t[0], t[1]);
};
Vt.ol4326CoordinateArrayToCsCartesians = function(e) {
  console.assert(e !== null);
  const t = Vt.ol4326CoordinateToCesiumCartesian, n = [];
  for (let s = 0; s < e.length; ++s)
    n.push(t(e[s]));
  return n;
};
Vt.olGeometryCloneTo4326 = function(e, t) {
  console.assert(t);
  const n = Wt("EPSG:4326"), s = Wt(t);
  if (s.getCode() !== n.getCode()) {
    const r = e.getProperties();
    e = e.clone(), e.transform(s, n), e.setProperties(r);
  }
  return e;
};
Vt.convertColorToCesium = function(e) {
  if (e = e || "black", Array.isArray(e))
    return new Cesium.Color(
      Cesium.Color.byteToFloat(e[0]),
      Cesium.Color.byteToFloat(e[1]),
      Cesium.Color.byteToFloat(e[2]),
      e[3]
    );
  if (typeof e == "string")
    return Cesium.Color.fromCssColorString(e);
  if (e instanceof CanvasPattern || e instanceof CanvasGradient) {
    const t = document.createElement("canvas"), n = t.getContext("2d");
    return t.width = t.height = 256, n.fillStyle = e, n.fillRect(0, 0, t.width, t.height), new Cesium.ImageMaterialProperty({
      image: t
    });
  }
  console.assert(!1, "impossible");
};
Vt.convertUrlToCesium = function(e) {
  let t = "";
  const n = /\{(\d|[a-z])-(\d|[a-z])\}/, s = n.exec(e);
  if (s) {
    e = e.replace(n, "{s}");
    const r = s[1].charCodeAt(0), i = s[2].charCodeAt(0);
    let a;
    for (a = r; a <= i; ++a)
      t += String.fromCharCode(a);
  }
  return {
    url: e,
    subdomains: t
  };
};
Vt.resetToNorthZenith = function(e, t) {
  return new Promise((n, s) => {
    const r = t.camera, i = Vt.pickBottomPoint(t);
    if (!i) {
      s("Could not get bottom pivot");
      return;
    }
    const a = e.getView().getRotation();
    if (a === void 0) {
      s("The view is not initialized");
      return;
    }
    const o = Vt.computeAngleToZenith(t, i);
    Vt.setHeadingUsingBottomCenter(t, a, i);
    const l = Cesium.Matrix4.fromTranslation(i), f = r.right, d = {
      callback: () => {
        const u = e.getView();
        Vt.normalizeView(u), n();
      }
    };
    Vt.rotateAroundAxis(r, -o, f, l, d);
  });
};
Vt.rotateAroundBottomCenter = function(e, t) {
  return new Promise((n, s) => {
    const r = e.camera, i = Vt.pickBottomPoint(e);
    if (!i) {
      s("could not get bottom pivot");
      return;
    }
    const a = { callback: n }, o = Cesium.Matrix4.fromTranslation(i), l = r.right, f = Vt.rotateAroundAxis;
    f(r, -t, l, o, a);
  });
};
Vt.normalizeView = function(e, t = 0) {
  const n = e.getResolution();
  e.setRotation(t), e.constrainResolution ? e.setResolution(e.constrainResolution(n)) : e.setResolution(e.getConstrainedResolution(n));
};
Vt.isCesiumProjection = function(e) {
  const t = e.getCode() === "EPSG:3857", n = e.getCode() === "EPSG:4326";
  return t || n;
};
function c_(e, t, n, s) {
  const r = {
    viewState: { zoom: t, center: n },
    extent: s
  };
  if (!e)
    return [];
  let i = e(r);
  return Array.isArray(i) || (i = [i]), i.map((a) => new Cesium.Credit(a, !0));
}
function N6(e, t, n, s) {
  const r = n.canvas, a = n.camera.frustum.fovy;
  console.assert(!isNaN(a));
  const o = s.getMetersPerUnit(), l = e * r.clientHeight, f = Math.cos(Math.abs(t));
  return l * o * f / 2 / Math.tan(a / 2);
}
function F6(e, t, n, s) {
  const r = n.canvas, a = n.camera.frustum.fovy;
  console.assert(!isNaN(a));
  const o = s.getMetersPerUnit(), l = 2 * e * Math.tan(a / 2), f = Math.cos(Math.abs(t));
  return l / o / f / r.clientHeight;
}
class j6 {
  /**
   * @constructor
   * @param {olcs.OLCesium} ol3d
   */
  constructor(t) {
    this.ol3d = t, this.scene_ = t.getCesiumScene(), this.canvas_ = this.scene_.canvas, this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this), this.repaintEventNames_ = [
      "mousemove",
      "mousedown",
      "mouseup",
      "touchstart",
      "touchend",
      "touchmove",
      "pointerdown",
      "pointerup",
      "pointermove",
      "wheel"
    ], this.enable();
  }
  /**
   * Enable.
   */
  enable() {
    this.scene_.requestRenderMode = !0, this.scene_.maximumRenderTimeChange = 1e3;
    for (const t of this.repaintEventNames_)
      this.canvas_.addEventListener(t, this._boundNotifyRepaintRequired, !1);
    window.addEventListener("resize", this._boundNotifyRepaintRequired, !1), this.ol3d.getOlMap().getLayerGroup().on("change", this._boundNotifyRepaintRequired);
  }
  /**
   * Disable.
   */
  disable() {
    for (const t of this.repaintEventNames_)
      this.canvas_.removeEventListener(t, this._boundNotifyRepaintRequired, !1);
    window.removeEventListener("resize", this._boundNotifyRepaintRequired, !1), this.ol3d.getOlMap().getLayerGroup().un("change", this._boundNotifyRepaintRequired), this.scene_.requestRenderMode = !1;
  }
  /**
   * Restart render loop.
   * Force a restart of the render loop.
   * @api
   */
  restartRenderLoop() {
    this.notifyRepaintRequired();
  }
  notifyRepaintRequired() {
    this.scene_.requestRender();
  }
}
function Qh(e) {
  return e * 180 / Math.PI;
}
function Ku(e) {
  return e * Math.PI / 180;
}
class Bl {
  /**
   * This object takes care of additional 3d-specific properties of the view and
   * ensures proper synchronization with the underlying raw Cesium.Camera object.
   * @param {!Cesium.Scene} scene
   * @param {!ol.Map} map
   * @api
   */
  constructor(t, n) {
    this.scene_ = t, this.cam_ = t.camera, this.map_ = n, this.view_ = null, this.viewListenKey_ = null, this.toLonLat_ = Bl.identityProjection, this.fromLonLat_ = Bl.identityProjection, this.tilt_ = 0, this.distance_ = 0, this.lastCameraViewMatrix_ = null, this.viewUpdateInProgress_ = !1, this.map_.on("change:view", (s) => {
      this.setView_(this.map_.getView());
    }), this.setView_(this.map_.getView());
  }
  /**
   * @param {Array.<number>} input Input coordinate array.
   * @param {Array.<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array.<number>} Input coordinate array (same array as input).
   */
  static identityProjection(t, n, s) {
    const r = s || t.length;
    if (n)
      for (let i = 0; i < r; ++i)
        n[i] = t[i];
    return t;
  }
  /**
   * @param {?ol.View} view New view to use.
   * @private
   */
  setView_(t) {
    if (this.view_ && (Fs(this.viewListenKey_), this.viewListenKey_ = null), this.view_ = t, t) {
      const n = ja(t.getProjection(), "EPSG:4326"), s = ja("EPSG:4326", t.getProjection());
      console.assert(n && s), this.toLonLat_ = n, this.fromLonLat_ = s, this.viewListenKey_ = t.on("propertychange", (r) => this.handleViewEvent_(r)), this.readFromView();
    } else
      this.toLonLat_ = Bl.identityProjection, this.fromLonLat_ = Bl.identityProjection;
  }
  /**
   * @param {?} e
   * @private
   */
  handleViewEvent_(t) {
    this.viewUpdateInProgress_ || this.readFromView();
  }
  /**
   * @param {number} heading In radians.
   * @api
   */
  setHeading(t) {
    this.view_ && this.view_.setRotation(t);
  }
  /**
   * @return {number|undefined} Heading in radians.
   * @api
   */
  getHeading() {
    return this.view_ ? this.view_.getRotation() || 0 : void 0;
  }
  /**
   * @param {number} tilt In radians.
   * @api
   */
  setTilt(t) {
    this.tilt_ = t, this.updateCamera_();
  }
  /**
   * @return {number} Tilt in radians.
   * @api
   */
  getTilt() {
    return this.tilt_;
  }
  /**
   * @param {number} distance In meters.
   * @api
   */
  setDistance(t) {
    this.distance_ = t, this.updateCamera_(), this.updateView();
  }
  /**
   * @return {number} Distance in meters.
   * @api
   */
  getDistance() {
    return this.distance_;
  }
  /**
   * Shortcut for ol.View.setCenter().
   * @param {!ol.Coordinate} center Same projection as the ol.View.
   * @api
   */
  setCenter(t) {
    this.view_ && this.view_.setCenter(t);
  }
  /**
   * Shortcut for ol.View.getCenter().
   * @return {ol.Coordinate|undefined} Same projection as the ol.View.
   * @api
   */
  getCenter() {
    if (this.view_)
      return this.view_.getCenter();
  }
  /**
   * Sets the position of the camera.
   * @param {!ol.Coordinate} position Same projection as the ol.View.
   * @api
   */
  setPosition(t) {
    if (!this.toLonLat_)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = new Cesium.Cartographic(
      Ku(n[0]),
      Ku(n[1]),
      this.getAltitude()
    );
    this.cam_.setView({
      destination: Cesium.Ellipsoid.WGS84.cartographicToCartesian(s)
    }), this.updateView();
  }
  /**
   * Calculates position under the camera.
   * @return {!ol.Coordinate|undefined} Same projection as the ol.View.
   * @api
   */
  getPosition() {
    if (!this.fromLonLat_)
      return;
    const t = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position), n = this.fromLonLat_([
      Qh(t.longitude),
      Qh(t.latitude)
    ]);
    return console.assert(n), n;
  }
  /**
   * @param {number} altitude In meters.
   * @api
   */
  setAltitude(t) {
    const n = Cesium.Ellipsoid.WGS84.cartesianToCartographic(
      this.cam_.position
    );
    n.height = t, this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(n), this.updateView();
  }
  /**
   * @return {number} Altitude in meters.
   * @api
   */
  getAltitude() {
    return Cesium.Ellipsoid.WGS84.cartesianToCartographic(
      this.cam_.position
    ).height;
  }
  /**
   * Updates the state of the underlying Cesium.Camera
   * according to the current values of the properties.
   * @private
   */
  updateCamera_() {
    if (!this.view_ || !this.toLonLat_)
      return;
    const t = this.view_.getCenter();
    if (!t)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = new Cesium.Cartographic(
      Ku(n[0]),
      Ku(n[1])
    );
    if (this.scene_.globe) {
      const a = this.scene_.globe.getHeight(s);
      s.height = a || 0;
    }
    const r = Cesium.Ellipsoid.WGS84.cartographicToCartesian(s), i = {
      pitch: this.tilt_ - Cesium.Math.PI_OVER_TWO,
      heading: -this.view_.getRotation(),
      roll: void 0
    };
    this.cam_.setView({
      destination: r,
      orientation: i
    }), this.cam_.moveBackward(this.distance_), this.checkCameraChange(!0);
  }
  /**
   * Calculates the values of the properties from the current ol.View state.
   * @api
   */
  readFromView() {
    if (!this.view_ || !this.toLonLat_)
      return;
    const t = this.view_.getCenter();
    if (t == null)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = this.view_.getResolution();
    this.distance_ = this.calcDistanceForResolution(
      s || 0,
      Ku(n[1])
    ), this.updateCamera_();
  }
  /**
   * Calculates the values of the properties from the current Cesium.Camera state.
   * Modifies the center, resolution and rotation properties of the view.
   * @api
   */
  updateView() {
    if (!this.view_ || !this.fromLonLat_)
      return;
    this.viewUpdateInProgress_ = !0;
    const t = Cesium.Ellipsoid.WGS84, n = this.scene_, s = Vt.pickCenterPoint(n);
    let r = s;
    if (!r) {
      const a = n.globe, o = this.cam_.positionCartographic.clone(), l = a.getHeight(o);
      o.height = l || 0, r = Cesium.Ellipsoid.WGS84.cartographicToCartesian(o);
    }
    this.distance_ = Cesium.Cartesian3.distance(r, this.cam_.position);
    const i = t.cartesianToCartographic(r);
    if (this.view_.setCenter(this.fromLonLat_([
      Qh(i.longitude),
      Qh(i.latitude)
    ])), this.view_.setResolution(
      this.calcResolutionForDistance(
        this.distance_,
        i ? i.latitude : 0
      )
    ), s) {
      const a = this.cam_.position, o = new Cesium.Cartesian3();
      t.geocentricSurfaceNormal(s, o);
      const l = new Cesium.Cartesian3();
      Cesium.Cartesian3.subtract(a, s, l), Cesium.Cartesian3.normalize(l, l);
      const f = this.cam_.up, d = this.cam_.right, u = new Cesium.Cartesian3(-s.y, s.x, 0), c = Cesium.Cartesian3.angleBetween(d, u), p = Cesium.Cartesian3.cross(s, f, new Cesium.Cartesian3()).z;
      this.view_.setRotation(p < 0 ? c : -c);
      const g = Math.acos(
        Cesium.Cartesian3.dot(o, l)
      );
      this.tilt_ = isNaN(g) ? 0 : g;
    } else
      this.view_.setRotation(this.cam_.heading), this.tilt_ = -this.cam_.pitch + Math.PI / 2;
    this.viewUpdateInProgress_ = !1;
  }
  /**
   * Check if the underlying camera state has changed and ensure synchronization.
   * @param {boolean=} opt_dontSync Do not synchronize the view.
   */
  checkCameraChange(t) {
    const n = this.lastCameraViewMatrix_, s = this.cam_.viewMatrix;
    (!n || !Cesium.Matrix4.equalsEpsilon(n, s, 1e-5)) && (this.lastCameraViewMatrix_ = s.clone(), t !== !0 && this.updateView());
  }
  /**
   * calculate the distance between camera and centerpoint based on the resolution and latitude value
   * @param {number} resolution Number of map units per pixel.
   * @param {number} latitude Latitude in radians.
   * @return {number} The calculated distance.
   * @api
   */
  calcDistanceForResolution(t, n) {
    return N6(t, n, this.scene_, this.view_.getProjection());
  }
  /**
   * calculate the resolution based on a distance(camera to position) and latitude value
   * @param {number} distance
   * @param {number} latitude
   * @return {number} The calculated resolution.
   * @api
   */
  calcResolutionForDistance(t, n) {
    return F6(t, n, this.scene_, this.view_.getProjection());
  }
}
class EE {
  /**
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @template T
   * @abstract
   * @api
   */
  constructor(t, n) {
    this.map = t, this.view = t.getView(), this.scene = n, this.olLayers = t.getLayerGroup().getLayers(), this.mapLayerGroup = t.getLayerGroup(), this.layerMap = {}, this.olLayerListenKeys = {}, this.olGroupListenKeys_ = {};
  }
  /**
   * Destroy all and perform complete synchronization of the layers.
   * @api
   */
  synchronize() {
    this.destroyAll(), this.addLayers_(this.mapLayerGroup);
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @protected
   */
  orderLayers() {
  }
  /**
   * Add a layer hierarchy.
   * @param {ol.layer.Base} root
   * @private
   */
  addLayers_(t) {
    const n = [{
      layer: t,
      parents: []
    }];
    for (; n.length > 0; ) {
      const s = n.splice(0, 1)[0], r = s.layer, i = Qe(r).toString();
      this.olLayerListenKeys[i] = [], console.assert(!this.layerMap[i]);
      let a = null;
      if (r instanceof Wa)
        this.listenForGroupChanges_(r), r !== this.mapLayerGroup && (a = this.createSingleLayerCounterparts(s)), a || r.getLayers().forEach((o) => {
          if (o) {
            const l = {
              layer: o,
              parents: r === this.mapLayerGroup ? [] : [s.layer].concat(s.parents)
            };
            n.push(l);
          }
        });
      else if (a = this.createSingleLayerCounterparts(s), !a) {
        const o = i, l = s, f = (d) => {
          const u = this.createSingleLayerCounterparts(l);
          u && (l.layer.un("change", f), this.addCesiumObjects_(u, o, l.layer), this.orderLayers());
        };
        this.olLayerListenKeys[i].push(Vl(l.layer, "change", f));
      }
      a && this.addCesiumObjects_(a, i, r);
    }
    this.orderLayers();
  }
  /**
   * Add Cesium objects.
   * @param {Array.<T>} cesiumObjects
   * @param {string} layerId
   * @param {ol.layer.Base} layer
   * @private
   */
  addCesiumObjects_(t, n, s) {
    this.layerMap[n] = t, this.olLayerListenKeys[n].push(Vl(s, "change:zIndex", () => this.orderLayers())), t.forEach((r) => {
      this.addCesiumObject(r);
    });
  }
  /**
   * Remove and destroy a single layer.
   * @param {ol.layer.Layer} layer
   * @return {boolean} counterpart destroyed
   * @private
   */
  removeAndDestroySingleLayer_(t) {
    const n = Qe(t).toString(), s = this.layerMap[n];
    return s && (s.forEach((r) => {
      this.removeSingleCesiumObject(r, !1), this.destroyCesiumObject(r);
    }), this.olLayerListenKeys[n].forEach(Fs), delete this.olLayerListenKeys[n]), delete this.layerMap[n], !!s;
  }
  /**
   * Unlisten a single layer group.
   * @param {ol.layer.Group} group
   * @private
   */
  unlistenSingleGroup_(t) {
    if (t === this.mapLayerGroup)
      return;
    const n = Qe(t).toString();
    this.olGroupListenKeys_[n].forEach((r) => {
      Fs(r);
    }), delete this.olGroupListenKeys_[n], delete this.layerMap[n];
  }
  /**
   * Remove layer hierarchy.
   * @param {ol.layer.Base} root
   * @private
   */
  removeLayer_(t) {
    if (t) {
      const n = [t];
      for (; n.length > 0; ) {
        const s = n.splice(0, 1)[0], r = this.removeAndDestroySingleLayer_(s);
        s instanceof Wa && (this.unlistenSingleGroup_(s), r || s.getLayers().forEach((i) => {
          n.push(i);
        }));
      }
    }
  }
  /**
   * Register listeners for single layer group change.
   * @param {ol.layer.Group} group
   * @private
   */
  listenForGroupChanges_(t) {
    const n = Qe(t).toString();
    console.assert(this.olGroupListenKeys_[n] === void 0);
    const s = [];
    this.olGroupListenKeys_[n] = s;
    let r = [];
    const i = (function() {
      const a = t.getLayers();
      a && (r = [
        a.on("add", (o) => {
          this.addLayers_(o.element);
        }),
        a.on("remove", (o) => {
          this.removeLayer_(o.element);
        })
      ], s.push(...r));
    }).bind(this);
    i(), s.push(t.on("change:layers", (a) => {
      r.forEach((o) => {
        const l = s.indexOf(o);
        l >= 0 && s.splice(l, 1), Fs(o);
      }), i();
    }));
  }
  /**
   * Destroys all the created Cesium objects.
   * @protected
   */
  destroyAll() {
    this.removeAllCesiumObjects(!0);
    let t;
    for (t in this.olGroupListenKeys_)
      this.olGroupListenKeys_[t].forEach(Fs);
    for (t in this.olLayerListenKeys)
      this.olLayerListenKeys[t].forEach(Fs);
    this.olGroupListenKeys_ = {}, this.olLayerListenKeys = {}, this.layerMap = {};
  }
  /**
   * Adds a single Cesium object to the collection.
   * @param {!T} object
   * @abstract
   * @protected
   */
  addCesiumObject(t) {
  }
  /**
   * @param {!T} object
   * @abstract
   * @protected
   */
  destroyCesiumObject(t) {
  }
  /**
   * Remove single Cesium object from the collection.
   * @param {!T} object
   * @param {boolean} destroy
   * @abstract
   * @protected
   */
  removeSingleCesiumObject(t, n) {
  }
  /**
   * Remove all Cesium objects from the collection.
   * @param {boolean} destroy
   * @abstract
   * @protected
   */
  removeAllCesiumObjects(t) {
  }
  /**
   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents
   * @return {?Array.<T>}
   * @abstract
   * @protected
   */
  createSingleLayerCounterparts(t) {
  }
}
class U6 extends EE {
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers raster layers to the given Cesium globe.
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @constructor
   * @extends {olcsAbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   */
  constructor(t, n) {
    super(t, n), this.cesiumLayers_ = n.imageryLayers, this.ourLayers_ = new Cesium.ImageryLayerCollection();
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    this.cesiumLayers_.add(t), this.ourLayers_.add(t);
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    this.cesiumLayers_.remove(t, n), this.ourLayers_.remove(t, !1);
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    for (let n = 0; n < this.ourLayers_.length; ++n)
      this.cesiumLayers_.remove(this.ourLayers_.get(n), t);
    this.ourLayers_.removeAll(!1);
  }
  /**
   * Creates an array of Cesium.ImageryLayer.
   * May be overriden by child classes to implement custom behavior.
   * The default implementation handles tiled imageries in EPSG:4326 or
   * EPSG:3859.
   * @param {!ol.layer.Base} olLayer
   * @param {!ol.proj.Projection} viewProj Projection of the view.
   * @return {?Array.<!Cesium.ImageryLayer>} array or null if not possible
   * (or supported)
   * @protected
   */
  convertLayerToCesiumImageries(t, n) {
    const s = Vt.tileLayerToImageryLayer(this.map, t, n);
    return s ? [s] : null;
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer, s = Qe(n).toString(), r = this.view.getProjection();
    console.assert(r);
    const i = this.convertLayerToCesiumImageries(n, r);
    if (i) {
      const a = [];
      if ([t.layer].concat(t.parents).forEach((o) => {
        a.push(o.on(["change:opacity", "change:visible"], () => {
          console.assert(i);
          for (let l = 0; l < i.length; ++l)
            Vt.updateCesiumLayerProperties(t, i[l]);
        }));
      }), n.getStyleFunction) {
        let o = n.getStyleFunction();
        a.push(n.on("change", () => {
          const l = n.getStyleFunction();
          if (o !== l) {
            o = l;
            for (let f = 0; f < i.length; ++f) {
              const d = i[f];
              d._imageryCache && d.imageryProvider.cache_ && (d._imageryCache = {}, d.imageryProvider.cache_ = {}, d.imageryProvider.styleFunction_ = l);
            }
            this.scene.requestRender();
          }
        }));
      }
      for (let o = 0; o < i.length; ++o)
        Vt.updateCesiumLayerProperties(t, i[o]);
      a.push(n.on("change:extent", (o) => {
        for (let l = 0; l < i.length; ++l)
          this.cesiumLayers_.remove(i[l], !0), this.ourLayers_.remove(i[l], !1);
        delete this.layerMap[Qe(n)], this.synchronize();
      })), a.push(n.on("change", (o) => {
        for (let l = 0; l < i.length; ++l) {
          const f = this.cesiumLayers_.indexOf(i[l]);
          f >= 0 && (this.cesiumLayers_.remove(i[l], !1), this.cesiumLayers_.add(i[l], f));
        }
      })), this.olLayerListenKeys[s].push(...a);
    }
    return Array.isArray(i) ? i : null;
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @override
   * @protected
   */
  orderLayers() {
    const t = [], n = {}, s = [this.mapLayerGroup];
    for (; s.length > 0; ) {
      const r = s.splice(0, 1)[0];
      if (t.push(r), n[Qe(r)] = r.getZIndex() || 0, r instanceof Wa) {
        const i = r.getLayers();
        i && s.unshift(...i.getArray());
      }
    }
    _6(
      t,
      (r, i) => n[Qe(r)] - n[Qe(i)]
    ), t.forEach((r) => {
      const i = Qe(r).toString(), a = this.layerMap[i];
      a && a.forEach((o) => {
        this.raiseToTop(o);
      });
    });
  }
  /**
   * @param {Cesium.ImageryLayer} counterpart
   */
  raiseToTop(t) {
    this.cesiumLayers_.raiseToTop(t);
  }
}
class W6 {
  /**
  * Result of the conversion of an OpenLayers layer to Cesium.
  * @param {!(ol.proj.Projection|string)} layerProjection
  * @param {!Cesium.Scene} scene
  */
  constructor(t, n) {
    const s = new Cesium.BillboardCollection({ scene: n }), r = new Cesium.PrimitiveCollection();
    this.olListenKeys = [], this.rootCollection_ = new Cesium.PrimitiveCollection(), this.context = {
      projection: t,
      billboards: s,
      featureToCesiumMap: {},
      primitives: r
    }, this.rootCollection_.add(s), this.rootCollection_.add(r);
  }
  /**
  * Unlisten.
  */
  destroy() {
    this.olListenKeys.forEach(Fs), this.olListenKeys.length = 0;
  }
  /**
  * @return {!Cesium.Primitive}
  */
  getRootPrimitive() {
    return this.rootCollection_;
  }
}
class $6 {
  /**
   * Concrete base class for converting from OpenLayers3 vectors to Cesium
   * primitives.
   * Extending this class is possible provided that the extending class and
   * the library are compiled together by the closure compiler.
   * @param {!Cesium.Scene} scene Cesium scene.
   * @constructor
   * @api
   */
  constructor(t) {
    this.scene = t, this.boundOnRemoveOrClearFeatureListener_ = this.onRemoveOrClearFeature_.bind(this), this.defaultBillboardEyeOffset_ = new Cesium.Cartesian3(0, 0, 10);
  }
  /**
   * @param {ol.source.Vector.Event} evt
   * @private
   */
  onRemoveOrClearFeature_(t) {
    const n = t.target;
    console.assert(n instanceof jr);
    const s = en.obj(n).olcs_cancellers;
    if (s) {
      const r = t.feature;
      if (r) {
        const i = Qe(r), a = s[i];
        a && (a(), delete s[i]);
      } else {
        for (const i in s)
          s.hasOwnProperty(i) && s[i]();
        en.obj(n).olcs_cancellers = {};
      }
    }
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!Cesium.Primitive|Cesium.Label|Cesium.Billboard} primitive
   * @protected
   */
  setReferenceForPicking(t, n, s) {
    s.olLayer = t, s.olFeature = n;
  }
  /**
   * Basics primitive creation using a color attribute.
   * Note that Cesium has 'interior' and outline geometries.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.
   * @param {!Cesium.Geometry} geometry
   * @param {!Cesium.Color} color
   * @param {number=} opt_lineWidth
   * @return {Cesium.Primitive}
   * @protected
   */
  createColoredPrimitive(t, n, s, r, i, a) {
    const o = function(c, h) {
      const p = new Cesium.GeometryInstance({
        // always update Cesium externs before adding a property
        geometry: c
      });
      return h && !(h instanceof Cesium.ImageMaterialProperty) && (p.attributes = {
        color: Cesium.ColorGeometryInstanceAttribute.fromColor(h)
      }), p;
    }, l = {
      // always update Cesium externs before adding a property
      flat: !0,
      // work with all geometries
      renderState: {
        depthTest: {
          enabled: !0
        }
      }
    };
    a !== void 0 && (l.renderState || (l.renderState = {}), l.renderState.lineWidth = a);
    const f = o(r, i), d = this.getHeightReference(t, n, s);
    let u;
    if (d === Cesium.HeightReference.CLAMP_TO_GROUND) {
      const c = f.geometry.constructor;
      if (c && !c.createShadowVolume)
        return null;
      u = new Cesium.GroundPrimitive({
        geometryInstances: f
      });
    } else
      u = new Cesium.Primitive({
        geometryInstances: f
      });
    if (i instanceof Cesium.ImageMaterialProperty) {
      const c = i.image.getValue().toDataURL();
      u.appearance = new Cesium.MaterialAppearance({
        flat: !0,
        renderState: {
          depthTest: {
            enabled: !0
          }
        },
        material: new Cesium.Material({
          fabric: {
            type: "Image",
            uniforms: {
              image: c
            }
          }
        })
      });
    } else
      u.appearance = new Cesium.PerInstanceColorAppearance(l);
    return this.setReferenceForPicking(t, n, u), u;
  }
  /**
   * Return the fill or stroke color from a plain ol style.
   * @param {!ol.style.Style|ol.style.Text} style
   * @param {boolean} outline
   * @return {!Cesium.Color}
   * @protected
   */
  extractColorFromOlStyle(t, n) {
    const s = t.getFill() ? t.getFill().getColor() : null, r = t.getStroke() ? t.getStroke().getColor() : null;
    let i = "black";
    return r && n ? i = r : s && (i = s), Vt.convertColorToCesium(i);
  }
  /**
   * Return the width of stroke from a plain ol style.
   * @param {!ol.style.Style|ol.style.Text} style
   * @return {number}
   * @protected
   */
  extractLineWidthFromOlStyle(t) {
    const n = t.getStroke() ? t.getStroke().getWidth() : void 0;
    return n !== void 0 ? n : 1;
  }
  /**
   * Create a primitive collection out of two Cesium geometries.
   * Only the OpenLayers style colors will be used.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.
   * @param {!Cesium.Geometry} fillGeometry
   * @param {!Cesium.Geometry} outlineGeometry
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection}
   * @protected
   */
  wrapFillAndOutlineGeometries(t, n, s, r, i, a) {
    const o = this.extractColorFromOlStyle(a, !1), l = this.extractColorFromOlStyle(a, !0), f = new Cesium.PrimitiveCollection();
    if (a.getFill()) {
      const d = this.createColoredPrimitive(
        t,
        n,
        s,
        r,
        o
      );
      console.assert(!!d), f.add(d);
    }
    if (a.getStroke() && i) {
      const d = this.extractLineWidthFromOlStyle(a), u = this.createColoredPrimitive(
        t,
        n,
        s,
        i,
        l,
        d
      );
      u && f.add(u);
    }
    return f;
  }
  // Geometry converters
  /**
   * Create a Cesium primitive if style has a text component.
   * Eventually return a PrimitiveCollection including current primitive.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Style} style
   * @param {!Cesium.Primitive} primitive current primitive
   * @return {!Cesium.PrimitiveCollection}
   * @protected
   */
  addTextStyle(t, n, s, r, i) {
    let a;
    if (i instanceof Cesium.PrimitiveCollection ? a = i : (a = new Cesium.PrimitiveCollection(), a.add(i)), !r.getText())
      return a;
    const o = (
      /** @type {!ol.style.Text} */
      r.getText()
    ), l = this.olGeometry4326TextPartToCesium(
      t,
      n,
      s,
      o
    );
    return l && a.add(l), a;
  }
  /**
   * Add a billboard to a Cesium.BillboardCollection.
   * Overriding this wrapper allows manipulating the billboard options.
   * @param {!Cesium.BillboardCollection} billboards
   * @param {!Cesium.optionsBillboardCollectionAdd} bbOptions
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Style} style
   * @return {!Cesium.Billboard} newly created billboard
   * @api
   */
  csAddBillboard(t, n, s, r, i, a) {
    n.eyeOffset || (n.eyeOffset = this.defaultBillboardEyeOffset_);
    const o = t.add(n);
    return this.setReferenceForPicking(s, r, o), o;
  }
  /**
   * Convert an OpenLayers circle geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Circle} olGeometry OpenLayers circle geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olCircleGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "Circle");
    let a = s.getCenter();
    const o = a.length == 3 ? a[2] : 0;
    let l = a.slice();
    l[0] += s.getRadius(), a = Vt.ol4326CoordinateToCesiumCartesian(a), l = Vt.ol4326CoordinateToCesiumCartesian(l);
    const f = Cesium.Cartesian3.distance(a, l), d = new Cesium.CircleGeometry({
      // always update Cesium externs before adding a property
      center: a,
      radius: f,
      height: o
    });
    let u, c;
    if (this.getHeightReference(t, n, s) === Cesium.HeightReference.CLAMP_TO_GROUND) {
      const p = this.extractLineWidthFromOlStyle(i);
      if (p) {
        const g = uP(s.getCenter(), f), m = Vt.ol4326CoordinateArrayToCsCartesians(g.getLinearRing(0).getCoordinates());
        if (ig(this.scene))
          u = new Cesium.GroundPolylinePrimitive({
            geometryInstances: new Cesium.GeometryInstance({
              geometry: new Cesium.GroundPolylineGeometry({ positions: m, width: p })
            }),
            appearance: new Cesium.PolylineMaterialAppearance({
              material: this.olStyleToCesium(n, i, !0)
            }),
            classificationType: Cesium.ClassificationType.TERRAIN
          }), u.readyPromise.then(() => {
            this.setReferenceForPicking(t, n, u._primitive);
          });
        else {
          const v = this.extractColorFromOlStyle(i, !0);
          u = this.createStackedGroundCorridors(t, n, p, v, m);
        }
      }
    } else
      c = new Cesium.CircleOutlineGeometry({
        // always update Cesium externs before adding a property
        center: a,
        radius: f,
        extrudedHeight: o,
        height: o
      });
    const h = this.wrapFillAndOutlineGeometries(
      t,
      n,
      s,
      d,
      c,
      i
    );
    return u && h.add(u), this.addTextStyle(t, n, s, i, h);
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!number} width The width of the line.
   * @param {!Cesium.Color} color The color of the line.
   * @param {!Array<Cesium.Cartesian3>|Array<Array<Cesium.Cartesian3>>} positions The vertices of the line(s).
   * @return {!Cesium.GroundPrimitive} primitive
   */
  createStackedGroundCorridors(t, n, s, r, i) {
    Array.isArray(i[0]) || (i = [i]), s = Math.max(3, s);
    const a = [];
    let o = 0;
    for (const l of [1e3, 4e3, 16e3, 64e3, 254e3, 1e6, 1e7]) {
      s *= 2.14;
      const f = {
        // always update Cesium externs before adding a property
        width: s,
        vertexFormat: Cesium.VertexFormat.POSITION_ONLY
      };
      for (const d of i)
        f.positions = d, a.push(new Cesium.GeometryInstance({
          geometry: new Cesium.CorridorGeometry(f),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(r),
            distanceDisplayCondition: new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(o, l - 1)
          }
        }));
      o = l;
    }
    return new Cesium.GroundPrimitive({
      // always update Cesium externs before adding a property
      geometryInstances: a
    });
  }
  /**
   * Convert an OpenLayers line string geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.LineString} olGeometry OpenLayers line string geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olLineStringGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "LineString");
    const a = Vt.ol4326CoordinateArrayToCsCartesians(s.getCoordinates()), o = this.extractLineWidthFromOlStyle(i);
    let l;
    const f = this.getHeightReference(t, n, s);
    if (f === Cesium.HeightReference.CLAMP_TO_GROUND && !ig(this.scene)) {
      const d = this.extractColorFromOlStyle(i, !0);
      l = this.createStackedGroundCorridors(t, n, o, d, a);
    } else {
      const d = new Cesium.PolylineMaterialAppearance({
        // always update Cesium externs before adding a property
        material: this.olStyleToCesium(n, i, !0)
      }), u = {
        // always update Cesium externs before adding a property
        positions: a,
        width: o
      }, c = {
        // always update Cesium externs before adding a property
        appearance: d
      };
      if (f === Cesium.HeightReference.CLAMP_TO_GROUND) {
        const h = new Cesium.GroundPolylineGeometry(u);
        c.geometryInstances = new Cesium.GeometryInstance({
          geometry: h
        }), l = new Cesium.GroundPolylinePrimitive(c), l.readyPromise.then(() => {
          this.setReferenceForPicking(t, n, l._primitive);
        });
      } else {
        u.vertexFormat = d.vertexFormat;
        const h = new Cesium.PolylineGeometry(u);
        c.geometryInstances = new Cesium.GeometryInstance({
          geometry: h
        }), l = new Cesium.Primitive(c);
      }
    }
    return this.setReferenceForPicking(t, n, l), this.addTextStyle(t, n, s, i, l);
  }
  /**
   * Convert an OpenLayers polygon geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Polygon} olGeometry OpenLayers polygon geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olPolygonGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "Polygon");
    const a = this.getHeightReference(t, n, s);
    let o, l, f;
    if (s.getCoordinates()[0].length == 5 && n.getGeometry().get("olcs.polygon_kind") === "rectangle") {
      const u = s.getCoordinates()[0], c = Yl(u), h = Cesium.Rectangle.fromDegrees(
        c[0],
        c[1],
        c[2],
        c[3]
      );
      let p = 0;
      if (u[0].length == 3)
        for (let g = 0; g < u.length; g++)
          p = Math.max(p, u[g][2]);
      o = new Cesium.RectangleGeometry({
        ellipsoid: Cesium.Ellipsoid.WGS84,
        rectangle: h,
        height: p
      }), l = new Cesium.RectangleOutlineGeometry({
        ellipsoid: Cesium.Ellipsoid.WGS84,
        rectangle: h,
        height: p
      });
    } else {
      const u = s.getLinearRings(), c = {}, h = c;
      console.assert(u.length > 0);
      for (let p = 0; p < u.length; ++p) {
        const g = u[p].getCoordinates(), m = Vt.ol4326CoordinateArrayToCsCartesians(g);
        console.assert(m && m.length > 0), p == 0 ? c.positions = m : (c.holes || (c.holes = []), c.holes.push({
          positions: m
        }));
      }
      if (o = new Cesium.PolygonGeometry({
        // always update Cesium externs before adding a property
        polygonHierarchy: h,
        perPositionHeight: !0
      }), a === Cesium.HeightReference.CLAMP_TO_GROUND) {
        const p = this.extractLineWidthFromOlStyle(i);
        if (p > 0) {
          const g = [c.positions];
          if (c.holes)
            for (let m = 0; m < c.holes.length; ++m)
              g.push(c.holes[m].positions);
          if (ig(this.scene)) {
            const m = new Cesium.PolylineMaterialAppearance({
              // always update Cesium externs before adding a property
              material: this.olStyleToCesium(n, i, !0)
            }), v = [];
            for (const E of g) {
              const C = new Cesium.GroundPolylineGeometry({ positions: E, width: p });
              v.push(new Cesium.GeometryInstance({
                geometry: C
              }));
            }
            const y = {
              // always update Cesium externs before adding a property
              appearance: m,
              geometryInstances: v
            };
            f = new Cesium.GroundPolylinePrimitive(y), f.readyPromise.then(() => {
              this.setReferenceForPicking(t, n, f._primitive);
            });
          } else {
            const m = this.extractColorFromOlStyle(i, !0);
            f = this.createStackedGroundCorridors(t, n, p, m, g);
          }
        }
      } else
        l = new Cesium.PolygonOutlineGeometry({
          // always update Cesium externs before adding a property
          polygonHierarchy: c,
          perPositionHeight: !0
        });
    }
    const d = this.wrapFillAndOutlineGeometries(
      t,
      n,
      s,
      o,
      l,
      i
    );
    return f && d.add(f), this.addTextStyle(t, n, s, i, d);
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @return {!Cesium.HeightReference}
   * @api
   */
  getHeightReference(t, n, s) {
    let r = s.get("altitudeMode");
    r === void 0 && (r = n.get("altitudeMode")), r === void 0 && (r = t.get("altitudeMode"));
    let i = Cesium.HeightReference.NONE;
    return r === "clampToGround" ? i = Cesium.HeightReference.CLAMP_TO_GROUND : r === "relativeToGround" && (i = Cesium.HeightReference.RELATIVE_TO_GROUND), i;
  }
  /**
   * Convert a point geometry to a Cesium BillboardCollection.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} style
   * @param {!ol.style.Image} imageStyle
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when the new billboard is added.
   * @api
   */
  createBillboardFromImage(t, n, s, r, i, a, o, l) {
    a instanceof Ua && a.load();
    const f = a.getImage(1), d = function(c) {
      return c.src != "" && c.naturalHeight != 0 && c.naturalWidth != 0 && c.complete;
    }, u = (function() {
      if (!f || !(f instanceof HTMLCanvasElement || f instanceof Image || f instanceof HTMLImageElement))
        return;
      const c = s.getCoordinates(), h = Vt.ol4326CoordinateToCesiumCartesian(c);
      let p;
      const g = a.getOpacity();
      g !== void 0 && (p = new Cesium.Color(1, 1, 1, g));
      const m = a.getScale(), v = this.getHeightReference(t, n, s), y = (
        /** @type {Cesium.optionsBillboardCollectionAdd} */
        {
          // always update Cesium externs before adding a property
          image: f,
          color: p,
          scale: m,
          heightReference: v,
          position: h
        }
      );
      if (Object.assign(y, n.get("cesiumOptions")), a instanceof Ua) {
        const C = a.getAnchor();
        C && (y.pixelOffset = new Cesium.Cartesian2((f.width / 2 - C[0]) * m, (f.height / 2 - C[1]) * m));
      }
      const E = this.csAddBillboard(o, y, t, n, s, i);
      l && l(E);
    }).bind(this);
    if (f instanceof Image && !d(f)) {
      let c = !1;
      const h = t.getSource(), p = function() {
        c = !0;
      };
      h.on(
        ["removefeature", "clear"],
        this.boundOnRemoveOrClearFeatureListener_
      );
      let g = en.obj(h).olcs_cancellers;
      g || (g = en.obj(h).olcs_cancellers = {});
      const m = Qe(n);
      g[m] && g[m](), g[m] = p;
      const v = function() {
        f.removeEventListener("load", v), !o.isDestroyed() && !c && u();
      };
      f.addEventListener("load", v);
    } else
      u();
  }
  /**
   * Convert a point geometry to a Cesium BillboardCollection.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} style
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when
   * the new billboard is added.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olPointGeometryToCesium(t, n, s, r, i, a, o) {
    console.assert(s.getType() == "Point"), s = Vt.olGeometryCloneTo4326(s, r);
    let l = null;
    const f = i.getImage();
    if (f) {
      const d = (
        /** @type {function():olcsx.ModelStyle} */
        s.get("olcs_model") || n.get("olcs_model")
      );
      if (d) {
        const u = d(), c = (
          /** @type {Cesium.ModelFromGltfOptions} */
          Object.assign({}, { scene: this.scene }, u.cesiumOptions)
        ), h = Cesium.Model.fromGltf(c);
        l = new Cesium.PrimitiveCollection(), l.add(h), u.debugModelMatrix && l.add(new Cesium.DebugModelMatrixPrimitive({
          modelMatrix: u.debugModelMatrix
        }));
      } else
        this.createBillboardFromImage(t, n, s, r, i, f, a, o);
    }
    return i.getText() ? this.addTextStyle(t, n, s, i, l || new Cesium.Primitive()) : l;
  }
  /**
   * Convert an OpenLayers multi-something geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry OpenLayers geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when
   * the new billboard is added.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olMultiGeometryToCesium(t, n, s, r, i, a, o) {
    const l = function(d, u) {
      const c = new Cesium.PrimitiveCollection();
      return d.forEach((h) => {
        c.add(u(t, n, h, r, i));
      }), c;
    };
    let f;
    switch (s.getType()) {
      case "MultiPoint":
        if (s = /** @type {!ol.geom.MultiPoint} */
        s, f = s.getPoints(), i.getText()) {
          const d = new Cesium.PrimitiveCollection();
          return f.forEach((u) => {
            console.assert(u);
            const c = this.olPointGeometryToCesium(
              t,
              n,
              u,
              r,
              i,
              a,
              o
            );
            c && d.add(c);
          }), d;
        } else
          return f.forEach((d) => {
            console.assert(d), this.olPointGeometryToCesium(
              t,
              n,
              d,
              r,
              i,
              a,
              o
            );
          }), null;
      case "MultiLineString":
        return s = /** @type {!ol.geom.MultiLineString} */
        s, f = s.getLineStrings(), l(f, this.olLineStringGeometryToCesium.bind(this));
      case "MultiPolygon":
        return s = /** @type {!ol.geom.MultiPolygon} */
        s, f = s.getPolygons(), l(f, this.olPolygonGeometryToCesium.bind(this));
      default:
        console.assert(!1, `Unhandled multi geometry type${s.getType()}`);
    }
  }
  /**
   * Convert an OpenLayers text style to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Text} style
   * @return {Cesium.LabelCollection} Cesium primitive
   * @api
   */
  olGeometry4326TextPartToCesium(t, n, s, r) {
    const i = r.getText();
    if (!i)
      return null;
    const a = new Cesium.LabelCollection({ scene: this.scene }), o = Fi(s.getExtent());
    if (s instanceof na) {
      const p = s.getFirstCoordinate();
      o[2] = p.length == 3 ? p[2] : 0;
    }
    const l = (
      /** @type {Cesium.optionsLabelCollection} */
      {}
    );
    l.position = Vt.ol4326CoordinateToCesiumCartesian(o), l.text = i, l.heightReference = this.getHeightReference(t, n, s);
    const f = r.getOffsetX(), d = r.getOffsetY();
    if (f != 0 && d != 0) {
      const p = new Cesium.Cartesian2(f, d);
      l.pixelOffset = p;
    }
    l.font = r.getFont() || "10px sans-serif";
    let u;
    r.getFill() && (l.fillColor = this.extractColorFromOlStyle(r, !1), u = Cesium.LabelStyle.FILL), r.getStroke() && (l.outlineWidth = this.extractLineWidthFromOlStyle(r), l.outlineColor = this.extractColorFromOlStyle(r, !0), u = Cesium.LabelStyle.OUTLINE), r.getFill() && r.getStroke() && (u = Cesium.LabelStyle.FILL_AND_OUTLINE), l.style = u;
    let c;
    switch (r.getTextAlign()) {
      case "left":
        c = Cesium.HorizontalOrigin.LEFT;
        break;
      case "right":
        c = Cesium.HorizontalOrigin.RIGHT;
        break;
      case "center":
      default:
        c = Cesium.HorizontalOrigin.CENTER;
    }
    if (l.horizontalOrigin = c, r.getTextBaseline()) {
      let p;
      switch (r.getTextBaseline()) {
        case "top":
          p = Cesium.VerticalOrigin.TOP;
          break;
        case "middle":
          p = Cesium.VerticalOrigin.CENTER;
          break;
        case "bottom":
          p = Cesium.VerticalOrigin.BOTTOM;
          break;
        case "alphabetic":
          p = Cesium.VerticalOrigin.TOP;
          break;
        case "hanging":
          p = Cesium.VerticalOrigin.BOTTOM;
          break;
        default:
          console.assert(!1, `unhandled baseline ${r.getTextBaseline()}`);
      }
      l.verticalOrigin = p;
    }
    const h = a.add(l);
    return this.setReferenceForPicking(t, n, h), a;
  }
  /**
   * Convert an OpenLayers style to a Cesium Material.
   * @param {ol.Feature} feature OpenLayers feature..
   * @param {!ol.style.Style} style
   * @param {boolean} outline
   * @return {Cesium.Material}
   * @api
   */
  olStyleToCesium(t, n, s) {
    const r = n.getFill(), i = n.getStroke();
    if (s && !i || !s && !r)
      return null;
    let a = s ? i.getColor() : r.getColor();
    return a = Vt.convertColorToCesium(a), s && i.getLineDash() ? Cesium.Material.fromType("Stripe", {
      // always update Cesium externs before adding a property
      horizontal: !1,
      repeat: 500,
      // TODO how to calculate this?
      evenColor: a,
      oddColor: new Cesium.Color(0, 0, 0, 0)
      // transparent
    }) : Cesium.Material.fromType("Color", {
      // always update Cesium externs before adding a property
      color: a
    });
  }
  /**
   * Compute OpenLayers plain style.
   * Evaluates style function, blend arrays, get default style.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature
   * @param {ol.StyleFunction|undefined} fallbackStyleFunction
   * @param {number} resolution
   * @return {Array.<!ol.style.Style>} null if no style is available
   * @api
   */
  computePlainStyle(t, n, s, r) {
    const i = n.getStyleFunction();
    let a = null;
    return i && (a = i(n, r)), !a && s && (a = s(n, r)), a ? Array.isArray(a) ? a : [a] : null;
  }
  /**
   * @protected
   * @param {!ol.Feature} feature
   * @param {!ol.style.Style} style
   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.
   * @return {ol.geom.Geometry|undefined}
   */
  getGeometryFromFeature(t, n, s) {
    if (s)
      return s;
    const r = (
      /** @type {!ol.geom.Geometry} */
      t.get("olcs.3d_geometry")
    );
    if (r && r instanceof pd)
      return r;
    if (n) {
      const i = n.getGeometryFunction()(t);
      if (i instanceof pd)
        return i;
    }
    return t.getGeometry();
  }
  /**
   * Convert one OpenLayers feature up to a collection of Cesium primitives.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.style.Style} style
   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context
   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olFeatureToCesium(t, n, s, r, i) {
    let a = this.getGeometryFromFeature(n, s, i);
    if (!a)
      return null;
    const o = r.projection, l = function(f) {
      const d = r.featureToCesiumMap[Qe(n)];
      d instanceof Array ? d.push(f) : r.featureToCesiumMap[Qe(n)] = [f];
    };
    switch (a.getType()) {
      case "GeometryCollection":
        const f = new Cesium.PrimitiveCollection();
        return /** @type {!ol.geom.GeometryCollection} */ a.getGeometries().forEach((p) => {
          if (p) {
            const g = this.olFeatureToCesium(
              t,
              n,
              s,
              r,
              p
            );
            g && f.add(g);
          }
        }), f;
      case "Point":
        a = /** @type {!ol.geom.Point} */
        a;
        const u = r.billboards, c = this.olPointGeometryToCesium(
          t,
          n,
          a,
          o,
          s,
          u,
          l
        );
        return c || null;
      case "Circle":
        return a = /** @type {!ol.geom.Circle} */
        a, this.olCircleGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "LineString":
        return a = /** @type {!ol.geom.LineString} */
        a, this.olLineStringGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "Polygon":
        return a = /** @type {!ol.geom.Polygon} */
        a, this.olPolygonGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        const h = this.olMultiGeometryToCesium(
          t,
          n,
          a,
          o,
          s,
          r.billboards,
          l
        );
        return h || null;
      case "LinearRing":
        throw new Error("LinearRing should only be part of polygon.");
      default:
        throw new Error(`Ol geom type not handled : ${a.getType()}`);
    }
  }
  /**
   * Convert an OpenLayers vector layer to Cesium primitive collection.
   * For each feature, the associated primitive will be stored in
   * `featurePrimitiveMap`.
   * @param {!(ol.layer.Vector|ol.layer.Image)} olLayer
   * @param {!ol.View} olView
   * @param {!Object.<number, !Cesium.Primitive>} featurePrimitiveMap
   * @return {!olcs.core.VectorLayerCounterpart}
   * @api
   */
  olVectorLayerToCesium(t, n, s) {
    const r = n.getProjection(), i = n.getResolution();
    if (i === void 0 || !r)
      throw console.assert(!1, "View not ready"), new Error("View not ready");
    let a = t.getSource();
    a instanceof u0 && (a = a.getSource()), console.assert(a instanceof jr);
    const o = a.getFeatures(), l = new W6(r, this.scene), f = l.context;
    for (let d = 0; d < o.length; ++d) {
      const u = o[d];
      if (!u)
        continue;
      const c = t.getStyleFunction(), h = this.computePlainStyle(
        t,
        u,
        c,
        i
      );
      if (!h || !h.length)
        continue;
      let p = null;
      for (let g = 0; g < h.length; g++) {
        const m = this.olFeatureToCesium(t, u, h[g], f);
        if (m) {
          if (!p)
            p = m;
          else if (m) {
            let v = 0, y;
            for (; y = m.get(v); )
              p.add(y), v++;
          }
        }
      }
      p && (s[Qe(u)] = p, l.getRootPrimitive().add(p));
    }
    return l;
  }
  /**
   * Convert an OpenLayers feature to Cesium primitive collection.
   * @param {!(ol.layer.Vector|ol.layer.Image)} layer
   * @param {!ol.View} view
   * @param {!ol.Feature} feature
   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context
   * @return {Cesium.Primitive}
   * @api
   */
  convert(t, n, s, r) {
    const i = n.getProjection(), a = n.getResolution();
    if (a == null || !i)
      return null;
    const o = t.getStyleFunction(), l = this.computePlainStyle(t, s, o, a);
    if (!l || !l.length)
      return null;
    r.projection = i;
    let f = null;
    for (let d = 0; d < l.length; d++) {
      const u = this.olFeatureToCesium(t, s, l[d], r);
      if (!f)
        f = u;
      else if (u) {
        let c = 0, h;
        for (; h = u.get(c); )
          f.add(h), c++;
      }
    }
    return f;
  }
}
class h_ extends EE {
  /**
   * Unidirectionally synchronize OpenLayers vector layers to Cesium.
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @param {olcs.FeatureConverter=} opt_converter
   * @extends {olcs.AbstractSynchronizer.<olcs.core.VectorLayerCounterpart>}
   * @api
   */
  constructor(t, n, s) {
    super(t, n), this.converter = s || new $6(n), this.csAllPrimitives_ = new Cesium.PrimitiveCollection(), n.primitives.add(this.csAllPrimitives_), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    console.assert(t), t.getRootPrimitive().counterpart = t, this.csAllPrimitives_.add(t.getRootPrimitive());
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.getRootPrimitive().destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    t.destroy(), this.csAllPrimitives_.destroyPrimitives = n, this.csAllPrimitives_.remove(t.getRootPrimitive()), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    if (this.csAllPrimitives_.destroyPrimitives = t, t)
      for (let n = 0; n < this.csAllPrimitives_.length; ++n)
        this.csAllPrimitives_.get(n).counterpart.destroy();
    this.csAllPrimitives_.removeAll(), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * Synchronizes the layer visibility properties
   * to the given Cesium Primitive.
   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents
   * @param {!Cesium.Primitive} csPrimitive
   */
  updateLayerVisibility(t, n) {
    let s = !0;
    [t.layer].concat(t.parents).forEach((r) => {
      const i = r.getVisible();
      i !== void 0 ? s &= i : s = !1;
    }), n.show = s;
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer;
    if (!(n instanceof vr) || n instanceof p0)
      return null;
    console.assert(n instanceof lu);
    let s = n.getSource();
    if (s instanceof u0 && (s = s.getSource()), !s)
      return null;
    console.assert(s instanceof jr), console.assert(this.view);
    const r = this.view, i = {}, a = this.converter.olVectorLayerToCesium(
      n,
      r,
      i
    ), o = a.getRootPrimitive(), l = a.olListenKeys;
    [t.layer].concat(t.parents).forEach((u) => {
      l.push(Vl(u, "change:visible", () => {
        this.updateLayerVisibility(t, o);
      }));
    }), this.updateLayerVisibility(t, o);
    const f = (function(u) {
      console.assert(
        n instanceof vr || n instanceof Rf
      );
      const c = a.context, h = this.converter.convert(n, r, u, c);
      h && (i[Qe(u)] = h, o.add(h));
    }).bind(this), d = (function(u) {
      const c = Qe(u), h = a.context, p = h.featureToCesiumMap[c];
      p && (delete h.featureToCesiumMap[c], p.forEach((m) => {
        m instanceof Cesium.Billboard && h.billboards.remove(m);
      }));
      const g = i[c];
      delete i[c], g && o.remove(g);
    }).bind(this);
    return l.push(Vl(s, "addfeature", (u) => {
      console.assert(u.feature), f(u.feature);
    })), l.push(Vl(s, "removefeature", (u) => {
      console.assert(u.feature), d(u.feature);
    })), l.push(Vl(s, "changefeature", (u) => {
      const c = u.feature;
      console.assert(c), d(c), f(c);
    })), a ? [a] : null;
  }
}
class z6 extends kP {
  /**
   * @param {olcsx.SynchronizedOverlayOptions} options SynchronizedOverlay Options.
   * @api
   */
  constructor(t) {
    const n = t.parent;
    super(n.getOptions()), this.scenePostRenderListenerRemover_ = null, this.scene_ = t.scene, this.synchronizer_ = t.synchronizer, this.parent_ = n, this.positionWGS84_ = void 0, this.observer_ = new MutationObserver(this.handleElementChanged.bind(this)), this.attributeObserver_ = [], this.listenerKeys_ = [];
    const s = (r) => this.setPropertyFromEvent_(r);
    this.listenerKeys_.push(this.parent_.on("change:position", s)), this.listenerKeys_.push(this.parent_.on("change:element", s)), this.listenerKeys_.push(this.parent_.on("change:offset", s)), this.listenerKeys_.push(this.parent_.on("change:position", s)), this.listenerKeys_.push(this.parent_.on("change:positioning", s)), this.setProperties(this.parent_.getProperties()), this.handleMapChanged(), this.handleElementChanged();
  }
  /**
   * @param {Node} target
   * @private
   */
  observeTarget_(t) {
    if (this.observer_) {
      this.observer_.disconnect(), this.observer_.observe(t, {
        attributes: !1,
        childList: !0,
        characterData: !0,
        subtree: !0
      }), this.attributeObserver_.forEach((n) => {
        n.disconnect();
      }), this.attributeObserver_.length = 0;
      for (let n = 0; n < t.childNodes.length; n++) {
        const s = t.childNodes[n];
        if (s.nodeType === 1) {
          const r = new MutationObserver(this.handleElementChanged.bind(this));
          r.observe(s, {
            attributes: !0,
            subtree: !0
          }), this.attributeObserver_.push(r);
        }
      }
    }
  }
  /**
   *
   * @param {ol.Object.Event} event
   * @private
   */
  setPropertyFromEvent_(t) {
    t.target && t.key && this.set(t.key, t.target.get(t.key));
  }
  /**
   * Get the scene associated with this overlay.
   * @see ol.Overlay.prototype.getMap
   * @return {!Cesium.Scene} The scene that the overlay is part of.
   * @api
   */
  getScene() {
    return this.scene_;
  }
  /**
   * @override
   */
  handleMapChanged() {
    this.scenePostRenderListenerRemover_ && (this.scenePostRenderListenerRemover_(), D6(this.element)), this.scenePostRenderListenerRemover_ = null;
    const t = this.getScene();
    if (t) {
      this.scenePostRenderListenerRemover_ = t.postRender.addEventListener(this.updatePixelPosition.bind(this)), this.updatePixelPosition();
      const n = this.stopEvent ? this.synchronizer_.getOverlayContainerStopEvent() : this.synchronizer_.getOverlayContainer();
      this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element);
    }
  }
  /**
   * @override
   */
  handlePositionChanged() {
    const t = this.getPosition();
    if (t) {
      const n = this.parent_.getMap().getView().getProjection();
      this.positionWGS84_ = ji(t, n, "EPSG:4326");
    } else
      this.positionWGS84_ = void 0;
    this.updatePixelPosition();
  }
  /**
   * @override
   */
  handleElementChanged() {
    function t(s, r) {
      const i = s.cloneNode();
      s.nodeName === "CANVAS" && i.getContext("2d").drawImage(s, 0, 0), r && r.appendChild(i), s.nodeType != Node.TEXT_NODE && i.addEventListener("click", (o) => {
        s.dispatchEvent(new MouseEvent("click", o)), o.stopPropagation();
      });
      const a = s.childNodes;
      for (let o = 0; o < a.length; o++)
        a[o] && t(a[o], i);
      return i;
    }
    A6(this.element);
    const n = this.getElement();
    if (n && n.parentNode && n.parentNode.childNodes)
      for (const s of n.parentNode.childNodes) {
        const r = t(s, null);
        this.element.appendChild(r);
      }
    n.parentNode && this.observeTarget_(n.parentNode);
  }
  /**
   * @override
   */
  updatePixelPosition() {
    const t = this.positionWGS84_;
    if (!this.scene_ || !t) {
      this.setVisible(!1);
      return;
    }
    let n = 0;
    if (t.length === 2) {
      const u = this.scene_.globe.getHeight(Cesium.Cartographic.fromDegrees(t[0], t[1]));
      u && this.scene_.globe.tilesLoaded && (t[2] = u), u && (n = u);
    } else
      n = t[2];
    const s = Cesium.Cartesian3.fromDegrees(t[0], t[1], n), r = this.scene_.camera, i = new Cesium.BoundingSphere(new Cesium.Cartesian3(), 6356752);
    if (!new Cesium.Occluder(i, r.position).isPointVisible(s)) {
      this.setVisible(!1);
      return;
    }
    if (r.frustum.computeCullingVolume(r.position, r.direction, r.up).computeVisibility(new Cesium.BoundingSphere(s)) !== 1) {
      this.setVisible(!1);
      return;
    }
    this.setVisible(!0);
    const l = this.scene_.cartesianToCanvasCoordinates(s), f = [l.x, l.y], d = [this.scene_.canvas.width, this.scene_.canvas.height];
    this.updateRenderedPosition(f, d);
  }
  /**
   * Destroys the overlay, removing all its listeners and elements
   * @api
   */
  destroy() {
    this.scenePostRenderListenerRemover_ && this.scenePostRenderListenerRemover_(), this.observer_ && this.observer_.disconnect(), Fs(this.listenerKeys_), this.listenerKeys_.splice(0), this.element.removeNode ? this.element.removeNode(!0) : this.element.remove(), this.element = null;
  }
}
class d_ {
  /**
  * @param {!ol.Map} map
  * @param {!Cesium.Scene} scene
  * @constructor
  * @template T
  * @api
  */
  constructor(t, n) {
    this.map = t, this.overlays_ = this.map.getOverlays(), this.scene = n, this.overlayContainerStopEvent_ = document.createElement("DIV"), this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"].forEach((r) => {
      this.overlayContainerStopEvent_.addEventListener(r, (i) => i.stopPropagation());
    }), this.scene.canvas.parentElement.appendChild(this.overlayContainerStopEvent_), this.overlayContainer_ = document.createElement("DIV"), this.overlayContainer_.className = "ol-overlaycontainer", this.scene.canvas.parentElement.appendChild(this.overlayContainer_), this.overlayMap_ = {};
  }
  /**
  * Get the element that serves as a container for overlays that don't allow
  * event propagation. Elements added to this container won't let mousedown and
  * touchstart events through to the map, so clicks and gestures on an overlay
  * don't trigger any {@link ol.MapBrowserEvent}.
  * @return {!Element} The map's overlay container that stops events.
  */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
  * Get the element that serves as a container for overlays.
  * @return {!Element} The map's overlay container.
  */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
  * Destroy all and perform complete synchronization of the overlays.
  * @api
  */
  synchronize() {
    this.destroyAll(), this.addOverlays(), this.overlays_.on("add", this.addOverlayFromEvent_.bind(this)), this.overlays_.on("remove", this.removeOverlayFromEvent_.bind(this));
  }
  /**
  * @param {ol.Collection.Event} event
  * @private
  */
  addOverlayFromEvent_(t) {
    const n = (
      /** @type {ol.Overlay} */
      t.element
    );
    this.addOverlay(n);
  }
  /**
  * @api
  */
  addOverlays() {
    this.overlays_.forEach((t) => {
      this.addOverlay(t);
    });
  }
  /**
  * @param {ol.Overlay} overlay
  * @api
  */
  addOverlay(t) {
    if (!t)
      return;
    const n = new z6({
      scene: this.scene,
      synchronizer: this,
      parent: t
    }), s = Qe(t).toString();
    this.overlayMap_[s] = n;
  }
  /**
  * @param {ol.Collection.Event} event
  * @private
  */
  removeOverlayFromEvent_(t) {
    const n = (
      /** @type {ol.Overlay} */
      t.element
    );
    this.removeOverlay(n);
  }
  /**
  * Removes an overlay from the scene
  * @param {ol.Overlay} overlay
  * @api
  */
  removeOverlay(t) {
    const n = Qe(t).toString(), s = this.overlayMap_[n];
    s && (s.destroy(), delete this.overlayMap_[n]);
  }
  /**
  * Destroys all the created Cesium objects.
  * @protected
  */
  destroyAll() {
    Object.keys(this.overlayMap_).forEach((t) => {
      this.overlayMap_[t].destroy(), delete this.overlayMap_[t];
    });
  }
}
class CE {
  /**
   * @param {!OLCesiumOptions} options Options.
   * @constructor
   * @api
   */
  constructor(t) {
    this.autoRenderLoop_ = null, this.map_ = t.map, this.time_ = t.time || function() {
      return Cesium.JulianDate.now();
    }, this.to4326Transform_ = ja(this.map_.getView().getProjection(), "EPSG:4326"), this.resolutionScale_ = 1, this.canvasClientWidth_ = 0, this.canvasClientHeight_ = 0, this.resolutionScaleChanged_ = !0;
    const n = "position:absolute;top:0;left:0;width:100%;height:100%;";
    this.container_ = document.createElement("DIV");
    const s = document.createAttribute("style");
    s.value = `${n}visibility:hidden;`, this.container_.setAttributeNode(s);
    let r = t.target || this.map_.getViewport();
    if (typeof r == "string" && (r = document.getElementById(r)), r.appendChild(this.container_), this.isOverMap_ = !t.target, this.isOverMap_ && t.stopOpenLayersEventsPropagation) {
      const u = ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"];
      for (let c = 0, h = u.length; c < h; ++c)
        this.container_.addEventListener(u[c], (p) => p.stopPropagation());
    }
    this.canvas_ = /** @type {!HTMLCanvasElement} */
    document.createElement("CANVAS");
    const i = document.createAttribute("style");
    i.value = n, this.canvas_.setAttributeNode(i), en.supportsImageRenderingPixelated() && (this.canvas_.style.imageRendering = en.imageRenderingValue()), this.canvas_.oncontextmenu = function() {
      return !1;
    }, this.canvas_.onselectstart = function() {
      return !1;
    }, this.container_.appendChild(this.canvas_), this.enabled_ = !1, this.pausedInteractions_ = [], this.hiddenRootGroup_ = null;
    const a = t.sceneOptions !== void 0 ? t.sceneOptions : (
      /** @type {Cesium.SceneOptions} */
      {}
    );
    a.canvas = this.canvas_, a.scene3DOnly = !0, this.scene_ = new Cesium.Scene(a);
    const o = this.scene_.screenSpaceCameraController;
    o.tiltEventTypes.push({
      eventType: Cesium.CameraEventType.LEFT_DRAG,
      modifier: Cesium.KeyboardEventModifier.SHIFT
    }), o.tiltEventTypes.push({
      eventType: Cesium.CameraEventType.LEFT_DRAG,
      modifier: Cesium.KeyboardEventModifier.ALT
    }), o.enableLook = !1, this.scene_.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z, this.camera_ = new Bl(this.scene_, this.map_), this.globe_ = new Cesium.Globe(Cesium.Ellipsoid.WGS84), this.globe_.baseColor = Cesium.Color.WHITE, this.scene_.globe = this.globe_, this.scene_.skyAtmosphere = new Cesium.SkyAtmosphere();
    const l = new Cesium.SingleTileImageryProvider({
      url: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=",
      rectangle: Cesium.Rectangle.fromDegrees(0, 0, 1, 1)
      // the Rectangle dimensions are arbitrary
    });
    this.globe_.imageryLayers.addImageryProvider(l, 0), this.dataSourceCollection_ = new Cesium.DataSourceCollection(), this.dataSourceDisplay_ = new Cesium.DataSourceDisplay({
      scene: this.scene_,
      dataSourceCollection: this.dataSourceCollection_
    });
    const f = t.createSynchronizers ? t.createSynchronizers(this.map_, this.scene_, this.dataSourceCollection_) : [
      new U6(this.map_, this.scene_),
      new h_(this.map_, this.scene_),
      new d_(this.map_, this.scene_)
    ];
    this.handleResize_();
    for (let u = f.length - 1; u >= 0; --u)
      f[u].synchronize();
    this.lastFrameTime_ = 0, this.renderId_ = void 0, this.targetFrameRate_ = Number.POSITIVE_INFINITY, this.blockCesiumRendering_ = !1, this.warmingUp_ = !1, this.trackedFeature_ = null, this.trackedEntity_ = null, this.entityView_ = null, this.needTrackedEntityUpdate_ = !1, this.boundingSphereScratch_ = new Cesium.BoundingSphere(), new Cesium.EventHelper().add(this.scene_.postRender, CE.prototype.updateTrackedEntity_, this), Cesium.Camera.enableSuspendTerrainAdjustment = !1;
  }
  /**
   * Render the Cesium scene.
   * @private
   */
  render_() {
    this.renderId_ !== void 0 && (cancelAnimationFrame(this.renderId_), this.renderId_ = void 0), (this.enabled_ || this.warmingUp_) && !this.blockCesiumRendering_ && (this.renderId_ = requestAnimationFrame(this.onAnimationFrame_.bind(this)));
  }
  /**
   * Callback for `requestAnimationFrame`.
   * @param {number} frameTime The frame time, from `performance.now()`.
   * @private
   */
  onAnimationFrame_(t) {
    this.renderId_ = void 0;
    const n = 1e3 / this.targetFrameRate_;
    if (t - this.lastFrameTime_ < n) {
      this.render_();
      return;
    }
    this.lastFrameTime_ = t;
    const r = this.time_();
    if (this.scene_.initializeFrame(), this.handleResize_(), this.dataSourceDisplay_.update(r), this.entityView_) {
      const i = this.trackedEntity_;
      this.dataSourceDisplay_.getBoundingSphere(i, !1, this.boundingSphereScratch_) === Cesium.BoundingSphereState.DONE && (this.boundingSphereScratch_.radius = 1, this.entityView_.update(r, this.boundingSphereScratch_));
    }
    this.scene_.render(r), this.camera_.checkCameraChange(), this.render_();
  }
  /**
   * @private
   */
  updateTrackedEntity_() {
    if (!this.needTrackedEntityUpdate_)
      return;
    const t = this.trackedEntity_, n = this.scene_, s = this.dataSourceDisplay_.getBoundingSphere(t, !1, this.boundingSphereScratch_);
    if (s === Cesium.BoundingSphereState.PENDING)
      return;
    n.screenSpaceCameraController.enableTilt = !1;
    const r = s !== Cesium.BoundingSphereState.FAILED ? this.boundingSphereScratch_ : void 0;
    r && (r.radius = 1), this.entityView_ = new Cesium.EntityView(t, n, n.mapProjection.ellipsoid), this.entityView_.update(this.time_(), r), this.needTrackedEntityUpdate_ = !1;
  }
  /**
   * @private
   */
  handleResize_() {
    let t = this.canvas_.clientWidth, n = this.canvas_.clientHeight;
    if (t === 0 | n === 0 || t === this.canvasClientWidth_ && n === this.canvasClientHeight_ && !this.resolutionScaleChanged_)
      return;
    let s = this.resolutionScale_;
    en.supportsImageRenderingPixelated() || (s *= window.devicePixelRatio || 1), this.resolutionScaleChanged_ = !1, this.canvasClientWidth_ = t, this.canvasClientHeight_ = n, t *= s, n *= s, this.canvas_.width = t, this.canvas_.height = n, this.scene_.camera.frustum.aspectRatio = t / n;
  }
  /**
   * @return {!olcs.Camera}
   * @api
   */
  getCamera() {
    return this.camera_;
  }
  /**
   * @return {!ol.Map}
   * @api
   */
  getOlMap() {
    return this.map_;
  }
  /**
   * @return {!ol.View}
   * @api
   */
  getOlView() {
    const t = this.map_.getView();
    return console.assert(t), t;
  }
  /**
   * @return {!Cesium.Scene}
   * @api
   */
  getCesiumScene() {
    return this.scene_;
  }
  /**
   * @return {!Cesium.DataSourceCollection}
   * @api
   */
  getDataSources() {
    return this.dataSourceCollection_;
  }
  /**
   * @return {!Cesium.DataSourceDisplay}
   * @api
   */
  getDataSourceDisplay() {
    return this.dataSourceDisplay_;
  }
  /**
   * @return {boolean}
   * @api
   */
  getEnabled() {
    return this.enabled_;
  }
  /**
   * Enables/disables the Cesium.
   * This modifies the visibility style of the container element.
   * @param {boolean} enable
   * @api
   */
  setEnabled(t) {
    if (this.enabled_ === t)
      return;
    this.enabled_ = t, this.container_.style.visibility = this.enabled_ ? "visible" : "hidden";
    let n;
    if (this.enabled_) {
      if (this.throwOnUnitializedMap_(), this.isOverMap_) {
        n = this.map_.getInteractions(), n.forEach((r, i, a) => {
          this.pausedInteractions_.push(r);
        }), n.clear(), this.map_.addInteraction = (r) => this.pausedInteractions_.push(r), this.map_.removeInteraction = (r) => this.pausedInteractions_ = this.pausedInteractions_.filter((i) => i !== r);
        const s = this.map_.getLayerGroup();
        s.getVisible() && (this.hiddenRootGroup_ = s, this.hiddenRootGroup_.setVisible(!1)), this.map_.getOverlayContainer().classList.add("olcs-hideoverlay");
      }
      this.camera_.readFromView(), this.render_();
    } else
      this.isOverMap_ && (n = this.map_.getInteractions(), this.pausedInteractions_.forEach((s) => {
        n.push(s);
      }), this.pausedInteractions_.length = 0, this.map_.addInteraction = (s) => this.map_.getInteractions().push(s), this.map_.removeInteraction = (s) => this.map_.getInteractions().remove(s), this.map_.getOverlayContainer().classList.remove("olcs-hideoverlay"), this.hiddenRootGroup_ && (this.hiddenRootGroup_.setVisible(!0), this.hiddenRootGroup_ = null)), this.camera_.updateView();
  }
  /**
   * Preload Cesium so that it is ready when transitioning from 2D to 3D.
   * @param {number} height Target height of the camera
   * @param {number} timeout Milliseconds after which the warming will stop
   * @api
  */
  warmUp(t, n) {
    if (this.enabled_)
      return;
    this.throwOnUnitializedMap_(), this.camera_.readFromView();
    const s = this.globe_.ellipsoid, r = this.scene_.camera, i = s.cartesianToCartographic(r.position);
    i.height < t && (i.height = t, r.position = s.cartographicToCartesian(i)), this.warmingUp_ = !0, this.render_(), setTimeout(() => {
      this.warmingUp_ = !1;
    }, n);
  }
  /**
   * Block Cesium rendering to save resources.
   * @param {boolean} block True to block.
   * @api
  */
  setBlockCesiumRendering(t) {
    this.blockCesiumRendering_ !== t && (this.blockCesiumRendering_ = t, this.render_());
  }
  /**
   * Render the globe only when necessary in order to save resources.
   * Experimental.
   * @api
   */
  enableAutoRenderLoop() {
    this.autoRenderLoop_ || (this.autoRenderLoop_ = new j6(this));
  }
  /**
   * Get the autorender loop.
   * @return {?olcs.AutoRenderLoop}
   * @api
  */
  getAutoRenderLoop() {
    return this.autoRenderLoop_;
  }
  /**
   * The 3D Cesium globe is rendered in a canvas with two different dimensions:
   * clientWidth and clientHeight which are the dimension on the screen and
   * width and height which are the dimensions of the drawing buffer.
   *
   * By using a resolution scale lower than 1.0, it is possible to render the
   * globe in a buffer smaller than the canvas client dimensions and improve
   * performance, at the cost of quality.
   *
   * Pixel ratio should also be taken into account; by default, a device with
   * pixel ratio of 2.0 will have a buffer surface 4 times bigger than the client
   * surface.
   *
   * @param {number} value
   * @this {olcs.OLCesium}
   * @api
   */
  setResolutionScale(t) {
    t = Math.max(0, t), t !== this.resolutionScale_ && (this.resolutionScale_ = Math.max(0, t), this.resolutionScaleChanged_ = !0, this.autoRenderLoop_ && this.autoRenderLoop_.restartRenderLoop());
  }
  /**
   * Set the target frame rate for the renderer. Set to `Number.POSITIVE_INFINITY`
   * to render as quickly as possible.
   * @param {number} value The frame rate, in frames per second.
   * @api
   */
  setTargetFrameRate(t) {
    this.targetFrameRate_ !== t && (this.targetFrameRate_ = t, this.render_());
  }
  /**
   * Check if OpenLayers map is not properly initialized.
   * @private
   */
  throwOnUnitializedMap_() {
    const n = this.map_.getView(), s = n.getCenter();
    if (!n.isDef() || isNaN(s[0]) || isNaN(s[1]))
      throw new Error(`The OpenLayers map is not properly initialized: ${s} / ${n.getResolution()}`);
  }
  /**
   * @type {ol.Feature}
   */
  get trackedFeature() {
    return this.trackedFeature_;
  }
  /**
   * @param {ol.Feature} feature
   */
  set trackedFeature(t) {
    if (this.trackedFeature_ !== t) {
      const n = this.scene_;
      if (!t || !t.getGeometry()) {
        this.needTrackedEntityUpdate_ = !1, n.screenSpaceCameraController.enableTilt = !0, this.trackedEntity_ && this.dataSourceDisplay_.defaultDataSource.entities.remove(this.trackedEntity_), this.trackedEntity_ = null, this.trackedFeature_ = null, this.entityView_ = null, n.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        return;
      }
      this.trackedFeature_ = t, this.needTrackedEntityUpdate_ = !0;
      const s = this.to4326Transform_, r = function() {
        const a = t.getGeometry();
        console.assert(a instanceof hi);
        const o = a.getCoordinates(), l = s(o, void 0, o.length);
        return Vt.ol4326CoordinateToCesiumCartesian(l);
      }, i = {
        position: new Cesium.CallbackProperty((a, o) => r(), !1),
        point: {
          pixelSize: 1,
          color: Cesium.Color.TRANSPARENT
        }
      };
      this.trackedEntity_ = this.dataSourceDisplay_.defaultDataSource.entities.add(i);
    }
  }
}
class K6 extends d_ {
  /* eslint-disable no-useless-constructor */
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers WMS raster layers to the given Cesium globe. This Synchronizer
   * assumes that the given WMS supports EPSG Code 4326 (WGS84)
   * @param {!ol.Map} map -
   * @param {!Cesium.Scene} scene -
   * @constructor
   * @extends {olcs.AbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   * @struct
   */
  constructor(t, n) {
    super(t, n);
  }
  /**
   * @api
   * @returns {void}
   */
  addOverlays() {
    this.overlays_.forEach((t) => {
      t.getId() !== void 0 && this.addOverlay(t);
    });
  }
}
class G6 extends EE {
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers WMS raster layers to the given Cesium globe. This Synchronizer
   * assumes that the given WMS supports EPSG Code 4326 (WGS84)
   * @param {!ol.Map} map -
   * @param {!Cesium.Scene} scene -
   * @constructor
   * @extends {olcs.AbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   * @struct
   */
  constructor(t, n) {
    super(t, n), this.cesiumLayers = n.imageryLayers, this.ourLayers = new Cesium.ImageryLayerCollection();
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    this.cesiumLayers.add(t), this.ourLayers.add(t);
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    this.cesiumLayers.remove(t, n), this.ourLayers.remove(t, !1);
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    for (let n = 0; n < this.ourLayers.length; ++n)
      this.cesiumLayers.remove(this.ourLayers.get(n), t);
    this.ourLayers.removeAll(!1);
  }
  /**
   * Creates an array of Cesium.ImageryLayer.
   * May be overriden by child classes to implement custom behavior.
   * The default implementation handles tiled imageries in EPSG:4326 or
   * EPSG:3859.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @return {?Array.<!Cesium.ImageryLayer>} Array or null if not possible.
   * (or supported)
   * @protected
   */
  convertLayerToCesiumImageries(t, n) {
    const s = {
      show: !1
    };
    let r = {}, i = {}, a = null;
    if (!(t instanceof kc) && !(t instanceof Rf))
      return null;
    if (r = t.getSource(), r instanceof Xy)
      a = this.createProviderForTileWMS(r, n, t);
    else {
      if (r instanceof Jy)
        return [this.createImageryLayerForImageWMS(t, n)];
      if (r instanceof l_)
        a = this.createProviderForStaticImageSource(r);
      else if (r instanceof Vf)
        a = new Cesium.WebMapTileServiceImageryProvider({
          url: r.getUrls()[0],
          format: r.getFormat(),
          layer: r.getLayer(),
          style: r.getStyle(),
          tileMatrixSetID: r.getMatrixSet(),
          tileMatrixLabels: r.getTileGrid().getMatrixIds(),
          credit: r.getAttributions()
        });
      else
        return console.warn("Sources other than TileImage are currently not supported."), null;
    }
    return i = new Cesium.ImageryLayer(a, s), i ? [i] : null;
  }
  /**
   * Creates an Cesium.WebMapServiceImageryProvider for RasterLayer of the type TileWMS.
   * @param {module:ol/source/TileWMS} source The raster layer source.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @returns {WebMapServiceImageryProvider} The imagery provider.
   */
  createProviderForTileWMS(t, n, s) {
    const r = t.getParams(), i = {
      url: t.getUrls()[0],
      parameters: r,
      layers: r.LAYERS,
      show: !1
    }, a = t.getTileGrid();
    if (a) {
      const o = s.getExtent();
      if (o && n) {
        i.rectangle = Vt.extentToRectangle(o, n);
        const l = this.getMinMaxLevelFromTileGrid(a, o, n);
        i.tileWidth = a.getTileSize(0)[0], i.tileHeight = a.getTileSize(0)[1], i.minimumLevel = l[0], i.maximumLevel = l[1];
      }
    }
    return new Cesium.WebMapServiceImageryProvider(i);
  }
  /**
   * Creates an Cesium.ImageryLayer for RasterLayer of the type ImageWMS.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @returns {Cesium.ImageryLayer} The imagery layer.
   */
  createImageryLayerForImageWMS(t, n) {
    return Vt.tileLayerToImageryLayer(this.map, t, n);
  }
  /**
   * Creates an Cesium.SingleTileImageryProvider for RasterLayer of the type StaticImageSource.
   * @param {module:ol/source/ImageStatic} source The raster layer source.
   * @returns {SingleTileImageryProvider} The imagery provider.
   */
  createProviderForStaticImageSource(t) {
    const n = t.getImageExtent(), s = {
      url: t.getUrl(),
      show: !1
    }, r = dn(t.getProjection().getCode(), "EPSG:4326", Oo(n)), i = dn(t.getProjection().getCode(), "EPSG:4326", To(n));
    return s.rectangle = Cesium.Rectangle.fromDegrees(r[0], r[1], i[0], i[1]), new Cesium.SingleTileImageryProvider(s);
  }
  /**
   *
   * @param {ol.Extent} extent -
   * @param {ol.ProjectionLike} projection -
   * @return {Array.<Cesium.Cartographic>} -
   * @private
   */
  getExtentPoints(t, n) {
    const s = Fc(t, n, "EPSG:4326");
    return [
      Oo(s),
      Xl(s),
      To(s),
      fs(s)
    ].map((i) => Cesium.Cartographic.fromDegrees(i[0], i[1]));
  }
  /**
   *
   * @param {ol.tilegrid.TileGrid} tilegrid -
   * @param {ol.Extent} extent -
   * @param {ol.ProjectionLike} projection -
   * @return {Array.<Number>} -
   */
  getMinMaxLevelFromTileGrid(t, n, s) {
    const r = [
      Oo(n),
      Xl(n),
      To(n),
      fs(n)
    ], i = t.getResolutions().slice(-1).pop(), a = r.map((h) => t.getTileCoordForCoordAndResolution(h, i)), o = Math.abs(a[0][1] - a[1][1]), l = Math.abs(a[0][2] - a[3][2]), f = this.getExtentPoints(n, s), d = new Cesium.GeographicTilingScheme({});
    let u = 0, c = 20;
    for (; u < c; ) {
      const h = f.map((g) => d.positionToTileXY(g, u)), p = [];
      if (p.push(Math.abs(h[0].x - h[1].x)), p.push(Math.abs(h[0].y - h[3].y)), p[0] > 1 || p[1] > 1) {
        u--;
        break;
      }
      u++;
    }
    for (; c > u; ) {
      const h = f.map((g) => d.positionToTileXY(g, c)), p = [];
      if (p.push(Math.abs(h[0].x - h[1].x)), p.push(Math.abs(h[0].y - h[3].y)), p[0] < o || p[1] < l) {
        c++;
        break;
      }
      c--;
    }
    return [u, c];
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer, s = Qe(n).toString(), r = this.view.getProjection(), i = this.convertLayerToCesiumImageries(n, r);
    if (i) {
      const a = [];
      [t.layer].concat(t.parents).forEach((o) => {
        a.push(o.on(["change:opacity", "change:visible"], () => {
          console.assert(i);
          for (let l = 0; l < i.length; ++l)
            Vt.updateCesiumLayerProperties(t, i[l]);
        }));
      });
      for (let o = 0; o < i.length; ++o)
        Vt.updateCesiumLayerProperties(t, i[o]);
      a.push(n.on("change:extent", function() {
        for (let o = 0; o < i.length; ++o)
          this.cesiumLayers.remove(i[o], !0), this.ourLayers.remove(i[o], !1);
        delete this.layerMap[Qe(n)], this.synchronize();
      }, this)), a.push(n.on("change", (function() {
        for (let o = 0; o < i.length; ++o) {
          const l = this.cesiumLayers.indexOf(i[o]);
          l >= 0 && (this.cesiumLayers.remove(i[o], !1), this.cesiumLayers.add(i[o], l));
        }
      }).bind(this))), this.olLayerListenKeys[s].push(...a);
    }
    return Array.isArray(i) ? i : null;
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @override
   * @protected
   */
  orderLayers() {
    const t = [], n = {}, s = [this.mapLayerGroup];
    for (; s.length > 0; ) {
      const r = s.splice(0, 1)[0];
      if (t.push(r), n[Qe(r)] = r.getZIndex(), r instanceof Wa) {
        const i = r.getLayers();
        i && s.unshift(...i.getArray());
      }
    }
    L_(t, (r, i) => n[Qe(r)] - n[Qe(i)]), t.forEach(function(r) {
      const i = Qe(r).toString(), a = this.layerMap[i];
      a && a.forEach(this.raiseToTop, this);
    }, this);
  }
  /**
   * @param {Cesium.ImageryLayer} counterpart -
   * @returns {void}
   */
  raiseToTop(t) {
    this.cesiumLayers.raiseToTop(t);
  }
}
let k6 = 0;
function pf(e, t) {
  Object.keys(t).forEach((n) => {
    const s = t[n];
    typeof s == "object" ? Object.keys(s).forEach((r) => {
      r !== "heading" && r !== "tilt" && r !== "altitude" && (e[n][r] = s[r]);
    }) : e[n] = s;
  });
}
function f_(e, t, n) {
  var o, l, f, d, u, c;
  let s, r, i, a;
  if (e && t)
    if (typeof e.heading < "u" ? a = parseFloat(e.heading) : typeof ((o = e.camera) == null ? void 0 : o.heading) < "u" && (a = parseFloat((l = e.camera) == null ? void 0 : l.heading)), e.cameraPosition)
      s = t.getCesiumScene().camera, r = n.Cartesian3.fromDegrees(e.cameraPosition[0], e.cameraPosition[1], e.cameraPosition[2]), i = {
        heading: n.Math.toRadians(a),
        pitch: n.Math.toRadians(parseFloat(e.pitch)),
        roll: n.Math.toRadians(parseFloat(e.roll))
      }, s.setView({
        destination: r,
        orientation: i
      });
    else {
      let h, p;
      typeof e.tilt < "u" ? h = parseFloat(e.tilt) : typeof ((f = e.camera) == null ? void 0 : f.tilt) < "u" && (h = parseFloat((d = e.camera) == null ? void 0 : d.tilt)), typeof e.altitude < "u" ? p = parseFloat(e.altitude) : typeof ((u = e.camera) == null ? void 0 : u.altitude) < "u" && (p = parseFloat((c = e.camera) == null ? void 0 : c.altitude)), s = t.getCamera(), h && s.setTilt(h), a && s.setHeading(a), p && s.setAltitude(p);
    }
}
function p_(e) {
  const t = new CE({
    map: e.map2D,
    time: e == null ? void 0 : e.shadowTime,
    stopOpenLayersEventsPropagation: !0,
    createSynchronizers: (n, s) => [new G6(n, s), new h_(n, s), new K6(n, s)]
  });
  return t.id = `map3D_${k6++}`, t.mapMode = "3D", pf(t.getCesiumScene(), fi.sceneOptions), e != null && e.cesiumParameter && (pf(t.getCesiumScene(), e.cesiumParameter), f_(e.cesiumParameter, t, Cesium)), t;
}
function H6(e) {
  var g, m;
  const t = this.scene, n = t.camera.getPickRay(e.position), s = t.globe.pick(n, t), r = this.map3D.getOlView().getProjection();
  let i, a, o, l, f, d, u, c, h, p;
  if (s) {
    if ((g = document.querySelector(".nav li")) != null && g.classList.contains("open") && document.querySelector(".nav li").classList.remove("open"), o = t.globe.ellipsoid.cartesianToCartographic(s), a = [Cesium.Math.toDegrees(o.longitude), Cesium.Math.toDegrees(o.latitude)], i = t.globe.getHeight(o), i && (a = a.concat([i])), l = Cesium.Cartesian3.distance(s, t.camera.position), f = this.map3D.getCamera().calcResolutionForDistance(l, o.latitude), d = ji(a, Wt("EPSG:4326"), r), u = null, t.pickPositionSupported) {
      const v = t.pick(e.position);
      c = t.pickPosition(e.position), !c && (v == null ? void 0 : v.primitive) instanceof window.Cesium.Billboard && (c = (m = v.primitive) == null ? void 0 : m.position), c && (h = t.globe.ellipsoid.cartesianToCartographic(c), u = ji([Cesium.Math.toDegrees(h.longitude), Cesium.Math.toDegrees(h.latitude)], Wt("EPSG:4326"), r), u.push(h.height));
    }
    p = {
      map3D: this,
      position: e.position,
      pickedPosition: u,
      coordinate: d,
      latitude: a[0],
      longitude: a[1],
      resolution: f,
      originalEvent: e
    };
  }
  return this.callback(p);
}
function Y6(e) {
  let t;
  Cesium && (t = new Cesium.ScreenSpaceEventHandler(e.scene.canvas), t.setInputAction(H6.bind(e), Cesium.ScreenSpaceEventType.LEFT_CLICK));
}
function X6(e, t, n) {
  const s = e.camera;
  let r = Object.prototype.hasOwnProperty.call(n, "cameraParameter") ? n.cameraParameter : {};
  return r = t != null && t.altitude ? Object.assign(r || {}, { altitude: t == null ? void 0 : t.altitude }) : r, r = t != null && t.heading ? Object.assign(r || {}, { heading: t == null ? void 0 : t.heading }) : r, r = t != null && t.tilt ? Object.assign(r || {}, { tilt: t == null ? void 0 : t.tilt }) : r, Object.keys(r).length > 0 && pf(e, { camera: r }), s;
}
const Z6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createMap: p_,
  handle3DEvents: Y6,
  prepareCamera: X6,
  setCameraParameter: f_,
  setCesiumSceneParams: pf
}, Symbol.toStringTag, { value: "Module" })), J6 = {
  /**
  * Creates a map and adds it to the mapCollection. Depending on param 'mapMode' a 2D or a 3D map is created. Default ist 2D.
  * @param {object} [config] - configuration object - falls back to defaults if none given
  * @param {string} [config.target="map"] - div id to render map to
  * @param {string} [config.namedProjections] - projections to create the map
  * @param {string} [config.backgroundImage] - background image for map; "" to use none
  * @param {string} [config.epsg] - CRS to use
  * @param {number[]} [config.extent] - extent to use
  * @param {Array.<{resolution: number, scale: number, zoomLevel: number}>} [config.options] - zoom level definition
  * @param {Array.<string[]>} [config.options] - each sub-array has two values: projection name, and projection description
  * @param {number} [config.startResolution] - initial resolution
  * @param {number[]} [config.startCenter] - initial position
  * @param {(string|object)} [config.layerConf] - services registry or URL thereof
  * @param {string} [config.gazetteerUrl] - url of gazetteer to use in searchAddress
  * @param {String} [mapMode = "2D"] The map mode. '2D' to create a 2D-map and '3D' to create a 3D-map.
  * @param {object}  [settings={}] - settings object
  * @param {object} [settings.mapParams] - additional parameter object that is spread into the ol.Map constructor object
  * @param {function} [settings.callback] - optional callback for layer list loading
  * @param {function} [settings.errorCallback] - optional callback for layer error events
  * @returns {module:ol/Map~Map} The map.
  */
  createMap: function(e, t = "2D", n = {}) {
    return {
      "2D": S6,
      "3D": p_
    }[t](e, n);
  },
  olcsMap: Z6
}, Q6 = {
  map: J6
};
var m_ = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(e) {
  (function(t, n, s, r) {
    var i = ["", "webkit", "Moz", "MS", "ms", "o"], a = n.createElement("div"), o = "function", l = Math.round, f = Math.abs, d = Date.now;
    function u(U, K, q) {
      return setTimeout(E(U, q), K);
    }
    function c(U, K, q) {
      return Array.isArray(U) ? (h(U, q[K], q), !0) : !1;
    }
    function h(U, K, q) {
      var ot;
      if (U)
        if (U.forEach)
          U.forEach(K, q);
        else if (U.length !== r)
          for (ot = 0; ot < U.length; )
            K.call(q, U[ot], ot, U), ot++;
        else
          for (ot in U)
            U.hasOwnProperty(ot) && K.call(q, U[ot], ot, U);
    }
    function p(U, K, q) {
      var ot = "DEPRECATED METHOD: " + K + `
` + q + ` AT 
`;
      return function() {
        var Et = new Error("get-stack-trace"), Rt = Et && Et.stack ? Et.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", ne = t.console && (t.console.warn || t.console.log);
        return ne && ne.call(t.console, ot, Rt), U.apply(this, arguments);
      };
    }
    var g;
    typeof Object.assign != "function" ? g = function(K) {
      if (K === r || K === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var q = Object(K), ot = 1; ot < arguments.length; ot++) {
        var Et = arguments[ot];
        if (Et !== r && Et !== null)
          for (var Rt in Et)
            Et.hasOwnProperty(Rt) && (q[Rt] = Et[Rt]);
      }
      return q;
    } : g = Object.assign;
    var m = p(function(K, q, ot) {
      for (var Et = Object.keys(q), Rt = 0; Rt < Et.length; )
        (!ot || ot && K[Et[Rt]] === r) && (K[Et[Rt]] = q[Et[Rt]]), Rt++;
      return K;
    }, "extend", "Use `assign`."), v = p(function(K, q) {
      return m(K, q, !0);
    }, "merge", "Use `assign`.");
    function y(U, K, q) {
      var ot = K.prototype, Et;
      Et = U.prototype = Object.create(ot), Et.constructor = U, Et._super = ot, q && g(Et, q);
    }
    function E(U, K) {
      return function() {
        return U.apply(K, arguments);
      };
    }
    function C(U, K) {
      return typeof U == o ? U.apply(K && K[0] || r, K) : U;
    }
    function x(U, K) {
      return U === r ? K : U;
    }
    function b(U, K, q) {
      h(S(K), function(ot) {
        U.addEventListener(ot, q, !1);
      });
    }
    function P(U, K, q) {
      h(S(K), function(ot) {
        U.removeEventListener(ot, q, !1);
      });
    }
    function T(U, K) {
      for (; U; ) {
        if (U == K)
          return !0;
        U = U.parentNode;
      }
      return !1;
    }
    function O(U, K) {
      return U.indexOf(K) > -1;
    }
    function S(U) {
      return U.trim().split(/\s+/g);
    }
    function L(U, K, q) {
      if (U.indexOf && !q)
        return U.indexOf(K);
      for (var ot = 0; ot < U.length; ) {
        if (q && U[ot][q] == K || !q && U[ot] === K)
          return ot;
        ot++;
      }
      return -1;
    }
    function A(U) {
      return Array.prototype.slice.call(U, 0);
    }
    function D(U, K, q) {
      for (var ot = [], Et = [], Rt = 0; Rt < U.length; ) {
        var ne = K ? U[Rt][K] : U[Rt];
        L(Et, ne) < 0 && ot.push(U[Rt]), Et[Rt] = ne, Rt++;
      }
      return q && (K ? ot = ot.sort(function(Pn, yn) {
        return Pn[K] > yn[K];
      }) : ot = ot.sort()), ot;
    }
    function _(U, K) {
      for (var q, ot, Et = K[0].toUpperCase() + K.slice(1), Rt = 0; Rt < i.length; ) {
        if (q = i[Rt], ot = q ? q + Et : K, ot in U)
          return ot;
        Rt++;
      }
      return r;
    }
    var w = 1;
    function B() {
      return w++;
    }
    function j(U) {
      var K = U.ownerDocument || U;
      return K.defaultView || K.parentWindow || t;
    }
    var k = /mobile|tablet|ip(ad|hone|od)|android/i, X = "ontouchstart" in t, rt = _(t, "PointerEvent") !== r, et = X && k.test(navigator.userAgent), Z = "touch", dt = "pen", vt = "mouse", bt = "kinect", it = 25, R = 1, V = 2, tt = 4, Y = 8, $ = 1, z = 2, at = 4, ct = 8, St = 16, F = z | at, M = ct | St, I = F | M, N = ["x", "y"], G = ["clientX", "clientY"];
    function nt(U, K) {
      var q = this;
      this.manager = U, this.callback = K, this.element = U.element, this.target = U.options.inputTarget, this.domHandler = function(ot) {
        C(U.options.enable, [U]) && q.handler(ot);
      }, this.init();
    }
    nt.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && b(this.element, this.evEl, this.domHandler), this.evTarget && b(this.target, this.evTarget, this.domHandler), this.evWin && b(j(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && P(this.element, this.evEl, this.domHandler), this.evTarget && P(this.target, this.evTarget, this.domHandler), this.evWin && P(j(this.element), this.evWin, this.domHandler);
      }
    };
    function lt(U) {
      var K, q = U.options.inputClass;
      return q ? K = q : rt ? K = pn : et ? K = mi : X ? K = wn : K = bn, new K(U, yt);
    }
    function yt(U, K, q) {
      var ot = q.pointers.length, Et = q.changedPointers.length, Rt = K & R && ot - Et === 0, ne = K & (tt | Y) && ot - Et === 0;
      q.isFirst = !!Rt, q.isFinal = !!ne, Rt && (U.session = {}), q.eventType = K, Lt(U, q), U.emit("hammer.input", q), U.recognize(q), U.session.prevInput = q;
    }
    function Lt(U, K) {
      var q = U.session, ot = K.pointers, Et = ot.length;
      q.firstInput || (q.firstInput = J(K)), Et > 1 && !q.firstMultiple ? q.firstMultiple = J(K) : Et === 1 && (q.firstMultiple = !1);
      var Rt = q.firstInput, ne = q.firstMultiple, vn = ne ? ne.center : Rt.center, Pn = K.center = ft(ot);
      K.timeStamp = d(), K.deltaTime = K.timeStamp - Rt.timeStamp, K.angle = kt(vn, Pn), K.distance = Ot(vn, Pn), Nt(q, K), K.offsetDirection = Mt(K.deltaX, K.deltaY);
      var yn = Ct(K.deltaTime, K.deltaX, K.deltaY);
      K.overallVelocityX = yn.x, K.overallVelocityY = yn.y, K.overallVelocity = f(yn.x) > f(yn.y) ? yn.x : yn.y, K.scale = ne ? Pe(ne.pointers, ot) : 1, K.rotation = ne ? de(ne.pointers, ot) : 0, K.maxPointers = q.prevInput ? K.pointers.length > q.prevInput.maxPointers ? K.pointers.length : q.prevInput.maxPointers : K.pointers.length, Jt(q, K);
      var Jn = U.element;
      T(K.srcEvent.target, Jn) && (Jn = K.srcEvent.target), K.target = Jn;
    }
    function Nt(U, K) {
      var q = K.center, ot = U.offsetDelta || {}, Et = U.prevDelta || {}, Rt = U.prevInput || {};
      (K.eventType === R || Rt.eventType === tt) && (Et = U.prevDelta = {
        x: Rt.deltaX || 0,
        y: Rt.deltaY || 0
      }, ot = U.offsetDelta = {
        x: q.x,
        y: q.y
      }), K.deltaX = Et.x + (q.x - ot.x), K.deltaY = Et.y + (q.y - ot.y);
    }
    function Jt(U, K) {
      var q = U.lastInterval || K, ot = K.timeStamp - q.timeStamp, Et, Rt, ne, vn;
      if (K.eventType != Y && (ot > it || q.velocity === r)) {
        var Pn = K.deltaX - q.deltaX, yn = K.deltaY - q.deltaY, Jn = Ct(ot, Pn, yn);
        Rt = Jn.x, ne = Jn.y, Et = f(Jn.x) > f(Jn.y) ? Jn.x : Jn.y, vn = Mt(Pn, yn), U.lastInterval = K;
      } else
        Et = q.velocity, Rt = q.velocityX, ne = q.velocityY, vn = q.direction;
      K.velocity = Et, K.velocityX = Rt, K.velocityY = ne, K.direction = vn;
    }
    function J(U) {
      for (var K = [], q = 0; q < U.pointers.length; )
        K[q] = {
          clientX: l(U.pointers[q].clientX),
          clientY: l(U.pointers[q].clientY)
        }, q++;
      return {
        timeStamp: d(),
        pointers: K,
        center: ft(K),
        deltaX: U.deltaX,
        deltaY: U.deltaY
      };
    }
    function ft(U) {
      var K = U.length;
      if (K === 1)
        return {
          x: l(U[0].clientX),
          y: l(U[0].clientY)
        };
      for (var q = 0, ot = 0, Et = 0; Et < K; )
        q += U[Et].clientX, ot += U[Et].clientY, Et++;
      return {
        x: l(q / K),
        y: l(ot / K)
      };
    }
    function Ct(U, K, q) {
      return {
        x: K / U || 0,
        y: q / U || 0
      };
    }
    function Mt(U, K) {
      return U === K ? $ : f(U) >= f(K) ? U < 0 ? z : at : K < 0 ? ct : St;
    }
    function Ot(U, K, q) {
      q || (q = N);
      var ot = K[q[0]] - U[q[0]], Et = K[q[1]] - U[q[1]];
      return Math.sqrt(ot * ot + Et * Et);
    }
    function kt(U, K, q) {
      q || (q = N);
      var ot = K[q[0]] - U[q[0]], Et = K[q[1]] - U[q[1]];
      return Math.atan2(Et, ot) * 180 / Math.PI;
    }
    function de(U, K) {
      return kt(K[1], K[0], G) + kt(U[1], U[0], G);
    }
    function Pe(U, K) {
      return Ot(K[0], K[1], G) / Ot(U[0], U[1], G);
    }
    var Me = {
      mousedown: R,
      mousemove: V,
      mouseup: tt
    }, Ce = "mousedown", $e = "mousemove mouseup";
    function bn() {
      this.evEl = Ce, this.evWin = $e, this.pressed = !1, nt.apply(this, arguments);
    }
    y(bn, nt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(K) {
        var q = Me[K.type];
        q & R && K.button === 0 && (this.pressed = !0), q & V && K.which !== 1 && (q = tt), this.pressed && (q & tt && (this.pressed = !1), this.callback(this.manager, q, {
          pointers: [K],
          changedPointers: [K],
          pointerType: vt,
          srcEvent: K
        }));
      }
    });
    var Ye = {
      pointerdown: R,
      pointermove: V,
      pointerup: tt,
      pointercancel: Y,
      pointerout: Y
    }, Hn = {
      2: Z,
      3: dt,
      4: vt,
      5: bt
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, fn = "pointerdown", Fe = "pointermove pointerup pointercancel";
    t.MSPointerEvent && !t.PointerEvent && (fn = "MSPointerDown", Fe = "MSPointerMove MSPointerUp MSPointerCancel");
    function pn() {
      this.evEl = fn, this.evWin = Fe, nt.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    y(pn, nt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(K) {
        var q = this.store, ot = !1, Et = K.type.toLowerCase().replace("ms", ""), Rt = Ye[Et], ne = Hn[K.pointerType] || K.pointerType, vn = ne == Z, Pn = L(q, K.pointerId, "pointerId");
        Rt & R && (K.button === 0 || vn) ? Pn < 0 && (q.push(K), Pn = q.length - 1) : Rt & (tt | Y) && (ot = !0), !(Pn < 0) && (q[Pn] = K, this.callback(this.manager, Rt, {
          pointers: q,
          changedPointers: [K],
          pointerType: ne,
          srcEvent: K
        }), ot && q.splice(Pn, 1));
      }
    });
    var mn = {
      touchstart: R,
      touchmove: V,
      touchend: tt,
      touchcancel: Y
    }, we = "touchstart", gn = "touchstart touchmove touchend touchcancel";
    function ze() {
      this.evTarget = we, this.evWin = gn, this.started = !1, nt.apply(this, arguments);
    }
    y(ze, nt, {
      handler: function(K) {
        var q = mn[K.type];
        if (q === R && (this.started = !0), !!this.started) {
          var ot = On.call(this, K, q);
          q & (tt | Y) && ot[0].length - ot[1].length === 0 && (this.started = !1), this.callback(this.manager, q, {
            pointers: ot[0],
            changedPointers: ot[1],
            pointerType: Z,
            srcEvent: K
          });
        }
      }
    });
    function On(U, K) {
      var q = A(U.touches), ot = A(U.changedTouches);
      return K & (tt | Y) && (q = D(q.concat(ot), "identifier", !0)), [q, ot];
    }
    var qe = {
      touchstart: R,
      touchmove: V,
      touchend: tt,
      touchcancel: Y
    }, se = "touchstart touchmove touchend touchcancel";
    function mi() {
      this.evTarget = se, this.targetIds = {}, nt.apply(this, arguments);
    }
    y(mi, nt, {
      handler: function(K) {
        var q = qe[K.type], ot = Xe.call(this, K, q);
        ot && this.callback(this.manager, q, {
          pointers: ot[0],
          changedPointers: ot[1],
          pointerType: Z,
          srcEvent: K
        });
      }
    });
    function Xe(U, K) {
      var q = A(U.touches), ot = this.targetIds;
      if (K & (R | V) && q.length === 1)
        return ot[q[0].identifier] = !0, [q, q];
      var Et, Rt, ne = A(U.changedTouches), vn = [], Pn = this.target;
      if (Rt = q.filter(function(yn) {
        return T(yn.target, Pn);
      }), K === R)
        for (Et = 0; Et < Rt.length; )
          ot[Rt[Et].identifier] = !0, Et++;
      for (Et = 0; Et < ne.length; )
        ot[ne[Et].identifier] && vn.push(ne[Et]), K & (tt | Y) && delete ot[ne[Et].identifier], Et++;
      if (vn.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          D(Rt.concat(vn), "identifier", !0),
          vn
        ];
    }
    var sn = 2500, Ue = 25;
    function wn() {
      nt.apply(this, arguments);
      var U = E(this.handler, this);
      this.touch = new mi(this.manager, U), this.mouse = new bn(this.manager, U), this.primaryTouch = null, this.lastTouches = [];
    }
    y(wn, nt, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(K, q, ot) {
        var Et = ot.pointerType == Z, Rt = ot.pointerType == vt;
        if (!(Rt && ot.sourceCapabilities && ot.sourceCapabilities.firesTouchEvents)) {
          if (Et)
            ii.call(this, q, ot);
          else if (Rt && Cs.call(this, ot))
            return;
          this.callback(K, q, ot);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function ii(U, K) {
      U & R ? (this.primaryTouch = K.changedPointers[0].identifier, oa.call(this, K)) : U & (tt | Y) && oa.call(this, K);
    }
    function oa(U) {
      var K = U.changedPointers[0];
      if (K.identifier === this.primaryTouch) {
        var q = { x: K.clientX, y: K.clientY };
        this.lastTouches.push(q);
        var ot = this.lastTouches, Et = function() {
          var Rt = ot.indexOf(q);
          Rt > -1 && ot.splice(Rt, 1);
        };
        setTimeout(Et, sn);
      }
    }
    function Cs(U) {
      for (var K = U.srcEvent.clientX, q = U.srcEvent.clientY, ot = 0; ot < this.lastTouches.length; ot++) {
        var Et = this.lastTouches[ot], Rt = Math.abs(K - Et.x), ne = Math.abs(q - Et.y);
        if (Rt <= Ue && ne <= Ue)
          return !0;
      }
      return !1;
    }
    var xs = _(a.style, "touchAction"), kr = xs !== r, Bn = "compute", gi = "auto", Hr = "manipulation", Ve = "none", vi = "pan-x", yi = "pan-y", Ze = bs();
    function Gi(U, K) {
      this.manager = U, this.set(K);
    }
    Gi.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(U) {
        U == Bn && (U = this.compute()), kr && this.manager.element.style && Ze[U] && (this.manager.element.style[xs] = U), this.actions = U.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var U = [];
        return h(this.manager.recognizers, function(K) {
          C(K.options.enable, [K]) && (U = U.concat(K.getTouchAction()));
        }), Or(U.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(U) {
        var K = U.srcEvent, q = U.offsetDirection;
        if (this.manager.session.prevented) {
          K.preventDefault();
          return;
        }
        var ot = this.actions, Et = O(ot, Ve) && !Ze[Ve], Rt = O(ot, yi) && !Ze[yi], ne = O(ot, vi) && !Ze[vi];
        if (Et) {
          var vn = U.pointers.length === 1, Pn = U.distance < 2, yn = U.deltaTime < 250;
          if (vn && Pn && yn)
            return;
        }
        if (!(ne && Rt) && (Et || Rt && q & F || ne && q & M))
          return this.preventSrc(K);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(U) {
        this.manager.session.prevented = !0, U.preventDefault();
      }
    };
    function Or(U) {
      if (O(U, Ve))
        return Ve;
      var K = O(U, vi), q = O(U, yi);
      return K && q ? Ve : K || q ? K ? vi : yi : O(U, Hr) ? Hr : gi;
    }
    function bs() {
      if (!kr)
        return !1;
      var U = {}, K = t.CSS && t.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(q) {
        U[q] = K ? t.CSS.supports("touch-action", q) : !0;
      }), U;
    }
    var Nn = 1, Tn = 2, ri = 4, Dn = 8, Fn = Dn, Je = 16, Yn = 32;
    function si(U) {
      this.options = g({}, this.defaults, U || {}), this.id = B(), this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = Nn, this.simultaneous = {}, this.requireFail = [];
    }
    si.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(U) {
        return g(this.options, U), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(U) {
        if (c(U, "recognizeWith", this))
          return this;
        var K = this.simultaneous;
        return U = sr(U, this), K[U.id] || (K[U.id] = U, U.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(U) {
        return c(U, "dropRecognizeWith", this) ? this : (U = sr(U, this), delete this.simultaneous[U.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(U) {
        if (c(U, "requireFailure", this))
          return this;
        var K = this.requireFail;
        return U = sr(U, this), L(K, U) === -1 && (K.push(U), U.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(U) {
        if (c(U, "dropRequireFailure", this))
          return this;
        U = sr(U, this);
        var K = L(this.requireFail, U);
        return K > -1 && this.requireFail.splice(K, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(U) {
        return !!this.simultaneous[U.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(U) {
        var K = this, q = this.state;
        function ot(Et) {
          K.manager.emit(Et, U);
        }
        q < Dn && ot(K.options.event + Tr(q)), ot(K.options.event), U.additionalEvent && ot(U.additionalEvent), q >= Dn && ot(K.options.event + Tr(q));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(U) {
        if (this.canEmit())
          return this.emit(U);
        this.state = Yn;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var U = 0; U < this.requireFail.length; ) {
          if (!(this.requireFail[U].state & (Yn | Nn)))
            return !1;
          U++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(U) {
        var K = g({}, U);
        if (!C(this.options.enable, [this, K])) {
          this.reset(), this.state = Yn;
          return;
        }
        this.state & (Fn | Je | Yn) && (this.state = Nn), this.state = this.process(K), this.state & (Tn | ri | Dn | Je) && this.tryEmit(K);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(U) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function Tr(U) {
      return U & Je ? "cancel" : U & Dn ? "end" : U & ri ? "move" : U & Tn ? "start" : "";
    }
    function Yr(U) {
      return U == St ? "down" : U == ct ? "up" : U == z ? "left" : U == at ? "right" : "";
    }
    function sr(U, K) {
      var q = K.manager;
      return q ? q.get(U) : U;
    }
    function Xn() {
      si.apply(this, arguments);
    }
    y(Xn, si, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(U) {
        var K = this.options.pointers;
        return K === 0 || U.pointers.length === K;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(U) {
        var K = this.state, q = U.eventType, ot = K & (Tn | ri), Et = this.attrTest(U);
        return ot && (q & Y || !Et) ? K | Je : ot || Et ? q & tt ? K | Dn : K & Tn ? K | ri : Tn : Yn;
      }
    });
    function Ei() {
      Xn.apply(this, arguments), this.pX = null, this.pY = null;
    }
    y(Ei, Xn, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: I
      },
      getTouchAction: function() {
        var U = this.options.direction, K = [];
        return U & F && K.push(yi), U & M && K.push(vi), K;
      },
      directionTest: function(U) {
        var K = this.options, q = !0, ot = U.distance, Et = U.direction, Rt = U.deltaX, ne = U.deltaY;
        return Et & K.direction || (K.direction & F ? (Et = Rt === 0 ? $ : Rt < 0 ? z : at, q = Rt != this.pX, ot = Math.abs(U.deltaX)) : (Et = ne === 0 ? $ : ne < 0 ? ct : St, q = ne != this.pY, ot = Math.abs(U.deltaY))), U.direction = Et, q && ot > K.threshold && Et & K.direction;
      },
      attrTest: function(U) {
        return Xn.prototype.attrTest.call(this, U) && (this.state & Tn || !(this.state & Tn) && this.directionTest(U));
      },
      emit: function(U) {
        this.pX = U.deltaX, this.pY = U.deltaY;
        var K = Yr(U.direction);
        K && (U.additionalEvent = this.options.event + K), this._super.emit.call(this, U);
      }
    });
    function Xr() {
      Xn.apply(this, arguments);
    }
    y(Xr, Xn, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ve];
      },
      attrTest: function(U) {
        return this._super.attrTest.call(this, U) && (Math.abs(U.scale - 1) > this.options.threshold || this.state & Tn);
      },
      emit: function(U) {
        if (U.scale !== 1) {
          var K = U.scale < 1 ? "in" : "out";
          U.additionalEvent = this.options.event + K;
        }
        this._super.emit.call(this, U);
      }
    });
    function Zr() {
      si.apply(this, arguments), this._timer = null, this._input = null;
    }
    y(Zr, si, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [gi];
      },
      process: function(U) {
        var K = this.options, q = U.pointers.length === K.pointers, ot = U.distance < K.threshold, Et = U.deltaTime > K.time;
        if (this._input = U, !ot || !q || U.eventType & (tt | Y) && !Et)
          this.reset();
        else if (U.eventType & R)
          this.reset(), this._timer = u(function() {
            this.state = Fn, this.tryEmit();
          }, K.time, this);
        else if (U.eventType & tt)
          return Fn;
        return Yn;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(U) {
        this.state === Fn && (U && U.eventType & tt ? this.manager.emit(this.options.event + "up", U) : (this._input.timeStamp = d(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function Pr() {
      Xn.apply(this, arguments);
    }
    y(Pr, Xn, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ve];
      },
      attrTest: function(U) {
        return this._super.attrTest.call(this, U) && (Math.abs(U.rotation) > this.options.threshold || this.state & Tn);
      }
    });
    function ki() {
      Xn.apply(this, arguments);
    }
    y(ki, Xn, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: F | M,
        pointers: 1
      },
      getTouchAction: function() {
        return Ei.prototype.getTouchAction.call(this);
      },
      attrTest: function(U) {
        var K = this.options.direction, q;
        return K & (F | M) ? q = U.overallVelocity : K & F ? q = U.overallVelocityX : K & M && (q = U.overallVelocityY), this._super.attrTest.call(this, U) && K & U.offsetDirection && U.distance > this.options.threshold && U.maxPointers == this.options.pointers && f(q) > this.options.velocity && U.eventType & tt;
      },
      emit: function(U) {
        var K = Yr(U.offsetDirection);
        K && this.manager.emit(this.options.event + K, U), this.manager.emit(this.options.event, U);
      }
    });
    function Di() {
      si.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    y(Di, si, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [Hr];
      },
      process: function(U) {
        var K = this.options, q = U.pointers.length === K.pointers, ot = U.distance < K.threshold, Et = U.deltaTime < K.time;
        if (this.reset(), U.eventType & R && this.count === 0)
          return this.failTimeout();
        if (ot && Et && q) {
          if (U.eventType != tt)
            return this.failTimeout();
          var Rt = this.pTime ? U.timeStamp - this.pTime < K.interval : !0, ne = !this.pCenter || Ot(this.pCenter, U.center) < K.posThreshold;
          this.pTime = U.timeStamp, this.pCenter = U.center, !ne || !Rt ? this.count = 1 : this.count += 1, this._input = U;
          var vn = this.count % K.taps;
          if (vn === 0)
            return this.hasRequireFailures() ? (this._timer = u(function() {
              this.state = Fn, this.tryEmit();
            }, K.interval, this), Tn) : Fn;
        }
        return Yn;
      },
      failTimeout: function() {
        return this._timer = u(function() {
          this.state = Yn;
        }, this.options.interval, this), Yn;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == Fn && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function Se(U, K) {
      return K = K || {}, K.recognizers = x(K.recognizers, Se.defaults.preset), new Jr(U, K);
    }
    Se.VERSION = "2.0.7", Se.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: Bn,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [Pr, { enable: !1 }],
        [Xr, { enable: !1 }, ["rotate"]],
        [ki, { direction: F }],
        [Ei, { direction: F }, ["swipe"]],
        [Di],
        [Di, { event: "doubletap", taps: 2 }, ["tap"]],
        [Zr]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var Zn = 1, Os = 2;
    function Jr(U, K) {
      this.options = g({}, Se.defaults, K || {}), this.options.inputTarget = this.options.inputTarget || U, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = U, this.input = lt(this), this.touchAction = new Gi(this, this.options.touchAction), Qr(this, !0), h(this.options.recognizers, function(q) {
        var ot = this.add(new q[0](q[1]));
        q[2] && ot.recognizeWith(q[2]), q[3] && ot.requireFailure(q[3]);
      }, this);
    }
    Jr.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(U) {
        return g(this.options, U), U.touchAction && this.touchAction.update(), U.inputTarget && (this.input.destroy(), this.input.target = U.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(U) {
        this.session.stopped = U ? Os : Zn;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(U) {
        var K = this.session;
        if (!K.stopped) {
          this.touchAction.preventDefaults(U);
          var q, ot = this.recognizers, Et = K.curRecognizer;
          (!Et || Et && Et.state & Fn) && (Et = K.curRecognizer = null);
          for (var Rt = 0; Rt < ot.length; )
            q = ot[Rt], K.stopped !== Os && // 1
            (!Et || q == Et || // 2
            q.canRecognizeWith(Et)) ? q.recognize(U) : q.reset(), !Et && q.state & (Tn | ri | Dn) && (Et = K.curRecognizer = q), Rt++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(U) {
        if (U instanceof si)
          return U;
        for (var K = this.recognizers, q = 0; q < K.length; q++)
          if (K[q].options.event == U)
            return K[q];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(U) {
        if (c(U, "add", this))
          return this;
        var K = this.get(U.options.event);
        return K && this.remove(K), this.recognizers.push(U), U.manager = this, this.touchAction.update(), U;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(U) {
        if (c(U, "remove", this))
          return this;
        if (U = this.get(U), U) {
          var K = this.recognizers, q = L(K, U);
          q !== -1 && (K.splice(q, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(U, K) {
        if (U !== r && K !== r) {
          var q = this.handlers;
          return h(S(U), function(ot) {
            q[ot] = q[ot] || [], q[ot].push(K);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(U, K) {
        if (U !== r) {
          var q = this.handlers;
          return h(S(U), function(ot) {
            K ? q[ot] && q[ot].splice(L(q[ot], K), 1) : delete q[ot];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(U, K) {
        this.options.domEvents && Hi(U, K);
        var q = this.handlers[U] && this.handlers[U].slice();
        if (!(!q || !q.length)) {
          K.type = U, K.preventDefault = function() {
            K.srcEvent.preventDefault();
          };
          for (var ot = 0; ot < q.length; )
            q[ot](K), ot++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && Qr(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function Qr(U, K) {
      var q = U.element;
      if (q.style) {
        var ot;
        h(U.options.cssProps, function(Et, Rt) {
          ot = _(q.style, Rt), K ? (U.oldCssProps[ot] = q.style[ot], q.style[ot] = Et) : q.style[ot] = U.oldCssProps[ot] || "";
        }), K || (U.oldCssProps = {});
      }
    }
    function Hi(U, K) {
      var q = n.createEvent("Event");
      q.initEvent(U, !0, !0), q.gesture = K, K.target.dispatchEvent(q);
    }
    g(Se, {
      INPUT_START: R,
      INPUT_MOVE: V,
      INPUT_END: tt,
      INPUT_CANCEL: Y,
      STATE_POSSIBLE: Nn,
      STATE_BEGAN: Tn,
      STATE_CHANGED: ri,
      STATE_ENDED: Dn,
      STATE_RECOGNIZED: Fn,
      STATE_CANCELLED: Je,
      STATE_FAILED: Yn,
      DIRECTION_NONE: $,
      DIRECTION_LEFT: z,
      DIRECTION_RIGHT: at,
      DIRECTION_UP: ct,
      DIRECTION_DOWN: St,
      DIRECTION_HORIZONTAL: F,
      DIRECTION_VERTICAL: M,
      DIRECTION_ALL: I,
      Manager: Jr,
      Input: nt,
      TouchAction: Gi,
      TouchInput: mi,
      MouseInput: bn,
      PointerEventInput: pn,
      TouchMouseInput: wn,
      SingleTouchInput: ze,
      Recognizer: si,
      AttrRecognizer: Xn,
      Tap: Di,
      Pan: Ei,
      Swipe: ki,
      Pinch: Xr,
      Rotate: Pr,
      Press: Zr,
      on: b,
      off: P,
      each: h,
      merge: v,
      extend: m,
      assign: g,
      inherit: y,
      bindFn: E,
      prefixed: _
    });
    var qr = typeof t < "u" ? t : typeof self < "u" ? self : {};
    qr.Hammer = Se, typeof r == "function" && r.amd ? r(function() {
      return Se;
    }) : e.exports ? e.exports = Se : t[s] = Se;
  })(window, document, "Hammer");
})(m_);
var q6 = m_.exports;
const tH = /* @__PURE__ */ qo(q6);
let g_ = null;
const eH = (e) => {
  g_ = e;
}, nH = () => g_, iH = $t.extend({
  data: () => ({
    resizeObserver: null
  }),
  computed: {
    ...Ee(["components"]),
    layout() {
      return nH();
    }
  },
  mounted() {
    this.resizeObserver = new ResizeObserver(this.updateClientDimensions), this.resizeObserver.observe(this.$root.$el), this.updateClientDimensions();
  },
  beforeDestroy() {
    this.resizeObserver instanceof ResizeObserver && this.resizeObserver.unobserve(this.$root.$el);
  },
  methods: {
    ...$r(["setClientWidth", "setClientHeight"]),
    updateClientDimensions() {
      this.setClientWidth(this.$root.$el.clientWidth), this.setClientHeight(this.$root.$el.clientHeight);
    }
  }
});
function Re(e, t, n, s, r, i, a, o) {
  var l = typeof e == "function" ? e.options : e;
  t && (l.render = t, l.staticRenderFns = n, l._compiled = !0), s && (l.functional = !0), i && (l._scopeId = "data-v-" + i);
  var f;
  if (a ? (f = function(c) {
    c = c || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !c && typeof __VUE_SSR_CONTEXT__ < "u" && (c = __VUE_SSR_CONTEXT__), r && r.call(this, c), c && c._registeredComponents && c._registeredComponents.add(a);
  }, l._ssrRegister = f) : r && (f = o ? function() {
    r.call(
      this,
      (l.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : r), f)
    if (l.functional) {
      l._injectStyles = f;
      var d = l.render;
      l.render = function(h, p) {
        return f.call(p), d(h, p);
      };
    } else {
      var u = l.beforeCreate;
      l.beforeCreate = u ? [].concat(u, f) : [f];
    }
  return {
    exports: e,
    options: l
  };
}
var rH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.layout, { tag: "component", staticClass: "map-ui" });
}, sH = [], aH = /* @__PURE__ */ Re(
  iH,
  rH,
  sH,
  !1,
  null,
  "d410bb1c",
  null,
  null
);
const oH = aH.exports;
const lH = $t.extend({
  components: {
    MapUi: oH
  },
  props: {
    mapConfiguration: {
      type: Object,
      required: !0
    }
  },
  data: () => ({
    lang: "de",
    noControlOnZoom: !1,
    noControlOnZoomTimeout: void 0,
    oneFingerPan: !1,
    oneFingerPanTimeout: void 0
  }),
  computed: {
    ...Ee(["hasWindowSize"])
  },
  watch: {
    // NOTE: Updates can happen if a user resizes the window or the fullscreen plugin is used.
    //       Added as a watcher to trigger the update at the correct time.
    hasWindowSize: function(e) {
      this.updateDragAndZoomInteractions(), this.updateListeners(e);
    }
  },
  mounted() {
    var t, n;
    const e = Q6.map.createMap(
      {
        target: this.$refs["polar-map-container"],
        ...this.mapConfiguration
      },
      "2D",
      {
        mapParams: {
          interactions: By({
            altShiftDragRotate: !1,
            pinchRotate: !1,
            dragPan: !1,
            mouseWheelZoom: !1
          })
        }
      }
    );
    this.setMap(e), this.updateDragAndZoomInteractions(), this.updateListeners(this.hasWindowSize), this.setConfiguration(this.mapConfiguration), (n = (t = this.mapConfiguration.locales) == null ? void 0 : t.forEach) == null || n.call(
      t,
      (s) => xn.addResourceBundle(s.type, "common", s.resources, !0)
    ), xn.on("languageChanged", (s) => {
      this.lang = s;
    }), this.mapConfiguration.checkServiceAvailability && this.checkServiceAvailability();
  },
  methods: {
    ...$r(["setMap", "setConfiguration"]),
    ...br(["updateDragAndZoomInteractions"]),
    checkServiceAvailability() {
      this.mapConfiguration.layerConf.map((e) => ({
        ping: ES(e),
        service: e
      })).forEach(
        ({ ping: e, service: t }) => e.then((n) => {
          n !== 200 && (this.$store.hasModule(["plugin", "toast"]) && this.$store.dispatch("plugin/toast/addToast", {
            type: "warning",
            text: xn.t("common:error.serviceUnavailable", {
              serviceId: t.id,
              serviceName: t.name
            })
          }), console.error(
            `Ping to "${t.id}" returned "${n}".`
          ), this.$store.commit("setErrors", [
            ...this.$store.getters.errors,
            {
              type: "connection",
              statusCode: n,
              text: `Ping to "${t.id}" returned "${n}".`
            }
          ]));
        }).catch(console.error)
      );
    },
    updateListeners(e) {
      e || (document.addEventListener("wheel", ({ ctrlKey: t }) => {
        clearTimeout(this.noControlOnZoomTimeout), this.noControlOnZoom = !t, this.noControlOnZoomTimeout = setTimeout(
          () => this.noControlOnZoom = !1,
          2e3
        );
      }), (window.innerHeight <= wv || window.innerWidth <= Vv) && new tH(this.$refs["polar-map-container"]).on("pan", (t) => {
        this.oneFingerPan = t.maxPointers === 1, setTimeout(() => this.oneFingerPan = !1, 2e3);
      }));
    }
  }
});
var uH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-app", { staticClass: "polar-wrapper", attrs: { lang: t.lang } }, [n("transition", { attrs: { name: "fade" } }, [!t.hasWindowSize && (t.noControlOnZoom || t.oneFingerPan) ? n("div", { staticClass: "polar-map-overlay" }, [t.noControlOnZoom ? [t._v(" " + t._s(t.$t("common:overlay.noControlOnZoom")) + " ")] : t.oneFingerPan ? [t._v(" " + t._s(t.$t("common:overlay.oneFingerPan")) + " ")] : t._e()], 2) : t._e()]), n("div", { ref: "polar-map-container", staticClass: "polar-map", attrs: { tabindex: "0", "aria-label": t.$t("common:canvas.label") } }), n("MapUi")], 1);
}, cH = [], hH = /* @__PURE__ */ Re(
  lH,
  uH,
  cH,
  !1,
  null,
  "7d603b48",
  null,
  null
);
const dH = hH.exports, fH = Symbol("Path could not be resolved."), pH = (e, t) => t.reduce(
  (n, s) => n && Object.prototype.hasOwnProperty.call(n, s) ? n[s] : fH,
  e
);
function mH(e, t, n = !0) {
  const s = e.split("/");
  return this.$store.watch((r) => pH(r, s), t, {
    immediate: n
  });
}
function gH({
  containerId: e,
  mapConfiguration: t
}) {
  const n = EG(t == null ? void 0 : t.vuetify);
  n.framework.theme.checkOrCreateStyleElement = function() {
    return this.styleEl || this.genStyleElement(), !!this.styleEl;
  };
  const s = 500, r = 10;
  let i = document.getElementById(e), a = 0;
  return new Promise((o, l) => {
    const f = setInterval(() => {
      if (i) {
        clearInterval(f);
        const d = i.attachShadow({ mode: "open" }), { querySelector: u } = document;
        document.querySelector = function(C) {
          return C === "[data-app]" ? d : u.call(this, C);
        };
        const c = "link", h = [...document.getElementsByTagName(c)], p = "data-polar", g = h.filter(
          (C) => C.getAttribute(p)
        );
        g.length > 0 ? g.map((C) => C.cloneNode(!0)).forEach((C) => d.appendChild(C)) : console.error(
          `core.createMap: Couldn't find required stylesheets, map won' render. Please add "data-polar" to the respective link-tag. The use value for the attribute can be chosen arbitrarily.`
        );
        const m = new $t({
          vuetify: n,
          store: n_,
          i18n: b6(t == null ? void 0 : t.language),
          // use a fresh div injected to the shadow root
          el: d.appendChild(document.createElement("div")),
          render: (C) => C(dH, {
            props: {
              mapConfiguration: t
            }
          })
        }), v = document.getElementById("vuetify-theme-stylesheet");
        d.appendChild(v), m.subscribe = mH;
        let y = 0;
        const E = setInterval(() => {
          const C = m.$store.getters.map.getSize();
          y++ < 100 && (C[0] === 0 || C[1] === 0) ? m.$store.getters.map.updateSize() : clearInterval(E);
        }, 0);
        o(m);
      } else {
        if (a >= r) {
          clearInterval(f), l(
            new Error(`containerId "${e}" not found on website.
                        Map client won't render.
                        Giving up after ${a} ${r}.`)
          );
          return;
        }
        console.error(
          `containerId "${e}" not found on website.
            Map client won't render.
            Retrying in ${s}ms ...`
        ), i = document.getElementById(e), a++;
      }
    }, s);
  });
}
const vH = Xs.prototype.addLayer;
Xs.prototype.addLayer = function(...e) {
  vH.call(this, ...e), Xs.prototype.getLayers.call(this).array_.forEach((t) => {
    const n = t.getSource();
    n.crossOrigin = "anonymous", t.setSource(n);
  });
};
const v_ = /{(?<key>[^=]+)=(?<value>[^}]+)}/gm;
function yH(e, t) {
  const n = {}, s = t.replaceAll(v_, (r, i, a) => (n[i] = a, ""));
  fetch(s, { method: "GET", headers: n }).then(
    (r) => r.ok ? r.blob() : r.text().then((i) => {
      throw i;
    })
  ).then((r) => {
    r && (e.getImage().src = URL.createObjectURL(r));
  }).catch(console.error);
}
const EH = Xs.prototype.addLayer;
Xs.prototype.addLayer = function(...e) {
  EH.call(this, ...e), Xs.prototype.getLayers.call(this).array_.forEach((t) => {
    var r;
    const n = t.getSource();
    ((r = n == null ? void 0 : n.urls) == null ? void 0 : r.some((i) => v_.test(i))) && typeof n.setTileLoadFunction == "function" && (n.setTileLoadFunction(yH), t.setSource(n));
  });
};
const CH = $t.extend({
  props: {
    pluginContainer: {
      type: Object,
      required: !0
    }
  }
});
var xH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.pluginContainer.plugin, t._b({ tag: "component", staticClass: "polar-clickable" }, "component", t.pluginContainer.options.props, !1));
}, bH = [], OH = /* @__PURE__ */ Re(
  CH,
  xH,
  bH,
  !1,
  null,
  null,
  null,
  null
);
const TH = OH.exports;
function PH(e, t) {
  const n = [];
  for (let s = 0; s < e.length; s++)
    e[s].options.layoutTag === t && n.push(e[s]);
  return n;
}
var go = /* @__PURE__ */ ((e) => (e.TOP_LEFT = "top-left top left nine-layout", e.TOP_MIDDLE = "top-mid mid top nine-layout", e.TOP_RIGHT = "top-right top right nine-layout", e.MIDDLE_LEFT = "mid-left mid left nine-layout", e.MIDDLE_MIDDLE = "mid-mid mid nine-layout", e.MIDDLE_RIGHT = "mid-right mid right nine-layout", e.BOTTOM_LEFT = "bottom-left bottom left nine-layout", e.BOTTOM_MIDDLE = "bottom-mid mid bottom nine-layout", e.BOTTOM_RIGHT = "bottom-right bottom right nine-layout", e))(go || {});
const gT = Object.values(go), MH = $t.extend({
  components: {
    PluginVessel: TH
  },
  data: () => ({
    tags: gT
  }),
  computed: {
    ...Ee(["components", "hasWindowSize"]),
    // creating plugin lists for all enums
    //  reduces to list of functions, each returning a list of plugins which are sorted by layout
    ...gT.reduce((e, t) => (e[t] = function() {
      return PH(this.components, t);
    }, e), {})
  },
  methods: {
    getSortedTo(e) {
      return this[e];
    }
  }
});
var SH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "wrapper" }, t._l(t.tags, function(s, r) {
    return n("div", { key: r, class: {
      [s]: !0,
      "has-window-size": t.hasWindowSize
    } }, t._l(t.getSortedTo(s), function(i, a) {
      return n("plugin-vessel", t._b({ key: `${r}-${a}` }, "plugin-vessel", { pluginContainer: i }, !1));
    }), 1);
  }), 0);
}, IH = [], _H = /* @__PURE__ */ Re(
  MH,
  SH,
  IH,
  !1,
  null,
  "ba51450e",
  null,
  null
);
const DH = _H.exports, qh = {
  ...E5,
  addPlugins: C5,
  createMap: gH
}, AH = "@polar/client-meldemichel", LH = "0.1.0", RH = "Client Meldemichel", wH = "EUPL-1.2", VH = "Dataport AöR <dataport-polar-support@dataport.de>", BH = "dist/client-meldemichel.mjs", NH = [
  "dist/**/**.*",
  "docs/**/**.*",
  "example/**/**.*",
  "CHANGELOG.md",
  "API.md"
], FH = {
  postversion: "npm run build",
  build: "rimraf dist && vite build && copyfiles -f src/html/**/* dist"
}, jH = {
  "@polar/core": "*",
  "@polar/lib-custom-types": "*",
  "@polar/plugin-address-search": "*",
  "@polar/plugin-attributions": "*",
  "@polar/plugin-fullscreen": "*",
  "@polar/plugin-geo-location": "*",
  "@polar/plugin-gfi": "*",
  "@polar/plugin-icon-menu": "*",
  "@polar/plugin-layer-chooser": "*",
  "@polar/plugin-loading-indicator": "*",
  "@polar/plugin-pins": "*",
  "@polar/plugin-reverse-geocoder": "*",
  "@polar/plugin-scale": "*",
  "@polar/plugin-toast": "*",
  "@polar/plugin-zoom": "*"
}, UH = {
  name: AH,
  version: LH,
  description: RH,
  license: wH,
  author: VH,
  main: BH,
  files: NH,
  scripts: FH,
  devDependencies: jH
}, Na = {
  // display everything
  COMPLETE: "COMPLETE",
  // do not display AfmButton, reports, filter, list
  REPORT: "REPORT",
  /* do not display AfmButton, reports, filter, list
   * do display a single (maybe movable) feature */
  SINGLE: "SINGLE"
}, WH = [
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  200,
  202,
  203,
  204,
  205,
  400,
  401,
  402,
  500,
  501,
  502,
  503
], vT = {
  PROCESSING: 0,
  PROCESSED: 1
}, td = {
  NONE: 0,
  DAYS_7: 1,
  DAYS_30: 2,
  SELECTABLE: 3
}, $H = $t.extend({
  name: "AddressSearchGroupSelect",
  computed: {
    ...Ee("plugin/addressSearch", [
      "selectedGroupId",
      "groupSelectOptions",
      "hasMultipleGroups"
    ]),
    selectedItem: {
      get() {
        return this.selectedGroupId;
      },
      set(e) {
        this.setSelectedGroupId(e);
      }
    }
  },
  methods: {
    ...br("plugin/addressSearch", ["setSelectedGroupId"])
  }
});
var zH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.hasMultipleGroups ? n("v-select", { staticClass: "polar-plugin-address-search-group-select", attrs: { dense: "", "aria-label": t.$t("common:plugins.addressSearch.groupSelector"), items: (
    // mapping in template to guarantee update on language change
    t.groupSelectOptions.map(({ value: s, text: r }) => ({ value: s, text: t.$t(r) }))
  ) }, model: { value: t.selectedItem, callback: function(s) {
    t.selectedItem = s;
  }, expression: "selectedItem" } }, [n("div", { attrs: { slot: "selection" }, slot: "selection" })]) : t._e();
}, KH = [], GH = /* @__PURE__ */ Re(
  $H,
  zH,
  KH,
  !1,
  null,
  null,
  null,
  null
);
const kH = GH.exports, HH = (e, t) => {
  const n = e.toLowerCase().indexOf(t.toLowerCase());
  return n === -1 ? e : e.substring(0, n) + "<em>" + e.substring(n, n + t.length) + "</em>" + e.substring(n + t.length);
}, YH = $t.extend({
  name: "AddressSearchResults",
  data: () => ({
    openCategories: []
  }),
  computed: {
    ...Ee(["clientHeight", "hasWindowSize"]),
    ...Ee("plugin/addressSearch", [
      "featuresAvailable",
      "inputValue",
      "featureListsWithCategory",
      "limitResults",
      "selectedGroupId",
      "selectedGroup"
    ]),
    maxHeight() {
      return this.hasWindowSize ? this.clientHeight * 0.6 : 400;
    }
  },
  watch: {
    /* reset opened categories on group change */
    selectedGroupId() {
      this.openCategories = [];
    }
  },
  methods: {
    ...br("plugin/addressSearch", ["selectResult"]),
    toggle(e) {
      this.openCategories = this.openCategories.indexOf(e) === -1 ? [...this.openCategories, e] : this.openCategories.filter((t) => t !== e);
    },
    hasMaximum(e) {
      var t;
      return !!((t = e == null ? void 0 : e.queryParameters) != null && t.maxFeatures);
    },
    emTitleByInput: HH
  }
});
var XH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.featuresAvailable ? n("v-card", { staticClass: "mx-auto overflow-y-auto rounded-b-xl polar-plugin-address-search-toolbar-results", attrs: { tile: "", dense: "", "max-height": t.maxHeight } }, t._l(t.featureListsWithCategory, function({ features: s, category: r, categoryId: i }, a) {
    return n("v-list", { key: ["results-list", a].join("-"), attrs: { subheader: "" } }, [r ? n("v-subheader", { key: ["results-category", a].join("-") }, [t._v(" " + t._s(t.$t(r)) + " " + t._s(t.$t("common:plugins.addressSearch.resultCount", { count: s.length })) + " ")]) : t._e(), t._l(s, function(o, l) {
      return n("v-list-item", { key: ["results-feature", a, l].join("-"), class: {
        "polar-plugin-address-search-hidden-result": l >= (t.openCategories.includes(r) ? Number.MAX_SAFE_INTEGER : t.limitResults)
      }, on: { click: function(f) {
        return t.selectResult({ feature: o, categoryId: i });
      } } }, [n("v-list-item-title", [n("span", { domProps: { innerHTML: t._s(t.emTitleByInput(o.title, t.inputValue)) } })])], 1);
    }), s.length > t.limitResults ? n("v-btn", { staticClass: "text-none", attrs: { text: "", tile: "", block: "" }, on: { click: function(o) {
      return t.toggle(r);
    } } }, [n("v-icon", { staticClass: "mr-1", attrs: { "x-small": "" } }, [t._v(" " + t._s(t.openCategories.includes(r) ? "fa-chevron-up" : "fa-chevron-down") + " ")]), t._v(" " + t._s(t.$t(`common:plugins.addressSearch.resultList.${t.openCategories.includes(r) ? "reduce" : `extend${t.hasMaximum(t.selectedGroup[a]) ? "Max" : ""}`}`, t.selectedGroup[a])) + " ")], 1) : t._e(), r ? n("v-divider", { key: ["results-divider", a].join("-") }) : t._e()], 2);
  }), 1) : t._e();
}, ZH = [], JH = /* @__PURE__ */ Re(
  YH,
  XH,
  ZH,
  !1,
  null,
  null,
  null,
  null
);
const QH = JH.exports, qH = $t.extend({
  name: "AddressSearchInput",
  computed: {
    ...Ee("plugin/addressSearch", [
      "label",
      "placeholder",
      "hint",
      "minLength",
      "loading",
      "inputValue"
    ])
  },
  methods: {
    ...br("plugin/addressSearch", [
      "input",
      "abortAndRequest",
      "clear"
    ])
  }
});
var t7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-text-field", { attrs: { "prepend-icon": "fa-magnifying-glass", clearable: "", label: t.$t(t.label), placeholder: t.$t(t.placeholder), hint: t.$t(t.hint, { minLength: t.minLength }), loading: t.loading, value: t.inputValue }, on: { input: t.input, keydown: function(s) {
    return !s.type.indexOf("key") && t._k(s.keyCode, "enter", 13, s.key, "Enter") ? null : t.abortAndRequest.apply(null, arguments);
  }, "click:clear": t.clear } });
}, e7 = [], n7 = /* @__PURE__ */ Re(
  qH,
  t7,
  e7,
  !1,
  null,
  null,
  null,
  null
);
const i7 = n7.exports, r7 = $t.extend({
  name: "AddressSearch",
  components: {
    GroupSelect: kH,
    Input: i7,
    Results: QH
  },
  computed: {
    ...Ee(["clientWidth", "hasSmallWidth", "hasWindowSize"]),
    ...Ee("plugin/addressSearch", ["featuresAvailable"]),
    style() {
      return "z-index: 1;" + (this.hasWindowSize && this.hasSmallWidth ? `max-width: ${this.clientWidth * 0.75}px` : "");
    },
    toolbarClass() {
      return this.featuresAvailable ? "rounded-t-xl" : "rounded-xl";
    }
  }
});
var s7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-container", { style: t.style }, [n("v-toolbar", { staticClass: "polar-plugin-address-search-toolbar pt-1", class: t.toolbarClass, attrs: { height: "72" } }, [n("GroupSelect"), n("Input")], 1), n("Results")], 1);
}, a7 = [], o7 = /* @__PURE__ */ Re(
  r7,
  s7,
  a7,
  !1,
  null,
  null,
  null,
  null
);
const l7 = o7.exports, u7 = [
  {
    type: "de",
    resources: {
      plugins: {
        addressSearch: {
          hint: {
            error: "Etwas ist bei der Suche schiefgegangen.",
            noResults: "Keine Ergebnisse gefunden.",
            loading: "Suche ...",
            tooShort: "Für die Suche bitte mindestens {{minLength}} Zeichen eingeben."
          },
          defaultGroup: "Adresssuche",
          groupSelector: "Suchthema auswählen",
          resultCount: "({{count}} Ergebnisse)",
          resultList: {
            extend: "Alle Ergebnisse anzeigen",
            extendMax: "Alle Ergebnisse (max. {{queryParameters.maxFeatures}}) anzeigen",
            reduce: "Ergebnisliste reduzieren"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        addressSearch: {
          hint: {
            error: "Something went wrong.",
            noResults: "No results for the current query.",
            loading: "Searching ...",
            tooShort: "Please enter at least {{minLength}} characters."
          },
          defaultGroup: "Address Search",
          groupSelector: "Select search topic",
          resultCount: "({{count}} results)",
          resultList: {
            extend: "Show all results",
            extendMax: "Show all results (max. {{queryParameters.maxFeatures}})",
            reduce: "Reduce result list"
          }
        }
      }
    }
  }
];
var c7 = "Expected a function", yT = 0 / 0, h7 = "[object Symbol]", d7 = /^\s+|\s+$/g, f7 = /^[-+]0x[0-9a-f]+$/i, p7 = /^0b[01]+$/i, m7 = /^0o[0-7]+$/i, g7 = parseInt, v7 = typeof _t == "object" && _t && _t.Object === Object && _t, y7 = typeof self == "object" && self && self.Object === Object && self, E7 = v7 || y7 || Function("return this")(), C7 = Object.prototype, x7 = C7.toString, b7 = Math.max, O7 = Math.min, rg = function() {
  return E7.Date.now();
};
function T7(e, t, n) {
  var s, r, i, a, o, l, f = 0, d = !1, u = !1, c = !0;
  if (typeof e != "function")
    throw new TypeError(c7);
  t = ET(t) || 0, Nv(n) && (d = !!n.leading, u = "maxWait" in n, i = u ? b7(ET(n.maxWait) || 0, t) : i, c = "trailing" in n ? !!n.trailing : c);
  function h(b) {
    var P = s, T = r;
    return s = r = void 0, f = b, a = e.apply(T, P), a;
  }
  function p(b) {
    return f = b, o = setTimeout(v, t), d ? h(b) : a;
  }
  function g(b) {
    var P = b - l, T = b - f, O = t - P;
    return u ? O7(O, i - T) : O;
  }
  function m(b) {
    var P = b - l, T = b - f;
    return l === void 0 || P >= t || P < 0 || u && T >= i;
  }
  function v() {
    var b = rg();
    if (m(b))
      return y(b);
    o = setTimeout(v, g(b));
  }
  function y(b) {
    return o = void 0, c && s ? h(b) : (s = r = void 0, a);
  }
  function E() {
    o !== void 0 && clearTimeout(o), f = 0, s = l = r = o = void 0;
  }
  function C() {
    return o === void 0 ? a : y(rg());
  }
  function x() {
    var b = rg(), P = m(b);
    if (s = arguments, r = this, l = b, P) {
      if (o === void 0)
        return p(l);
      if (u)
        return o = setTimeout(v, t), h(l);
    }
    return o === void 0 && (o = setTimeout(v, t)), a;
  }
  return x.cancel = E, x.flush = C, x;
}
function Nv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function P7(e) {
  return !!e && typeof e == "object";
}
function M7(e) {
  return typeof e == "symbol" || P7(e) && x7.call(e) == h7;
}
function ET(e) {
  if (typeof e == "number")
    return e;
  if (M7(e))
    return yT;
  if (Nv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Nv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(d7, "");
  var n = p7.test(e);
  return n || m7.test(e) ? g7(e.slice(2), n ? 2 : 8) : f7.test(e) ? yT : +e;
}
var S7 = T7;
const y_ = /* @__PURE__ */ qo(S7), Ca = {
  ERROR: Symbol("error"),
  NO_SEARCH: Symbol("noSearch")
};
function E_(e) {
  if (!e.ok)
    throw new Error(
      `getFeatures/parseGazetteerResponse: ${e.status === 418 ? "The server refuses to brew coffee because it is, permanently, a teapot." : `The received status code ${e.status} indicates an error.`}`
    );
}
function I7(e, t, n, s, r) {
  return e.text().then((i) => {
    const a = [], o = new DOMParser().parseFromString(i, "application/xml").getElementsByTagName(`wfs:${t}`), l = {
      type: "FeatureCollection",
      features: a
    };
    let f;
    if (o.length === 0)
      return l;
    const d = Array.from(o), u = d[0].getElementsByTagName("iso19112:position").length > 0 ? `EPSG:${// NOTE: The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    d[0].getElementsByTagName("iso19112:position")[0].getElementsByTagName("gml:Point")[0].attributes[1].textContent.split("::")[1]}` : s;
    return d.forEach((c) => {
      const h = Object.values(
        ...n.map(
          (g) => c.getElementsByTagNameNS(g, "*")
        )
      ).reduce(
        (g, m) => ({ ...g, [m.localName]: m.textContent }),
        {}
      );
      if (c.getElementsByTagName("iso19112:position").length > 0) {
        const g = (
          // NOTE: The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          c.getElementsByTagName("iso19112:position")[0].getElementsByTagName("gml:pos")[0].textContent.split(" ").map((m) => parseFloat(m))
        );
        f = {
          type: "Point",
          coordinates: u === s ? g : ji(g, u, s)
        };
      }
      if (c.getElementsByTagName("iso19112:geographicExtent").length > 0) {
        const g = (
          // NOTE: The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          c.getElementsByTagName("iso19112:geographicExtent")[0].getElementsByTagName("gml:posList")[0].textContent.split(" ").map((m) => parseFloat(m)).reduce(
            (m, v, y, E) => y % 2 === 0 ? [...m, [E[y], E[y + 1]]] : m,
            []
          )
        );
        h.geographicExtent = {
          type: "Polygon",
          coordinates: [
            u === s ? g : g.map(
              (m) => ji(m, u, s)
            )
          ]
        };
      }
      const p = {
        epsg: s,
        type: "Feature",
        geometry: f,
        properties: h
      };
      r && r.length > 0 && (p.title = Array.isArray(r) ? r.reduce(
        (g, m) => g + h[m] + " ",
        ""
      ).slice(0, -1) : h[r]), a.push(p);
    }), l;
  });
}
function _7(e, t, n, s, r, i, a, o = {}) {
  let l = Object.entries(n).reduce(
    (f, d) => `${f}&${d[0]}=${d[1]}`,
    `${t}?service=WFS&request=GetFeature&version=${s}`
  );
  return l += o.maxFeatures ? `&${s === "2.0.0" ? "count" : "maxFeatures"}=${o.maxFeatures}` : "", l += o.storedQueryId ? `&StoredQuery_ID=${o.storedQueryId}` : "", fetch(encodeURI(l), { signal: e }).then((f) => (E_(f), I7(
    f,
    r,
    i,
    a,
    o == null ? void 0 : o.title
  )));
}
const sg = {}, C_ = (e) => {
  if (sg[e])
    return sg[e];
  const t = Array.from(e.matchAll(/{{(.*?)}}/g)), n = [];
  let s = 0;
  for (const r of t)
    s < r.index && (n.push(e.substring(s, r.index)), s = r.index), n.push(r), s += r[0].length;
  return sg[e] = n, n;
}, D7 = (e, t) => e.uninterpreted > t.uninterpreted ? 1 : e.uninterpreted < t.uninterpreted ? -1 : e.index > t.index ? 1 : e.index < t.index ? -1 : 0, A7 = (e, t, n) => {
  const r = [...e.map((o, l) => ({
    match: o,
    uninterpreted: n[l],
    patternLengthDiff: (t[l].match(/{{/g) || []).length - o.length,
    index: l
  }))].sort(D7).map(({ match: o }) => o), i = [];
  return r.filter((o) => {
    if (o.length === 0)
      return !1;
    const l = JSON.stringify(o);
    return i.includes(l) ? !1 : (i.push(l), !0);
  });
}, L7 = (e, t, n) => {
  const s = [], r = [];
  return e.forEach((a) => {
    const o = C_(a), l = [];
    let f = n;
    o.forEach((d) => {
      let u = "";
      if (Array.isArray(d)) {
        const c = d[1], h = t[c], p = f.match(new RegExp("^" + h));
        if (p !== null) {
          const g = p[1];
          l.push([c, g.trim()]), u = p[0].trim();
        }
      } else
        u = d.trim();
      f.startsWith(u) && (f = f.substring(u.length).trim());
    }), r.push(f.length), s.push(l);
  }), A7(s, e, r);
}, R7 = (e, t) => e.fillPercentage > t.fillPercentage ? -1 : e.fillPercentage < t.fillPercentage ? 1 : e.keys.length > t.keys.length ? -1 : e.keys.length < t.keys.length ? 1 : e.index > t.index ? -1 : e.index < t.index ? 1 : 0, w7 = (e, t) => {
  const n = e.properties || {}, i = [...t.map((o, l) => {
    const d = C_(o).reduce(
      (c, h) => Array.isArray(h) ? [...c, h[1]] : c,
      []
    ), u = d.reduce(
      (c, h) => typeof n[h] < "u" && n[h] !== "" ? c + 1 : c,
      0
    );
    return {
      pattern: o,
      keys: d,
      index: l,
      fillPercentage: u / d.length
    };
  })].sort(R7)[0];
  return i.keys.reduce(
    (o, l) => o.replace(`{{${l}}}`, n[l] || ""),
    i.pattern
  );
};
function V7(e, t, n) {
  const s = [], r = {
    type: "FeatureCollection",
    features: s
  };
  return e.text().then((i) => {
    const a = new Yc(), o = new Qs(), l = a.readFeatures(i), { srsName: f } = a.readFeatureCollectionMetadata(i);
    return l.forEach((d) => {
      const u = JSON.parse(o.writeFeature(d));
      u.title = "", t && (n ? u.title = w7(
        u,
        t
      ) : u.title = Array.isArray(t) ? t.map((c) => u.properties[c]).join(" ") : u.properties[t]), f && (u.epsg = "EPSG:" + f.split("::")[1]), s.push(u);
    }), r;
  });
}
const B7 = (e) => e.replace(/\r?\n|\r/g, ""), N7 = ({ maxFeatures: e }) => `
<?xml version="1.0" encoding="UTF-8"?>
<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" service="WFS" version="1.1.0" xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"${e ? ` maxFeatures="${e}"` : ""}>`, F7 = ({
  srsName: e,
  featurePrefix: t,
  typeName: n,
  xmlns: s
}) => `
<wfs:Query typeName="${t}:${n}" xmlns:${t}="${s}"${e ? ` srsName="${e}"` : ""}>
<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">`, CT = (e, t, { featurePrefix: n, useRightHandWildcard: s }) => `
<ogc:PropertyIsLike wildCard="*" singleChar="." escapeChar="!">
<ogc:PropertyName>${n}:${e}</ogc:PropertyName>
<ogc:Literal>${t}${typeof s == "boolean" && !s ? "" : "*"}</ogc:Literal>
</ogc:PropertyIsLike>`, j7 = "</ogc:Filter></wfs:Query>", U7 = "</wfs:GetFeature>", W7 = (e, t) => {
  let n = F7(t);
  if (e.length > 1)
    n += `<ogc:And>${e.map(([s, r]) => CT(s, r, t)).join("")}</ogc:And>`;
  else if (e.length === 1) {
    const [s, r] = e[0];
    n += CT(s, r, t);
  }
  return n + j7;
}, $7 = (e, t) => B7(
  N7(t) + e.map((n) => W7(n, t)).join("") + U7
);
function z7(e, t, n, s) {
  const { fieldName: r, patterns: i, patternKeys: a } = s;
  let o = [[[]]];
  r && i && console.error(
    "Using both fieldName and patterns for WFS search. These are mutually exclusive. Patterns will be ignored."
  ), r ? o = [[[r, n]]] : i && a ? o = L7(i, a, n) : console.error(
    'Incomplete WFS search configuration. Either "fieldName" or "patterns" and "patternKeys" are required.'
  );
  const l = $7(o, s);
  return fetch(encodeURI(t), { signal: e, method: "POST", body: l }).then(
    (f) => (E_(f), V7(f, r || i, !r))
  );
}
function K7(e, t, n, s) {
  let r = `${t}?query=${n.replace(" ", "+")}`;
  if (s) {
    for (const [a, o] of Object.entries(s).filter(
      ([l]) => l !== "filter" && l !== "epsg" && l !== "apiKey" && l !== "accessToken"
    ))
      r += `&${a}=${o}`;
    s.filter && Object.keys(s.filter).length > 0 && (r += "&filter=", r = Object.entries(s.filter).reduce((a, [o, l]) => `${a + o}:${l}&`, r).slice(0, -1));
  }
  const i = { signal: e };
  return s.accessToken ? i.headers = { Authorization: `Bearer ${s.accessToken}` } : s.apiKey && (i.headers = { "X-Api-Key": s.apiKey }), fetch(encodeURI(r), i).then((a) => a.json()).then((a) => ({
    ...a,
    features: a.features.map((o) => ({
      ...o,
      geometry: {
        ...o.geometry,
        coordinates: s.epsg === "EPSG:4326" ? o.geometry.coordinates : ji(
          o.geometry.coordinates,
          "EPSG:4326",
          s.epsg
        )
      },
      epsg: s.epsg,
      title: o.properties.text
    }))
  }));
}
function G7(e, t) {
  if (Array.isArray(e)) {
    const n = t.split(" ");
    return e.reduce(
      (s, r, i) => ({
        ...s,
        [r]: n[i]
      }),
      {}
    );
  }
  return { [e]: t };
}
function k7(e, t, n, s) {
  const r = {
    title: s.fieldName,
    storedQueryId: s.storedQueryId
  };
  return s.maxFeatures && (r.maxFeatures = s.maxFeatures), _7(
    e,
    t,
    G7(s.fieldName, n),
    s.version || "2.0.0",
    s.memberSuffix,
    Array.isArray(s.namespaces) ? s.namespaces : [s.namespaces],
    s.epsg,
    r
  );
}
const H7 = (e, t, n, s) => e.map((r) => {
  const { name: i, geometry: a } = r, o = [
    parseInt(a.coordinates[0]),
    parseInt(a.coordinates[1])
  ], l = s === n ? o : ji(o, s, n);
  return {
    ...r,
    signal: t,
    title: i,
    epsg: s,
    geometry: {
      ...a,
      coordinates: l
    }
  };
});
async function Y7(e, t, n, s) {
  z0(t);
  try {
    const r = await vS(n, {
      ...s,
      // always trigger search – control done on a higher level as minLength
      minCharacters: 0
    });
    if (r.length === 0)
      return {
        type: "FeatureCollection",
        features: []
      };
    const a = r[0].properties.position.Point[0].$.srsName;
    let o;
    return a.includes("::") ? o = `EPSG:${a.split("::")[1]}` : a.includes(":") ? o = a : console.error("Unknown formatting of projection:", a), {
      type: "FeatureCollection",
      features: H7(r, e, s.epsg, o)
    };
  } catch (r) {
    throw console.error(r), new Error("An error occurred while fetching the feature collection.");
  }
}
const Fv = { bkg: K7, gazetteer: k7, wfs: z7, mpapi: Y7 }, X7 = (e) => Object.entries(e).forEach(([t, n]) => {
  Fv[t] ? console.error(
    `AddressSearch: Method "${t}" already exists. Please choose a different name. Overrides are not allowed.`
  ) : Fv[t] = n;
});
function Z7(e) {
  const t = Fv[e];
  if (t)
    return t;
  throw new Error(
    `AddressSearch: The given type "${e}" does not define a valid searchMethod.`
  );
}
let Ls, xT;
const J7 = {
  setupModule({ getters: e }) {
    xT = y_(
      () => this.dispatch("plugin/addressSearch/load"),
      e.waitMs
    ).bind(this), e.searchMethods.filter(({ url: n }) => !n).forEach(
      (n) => console.error(
        `POLAR Plugin AddressSearch: A specification is missing an URL: (${JSON.stringify(
          n
        )})`
      )
    );
    const t = e.addressSearchConfiguration.customSearchMethods;
    t && X7(t);
  },
  setSelectedGroupId({ commit: e, dispatch: t, state: n }, s) {
    e("setSelectedGroupId", s), e("setSearchResults", Ca.NO_SEARCH), t("input", n.inputValue);
  },
  input({ commit: e, dispatch: t }, n) {
    e("setInputValue", n), t("abortAndRequest");
  },
  abortAndRequest() {
    Ls && (Ls.abort(), Ls = void 0), xT();
  },
  clear({ commit: e }) {
    e("setSearchResults", Ca.NO_SEARCH), e("setChosenAddress", null);
  },
  load({
    state: { inputValue: e },
    rootGetters: t,
    getters: n,
    commit: s,
    dispatch: r
  }) {
    const { minLength: i } = n.addressSearchConfiguration, a = n.selectedGroup;
    if (typeof e > "u" || e === null || e.length < i) {
      s("setSearchResults", Ca.NO_SEARCH), r("indicateLoading", !1);
      return;
    }
    r("indicateLoading", !0), Ls = new AbortController();
    const o = Ls, l = a.map(
      (f) => Z7(f.type)(
        Ls.signal,
        f.url,
        e,
        {
          ...f.queryParameters,
          epsg: t.configuration.epsg,
          map: t.map
        }
      )
    );
    return Promise.allSettled(l).then((f) => {
      const d = f.reduce(
        (u, c, h) => c.status === "fulfilled" ? [
          ...u,
          {
            value: c.value,
            index: h
          }
        ] : u,
        []
      );
      o.signal.aborted || f.filter(
        ({ status: u }) => u === "rejected"
      ).forEach(
        ({ reason: u }) => console.error(
          "AddressSearch: An error occurred while sending a request: ",
          u
        )
      ), s("setSearchResults", d);
    }).catch((f) => {
      console.error(
        "AddressSearch: An error occurred while searching.",
        f
      ), s("setSearchResults", Ca.ERROR);
    }).finally(() => {
      r("indicateLoading", !1);
    });
  },
  indicateLoading({ getters: { addressSearchConfiguration: e }, commit: t }, n) {
    t("setLoading", n);
    const { addLoading: s, removeLoading: r } = e;
    n && s && s.length > 0 ? t(s, "AddressSearch", { root: !0 }) : !n && r && r.length > 0 && t(r, "AddressSearch", { root: !0 });
  },
  selectResult(e, t) {
    var o;
    const { commit: n, getters: s } = e, { feature: r, categoryId: i } = t, a = (o = s.addressSearchConfiguration.customSelectResult) == null ? void 0 : o[i];
    a ? a(e, t) : (n("setChosenAddress", r), n("setInputValue", r.title), n("setSearchResults", Ca.NO_SEARCH));
  },
  /**
   * `search` is meant for programmatic access. User search is triggered from
   * the `input` action effects and features a debouncing mechanism.
   * @param vuexParameters - vuex standard parameter object
   * @param payload - input to search for and an autoselect mode
   */
  async search({ state: e, commit: t, dispatch: n, getters: s }, {
    input: r,
    autoselect: i
  }) {
    var l;
    if (t("setInputValue", r), Ls && (Ls.abort(), Ls = void 0), await n("load"), typeof e.searchResults == "symbol")
      return;
    const a = e.searchResults.find(
      ({ value: f }) => f.features.length
    ), o = ((l = a == null ? void 0 : a.value) == null ? void 0 : l.features) || [];
    (i === "first" && o.length >= 1 || i === "only" && o.length === 1) && n("selectResult", {
      feature: o[0],
      categoryId: s.selectedGroup[(a == null ? void 0 : a.index) || 0].categoryId || ""
    });
  }
}, jv = () => ({
  chosenAddress: null,
  inputValue: "",
  loading: !1,
  searchResults: Ca.NO_SEARCH,
  selectedGroupId: null
}), Uv = {
  label: "common:plugins.addressSearch.defaultGroup",
  placeholder: "",
  hint: "",
  resultDisplayMode: "mixed",
  limitResults: Number.MAX_SAFE_INTEGER
}, Q7 = {
  minLength: 0,
  waitMs: 0,
  searchMethods: []
}, ed = ({
  searchMethodsByGroupId: e,
  selectedGroupProperties: t,
  selectedGroupId: n,
  key: s
}) => t[s] || // if not set, first entry defines [key] value
e[n][0][s] || Uv[s], q7 = {
  ...rr(jv()),
  /** true if any service of selected group yielded features */
  featuresAvailable(e, { searchResults: t }) {
    return Array.isArray(t) && t.length > 0 && t.some(
      ({ value: n }) => {
        var s;
        return Array.isArray(n == null ? void 0 : n.features) && ((s = n.features) == null ? void 0 : s.length) > 0;
      }
    );
  },
  addressSearchConfiguration(e, t, n, s) {
    var r;
    return {
      ...Q7,
      ...((r = s == null ? void 0 : s.configuration) == null ? void 0 : r.addressSearch) || {}
    };
  },
  minLength(e, { addressSearchConfiguration: t }) {
    return t.minLength;
  },
  waitMs(e, { addressSearchConfiguration: t }) {
    return t.waitMs;
  },
  searchMethods(e, { addressSearchConfiguration: t }) {
    return t.searchMethods;
  },
  searchMethodsByGroupId(e, { searchMethods: t }) {
    const n = {};
    return t.forEach((s) => {
      const r = s.groupId || "defaultGroup";
      n[r] ? n[r].push(s) : n[r] = [s];
    }), n;
  },
  groupIds(e, { searchMethodsByGroupId: t }) {
    return Object.keys(t);
  },
  selectedGroupId({ selectedGroupId: e }, { groupIds: t }) {
    return e || t[0];
  },
  selectedGroup(e, { searchMethodsByGroupId: t, selectedGroupId: n }) {
    return t[n];
  },
  getGroupProperties(e, { addressSearchConfiguration: t }) {
    return (n) => {
      var r;
      const s = ((r = t.groupProperties) == null ? void 0 : r[n]) || {};
      return n === "defaultGroup" ? {
        ...Uv,
        ...s
      } : s;
    };
  },
  selectedGroupProperties(e, { selectedGroupId: t, getGroupProperties: n }) {
    return n(t);
  },
  limitResults(e, { selectedGroupProperties: t }) {
    return t.limitResults || Uv.limitResults;
  },
  categoryProperties(e, { addressSearchConfiguration: t }) {
    return t.categoryProperties || {};
  },
  label(e, { searchMethodsByGroupId: t, selectedGroupProperties: n, selectedGroupId: s }) {
    return ed({
      searchMethodsByGroupId: t,
      selectedGroupProperties: n,
      selectedGroupId: s,
      key: "label"
    });
  },
  placeholder(e, { searchMethodsByGroupId: t, selectedGroupProperties: n, selectedGroupId: s }) {
    return ed({
      searchMethodsByGroupId: t,
      selectedGroupProperties: n,
      selectedGroupId: s,
      key: "placeholder"
    });
  },
  selectedGroupHint(e, { searchMethodsByGroupId: t, selectedGroupId: n, selectedGroupProperties: s }) {
    return ed({
      searchMethodsByGroupId: t,
      selectedGroupProperties: s,
      selectedGroupId: n,
      key: "hint"
    });
  },
  hint({ inputValue: e, searchResults: t }, { selectedGroupHint: n, minLength: s, featuresAvailable: r, loading: i }) {
    return i ? "common:plugins.addressSearch.hint.loading" : t === Ca.ERROR ? "common:plugins.addressSearch.hint.error" : e && e.length > 0 && e.length < s ? "common:plugins.addressSearch.hint.tooShort" : t !== Ca.NO_SEARCH && !r ? "common:plugins.addressSearch.hint.noResults" : n;
  },
  hasMultipleGroups(e, { groupIds: t }) {
    return t.length > 1;
  },
  groupSelectOptions(e, { searchMethodsByGroupId: t, getGroupProperties: n }) {
    return Object.keys(t).map((s) => ({
      value: s,
      text: ed({
        searchMethodsByGroupId: t,
        selectedGroupProperties: n(s),
        selectedGroupId: s,
        key: "label"
      })
    }));
  },
  featureListsWithCategory({ searchResults: e }, { selectedGroup: t, categoryProperties: n }) {
    return typeof e == "symbol" ? [] : e.map((s) => {
      var r, i, a;
      return {
        features: s.value.features,
        categoryId: ((r = t[s.index]) == null ? void 0 : r.categoryId) || "",
        category: ((a = n[((i = t[s.index]) == null ? void 0 : i.categoryId) || ""]) == null ? void 0 : a.label) || ""
      };
    });
  }
}, t9 = {
  namespaced: !0,
  state: jv(),
  actions: J7,
  getters: q7,
  mutations: {
    ...zr(jv())
  }
}, e9 = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "addressSearch",
  plugin: l7,
  language: u7,
  storeModule: t9,
  options: e
}), n9 = $t.extend({
  name: "GeoLocation",
  computed: {
    ...Ee("plugin/geoLocation", [
      "geolocation",
      "tracking",
      "isGeolocationDenied"
    ]),
    tooltipMessage() {
      return this.isGeolocationDenied ? "common:plugins.geoLocation.button.tooltip.locationAccessDenied" : this.tracking ? "common:plugins.geoLocation.button.tooltip.removeLocationMarker" : "common:plugins.geoLocation.button.tooltip.placeLocationMarker";
    }
  },
  methods: {
    ...br("plugin/geoLocation", ["track", "untrack"])
  }
});
var i9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-tooltip", { staticClass: "polar-geo-location-wrap", attrs: { left: "" }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ staticClass: "ma-2", attrs: { color: "primary", small: "", fab: "", disabled: t.isGeolocationDenied }, on: { click: function(i) {
      t.geolocation === null ? t.track() : t.untrack();
    } } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v("fa-map-pin")])], 1)];
  } }]) }, [n("span", [t._v(t._s(t.$t(t.tooltipMessage)))])])], 1);
}, r9 = [], s9 = /* @__PURE__ */ Re(
  n9,
  i9,
  r9,
  !1,
  null,
  "b2a1cd23",
  null,
  null
);
const a9 = s9.exports, o9 = [
  {
    type: "de",
    resources: {
      plugins: {
        geoLocation: {
          markerText: "Aktuelle Position",
          button: {
            tooltip: {
              placeLocationMarker: "Eigene Position markieren",
              removeLocationMarker: "Positionsmarker entfernen",
              locationAccessDenied: "Standortzugriff nutzerseitig abgelehnt"
            }
          },
          toast: {
            notInBoundary: "Sie befinden sich nicht im Kartengebiet.",
            boundaryError: "Die Überprüfung Ihrer Position ist fehlgeschlagen. Bitte versuchen Sie es später erneut oder wenden Sie sich an einen Administrator, wenn das Problem bestehen bleibt."
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        geoLocation: {
          markerText: "Current location",
          button: {
            tooltip: {
              placeLocationMarker: "Mark own location",
              removeLocationMarker: "Remove location marker",
              locationAccessDenied: "Location access denied by user"
            }
          },
          toast: {
            notInBoundary: "You are not within the map's boundaries.",
            boundaryError: "Validating your position failed. Please try later again or contact an administrator if the issue persists."
          }
        }
      }
    }
  }
], Wv = () => ({
  geolocation: null,
  position: [],
  tracking: !1,
  isGeolocationDenied: !1
});
let bT = 0;
const l9 = 100, u9 = 100, ag = {
  undefinedBoundaryLayer: Symbol.for("Boundary Layer undefined"),
  undefinedBoundarySource: Symbol.for("Boundary Source undefined"),
  sourceNotReady: Symbol.for("Source not ready")
}, c9 = async (e) => {
  for (; e.getState() !== "ready" || e.getFeatures().length === 0; )
    if (bT++ < l9)
      await new Promise((t) => {
        setTimeout(t, u9);
      });
    else
      return !1;
  return bT = 0, !0;
}, x_ = async (e, t, n) => {
  if (typeof t > "u")
    return Promise.resolve(!0);
  const s = e.getLayers().getArray().find(
    (o) => o.get("id") === t
  );
  if (!s)
    return console.error(
      `POLAR Map Client: No layer configured to match boundaryLayerId "${t}" in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(ag.undefinedBoundaryLayer);
  const r = s.getSource();
  if (!r)
    return console.error(
      `POLAR Map Client: Layer with boundaryLayerId "${t}" missing source in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(ag.undefinedBoundarySource);
  if (!await c9(r))
    return console.error(
      `POLAR Map Client: Layer with boundaryLayerId "${t}" did not load or is featureless in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(ag.sourceNotReady);
  const a = r.getFeatures() || [];
  return Promise.resolve(
    a.some(
      (o) => {
        var l;
        return (l = o.getGeometry()) == null ? void 0 : l.intersectsCoordinate(n);
      }
    )
  );
}, h9 = '<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512"><path d="M320 64A64 64 0 1 0 192 64a64 64 0 1 0 128 0zm-96 96c-35.3 0-64 28.7-64 64v48c0 17.7 14.3 32 32 32h1.8l11.1 99.5c1.8 16.2 15.5 28.5 31.8 28.5h38.7c16.3 0 30-12.3 31.8-28.5L318.2 304H320c17.7 0 32-14.3 32-32V224c0-35.3-28.7-64-64-64H224zM132.3 394.2c13-2.4 21.7-14.9 19.3-27.9s-14.9-21.7-27.9-19.3c-32.4 5.9-60.9 14.2-82 24.8c-10.5 5.3-20.3 11.7-27.8 19.6C6.4 399.5 0 410.5 0 424c0 21.4 15.5 36.1 29.1 45c14.7 9.6 34.3 17.3 56.4 23.4C130.2 504.7 190.4 512 256 512s125.8-7.3 170.4-19.6c22.1-6.1 41.8-13.8 56.4-23.4c13.7-8.9 29.1-23.6 29.1-45c0-13.5-6.4-24.5-14-32.6c-7.5-7.9-17.3-14.3-27.8-19.6c-21-10.6-49.5-18.9-82-24.8c-13-2.4-25.5 6.3-27.9 19.3s6.3 25.5 19.3 27.9c30.2 5.5 53.7 12.8 69 20.5c3.2 1.6 5.8 3.1 7.9 4.5c3.6 2.4 3.6 7.2 0 9.6c-8.8 5.7-23.1 11.8-43 17.3C374.3 457 318.5 464 256 464s-118.3-7-157.7-17.9c-19.9-5.5-34.2-11.6-43-17.3c-3.6-2.4-3.6-7.2 0-9.6c2.1-1.4 4.8-2.9 7.9-4.5c15.3-7.7 38.8-14.9 69-20.5z" /></svg>', og = (e) => () => e.innerHTML = `<h2>${xn.t(
  "plugins.geoLocation.markerText"
)}</h2>`, d9 = `
  background: rgba(255, 255, 255, 0.8);
  padding: 0.2em 0.5em;
  border-radius: 4px;
  color: #16161d;
  box-shadow: 0px 0px 3px 2px rgba(0, 0, 0, 0.5);
`, f9 = () => {
  const e = document.createElement("div");
  return e.style.cssText = d9, og(e)(), xn.on("languageChanged", og(e)), xn.store.on("added", og(e)), e;
}, p9 = {
  setupModule({ getters: e, commit: t, dispatch: n }) {
    n("addMarkerLayer"), navigator.permissions.query({ name: "geolocation" }).then((s) => {
      s.state === "denied" && t("setIsGeolocationDenied", !0);
    }), e.checkLocationInitially && n("track"), n("setupTooltip");
  },
  setupTooltip({ getters: e, rootGetters: t }) {
    if (e.showTooltip) {
      const { map: n } = t, s = new kP({
        element: f9(),
        positioning: "bottom-center",
        offset: [0, -5]
      });
      n.addOverlay(s), n.on("pointermove", ({ pixel: r, dragging: i }) => {
        if (i)
          return;
        const o = n.getFeaturesAtPixel(r, {
          layerFilter: (l) => l.get("name") === "geoLocationMarkerLayer"
        }).length ? n.getCoordinateFromPixel(r) : void 0;
        s.setPosition(o);
      });
    }
  },
  /** Enable tracking of geo position */
  track({ getters: { isGeolocationDenied: e, geolocation: t }, commit: n, dispatch: s }) {
    e === !1 ? (t === null ? (t = new WD({
      tracking: !0,
      projection: Wt("EPSG:4326")
    }), n("setGeolocation", t)) : s("positioning"), t.on("change:position", () => s("positioning")), t.on("error", (r) => s("onError", r)), n("setTracking", !0)) : s("onError");
  },
  /**
   * Stop tracking of geo position
   */
  untrack({ getters: { geolocation: e }, commit: t, dispatch: n }) {
    e == null || e.setTracking(!1), n("removeMarker"), t("setTracking", !1), t("setGeolocation", null);
  },
  /**
   * Adds the geoLocationMarkerLayer to the map which also has a feature
   * called geoLocationMarker for visualising the geoLocation of a user.
   * Until the tracking is initiated the style of the layer will be null and
   * gets only changed when the addMarker function gets called.
   */
  addMarkerLayer({ rootGetters: { map: e } }) {
    const t = new vr({
      source: new jr({
        features: [
          new Xi({
            type: "point",
            name: "geoLocationMarker"
          })
        ]
      }),
      style: null,
      properties: { name: "geoLocationMarkerLayer" }
    });
    e.addLayer(t), t.setZIndex(1 / 0);
  },
  /**
   * Setting the current map on the position
   */
  async positioning({
    rootGetters: { map: e },
    getters: {
      boundaryLayerId: t,
      boundaryOnError: n,
      geolocation: s,
      configuredEpsg: r,
      position: i
    },
    commit: a,
    dispatch: o
  }) {
    const l = ji(
      s == null ? void 0 : s.getPosition(),
      Wt("EPSG:4326"),
      r
    ), f = await x_(
      e,
      t,
      l
    ), d = typeof f == "symbol";
    if (f === !1 || d && n !== "permissive") {
      o("printPositioningFailed", d), o("untrack");
      return;
    }
    (i[0] !== l[0] || i[1] !== l[1]) && (a("setPosition", l), o("addMarker", l));
  },
  printPositioningFailed({ dispatch: e, getters: { toastAction: t } }, n) {
    t ? e(t, n ? {
      type: "error",
      text: "plugins.geoLocation.toast.boundaryError",
      timeout: 0
    } : {
      type: "info",
      text: "plugins.geoLocation.toast.notInBoundary",
      timeout: 1e4
    }, { root: !0 }) : console[n ? "error" : "log"](
      n ? "Checking boundary layer failed." : "User position outside of boundary layer."
    );
  },
  /**
   * Adds a marker to the map, which indicates the users geoLocation.
   * This happens by applying a style to the geoLocationMarkerLayer and
   * a geometry to the geoLocationMarker.
   */
  addMarker({
    getters: { geoLocationMarkerLayer: e, markerFeature: t, keepCentered: n },
    dispatch: s
  }, r) {
    const i = !!t.getGeometry();
    t.setGeometry(new hi(r)), e == null || e.setStyle(
      new zn({
        image: new Ua({
          // TODO: It might be interesting to be able to change the color.
          src: `data:image/svg+xml;utf8,${h9}`,
          scale: 0.08,
          opacity: 1
        })
      })
    ), (n || !i) && s("zoomAndCenter");
  },
  /**
   * Removes the geoLocation marker from the map by setting style property
   * of the geoLocationMarkerLayer to null.
   */
  removeMarker({
    getters: { geoLocationMarkerLayer: e, markerFeature: t },
    commit: n
  }) {
    e == null || e.setStyle(null), t.setGeometry(void 0), n("setPosition", []);
  },
  /**
   * Zooms to the configured zoomLevel and centers the map
   * according to a users coordinates
   */
  zoomAndCenter({ rootGetters: e, getters: { position: t, zoomLevel: n } }) {
    e.map.getView().setCenter(t), e.map.getView().setZoom(n);
  },
  /**
   * Show error information and stop tracking if there are errors by tracking the position
   */
  onError({ commit: e, dispatch: t }, n) {
    t(
      "plugin/toast/addToast",
      {
        type: "error",
        text: "common:plugins.geoLocation.button.tooltip.locationAccessDenied",
        timeout: 5e3
      },
      { root: !0 }
    ), console.error(n.message), e("setIsGeolocationDenied", !0), e("setTracking", !1), t("removeMarker");
  }
}, m9 = {
  ...rr(Wv()),
  boundaryLayerId: (e, t, n, s) => {
    var r, i;
    return (i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.boundaryLayerId;
  },
  boundaryOnError: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.boundaryOnError) || "permissive";
  },
  configuredEpsg: (e, t, n, s) => {
    var r;
    return (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.epsg;
  },
  checkLocationInitially: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.checkLocationInitially) || !1;
  },
  keepCentered: (e, t, n, s) => {
    var i, a;
    const r = (a = (i = s == null ? void 0 : s.configuration) == null ? void 0 : i.geoLocation) == null ? void 0 : a.keepCentered;
    return typeof r == "boolean" ? r : !1;
  },
  showTooltip: (e, t, n, s) => {
    var r, i;
    return !!((i = (r = s.configuration) == null ? void 0 : r.geoLocation) != null && i.showTooltip);
  },
  toastAction: (e, t, n, s) => {
    var r, i;
    return (i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.toastAction;
  },
  zoomLevel: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.zoomLevel) || 7;
  },
  geoLocationMarkerLayer(e, t, n, s) {
    return s == null ? void 0 : s.map.getLayers().getArray().find((r) => r.get("name") === "geoLocationMarkerLayer");
  },
  markerFeature(e, { geoLocationMarkerLayer: t }) {
    var n, s, r, i, a;
    return ((a = (i = (r = (s = (n = t == null ? void 0 : t.getSource) == null ? void 0 : n.call(t)) == null ? void 0 : s.getFeatures) == null ? void 0 : r.call(s)) == null ? void 0 : i.find) == null ? void 0 : a.call(i, (o) => o.get("name") === "geoLocationMarker")) || null;
  }
}, g9 = {
  namespaced: !0,
  state: Wv(),
  actions: p9,
  getters: m9,
  mutations: {
    ...zr(Wv())
  }
}, v9 = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "geoLocation",
  plugin: a9,
  language: o9,
  storeModule: g9,
  options: e
});
function OT(e) {
  return !isNaN(e) && typeof e == "number" && e >= 0;
}
const y9 = $t.extend({
  name: "MoveHandle",
  props: {
    minHeight: {
      type: Number,
      default: 0.1,
      validator: OT
    },
    maxHeight: {
      type: Number,
      default: 1,
      validator: OT
    }
  },
  data: () => ({
    handleElement: null,
    initialCursorY: 0,
    isMoving: !1,
    preMoveHandleTop: 0,
    touchDevice: !1,
    timeoutReference: 0
  }),
  computed: {
    moveEventNames() {
      return this.touchDevice ? { move: "touchmove", end: "touchend" } : { move: "mousemove", end: "mouseup" };
    }
  },
  watch: {
    isMoving(e) {
      const { move: t, end: n } = this.moveEventNames;
      if (e) {
        this.handleElement.classList.add("polar-move-handle-is-moving"), document.addEventListener(t, this.onMove), document.addEventListener(n, this.onMoveEnd, { once: !0 });
        return;
      }
      this.handleElement.classList.remove("polar-move-handle-is-moving"), document.removeEventListener(t, this.onMove), document.removeEventListener(n, this.onMoveEnd);
    },
    maxHeight(e, t) {
      e < t && (this.savePreMoveHandleTop(), this.setNewPosition(0));
    }
  },
  mounted() {
    if (this.$el.parentElement) {
      this.handleElement = this.$el.parentElement;
      return;
    }
    console.error(
      "MoveHandle: No parent element used, using MoveHandle container."
    ), this.handleElement = this.$el;
  },
  methods: {
    moveHandle(e) {
      (e === "ArrowUp" || e === "ArrowDown") && (this.savePreMoveHandleTop(), this.setNewPosition(e === "ArrowUp" ? -5 : 5));
    },
    onMouseDown(e) {
      this.touchDevice = !1, this.startMoving(e);
    },
    onMove(e) {
      const t = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, n = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY, s = n - this.initialCursorY;
      (t < 0 || t > window.innerWidth || n < 0 || n > window.innerHeight) && (this.isMoving = !1), this.setNewPosition(s);
    },
    onMoveEnd() {
      this.isMoving = !1;
    },
    onTouchStart(e) {
      this.touchDevice = !0, this.startMoving(e);
    },
    saveInitialCursorCoordinates(e) {
      this.initialCursorY = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;
    },
    savePreMoveHandleTop() {
      this.preMoveHandleTop = this.handleElement.offsetTop;
    },
    setNewPosition(e) {
      const t = this.$root.$el.clientHeight;
      let n = Math.round(this.preMoveHandleTop + e);
      t - n < t * this.minHeight && (n = t - t * this.minHeight), t - n > t * this.maxHeight && (n = t - t * this.maxHeight), this.handleElement.style.top = n + "px";
    },
    startMoving(e) {
      this.saveInitialCursorCoordinates(e), this.savePreMoveHandleTop(), this.isMoving = !0;
    }
  }
});
var E9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "polar-move-handle", attrs: { tabindex: "0" }, on: { focus: function(s) {
    return t.moveHandle(s.key);
  }, keydown: function(s) {
    return t.moveHandle(s.key);
  }, mousedown: function(s) {
    return s.stopPropagation(), t.onMouseDown.apply(null, arguments);
  }, touchstart: function(s) {
    return s.stopPropagation(), t.onTouchStart.apply(null, arguments);
  } } }, [t._t("default")], 2);
}, C9 = [], x9 = /* @__PURE__ */ Re(
  y9,
  E9,
  C9,
  !1,
  null,
  "979c5207",
  null,
  null
);
const b9 = x9.exports, O9 = $t.extend({
  name: "GfiSwitchButtons",
  computed: {
    ...Ee("plugin/gfi", [
      "windowFeatures",
      "visibleWindowFeatureIndex"
    ])
  },
  methods: {
    ...$r("plugin/gfi", ["setVisibleWindowFeatureIndex"]),
    /** switch to next or previous feature */
    switchFeature(e) {
      const {
        visibleWindowFeatureIndex: t,
        windowFeatures: n,
        setVisibleWindowFeatureIndex: s
      } = this, r = n.length - 1, i = t + e;
      if (i < 0) {
        s(n.length - 1);
        return;
      }
      if (i > r) {
        s(0);
        return;
      }
      s(i);
    }
  }
});
var T9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-gfi-switch-buttons" } }, [n("v-btn", { staticClass: "ma-2", attrs: { elevation: "2", fab: "", "x-small": "", "aria-label": t.$t("common:plugins.gfi.switch.previous") }, on: { click: function(s) {
    return t.switchFeature(-1);
  } } }, [n("v-icon", [t._v("fa-chevron-left")])], 1), n("v-btn", { staticClass: "ma-2", attrs: { elevation: "2", fab: "", "x-small": "", "aria-label": t.$t("common:plugins.gfi.switch.next") }, on: { click: function(s) {
    return t.switchFeature(1);
  } } }, [n("v-icon", [t._v("fa-chevron-right")])], 1)], 1);
}, P9 = [], M9 = /* @__PURE__ */ Re(
  O9,
  T9,
  P9,
  !1,
  null,
  "20a8e6f0",
  null,
  null
);
const S9 = M9.exports, I9 = $t.extend({
  name: "GfiButtonGroup",
  components: {
    GfiSwitchButtons: S9
  },
  props: {
    exportProperty: {
      type: String,
      default: ""
    },
    showSwitchButtons: {
      type: Boolean,
      default: !1
    }
  }
});
var _9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-plugin-gfi-button-group" } }, [n("div", [t.exportProperty ? n("v-btn", { staticClass: "ma-2 text-none reticent-button primaryContrast--text", attrs: { id: "polar-plugin-gfi-export-link", elevation: "2", color: "primary", href: t.exportProperty, target: "_blank", title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.export"), onmousedown: "return false" } }, [t._v(" " + t._s(t.$t("common:plugins.gfi.property.export")) + " ")]) : t._e()], 1), t.showSwitchButtons ? n("GfiSwitchButtons") : t._e()], 1);
}, D9 = [], A9 = /* @__PURE__ */ Re(
  I9,
  _9,
  D9,
  !1,
  null,
  "4f15ef16",
  null,
  null
);
const L9 = A9.exports;
function R9(e) {
  let t;
  try {
    t = new URL(e);
  } catch {
    return !1;
  }
  return t.protocol === "http:" || t.protocol === "https:";
}
const w9 = $t.extend({
  name: "GfiBody",
  props: {
    currentProperties: {
      type: Object,
      required: !0
    },
    photoHeight: {
      type: Number,
      default: 250
    }
  },
  computed: {
    /** Removes polarInternalLayerKey as it shouldn't be displayed to the user. */
    filteredProperties() {
      return this.currentProperties ? Object.fromEntries(
        Object.entries(this.currentProperties).filter(
          ([e]) => e !== "polarInternalLayerKey"
        )
      ) : {};
    }
  },
  methods: {
    isValidHttpUrl: R9
  }
});
var V9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("tbody", t._l(Object.entries(t.filteredProperties), function([s, r]) {
    return n("tr", { key: s }, [n("td", [t._v(t._s(s))]), r.match(/\.(jpeg|jpg|gif|png)$/) !== null ? n("td", [n("a", { attrs: { href: r, target: "_blank" } }, [n("img", { attrs: { src: r, alt: t.$t("common:plugins.gfi.property.imageAlt"), title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.linkTitle"), height: t.photoHeight < 200 ? 200 : t.photoHeight, width: "auto" } })])]) : t.isValidHttpUrl(r) ? n("td", [n("a", { attrs: { href: r, target: "_blank", title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.linkTitle") } }, [t._v(" " + t._s("Link") + " ")])]) : n("td", [t._v(" " + t._s(r) + " ")])]);
  }), 0);
}, B9 = [], N9 = /* @__PURE__ */ Re(
  w9,
  V9,
  B9,
  !1,
  null,
  "c7584b28",
  null,
  null
);
const F9 = N9.exports, j9 = $t.extend({
  name: "GfiHead"
});
var U9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("thead", [n("tr", [n("th", { staticClass: "text-left" }, [t._v(t._s(t.$t("common:plugins.gfi.header.field")))]), n("th", { staticClass: "text-left" }, [t._v(t._s(t.$t("common:plugins.gfi.header.value")))])])]);
}, W9 = [], $9 = /* @__PURE__ */ Re(
  j9,
  U9,
  W9,
  !1,
  null,
  "fe8329ca",
  null,
  null
);
const z9 = $9.exports, K9 = $t.extend({
  name: "GfiContent",
  components: {
    GfiButtonGroup: L9,
    GfiBody: F9,
    GfiHead: z9
  },
  props: {
    currentProperties: {
      type: Object,
      required: !0
    },
    clientWidth: {
      type: Number,
      required: !0
    },
    exportProperty: {
      type: String,
      default: ""
    },
    showSwitchButtons: {
      type: Boolean,
      default: !1
    }
  },
  data: () => ({ closeLabel: "common:plugins.gfi.header.close" }),
  computed: {
    ...Ee(["hasSmallWidth", "hasWindowSize"]),
    photoHeight() {
      return this.clientWidth * 0.15;
    }
  },
  methods: {
    ...br("plugin/gfi", ["close"])
  }
});
var G9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("div", { staticClass: "polar-plugin-gfi-button-container" }, [t.hasWindowSize && t.hasSmallWidth ? n("v-icon", { attrs: { id: "polar-plugin-gfi-grip-icon" } }, [t._v(" fa-grip-lines ")]) : t._e(), n("v-btn", { attrs: { id: "polar-plugin-gfi-close-button", icon: "", small: "", "aria-label": t.$t(t.closeLabel) }, on: { click: t.close } }, [n("v-icon", [t._v("fa-xmark")])], 1)], 1), n("v-simple-table", { staticClass: "polar-edgy-table", attrs: { dense: "" }, scopedSlots: t._u([{ key: "default", fn: function() {
    return [n("GfiHead"), n("GfiBody", { attrs: { "current-properties": t.currentProperties, "photo-height": t.photoHeight } })];
  }, proxy: !0 }]) }), t.exportProperty || t.showSwitchButtons ? n("GfiButtonGroup", { attrs: { "export-property": t.exportProperty, "show-switch-buttons": t.showSwitchButtons } }) : t._e()], 1);
}, k9 = [], H9 = /* @__PURE__ */ Re(
  K9,
  G9,
  k9,
  !1,
  null,
  "6efb44bd",
  null,
  null
);
const Y9 = H9.exports, X9 = $t.extend({
  name: "PolarGfi",
  components: {
    MoveHandle: b9
  },
  data: () => ({ clientWidth: 0, maxMobileHeight: 1 }),
  computed: {
    ...Ee(["hasSmallWidth", "hasWindowSize"]),
    ...Ee("plugin/gfi", [
      "exportPropertyLayerKeys",
      "windowFeatures",
      "visibleWindowFeatureIndex",
      "gfiContentComponent"
    ]),
    contentComponent() {
      return this.gfiContentComponent || Y9;
    },
    currentProperties() {
      const e = {
        ...this.windowFeatures[this.visibleWindowFeatureIndex]
      }, t = this.exportPropertyLayerKeys[e.polarInternalLayerKey];
      return t.length > 0 && delete e[t], e;
    },
    exportProperty() {
      if (this.currentProperties) {
        const e = this.exportPropertyLayerKeys[this.currentProperties.polarInternalLayerKey];
        return e.length > 0 ? this.windowFeatures[this.visibleWindowFeatureIndex][e] : "";
      }
      return "";
    },
    renderUi() {
      return this.windowFeatures.length > 0;
    },
    /** only show switch buttons if multiple property sets are available */
    showSwitchButtons() {
      return this.windowFeatures.length > 1;
    }
  },
  mounted() {
    window.addEventListener("resize", () => {
      this.updateClientWidth(), this.updateMaxMobileHeight();
    }), this.updateClientWidth();
  },
  updated() {
    this.$nextTick(this.updateMaxMobileHeight);
  },
  methods: {
    updateClientWidth() {
      this.clientWidth = this.$root.$el.clientWidth;
    },
    updateMaxMobileHeight() {
      this.$el.clientHeight && (this.maxMobileHeight = this.$el.clientHeight / this.$root.$el.clientHeight);
    }
  }
});
var Z9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.renderUi ? n("div", { class: t.hasWindowSize ? "polar-plugin-gfi-fullscreen" : "", attrs: { id: "polar-plugin-gfi" } }, [t.hasWindowSize && t.hasSmallWidth ? n("MoveHandle", { attrs: { "max-height": t.maxMobileHeight } }, [n(t.contentComponent, { tag: "component", attrs: { "current-properties": t.currentProperties, "client-width": t.clientWidth, "export-property": t.exportProperty, "show-switch-buttons": t.showSwitchButtons } })], 1) : n(t.contentComponent, { tag: "component", attrs: { "current-properties": t.currentProperties, "client-width": t.clientWidth, "export-property": t.exportProperty, "show-switch-buttons": t.showSwitchButtons } })], 1) : t._e();
}, J9 = [], Q9 = /* @__PURE__ */ Re(
  X9,
  Z9,
  J9,
  !1,
  null,
  "83895759",
  null,
  null
);
const q9 = Q9.exports, tY = [
  {
    type: "de",
    resources: {
      plugins: {
        gfi: {
          header: {
            close: "Informationsfenster schließen",
            field: "Feld",
            value: "Wert"
          },
          property: {
            export: "Export als PDF",
            imageAlt: "Bitte entnehmen Sie Informationen zum Inhalt des Bildes aus den umliegenden Tabellenfeldern",
            linkTitle: "In neuem Tab öffnen"
          },
          switch: {
            previous: "Vorangehender Datensatz",
            next: "Nächster Datensatz"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        gfi: {
          header: {
            close: "Close information window",
            field: "Field",
            value: "Value"
          },
          property: {
            export: "Export as a PDF document",
            imageAlt: "Please refer to the other table fields for further information about the topics of the displayed picture",
            link: "Open in a new tab"
          },
          switch: {
            previous: "Previous data",
            next: "Next data"
          }
        }
      }
    }
  }
], xE = () => ({
  featureInformation: {},
  visibleWindowFeatureIndex: 0,
  defaultHighlightStyle: {
    stroke: {
      color: "#003064",
      width: 3
    },
    fill: {
      color: "rgb(255, 255, 255, 0.7)"
    }
  }
}), eY = new Qs(), su = new vr({
  source: new jr({
    features: []
  })
});
su.set("polarInternalId", "pluginGfiFeatureDisplay");
su.setZIndex(90);
function b_(e) {
  return e instanceof jr;
}
function lg() {
  const e = su.getSource();
  b_(e) && e.clear();
}
function nY(e) {
  const t = su.getSource();
  b_(t) && t.addFeature(eY.readFeature(e));
}
const TT = {
  GML: tM,
  GML2: Qo,
  GML3: re,
  GML32: Hc
};
function iY(e) {
  const t = e.split(`
`), n = [];
  let s;
  for (const r of t)
    if (!(r === "" || r.startsWith("GetFeatureInfo results") || r.startsWith("Layer"))) {
      if (r.startsWith("    ")) {
        if (typeof s < "u") {
          const i = r.indexOf("="), [a, o] = [
            r.substring(0, i),
            r.substring(i + 3, r.length - 1)
          ].map((l) => l.trim());
          s.set(a, o);
        } else
          console.error(
            "Found property before feature declaration in readTextFeatures.",
            r,
            "Skipping ..."
          );
        continue;
      }
      if (r.startsWith("  ")) {
        if (r.includes("Search returned no results"))
          break;
        const i = r.substring(0, r.length - 2).trim();
        s = new Xi(), s.setId(i), n.push(s);
      }
    }
  return n;
}
function rY(e) {
  const t = e.includes('xmlns:gml="http://www.opengis.net/gml/3.2"') ? Hc : e.includes('xmlns:gml="http://www.opengis.net/gml"') ? tM : e.includes('xmlns:gml="http://www.opengis.net/gml/2') ? Qo : re;
  return new Yc({
    gmlFormat: new t()
  });
}
function sY(e) {
  if (TT[e])
    return new Yc({
      gmlFormat: new TT[e]()
    });
  if (e === "text")
    return {
      readFeatures: iY
    };
  throw new Error(`Format '${e}' not yet implemented in requestGfiWms.ts.`);
}
function aY({
  map: e,
  layer: t,
  coordinate: n
}, { infoFormat: s }) {
  const r = t.getSource(), i = e.getView(), a = r.getFeatureInfoUrl(
    n,
    i.getResolution(),
    i.getProjection(),
    {
      feature_count: 10
    }
  ), o = s ? `&info_format=${s}` : "";
  return a + o;
}
const oY = (e) => {
  const { coordinate: t, layerConfiguration: n, layerSpecification: s } = e, { filterBy: r, geometryName: i, format: a } = n, o = aY(e, s);
  return fetch(o).then((l) => l.text()).then((l) => {
    const d = (s.infoFormat === "application/geojson" ? new Qs() : a ? sY(a) : rY(l)).readFeatures(l), u = new Qs();
    return i && d.forEach((h) => h.setGeometryName("geometry")), d.filter(
      (h) => {
        var p;
        return r === "clickPosition" ? (p = h.getGeometry()) == null ? void 0 : p.intersectsCoordinate(t) : !0;
      }
    ).map((h) => JSON.parse(u.writeFeature(h)));
  }).catch((l) => Promise.reject(l));
}, lY = (e, t) => {
  const n = new Yc({ version: t }), s = new Qs();
  return n.readFeatures(e).map(
    (a) => JSON.parse(s.writeFeature(a))
  );
}, uY = ({
  map: e,
  coordinate: t,
  layerConfiguration: n,
  layerSpecification: s,
  mode: r
}) => {
  const { featureType: i, url: a, version: o } = s, { geometryName: l } = n, f = e.getView().getProjection().getCode();
  let u = `${a}?service=WFS&version=${o}&request=GetFeature&${o === "2.0.0" ? "typeNames" : "typename"}=${i}&srsName=${f}`;
  if (r === "bboxDot")
    u += `&bbox=${[
      [t[0] - 0.1, t[1] - 0.1],
      [t[0] + 0.1, t[1] + 0.1]
    ]},${f}`;
  else if (r === "intersects") {
    const c = `<gml:Point srsName="${f}"><gml:coordinates>${t[0]},${t[1]}</gml:coordinates></gml:Point>`;
    u += "&FILTER=" + // NOTE: fes as a namespace and ValueReference for a property has been introduced in 2.0.0
    (o === "2.0.0" ? `<fes:Filter><fes:Intersects><fes:ValueReference>${l}</fes:ValueReference>` + c + "</fes:Intersects></fes:Filter>" : `<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"><ogc:Intersects><ogc:PropertyName>${l}</ogc:PropertyName>` + c + "</fes:Intersects></fes:Filter>");
  } else
    return Promise.reject(
      new Error(
        `Type error in requestGfiWfs.ts: mode must be "intersects" or "bboxDot", but was "${r}".`
      )
    );
  return fetch(u, { method: "GET" }).then((c) => c.text()).then((c) => lY(c, o));
};
function cY({
  map: e,
  layer: t,
  coordinate: n,
  layerConfiguration: s,
  layerSpecification: r,
  mode: i
}) {
  try {
    return t instanceof kc ? oY({
      map: e,
      layer: t,
      coordinate: n,
      layerConfiguration: s,
      layerSpecification: r
    }) : t instanceof vr ? uY({
      map: e,
      coordinate: n,
      layerConfiguration: s,
      layerSpecification: r,
      mode: i
    }) : Promise.reject(
      new Error(
        `Layer ${t.get(
          "id"
        )} was neither a Tile- nor a VectorLayer. GFI not implemented.`
      )
    );
  } catch {
    return Promise.reject(
      new Error(
        `An error occurred while requesting features from layer with the id ${t.get(
          "id"
        )}.`
      )
    );
  }
}
function hY(e, t, n) {
  const s = new Qs({
    dataProjection: n,
    featureProjection: n
  }), r = s.readGeometry(e.geometry), i = s.readGeometry(t.geometry), a = r instanceof nr || r instanceof Js, o = i instanceof nr || i instanceof Js;
  if (a && o)
    return i.getArea() - r.getArea();
  if (a)
    return -1;
  if (o)
    return 1;
  const l = r instanceof qi || r instanceof Zs, f = i instanceof qi || i instanceof Zs;
  return l && f ? 0 : l ? -1 : f ? 1 : 0;
}
const dY = {
  /**
   * Responsible for setting up the module by
   * - adding watchers to configured coordinate sources. Whenever one of these
   *   sources changes, the module is reset and all information is fetched
   *   anew.
   * - adding the geometry display layer to the map.
   */
  setupModule({
    getters: { gfiConfiguration: e, defaultHighlightStyle: t },
    rootGetters: n,
    dispatch: s
  }) {
    const { coordinateSources: r, customHighlightStyle: i } = e, { map: a } = n, o = (l) => {
      lg(), l && l.length && s("getFeatureInfo", l);
    };
    r.forEach(
      (l) => this.watch(() => n[l], o)
    ), a.addLayer(su), su.setStyle(
      new zn({
        stroke: new pr(
          (i == null ? void 0 : i.stroke) || t.stroke
        ),
        fill: new Lr(
          (i == null ? void 0 : i.fill) || t.fill
        )
      })
    );
  },
  close({ commit: e, dispatch: t }) {
    e("clearFeatureInformation"), t("plugin/pins/removeMarker", null, { root: !0 }), lg();
  },
  /**
   * Action getFeatureInfo
   * 1. resets the module state
   * 2. fetches new feature information for each configured layer
   * 3. adds features to the display layer optionally (if configured)
   */
  async getFeatureInfo({ commit: e, dispatch: t }, n) {
    return e("clearFeatureInformation"), e("setVisibleWindowFeatureIndex", 0), lg(), await t("debouncedGfiRequest", n);
  },
  /**
   * Code from `getFeatureInfo`, pulled to avoid overly requesting feature
   * information. Since sources in Pins plugin update right after each other
   * (and such effects are to be expected across the system), we're debouncing
   * this *after* resetting the module state, as something is bound to happen.
   */
  debouncedGfiRequest: y_(
    // TODO: Types are not properly displayed here as it is wrapped through debounce
    async ({
      commit: e,
      rootGetters: { map: t, configuration: n },
      getters: { layerKeys: s, geometryLayerKeys: r, afterLoadFunction: i }
    }, a) => {
      const o = s.map(
        (h) => {
          const p = t.getLayers().getArray().find((E) => E.getProperties().id === h);
          if (!p)
            return console.error(
              `No layer with id "${h}" found during run-time. GFI skipped.`
            ), [];
          const g = n.gfi.layers[h] || {}, m = Ka({ id: h }), y = n.layers.find(
            (E) => E.id === h
          ).gfiMode || n.gfi.mode || "bboxDot";
          return cY({
            map: t,
            layer: p,
            coordinate: a,
            layerConfiguration: g,
            layerSpecification: m,
            mode: y
          });
        }
      ), l = (h) => Symbol(h), f = (await Promise.allSettled(o)).map(
        (h) => h.status === "fulfilled" ? h.value : (console.error(h), l(h.reason.message))
      ), d = n.gfi.maxFeatures || Number.POSITIVE_INFINITY, u = t.getView().getProjection().getCode();
      let c = s.reduce(
        (h, p, g) => ({
          ...h,
          [p]: Array.isArray(f[g]) ? f[g].slice(
            0,
            n.gfi.layers[p].maxFeatures || d
          ) : f[g]
        }),
        {}
      );
      c = Object.entries(c).reduce(
        (h, [p, g]) => ({
          ...h,
          [p]: Array.isArray(g) && g.length >= 2 ? g.sort((m, v) => hY(m, v, u)) : g
        }),
        {}
      ), typeof i == "function" && (c = await i(c, u)), e("setFeatureInformation", c), r.filter((h) => Array.isArray(c[h])).forEach((h) => c[h].forEach(nY));
    },
    50
  )
}, fY = {
  ...zr(xE()),
  clearFeatureInformation(e) {
    e.featureInformation = {};
  }
}, pY = {
  ...rr(xE()),
  gfiConfiguration(e, t, n, s) {
    var r;
    return ((r = s == null ? void 0 : s.configuration) == null ? void 0 : r.gfi) || {
      afterLoadFunction: null,
      coordinateSources: [],
      layers: {}
    };
  },
  gfiContentComponent(e, { gfiConfiguration: t }) {
    return t.gfiContentComponent || null;
  },
  afterLoadFunction(e, { gfiConfiguration: t }) {
    return typeof (t == null ? void 0 : t.afterLoadFunction) == "function" ? t.afterLoadFunction : null;
  },
  layerKeys(e, { gfiConfiguration: t }) {
    return Object.keys((t == null ? void 0 : t.layers) || {});
  },
  exportPropertyLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { exportProperty: r }]) => ({
        ...n,
        [s]: typeof r == "string" ? r : ""
      }),
      {}
    );
  },
  windowLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { window: r }]) => r ? [...n, s] : n,
      []
    );
  },
  geometryLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { geometry: r }]) => r ? [...n, s] : n,
      []
    );
  },
  windowFeatures(e, { featureInformation: t, windowLayerKeys: n, gfiConfiguration: s }) {
    return Object.entries(t).map(
      ([r, i]) => (
        /*
          NOTE: When displaying the features in the map, the first feature is rendered first
            thus lying under every other following feature. However, when using the gfi window,
            the first feature is initially displayed in the window.
            To have both in line, the feature displayed on top, the order of the features is reversed here for the window.
         */
        n.includes(r) && Array.isArray(i) ? i.reverse().map(({ properties: a }) => {
          const o = { polarInternalLayerKey: r }, l = s.layers[r].properties;
          if (Array.isArray(l))
            return {
              ...Object.fromEntries(
                Object.entries(a || {}).filter(
                  ([f]) => l.includes(f)
                )
              ),
              ...o
            };
          if (typeof l == "object") {
            const f = Object.keys(l);
            return {
              ...Object.fromEntries(
                Object.entries(a || {}).filter(([d]) => f.includes(d)).map(([d, u]) => [l[d], u])
              ),
              ...o
            };
          }
          return { ...a, ...o };
        }) : []
      )
    ).flat(1);
  }
}, mY = {
  namespaced: !0,
  state: xE(),
  actions: dY,
  mutations: fY,
  getters: pY
}, gY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "gfi",
  plugin: q9,
  language: tY,
  storeModule: mY,
  options: e
}), vY = $t.extend({
  name: "IconMenu",
  data: () => ({
    maxWidth: "inherit"
  }),
  computed: {
    ...Ee(["hasSmallHeight", "hasWindowSize", "clientHeight"]),
    ...Ee("plugin/iconMenu", ["menus", "open"]),
    asList() {
      return this.menus.length > 1;
    },
    wrapperComponent() {
      return this.asList ? "ul" : "div";
    },
    itemComponent() {
      return this.asList ? "li" : "div";
    },
    isHorizontal() {
      return this.hasSmallHeight && this.hasWindowSize;
    },
    maxHeight() {
      return this.hasWindowSize ? `calc(${this.clientHeight}px - ${this.isHorizontal ? "calc(100% + 1.5em)" : "1em"})` : "inherit";
    }
  },
  mounted() {
    addEventListener("resize", this.updateMaxSize), this.updateMaxSize();
  },
  beforeDestroy() {
    removeEventListener("resize", this.updateMaxSize);
  },
  methods: {
    ...$r("plugin/iconMenu", ["setOpen"]),
    toggle(e) {
      this.open === e ? this.setOpen(null) : this.setOpen(e), this.updateMaxSize();
    },
    updateMaxSize() {
      const e = this.$refs["item-component"];
      if (!this.hasWindowSize && e) {
        const { width: t, left: n } = e[0].$el.getBoundingClientRect();
        this.maxWidth = `${t + n}px`;
      } else
        this.maxWidth = "inherit";
    }
  }
});
var yY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.wrapperComponent, { tag: "component", staticClass: "icon-menu-list ma-2" }, t._l(t.menus, function({ plugin: s, icon: r, id: i, hint: a }, o) {
    return n(t.itemComponent, { key: o, tag: "component", class: t.isHorizontal ? "icon-menu-list-item-horizontal" : "icon-menu-list-item" }, [r === void 0 ? n(s, { tag: "component", attrs: { "is-horizontal": t.isHorizontal } }) : [n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal }, scopedSlots: t._u([{ key: "activator", fn: function({ on: l, attrs: f }) {
      return [n("v-btn", t._g(t._b({ attrs: { color: t.open === o ? "primaryContrast" : "primary", fab: "", small: "", "aria-label": t.$t(a || `common:plugins.iconMenu.hints.${i}`) }, on: { click: function(d) {
        t.toggle(Number(o));
      } } }, "v-btn", f, !1), l), [n("v-icon", { attrs: { color: t.open === o ? "primary" : "primaryContrast" } }, [t._v(" " + t._s(r) + " ")])], 1)];
    } }], null, !0) }, [n("span", [t._v(t._s(t.$t(a || `common:plugins.iconMenu.hints.${i}`)))])]), t.open === o ? n(s, { ref: "item-component", refInFor: !0, tag: "component", class: [
      t.isHorizontal ? "icon-menu-list-item-content-horizontal" : "icon-menu-list-item-content",
      "icon-menu-list-item-content-scrollable-y"
    ], style: `max-height: ${t.maxHeight}; max-width: ${t.maxWidth}` }) : t._e()]], 2);
  }), 1);
}, EY = [], CY = /* @__PURE__ */ Re(
  vY,
  yY,
  EY,
  !1,
  null,
  "e8b98b07",
  null,
  null
);
const xY = CY.exports, bY = [
  {
    type: "de",
    resources: {
      plugins: {
        iconMenu: {
          hints: {
            attributions: "Quellennachweis",
            draw: "Zeichenwerkzeuge",
            layerChooser: "Kartenauswahl"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        iconMenu: {
          hints: {
            attributions: "Attributions",
            draw: "Draw tools",
            layerChooser: "Choose map"
          }
        }
      }
    }
  }
], ug = () => ({
  menus: [],
  open: null
}), OY = {
  namespaced: !0,
  state: ug(),
  actions: {
    setupModule({ commit: e, rootGetters: t }) {
      var a, o, l, f;
      const s = (((o = (a = t.configuration) == null ? void 0 : a.iconMenu) == null ? void 0 : o.menus) || []).filter(({ id: d }) => {
        var c, h;
        const u = (h = (c = t == null ? void 0 : t.configuration) == null ? void 0 : c[d]) == null ? void 0 : h.displayComponent;
        return typeof u == "boolean" ? u : !0;
      }).map((d) => {
        let u;
        const c = {
          $store: {
            ...this,
            dispatch: (h, p) => {
              this.dispatch(h, p), u = p.plugin;
            }
          }
        };
        return d.plugin(c), {
          ...d,
          plugin: u
        };
      });
      e("setMenus", s);
      const r = ((f = (l = t.configuration) == null ? void 0 : l.iconMenu) == null ? void 0 : f.initiallyOpen) || "", i = s.findIndex(({ id: d }) => d === r);
      i !== -1 && e("setOpen", i);
    }
  },
  mutations: {
    ...zr(ug())
  },
  getters: {
    ...rr(ug())
  }
}, TY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "iconMenu",
  plugin: xY,
  language: bY,
  storeModule: OY,
  options: e
});
const PY = {
  name: "DefaultIndicator",
  props: {
    showLoader: {
      type: Boolean,
      default: !1
    }
  }
};
var MY = function() {
  var t = this, n = t._self._c;
  return t.showLoader ? n("div", [n("v-card", [n("v-card-text", [t._v(" " + t._s(t.$t("common:plugins.loadingIndicator.loading")) + " "), n("v-progress-linear", { staticClass: "mb-0", attrs: { indeterminate: "", color: "primary" } })], 1)], 1)], 1) : t._e();
}, SY = [], IY = /* @__PURE__ */ Re(
  PY,
  MY,
  SY,
  !1,
  null,
  "667d4f83",
  null,
  null
);
const _Y = IY.exports, DY = $t.extend({
  name: "LoadingIndicator",
  components: { DefaultIndicator: _Y },
  computed: {
    ...Ee("plugin/loadingIndicator", ["showLoader"])
  }
});
var AY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("DefaultIndicator", { attrs: { "show-loader": t.showLoader } });
}, LY = [], RY = /* @__PURE__ */ Re(
  DY,
  AY,
  LY,
  !1,
  null,
  "e82c649c",
  null,
  null
);
const wY = RY.exports, VY = [
  {
    type: "de",
    resources: {
      plugins: {
        loadingIndicator: {
          loading: "Lädt..."
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        loadingIndicator: {
          loading: "Loading..."
        }
      }
    }
  }
], BY = () => ({
  loadKeys: /* @__PURE__ */ new Set()
}), NY = {
  namespaced: !0,
  state: BY(),
  mutations: {
    addLoadingKey(e, t) {
      e.loadKeys = /* @__PURE__ */ new Set([...e.loadKeys, t]);
    },
    removeLoadingKey(e, t) {
      const n = new Set(e.loadKeys);
      n.delete(t), e.loadKeys = n;
    }
  },
  getters: {
    showLoader: ({ loadKeys: e }) => e.size > 0
  }
}, FY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "loadingIndicator",
  plugin: wY,
  language: VY,
  storeModule: NY,
  options: e
}), jY = {
  Circle: iM,
  LinearRing: vd,
  LineString: qi,
  MultiLineString: Zs,
  MultiPoint: gu,
  MultiPolygon: Js,
  Point: hi,
  Polygon: nr
};
function UY(e, t, n, s) {
  const r = jY[n || "Point"], i = new r(s);
  let a = Fi(i.getExtent());
  return (n === "Polygon" || n === "MultiPolygon") && !i.intersectsCoordinate(a) && (a = n === "Polygon" ? i.getInteriorPoint().getFirstCoordinate() : i.getInteriorPoints().getFirstCoordinate()), e === t ? a : ji(a, e, t);
}
const WY = ({ fill: e = "#005CA9", stroke: t = "#FFF" }) => `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="-1 -1 25 25"
  >
    <path
      d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5z"
      fill="${e}"
      stroke="${t}"
      stroke-width="1"
    />
  </svg>
`, $Y = (e) => new zn({
  image: new Ua({
    src: `data:image/svg+xml;base64,${btoa(WY(e))}`,
    scale: 2,
    anchor: [0.5, 1]
  })
}), cg = () => ({
  isActive: !1,
  transformedCoordinate: [],
  latLon: [],
  coordinatesAfterDrag: [],
  getsDragged: !1,
  toZoomLevel: 0,
  atZoomLevel: 0
});
let bl;
const PT = new wk({
  layers: (e) => e === bl,
  style: null,
  condition: sR
}), zY = {
  namespaced: !0,
  state: cg(),
  actions: {
    /**
     * Responsible for setting up the module by adding a watcher. This watcher
     * calls removeMarker and showMarker if the store for addressSearch changes
     * its value for the chosenAddress.
     */
    setupModule({ getters: e, rootGetters: t, dispatch: n, commit: s }) {
      const { appearOnClick: r, coordinateSource: i, initial: a, movable: o, toZoomLevel: l } = t.configuration.pins || {}, f = t.map.getInteractions();
      l && s("setToZoomLevel", l), r != null && r.atZoomLevel && s("setAtZoomLevel", r.atZoomLevel);
      const d = r === void 0 ? !0 : r.show;
      if (typeof o == "boolean" && console.warn(
        "Pins: Using a boolean for the configuration parameter 'movable' has been deprecated and will be removed in the next major release."
      ), t.map.on("singleclick", async ({ coordinate: u }) => {
        const c = f.getArray().some((h) => h instanceof Dk);
        if ((typeof o == "boolean" && o || o === "drag" || o === "click") && d && // NOTE: It is assumed that getZoom actually returns the currentZoomLevel, thus the view has a constraint in the resolution.
        t.map.getView().getZoom() >= e.atZoomLevel && !c && await n("isCoordinateInBoundaryLayer", u)) {
          const h = { coordinates: u, clicked: !0 };
          n("removeMarker"), n("showMarker", h), s("setCoordinatesAfterDrag", u), n("updateCoordinates", u);
        }
      }), i && this.watch(
        () => t[i],
        (u) => {
          if (u && u.type !== "reverse_geocoded") {
            const c = {
              coordinates: u.geometry.coordinates,
              type: u.geometry.type,
              clicked: !1,
              epsg: u.epsg
            };
            n("removeMarker"), n("showMarker", c);
          }
        },
        { deep: !0 }
      ), (!o || o === "none") && (t.map.addInteraction(PT), PT.on(
        "select",
        ({ selected: u }) => document.body.style.cursor = u.length ? "not-allowed" : ""
      )), a) {
        const { coordinates: u, centerOn: c, epsg: h } = a, p = typeof h == "string" ? ji(u, h, t.configuration.epsg) : u;
        n("removeMarker"), n("showMarker", {
          coordinates: p,
          clicked: !0
        }), s("setCoordinatesAfterDrag", p), n("updateCoordinates", p), c && (t.map.getView().setCenter(e.transformedCoordinate), t.map.getView().setZoom(e.toZoomLevel));
      }
    },
    /**
     * Builds a vectorLayer which contains the mapMarker as
     * a vectorFeature and adds it to the map.
     * @param payload - an object with a boolean that shows if the coordinate
     * was submitted via click and the corresponding coordinates.
     */
    showMarker({ getters: e, rootGetters: t, commit: n, dispatch: s }, r) {
      var i, a;
      if (e.isActive === !1) {
        const { configuration: o, map: l } = t;
        r.clicked === !1 && (s(
          "updateCoordinates",
          UY(
            r.epsg,
            o.epsg,
            r.type,
            r.coordinates
          )
        ), l.getView().setCenter(e.transformedCoordinate), l.getView().setZoom(e.toZoomLevel));
        const f = r.clicked === !0 ? r.coordinates : e.transformedCoordinate;
        bl = new vr({
          source: new jr({
            features: [
              new Xi({
                geometry: new hi(f),
                type: "point",
                name: "mapMarker",
                zIndex: 100
              })
            ]
          }),
          style: $Y(((i = o == null ? void 0 : o.pins) == null ? void 0 : i.style) || {})
        }), bl.set("polarInternalId", "mapMarkerVectorLayer"), l.addLayer(bl), bl.setZIndex(100), n("setIsActive", !0);
        const d = (a = o.pins) == null ? void 0 : a.movable;
        (typeof d == "boolean" && d || d === "drag") && s("makeMarkerDraggable");
      }
    },
    /**
     * Makes the mapMarker draggable
     */
    makeMarkerDraggable({
      rootGetters: { map: e },
      getters: t,
      commit: n,
      dispatch: s
    }) {
      const { atZoomLevel: r } = t, i = new Bk({
        condition: () => e.getView().getZoom() >= r,
        layers: [bl]
      });
      e.addInteraction(i), i.on("translatestart", () => {
        n("setGetsDragged", !0);
      }), i.on("translateend", (a) => {
        n("setGetsDragged", !1), a.features.forEach(async (o) => {
          const l = o.getGeometry();
          let f = l == null ? void 0 : l.getCoordinates();
          await s("isCoordinateInBoundaryLayer", f) || (f = t.transformedCoordinate, s("removeMarker"), s("showMarker", {
            coordinates: f,
            clicked: !0
          })), n("setCoordinatesAfterDrag", f), s("updateCoordinates", f);
        });
      });
    },
    /**
     * Removes the mapMarker from the map by removing its vectorLayer
     */
    removeMarker({ rootGetters: { map: e }, commit: t }) {
      e.getLayers().forEach(function(n) {
        n !== void 0 && n.get("polarInternalId") === "mapMarkerVectorLayer" && e.removeLayer(n);
      }), t("setIsActive", !1);
    },
    /**
     * Set the value for the transformed coordinate and save it as latLon as well.
     * @param coordinates - Coordinates of the pin.
     */
    updateCoordinates({ commit: e, rootGetters: t }, n) {
      const s = vD(n, t.configuration.epsg), r = [s[1], s[0]];
      e("setTransformedCoordinate", n), e("setLatLon", r);
    },
    /**
     * Checks if boundary layer conditions are met; returns false if not and
     * toasts to the user about why the action was blocked, if `toastAction` is
     * configured. If no boundaryLayer configured, always returns true.
     */
    async isCoordinateInBoundaryLayer({ rootGetters: e, dispatch: t }, n) {
      var l;
      const { boundaryLayerId: s, toastAction: r, boundaryOnError: i } = ((l = e == null ? void 0 : e.configuration) == null ? void 0 : l.pins) || {}, a = await x_(
        e.map,
        s,
        n
      );
      if (!s || // if a setup error occurred, client will act as if no boundaryLayerId specified
      a === !0 || typeof a == "symbol" && i !== "strict")
        return !0;
      const o = typeof a == "symbol";
      return r ? t(r, o ? {
        type: "error",
        text: "plugins.pins.toast.boundaryError",
        timeout: 0
      } : {
        type: "info",
        text: "plugins.pins.toast.notInBoundary",
        timeout: 1e4
      }, { root: !0 }) : console[o ? "error" : "log"](
        o ? "Checking boundary layer failed." : ["Pin position outside of boundary layer:", n]
      ), !1;
    }
  },
  mutations: {
    ...zr(cg())
  },
  getters: {
    ...rr(cg())
  }
}, KY = [
  {
    type: "de",
    resources: {
      plugins: {
        pins: {
          toast: {
            notInBoundary: "Diese Koordinate kann nicht gewählt werden.",
            boundaryError: "Die Überprüfung der Koordinate ist fehlgeschlagen. Bitte versuchen Sie es später erneut oder wenden Sie sich an einen Administrator, wenn das Problem bestehen bleibt."
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        pins: {
          toast: {
            notInBoundary: "It is not possible to select this coordinate.",
            boundaryError: "Validating the coordinate failed. Please try again later or contact an administrator if the issue persists."
          }
        }
      }
    }
  }
], GY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "pins",
  language: KY,
  storeModule: zY,
  options: e
});
var mf = { exports: {} };
mf.exports;
(function(e, t) {
  var n = 200, s = "Expected a function", r = "__lodash_hash_undefined__", i = 1, a = 2, o = 1 / 0, l = 9007199254740991, f = "[object Arguments]", d = "[object Array]", u = "[object Boolean]", c = "[object Date]", h = "[object Error]", p = "[object Function]", g = "[object GeneratorFunction]", m = "[object Map]", v = "[object Number]", y = "[object Object]", E = "[object Promise]", C = "[object RegExp]", x = "[object Set]", b = "[object String]", P = "[object Symbol]", T = "[object WeakMap]", O = "[object ArrayBuffer]", S = "[object DataView]", L = "[object Float32Array]", A = "[object Float64Array]", D = "[object Int8Array]", _ = "[object Int16Array]", w = "[object Int32Array]", B = "[object Uint8Array]", j = "[object Uint8ClampedArray]", k = "[object Uint16Array]", X = "[object Uint32Array]", rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, et = /^\w*$/, Z = /^\./, dt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, vt = /[\\^$.*+?()[\]{}|]/g, bt = /\\(\\)?/g, it = /^\[object .+?Constructor\]$/, R = /^(?:0|[1-9]\d*)$/, V = {};
  V[L] = V[A] = V[D] = V[_] = V[w] = V[B] = V[j] = V[k] = V[X] = !0, V[f] = V[d] = V[O] = V[u] = V[S] = V[c] = V[h] = V[p] = V[m] = V[v] = V[y] = V[C] = V[x] = V[b] = V[T] = !1;
  var tt = typeof _t == "object" && _t && _t.Object === Object && _t, Y = typeof self == "object" && self && self.Object === Object && self, $ = tt || Y || Function("return this")(), z = t && !t.nodeType && t, at = z && !0 && e && !e.nodeType && e, ct = at && at.exports === z, St = ct && tt.process, F = function() {
    try {
      return St && St.binding("util");
    } catch {
    }
  }(), M = F && F.isTypedArray;
  function I(W, Q) {
    for (var pt = -1, Tt = W ? W.length : 0; ++pt < Tt; )
      if (Q(W[pt], pt, W))
        return !0;
    return !1;
  }
  function N(W) {
    return function(Q) {
      return Q == null ? void 0 : Q[W];
    };
  }
  function G(W, Q) {
    for (var pt = -1, Tt = Array(W); ++pt < W; )
      Tt[pt] = Q(pt);
    return Tt;
  }
  function nt(W) {
    return function(Q) {
      return W(Q);
    };
  }
  function lt(W, Q) {
    return W == null ? void 0 : W[Q];
  }
  function yt(W) {
    var Q = !1;
    if (W != null && typeof W.toString != "function")
      try {
        Q = !!(W + "");
      } catch {
      }
    return Q;
  }
  function Lt(W) {
    var Q = -1, pt = Array(W.size);
    return W.forEach(function(Tt, ie) {
      pt[++Q] = [ie, Tt];
    }), pt;
  }
  function Nt(W, Q) {
    return function(pt) {
      return W(Q(pt));
    };
  }
  function Jt(W) {
    var Q = -1, pt = Array(W.size);
    return W.forEach(function(Tt) {
      pt[++Q] = Tt;
    }), pt;
  }
  var J = Array.prototype, ft = Function.prototype, Ct = Object.prototype, Mt = $["__core-js_shared__"], Ot = function() {
    var W = /[^.]+$/.exec(Mt && Mt.keys && Mt.keys.IE_PROTO || "");
    return W ? "Symbol(src)_1." + W : "";
  }(), kt = ft.toString, de = Ct.hasOwnProperty, Pe = Ct.toString, Me = RegExp(
    "^" + kt.call(de).replace(vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ce = $.Symbol, $e = $.Uint8Array, bn = Ct.propertyIsEnumerable, Ye = J.splice, Hn = Nt(Object.keys, Object), fn = ts($, "DataView"), Fe = ts($, "Map"), pn = ts($, "Promise"), mn = ts($, "Set"), we = ts($, "WeakMap"), gn = ts(Object, "create"), ze = es(fn), On = es(Fe), qe = es(pn), se = es(mn), mi = es(we), Xe = Ce ? Ce.prototype : void 0, sn = Xe ? Xe.valueOf : void 0, Ue = Xe ? Xe.toString : void 0;
  function wn(W) {
    var Q = -1, pt = W ? W.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Tt = W[Q];
      this.set(Tt[0], Tt[1]);
    }
  }
  function ii() {
    this.__data__ = gn ? gn(null) : {};
  }
  function oa(W) {
    return this.has(W) && delete this.__data__[W];
  }
  function Cs(W) {
    var Q = this.__data__;
    if (gn) {
      var pt = Q[W];
      return pt === r ? void 0 : pt;
    }
    return de.call(Q, W) ? Q[W] : void 0;
  }
  function xs(W) {
    var Q = this.__data__;
    return gn ? Q[W] !== void 0 : de.call(Q, W);
  }
  function kr(W, Q) {
    var pt = this.__data__;
    return pt[W] = gn && Q === void 0 ? r : Q, this;
  }
  wn.prototype.clear = ii, wn.prototype.delete = oa, wn.prototype.get = Cs, wn.prototype.has = xs, wn.prototype.set = kr;
  function Bn(W) {
    var Q = -1, pt = W ? W.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Tt = W[Q];
      this.set(Tt[0], Tt[1]);
    }
  }
  function gi() {
    this.__data__ = [];
  }
  function Hr(W) {
    var Q = this.__data__, pt = Ei(Q, W);
    if (pt < 0)
      return !1;
    var Tt = Q.length - 1;
    return pt == Tt ? Q.pop() : Ye.call(Q, pt, 1), !0;
  }
  function Ve(W) {
    var Q = this.__data__, pt = Ei(Q, W);
    return pt < 0 ? void 0 : Q[pt][1];
  }
  function vi(W) {
    return Ei(this.__data__, W) > -1;
  }
  function yi(W, Q) {
    var pt = this.__data__, Tt = Ei(pt, W);
    return Tt < 0 ? pt.push([W, Q]) : pt[Tt][1] = Q, this;
  }
  Bn.prototype.clear = gi, Bn.prototype.delete = Hr, Bn.prototype.get = Ve, Bn.prototype.has = vi, Bn.prototype.set = yi;
  function Ze(W) {
    var Q = -1, pt = W ? W.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Tt = W[Q];
      this.set(Tt[0], Tt[1]);
    }
  }
  function Gi() {
    this.__data__ = {
      hash: new wn(),
      map: new (Fe || Bn)(),
      string: new wn()
    };
  }
  function Or(W) {
    return yn(this, W).delete(W);
  }
  function bs(W) {
    return yn(this, W).get(W);
  }
  function Nn(W) {
    return yn(this, W).has(W);
  }
  function Tn(W, Q) {
    return yn(this, W).set(W, Q), this;
  }
  Ze.prototype.clear = Gi, Ze.prototype.delete = Or, Ze.prototype.get = bs, Ze.prototype.has = Nn, Ze.prototype.set = Tn;
  function ri(W) {
    var Q = -1, pt = W ? W.length : 0;
    for (this.__data__ = new Ze(); ++Q < pt; )
      this.add(W[Q]);
  }
  function Dn(W) {
    return this.__data__.set(W, r), this;
  }
  function Fn(W) {
    return this.__data__.has(W);
  }
  ri.prototype.add = ri.prototype.push = Dn, ri.prototype.has = Fn;
  function Je(W) {
    this.__data__ = new Bn(W);
  }
  function Yn() {
    this.__data__ = new Bn();
  }
  function si(W) {
    return this.__data__.delete(W);
  }
  function Tr(W) {
    return this.__data__.get(W);
  }
  function Yr(W) {
    return this.__data__.has(W);
  }
  function sr(W, Q) {
    var pt = this.__data__;
    if (pt instanceof Bn) {
      var Tt = pt.__data__;
      if (!Fe || Tt.length < n - 1)
        return Tt.push([W, Q]), this;
      pt = this.__data__ = new Ze(Tt);
    }
    return pt.set(W, Q), this;
  }
  Je.prototype.clear = Yn, Je.prototype.delete = si, Je.prototype.get = Tr, Je.prototype.has = Yr, Je.prototype.set = sr;
  function Xn(W, Q) {
    var pt = Ps(W) || Du(W) ? G(W.length, String) : [], Tt = pt.length, ie = !!Tt;
    for (var Ut in W)
      (Q || de.call(W, Ut)) && !(ie && (Ut == "length" || ih(Ut, Tt))) && pt.push(Ut);
    return pt;
  }
  function Ei(W, Q) {
    for (var pt = W.length; pt--; )
      if (oh(W[pt][0], Q))
        return pt;
    return -1;
  }
  var Xr = Rt();
  function Zr(W, Q) {
    return W && Xr(W, Q, ns);
  }
  function Pr(W, Q) {
    Q = so(Q, W) ? [Q] : Et(Q);
    for (var pt = 0, Tt = Q.length; W != null && pt < Tt; )
      W = W[il(Q[pt++])];
    return pt && pt == Tt ? W : void 0;
  }
  function ki(W) {
    return Pe.call(W);
  }
  function Di(W, Q) {
    return W != null && Q in Object(W);
  }
  function Se(W, Q, pt, Tt, ie) {
    return W === Q ? !0 : W == null || Q == null || !fe(W) && !xe(Q) ? W !== W && Q !== Q : Zn(W, Q, Se, pt, Tt, ie);
  }
  function Zn(W, Q, pt, Tt, ie, Ut) {
    var Ie = Ps(W), Ge = Ps(Q), an = d, jn = d;
    Ie || (an = ar(W), an = an == f ? y : an), Ge || (jn = ar(Q), jn = jn == f ? y : jn);
    var xi = an == y && !yt(W), Li = jn == y && !yt(Q), Un = an == jn;
    if (Un && !xi)
      return Ut || (Ut = new Je()), Ie || me(W) ? ne(W, Q, pt, Tt, ie, Ut) : vn(W, Q, an, pt, Tt, ie, Ut);
    if (!(ie & a)) {
      var or = xi && de.call(W, "__wrapped__"), lr = Li && de.call(Q, "__wrapped__");
      if (or || lr) {
        var ua = or ? W.value() : W, Ms = lr ? Q.value() : Q;
        return Ut || (Ut = new Je()), pt(ua, Ms, Tt, ie, Ut);
      }
    }
    return Un ? (Ut || (Ut = new Je()), Pn(W, Q, pt, Tt, ie, Ut)) : !1;
  }
  function Os(W, Q, pt, Tt) {
    var ie = pt.length, Ut = ie, Ie = !Tt;
    if (W == null)
      return !Ut;
    for (W = Object(W); ie--; ) {
      var Ge = pt[ie];
      if (Ie && Ge[2] ? Ge[1] !== W[Ge[0]] : !(Ge[0] in W))
        return !1;
    }
    for (; ++ie < Ut; ) {
      Ge = pt[ie];
      var an = Ge[0], jn = W[an], xi = Ge[1];
      if (Ie && Ge[2]) {
        if (jn === void 0 && !(an in W))
          return !1;
      } else {
        var Li = new Je();
        if (Tt)
          var Un = Tt(jn, xi, an, W, Q, Li);
        if (!(Un === void 0 ? Se(xi, jn, Tt, i | a, Li) : Un))
          return !1;
      }
    }
    return !0;
  }
  function Jr(W) {
    if (!fe(W) || rh(W))
      return !1;
    var Q = ut(W) || yt(W) ? Me : it;
    return Q.test(es(W));
  }
  function Qr(W) {
    return xe(W) && wt(W.length) && !!V[Pe.call(W)];
  }
  function Hi(W) {
    return typeof W == "function" ? W : W == null ? Lu : typeof W == "object" ? Ps(W) ? K(W[0], W[1]) : U(W) : lh(W);
  }
  function qr(W) {
    if (!Ts(W))
      return Hn(W);
    var Q = [];
    for (var pt in Object(W))
      de.call(W, pt) && pt != "constructor" && Q.push(pt);
    return Q;
  }
  function U(W) {
    var Q = Jn(W);
    return Q.length == 1 && Q[0][2] ? sh(Q[0][0], Q[0][1]) : function(pt) {
      return pt === W || Os(pt, W, Q);
    };
  }
  function K(W, Q) {
    return so(W) && la(Q) ? sh(il(W), Q) : function(pt) {
      var Tt = Ai(pt, W);
      return Tt === void 0 && Tt === Q ? Ci(pt, W) : Se(Q, Tt, void 0, i | a);
    };
  }
  function q(W) {
    return function(Q) {
      return Pr(Q, W);
    };
  }
  function ot(W) {
    if (typeof W == "string")
      return W;
    if (je(W))
      return Ue ? Ue.call(W) : "";
    var Q = W + "";
    return Q == "0" && 1 / W == -o ? "-0" : Q;
  }
  function Et(W) {
    return Ps(W) ? W : ah(W);
  }
  function Rt(W) {
    return function(Q, pt, Tt) {
      for (var ie = -1, Ut = Object(Q), Ie = Tt(Q), Ge = Ie.length; Ge--; ) {
        var an = Ie[W ? Ge : ++ie];
        if (pt(Ut[an], an, Ut) === !1)
          break;
      }
      return Q;
    };
  }
  function ne(W, Q, pt, Tt, ie, Ut) {
    var Ie = ie & a, Ge = W.length, an = Q.length;
    if (Ge != an && !(Ie && an > Ge))
      return !1;
    var jn = Ut.get(W);
    if (jn && Ut.get(Q))
      return jn == Q;
    var xi = -1, Li = !0, Un = ie & i ? new ri() : void 0;
    for (Ut.set(W, Q), Ut.set(Q, W); ++xi < Ge; ) {
      var or = W[xi], lr = Q[xi];
      if (Tt)
        var ua = Ie ? Tt(lr, or, xi, Q, W, Ut) : Tt(or, lr, xi, W, Q, Ut);
      if (ua !== void 0) {
        if (ua)
          continue;
        Li = !1;
        break;
      }
      if (Un) {
        if (!I(Q, function(Ms, ao) {
          if (!Un.has(ao) && (or === Ms || pt(or, Ms, Tt, ie, Ut)))
            return Un.add(ao);
        })) {
          Li = !1;
          break;
        }
      } else if (!(or === lr || pt(or, lr, Tt, ie, Ut))) {
        Li = !1;
        break;
      }
    }
    return Ut.delete(W), Ut.delete(Q), Li;
  }
  function vn(W, Q, pt, Tt, ie, Ut, Ie) {
    switch (pt) {
      case S:
        if (W.byteLength != Q.byteLength || W.byteOffset != Q.byteOffset)
          return !1;
        W = W.buffer, Q = Q.buffer;
      case O:
        return !(W.byteLength != Q.byteLength || !Tt(new $e(W), new $e(Q)));
      case u:
      case c:
      case v:
        return oh(+W, +Q);
      case h:
        return W.name == Q.name && W.message == Q.message;
      case C:
      case b:
        return W == Q + "";
      case m:
        var Ge = Lt;
      case x:
        var an = Ut & a;
        if (Ge || (Ge = Jt), W.size != Q.size && !an)
          return !1;
        var jn = Ie.get(W);
        if (jn)
          return jn == Q;
        Ut |= i, Ie.set(W, Q);
        var xi = ne(Ge(W), Ge(Q), Tt, ie, Ut, Ie);
        return Ie.delete(W), xi;
      case P:
        if (sn)
          return sn.call(W) == sn.call(Q);
    }
    return !1;
  }
  function Pn(W, Q, pt, Tt, ie, Ut) {
    var Ie = ie & a, Ge = ns(W), an = Ge.length, jn = ns(Q), xi = jn.length;
    if (an != xi && !Ie)
      return !1;
    for (var Li = an; Li--; ) {
      var Un = Ge[Li];
      if (!(Ie ? Un in Q : de.call(Q, Un)))
        return !1;
    }
    var or = Ut.get(W);
    if (or && Ut.get(Q))
      return or == Q;
    var lr = !0;
    Ut.set(W, Q), Ut.set(Q, W);
    for (var ua = Ie; ++Li < an; ) {
      Un = Ge[Li];
      var Ms = W[Un], ao = Q[Un];
      if (Tt)
        var bE = Ie ? Tt(ao, Ms, Un, Q, W, Ut) : Tt(Ms, ao, Un, W, Q, Ut);
      if (!(bE === void 0 ? Ms === ao || pt(Ms, ao, Tt, ie, Ut) : bE)) {
        lr = !1;
        break;
      }
      ua || (ua = Un == "constructor");
    }
    if (lr && !ua) {
      var uh = W.constructor, ch = Q.constructor;
      uh != ch && "constructor" in W && "constructor" in Q && !(typeof uh == "function" && uh instanceof uh && typeof ch == "function" && ch instanceof ch) && (lr = !1);
    }
    return Ut.delete(W), Ut.delete(Q), lr;
  }
  function yn(W, Q) {
    var pt = W.__data__;
    return Iu(Q) ? pt[typeof Q == "string" ? "string" : "hash"] : pt.map;
  }
  function Jn(W) {
    for (var Q = ns(W), pt = Q.length; pt--; ) {
      var Tt = Q[pt], ie = W[Tt];
      Q[pt] = [Tt, ie, la(ie)];
    }
    return Q;
  }
  function ts(W, Q) {
    var pt = lt(W, Q);
    return Jr(pt) ? pt : void 0;
  }
  var ar = ki;
  (fn && ar(new fn(new ArrayBuffer(1))) != S || Fe && ar(new Fe()) != m || pn && ar(pn.resolve()) != E || mn && ar(new mn()) != x || we && ar(new we()) != T) && (ar = function(W) {
    var Q = Pe.call(W), pt = Q == y ? W.constructor : void 0, Tt = pt ? es(pt) : void 0;
    if (Tt)
      switch (Tt) {
        case ze:
          return S;
        case On:
          return m;
        case qe:
          return E;
        case se:
          return x;
        case mi:
          return T;
      }
    return Q;
  });
  function Su(W, Q, pt) {
    Q = so(Q, W) ? [Q] : Et(Q);
    for (var Tt, ie = -1, Ie = Q.length; ++ie < Ie; ) {
      var Ut = il(Q[ie]);
      if (!(Tt = W != null && pt(W, Ut)))
        break;
      W = W[Ut];
    }
    if (Tt)
      return Tt;
    var Ie = W ? W.length : 0;
    return !!Ie && wt(Ie) && ih(Ut, Ie) && (Ps(W) || Du(W));
  }
  function ih(W, Q) {
    return Q = Q ?? l, !!Q && (typeof W == "number" || R.test(W)) && W > -1 && W % 1 == 0 && W < Q;
  }
  function so(W, Q) {
    if (Ps(W))
      return !1;
    var pt = typeof W;
    return pt == "number" || pt == "symbol" || pt == "boolean" || W == null || je(W) ? !0 : et.test(W) || !rt.test(W) || Q != null && W in Object(Q);
  }
  function Iu(W) {
    var Q = typeof W;
    return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? W !== "__proto__" : W === null;
  }
  function rh(W) {
    return !!Ot && Ot in W;
  }
  function Ts(W) {
    var Q = W && W.constructor, pt = typeof Q == "function" && Q.prototype || Ct;
    return W === pt;
  }
  function la(W) {
    return W === W && !fe(W);
  }
  function sh(W, Q) {
    return function(pt) {
      return pt == null ? !1 : pt[W] === Q && (Q !== void 0 || W in Object(pt));
    };
  }
  var ah = _u(function(W) {
    W = Ke(W);
    var Q = [];
    return Z.test(W) && Q.push(""), W.replace(dt, function(pt, Tt, ie, Ut) {
      Q.push(ie ? Ut.replace(bt, "$1") : Tt || pt);
    }), Q;
  });
  function il(W) {
    if (typeof W == "string" || je(W))
      return W;
    var Q = W + "";
    return Q == "0" && 1 / W == -o ? "-0" : Q;
  }
  function es(W) {
    if (W != null) {
      try {
        return kt.call(W);
      } catch {
      }
      try {
        return W + "";
      } catch {
      }
    }
    return "";
  }
  function _u(W, Q) {
    if (typeof W != "function" || Q && typeof Q != "function")
      throw new TypeError(s);
    var pt = function() {
      var Tt = arguments, ie = Q ? Q.apply(this, Tt) : Tt[0], Ut = pt.cache;
      if (Ut.has(ie))
        return Ut.get(ie);
      var Ie = W.apply(this, Tt);
      return pt.cache = Ut.set(ie, Ie), Ie;
    };
    return pt.cache = new (_u.Cache || Ze)(), pt;
  }
  _u.Cache = Ze;
  function oh(W, Q) {
    return W === Q || W !== W && Q !== Q;
  }
  function Du(W) {
    return st(W) && de.call(W, "callee") && (!bn.call(W, "callee") || Pe.call(W) == f);
  }
  var Ps = Array.isArray;
  function H(W) {
    return W != null && wt(W.length) && !ut(W);
  }
  function st(W) {
    return xe(W) && H(W);
  }
  function ut(W) {
    var Q = fe(W) ? Pe.call(W) : "";
    return Q == p || Q == g;
  }
  function wt(W) {
    return typeof W == "number" && W > -1 && W % 1 == 0 && W <= l;
  }
  function fe(W) {
    var Q = typeof W;
    return !!W && (Q == "object" || Q == "function");
  }
  function xe(W) {
    return !!W && typeof W == "object";
  }
  function je(W) {
    return typeof W == "symbol" || xe(W) && Pe.call(W) == P;
  }
  var me = M ? nt(M) : Qr;
  function Ke(W) {
    return W == null ? "" : ot(W);
  }
  function Ai(W, Q, pt) {
    var Tt = W == null ? void 0 : Pr(W, Q);
    return Tt === void 0 ? pt : Tt;
  }
  function Ci(W, Q) {
    return W != null && Su(W, Q, Di);
  }
  function ns(W) {
    return H(W) ? Xn(W) : qr(W);
  }
  function Au(W, Q) {
    var pt = {};
    return Q = Hi(Q), Zr(W, function(Tt, ie, Ut) {
      pt[ie] = Q(Tt, ie, Ut);
    }), pt;
  }
  function Lu(W) {
    return W;
  }
  function lh(W) {
    return so(W) ? N(il(W)) : q(W);
  }
  e.exports = Au;
})(mf, mf.exports);
var kY = mf.exports;
const HY = /* @__PURE__ */ qo(kY), { parseString: YY, processors: XY } = ss, ZY = ([e, t]) => `
  <wps:Execute xmlns:wps='http://www.opengis.net/wps/1.0.0' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:ows='http://www.opengis.net/ows/1.1' service='WPS' version='1.0.0' xsi:schemaLocation='http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsExecute_request.xsd'>
    <ows:Identifier>ReverseGeocoder.fmw</ows:Identifier>
      <wps:DataInputs>
        <wps:Input>
          <ows:Identifier>X</ows:Identifier>
          <wps:Data>
            <wps:LiteralData dataType='float'>${e}</wps:LiteralData>
          </wps:Data>
        </wps:Input>
        <wps:Input>
        <ows:Identifier>Y</ows:Identifier>
        <wps:Data>
          <wps:LiteralData dataType='float'>${t}</wps:LiteralData>
        </wps:Data>
      </wps:Input>
    </wps:DataInputs>
  </wps:Execute>
`, JY = (e) => new Promise(
  (t, n) => YY(
    e,
    { tagNameProcessors: [XY.stripPrefix] },
    (s, r) => s ? n(s) : t(r)
  )
), QY = async (e, t) => {
  const n = await fetch(e, {
    method: "POST",
    body: ZY(t)
  }), s = await JY(await n.text()), r = HY(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore | no types for WPS output defined
    s.ExecuteResponse.ProcessOutputs[0].Output[0].Data[0].ComplexData[0].ReverseGeocoder[0].Ergebnis[0].Adresse[0],
    (o) => o[0]
  ), i = {
    Distanz: parseFloat(r.Distanz),
    Hausnr: parseInt(r.Hausnr, 10),
    Plz: parseInt(r.Plz, 10),
    Strasse: r.Strasse,
    XKoordinate: parseFloat(r.XKoordinate),
    YKoordinate: parseFloat(r.YKoordinate),
    Zusatz: r.Zusatz
  };
  return {
    type: "reverse_geocoded",
    title: `${i.Strasse} ${i.Hausnr}${i.Zusatz}`,
    properties: i,
    geometry: {
      // as clicked by user - usually want to keep this since user is pointing at something
      coordinates: t,
      type: "Point"
    },
    addressGeometry: {
      // as returned by reverse geocoder
      coordinates: [i.XKoordinate, i.YKoordinate],
      type: "Point"
    }
  };
};
let MT = 0;
const qY = {
  namespaced: !0,
  state: {},
  actions: {
    setupModule({ rootGetters: e, dispatch: t }) {
      const { coordinateSource: n } = e.configuration.reverseGeocoder || {};
      n && this.watch(
        () => e[n],
        (s) => {
          s && s.length && t("resolveCoordinate", s);
        },
        { deep: !0 }
      );
    },
    async resolveCoordinate({ rootGetters: e, commit: t, dispatch: n }, s) {
      const { url: r, addressTarget: i, addLoading: a, removeLoading: o, zoomTo: l } = e.configuration.reverseGeocoder || {}, { map: f } = e;
      if (!r)
        throw new Error(
          "POLAR ReverseGeocoder#resolveCoordinate: No URL specified."
        );
      const d = ++MT, u = `reverse-geocoder-load-${d}`;
      a && t(a, u, { root: !0 });
      let c = null;
      try {
        c = await QY(r, s), d === MT && (i && n(i, { feature: c }, { root: !0 }), typeof l == "number" && f.getView().fit(new hi(s), {
          maxZoom: l,
          duration: 400,
          easing: Zo
        }));
      } catch (h) {
        console.error(
          "An error occurred in POLAR ReverseGeocoder#resolveCoordinate:"
        ), console.error(h);
      } finally {
        o && t(o, u, { root: !0 });
      }
      return c;
    }
  },
  getters: {},
  mutations: {}
}, tX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "reverseGeocoder",
  storeModule: qY,
  options: e
}), eX = $t.extend({
  name: "PolarScale",
  computed: {
    ...Ee("plugin/scale", ["scaleToOne", "scaleWithUnit"])
  }
});
var nX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-plugin-scales", title: t.$t("common:plugins.scale.label"), "aria-label": t.$t("common:plugins.scale.label") } }, [n("span", { staticClass: "scale-as-a-ratio" }, [t._v(" " + t._s(t.scaleToOne) + " ")]), n("span", { staticClass: "scale-line" }, [t._v(" " + t._s(t.scaleWithUnit) + " ")])]);
}, iX = [], rX = /* @__PURE__ */ Re(
  eX,
  nX,
  iX,
  !1,
  null,
  null,
  null,
  null
);
const sX = rX.exports, aX = [
  {
    type: "de",
    resources: {
      plugins: {
        scale: {
          toOneNegative: "Skalierung muss eine positive Zahl sein",
          label: "Skala"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        scale: {
          toOneNegative: "scale must be a positive number",
          label: "Scale"
        }
      }
    }
  }
];
function oX(e, t = ".", n = ",") {
  const s = typeof e != "string" ? e.toString() : e, r = s.indexOf("."), a = (r > -1 ? s.substring(0, r) : s).replace(/\B(?=(\d{3})+(?!\d),?.*)/g, t), o = r > -1 ? s.substring(r + 1) : !1;
  return o ? a + n + o : a;
}
function lX() {
  let e = 96;
  try {
    const t = document.createElement("div"), n = document.body;
    t.id = "programmatical-dpidiv", t.setAttribute(
      "style",
      "position: absolute; height: 1in; width: 1in; top: -100%; left: -100%;"
    ), n.appendChild(t), e = t.offsetWidth * (window.devicePixelRatio || 1), n.removeChild(t);
  } catch (t) {
    console.error(t), console.warn(
      `Since the dpi could not be inferred, the default value ${e} will be used.`
    );
  }
  return e;
}
const hg = () => ({
  scaleValue: 0,
  scaleToOne: "",
  scaleWithUnit: ""
}), uX = {
  namespaced: !0,
  state: hg(),
  actions: {
    setupModule({ rootGetters: { map: e }, dispatch: t }) {
      e.on("moveend", () => t("getScale"));
    },
    /**
     * gets the current scale and sets it to the state variable scaleValue
     */
    getScale({ rootGetters: { map: e }, commit: t, dispatch: n }) {
      const s = e.getView().getProjection().getUnits(), r = e.getView().getResolution(), i = 39.37, a = Math.round(
        r * Zl[s] * i * lX()
      );
      t("setScaleValue", a), n("scaleWithUnit"), n("scaleToOne");
    },
    /**
     * generates a beautified state in format "1 : scale" where scale is rounded based on its value
     */
    scaleToOne({ getters: e, commit: t }) {
      let n = e.scaleValue;
      if (typeof n != "number" || n <= 0)
        return `1 : ${qI("common:plugins.scale.toOneNegative")}`;
      n > 1e4 ? n = Math.round(n / 500) * 500 : n > 1e3 && (n = Math.round(n / 50) * 50);
      const s = "1 : " + oX(n);
      t("setScaleToOne", s);
    },
    /**
     * generates a beautified scale with a km or m unit
     */
    scaleWithUnit({ getters: e, commit: t }) {
      const n = Math.round(0.02 * e.scaleValue), s = n >= 1e3 ? `${Math.round(n / 100) / 10} km` : `${n} m`;
      t("setScaleWithUnit", s);
    }
  },
  mutations: {
    ...zr(hg())
  },
  getters: {
    ...rr(hg())
  }
}, cX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "scale",
  plugin: sX,
  language: aX,
  storeModule: uX,
  options: e
}), hX = $t.extend({
  name: "PolarToast",
  computed: {
    ...Ee("plugin/toast", ["toasts", "types"])
  },
  methods: {
    ...$r("plugin/toast", ["removeToast"]),
    ...br("plugin/toast", ["addToast"])
  }
});
var dX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "polar-alert-invert" }, t._l(t.toasts, function(s, r) {
    return n("v-alert", { key: s.type + "-" + r + "-" + s.text, staticClass: "v-alert", attrs: { dismissible: "", dense: "", "close-label": t.$t("common:plugins.toast.close"), type: s.type, color: s.color, icon: s.icon }, on: { input: function(i) {
      return t.removeToast(s);
    } } }, [t._v(" " + t._s(t.$t(s.text)) + " ")]);
  }), 1);
}, fX = [], pX = /* @__PURE__ */ Re(
  hX,
  dX,
  fX,
  !1,
  null,
  "98b4ed40",
  null,
  null
);
const mX = pX.exports, gX = [
  {
    type: "de",
    resources: {
      plugins: {
        toast: {
          close: "Benachrichtigung ausblenden"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        toast: {
          close: "Hide notification"
        }
      }
    }
  }
], dg = () => ({
  toasts: [],
  types: {
    success: {
      color: void 0,
      icon: void 0
    },
    warning: {
      color: void 0,
      icon: void 0
    },
    info: {
      color: void 0,
      icon: void 0
    },
    error: {
      color: void 0,
      icon: void 0
    }
  }
}), vX = {
  namespaced: !0,
  state: dg(),
  actions: {
    setupModule({ state: e, commit: t, rootGetters: n }) {
      const s = n.configuration.toast || dg().types, r = Lc({}, e.types, {
        error: s.error || {},
        warning: s.warning || {},
        info: s.info || {},
        success: s.success || {}
      });
      t("setTypes", r);
    },
    addToast({ state: e, commit: t }, n) {
      const s = {
        ...e.types[n.type] || {},
        ...n
      };
      t("addToast", s), n.timeout && setTimeout(() => {
        t("removeToast", s);
      }, n.timeout);
    }
  },
  getters: {
    ...rr(dg())
  },
  mutations: {
    setTypes(e, t) {
      e.types = t;
    },
    addToast(e, t) {
      e.toasts = [...e.toasts, t];
    },
    removeToast(e, t) {
      e.toasts = e.toasts.filter((n) => n !== t);
    }
  }
}, yX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "toast",
  plugin: mX,
  language: gX,
  options: e,
  storeModule: vX
}), EX = $t.extend({
  name: "AttributionButton",
  computed: {
    ...Ee("plugin/attributions", ["windowIsOpen"]),
    mapInfoIcon() {
      return this.windowIsOpen ? "fa-chevron-right" : "fa-regular fa-copyright";
    }
  },
  methods: {
    ...$r("plugin/attributions", ["setWindowIsOpen"]),
    toggleMapInfo() {
      this.setWindowIsOpen(!this.windowIsOpen);
    }
  }
});
var CX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-btn", { staticClass: "buttonSecondary", attrs: { "x-small": "", fab: "", color: "secondary", title: t.$t(
    `common:plugins.attributions.button.${t.windowIsOpen ? "close" : "open"}Title`
  ) }, on: { click: t.toggleMapInfo } }, [n("v-icon", { attrs: { color: "secondaryContrast" } }, [t._v(t._s(t.mapInfoIcon))])], 1);
}, xX = [], bX = /* @__PURE__ */ Re(
  EX,
  CX,
  xX,
  !1,
  null,
  "2d4c700a",
  null,
  null
);
const OX = bX.exports, TX = $t.extend({
  name: "AttributionContent",
  computed: {
    ...Ee(["clientWidth", "hasSmallWidth", "hasWindowSize"]),
    ...Ee("plugin/attributions", ["mapInfo", "windowWidth"]),
    maxWidth() {
      return this.hasWindowSize && this.hasSmallWidth ? this.clientWidth * 0.85 : 1080;
    },
    cardText() {
      return this.mapInfo.map(
        (e) => qI(e, {
          MONTH: `${(/* @__PURE__ */ new Date()).getMonth() + 1}`.padStart(2, "0"),
          YEAR: (/* @__PURE__ */ new Date()).getFullYear().toString()
        })
      ).join("<br>");
    }
  },
  mounted() {
    this.$refs.sources.getElementsByTagName("a").length > 0 && this.$nextTick(
      () => this.$refs.sources.getElementsByTagName("a")[0].focus({ focusVisible: !0 })
    );
  }
});
var PX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-scroll-x-reverse-transition", [n("v-card", { attrs: { dir: "ltr", dense: "", filled: "", width: t.windowWidth, color: "#ffffffdd", "max-width": t.maxWidth } }, [n("v-card-text", { ref: "sources", domProps: { innerHTML: t._s(t.cardText) } })], 1)], 1)], 1);
}, MX = [], SX = /* @__PURE__ */ Re(
  TX,
  PX,
  MX,
  !1,
  null,
  "22a9c86d",
  null,
  null
);
const IX = SX.exports, _X = $t.extend({
  name: "AttributionsPlugin",
  components: {
    AttributionButton: OX,
    AttributionContent: IX
  },
  computed: {
    ...Ee("plugin/attributions", ["renderType", "windowIsOpen"])
  }
});
var DX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.renderType === "independent" ? n("div", { staticClass: "polar-plugin-attributions-wrapper" }, [t.windowIsOpen ? n("AttributionContent", { staticClass: "mr-2" }) : t._e(), n("AttributionButton")], 1) : n("AttributionContent");
}, AX = [], LX = /* @__PURE__ */ Re(
  _X,
  DX,
  AX,
  !1,
  null,
  "4419ce0e",
  null,
  null
);
const RX = LX.exports, wX = [
  {
    type: "de",
    resources: {
      plugins: {
        attributions: {
          button: {
            closeTitle: "Quellennachweis ausblenden",
            openTitle: "Quellennachweis einblenden"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        attributions: {
          button: {
            closeTitle: "Hide Attributions",
            openTitle: "Show Attributions"
          }
        }
      }
    }
  }
];
function VX(e, t, n) {
  return NX(
    FX(e, t),
    n
  );
}
function BX(e) {
  const t = [];
  return e.forEach((n) => {
    n.getVisible() && n.get("id") && t.push(n.get("id"));
  }), t;
}
function NX(e, t = []) {
  const n = [];
  return e.forEach((s) => {
    n.push(s.title);
  }), t.forEach((s) => n.push(s)), n;
}
function FX(e, t) {
  const n = [];
  return t.forEach((s) => {
    e.includes(s.id) && n.push(s);
  }), n;
}
function jX(e) {
  const t = /* @__PURE__ */ new Date();
  return e.replaceAll("{{YEAR}}", t.getFullYear().toString()).replaceAll("{{MONTH}}", `${t.getMonth() + 1}`.padStart(2, "0"));
}
const fg = () => ({
  layer: [],
  attributions: [],
  windowIsOpen: !1
}), UX = {
  namespaced: !0,
  state: fg(),
  actions: {
    setupModule({
      commit: e,
      dispatch: t,
      getters: { listenToChanges: n, renderType: s },
      rootGetters: r
    }) {
      var o, l;
      const { map: i } = r;
      n.forEach(
        (f) => this.watch(
          () => r[f],
          () => t("setLayer"),
          {
            deep: !0
          }
        )
      );
      const a = i.getLayers();
      a.on("add", () => t("setLayer")), a.on("add", () => t("setAttributions")), a.on("change", () => t("setLayer")), t("setLayer"), t("setAttributions"), typeof ((l = (o = r == null ? void 0 : r.configuration) == null ? void 0 : o.attributions) == null ? void 0 : l.initiallyOpen) == "boolean" && s === "independent" && e(
        "setWindowIsOpen",
        r.configuration.attributions.initiallyOpen
      );
    },
    setLayer({ rootGetters: { map: e }, commit: t }) {
      t("setLayer", BX(e.getLayers()));
    },
    setAttributions({ rootGetters: { configuration: e }, commit: t }) {
      var n;
      t(
        "setAttributions",
        ((n = e.attributions) == null ? void 0 : n.layerAttributions) === void 0 ? [] : e.attributions.layerAttributions.map((s) => ({
          ...s,
          title: jX(s.title)
        }))
      );
    }
  },
  mutations: {
    ...zr(fg())
  },
  getters: {
    ...rr(fg()),
    listenToChanges: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.listenToChanges) || [];
    },
    mapInfo: (e, { layer: t, attributions: n, staticAttributions: s }) => VX(t, n, s),
    renderType: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.renderType) || "independent";
    },
    staticAttributions: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.staticAttributions) || [];
    },
    windowWidth: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.windowWidth) || 500;
    }
  }
}, WX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "attributions",
  plugin: RX,
  language: wX,
  storeModule: UX,
  options: e
}), $X = $t.extend({
  name: "FullscreenPlugin",
  props: {
    isHorizontal: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    ...Ee(["map"]),
    ...Ee("plugin/fullscreen", [
      "isInFullscreen",
      "renderType",
      "targetContainerId"
    ]),
    targetContainer() {
      if (this.targetContainerId.length > 0) {
        if (document.getElementById(this.targetContainerId))
          return document.getElementById(this.targetContainerId);
        console.error(
          `Fullscreen.vue: The given targetContainerId ${this.targetContainerId} does not refer to a valid html element.`
        );
      }
      return this.$root.$el;
    }
  },
  mounted() {
    document.addEventListener("webkitfullscreenchange", this.escapeHandler), document.addEventListener("fullscreenchange", this.escapeHandler);
  },
  methods: {
    ...$r("plugin/fullscreen", ["setIsInFullscreen"]),
    /**
     * function that gets fired on changes to the fullscreen mode via the F11 or ESC keys.
     * Sets the state variable accordingly.
     */
    escapeHandler() {
      this.setIsInFullscreen(this.checkForFullscreen());
    },
    /**
     * checks if the browser is in fullscreen
     * @returns true if the fullscreen is activated
     */
    checkForFullscreen() {
      return !!// @ts-expect-error | Error: 'TS2339: Property 'webkitFullscreenElement' does not exist on type 'Element'.'; For information refer to https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API#browser_compatibility
      (document.fullscreenElement || document.webkitFullscreenElement);
    },
    /**
     * Toggles the fullscreen mode
     * As there is currently only support from Chrome, Edge and FireFox for the FullScreen-API
     * without vendor prefix there must be a case distinction.
     */
    toggleFullscreen() {
      this.isInFullscreen ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : (this.targetContainer.requestFullscreen ? this.targetContainer.requestFullscreen() : this.targetContainer.webkitRequestFullscreen && this.targetContainer.webkitRequestFullscreen(), setTimeout(() => this.map.updateSize(), 200)), this.setIsInFullscreen(!this.isInFullscreen);
    }
  }
});
var zX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-tooltip", { staticClass: "polar-fullscreen-wrap", attrs: { left: !t.isHorizontal, bottom: t.isHorizontal }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: { "ma-2": t.renderType === "independent" }, attrs: { color: "primary", small: "", fab: "" }, on: { click: t.toggleFullscreen } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" " + t._s(t.isInFullscreen ? "fa-compress" : "fa-expand") + " ")])], 1)];
  } }]) }, [n("span", [t._v(t._s(t.isInFullscreen ? t.$t("common:plugins.fullscreen.button.tooltip.deactivate") : t.$t("common:plugins.fullscreen.button.tooltip.activate")))])]);
}, KX = [], GX = /* @__PURE__ */ Re(
  $X,
  zX,
  KX,
  !1,
  null,
  "f881fc01",
  null,
  null
);
const kX = GX.exports, HX = [
  {
    type: "de",
    resources: {
      plugins: {
        fullscreen: {
          button: {
            tooltip: {
              activate: "Vollbildmodus aktivieren",
              deactivate: "Vollbildmodus deaktivieren"
            }
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        fullscreen: {
          button: {
            tooltip: {
              activate: "Activate fullscreen",
              deactivate: "Deactivate fullscreen"
            }
          }
        }
      }
    }
  }
], pg = () => ({
  isInFullscreen: !1
}), YX = {
  namespaced: !0,
  state: pg(),
  mutations: {
    ...zr(pg())
  },
  getters: {
    ...rr(pg()),
    renderType: (e, t, n, s) => {
      var r, i;
      return (i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.fullscreen) != null && i.renderType ? s == null ? void 0 : s.configuration.fullscreen.renderType : "independent";
    },
    targetContainerId(e, t, n, s) {
      var r, i, a, o;
      return (i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.fullscreen) != null && i.targetContainerId ? (o = (a = s == null ? void 0 : s.configuration) == null ? void 0 : a.fullscreen) == null ? void 0 : o.targetContainerId : "";
    }
  }
}, XX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "fullscreen",
  plugin: kX,
  language: HX,
  storeModule: YX,
  options: e
}), ZX = $t.extend({
  name: "LayerChooserOptions",
  props: {
    maxWidth: {
      type: Number,
      required: !0
    }
  },
  computed: {
    ...Ee(["clientWidth"]),
    ...Ee("plugin/layerChooser", [
      "openedOptionsService",
      "openedOptionsServiceLayers",
      "activeLayerIds"
    ]),
    activeLayers: {
      get() {
        return this.activeLayerIds[this.openedOptionsService.id];
      },
      set(e) {
        this.toggleOpenedOptionsServiceLayer(e);
      }
    },
    cardActionStyle() {
      return this.clientWidth === this.maxWidth ? "" : `
        width: ${this.maxWidth}px;
        white-space: normal;
      `;
    }
  },
  methods: {
    ...$r("plugin/layerChooser", ["setOpenedOptions"]),
    ...br("plugin/layerChooser", ["toggleOpenedOptionsServiceLayer"])
  }
});
var JX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-card", { staticClass: "layer-chooser-options", attrs: { "max-width": t.maxWidth } }, [n("v-card-actions", { style: t.cardActionStyle }, [n("v-btn", { attrs: { icon: "", small: "", "aria-label": t.$t("common:plugins.layerChooser.returnToLayers") }, on: { click: function(s) {
    return t.setOpenedOptions(null);
  } } }, [n("v-icon", { attrs: { small: "" } }, [t._v("fa-chevron-left")])], 1), n("v-card-title", { staticClass: "layer-chooser-options-card-title" }, [t._v(t._s(t.$t("common:plugins.layerChooser.optionsHeader", t.openedOptionsService)))])], 1), t.openedOptionsService.options.layers && t.openedOptionsServiceLayers ? [n("v-card-title", { attrs: { id: "polar-label-options-layer-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.layerHeader")))]), n("v-card-text", [t._l(t.openedOptionsServiceLayers, function({
    layerName: s,
    displayName: r,
    layerImage: i
  }) {
    return [n("v-checkbox", { key: `layer-chooser-layer-option-${s}`, attrs: { label: t.$t(r), value: s, "aria-describedby": "polar-label-options-layer-title", dense: "", "hide-details": "", disabled: t.activeLayers.length === 1 && t.activeLayers.includes(s) }, scopedSlots: t._u([i ? { key: "prepend", fn: function() {
      return [n("img", { attrs: { src: i } })];
    }, proxy: !0 } : null], null, !0), model: { value: t.activeLayers, callback: function(a) {
      t.activeLayers = a;
    }, expression: "activeLayers" } })];
  })], 2)] : t._e()], 2);
}, QX = [], qX = /* @__PURE__ */ Re(
  ZX,
  JX,
  QX,
  !1,
  null,
  "b8eec4bb",
  null,
  null
);
const tZ = qX.exports, eZ = $t.extend({
  name: "LayerChooserLayerWrapper",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabledLayers: {
      type: Array,
      required: !0
    },
    layerId: {
      type: String,
      required: !0
    }
  },
  computed: {
    ...Ee("plugin/layerChooser", ["idsWithOptions"]),
    hasOptions() {
      return this.idsWithOptions.includes(this.layerId);
    }
  },
  methods: {
    ...$r("plugin/layerChooser", ["setOpenedOptions"])
  }
});
var nZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-tooltip", { attrs: { left: "" }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s }) {
    return [n("div", t._g({ staticClass: "polar-layer-chooser-option-line" }, t.disabledLayers[t.index] && s), [t._t("default"), n("v-btn", { staticClass: "ml-1", class: !t.hasOptions && "polar-layer-chooser-option-invisible", attrs: { "aria-label": t.$t("common:plugins.layerChooser.layerOptions"), icon: "", small: "" }, on: { click: function(r) {
      return t.setOpenedOptions(t.layerId);
    } } }, [n("v-icon", { attrs: { small: "" } }, [t._v("fa-gear")])], 1)], 2)];
  } }], null, !0) }, [t._v(" " + t._s(t.$t("common:plugins.layerChooser.tooltipDisabledLayer")) + " ")]);
}, iZ = [], rZ = /* @__PURE__ */ Re(
  eZ,
  nZ,
  iZ,
  !1,
  null,
  "46f82b1d",
  null,
  null
);
const sZ = rZ.exports, aZ = $t.extend({
  name: "LayerChooserSelection",
  components: { LayerWrapper: sZ },
  props: {
    maxWidth: {
      type: Number,
      required: !0
    }
  },
  computed: {
    ...Ee("plugin/layerChooser", [
      "activeBackgroundId",
      "activeMaskIds",
      "backgrounds",
      "disabledBackgrounds",
      "disabledMasks",
      "shownMasks"
    ]),
    activeBackground: {
      get() {
        return this.activeBackgroundId;
      },
      set(e) {
        this.setActiveBackgroundId(e);
      }
    },
    activeMasks: {
      get() {
        return this.activeMaskIds;
      },
      set(e) {
        this.setActiveMaskIds(e);
      }
    }
  },
  methods: {
    ...br("plugin/layerChooser", [
      "setActiveBackgroundId",
      "setActiveMaskIds"
    ])
  }
});
var oZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-card", { staticClass: "layer-chooser-selection", attrs: { "max-width": t.maxWidth } }, [t.backgrounds.length ? n("v-card-title", { attrs: { id: "polar-label-background-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.backgroundTitle")))]) : t._e(), t.backgrounds.length ? n("v-card-text", [n("v-radio-group", { attrs: { dense: "", "hide-details": "" }, model: { value: t.activeBackground, callback: function(s) {
    t.activeBackground = s;
  }, expression: "activeBackground" } }, [t._l(t.backgrounds, function({ name: s, id: r }, i) {
    return [n("LayerWrapper", { key: "disabled-background-" + i, attrs: { index: i, "disabled-layers": t.disabledBackgrounds, "layer-id": r } }, [n("v-radio", { key: i, attrs: { "aria-describedby": "polar-label-background-title", dense: "", "hide-details": "", label: t.$t(s), value: r, disabled: t.disabledBackgrounds[i] } })], 1)];
  })], 2)], 1) : t._e(), t.shownMasks.length ? n("v-card-title", { attrs: { id: "polar-label-mask-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.maskTitle")))]) : t._e(), t.shownMasks.length ? n("v-card-text", [t._l(t.shownMasks, function({ name: s, id: r }, i) {
    return [n("LayerWrapper", { key: "disabled-mask-" + i, attrs: { index: i, "disabled-layers": t.disabledMasks, "layer-id": r } }, [n("v-checkbox", { staticClass: "cut-off-top-space", attrs: { label: t.$t(s), value: r, "aria-describedby": "polar-label-mask-title", dense: "", "hide-details": "", disabled: t.disabledMasks[i] }, model: { value: t.activeMasks, callback: function(a) {
      t.activeMasks = a;
    }, expression: "activeMasks" } })], 1)];
  })], 2) : t._e()], 1);
}, lZ = [], uZ = /* @__PURE__ */ Re(
  aZ,
  oZ,
  lZ,
  !1,
  null,
  "35e295c7",
  null,
  null
);
const cZ = uZ.exports, hZ = $t.extend({
  name: "LayerChooser",
  components: {
    Options: tZ,
    Selection: cZ
  },
  computed: {
    ...Ee(["clientWidth", "hasSmallWidth", "hasWindowSize"]),
    ...Ee("plugin/layerChooser", ["openedOptions"]),
    displaySelection() {
      return this.openedOptions === null;
    },
    maxWidth() {
      return this.clientWidth * (this.hasWindowSize && this.hasSmallWidth ? 0.75 : 1);
    }
  }
});
var dZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-scroll-x-reverse-transition", [n("div", [t.displaySelection ? n("Selection", { attrs: { "max-width": t.maxWidth } }) : n("Options", { attrs: { "max-width": t.maxWidth } })], 1)]);
}, fZ = [], pZ = /* @__PURE__ */ Re(
  hZ,
  dZ,
  fZ,
  !1,
  null,
  null,
  null,
  null
);
const mZ = pZ.exports, gZ = [
  {
    type: "de",
    resources: {
      plugins: {
        layerChooser: {
          backgroundTitle: "Hintergrundkarte",
          maskTitle: "Fachdaten",
          tooltipDisabledLayer: "Auf der aktuellen Zoomstufe nicht verfügbar.",
          optionsHeader: 'Optionen für Layer "{{name}}"',
          layerHeader: "Auswahl sichtbarer Ebenen",
          layerOptions: "Optionen für Kartenmaterial",
          returnToLayers: "Zurück zur Auswahl"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        layerChooser: {
          backgroundTitle: "Background maps",
          maskTitle: "Subject data",
          tooltipDisabledLayer: "Not available on the current zoom level.",
          optionsHeader: '"{{name}}" layer options',
          layerHeader: "Visible layer selection",
          layerOptions: "Map data options",
          returnToLayers: "Return to selection"
        }
      }
    }
  }
];
function ST(e, t) {
  return e.filter((n) => {
    let { minZoom: s, maxZoom: r } = n;
    return typeof s > "u" && (s = 0), typeof r > "u" && (r = Number.MAX_SAFE_INTEGER), s <= t && t <= r;
  });
}
function mg(e, t = (n) => n) {
  const n = e.map(({ id: s }) => String(s));
  return t(n);
}
const gf = (e, t) => {
  if (Array.isArray(e))
    return e.map((n) => gf(n, t)).find((n) => n !== null) || null;
  if (typeof e == "object") {
    if (e.Name === t)
      return e;
    if (e.Layer)
      return gf(e.Layer, t);
  }
  return null;
}, vZ = (e) => (Array.isArray(e) ? e : [e]).map(
  (t) => (Array.isArray(t.LegendURL) ? t.LegendURL : typeof t.LegendURL == "object" ? [t.LegendURL] : []).map((n) => n.OnlineResource)
).flat(1), yZ = (e, t) => {
  const n = gf(e.Capability.Layer, t);
  return (n == null ? void 0 : n.Title) || "";
}, EZ = (e, t) => {
  const n = gf(e.Capability.Layer, t), s = n == null ? void 0 : n.Style;
  return s && vZ(s)[0] || "";
}, gg = () => ({
  openedOptions: null,
  backgrounds: [],
  masks: [],
  availableBackgrounds: [],
  availableMasks: [],
  activeBackgroundId: "",
  activeMaskIds: [],
  activeLayerIds: {}
}), CZ = {
  namespaced: !0,
  state: gg(),
  actions: {
    setupModule({
      state: e,
      rootGetters: { configuration: t, map: n },
      commit: s,
      dispatch: r
    }) {
      const [i, a] = t.layers.reduce(
        ([f, d], u) => u.type === "background" ? [[...f, u], d] : u.type === "mask" ? [f, [...d, u]] : (console.error(
          `Unknown layer type ${u.type} in Plugin LayerChooser. Layer is ignored by plugin.`
        ), [f, d]),
        [[], []]
      ), o = i.find(({ visibility: f }) => f), l = a.filter(({ visibility: f }) => f);
      s("setBackgrounds", i), s("setMasks", a), r("setActiveBackgroundId", (o == null ? void 0 : o.id) || null), r("setActiveMaskIds", mg(l)), r("updateActiveAndAvailableLayersByZoom"), n.on("moveend", () => r("updateActiveAndAvailableLayersByZoom")), t.layers.forEach((f) => {
        var u, c, h, p, g;
        const d = Ka({
          id: f.id
        });
        if (d.typ !== "WMS" && !f.hideInMenu) {
          console.warn(
            `Used configuration 'layers' on layer with type '${d.typ}', but only 'WMS' is supported. Ignoring configuration for ${JSON.stringify(
              d
            )}.`
          );
          return;
        }
        (u = f == null ? void 0 : f.options) != null && u.layers && s("setActiveLayerIds", {
          ...e.activeLayerIds,
          [f.id]: d.layers.split(",")
        }), (((h = (c = f == null ? void 0 : f.options) == null ? void 0 : c.layers) == null ? void 0 : h.title) === !0 || ((g = (p = f == null ? void 0 : f.options) == null ? void 0 : p.layers) == null ? void 0 : g.legend) === !0) && r("capabilities/loadCapabilities", f.id, { root: !0 });
      });
    },
    setActiveBackgroundId({ rootGetters: { map: e }, getters: { backgrounds: t }, commit: n }, s) {
      e.getLayers().getArray().forEach((r) => {
        t.find(({ id: i }) => i === r.get("id")) && r.setVisible(r.get("id") === s);
      }), n("setActiveBackgroundId", s);
    },
    setActiveMaskIdsVisibility({ rootGetters: { map: e }, getters: { masks: t } }, n) {
      e.getLayers().getArray().forEach((s) => {
        t.find(({ id: r }) => r === s.get("id")) && s.setVisible(n.includes(s.get("id")));
      });
    },
    setActiveMaskIds({ commit: e, dispatch: t }, n) {
      t("setActiveMaskIdsVisibility", n), e("setActiveMaskIds", n);
    },
    // when the zoom changes, it does what needs to be done
    updateActiveAndAvailableLayersByZoom({
      rootGetters: { map: e },
      getters: { backgrounds: t, masks: n },
      commit: s,
      dispatch: r,
      getters: { activeBackgroundId: i, activeMaskIds: a }
    }) {
      const o = e.getView().getZoom(), l = ST(
        t,
        o
      ), f = ST(n, o), d = mg(l), u = mg(f);
      d.includes(i) || r("setActiveBackgroundId", d[0] || ""), r(
        "setActiveMaskIdsVisibility",
        u.filter((c) => a.includes(c))
      ), s("setAvailableBackgrounds", l), s("setAvailableMasks", f);
    },
    toggleOpenedOptionsServiceLayer({
      commit: e,
      rootGetters: t,
      getters: {
        openedOptionsService: n,
        openedOptionsServiceLayers: s,
        activeLayerIds: r
      }
    }, i) {
      var u;
      const a = s === null ? i : s.filter(({ layerName: c }) => i.includes(c)).map(({ layerName: c }) => c).reverse(), l = (t == null ? void 0 : t.map).getLayers().getArray().find((c) => c.get("id") === n.id), f = (u = l == null ? void 0 : l.getSource) == null ? void 0 : u.call(l);
      if (!l || !f) {
        console.error(
          `Action 'toggleOpenedOptionsServiceLayer' failed on ${n.id} with value ${a}: Layer not found in OL, or source not initialized in OL.`
        );
        return;
      }
      const d = { ...f.getParams(), LAYERS: a };
      f.updateParams(d), e("setActiveLayerIds", {
        ...r,
        [n.id]: a
      });
    }
  },
  mutations: {
    ...zr(gg())
  },
  getters: {
    ...rr(gg()),
    disabledBackgrounds(e, { availableBackgrounds: t, backgrounds: n }) {
      return n.map(
        ({ id: s }) => t.findIndex((r) => r.id === s)
      ).map((s) => s === -1);
    },
    disabledMasks(e, { availableMasks: t, masks: n }) {
      return n.filter(({ hideInMenu: s }) => !s).map(
        ({ id: s }) => t.findIndex((r) => r.id === s)
      ).map((s) => s === -1);
    },
    shownMasks({ masks: e }) {
      return e.filter(({ hideInMenu: t }) => !t);
    },
    idsWithOptions(e, { backgrounds: t, masks: n }) {
      return [...t, ...n].filter((s) => !!s.options).map((s) => s.id);
    },
    openedOptionsService(e, { backgrounds: t, masks: n, openedOptions: s }) {
      return [...t, ...n].find(
        (r) => r.id === s
      );
    },
    openedOptionsServiceLayers(e, { openedOptionsService: t }, n, s) {
      var l, f, d;
      const r = (l = t == null ? void 0 : t.options) == null ? void 0 : l.layers;
      if (typeof r > "u")
        return null;
      const i = Ka({
        id: t.id
      });
      if (!i.layers)
        return console.error(
          'Trying to configure layers of a layer without "layers" field.',
          i
        ), null;
      const a = s == null ? void 0 : s["capabilities/wmsCapabilitiesAsJsonById"](t.id);
      return a === null ? (console.error(
        `CapabilitiesJson for layer ${JSON.stringify(
          t
        )} is null.`
      ), null) : (((d = (f = r.order) == null ? void 0 : f.split) == null ? void 0 : d.call(f, ",")) || i.layers.split(",")).map((u) => {
        var c;
        return {
          layerName: u,
          displayName: ((r == null ? void 0 : r.title) === !0 ? yZ(
            a,
            u
          ) : (r == null ? void 0 : r.title) === !1 ? u : r == null ? void 0 : r.title[u]) || u,
          layerImage: r.legend === !1 ? null : r.legend === !0 ? EZ(
            a,
            u
          ) : ((c = r.legend) == null ? void 0 : c[u]) || null
        };
      });
    }
  }
}, xZ = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "layerChooser",
  plugin: mZ,
  language: gZ,
  storeModule: CZ,
  options: e
}), bZ = $t.extend({
  name: "PolarZoom",
  props: {
    isHorizontal: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    ...Ee(["hasSmallHeight"]),
    ...Ee("plugin/zoom", [
      "maximumZoomLevelActive",
      "minimumZoomLevelActive",
      "renderType",
      "showMobile"
    ]),
    showZoomButtons() {
      return this.hasSmallHeight ? this.showMobile : !0;
    }
  },
  methods: {
    ...br("plugin/zoom", ["increaseZoomLevel", "decreaseZoomLevel"])
  }
});
var OZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.showZoomButtons ? n("div", { staticClass: "polar-zoom-wrap" }, [n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: t.renderType === "iconMenu" ? `polar-zoom-dependent${t.isHorizontal ? "-horizontal" : ""}` : "ma-2", attrs: { "aria-label": t.$t("common:plugins.zoom.in"), color: "primary", small: "", fab: "", disabled: t.maximumZoomLevelActive }, on: { click: t.increaseZoomLevel } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" fa-plus ")])], 1)];
  } }], null, !1, 1658946353) }, [n("span", [t._v(t._s(t.$t("common:plugins.zoom.in")))])]), n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: { "ma-2": t.renderType === "independent" }, attrs: { "aria-label": t.$t("common:plugins.zoom.out"), color: "primary", small: "", fab: "", disabled: t.minimumZoomLevelActive }, on: { click: t.decreaseZoomLevel } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" fa-minus ")])], 1)];
  } }], null, !1, 2549324567) }, [n("span", [t._v(t._s(t.$t("common:plugins.zoom.out")))])])], 1) : t._e();
}, TZ = [], PZ = /* @__PURE__ */ Re(
  bZ,
  OZ,
  TZ,
  !1,
  null,
  "aee50481",
  null,
  null
);
const MZ = PZ.exports, SZ = [
  {
    type: "de",
    resources: {
      plugins: {
        zoom: {
          in: "Hinein zoomen",
          out: "Heraus zoomen"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        zoom: {
          in: "Zoom in",
          out: "Zoom out"
        }
      }
    }
  }
], vg = () => ({
  zoomLevel: 0,
  maximumZoomLevel: 12,
  minimumZoomLevel: 0
}), IZ = {
  namespaced: !0,
  state: vg(),
  actions: {
    setupModule({ rootGetters: { map: e }, commit: t, dispatch: n }) {
      const s = e.getView();
      e.on("moveend", () => n("setZoomLevel", s.getZoom())), n("setZoomLevel", s.getZoom()), t("setMaximumZoomLevel", s.getMaxZoom()), t("setMinimumZoomLevel", s.getMinZoom());
    },
    setZoomLevel({
      getters: { maximumZoomLevel: e, minimumZoomLevel: t, zoomLevel: n },
      rootGetters: { map: s },
      commit: r
    }, i) {
      i !== n && n <= e && n >= t && s && (r("setZoomLevel", i), s.getView().setZoom(i));
    },
    increaseZoomLevel({ dispatch: e, getters: { zoomLevel: t } }) {
      e("setZoomLevel", t + 1);
    },
    decreaseZoomLevel({ dispatch: e, getters: { zoomLevel: t } }) {
      e("setZoomLevel", t - 1);
    }
  },
  mutations: {
    ...zr(vg())
  },
  getters: {
    ...rr(vg()),
    maximumZoomLevelActive: (e, { zoomLevel: t, maximumZoomLevel: n }) => t >= n,
    minimumZoomLevelActive: (e, { zoomLevel: t, minimumZoomLevel: n }) => t <= n,
    renderType: (e, t, n, s) => {
      var r, i;
      return (i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.zoom) != null && i.renderType ? s == null ? void 0 : s.configuration.zoom.renderType : "independent";
    },
    showMobile: (e, t, n, s) => {
      var r, i;
      return typeof ((i = (r = s == null ? void 0 : s.configuration) == null ? void 0 : r.zoom) == null ? void 0 : i.showMobile) == "boolean" ? s == null ? void 0 : s.configuration.zoom.showMobile : !1;
    }
  }
}, _Z = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "zoom",
  plugin: MZ,
  language: SZ,
  storeModule: IZ,
  options: e
});
function DZ(e) {
  return [
    {
      plugin: xZ({}),
      icon: "fa-book-atlas",
      id: "layerChooser"
    },
    {
      plugin: _Z({ renderType: "iconMenu" }),
      id: "zoom"
    },
    e !== Na.REPORT && {
      plugin: XX({ renderType: "iconMenu" }),
      id: "fullscreen"
    },
    {
      plugin: WX({
        renderType: "iconMenu",
        windowWidth: 550,
        listenToChanges: [
          "plugin/zoom/zoomLevel",
          "plugin/layerChooser/activeBackgroundId",
          "plugin/layerChooser/activeMaskIds"
        ]
      }),
      icon: "fa-regular fa-copyright",
      id: "attributions"
    }
  ].filter(
    (t) => t
    /* remove `false` entries */
  );
}
const AZ = (e, t) => {
  const n = TY({
    initiallyOpen: "layerChooser",
    displayComponent: !0,
    menus: DZ(t),
    layoutTag: go.TOP_RIGHT
  });
  eH(DH), e.addPlugins(
    [
      n,
      t !== Na.SINGLE && e9({
        displayComponent: !0,
        layoutTag: go.TOP_LEFT,
        addLoading: "plugin/loadingIndicator/addLoadingKey",
        removeLoading: "plugin/loadingIndicator/removeLoadingKey"
      }),
      GY({
        displayComponent: !0,
        appearOnClick: { show: !0, atZoomLevel: 0 },
        coordinateSource: "plugin/addressSearch/chosenAddress",
        toastAction: "plugin/toast/addToast"
      }),
      gY({
        displayComponent: !0,
        coordinateSources: ["plugin/addressSearch/chosenAddress"],
        // TODO what is this? often used, seemingly nowhere available
        coordinatesFromMarker: "plugin/pins/coordinatesAfterDrag",
        showGfi: !0
      }),
      FY({
        displayComponent: !0,
        layoutTag: go.MIDDLE_MIDDLE
      }),
      cX({ displayComponent: !0, layoutTag: go.BOTTOM_RIGHT }),
      yX({
        displayComponent: !0,
        layoutTag: go.BOTTOM_MIDDLE
      }),
      t !== Na.SINGLE && v9({
        displayComponent: !1,
        toastAction: "plugin/toast/addToast"
      }),
      tX({
        url: "https://geodienste.hamburg.de/HH_WPS",
        addLoading: "plugin/loadingIndicator/addLoadingKey",
        removeLoading: "plugin/loadingIndicator/removeLoadingKey",
        zoomTo: 7
      })
    ].filter(
      (s) => s
      /* remove `false` entries */
    )
  );
}, O_ = [
  {
    type: "de",
    resources: {
      meldemichel: {
        attributions: {
          stadtplan: 'Kartografie Stadtplan: <a target="_blank" href="https://www.hamburg.de/bsw/landesbetrieb-geoinformation-und-vermessung/">Landesbetrieb Geoinformation und Vermessung</a>',
          luftbilder: 'Kartografie Luftbilder: <a target="_blank" href="https://www.hamburg.de/bsw/landesbetrieb-geoinformation-und-vermessung/">Landesbetrieb Geoinformation und Vermessung</a>',
          reports: "Meldungen durch Bürger"
        },
        layers: {
          stadtplan: "Stadtplan",
          luftbilder: "Luftbildansicht",
          reports: "Meldungen",
          hamburgBorder: "Stadtgrenze Hamburg"
        },
        skat: {
          100: "Wege und Straßen",
          101: "Schlagloch und Wegeschaden",
          102: "Verunreinigung und Vandalismus",
          103: "Wildwuchs und Überwuchs",
          104: "Beschädigtes Verkehrszeichen",
          105: "Beschädigte Brücke, Tunnel, Mauer, Treppe",
          106: "Beschädigte Geländer, Poller, Fahrradständer, Sitzgelegenheit",
          111: "Schrottfahrräder",
          112: "Abgemeldete Fahrzeuge",
          113: "Radverkehr",
          114: "Stadtwald Hamburg",
          115: "Stadtwald: Schäden am Baumbestand",
          116: "Stadtwald: Schäden an Einrichtungen",
          117: "Stadtwald: Wegeschäden",
          118: "Stadtwald: Verschmutzung / Müll",
          119: "Stadtwald: Illegale Aktivitäten",
          120: "Stadtwald: Sonstige Schäden",
          200: "Ampeln und Leuchten",
          202: "Ampel gestört",
          203: "beleuchtetes Schild gestört",
          204: "Straßenbeleuchtung ausgefallen",
          205: "Straßenbeleuchtung tagsüber in Betrieb",
          400: "Grünanlagen und Spielplätze",
          401: "Baumschaden",
          402: "Spielgeräteschaden",
          500: "Siele und Gewässer",
          501: "Gully-Schaden",
          502: "Graben",
          503: "Gewässerverunreinigung"
        },
        status: {
          [vT.PROCESSING]: "In Bearbeitung",
          [vT.PROCESSED]: "Bearbeitet"
        },
        time: {
          [td.NONE]: "Keine Einschränkung",
          [td.DAYS_7]: "Die letzten 7 Tage",
          [td.DAYS_30]: "Die letzten 30 Tage",
          [td.SELECTABLE]: "Zeitraum wählen"
        }
      },
      plugins: {
        geoLocation: {
          toast: {
            notInBoundary: "Das System konnte Sie leider nicht in Hamburg verorten. Bitte benutzen Sie Karte und Suche, um einen Schaden innerhalb von Hamburg zu melden.",
            boundaryError: "Die Verortung ist fehlgeschlagen. Bitte benutzen Sie Karte und Suche, um einen Schaden innerhalb von Hamburg zu melden."
          }
        },
        pins: {
          toast: {
            notInBoundary: "Es können nur Koordinaten innerhalb von Hamburg gewählt werden."
          }
        }
      }
    }
  }
];
O_.forEach((e) => {
  const t = Object.keys(e.resources.meldemichel.skat), n = WH.map((s) => String(s));
  if (t.sort().join(",") !== n.sort().join(","))
    throw new Error(
      `POLAR Meldemichel: Error in language.ts/enums.ts: SKAT and Locales not in sync for language "${e.type}". Affected SKAT: ${t.filter((s) => !n.includes(s)).concat(n.filter((s) => !t.includes(s)))}`
    );
});
const T_ = "453", P_ = "452", op = "6074", IT = "#ffffff", _T = "#003063", LZ = "#ff0019", yg = {
  checkServiceAvailability: !1,
  // service register too long
  epsg: "EPSG:25832",
  locales: O_,
  vuetify: {
    theme: {
      themes: {
        light: {
          primary: _T,
          primaryContrast: IT,
          secondary: IT,
          secondaryContrast: _T
        }
      }
    }
  },
  namedProjections: [
    [
      "EPSG:25832",
      "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    ],
    [
      "EPSG:4326",
      "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
    ]
  ]
}, Eg = [
  {
    id: T_,
    visibility: !0,
    type: "background",
    name: "meldemichel.layers.stadtplan"
  },
  {
    id: P_,
    type: "background",
    name: "meldemichel.layers.luftbilder"
  },
  {
    id: op,
    visibility: !0,
    hideInMenu: !0,
    type: "mask",
    name: "meldemichel.layers.hamburgBorder"
  }
], nd = {
  initiallyOpen: !1,
  layerAttributions: [
    {
      id: T_,
      title: "meldemichel.attributions.stadtplan"
    },
    {
      id: P_,
      title: "meldemichel.attributions.luftbilder"
    }
  ]
}, DT = {
  searchMethods: [
    {
      // @ts-expect-error | missing field "epsg" filled later in process
      queryParameters: {
        searchAddress: !0,
        searchStreets: !0,
        searchHouseNumbers: !0
      },
      type: "mpapi",
      url: "https://geodienste.hamburg.de/HH_WFS_GAGES?service=WFS&request=GetFeature&version=2.0.0"
    }
  ],
  minLength: 3,
  waitMs: 300
}, Cg = {
  // TODO must work separate to GFI (clicking !== selecting, in Meldemichel)
  toZoomLevel: 7,
  movable: !0,
  style: {
    fill: LZ
  },
  boundaryLayerId: op
}, AT = {
  coordinateSource: "plugin/pins/transformedCoordinate",
  addressTarget: "plugin/addressSearch/selectResult"
}, LT = {
  checkLocationInitially: !0,
  zoomLevel: 7,
  boundaryLayerId: op,
  boundaryOnError: "strict",
  showTooltip: !0
}, RZ = {
  [Na.COMPLETE]: (e) => ({
    ...yg,
    addressSearch: DT,
    layers: [
      ...Eg,
      {
        // TODO implement grouping & spider for this one
        // TODO features visible as single, group, selected (green)
        id: e,
        visibility: !0,
        distance: 30,
        type: "mask",
        name: "meldemichel.layers.reports"
      }
    ],
    attributions: {
      ...nd,
      layerAttributions: [
        ...nd.layerAttributions,
        {
          id: e,
          title: "meldemichel.attributions.reports"
        }
      ],
      staticAttributions: [
        '<a href="https://www.hamburg.de/impressum/" target="_blank">Impressum</a>'
      ]
    },
    geoLocation: LT,
    gfi: {
      mode: "bboxDot",
      layers: {
        [e]: {
          // TODO doesn't work atm; no coordinate source
          geometry: !1,
          window: !0,
          properties: {
            filename: "Name of file"
          }
        }
      },
      coordinateSources: []
      // to be set in addPlugins.ts
    },
    pins: Cg,
    reverseGeocoder: AT
  }),
  [Na.REPORT]: () => ({
    ...yg,
    addressSearch: DT,
    layers: Eg,
    attributions: {
      ...nd
    },
    geoLocation: LT,
    pins: Cg,
    reverseGeocoder: AT
  }),
  [Na.SINGLE]: () => ({
    ...yg,
    layers: Eg,
    attributions: {
      ...nd
    },
    pins: Cg
  })
}, wZ = ({
  mode: e,
  // NOTE temporarily commenting out, needed later in NeuesAnliegen-Plugin
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  afmUrl: t,
  reportServiceId: n
}) => {
  if (e === Na.COMPLETE && typeof n > "u")
    throw new Error(
      "POLAR Meldemichel Client: Missing reportServiceId configuration in mode COMPLETE."
    );
  return {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore | TS doesn't get the if above right
    ...RZ[e](n)
    // NOTE local plugin does not exist yet
    // meldemichelNeuesAnliegen: {
    //   afmUrl
    // }
  };
}, VZ = (e) => {
  const t = document.getElementById(e);
  t.shadowRoot.children.app.style.backgroundImage = "url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCADIAMgBAREA/8QAGAABAQEBAQAAAAAAAAAAAAAAAQACAwf/xAAtEAEAAQQCAgEDAwQDAQEAAAABEQACITFBURJhInGBsTKRoQPB4fBCUtHxE//aAAgBAQAAPwD0u0CWRjnqpgwsTzNVuF23VNsSIE5c5olBRzS4PK7rlx7oYu7R1FUqkMnJNURdwz2YqTLBl65pV3xQ+UQJK0WihJrqtW9SgYoZUtG6eYd1lZUhj3Tlxr7VolHPqqDxlUXdBzMNPmMeT6qVYjB75rNt5/UtLw8SMTsrQ+EigvM1m0uwuc4jqkFPjvnqtIIDCdVnnE6kEqiMZZ3VHjPvqiVunnGasl05n1zUYvGDOa1cDdqPrUpno7ap8oFFirF1x79UBcPXcVLGdRqrcOk6ao6ldk1pc/pYCj0/pHFFylzcxg3OioAFnj96Ui2fKgiJZXj1S/IJtlXii4PGFPfqkuAQzJzQWxdvW+qYFflxJG6tTvU0Plzg3k3SsyO+u6BAlqhv+IRNXi+2Kkx8UgKVxMSR1NGJ0fYqtVVHihbonY02l2uefpUm4MmdVWyS4jodU2o5PKHiamCYtn1qqRcZ+lULyfah0g5NHfdTPjjxXpqXGSU5mjEfjOqVXUB3WrY8uxrORwy+qde5qkXOA7qtvidS41RFyxz9P7VlPJAfFMjWm5iTNFxBKxT5luGDFJb5dH1qfjMG+qQkzRuV1rFMgZFjWay3MR45jNXk4D7+qWwbZhfvVgt8hxxUxzucwVW/G7xecjsakXj7TWoG1Qd66rKH0c/esw+Jhlrd1sQuH8+6Fhh5qFykMchSWxasbrDZcXeU/G3Y80wwcPdMy9PGOKhlzyUoBME6azEZYOZjNMzaDtOOKhnh1UhrDFZtDxM6aXLGz1j+aolmWefVEIpdcZ6pUP0lNq58gj8VlW53AalrdrGAl96KocZpbpjQGfrQDLIQdNZyzDEUa3zTx3ButBLEgB1qpi1PG7Vcy5uvzLbnKQTW741rv3WfJFdMdUn6dJ1S4AZDuKhh8QcVnx8rsQxz1WlLdywRrmif1I/vRsB+lazEaE0O6yipgJ420r8o1GMVcz5YqvbfEPE9tQZhj7UkIbx1Vd/pFUNWeB1UCHlGCsmUwDyVoQmc45ocEcPVNkEL+qZcUtrpd6JqWMxkx9ayAg/udVGY3/aqc+SDGsVKMobcZ1VI5HO0CgnAbnbSF25J6Ki1swEfWpAVnI67qwywz0d1ottFxP4pbV0D6awowZ3VEWdT/FQ+Oz1WjKa1MUZHyImKr1MH/lHjbdA5qVuDaTUCXQz3NQzdPkY0VGcuzorSyGddlZS4B8RR1dRdbbDC5ctJ4hCpDVbaeLMk+6k43Ufokz6ijK7z3qtSCGj8UKjthpZCEmOYqMOPvxU4cpG4eaS6b4P/AJWZvlgliaMCuPZ7rWAJMNUpn+KyomDXfdITx6qyKY/alu3hezqoQe/R1VdafpCGc1eLEAWx3hKzreIqLlUkX603Hx49RUsp61Uq3YIHG6hYz3qozI4OpqG1XEp+amc2yk1oYwk9NEfKBzzPFIlxrfqhuAJ55oXPlOTTV5RJMHVUSOATjmrBCzvlpULsTn1SiXTEMUGpmi61SXjROarrpcy/iguFQAOmoYcIRjG2tT/xXfdQyxl6ol8tTVPxnxfpH4quMGdmqfHgQnP1rJKsQLo4rVyBjnc1LIMH3oQU0y/elkSCX6UnXj+9SluDPbqhugJCV45omJtLj3HFUHBHa1E5MYOaRtj9M46oRLhSE0/Wp+R9OatpqXia1Lb9eqxcxbAb3DVvEDB+1SCCTBrHNBFseGCcrxWkh1I7pZSYxxV3ID+KzwZmOfValX42/egwMcaocRNabhhn7VJBagysoVYl8mCMDurQxaBxQeR44Uf4/wAU3MLIZ4KxaWjd4gqxdWsto880tt2Cec/5qmFOPpWVufJUbVg8SMVDhzEUjmXyXmaQZ8rpUrMSkYnlpSZyZ1NXjj9WZ3zUgGev3qQ8flvf1qepJTXB/mjFuCcbaUAHn00z5RjWqkbhtzPHusxBaR9onFSeHtrSvjO3/d0WkTcC9+6eJd/2+tEI9RmoZmcxzGK1ZYE5iWZ7qCcWkQ7otuLZxkZqZbZGZZfVQAYxnFZU8tbyUh7fWagLrZVgz96rrZ6jT9al8g0J/s1W3AwAcFOmXjjdUKuZkmogTX0ayiytzCa5qtRgiSOSlwFsm81AzJD3ndCxCsxqlW0JC5dd05bf0y9UFxcYYYqgLrruWMPqm4yzmcuaglnUvdGlh1yUkrLE8UML+acKoGPWqizDh9RqhmIiU9VSbOOJ56pIhYwU48Rd/tWW2fU6qgtcHNZm7UwdpWhLcwXTVEBnD1Wm3Jn49NZvsH4qg5kpYcEQ6KnYaXdVtg7JjNC6ExOKn+oluWIMfSguW21QIMhzWrmYXCOaszz/AHpLgt8Tj+KxbkWWX3RkkP5rWLsyv0pEwc8TuibtTk/3FSxl26qcjgGNlJaMs6zujyTZKGqWMCOs5zVi1zdlzFICREn+5qwbycRisyYMAbKSbpFy4KQRi2Digy5zjir/AJE4oBLYGc8VWrLOnjqpsz8kCdpWtTienis8ymt4pW4UotlZDEc7aC6bcHGqS0Y6oTJE555rQ5lifbQCqmHsqi7cGezihxIh/mtAFsmGsDiboDXutlpHlMnVQW+fkC3XERUXAYfKq7KPBzUxMRAbpwEEM98Vl+Mdd1eUTA0Al2CJ9VsxMd5fdZtwYitbtGdUXtuPk4xWSR8ne6VnOXWqY5zQ/wDZj1QCRHWa3L5CBvE1lMzLimUt3t/alRc8MeqEeH0zUmohDisWJdba3TkGH8VudRbjmsrkkjr1TI3OYd0XXhZM/dpBCGPGnx4cEYxUHw3n05ohCFnycFIOhzWbX+nfd8Ue4d1tIlUjvWayXZ4lNVR5EYz3VdhLeA3RawzOq1MTGn9qLVwMYdUtjOPiboFJP1Y31US48j3NMsgYDdACCQsxFUxJK8w9UltzmMHMZmq6MO0z9aBW2cHZOqp+ZYGeINUkXEQMUZmWIHB7pT/i6e6uNa3FUk9lXkuNDQM3+Qq9904SLUOcFKCQu9cRWbrcTxOXVatLZ+L7nmsXShH/ACcU3W4zga14niDjr60JGFmOmpi1Pe81fqJ6rLbcP6sPCVruef4oWAOJx7a0r45H0RUhoWdxNFrCqZ6oYnAQ6pBjbJyVl/pjyT/2MfatzFpLHGeaypGJy1YGUia1PrFZulOx/FQqPi6OabLi+4tuAd/Wm79XjcTFZZMBIPDQG7cRFJcXQOQx9KkgcT9eaLcEriIStsG7c8fShtByRRmYnH9qB4dPNawWyrnkrN1gtrK+Oj60o29n+7qiTAy+6dDb+89VlYu+Mx0cVpuLrfi5GRGrKo4d63VBpymsa90Iughf4q99d8VoWEgmNViFJVE0U22+SXTCaqwQrLa4qYdrJVk+S490hAafzUO5jNATzD7rWbXxQXVEAZUoE8YzBxzVNsXMRHFZS5y87rQq6d4p2fLng/8Aax5hdb/TuW6+OfzT5TMGfxVp5A/NKRa7z+am6ScdYpFVt4MxVOc3JJM8lZH5RmXn33WpfHBvvdTLgJj3UZiCkCcsPbUkQ5fUVm5wtuCdFPkXW4idYqCGFy7qmBdxzFAwpEwTmpZSILuyrRv7JSYEU+rWTD43ZzxWkRhZzMlLJBJIT+9Zws5ijwtcIazcfilxmPrmabiWMp+aM+KCQe9UWltwKqDS+QLMe6Lk51y7qEny44qjykFBPvXQ+V2Zja1hZxbkjbSoRjPM6qJHHX7VW6hZiq2S2YmKriBlybRmn9RF13xSGiA8jJDC1kZzMYgpWYgWqEzOAzjdBMaqbJj0zWrULkCQmKkFwzP5qBLZYPVBPlqWMVN28566qlQ/6vdF07XAaqFbRzbIY5qJTxYl91CkzEnvf0rYl1uVIqC7EqZw0eNsrbEu4/NVpMSS80WkXXDNx3+aIM/KI/mtmSIbfw0P/YmTclCLmSeKYuBOI1RduIxilJPjcWo6rEwMcsTTPiguuO6Rtbuo59VX3Ns3XQB0USJ8dJM0t9yfH6TWQxh+7WpLWXPdMpmMVktibj/7USKXBIww/tWgHj/PdCQDHP71M8YOa1lRHiInFSKTj6m4o/S5ymdYqfGFMR7qH5RGXRvNGVPJZODXutH6iHEaqJGQgoWbY16mgFhgl94qZtSXDw0gDiMnNZ/Xs3/NagnMpS2ihiWhwJjcTQ+QrDgiKLxLRxMxjih28BqkCDRT5eLnTureJ31TO/XFBGWCHcuaS60jxDqGhnxkSOMUiafxVd/ULbfjZ5RmAzRbc3ApCmR4qZk8WAckbP7VeRrGde/pWVVgYQ3zNMv/AOahN09wNFzIP8clabQCNUCj44baj+phgdyRxSErj6UyyZx3FSWrMrHNEFykueT+1V183wikbjFa8Sdsclf/2Q==')";
}, RT = (e) => e.split(",").map((t) => Number(t)), BZ = {
  namespaced: !0,
  state: {},
  actions: {
    // setupModule({ getters }): void {},
    setMapState: ({ commit: e, dispatch: t, rootGetters: { map: n } }, {
      mapCenter: s,
      mapZoomLevel: r,
      mapBaseLayer: i,
      vendor_maps_position: a,
      vendor_maps_address_str: o,
      vendor_maps_address_hnr: l
    }) => {
      s && n.getView().setCenter(RT(s)), r && t("plugin/zoom/setZoomLevel", Number(r), {
        root: !0
      }), i && t(
        "plugin/layerChooser/setActiveBackgroundId",
        String(i),
        {
          root: !0
        }
      ), o && l && e(
        "plugin/addressSearch/setInputValue",
        `${o} ${l}`,
        { root: !0 }
      ), a && t(
        "plugin/pins/showMarker",
        {
          clicked: !0,
          epsg: "EPSG:25832",
          type: "Point",
          coordinates: RT(a)
        },
        { root: !0 }
      );
    }
  },
  mutations: {},
  getters: {
    mapState(e, t, n) {
      var r, i, a, o, l, f, d, u, c, h, p, g;
      let s = (i = (r = n == null ? void 0 : n.plugin) == null ? void 0 : r.addressSearch) == null ? void 0 : i.chosenAddress;
      return (s == null ? void 0 : s.type) !== "reverse_geocoded" && (s = null), {
        mapCenter: ((a = n.center) == null ? void 0 : a.join(",")) || "",
        mapZoomLevel: (l = (o = n == null ? void 0 : n.plugin) == null ? void 0 : o.zoom) == null ? void 0 : l.zoomLevel,
        mapBaseLayer: (d = (f = n == null ? void 0 : n.plugin) == null ? void 0 : f.layerChooser) == null ? void 0 : d.activeBackgroundId,
        vendor_maps_position: (c = (u = n == null ? void 0 : n.plugin) == null ? void 0 : u.pins) == null ? void 0 : c.transformedCoordinate,
        vendor_maps_address_str: (h = s == null ? void 0 : s.properties) == null ? void 0 : h.Strasse,
        vendor_maps_address_hnr: s ? `${s.properties.Hausnr}${s.properties.Zusatz}` : void 0,
        vendor_maps_address_plz: (p = s == null ? void 0 : s.properties) == null ? void 0 : p.Plz,
        vendor_maps_address_to: (g = s == null ? void 0 : s.properties) == null ? void 0 : g.Distanz
      };
    }
  }
};
console.log(`POLAR Meldemichel loaded in version ${UH.version}.`);
const NZ = "https://geoportal-hamburg.de/lgv-config/services-internet.json", FZ = (e) => {
  e.getLayers().getArray().find((t) => t.get("id") === op).setStyle(null);
}, GZ = {
  ...qh,
  // TODO API is probably not complete; worked out as part of project
  // how do we identify which marker is moved? by coordinate?
  // movable = false // NOTE relevant for SINGLE mode later – map to Pins config
  createMap: ({
    containerId: e,
    mode: t,
    afmUrl: n,
    reportServiceId: s,
    configOverride: r
  }) => new Promise((i) => {
    Object.keys(Na).includes(t) || console.error(
      `POLAR Meldemichel: Critical error. Unknown mode "${t}" configured. Please use 'COMPLETE', 'REPORT', or 'SINGLE'.`
    ), AZ(qh, t), qh.rawLayerList.initializeLayerList(
      NZ,
      async (a) => {
        const o = await qh.createMap({
          containerId: e,
          mapConfiguration: Lc(
            {
              ...wZ({ mode: t, afmUrl: n, reportServiceId: s }),
              layerConf: a
            },
            r || {}
          )
        });
        o.$store.registerModule("meldemichel", BZ), FZ(o.$store.getters.map), VZ(e), i(o);
      }
    );
  })
};
export {
  GZ as default
};
