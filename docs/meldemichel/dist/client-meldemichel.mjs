const kI = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection"
};
class HI extends Error {
  /**
   * @param {number} code Error code.
   */
  constructor(t) {
    const n = kI[t];
    super(n), this.code = t, this.name = "AssertionError", this.message = n;
  }
}
const XO = HI;
class YI {
  /**
   * @param {string} type Type.
   */
  constructor(t) {
    this.propagationStopped, this.defaultPrevented, this.type = t, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const Wi = YI, Zl = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class XI {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const Qv = XI;
function ZI(e, t, n) {
  let s, r;
  n = n || wo;
  let i = 0, a = e.length, o = !1;
  for (; i < a; )
    s = i + (a - i >> 1), r = +n(e[s], t), r < 0 ? i = s + 1 : (a = s, o = !r);
  return o ? i : ~i;
}
function wo(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}
function Pf(e, t, n) {
  const s = e.length;
  if (e[0] <= t)
    return 0;
  if (t <= e[s - 1])
    return s - 1;
  {
    let r;
    if (n > 0) {
      for (r = 1; r < s; ++r)
        if (e[r] < t)
          return r - 1;
    } else if (n < 0) {
      for (r = 1; r < s; ++r)
        if (e[r] <= t)
          return r;
    } else
      for (r = 1; r < s; ++r) {
        if (e[r] == t)
          return r;
        if (e[r] < t)
          return typeof n == "function" ? n(t, e[r - 1], e[r]) > 0 ? r - 1 : r : e[r - 1] - t < t - e[r] ? r - 1 : r;
      }
    return s - 1;
  }
}
function JI(e, t, n) {
  for (; t < n; ) {
    const s = e[t];
    e[t] = e[n], e[n] = s, ++t, --n;
  }
}
function Kn(e, t) {
  const n = Array.isArray(t) ? t : [t], s = n.length;
  for (let r = 0; r < s; r++)
    e[e.length] = n[r];
}
function Jo(e, t) {
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let s = 0; s < n; s++)
    if (e[s] !== t[s])
      return !1;
  return !0;
}
function QI(e, t) {
  const n = e.length, s = Array(e.length);
  let r;
  for (r = 0; r < n; r++)
    s[r] = { index: r, value: e[r] };
  for (s.sort(function(i, a) {
    return t(i.value, a.value) || i.index - a.index;
  }), r = 0; r < e.length; r++)
    e[r] = s[r].value;
}
function qI(e, t, n) {
  const s = t || wo;
  return e.every(function(r, i) {
    if (i === 0)
      return !0;
    const a = s(e[i - 1], r);
    return !(a > 0 || n && a === 0);
  });
}
function ms() {
  return !0;
}
function uu() {
  return !1;
}
function Vo() {
}
function tD(e) {
  let t = !1, n, s, r;
  return function() {
    const i = Array.prototype.slice.call(arguments);
    return (!t || this !== r || !Jo(i, s)) && (t = !0, r = this, s = i, n = e.apply(this, arguments)), n;
  };
}
function cu(e) {
  for (const t in e)
    delete e[t];
}
function Bo(e) {
  let t;
  for (t in e)
    return !1;
  return !t;
}
class eD extends Qv {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(t) {
    super(), this.eventTarget_ = t, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(t, n) {
    if (!t || !n)
      return;
    const s = this.listeners_ || (this.listeners_ = {}), r = s[t] || (s[t] = []);
    r.includes(n) || r.push(n);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(t) {
    const n = typeof t == "string", s = n ? t : t.type, r = this.listeners_ && this.listeners_[s];
    if (!r)
      return;
    const i = n ? new Wi(t) : (
      /** @type {Event} */
      t
    );
    i.target || (i.target = this.eventTarget_ || this);
    const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    s in a || (a[s] = 0, o[s] = 0), ++a[s];
    let l;
    for (let f = 0, d = r.length; f < d; ++f)
      if ("handleEvent" in r[f] ? l = /** @type {import("../events.js").ListenerObject} */
      r[f].handleEvent(i) : l = /** @type {import("../events.js").ListenerFunction} */
      r[f].call(this, i), l === !1 || i.propagationStopped) {
        l = !1;
        break;
      }
    if (--a[s] === 0) {
      let f = o[s];
      for (delete o[s]; f--; )
        this.removeEventListener(s, Vo);
      delete a[s];
    }
    return l;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && cu(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(t) {
    return this.listeners_ && this.listeners_[t] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(t) {
    return this.listeners_ ? t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(t, n) {
    const s = this.listeners_ && this.listeners_[t];
    if (s) {
      const r = s.indexOf(n);
      r !== -1 && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (s[r] = Vo, ++this.pendingRemovals_[t]) : (s.splice(r, 1), s.length === 0 && delete this.listeners_[t]));
    }
  }
}
const Nc = eD, Kt = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function ve(e, t, n, s, r) {
  if (s && s !== e && (n = n.bind(s)), r) {
    const a = n;
    n = function() {
      e.removeEventListener(t, n), a.apply(this, arguments);
    };
  }
  const i = {
    target: e,
    type: t,
    listener: n
  };
  return e.addEventListener(t, n), i;
}
function yd(e, t, n, s) {
  return ve(e, t, n, s, !0);
}
function Ue(e) {
  e && e.target && (e.target.removeEventListener(e.type, e.listener), cu(e));
}
class Sf extends Nc {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(t, n) {
    if (Array.isArray(t)) {
      const s = t.length, r = new Array(s);
      for (let i = 0; i < s; ++i)
        r[i] = ve(this, t[i], n);
      return r;
    } else
      return ve(
        this,
        /** @type {string} */
        t,
        n
      );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(t, n) {
    let s;
    if (Array.isArray(t)) {
      const r = t.length;
      s = new Array(r);
      for (let i = 0; i < r; ++i)
        s[i] = yd(this, t[i], n);
    } else
      s = yd(
        this,
        /** @type {string} */
        t,
        n
      );
    return n.ol_key = s, s;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(t, n) {
    const s = (
      /** @type {Object} */
      n.ol_key
    );
    if (s)
      zs(s);
    else if (Array.isArray(t))
      for (let r = 0, i = t.length; r < i; ++r)
        this.removeEventListener(t[r], n);
    else
      this.removeEventListener(t, n);
  }
}
Sf.prototype.on;
Sf.prototype.once;
Sf.prototype.un;
function zs(e) {
  if (Array.isArray(e))
    for (let t = 0, n = e.length; t < n; ++t)
      Ue(e[t]);
  else
    Ue(
      /** @type {import("./events.js").EventsKey} */
      e
    );
}
const ZO = Sf;
function Gt() {
  throw new Error("Unimplemented abstract method.");
}
let nD = 0;
function Xt(e) {
  return e.ol_uid || (e.ol_uid = String(++nD));
}
class wE extends Wi {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(t, n, s) {
    super(t), this.key = n, this.oldValue = s;
  }
}
class iD extends ZO {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, Xt(this), this.values_ = null, t !== void 0 && this.setProperties(t);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(t) {
    let n;
    return this.values_ && this.values_.hasOwnProperty(t) && (n = this.values_[t]), n;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(t, n) {
    let s;
    s = `change:${t}`, this.hasListener(s) && this.dispatchEvent(new wE(s, t, n)), s = Zl.PROPERTYCHANGE, this.hasListener(s) && this.dispatchEvent(new wE(s, t, n));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(t, n) {
    this.addEventListener(`change:${t}`, n);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(t, n) {
    this.removeEventListener(`change:${t}`, n);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(t, n, s) {
    const r = this.values_ || (this.values_ = {});
    if (s)
      r[t] = n;
    else {
      const i = r[t];
      r[t] = n, i !== n && this.notify(t, i);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(t, n) {
    for (const s in t)
      this.set(s, t[s], n);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(t) {
    t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(t, n) {
    if (this.values_ && t in this.values_) {
      const s = this.values_[t];
      delete this.values_[t], Bo(this.values_) && (this.values_ = null), n || this.notify(t, s);
    }
  }
}
const xr = iD, zn = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, VE = {
  LENGTH: "length"
};
class mh extends Wi {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(t, n, s) {
    super(t), this.element = n, this.index = s;
  }
}
class rD extends xr {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(t, n) {
    if (super(), this.on, this.once, this.un, n = n || {}, this.unique_ = !!n.unique, this.array_ = t || [], this.unique_)
      for (let s = 0, r = this.array_.length; s < r; ++s)
        this.assertUnique_(this.array_[s], s);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(t) {
    for (let n = 0, s = t.length; n < s; ++n)
      this.push(t[n]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(t) {
    const n = this.array_;
    for (let s = 0, r = n.length; s < r; ++s)
      t(n[s], s, n);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(t) {
    return this.array_[t];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(VE.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(t, n) {
    if (t < 0 || t > this.getLength())
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(n), this.array_.splice(t, 0, n), this.updateLength_(), this.dispatchEvent(
      new mh(zn.ADD, n, t)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(t) {
    this.unique_ && this.assertUnique_(t);
    const n = this.getLength();
    return this.insertAt(n, t), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(t) {
    const n = this.array_;
    for (let s = 0, r = n.length; s < r; ++s)
      if (n[s] === t)
        return this.removeAt(s);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(t) {
    if (t < 0 || t >= this.getLength())
      return;
    const n = this.array_[t];
    return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new mh(zn.REMOVE, n, t)
    ), n;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(t, n) {
    const s = this.getLength();
    if (t >= s) {
      this.insertAt(t, n);
      return;
    }
    if (t < 0)
      throw new Error("Index out of bounds: " + t);
    this.unique_ && this.assertUnique_(n, t);
    const r = this.array_[t];
    this.array_[t] = n, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new mh(zn.REMOVE, r, t)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new mh(zn.ADD, n, t)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(VE.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(t, n) {
    for (let s = 0, r = this.array_.length; s < r; ++s)
      if (this.array_[s] === t && s !== n)
        throw new XO(58);
  }
}
const Fi = rD;
function Zt(e, t) {
  if (!e)
    throw new XO(t);
}
let sD = class JO extends xr {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(t) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), t)
      if (typeof /** @type {?} */
      t.getSimplifiedGeometry == "function") {
        const n = (
          /** @type {Geometry} */
          t
        );
        this.setGeometry(n);
      } else {
        const n = t;
        this.setProperties(n);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const t = (
      /** @type {Feature<Geometry>} */
      new JO(this.hasProperties() ? this.getProperties() : null)
    );
    t.setGeometryName(this.getGeometryName());
    const n = this.getGeometry();
    n && t.setGeometry(
      /** @type {Geometry} */
      n.clone()
    );
    const s = this.getStyle();
    return s && t.setStyle(s), t;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (Ue(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const t = this.getGeometry();
    t && (this.geometryChangeKey_ = ve(
      t,
      Kt.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(t) {
    this.set(this.geometryName_, t);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(t) {
    this.style_ = t, this.styleFunction_ = t ? aD(t) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(t) {
    this.id_ = t, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(t) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = t, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
};
function aD(e) {
  if (typeof e == "function")
    return e;
  {
    let t;
    return Array.isArray(e) ? t = e : (Zt(typeof /** @type {?} */
    e.getZIndex == "function", 41), t = [
      /** @type {import("./style/Style.js").default} */
      e
    ]), function() {
      return t;
    };
  }
}
const Pi = sD, za = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", oD = za.includes("firefox"), lD = za.includes("safari") && !za.includes("chrom");
lD && (za.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(za));
const uD = za.includes("webkit") && !za.includes("edge"), QO = za.includes("macintosh"), Mf = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, qv = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, cD = typeof Image < "u" && Image.prototype.decode, qO = function() {
  let e = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get: function() {
        e = !0;
      }
    });
    window.addEventListener("_", null, t), window.removeEventListener("_", null, t);
  } catch {
  }
  return e;
}(), t1 = new Array(6);
function tr() {
  return [1, 0, 0, 1, 0, 0];
}
function BE(e) {
  return _f(e, 1, 0, 0, 1, 0, 0);
}
function ty(e, t) {
  const n = e[0], s = e[1], r = e[2], i = e[3], a = e[4], o = e[5], l = t[0], f = t[1], d = t[2], u = t[3], c = t[4], h = t[5];
  return e[0] = n * l + r * f, e[1] = s * l + i * f, e[2] = n * d + r * u, e[3] = s * d + i * u, e[4] = n * c + r * h + a, e[5] = s * c + i * h + o, e;
}
function _f(e, t, n, s, r, i, a) {
  return e[0] = t, e[1] = n, e[2] = s, e[3] = r, e[4] = i, e[5] = a, e;
}
function hD(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function Ln(e, t) {
  const n = t[0], s = t[1];
  return t[0] = e[0] * n + e[2] * s + e[4], t[1] = e[1] * n + e[3] * s + e[5], t;
}
function ud(e, t, n) {
  return ty(e, _f(t1, t, 0, 0, n, 0, 0));
}
function dD(e, t, n) {
  return _f(e, t, 0, 0, n, 0, 0);
}
function fD(e, t, n) {
  return ty(e, _f(t1, 1, 0, 0, 1, t, n));
}
function $r(e, t, n, s, r, i, a, o) {
  const l = Math.sin(i), f = Math.cos(i);
  return e[0] = s * f, e[1] = r * l, e[2] = -s * l, e[3] = r * f, e[4] = a * s * f - o * s * l + t, e[5] = a * r * l + o * r * f + n, e;
}
function If(e, t) {
  const n = pD(t);
  Zt(n !== 0, 32);
  const s = t[0], r = t[1], i = t[2], a = t[3], o = t[4], l = t[5];
  return e[0] = a / n, e[1] = -r / n, e[2] = -i / n, e[3] = s / n, e[4] = (i * l - a * o) / n, e[5] = -(s * l - r * o) / n, e;
}
function pD(e) {
  return e[0] * e[3] - e[1] * e[2];
}
let FE;
function ey(e) {
  const t = "matrix(" + e.join(", ") + ")";
  if (qv)
    return t;
  const n = FE || (FE = document.createElement("div"));
  return n.style.transform = t, n.style.transform;
}
const Wn = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Jl(e) {
  const t = ji();
  for (let n = 0, s = e.length; n < s; ++n)
    ec(t, e[n]);
  return t;
}
function mD(e, t, n) {
  const s = Math.min.apply(null, e), r = Math.min.apply(null, t), i = Math.max.apply(null, e), a = Math.max.apply(null, t);
  return ir(s, r, i, a, n);
}
function Br(e, t, n) {
  return n ? (n[0] = e[0] - t, n[1] = e[1] - t, n[2] = e[2] + t, n[3] = e[3] + t, n) : [
    e[0] - t,
    e[1] - t,
    e[2] + t,
    e[3] + t
  ];
}
function e1(e, t) {
  return t ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : e.slice();
}
function Qo(e, t, n) {
  let s, r;
  return t < e[0] ? s = e[0] - t : e[2] < t ? s = t - e[2] : s = 0, n < e[1] ? r = e[1] - n : e[3] < n ? r = n - e[3] : r = 0, s * s + r * r;
}
function jc(e, t) {
  return ny(e, t[0], t[1]);
}
function Rr(e, t) {
  return e[0] <= t[0] && t[2] <= e[2] && e[1] <= t[1] && t[3] <= e[3];
}
function ny(e, t, n) {
  return e[0] <= t && t <= e[2] && e[1] <= n && n <= e[3];
}
function Ag(e, t) {
  const n = e[0], s = e[1], r = e[2], i = e[3], a = t[0], o = t[1];
  let l = Wn.UNKNOWN;
  return a < n ? l = l | Wn.LEFT : a > r && (l = l | Wn.RIGHT), o < s ? l = l | Wn.BELOW : o > i && (l = l | Wn.ABOVE), l === Wn.UNKNOWN && (l = Wn.INTERSECTING), l;
}
function ji() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ir(e, t, n, s, r) {
  return r ? (r[0] = e, r[1] = t, r[2] = n, r[3] = s, r) : [e, t, n, s];
}
function $c(e) {
  return ir(1 / 0, 1 / 0, -1 / 0, -1 / 0, e);
}
function iy(e, t) {
  const n = e[0], s = e[1];
  return ir(n, s, n, s, t);
}
function ry(e, t, n, s, r) {
  const i = $c(r);
  return i1(i, e, t, n, s);
}
function Fo(e, t) {
  return e[0] == t[0] && e[2] == t[2] && e[1] == t[1] && e[3] == t[3];
}
function n1(e, t) {
  return t[0] < e[0] && (e[0] = t[0]), t[2] > e[2] && (e[2] = t[2]), t[1] < e[1] && (e[1] = t[1]), t[3] > e[3] && (e[3] = t[3]), e;
}
function ec(e, t) {
  t[0] < e[0] && (e[0] = t[0]), t[0] > e[2] && (e[2] = t[0]), t[1] < e[1] && (e[1] = t[1]), t[1] > e[3] && (e[3] = t[1]);
}
function i1(e, t, n, s, r) {
  for (; n < s; n += r)
    gD(e, t[n], t[n + 1]);
  return e;
}
function gD(e, t, n) {
  e[0] = Math.min(e[0], t), e[1] = Math.min(e[1], n), e[2] = Math.max(e[2], t), e[3] = Math.max(e[3], n);
}
function sy(e, t) {
  let n;
  return n = t(So(e)), n || (n = t(Ql(e)), n) || (n = t(Mo(e)), n) || (n = t(gs(e)), n) ? n : !1;
}
function Lg(e) {
  let t = 0;
  return Df(e) || (t = Ee(e) * In(e)), t;
}
function So(e) {
  return [e[0], e[1]];
}
function Ql(e) {
  return [e[2], e[1]];
}
function $i(e) {
  return [(e[0] + e[2]) / 2, (e[1] + e[3]) / 2];
}
function vD(e, t) {
  let n;
  return t === "bottom-left" ? n = So(e) : t === "bottom-right" ? n = Ql(e) : t === "top-left" ? n = gs(e) : t === "top-right" ? n = Mo(e) : Zt(!1, 13), n;
}
function $l(e, t, n, s, r) {
  const [i, a, o, l, f, d, u, c] = Rg(
    e,
    t,
    n,
    s
  );
  return ir(
    Math.min(i, o, f, u),
    Math.min(a, l, d, c),
    Math.max(i, o, f, u),
    Math.max(a, l, d, c),
    r
  );
}
function Rg(e, t, n, s) {
  const r = t * s[0] / 2, i = t * s[1] / 2, a = Math.cos(n), o = Math.sin(n), l = r * a, f = r * o, d = i * a, u = i * o, c = e[0], h = e[1];
  return [
    c - l + u,
    h - f - d,
    c - l - u,
    h - f + d,
    c + l - u,
    h + f + d,
    c + l + u,
    h + f - d,
    c - l + u,
    h - f - d
  ];
}
function In(e) {
  return e[3] - e[1];
}
function Ys(e, t, n) {
  const s = n || ji();
  return hn(e, t) ? (e[0] > t[0] ? s[0] = e[0] : s[0] = t[0], e[1] > t[1] ? s[1] = e[1] : s[1] = t[1], e[2] < t[2] ? s[2] = e[2] : s[2] = t[2], e[3] < t[3] ? s[3] = e[3] : s[3] = t[3]) : $c(s), s;
}
function gs(e) {
  return [e[0], e[3]];
}
function Mo(e) {
  return [e[2], e[3]];
}
function Ee(e) {
  return e[2] - e[0];
}
function hn(e, t) {
  return e[0] <= t[2] && e[2] >= t[0] && e[1] <= t[3] && e[3] >= t[1];
}
function Df(e) {
  return e[2] < e[0] || e[3] < e[1];
}
function yD(e, t) {
  return t ? (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t) : e;
}
function ED(e, t, n) {
  let s = !1;
  const r = Ag(e, t), i = Ag(e, n);
  if (r === Wn.INTERSECTING || i === Wn.INTERSECTING)
    s = !0;
  else {
    const a = e[0], o = e[1], l = e[2], f = e[3], d = t[0], u = t[1], c = n[0], h = n[1], p = (h - u) / (c - d);
    let g, m;
    i & Wn.ABOVE && !(r & Wn.ABOVE) && (g = c - (h - f) / p, s = g >= a && g <= l), !s && i & Wn.RIGHT && !(r & Wn.RIGHT) && (m = h - (c - l) * p, s = m >= o && m <= f), !s && i & Wn.BELOW && !(r & Wn.BELOW) && (g = c - (h - o) / p, s = g >= a && g <= l), !s && i & Wn.LEFT && !(r & Wn.LEFT) && (m = h - (c - a) * p, s = m >= o && m <= f);
  }
  return s;
}
function CD(e, t, n, s) {
  let r = [];
  if (s > 1) {
    const o = e[2] - e[0], l = e[3] - e[1];
    for (let f = 0; f < s; ++f)
      r.push(
        e[0] + o * f / s,
        e[1],
        e[2],
        e[1] + l * f / s,
        e[2] - o * f / s,
        e[3],
        e[0],
        e[3] - l * f / s
      );
  } else
    r = [
      e[0],
      e[1],
      e[2],
      e[1],
      e[2],
      e[3],
      e[0],
      e[3]
    ];
  t(r, r, 2);
  const i = [], a = [];
  for (let o = 0, l = r.length; o < l; o += 2)
    i.push(r[o]), a.push(r[o + 1]);
  return mD(i, a, n);
}
function r1(e, t) {
  const n = t.getExtent(), s = $i(e);
  if (t.canWrapX() && (s[0] < n[0] || s[0] >= n[2])) {
    const r = Ee(n), a = Math.floor(
      (s[0] - n[0]) / r
    ) * r;
    e[0] -= a, e[2] -= a;
  }
  return e;
}
function xD(e, t) {
  if (t.canWrapX()) {
    const n = t.getExtent();
    if (!isFinite(e[0]) || !isFinite(e[2]))
      return [[n[0], e[1], n[2], e[3]]];
    r1(e, t);
    const s = Ee(n);
    if (Ee(e) > s)
      return [[n[0], e[1], n[2], e[3]]];
    if (e[0] < n[0])
      return [
        [e[0] + s, e[1], n[2], e[3]],
        [n[0], e[1], e[2], e[3]]
      ];
    if (e[2] > n[2])
      return [
        [e[0], e[1], n[2], e[3]],
        [n[0], e[1], e[2] - s, e[3]]
      ];
  }
  return [e];
}
const ql = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let bD = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(t) {
    this.code_ = t.code, this.units_ = /** @type {import("./Units.js").Units} */
    t.units, this.extent_ = t.extent !== void 0 ? t.extent : null, this.worldExtent_ = t.worldExtent !== void 0 ? t.worldExtent : null, this.axisOrientation_ = t.axisOrientation !== void 0 ? t.axisOrientation : "enu", this.global_ = t.global !== void 0 ? t.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = t.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = t.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || ql[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(t) {
    this.global_ = t, this.canWrapX_ = !!(t && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(t) {
    this.defaultTileGrid_ = t;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(t) {
    this.extent_ = t, this.canWrapX_ = !!(this.global_ && t);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(t) {
    this.worldExtent_ = t;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(t) {
    this.getPointResolutionFunc_ = t;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const Af = bD, Uc = 6378137, Pl = Math.PI * Uc, TD = [-Pl, -Pl, Pl, Pl], OD = [-180, -85, 180, 85], gh = Uc * Math.log(Math.tan(Math.PI / 2));
class ol extends Af {
  /**
   * @param {string} code Code.
   */
  constructor(t) {
    super({
      code: t,
      units: "m",
      extent: TD,
      global: !0,
      worldExtent: OD,
      getPointResolution: function(n, s) {
        return n / Math.cosh(s[1] / Uc);
      }
    });
  }
}
const NE = [
  new ol("EPSG:3857"),
  new ol("EPSG:102100"),
  new ol("EPSG:102113"),
  new ol("EPSG:900913"),
  new ol("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new ol("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function PD(e, t, n) {
  const s = e.length;
  n = n > 1 ? n : 2, t === void 0 && (n > 2 ? t = e.slice() : t = new Array(s));
  for (let r = 0; r < s; r += n) {
    t[r] = Pl * e[r] / 180;
    let i = Uc * Math.log(Math.tan(Math.PI * (+e[r + 1] + 90) / 360));
    i > gh ? i = gh : i < -gh && (i = -gh), t[r + 1] = i;
  }
  return t;
}
function SD(e, t, n) {
  const s = e.length;
  n = n > 1 ? n : 2, t === void 0 && (n > 2 ? t = e.slice() : t = new Array(s));
  for (let r = 0; r < s; r += n)
    t[r] = 180 * e[r] / Pl, t[r + 1] = 360 * Math.atan(Math.exp(e[r + 1] / Uc)) / Math.PI - 90;
  return t;
}
const MD = 6378137, jE = [-180, -90, 180, 90], _D = Math.PI * MD / 180;
class co extends Af {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(t, n) {
    super({
      code: t,
      units: "degrees",
      extent: jE,
      axisOrientation: n,
      global: !0,
      metersPerUnit: _D,
      worldExtent: jE
    });
  }
}
const $E = [
  new co("CRS:84"),
  new co("EPSG:4326", "neu"),
  new co("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new co("urn:ogc:def:crs:OGC:2:84"),
  new co("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new co("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new co("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let wg = {};
function ID(e) {
  return wg[e] || wg[e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function DD(e, t) {
  wg[e] = t;
}
let Ul = {};
function tu(e, t, n) {
  const s = e.getCode(), r = t.getCode();
  s in Ul || (Ul[s] = {}), Ul[s][r] = n;
}
function s1(e, t) {
  let n;
  return e in Ul && t in Ul[e] && (n = Ul[e][t]), n;
}
function dn(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function AD(e, t, n, s, r, i) {
  const a = r - n, o = i - s;
  if (a !== 0 || o !== 0) {
    const l = ((e - n) * a + (t - s) * o) / (a * a + o * o);
    l > 1 ? (n = r, s = i) : l > 0 && (n += a * l, s += o * l);
  }
  return Xs(e, t, n, s);
}
function Xs(e, t, n, s) {
  const r = n - e, i = s - t;
  return r * r + i * i;
}
function LD(e) {
  const t = e.length;
  for (let s = 0; s < t; s++) {
    let r = s, i = Math.abs(e[s][s]);
    for (let o = s + 1; o < t; o++) {
      const l = Math.abs(e[o][s]);
      l > i && (i = l, r = o);
    }
    if (i === 0)
      return null;
    const a = e[r];
    e[r] = e[s], e[s] = a;
    for (let o = s + 1; o < t; o++) {
      const l = -e[o][s] / e[s][s];
      for (let f = s; f < t + 1; f++)
        s == f ? e[o][f] = 0 : e[o][f] += l * e[s][f];
    }
  }
  const n = new Array(t);
  for (let s = t - 1; s >= 0; s--) {
    n[s] = e[s][t] / e[s][s];
    for (let r = s - 1; r >= 0; r--)
      e[r][t] -= e[r][s] * n[s];
  }
  return n;
}
function UE(e) {
  return e * 180 / Math.PI;
}
function _o(e) {
  return e * Math.PI / 180;
}
function Va(e, t) {
  const n = e % t;
  return n * t < 0 ? n + t : n;
}
function Us(e, t, n) {
  return e + n * (t - e);
}
function Lf(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
function WE(e, t) {
  return Math.round(Lf(e, t));
}
function Sl(e, t) {
  return Math.floor(Lf(e, t));
}
function Ma(e, t) {
  return Math.ceil(Lf(e, t));
}
function a1(e, t) {
  const n = ("" + e).split("."), s = ("" + t).split(".");
  for (let r = 0; r < Math.max(n.length, s.length); r++) {
    const i = parseInt(n[r] || "0", 10), a = parseInt(s[r] || "0", 10);
    if (i > a)
      return 1;
    if (a > i)
      return -1;
  }
  return 0;
}
function o1(e, t) {
  return e[0] += +t[0], e[1] += +t[1], e;
}
function Ed(e, t) {
  let n = !0;
  for (let s = e.length - 1; s >= 0; --s)
    if (e[s] != t[s]) {
      n = !1;
      break;
    }
  return n;
}
function ay(e, t) {
  const n = Math.cos(t), s = Math.sin(t), r = e[0] * n - e[1] * s, i = e[1] * n + e[0] * s;
  return e[0] = r, e[1] = i, e;
}
function l1(e, t) {
  return e[0] *= t, e[1] *= t, e;
}
function u1(e, t) {
  const n = e[0] - t[0], s = e[1] - t[1];
  return n * n + s * s;
}
function c1(e, t) {
  return Math.sqrt(u1(e, t));
}
function oy(e, t) {
  if (t.canWrapX()) {
    const n = Ee(t.getExtent()), s = h1(e, t, n);
    s && (e[0] -= s * n);
  }
  return e;
}
function h1(e, t, n) {
  const s = t.getExtent();
  let r = 0;
  return t.canWrapX() && (e[0] < s[0] || e[0] > s[2]) && (n = n || Ee(s), r = Math.floor(
    (e[0] - s[0]) / n
  )), r;
}
const d1 = 63710088e-1;
function zE(e, t, n) {
  n = n || d1;
  const s = _o(e[1]), r = _o(t[1]), i = (r - s) / 2, a = _o(t[0] - e[0]) / 2, o = Math.sin(i) * Math.sin(i) + Math.sin(a) * Math.sin(a) * Math.cos(s) * Math.cos(r);
  return 2 * n * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o));
}
function RD(e, t, n, s) {
  s = s || d1;
  const r = _o(e[1]), i = _o(e[0]), a = t / s, o = Math.asin(
    Math.sin(r) * Math.cos(a) + Math.cos(r) * Math.sin(a) * Math.cos(n)
  ), l = i + Math.atan2(
    Math.sin(n) * Math.sin(a) * Math.cos(r),
    Math.cos(a) - Math.sin(r) * Math.sin(o)
  );
  return [UE(l), UE(o)];
}
let Vg = !0;
function wD(e) {
  Vg = !(e === void 0 ? !0 : e);
}
function ly(e, t, n) {
  if (t !== void 0) {
    for (let s = 0, r = e.length; s < r; ++s)
      t[s] = e[s];
    t = t;
  } else
    t = e.slice();
  return t;
}
function uy(e, t, n) {
  if (t !== void 0 && e !== t) {
    for (let s = 0, r = e.length; s < r; ++s)
      t[s] = e[s];
    e = t;
  }
  return e;
}
function cy(e) {
  DD(e.getCode(), e), tu(e, e, ly);
}
function VD(e) {
  e.forEach(cy);
}
function Wt(e) {
  return typeof e == "string" ? ID(
    /** @type {string} */
    e
  ) : (
    /** @type {Projection} */
    e || null
  );
}
function KE(e, t, n, s) {
  e = Wt(e);
  let r;
  const i = e.getPointResolutionFunc();
  if (i) {
    if (r = i(t, n), s && s !== e.getUnits()) {
      const a = e.getMetersPerUnit();
      a && (r = r * a / ql[s]);
    }
  } else {
    const a = e.getUnits();
    if (a == "degrees" && !s || s == "degrees")
      r = t;
    else {
      const o = Rf(
        e,
        Wt("EPSG:4326")
      );
      if (o === uy && a !== "degrees")
        r = t * e.getMetersPerUnit();
      else {
        let f = [
          n[0] - t / 2,
          n[1],
          n[0] + t / 2,
          n[1],
          n[0],
          n[1] - t / 2,
          n[0],
          n[1] + t / 2
        ];
        f = o(f, f, 2);
        const d = zE(f.slice(0, 2), f.slice(2, 4)), u = zE(f.slice(4, 6), f.slice(6, 8));
        r = (d + u) / 2;
      }
      const l = s ? ql[s] : e.getMetersPerUnit();
      l !== void 0 && (r /= l);
    }
  }
  return r;
}
function Bg(e) {
  VD(e), e.forEach(function(t) {
    e.forEach(function(n) {
      t !== n && tu(t, n, ly);
    });
  });
}
function BD(e, t, n, s) {
  e.forEach(function(r) {
    t.forEach(function(i) {
      tu(r, i, n), tu(i, r, s);
    });
  });
}
function hy(e, t) {
  return e ? typeof e == "string" ? Wt(e) : (
    /** @type {Projection} */
    e
  ) : Wt(t);
}
function GE(e) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(t, n, s) {
      const r = t.length;
      s = s !== void 0 ? s : 2, n = n !== void 0 ? n : new Array(r);
      for (let i = 0; i < r; i += s) {
        const a = e(t.slice(i, i + s)), o = a.length;
        for (let l = 0, f = s; l < f; ++l)
          n[i + l] = l >= o ? t[i + l] : a[l];
      }
      return n;
    }
  );
}
function FD(e, t, n, s) {
  const r = Wt(e), i = Wt(t);
  tu(
    r,
    i,
    GE(n)
  ), tu(
    i,
    r,
    GE(s)
  );
}
function ND(e, t) {
  const n = Ui(
    e,
    t !== void 0 ? t : "EPSG:3857",
    "EPSG:4326"
  ), s = n[0];
  return (s < -180 || s > 180) && (n[0] = Va(s + 180, 360) - 180), n;
}
function mr(e, t) {
  if (e === t)
    return !0;
  const n = e.getUnits() === t.getUnits();
  return (e.getCode() === t.getCode() || Rf(e, t) === ly) && n;
}
function Rf(e, t) {
  const n = e.getCode(), s = t.getCode();
  let r = s1(n, s);
  return r || (r = uy), r;
}
function Ka(e, t) {
  const n = Wt(e), s = Wt(t);
  return Rf(n, s);
}
function Ui(e, t, n) {
  return Ka(t, n)(e, void 0, e.length);
}
function Wc(e, t, n, s) {
  const r = Ka(t, n);
  return CD(e, r, void 0, s);
}
function Fg(e, t) {
  return e;
}
function Ar(e, t) {
  return Vg && !Ed(e, [0, 0]) && e[0] >= -180 && e[0] <= 180 && e[1] >= -90 && e[1] <= 90 && (Vg = !1, console.warn(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), e;
}
function f1(e, t) {
  return e;
}
function Ks(e, t) {
  return e;
}
function kE(e, t, n) {
  return function(s) {
    let r, i;
    if (e.canWrapX()) {
      const a = e.getExtent(), o = Ee(a);
      s = s.slice(0), i = h1(s, e, o), i && (s[0] = s[0] - i * o), s[0] = dn(s[0], a[0], a[2]), s[1] = dn(s[1], a[1], a[3]), r = n(s);
    } else
      r = n(s);
    return i && t.canWrapX() && (r[0] += i * Ee(t.getExtent())), r;
  };
}
function jD() {
  Bg(NE), Bg($E), BD(
    $E,
    NE,
    PD,
    SD
  );
}
jD();
function Ba(e, t, n, s, r, i) {
  i = i || [];
  let a = 0;
  for (let o = t; o < n; o += s) {
    const l = e[o], f = e[o + 1];
    i[a++] = r[0] * l + r[2] * f + r[4], i[a++] = r[1] * l + r[3] * f + r[5];
  }
  return i && i.length != a && (i.length = a), i;
}
function dy(e, t, n, s, r, i, a) {
  a = a || [];
  const o = Math.cos(r), l = Math.sin(r), f = i[0], d = i[1];
  let u = 0;
  for (let c = t; c < n; c += s) {
    const h = e[c] - f, p = e[c + 1] - d;
    a[u++] = f + h * o - p * l, a[u++] = d + h * l + p * o;
    for (let g = c + 2; g < c + s; ++g)
      a[u++] = e[g];
  }
  return a && a.length != u && (a.length = u), a;
}
function $D(e, t, n, s, r, i, a, o) {
  o = o || [];
  const l = a[0], f = a[1];
  let d = 0;
  for (let u = t; u < n; u += s) {
    const c = e[u] - l, h = e[u + 1] - f;
    o[d++] = l + r * c, o[d++] = f + i * h;
    for (let p = u + 2; p < u + s; ++p)
      o[d++] = e[p];
  }
  return o && o.length != d && (o.length = d), o;
}
function p1(e, t, n, s, r, i, a) {
  a = a || [];
  let o = 0;
  for (let l = t; l < n; l += s) {
    a[o++] = e[l] + r, a[o++] = e[l + 1] + i;
    for (let f = l + 2; f < l + s; ++f)
      a[o++] = e[f];
  }
  return a && a.length != o && (a.length = o), a;
}
const HE = tr();
class UD extends xr {
  constructor() {
    super(), this.extent_ = ji(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = tD(function(t, n, s) {
      if (!s)
        return this.getSimplifiedGeometry(n);
      const r = this.clone();
      return r.applyTransform(s), r.getSimplifiedGeometry(n);
    });
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(t, n) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      t,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Gt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return Gt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.getClosestPoint([t, n]);
    return s[0] === t && s[1] === n;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(t, n) {
    return n = n || [NaN, NaN], this.closestPointXY(t[0], t[1], n, 1 / 0), n;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(t) {
    return this.containsXY(t[0], t[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return Gt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(t) {
    if (this.extentRevision_ != this.getRevision()) {
      const n = this.computeExtent(this.extent_);
      (isNaN(n[0]) || isNaN(n[1])) && $c(n), this.extentRevision_ = this.getRevision();
    }
    return yD(this.extent_, t);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    Gt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    Gt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(t) {
    return this.getSimplifiedGeometry(t * t);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return Gt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Gt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(t) {
    Gt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(t) {
    return Gt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    Gt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(t, n) {
    const s = Wt(t), r = s.getUnits() == "tile-pixels" ? function(i, a, o) {
      const l = s.getExtent(), f = s.getWorldExtent(), d = In(f) / In(l);
      return $r(
        HE,
        f[0],
        f[3],
        d,
        -d,
        0,
        0,
        0
      ), Ba(
        i,
        0,
        i.length,
        o,
        HE,
        a
      ), Ka(s, n)(
        i,
        a,
        o
      );
    } : Ka(s, n);
    return this.applyTransform(r), this;
  }
}
const Cd = UD;
class WD extends Cd {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return ry(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Gt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const n = this.getSimplifiedGeometryInternal(t);
    return n.getFlatCoordinates().length < this.flatCoordinates.length ? n : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(t, n) {
    this.stride = xd(t), this.layout = t, this.flatCoordinates = n;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(t, n) {
    Gt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(t, n, s) {
    let r;
    if (t)
      r = xd(t);
    else {
      for (let i = 0; i < s; ++i)
        if (n.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        } else
          n = /** @type {Array} */
          n[0];
      r = n.length, t = zD(r);
    }
    this.layout = t, this.stride = r;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.getFlatCoordinates();
    if (s) {
      const r = this.getStride();
      dy(
        s,
        0,
        s.length,
        r,
        t,
        n,
        s
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    n === void 0 && (n = t), s || (s = $i(this.getExtent()));
    const r = this.getFlatCoordinates();
    if (r) {
      const i = this.getStride();
      $D(
        r,
        0,
        r.length,
        i,
        t,
        n,
        s,
        r
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.getFlatCoordinates();
    if (s) {
      const r = this.getStride();
      p1(
        s,
        0,
        s.length,
        r,
        t,
        n,
        s
      ), this.changed();
    }
  }
}
function zD(e) {
  let t;
  return e == 2 ? t = "XY" : e == 3 ? t = "XYZ" : e == 4 && (t = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  t;
}
function xd(e) {
  let t;
  return e == "XY" ? t = 2 : e == "XYZ" || e == "XYM" ? t = 3 : e == "XYZM" && (t = 4), /** @type {number} */
  t;
}
function KD(e, t, n) {
  const s = e.getFlatCoordinates();
  if (s) {
    const r = e.getStride();
    return Ba(
      s,
      0,
      s.length,
      r,
      t,
      n
    );
  } else
    return null;
}
const oa = WD;
function YE(e, t, n, s, r, i, a) {
  const o = e[t], l = e[t + 1], f = e[n] - o, d = e[n + 1] - l;
  let u;
  if (f === 0 && d === 0)
    u = t;
  else {
    const c = ((r - o) * f + (i - l) * d) / (f * f + d * d);
    if (c > 1)
      u = n;
    else if (c > 0) {
      for (let h = 0; h < s; ++h)
        a[h] = Us(
          e[t + h],
          e[n + h],
          c
        );
      a.length = s;
      return;
    } else
      u = t;
  }
  for (let c = 0; c < s; ++c)
    a[c] = e[u + c];
  a.length = s;
}
function fy(e, t, n, s, r) {
  let i = e[t], a = e[t + 1];
  for (t += s; t < n; t += s) {
    const o = e[t], l = e[t + 1], f = Xs(i, a, o, l);
    f > r && (r = f), i = o, a = l;
  }
  return r;
}
function py(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r = fy(e, t, o, s, r), t = o;
  }
  return r;
}
function GD(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r = py(e, t, o, s, r), t = o[o.length - 1];
  }
  return r;
}
function my(e, t, n, s, r, i, a, o, l, f, d) {
  if (t == n)
    return f;
  let u, c;
  if (r === 0)
    if (c = Xs(
      a,
      o,
      e[t],
      e[t + 1]
    ), c < f) {
      for (u = 0; u < s; ++u)
        l[u] = e[t + u];
      return l.length = s, c;
    } else
      return f;
  d = d || [NaN, NaN];
  let h = t + s;
  for (; h < n; )
    if (YE(
      e,
      h - s,
      h,
      s,
      a,
      o,
      d
    ), c = Xs(a, o, d[0], d[1]), c < f) {
      for (f = c, u = 0; u < s; ++u)
        l[u] = d[u];
      l.length = s, h += s;
    } else
      h += s * Math.max(
        (Math.sqrt(c) - Math.sqrt(f)) / r | 0,
        1
      );
  if (i && (YE(
    e,
    n - s,
    t,
    s,
    a,
    o,
    d
  ), c = Xs(a, o, d[0], d[1]), c < f)) {
    for (f = c, u = 0; u < s; ++u)
      l[u] = d[u];
    l.length = s;
  }
  return f;
}
function gy(e, t, n, s, r, i, a, o, l, f, d) {
  d = d || [NaN, NaN];
  for (let u = 0, c = n.length; u < c; ++u) {
    const h = n[u];
    f = my(
      e,
      t,
      h,
      s,
      r,
      i,
      a,
      o,
      l,
      f,
      d
    ), t = h;
  }
  return f;
}
function kD(e, t, n, s, r, i, a, o, l, f, d) {
  d = d || [NaN, NaN];
  for (let u = 0, c = n.length; u < c; ++u) {
    const h = n[u];
    f = gy(
      e,
      t,
      h,
      s,
      r,
      i,
      a,
      o,
      l,
      f,
      d
    ), t = h[h.length - 1];
  }
  return f;
}
function m1(e, t, n, s) {
  for (let r = 0, i = n.length; r < i; ++r)
    e[t++] = n[r];
  return t;
}
function wf(e, t, n, s) {
  for (let r = 0, i = n.length; r < i; ++r) {
    const a = n[r];
    for (let o = 0; o < s; ++o)
      e[t++] = a[o];
  }
  return t;
}
function vy(e, t, n, s, r) {
  r = r || [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = wf(
      e,
      t,
      n[a],
      s
    );
    r[i++] = l, t = l;
  }
  return r.length = i, r;
}
function HD(e, t, n, s, r) {
  r = r || [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = vy(
      e,
      t,
      n[a],
      s,
      r[i]
    );
    l.length === 0 && (l[0] = t), r[i++] = l, t = l[l.length - 1];
  }
  return r.length = i, r;
}
function yy(e, t, n, s, r, i, a) {
  const o = (n - t) / s;
  if (o < 3) {
    for (; t < n; t += s)
      i[a++] = e[t], i[a++] = e[t + 1];
    return a;
  }
  const l = new Array(o);
  l[0] = 1, l[o - 1] = 1;
  const f = [t, n - s];
  let d = 0;
  for (; f.length > 0; ) {
    const u = f.pop(), c = f.pop();
    let h = 0;
    const p = e[c], g = e[c + 1], m = e[u], v = e[u + 1];
    for (let y = c + s; y < u; y += s) {
      const E = e[y], C = e[y + 1], x = AD(E, C, p, g, m, v);
      x > h && (d = y, h = x);
    }
    h > r && (l[(d - t) / s] = 1, c + s < d && f.push(c, d), d + s < u && f.push(d, u));
  }
  for (let u = 0; u < o; ++u)
    l[u] && (i[a++] = e[t + u * s], i[a++] = e[t + u * s + 1]);
  return a;
}
function YD(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    a = yy(
      e,
      t,
      d,
      s,
      r,
      i,
      a
    ), o.push(a), t = d;
  }
  return a;
}
function Eo(e, t) {
  return t * Math.round(e / t);
}
function XD(e, t, n, s, r, i, a) {
  if (t == n)
    return a;
  let o = Eo(e[t], r), l = Eo(e[t + 1], r);
  t += s, i[a++] = o, i[a++] = l;
  let f, d;
  do
    if (f = Eo(e[t], r), d = Eo(e[t + 1], r), t += s, t == n)
      return i[a++] = f, i[a++] = d, a;
  while (f == o && d == l);
  for (; t < n; ) {
    const u = Eo(e[t], r), c = Eo(e[t + 1], r);
    if (t += s, u == f && c == d)
      continue;
    const h = f - o, p = d - l, g = u - o, m = c - l;
    if (h * m == p * g && (h < 0 && g < h || h == g || h > 0 && g > h) && (p < 0 && m < p || p == m || p > 0 && m > p)) {
      f = u, d = c;
      continue;
    }
    i[a++] = f, i[a++] = d, o = f, l = d, f = u, d = c;
  }
  return i[a++] = f, i[a++] = d, a;
}
function g1(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    a = XD(
      e,
      t,
      d,
      s,
      r,
      i,
      a
    ), o.push(a), t = d;
  }
  return a;
}
function ZD(e, t, n, s, r, i, a, o) {
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l], u = [];
    a = g1(
      e,
      t,
      d,
      s,
      r,
      i,
      a,
      u
    ), o.push(u), t = d[d.length - 1];
  }
  return a;
}
function _a(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = t; a < n; a += s)
    r[i++] = e.slice(a, a + s);
  return r.length = i, r;
}
function uc(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    r[i++] = _a(
      e,
      t,
      l,
      s,
      r[i]
    ), t = l;
  }
  return r.length = i, r;
}
function Ng(e, t, n, s, r) {
  r = r !== void 0 ? r : [];
  let i = 0;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    r[i++] = l.length === 1 && l[0] === t ? [] : uc(
      e,
      t,
      l,
      s,
      r[i]
    ), t = l[l.length - 1];
  }
  return r.length = i, r;
}
function v1(e, t, n, s) {
  let r = 0, i = e[n - s], a = e[n - s + 1];
  for (; t < n; t += s) {
    const o = e[t], l = e[t + 1];
    r += a * o - i * l, i = o, a = l;
  }
  return r / 2;
}
function y1(e, t, n, s) {
  let r = 0;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r += v1(e, t, o, s), t = o;
  }
  return r;
}
function JD(e, t, n, s) {
  let r = 0;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    r += y1(e, t, o, s), t = o[o.length - 1];
  }
  return r;
}
class bd extends oa {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new bd(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Qo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      fy(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), my(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return v1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return _a(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [];
    return n.length = yy(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      0
    ), new bd(n, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = wf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const Td = bd;
let QD = class E1 extends oa {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.setCoordinates(t, n);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const t = new E1(this.flatCoordinates.slice(), this.layout);
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    const i = this.flatCoordinates, a = Xs(
      t,
      n,
      i[0],
      i[1]
    );
    if (a < r) {
      const o = this.stride;
      for (let l = 0; l < o; ++l)
        s[l] = i[l];
      return s.length = o, a;
    } else
      return r;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates ? this.flatCoordinates.slice() : [];
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    return iy(this.flatCoordinates, t);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return ny(t, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = m1(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
};
const hi = QD;
function qD(e, t, n, s, r) {
  return !sy(
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(a) {
      return !Co(
        e,
        t,
        n,
        s,
        a[0],
        a[1]
      );
    }
  );
}
function Co(e, t, n, s, r, i) {
  let a = 0, o = e[n - s], l = e[n - s + 1];
  for (; t < n; t += s) {
    const f = e[t], d = e[t + 1];
    l <= i ? d > i && (f - o) * (i - l) - (r - o) * (d - l) > 0 && a++ : d <= i && (f - o) * (i - l) - (r - o) * (d - l) < 0 && a--, o = f, l = d;
  }
  return a !== 0;
}
function Ey(e, t, n, s, r, i) {
  if (n.length === 0 || !Co(e, t, n[0], s, r, i))
    return !1;
  for (let a = 1, o = n.length; a < o; ++a)
    if (Co(e, n[a - 1], n[a], s, r, i))
      return !1;
  return !0;
}
function tA(e, t, n, s, r, i) {
  if (n.length === 0)
    return !1;
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    if (Ey(e, t, l, s, r, i))
      return !0;
    t = l[l.length - 1];
  }
  return !1;
}
function Cy(e, t, n, s, r, i, a) {
  let o, l, f, d, u, c, h;
  const p = r[i + 1], g = [];
  for (let y = 0, E = n.length; y < E; ++y) {
    const C = n[y];
    for (d = e[C - s], c = e[C - s + 1], o = t; o < C; o += s)
      u = e[o], h = e[o + 1], (p <= c && h <= p || c <= p && p <= h) && (f = (p - c) / (h - c) * (u - d) + d, g.push(f)), d = u, c = h;
  }
  let m = NaN, v = -1 / 0;
  for (g.sort(wo), d = g[0], o = 1, l = g.length; o < l; ++o) {
    u = g[o];
    const y = Math.abs(u - d);
    y > v && (f = (d + u) / 2, Ey(e, t, n, s, f, p) && (m = f, v = y)), d = u;
  }
  return isNaN(m) && (m = r[i]), a ? (a.push(m, p, v), a) : [m, p, v];
}
function C1(e, t, n, s, r) {
  let i = [];
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    i = Cy(
      e,
      t,
      l,
      s,
      r,
      2 * a,
      i
    ), t = l[l.length - 1];
  }
  return i;
}
function x1(e, t, n, s, r) {
  let i;
  for (t += s; t < n; t += s)
    if (i = r(
      e.slice(t - s, t),
      e.slice(t, t + s)
    ), i)
      return i;
  return !1;
}
function Vf(e, t, n, s, r) {
  const i = i1(
    ji(),
    e,
    t,
    n,
    s
  );
  return hn(r, i) ? Rr(r, i) || i[0] >= r[0] && i[2] <= r[2] || i[1] >= r[1] && i[3] <= r[3] ? !0 : x1(
    e,
    t,
    n,
    s,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(a, o) {
      return ED(r, a, o);
    }
  ) : !1;
}
function eA(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    if (Vf(e, t, n[i], s, r))
      return !0;
    t = n[i];
  }
  return !1;
}
function b1(e, t, n, s, r) {
  return !!(Vf(e, t, n, s, r) || Co(
    e,
    t,
    n,
    s,
    r[0],
    r[1]
  ) || Co(
    e,
    t,
    n,
    s,
    r[0],
    r[3]
  ) || Co(
    e,
    t,
    n,
    s,
    r[2],
    r[1]
  ) || Co(
    e,
    t,
    n,
    s,
    r[2],
    r[3]
  ));
}
function T1(e, t, n, s, r) {
  if (!b1(e, t, n[0], s, r))
    return !1;
  if (n.length === 1)
    return !0;
  for (let i = 1, a = n.length; i < a; ++i)
    if (qD(
      e,
      n[i - 1],
      n[i],
      s,
      r
    ) && !Vf(
      e,
      n[i - 1],
      n[i],
      s,
      r
    ))
      return !1;
  return !0;
}
function nA(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    if (T1(e, t, o, s, r))
      return !0;
    t = o[o.length - 1];
  }
  return !1;
}
function iA(e, t, n, s) {
  for (; t < n - s; ) {
    for (let r = 0; r < s; ++r) {
      const i = e[t + r];
      e[t + r] = e[n - s + r], e[n - s + r] = i;
    }
    t += s, n -= s;
  }
}
function xy(e, t, n, s) {
  let r = 0, i = e[n - s], a = e[n - s + 1];
  for (; t < n; t += s) {
    const o = e[t], l = e[t + 1];
    r += (o - i) * (l + a), i = o, a = l;
  }
  return r === 0 ? void 0 : r > 0;
}
function O1(e, t, n, s, r) {
  r = r !== void 0 ? r : !1;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i], l = xy(
      e,
      t,
      o,
      s
    );
    if (i === 0) {
      if (r && l || !r && !l)
        return !1;
    } else if (r && !l || !r && l)
      return !1;
    t = o;
  }
  return !0;
}
function rA(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i];
    if (!O1(e, t, o, s, r))
      return !1;
    o.length && (t = o[o.length - 1]);
  }
  return !0;
}
function jg(e, t, n, s, r) {
  r = r !== void 0 ? r : !1;
  for (let i = 0, a = n.length; i < a; ++i) {
    const o = n[i], l = xy(
      e,
      t,
      o,
      s
    );
    (i === 0 ? r && l || !r && !l : r && !l || !r && l) && iA(e, t, o, s), t = o;
  }
  return t;
}
function XE(e, t, n, s, r) {
  for (let i = 0, a = n.length; i < a; ++i)
    t = jg(
      e,
      t,
      n[i],
      s,
      r
    );
  return t;
}
function sA(e, t) {
  const n = [];
  let s = 0, r = 0;
  for (let i = 0, a = t.length; i < a; ++i) {
    const o = t[i];
    if (!xy(e, s, o, 2))
      n.push(t.slice(r, i + 1));
    else {
      if (n.length === 0)
        continue;
      n[n.length - 1].push(t[r]);
    }
    r = i + 1, s = o;
  }
  return n;
}
class eu extends oa {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(t, n, s) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, n !== void 0 && s ? (this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ), this.ends_ = s) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      t,
      n
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const t = new eu(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Qo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      py(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), gy(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    return Ey(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t,
      n
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return y1(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let n;
    return t !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), jg(n, 0, this.ends_, this.stride, t)) : n = this.flatCoordinates, uc(n, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const t = $i(this.getExtent());
      this.flatInteriorPoint_ = Cy(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new hi(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(t) {
    return t < 0 || this.ends_.length <= t ? null : new Td(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const t = this.layout, n = this.flatCoordinates, s = this.ends_, r = [];
    let i = 0;
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a], f = new Td(
        n.slice(i, l),
        t
      );
      r.push(f), i = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      O1(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = jg(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = g1(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(t),
      n,
      0,
      s
    ), new eu(n, "XY", s);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return T1(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const s = vy(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1], this.changed();
  }
}
const rr = eu;
function P1(e, t, n, s) {
  n = n || 32;
  const r = [];
  for (let i = 0; i < n; ++i)
    Kn(
      r,
      RD(e, t, 2 * Math.PI * i / n, s)
    );
  return r.push(r[0], r[1]), new eu(r, "XY", [r.length]);
}
function ZE(e) {
  const t = e[0], n = e[1], s = e[2], r = e[3], i = [
    t,
    n,
    t,
    r,
    s,
    r,
    s,
    n,
    t,
    n
  ];
  return new eu(i, "XY", [i.length]);
}
const ln = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
};
class aA extends Wi {
  /**
   * @param {GeolocationPositionError} error error object.
   */
  constructor(t) {
    super(Kt.ERROR), this.code = t.code, this.message = t.message;
  }
}
class oA extends xr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.position_ = null, this.transform_ = uy, this.watchId_ = void 0, this.addChangeListener(ln.PROJECTION, this.handleProjectionChanged_), this.addChangeListener(ln.TRACKING, this.handleTrackingChanged_), t.projection !== void 0 && this.setProjection(t.projection), t.trackingOptions !== void 0 && this.setTrackingOptions(t.trackingOptions), this.setTracking(t.tracking !== void 0 ? t.tracking : !1);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setTracking(!1), super.disposeInternal();
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    const t = this.getProjection();
    t && (this.transform_ = Rf(
      Wt("EPSG:4326"),
      t
    ), this.position_ && this.set(ln.POSITION, this.transform_(this.position_)));
  }
  /**
   * @private
   */
  handleTrackingChanged_() {
    if ("geolocation" in navigator) {
      const t = this.getTracking();
      t && this.watchId_ === void 0 ? this.watchId_ = navigator.geolocation.watchPosition(
        this.positionChange_.bind(this),
        this.positionError_.bind(this),
        this.getTrackingOptions()
      ) : !t && this.watchId_ !== void 0 && (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0);
    }
  }
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */
  positionChange_(t) {
    const n = t.coords;
    this.set(ln.ACCURACY, n.accuracy), this.set(
      ln.ALTITUDE,
      n.altitude === null ? void 0 : n.altitude
    ), this.set(
      ln.ALTITUDE_ACCURACY,
      n.altitudeAccuracy === null ? void 0 : n.altitudeAccuracy
    ), this.set(
      ln.HEADING,
      n.heading === null ? void 0 : _o(n.heading)
    ), this.position_ ? (this.position_[0] = n.longitude, this.position_[1] = n.latitude) : this.position_ = [n.longitude, n.latitude];
    const s = this.transform_(this.position_);
    this.set(ln.POSITION, s), this.set(ln.SPEED, n.speed === null ? void 0 : n.speed);
    const r = P1(this.position_, n.accuracy);
    r.applyTransform(this.transform_), this.set(ln.ACCURACY_GEOMETRY, r), this.changed();
  }
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */
  positionError_(t) {
    this.dispatchEvent(new aA(t));
  }
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */
  getAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(ln.ACCURACY)
    );
  }
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */
  getAccuracyGeometry() {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(ln.ACCURACY_GEOMETRY) || null
    );
  }
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */
  getAltitude() {
    return (
      /** @type {number|undefined} */
      this.get(ln.ALTITUDE)
    );
  }
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */
  getAltitudeAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(ln.ALTITUDE_ACCURACY)
    );
  }
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */
  getHeading() {
    return (
      /** @type {number|undefined} */
      this.get(ln.HEADING)
    );
  }
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ln.POSITION)
    );
  }
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(ln.PROJECTION)
    );
  }
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */
  getSpeed() {
    return (
      /** @type {number|undefined} */
      this.get(ln.SPEED)
    );
  }
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */
  getTracking() {
    return (
      /** @type {boolean} */
      this.get(ln.TRACKING)
    );
  }
  /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  getTrackingOptions() {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(ln.TRACKING_OPTIONS)
    );
  }
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  setProjection(t) {
    this.set(ln.PROJECTION, Wt(t));
  }
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */
  setTracking(t) {
    this.set(ln.TRACKING, t);
  }
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  setTrackingOptions(t) {
    this.set(ln.TRACKING_OPTIONS, t);
  }
}
const lA = oA, Fa = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};
class by {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new by({
      color: Array.isArray(t) ? t.slice() : t || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
}
const wr = by;
function Od(e, t, n, s, r, i, a) {
  let o, l;
  const f = (n - t) / s;
  if (f === 1)
    o = t;
  else if (f === 2)
    o = t, l = r;
  else if (f !== 0) {
    let d = e[t], u = e[t + 1], c = 0;
    const h = [0];
    for (let m = t + s; m < n; m += s) {
      const v = e[m], y = e[m + 1];
      c += Math.sqrt((v - d) * (v - d) + (y - u) * (y - u)), h.push(c), d = v, u = y;
    }
    const p = r * c, g = ZI(h, p);
    g < 0 ? (l = (p - h[-g - 2]) / (h[-g - 1] - h[-g - 2]), o = t + (-g - 2) * s) : o = t + g * s;
  }
  a = a > 1 ? a : 2, i = i || new Array(a);
  for (let d = 0; d < a; ++d)
    i[d] = o === void 0 ? NaN : l === void 0 ? e[o + d] : Us(e[o + d], e[o + s + d], l);
  return i;
}
function $g(e, t, n, s, r, i) {
  if (n == t)
    return null;
  let a;
  if (r < e[t + s - 1])
    return i ? (a = e.slice(t, t + s), a[s - 1] = r, a) : null;
  if (e[n - 1] < r)
    return i ? (a = e.slice(n - s, n), a[s - 1] = r, a) : null;
  if (r == e[t + s - 1])
    return e.slice(t, t + s);
  let o = t / s, l = n / s;
  for (; o < l; ) {
    const c = o + l >> 1;
    r < e[(c + 1) * s - 1] ? l = c : o = c + 1;
  }
  const f = e[o * s - 1];
  if (r == f)
    return e.slice((o - 1) * s, (o - 1) * s + s);
  const d = e[(o + 1) * s - 1], u = (r - f) / (d - f);
  a = [];
  for (let c = 0; c < s - 1; ++c)
    a.push(
      Us(
        e[(o - 1) * s + c],
        e[o * s + c],
        u
      )
    );
  return a.push(r), a;
}
function uA(e, t, n, s, r, i, a) {
  if (a)
    return $g(
      e,
      t,
      n[n.length - 1],
      s,
      r,
      i
    );
  let o;
  if (r < e[s - 1])
    return i ? (o = e.slice(0, s), o[s - 1] = r, o) : null;
  if (e[e.length - 1] < r)
    return i ? (o = e.slice(e.length - s), o[s - 1] = r, o) : null;
  for (let l = 0, f = n.length; l < f; ++l) {
    const d = n[l];
    if (t != d) {
      if (r < e[t + s - 1])
        return null;
      if (r <= e[d - 1])
        return $g(
          e,
          t,
          d,
          s,
          r,
          !1
        );
      t = d;
    }
  }
  return null;
}
function S1(e, t, n, s) {
  let r = e[t], i = e[t + 1], a = 0;
  for (let o = t + s; o < n; o += s) {
    const l = e[o], f = e[o + 1];
    a += Math.sqrt((l - r) * (l - r) + (f - i) * (f - i)), r = l, i = f;
  }
  return a;
}
class Pd extends oa {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, n !== void 0 && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t) : this.flatCoordinates = t.slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const t = new Pd(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Qo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      fy(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), my(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(t) {
    return x1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, n) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (n = n !== void 0 ? n : !1, $g(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return _a(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(t, n) {
    return Od(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return S1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [];
    return n.length = yy(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t,
      n,
      0
    ), new Pd(n, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return Vf(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = wf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const er = Pd;
class Ty {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.color_ = t.color !== void 0 ? t.color : null, this.lineCap_ = t.lineCap, this.lineDash_ = t.lineDash !== void 0 ? t.lineDash : null, this.lineDashOffset_ = t.lineDashOffset, this.lineJoin_ = t.lineJoin, this.miterLimit_ = t.miterLimit, this.width_ = t.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const t = this.getColor();
    return new Ty({
      color: Array.isArray(t) ? t.slice() : t || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(t) {
    this.color_ = t;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(t) {
    this.lineCap_ = t;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(t) {
    this.lineDash_ = t;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(t) {
    this.lineDashOffset_ = t;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(t) {
    this.lineJoin_ = t;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(t) {
    this.miterLimit_ = t;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(t) {
    this.width_ = t;
  }
}
const vr = Ty, he = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function JE(e, t, n) {
  return n === void 0 && (n = [0, 0]), n[0] = e[0] + 2 * t, n[1] = e[1] + 2 * t, n;
}
function QE(e) {
  return e[0] > 0 && e[1] > 0;
}
function M1(e, t, n) {
  return n === void 0 && (n = [0, 0]), n[0] = e[0] * t + 0.5 | 0, n[1] = e[1] * t + 0.5 | 0, n;
}
function ti(e, t) {
  return Array.isArray(e) ? e : (t === void 0 ? t = [e, e] : (t[0] = e, t[1] = e), t);
}
class Oy {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    this.opacity_ = t.opacity, this.rotateWithView_ = t.rotateWithView, this.rotation_ = t.rotation, this.scale_ = t.scale, this.scaleArray_ = ti(t.scale), this.displacement_ = t.displacement, this.declutterMode_ = t.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Oy({
      opacity: this.getOpacity(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Gt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getImage(t) {
    return Gt();
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getHitDetectionImage() {
    return Gt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Gt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Gt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Gt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Gt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(t) {
    this.displacement_ = t;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(t) {
    this.opacity_ = t;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = ti(t);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    Gt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Gt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    Gt();
  }
}
const _1 = Oy, cA = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, hA = /^([a-z]*)$|^hsla?\(.*\)$/i;
function I1(e) {
  return typeof e == "string" ? e : D1(e);
}
function dA(e) {
  const t = document.createElement("div");
  if (t.style.color = e, t.style.color !== "") {
    document.body.appendChild(t);
    const n = getComputedStyle(t).color;
    return document.body.removeChild(t), n;
  } else
    return "";
}
const fA = function() {
  const t = {};
  let n = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function(s) {
      let r;
      if (t.hasOwnProperty(s))
        r = t[s];
      else {
        if (n >= 1024) {
          let i = 0;
          for (const a in t)
            i++ & 3 || (delete t[a], --n);
        }
        r = pA(s), t[s] = r, ++n;
      }
      return r;
    }
  );
}();
function Sd(e) {
  return Array.isArray(e) ? e : fA(e);
}
function pA(e) {
  let t, n, s, r, i;
  if (hA.exec(e) && (e = dA(e)), cA.exec(e)) {
    const a = e.length - 1;
    let o;
    a <= 4 ? o = 1 : o = 2;
    const l = a === 4 || a === 8;
    t = parseInt(e.substr(1 + 0 * o, o), 16), n = parseInt(e.substr(1 + 1 * o, o), 16), s = parseInt(e.substr(1 + 2 * o, o), 16), l ? r = parseInt(e.substr(1 + 3 * o, o), 16) : r = 255, o == 1 && (t = (t << 4) + t, n = (n << 4) + n, s = (s << 4) + s, l && (r = (r << 4) + r)), i = [t, n, s, r / 255];
  } else
    e.startsWith("rgba(") ? (i = e.slice(5, -1).split(",").map(Number), qE(i)) : e.startsWith("rgb(") ? (i = e.slice(4, -1).split(",").map(Number), i.push(1), qE(i)) : Zt(!1, 14);
  return i;
}
function qE(e) {
  return e[0] = dn(e[0] + 0.5 | 0, 0, 255), e[1] = dn(e[1] + 0.5 | 0, 0, 255), e[2] = dn(e[2] + 0.5 | 0, 0, 255), e[3] = dn(e[3], 0, 1), e;
}
function D1(e) {
  let t = e[0];
  t != (t | 0) && (t = t + 0.5 | 0);
  let n = e[1];
  n != (n | 0) && (n = n + 0.5 | 0);
  let s = e[2];
  s != (s | 0) && (s = s + 0.5 | 0);
  const r = e[3] === void 0 ? 1 : Math.round(e[3] * 100) / 100;
  return "rgba(" + t + "," + n + "," + s + "," + r + ")";
}
function us(e) {
  return Array.isArray(e) ? D1(e) : e;
}
function Di(e, t, n, s) {
  let r;
  return n && n.length ? r = n.shift() : qv ? r = new OffscreenCanvas(e || 300, t || 300) : r = document.createElement("canvas"), e && (r.width = e), t && (r.height = t), /** @type {CanvasRenderingContext2D} */
  r.getContext("2d", s);
}
function Py(e) {
  const t = e.canvas;
  t.width = 1, t.height = 1, e.clearRect(0, 0, 1, 1);
}
function mA(e) {
  let t = e.offsetWidth;
  const n = getComputedStyle(e);
  return t += parseInt(n.marginLeft, 10) + parseInt(n.marginRight, 10), t;
}
function gA(e) {
  let t = e.offsetHeight;
  const n = getComputedStyle(e);
  return t += parseInt(n.marginTop, 10) + parseInt(n.marginBottom, 10), t;
}
function tC(e, t) {
  const n = t.parentNode;
  n && n.replaceChild(e, t);
}
function Md(e) {
  return e && e.parentNode ? e.parentNode.removeChild(e) : null;
}
function A1(e) {
  for (; e.lastChild; )
    e.removeChild(e.lastChild);
}
function vA(e, t) {
  const n = e.childNodes;
  for (let s = 0; ; ++s) {
    const r = n[s], i = t[s];
    if (!r && !i)
      break;
    if (r !== i) {
      if (!r) {
        e.appendChild(i);
        continue;
      }
      if (!i) {
        e.removeChild(r), --s;
        continue;
      }
      e.insertBefore(i, r);
    }
  }
}
const vh = "ol-hidden", yA = "ol-selectable", Bf = "ol-unselectable", Sy = "ol-control", eC = "ol-collapsed", EA = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), nC = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], L1 = function(e) {
  const t = e.match(EA);
  if (!t)
    return null;
  const n = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let s = 0, r = nC.length; s < r; ++s) {
    const i = t[s + 1];
    i !== void 0 && (n[nC[s]] = i);
  }
  return n.families = n.family.split(/,\s?/), n;
}, R1 = "10px sans-serif", Zs = "#000", _d = "round", cc = [], hc = 0, nu = "round", dc = 10, fc = "#000", pc = "center", Id = "middle", xo = [0, 0, 0, 0], mc = 1, Ns = new xr();
let gl = null, Ug;
const Wg = {}, CA = function() {
  const t = "32px ", n = ["monospace", "serif"], s = n.length, r = "wmytzilWMYTZIL@#/&?$%10";
  let i, a;
  function o(f, d, u) {
    let c = !0;
    for (let h = 0; h < s; ++h) {
      const p = n[h];
      if (a = Dd(
        f + " " + d + " " + t + p,
        r
      ), u != p) {
        const g = Dd(
          f + " " + d + " " + t + u + "," + p,
          r
        );
        c = c && g != a;
      }
    }
    return !!c;
  }
  function l() {
    let f = !0;
    const d = Ns.getKeys();
    for (let u = 0, c = d.length; u < c; ++u) {
      const h = d[u];
      Ns.get(h) < 100 && (o.apply(this, h.split(`
`)) ? (cu(Wg), gl = null, Ug = void 0, Ns.set(h, 100)) : (Ns.set(h, Ns.get(h) + 1, !0), f = !1));
    }
    f && (clearInterval(i), i = void 0);
  }
  return function(f) {
    const d = L1(f);
    if (!d)
      return;
    const u = d.families;
    for (let c = 0, h = u.length; c < h; ++c) {
      const p = u[c], g = d.style + `
` + d.weight + `
` + p;
      Ns.get(g) === void 0 && (Ns.set(g, 100, !0), o(d.style, d.weight, p) || (Ns.set(g, 0, !0), i === void 0 && (i = setInterval(l, 32))));
    }
  };
}(), xA = function() {
  let e;
  return function(t) {
    let n = Wg[t];
    if (n == null) {
      if (qv) {
        const s = L1(t), r = w1(t, "g");
        n = (isNaN(Number(s.lineHeight)) ? 1.2 : Number(s.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent);
      } else
        e || (e = document.createElement("div"), e.innerHTML = "M", e.style.minHeight = "0", e.style.maxHeight = "none", e.style.height = "auto", e.style.padding = "0", e.style.border = "none", e.style.position = "absolute", e.style.display = "block", e.style.left = "-99999px"), e.style.font = t, document.body.appendChild(e), n = e.offsetHeight, document.body.removeChild(e);
      Wg[t] = n;
    }
    return n;
  };
}();
function w1(e, t) {
  return gl || (gl = Di(1, 1)), e != Ug && (gl.font = e, Ug = gl.font), gl.measureText(t);
}
function Dd(e, t) {
  return w1(e, t).width;
}
function iC(e, t, n) {
  if (t in n)
    return n[t];
  const s = t.split(`
`).reduce((r, i) => Math.max(r, Dd(e, i)), 0);
  return n[t] = s, s;
}
function bA(e, t) {
  const n = [], s = [], r = [];
  let i = 0, a = 0, o = 0, l = 0;
  for (let f = 0, d = t.length; f <= d; f += 2) {
    const u = t[f];
    if (u === `
` || f === d) {
      i = Math.max(i, a), r.push(a), a = 0, o += l;
      continue;
    }
    const c = t[f + 1] || e.font, h = Dd(c, u);
    n.push(h), a += h;
    const p = xA(c);
    s.push(p), l = Math.max(l, p);
  }
  return { width: i, height: o, widths: n, heights: s, lineWidths: r };
}
function TA(e, t, n, s, r, i, a, o, l, f, d) {
  e.save(), n !== 1 && (e.globalAlpha *= n), t && e.setTransform.apply(e, t), /** @type {*} */
  s.contextInstructions ? (e.translate(l, f), e.scale(d[0], d[1]), OA(
    /** @type {Label} */
    s,
    e
  )) : d[0] < 0 || d[1] < 0 ? (e.translate(l, f), e.scale(d[0], d[1]), e.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    s,
    r,
    i,
    a,
    o,
    0,
    0,
    a,
    o
  )) : e.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    s,
    r,
    i,
    a,
    o,
    l,
    f,
    a * d[0],
    o * d[1]
  ), e.restore();
}
function OA(e, t) {
  const n = e.contextInstructions;
  for (let s = 0, r = n.length; s < r; s += 2)
    Array.isArray(n[s + 1]) ? t[n[s]].apply(
      t,
      n[s + 1]
    ) : t[n[s]] = n[s + 1];
}
class My extends _1 {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    const n = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: 1,
      rotateWithView: n,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      scale: t.scale !== void 0 ? t.scale : 1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = t.fill !== void 0 ? t.fill : null, this.origin_ = [0, 0], this.points_ = t.points, this.radius_ = t.radius !== void 0 ? t.radius : t.radius1, this.radius2_ = t.radius2, this.angle_ = t.angle !== void 0 ? t.angle : 0, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), n = new My({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const t = this.size_;
    if (!t)
      return null;
    const n = this.getDisplacement(), s = this.getScaleArray();
    return [
      t[0] / 2 - n[0] / s[0],
      t[1] / 2 + n[1] / s[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    let n = this.canvas_[t];
    if (!n) {
      const s = this.renderOptions_, r = Di(
        s.size * t,
        s.size * t
      );
      this.draw_(s, r, t), n = r.canvas, this.canvas_[t] = n;
    }
    return n;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(t) {
    return t;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return he.LOADED;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(t, n, s) {
    if (n === 0 || this.points_ === 1 / 0 || t !== "bevel" && t !== "miter")
      return n;
    let r = this.radius_, i = this.radius2_ === void 0 ? r : this.radius2_;
    if (r < i) {
      const b = r;
      r = i, i = b;
    }
    const a = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, o = 2 * Math.PI / a, l = i * Math.sin(o), f = Math.sqrt(i * i - l * l), d = r - f, u = Math.sqrt(l * l + d * d), c = u / l;
    if (t === "miter" && c <= s)
      return c * n;
    const h = n / 2 / c, p = n / 2 * (d / u), m = Math.sqrt((r + h) * (r + h) + p * p) - r;
    if (this.radius2_ === void 0 || t === "bevel")
      return m * 2;
    const v = r * Math.sin(o), y = Math.sqrt(r * r - v * v), E = i - y, x = Math.sqrt(v * v + E * E) / v;
    if (x <= s) {
      const b = x * n / 2 - i - r;
      return 2 * Math.max(m, b);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let t = nu, n = 0, s = null, r = 0, i, a = 0;
    this.stroke_ && (i = this.stroke_.getColor(), i === null && (i = fc), i = us(i), a = this.stroke_.getWidth(), a === void 0 && (a = mc), s = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset(), t = this.stroke_.getLineJoin(), t === void 0 && (t = nu), n = this.stroke_.getMiterLimit(), n === void 0 && (n = dc));
    const o = this.calculateLineJoinSize_(t, a, n), l = Math.max(this.radius_, this.radius2_ || 0), f = Math.ceil(2 * l + o);
    return {
      strokeStyle: i,
      strokeWidth: a,
      size: f,
      lineDash: s,
      lineDashOffset: r,
      lineJoin: t,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const t = this.renderOptions_.size;
    this.canvas_ = {}, this.size_ = [t, t];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(t, n, s) {
    if (n.scale(s, s), n.translate(t.size / 2, t.size / 2), this.createPath_(n), this.fill_) {
      let r = this.fill_.getColor();
      r === null && (r = Zs), n.fillStyle = us(r), n.fill();
    }
    this.stroke_ && (n.strokeStyle = t.strokeStyle, n.lineWidth = t.strokeWidth, t.lineDash && (n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset), n.lineJoin = t.lineJoin, n.miterLimit = t.miterLimit, n.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(t) {
    if (this.fill_) {
      let n = this.fill_.getColor(), s = 0;
      if (typeof n == "string" && (n = Sd(n)), n === null ? s = 1 : Array.isArray(n) && (s = n.length === 4 ? n[3] : 1), s === 0) {
        const r = Di(
          t.size,
          t.size
        );
        this.hitDetectionCanvas_ = r.canvas, this.drawHitDetectionCanvas_(t, r);
      }
    }
    this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(t) {
    let n = this.points_;
    const s = this.radius_;
    if (n === 1 / 0)
      t.arc(0, 0, s, 0, 2 * Math.PI);
    else {
      const r = this.radius2_ === void 0 ? s : this.radius2_;
      this.radius2_ !== void 0 && (n *= 2);
      const i = this.angle_ - Math.PI / 2, a = 2 * Math.PI / n;
      for (let o = 0; o < n; o++) {
        const l = i + o * a, f = o % 2 === 0 ? s : r;
        t.lineTo(f * Math.cos(l), f * Math.sin(l));
      }
      t.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(t, n) {
    n.translate(t.size / 2, t.size / 2), this.createPath_(n), n.fillStyle = Zs, n.fill(), this.stroke_ && (n.strokeStyle = t.strokeStyle, n.lineWidth = t.strokeWidth, t.lineDash && (n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset), n.lineJoin = t.lineJoin, n.miterLimit = t.miterLimit, n.stroke());
  }
}
const V1 = My;
class _y extends V1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || { radius: 5 }, super({
      points: 1 / 0,
      fill: t.fill,
      radius: t.radius,
      stroke: t.stroke,
      scale: t.scale !== void 0 ? t.scale : 1,
      rotation: t.rotation !== void 0 ? t.rotation : 0,
      rotateWithView: t.rotateWithView !== void 0 ? t.rotateWithView : !1,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      declutterMode: t.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale(), n = new _y({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(t) ? t.slice() : t,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return n.setOpacity(this.getOpacity()), n;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(t) {
    this.radius_ = t, this.render();
  }
}
const Ff = _y;
class Ia {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(t) {
    t = t || {}, this.geometry_ = null, this.geometryFunction_ = rC, t.geometry !== void 0 && this.setGeometry(t.geometry), this.fill_ = t.fill !== void 0 ? t.fill : null, this.image_ = t.image !== void 0 ? t.image : null, this.renderer_ = t.renderer !== void 0 ? t.renderer : null, this.hitDetectionRenderer_ = t.hitDetectionRenderer !== void 0 ? t.hitDetectionRenderer : null, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.text_ = t.text !== void 0 ? t.text : null, this.zIndex_ = t.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let t = this.getGeometry();
    return t && typeof t == "object" && (t = /** @type {import("../geom/Geometry.js").default} */
    t.clone()), new Ia({
      geometry: t,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(t) {
    this.renderer_ = t;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(t) {
    this.hitDetectionRenderer_ = t;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(t) {
    this.image_ = t;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(t) {
    typeof t == "function" ? this.geometryFunction_ = t : typeof t == "string" ? this.geometryFunction_ = function(n) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        n.get(t)
      );
    } : t ? t !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t
      );
    }) : this.geometryFunction_ = rC, this.geometry_ = t;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(t) {
    this.zIndex_ = t;
  }
}
function PA(e) {
  let t;
  if (typeof e == "function")
    t = e;
  else {
    let n;
    Array.isArray(e) ? n = e : (Zt(typeof /** @type {?} */
    e.getZIndex == "function", 41), n = [
      /** @type {Style} */
      e
    ]), t = function() {
      return n;
    };
  }
  return t;
}
let vp = null;
function SA(e, t) {
  if (!vp) {
    const n = new wr({
      color: "rgba(255,255,255,0.4)"
    }), s = new vr({
      color: "#3399CC",
      width: 1.25
    });
    vp = [
      new Ia({
        image: new Ff({
          fill: n,
          stroke: s,
          radius: 5
        }),
        fill: n,
        stroke: s
      })
    ];
  }
  return vp;
}
function B1() {
  const e = {}, t = [255, 255, 255, 1], n = [0, 153, 255, 1], s = 3;
  return e.Polygon = [
    new Ia({
      fill: new wr({
        color: [255, 255, 255, 0.5]
      })
    })
  ], e.MultiPolygon = e.Polygon, e.LineString = [
    new Ia({
      stroke: new vr({
        color: t,
        width: s + 2
      })
    }),
    new Ia({
      stroke: new vr({
        color: n,
        width: s
      })
    })
  ], e.MultiLineString = e.LineString, e.Circle = e.Polygon.concat(e.LineString), e.Point = [
    new Ia({
      image: new Ff({
        radius: s * 2,
        fill: new wr({
          color: n
        }),
        stroke: new vr({
          color: t,
          width: s / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], e.MultiPoint = e.Point, e.GeometryCollection = e.Polygon.concat(
    e.LineString,
    e.Point
  ), e;
}
function rC(e) {
  return e.getGeometry();
}
const Mn = Ia, MA = "#333";
class Iy {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, this.font_ = t.font, this.rotation_ = t.rotation, this.rotateWithView_ = t.rotateWithView, this.scale_ = t.scale, this.scaleArray_ = ti(t.scale !== void 0 ? t.scale : 1), this.text_ = t.text, this.textAlign_ = t.textAlign, this.justify_ = t.justify, this.textBaseline_ = t.textBaseline, this.fill_ = t.fill !== void 0 ? t.fill : new wr({ color: MA }), this.maxAngle_ = t.maxAngle !== void 0 ? t.maxAngle : Math.PI / 4, this.placement_ = t.placement !== void 0 ? t.placement : "point", this.overflow_ = !!t.overflow, this.stroke_ = t.stroke !== void 0 ? t.stroke : null, this.offsetX_ = t.offsetX !== void 0 ? t.offsetX : 0, this.offsetY_ = t.offsetY !== void 0 ? t.offsetY : 0, this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null, this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null, this.padding_ = t.padding === void 0 ? null : t.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Iy({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(t) ? t.slice() : t,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(t) {
    this.overflow_ = t;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(t) {
    this.font_ = t;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(t) {
    this.maxAngle_ = t;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(t) {
    this.offsetX_ = t;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(t) {
    this.offsetY_ = t;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(t) {
    this.placement_ = t;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(t) {
    this.rotateWithView_ = t;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(t) {
    this.fill_ = t;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(t) {
    this.rotation_ = t;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(t) {
    this.scale_ = t, this.scaleArray_ = ti(t !== void 0 ? t : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(t) {
    this.stroke_ = t;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(t) {
    this.text_ = t;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(t) {
    this.textAlign_ = t;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(t) {
    this.justify_ = t;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(t) {
    this.textBaseline_ = t;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(t) {
    this.backgroundFill_ = t;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(t) {
    this.backgroundStroke_ = t;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(t) {
    this.padding_ = t;
  }
}
const F1 = Iy, Be = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
class _A extends xr {
  /**
   * @param {Options} options Layer options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.background_ = t.background;
    const n = Object.assign({}, t);
    typeof t.properties == "object" && (delete n.properties, Object.assign(n, t.properties)), n[Be.OPACITY] = t.opacity !== void 0 ? t.opacity : 1, Zt(typeof n[Be.OPACITY] == "number", 64), n[Be.VISIBLE] = t.visible !== void 0 ? t.visible : !0, n[Be.Z_INDEX] = t.zIndex, n[Be.MAX_RESOLUTION] = t.maxResolution !== void 0 ? t.maxResolution : 1 / 0, n[Be.MIN_RESOLUTION] = t.minResolution !== void 0 ? t.minResolution : 0, n[Be.MIN_ZOOM] = t.minZoom !== void 0 ? t.minZoom : -1 / 0, n[Be.MAX_ZOOM] = t.maxZoom !== void 0 ? t.maxZoom : 1 / 0, this.className_ = n.className !== void 0 ? n.className : "ol-layer", delete n.className, this.setProperties(n), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(t) {
    const n = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: t === void 0 ? !0 : t
    }, s = this.getZIndex();
    return n.opacity = dn(Math.round(this.getOpacity() * 100) / 100, 0, 1), n.visible = this.getVisible(), n.extent = this.getExtent(), n.zIndex = s === void 0 && !n.managed ? 1 / 0 : s, n.maxResolution = this.getMaxResolution(), n.minResolution = Math.max(this.getMinResolution(), 0), n.minZoom = this.getMinZoom(), n.maxZoom = this.getMaxZoom(), this.state_ = n, n;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return Gt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return Gt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Be.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Be.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Be.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Be.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Be.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Be.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Gt();
  }
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Be.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number} */
      this.get(Be.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(t) {
    this.background_ = t, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(t) {
    this.set(Be.EXTENT, t);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(t) {
    this.set(Be.MAX_RESOLUTION, t);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(t) {
    this.set(Be.MIN_RESOLUTION, t);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(t) {
    this.set(Be.MAX_ZOOM, t);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(t) {
    this.set(Be.MIN_ZOOM, t);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(t) {
    Zt(typeof t == "number", 64), this.set(Be.OPACITY, t);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(t) {
    this.set(Be.VISIBLE, t);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(t) {
    this.set(Be.Z_INDEX, t);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const N1 = _A;
class IA extends N1 {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(t) {
    const n = Object.assign({}, t);
    delete n.source, super(n), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.rendered = !1, t.render && (this.render = t.render), t.map && this.setMap(t.map), this.addChangeListener(
      Be.SOURCE,
      this.handleSourcePropertyChange_
    );
    const s = t.source ? (
      /** @type {SourceType} */
      t.source
    ) : null;
    this.setSource(s);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t || [], t.push(this), t;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    return t = t || [], t.push(this.getLayerState()), t;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Be.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const t = this.getSource();
    return t ? t.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (Ue(this.sourceChangeKey_), this.sourceChangeKey_ = null);
    const t = this.getSource();
    t && (this.sourceChangeKey_ = ve(
      t,
      Kt.CHANGE,
      this.handleSourceChange_,
      this
    )), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return this.renderer_ ? this.renderer_.getFeatures(t) : new Promise((n) => n([]));
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(t);
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */
  render(t, n) {
    const s = this.getRenderer();
    if (s.prepareFrame(t))
      return this.rendered = !0, s.renderFrame(t, n);
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(t) {
    t || this.unrender(), this.set(Be.MAP, t);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Be.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.mapPrecomposeKey_ && (Ue(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), t || this.changed(), this.mapRenderKey_ && (Ue(this.mapRenderKey_), this.mapRenderKey_ = null), t && (this.mapPrecomposeKey_ = ve(
      t,
      Fa.PRECOMPOSE,
      function(n) {
        const r = /** @type {import("../render/Event.js").default} */ n.frameState.layerStatesArray, i = this.getLayerState(!1);
        Zt(
          !r.some(function(a) {
            return a.layer === i.layer;
          }),
          67
        ), r.push(i);
      },
      this
    ), this.mapRenderKey_ = ve(this, Kt.CHANGE, t.render, t), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(t) {
    this.set(Be.SOURCE, t);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function Dy(e, t) {
  if (!e.visible)
    return !1;
  const n = t.resolution;
  if (n < e.minResolution || n >= e.maxResolution)
    return !1;
  const s = t.zoom;
  return s > e.minZoom && s <= e.maxZoom;
}
const hu = IA;
function DA(e, t, n, s, r) {
  j1(e, t, n || 0, s || e.length - 1, r || AA);
}
function j1(e, t, n, s, r) {
  for (; s > n; ) {
    if (s - n > 600) {
      var i = s - n + 1, a = t - n + 1, o = Math.log(i), l = 0.5 * Math.exp(2 * o / 3), f = 0.5 * Math.sqrt(o * l * (i - l) / i) * (a - i / 2 < 0 ? -1 : 1), d = Math.max(n, Math.floor(t - a * l / i + f)), u = Math.min(s, Math.floor(t + (i - a) * l / i + f));
      j1(e, t, d, u, r);
    }
    var c = e[t], h = n, p = s;
    for (Bu(e, n, t), r(e[s], c) > 0 && Bu(e, n, s); h < p; ) {
      for (Bu(e, h, p), h++, p--; r(e[h], c) < 0; )
        h++;
      for (; r(e[p], c) > 0; )
        p--;
    }
    r(e[n], c) === 0 ? Bu(e, n, p) : (p++, Bu(e, p, s)), p <= t && (n = p + 1), t <= p && (s = p - 1);
  }
}
function Bu(e, t, n) {
  var s = e[t];
  e[t] = e[n], e[n] = s;
}
function AA(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
let $1 = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const s = [];
    if (!Eh(t, n))
      return s;
    const r = this.toBBox, i = [];
    for (; n; ) {
      for (let a = 0; a < n.children.length; a++) {
        const o = n.children[a], l = n.leaf ? r(o) : o;
        Eh(t, l) && (n.leaf ? s.push(o) : Ep(t, l) ? this._all(o, s) : i.push(o));
      }
      n = i.pop();
    }
    return s;
  }
  collides(t) {
    let n = this.data;
    if (!Eh(t, n))
      return !1;
    const s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const i = n.children[r], a = n.leaf ? this.toBBox(i) : i;
        if (Eh(t, a)) {
          if (n.leaf || Ep(t, a))
            return !0;
          s.push(i);
        }
      }
      n = s.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length))
      return this;
    if (t.length < this._minEntries) {
      for (let s = 0; s < t.length; s++)
        this.insert(t[s]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const s = this.data;
        this.data = n, n = s;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = vl([]), this;
  }
  remove(t, n) {
    if (!t)
      return this;
    let s = this.data;
    const r = this.toBBox(t), i = [], a = [];
    let o, l, f;
    for (; s || i.length; ) {
      if (s || (s = i.pop(), l = i[i.length - 1], o = a.pop(), f = !0), s.leaf) {
        const d = LA(t, s.children, n);
        if (d !== -1)
          return s.children.splice(d, 1), i.push(s), this._condense(i), this;
      }
      !f && !s.leaf && Ep(s, r) ? (i.push(s), a.push(o), o = 0, l = s, s = s.children[0]) : l ? (o++, s = l.children[o], f = !1) : s = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const s = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : s.push(...t.children), t = s.pop();
    return n;
  }
  _build(t, n, s, r) {
    const i = s - n + 1;
    let a = this._maxEntries, o;
    if (i <= a)
      return o = vl(t.slice(n, s + 1)), ll(o, this.toBBox), o;
    r || (r = Math.ceil(Math.log(i) / Math.log(a)), a = Math.ceil(i / Math.pow(a, r - 1))), o = vl([]), o.leaf = !1, o.height = r;
    const l = Math.ceil(i / a), f = l * Math.ceil(Math.sqrt(a));
    sC(t, n, s, f, this.compareMinX);
    for (let d = n; d <= s; d += f) {
      const u = Math.min(d + f - 1, s);
      sC(t, d, u, l, this.compareMinY);
      for (let c = d; c <= u; c += l) {
        const h = Math.min(c + l - 1, u);
        o.children.push(this._build(t, c, h, r - 1));
      }
    }
    return ll(o, this.toBBox), o;
  }
  _chooseSubtree(t, n, s, r) {
    for (; r.push(n), !(n.leaf || r.length - 1 === s); ) {
      let i = 1 / 0, a = 1 / 0, o;
      for (let l = 0; l < n.children.length; l++) {
        const f = n.children[l], d = yp(f), u = VA(t, f) - d;
        u < a ? (a = u, i = d < i ? d : i, o = f) : u === a && d < i && (i = d, o = f);
      }
      n = o || n.children[0];
    }
    return n;
  }
  _insert(t, n, s) {
    const r = s ? t : this.toBBox(t), i = [], a = this._chooseSubtree(r, this.data, n, i);
    for (a.children.push(t), Xu(a, r); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(r, i, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const s = t[n], r = s.children.length, i = this._minEntries;
    this._chooseSplitAxis(s, i, r);
    const a = this._chooseSplitIndex(s, i, r), o = vl(s.children.splice(a, s.children.length - a));
    o.height = s.height, o.leaf = s.leaf, ll(s, this.toBBox), ll(o, this.toBBox), n ? t[n - 1].children.push(o) : this._splitRoot(s, o);
  }
  _splitRoot(t, n) {
    this.data = vl([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, ll(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, s) {
    let r, i = 1 / 0, a = 1 / 0;
    for (let o = n; o <= s - n; o++) {
      const l = Yu(t, 0, o, this.toBBox), f = Yu(t, o, s, this.toBBox), d = BA(l, f), u = yp(l) + yp(f);
      d < i ? (i = d, r = o, a = u < a ? u : a) : d === i && u < a && (a = u, r = o);
    }
    return r || s - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, s) {
    const r = t.leaf ? this.compareMinX : RA, i = t.leaf ? this.compareMinY : wA, a = this._allDistMargin(t, n, s, r), o = this._allDistMargin(t, n, s, i);
    a < o && t.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, s, r) {
    t.children.sort(r);
    const i = this.toBBox, a = Yu(t, 0, n, i), o = Yu(t, s - n, s, i);
    let l = yh(a) + yh(o);
    for (let f = n; f < s - n; f++) {
      const d = t.children[f];
      Xu(a, t.leaf ? i(d) : d), l += yh(a);
    }
    for (let f = s - n - 1; f >= n; f--) {
      const d = t.children[f];
      Xu(o, t.leaf ? i(d) : d), l += yh(o);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, s) {
    for (let r = s; r >= 0; r--)
      Xu(n[r], t);
  }
  _condense(t) {
    for (let n = t.length - 1, s; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (s = t[n - 1].children, s.splice(s.indexOf(t[n]), 1)) : this.clear() : ll(t[n], this.toBBox);
  }
};
function LA(e, t, n) {
  if (!n)
    return t.indexOf(e);
  for (let s = 0; s < t.length; s++)
    if (n(e, t[s]))
      return s;
  return -1;
}
function ll(e, t) {
  Yu(e, 0, e.children.length, t, e);
}
function Yu(e, t, n, s, r) {
  r || (r = vl(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let i = t; i < n; i++) {
    const a = e.children[i];
    Xu(r, e.leaf ? s(a) : a);
  }
  return r;
}
function Xu(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function RA(e, t) {
  return e.minX - t.minX;
}
function wA(e, t) {
  return e.minY - t.minY;
}
function yp(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function yh(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function VA(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function BA(e, t) {
  const n = Math.max(e.minX, t.minX), s = Math.max(e.minY, t.minY), r = Math.min(e.maxX, t.maxX), i = Math.min(e.maxY, t.maxY);
  return Math.max(0, r - n) * Math.max(0, i - s);
}
function Ep(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function Eh(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function vl(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function sC(e, t, n, s, r) {
  const i = [t, n];
  for (; i.length; ) {
    if (n = i.pop(), t = i.pop(), n - t <= s)
      continue;
    const a = t + Math.ceil((n - t) / s / 2) * s;
    DA(e, a, t, n, r), i.push(t, a, a, n);
  }
}
class FA {
  constructor() {
    this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let t = 0;
      for (const n in this.cache_) {
        const s = this.cache_[n];
        !(t++ & 3) && !s.hasListener() && (delete this.cache_[n], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(t, n, s) {
    const r = aC(t, n, s);
    return r in this.cache_ ? this.cache_[r] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */
  set(t, n, s, r) {
    const i = aC(t, n, s);
    this.cache_[i] = r, ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(t) {
    this.maxCacheSize_ = t, this.expire();
  }
}
function aC(e, t, n) {
  const s = n ? I1(n) : "null";
  return t + ":" + e + ":" + s;
}
const Ad = new FA();
class NA extends Nc {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  constructor(t, n, s, r) {
    super(), this.extent = t, this.pixelRatio_ = s, this.resolution = n, this.state = r;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return Gt();
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Gt();
  }
}
const U1 = NA;
class jA extends U1 {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, s, he.IDLE), this.src_ = r, this.image_ = new Image(), i !== null && (this.image_.crossOrigin = i), this.unlisten_ = null, this.state = he.IDLE, this.imageLoadFunction_ = a;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = he.ERROR, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    this.resolution === void 0 && (this.resolution = In(this.extent) / this.image_.height), this.state = he.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */
  load() {
    (this.state == he.IDLE || this.state == he.ERROR) && (this.state = he.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = Ay(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  setImage(t) {
    this.image_ = t, this.resolution = In(this.extent) / this.image_.height;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function Ay(e, t, n) {
  const s = (
    /** @type {HTMLImageElement} */
    e
  );
  let r = !0, i = !1, a = !1;
  const o = [
    yd(s, Kt.LOAD, function() {
      a = !0, i || t();
    })
  ];
  return s.src && cD ? (i = !0, s.decode().then(function() {
    r && t();
  }).catch(function(l) {
    r && (a ? t() : n());
  })) : o.push(yd(s, Kt.ERROR, n)), function() {
    r = !1, o.forEach(Ue);
  };
}
const W1 = jA;
let Fu = null;
class $A extends Nc {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(t, n, s, r, i, a) {
    super(), this.hitDetectionImage_ = null, this.image_ = t, this.crossOrigin_ = r, this.canvas_ = {}, this.color_ = a, this.unlisten_ = null, this.imageState_ = i, this.size_ = s, this.src_ = n, this.tainted_;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === he.LOADED) {
      Fu || (Fu = Di(1, 1)), Fu.drawImage(this.image_, 0, 0);
      try {
        Fu.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Fu = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = he.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = he.LOADED, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  getImage(t) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(t) {
    return this.replaceColor_(t), this.canvas_[t] ? t : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const t = this.size_[0], n = this.size_[1], s = Di(t, n);
        s.fillRect(0, 0, t, n), this.hitDetectionImage_ = s.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === he.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = he.LOADING;
      try {
        this.image_.src = this.src_;
      } catch {
        this.handleImageError_();
      }
      this.unlisten_ = Ay(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(t) {
    if (!this.color_ || this.canvas_[t] || this.imageState_ !== he.LOADED)
      return;
    const n = this.image_, s = document.createElement("canvas");
    s.width = Math.ceil(n.width * t), s.height = Math.ceil(n.height * t);
    const r = s.getContext("2d");
    r.scale(t, t), r.drawImage(n, 0, 0), r.globalCompositeOperation = "multiply", r.fillStyle = I1(this.color_), r.fillRect(0, 0, s.width / t, s.height / t), r.globalCompositeOperation = "destination-in", r.drawImage(n, 0, 0), this.canvas_[t] = s;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function UA(e, t, n, s, r, i) {
  let a = Ad.get(t, s, i);
  return a || (a = new $A(e, t, n, s, r, i), Ad.set(t, s, i, a)), a;
}
class Ly extends _1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = t.opacity !== void 0 ? t.opacity : 1, s = t.rotation !== void 0 ? t.rotation : 0, r = t.scale !== void 0 ? t.scale : 1, i = t.rotateWithView !== void 0 ? t.rotateWithView : !1;
    super({
      opacity: n,
      rotation: s,
      scale: r,
      displacement: t.displacement !== void 0 ? t.displacement : [0, 0],
      rotateWithView: i,
      declutterMode: t.declutterMode
    }), this.anchor_ = t.anchor !== void 0 ? t.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = t.anchorOrigin !== void 0 ? t.anchorOrigin : "top-left", this.anchorXUnits_ = t.anchorXUnits !== void 0 ? t.anchorXUnits : "fraction", this.anchorYUnits_ = t.anchorYUnits !== void 0 ? t.anchorYUnits : "fraction", this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null;
    const a = t.img !== void 0 ? t.img : null;
    this.imgSize_ = t.imgSize;
    let o = t.src;
    Zt(!(o !== void 0 && a), 4), Zt(!a || a && this.imgSize_, 5), (o === void 0 || o.length === 0) && a && (o = /** @type {HTMLImageElement} */
    a.src || Xt(a)), Zt(o !== void 0 && o.length > 0, 6);
    const l = t.src !== void 0 ? he.IDLE : he.LOADED;
    this.color_ = t.color !== void 0 ? Sd(t.color) : null, this.iconImage_ = UA(
      a,
      /** @type {string} */
      o,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = t.offset !== void 0 ? t.offset : [0, 0], this.offsetOrigin_ = t.offsetOrigin !== void 0 ? t.offsetOrigin : "top-left", this.origin_ = null, this.size_ = t.size !== void 0 ? t.size : null;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    const t = this.getScale();
    return new Ly({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: Array.isArray(t) ? t.slice() : t,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let t = this.normalizedAnchor_;
    if (!t) {
      t = this.anchor_;
      const r = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!r)
          return null;
        t = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (t[0] *= r[0]), this.anchorYUnits_ == "fraction" && (t[1] *= r[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!r)
          return null;
        t === this.anchor_ && (t = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (t[0] = -t[0] + r[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (t[1] = -t[1] + r[1]);
      }
      this.normalizedAnchor_ = t;
    }
    const n = this.getDisplacement(), s = this.getScaleArray();
    return [
      t[0] - n[0] / s[0],
      t[1] + n[1] / s[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(t) {
    this.anchor_ = t, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(t) {
    return this.iconImage_.getImage(t);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(t) {
    return this.iconImage_.getPixelRatio(t);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let t = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const n = this.getSize(), s = this.iconImage_.getSize();
      if (!n || !s)
        return null;
      t = t.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (t[0] = s[0] - n[0] - t[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (t[1] = s[1] - n[1] - t[1]);
    }
    return this.origin_ = t, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(t) {
    this.iconImage_.addEventListener(Kt.CHANGE, t);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(t) {
    this.iconImage_.removeEventListener(Kt.CHANGE, t);
  }
}
const vs = Ly;
function oC(e) {
  return new Mn({
    fill: gc(e, ""),
    stroke: vc(e, ""),
    text: WA(e),
    image: zA(e)
  });
}
function gc(e, t) {
  const n = e[t + "fill-color"];
  if (n)
    return new wr({ color: n });
}
function vc(e, t) {
  const n = e[t + "stroke-width"], s = e[t + "stroke-color"];
  if (!(!n && !s))
    return new vr({
      width: n,
      color: s,
      lineCap: e[t + "stroke-line-cap"],
      lineJoin: e[t + "stroke-line-join"],
      lineDash: e[t + "stroke-line-dash"],
      lineDashOffset: e[t + "stroke-line-dash-offset"],
      miterLimit: e[t + "stroke-miter-limit"]
    });
}
function WA(e) {
  const t = e["text-value"];
  return t ? new F1({
    text: t,
    font: e["text-font"],
    maxAngle: e["text-max-angle"],
    offsetX: e["text-offset-x"],
    offsetY: e["text-offset-y"],
    overflow: e["text-overflow"],
    placement: e["text-placement"],
    scale: e["text-scale"],
    rotateWithView: e["text-rotate-with-view"],
    rotation: e["text-rotation"],
    textAlign: e["text-align"],
    justify: e["text-justify"],
    textBaseline: e["text-baseline"],
    padding: e["text-padding"],
    fill: gc(e, "text-"),
    backgroundFill: gc(e, "text-background-"),
    stroke: vc(e, "text-"),
    backgroundStroke: vc(e, "text-background-")
  }) : void 0;
}
function zA(e) {
  const t = e["icon-src"], n = e["icon-img"];
  if (t || n)
    return new vs({
      src: t,
      img: n,
      imgSize: e["icon-img-size"],
      anchor: e["icon-anchor"],
      anchorOrigin: e["icon-anchor-origin"],
      anchorXUnits: e["icon-anchor-x-units"],
      anchorYUnits: e["icon-anchor-y-units"],
      color: e["icon-color"],
      crossOrigin: e["icon-cross-origin"],
      offset: e["icon-offset"],
      displacement: e["icon-displacement"],
      opacity: e["icon-opacity"],
      scale: e["icon-scale"],
      rotation: e["icon-rotation"],
      rotateWithView: e["icon-rotate-with-view"],
      size: e["icon-size"],
      declutterMode: e["icon-declutter-mode"]
    });
  const s = e["shape-points"];
  if (s) {
    const i = "shape-";
    return new V1({
      points: s,
      fill: gc(e, i),
      stroke: vc(e, i),
      radius: e["shape-radius"],
      radius1: e["shape-radius1"],
      radius2: e["shape-radius2"],
      angle: e["shape-angle"],
      displacement: e["shape-displacement"],
      rotation: e["shape-rotation"],
      rotateWithView: e["shape-rotate-with-view"],
      scale: e["shape-scale"],
      declutterMode: e["shape-declutter-mode"]
    });
  }
  const r = e["circle-radius"];
  if (r) {
    const i = "circle-";
    return new Ff({
      radius: r,
      fill: gc(e, i),
      stroke: vc(e, i),
      displacement: e["circle-displacement"],
      scale: e["circle-scale"],
      rotation: e["circle-rotation"],
      rotateWithView: e["circle-rotate-with-view"],
      declutterMode: e["circle-declutter-mode"]
    });
  }
}
const lC = {
  RENDER_ORDER: "renderOrder"
};
class KA extends hu {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = Object.assign({}, t);
    delete n.style, delete n.renderBuffer, delete n.updateWhileAnimating, delete n.updateWhileInteracting, super(n), this.declutter_ = t.declutter !== void 0 ? t.declutter : !1, this.renderBuffer_ = t.renderBuffer !== void 0 ? t.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(t.style), this.updateWhileAnimating_ = t.updateWhileAnimating !== void 0 ? t.updateWhileAnimating : !1, this.updateWhileInteracting_ = t.updateWhileInteracting !== void 0 ? t.updateWhileInteracting : !1;
  }
  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(lC.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    t.declutterTree || (t.declutterTree = new $1(9)), this.getRenderer().renderDeclutter(t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(t) {
    this.set(lC.RENDER_ORDER, t);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use "flat" style object literals instead of
   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(t) {
    let n;
    if (t === void 0)
      n = SA;
    else if (t === null)
      n = null;
    else if (typeof t == "function")
      n = t;
    else if (t instanceof Mn)
      n = t;
    else if (Array.isArray(t)) {
      const s = t.length, r = new Array(s);
      for (let i = 0; i < s; ++i) {
        const a = t[i];
        a instanceof Mn ? r[i] = a : r[i] = oC(a);
      }
      n = r;
    } else
      n = oC(t);
    this.style_ = n, this.styleFunction_ = t === null ? void 0 : PA(this.style_), this.changed();
  }
}
const z1 = KA, zc = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Ch = [zc.FILL], Da = [zc.STROKE], bo = [zc.BEGIN_PATH], uC = [zc.CLOSE_PATH], Yt = zc;
class GA {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(t, n, s, r) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(t) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(t) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(t, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(t, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(t, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(t, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(t, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(t, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(t, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(t, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(t, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(t, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(t, n) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(t, n) {
  }
}
const K1 = GA;
class kA extends K1 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(), this.tolerance = t, this.maxExtent = n, this.pixelRatio = r, this.maxLineWidth = 0, this.resolution = s, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(t) {
    const n = this.pixelRatio;
    return n == 1 ? t : t.map(function(s) {
      return s * n;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(t, n) {
    const s = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, i = this.coordinates;
    let a = i.length;
    for (let o = 0, l = t.length; o < l; o += n)
      r[0] = t[o], r[1] = t[o + 1], jc(s, r) && (i[a++] = r[0], i[a++] = r[1]);
    return a;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(t, n, s, r, i, a) {
    const o = this.coordinates;
    let l = o.length;
    const f = this.getBufferedMaxExtent();
    a && (n += r);
    let d = t[n], u = t[n + 1];
    const c = this.tmpCoordinate_;
    let h = !0, p, g, m;
    for (p = n + r; p < s; p += r)
      c[0] = t[p], c[1] = t[p + 1], m = Ag(f, c), m !== g ? (h && (o[l++] = d, o[l++] = u, h = !1), o[l++] = c[0], o[l++] = c[1]) : m === Wn.INTERSECTING ? (o[l++] = c[0], o[l++] = c[1], h = !1) : h = !0, d = c[0], u = c[1], g = m;
    return (i && h || p === n + r) && (o[l++] = d, o[l++] = u), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(t, n, s, r, i) {
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a], f = this.appendFlatLineCoordinates(
        t,
        n,
        l,
        r,
        !1,
        !1
      );
      i.push(f), n = l;
    }
    return n;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(t, n, s, r) {
    this.beginGeometry(t, n);
    const i = t.getType(), a = t.getStride(), o = this.coordinates.length;
    let l, f, d, u, c;
    switch (i) {
      case "MultiPolygon":
        l = /** @type {import("../../geom/MultiPolygon.js").default} */
        t.getOrientedFlatCoordinates(), u = [];
        const h = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        c = 0;
        for (let p = 0, g = h.length; p < g; ++p) {
          const m = [];
          c = this.drawCustomCoordinates_(
            l,
            c,
            h[p],
            a,
            m
          ), u.push(m);
        }
        this.instructions.push([
          Yt.CUSTOM,
          o,
          u,
          t,
          s,
          Ng
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          u,
          t,
          r || s,
          Ng
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        d = [], l = i == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          t.getOrientedFlatCoordinates()
        ) : t.getFlatCoordinates(), c = this.drawCustomCoordinates_(
          l,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          t.getEnds(),
          a,
          d
        ), this.instructions.push([
          Yt.CUSTOM,
          o,
          d,
          t,
          s,
          uc
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          d,
          t,
          r || s,
          uc
        ]);
        break;
      case "LineString":
      case "Circle":
        l = t.getFlatCoordinates(), f = this.appendFlatLineCoordinates(
          l,
          0,
          l.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s,
          _a
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s,
          _a
        ]);
        break;
      case "MultiPoint":
        l = t.getFlatCoordinates(), f = this.appendFlatPointCoordinates(l, a), f > o && (this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s,
          _a
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s,
          _a
        ]));
        break;
      case "Point":
        l = t.getFlatCoordinates(), this.coordinates.push(l[0], l[1]), f = this.coordinates.length, this.instructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          s
        ]), this.hitDetectionInstructions.push([
          Yt.CUSTOM,
          o,
          f,
          t,
          r || s
        ]);
        break;
    }
    this.endGeometry(n);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(t, n) {
    this.beginGeometryInstruction1_ = [
      Yt.BEGIN_GEOMETRY,
      n,
      0,
      t
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      Yt.BEGIN_GEOMETRY,
      n,
      0,
      t
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const t = this.hitDetectionInstructions;
    t.reverse();
    let n;
    const s = t.length;
    let r, i, a = -1;
    for (n = 0; n < s; ++n)
      r = t[n], i = /** @type {import("./Instruction.js").default} */
      r[0], i == Yt.END_GEOMETRY ? a = n : i == Yt.BEGIN_GEOMETRY && (r[2] = n, JI(this.hitDetectionInstructions, a, n), a = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
    const s = this.state;
    if (t) {
      const r = t.getColor();
      s.fillStyle = us(
        r || Zs
      );
    } else
      s.fillStyle = void 0;
    if (n) {
      const r = n.getColor();
      s.strokeStyle = us(
        r || fc
      );
      const i = n.getLineCap();
      s.lineCap = i !== void 0 ? i : _d;
      const a = n.getLineDash();
      s.lineDash = a ? a.slice() : cc;
      const o = n.getLineDashOffset();
      s.lineDashOffset = o || hc;
      const l = n.getLineJoin();
      s.lineJoin = l !== void 0 ? l : nu;
      const f = n.getWidth();
      s.lineWidth = f !== void 0 ? f : mc;
      const d = n.getMiterLimit();
      s.miterLimit = d !== void 0 ? d : dc, s.lineWidth > this.maxLineWidth && (this.maxLineWidth = s.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      s.strokeStyle = void 0, s.lineCap = void 0, s.lineDash = null, s.lineDashOffset = void 0, s.lineJoin = void 0, s.lineWidth = void 0, s.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(t) {
    const n = t.fillStyle, s = [Yt.SET_FILL_STYLE, n];
    return typeof n != "string" && s.push(!0), s;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    this.instructions.push(this.createStroke(t));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(t) {
    return [
      Yt.SET_STROKE_STYLE,
      t.strokeStyle,
      t.lineWidth * this.pixelRatio,
      t.lineCap,
      t.lineJoin,
      t.miterLimit,
      this.applyPixelRatio(t.lineDash),
      t.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(t, n) {
    const s = t.fillStyle;
    (typeof s != "string" || t.currentFillStyle != s) && (s !== void 0 && this.instructions.push(n.call(this, t)), t.currentFillStyle = s);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(t, n) {
    const s = t.strokeStyle, r = t.lineCap, i = t.lineDash, a = t.lineDashOffset, o = t.lineJoin, l = t.lineWidth, f = t.miterLimit;
    (t.currentStrokeStyle != s || t.currentLineCap != r || i != t.currentLineDash && !Jo(t.currentLineDash, i) || t.currentLineDashOffset != a || t.currentLineJoin != o || t.currentLineWidth != l || t.currentMiterLimit != f) && (s !== void 0 && n.call(this, t), t.currentStrokeStyle = s, t.currentLineCap = r, t.currentLineDash = i, t.currentLineDashOffset = a, t.currentLineJoin = o, t.currentLineWidth = l, t.currentMiterLimit = f);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(t) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const n = [Yt.END_GEOMETRY, t];
    this.instructions.push(n), this.hitDetectionInstructions.push(n);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = e1(this.maxExtent), this.maxLineWidth > 0)) {
      const t = this.resolution * (this.maxLineWidth + 1) / 2;
      Br(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const Kc = kA;
class HA extends Kc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(t, n);
    const s = t.getFlatCoordinates(), r = t.getStride(), i = this.coordinates.length, a = this.appendFlatPointCoordinates(s, r);
    this.instructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(t, n);
    const s = t.getFlatCoordinates(), r = t.getStride(), i = this.coordinates.length, a = this.appendFlatPointCoordinates(s, r);
    this.instructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_IMAGE,
      i,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(t, n) {
    const s = t.getAnchor(), r = t.getSize(), i = t.getOrigin();
    this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio), this.anchorX_ = s[0], this.anchorY_ = s[1], this.hitDetectionImage_ = t.getHitDetectionImage(), this.image_ = t.getImage(this.pixelRatio), this.height_ = r[1], this.opacity_ = t.getOpacity(), this.originX_ = i[0], this.originY_ = i[1], this.rotateWithView_ = t.getRotateWithView(), this.rotation_ = t.getRotation(), this.scale_ = t.getScaleArray(), this.width_ = r[0], this.declutterMode_ = t.getDeclutterMode(), this.declutterImageWithText_ = n;
  }
}
const YA = HA;
class XA extends Kc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(t, n, s, r) {
    const i = this.coordinates.length, a = this.appendFlatLineCoordinates(
      t,
      n,
      s,
      r,
      !1,
      !1
    ), o = [
      Yt.MOVE_TO_LINE_TO,
      i,
      a
    ];
    return this.instructions.push(o), this.hitDetectionInstructions.push(o), s;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(t, n) {
    const s = this.state, r = s.strokeStyle, i = s.lineWidth;
    if (r === void 0 || i === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, n), this.hitDetectionInstructions.push(
      [
        Yt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        cc,
        hc
      ],
      bo
    );
    const a = t.getFlatCoordinates(), o = t.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      o
    ), this.hitDetectionInstructions.push(Da), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(t, n) {
    const s = this.state, r = s.strokeStyle, i = s.lineWidth;
    if (r === void 0 || i === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(t, n), this.hitDetectionInstructions.push(
      [
        Yt.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        s.lineDash,
        s.lineDashOffset
      ],
      bo
    );
    const a = t.getEnds(), o = t.getFlatCoordinates(), l = t.getStride();
    let f = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      f = this.drawFlatCoordinates_(
        o,
        f,
        /** @type {number} */
        a[d],
        l
      );
    this.hitDetectionInstructions.push(Da), this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = this.state;
    return t.lastStroke != null && t.lastStroke != this.coordinates.length && this.instructions.push(Da), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(t) {
    t.lastStroke != null && t.lastStroke != this.coordinates.length && (this.instructions.push(Da), t.lastStroke = this.coordinates.length), t.lastStroke = 0, super.applyStroke(t), this.instructions.push(bo);
  }
}
const ZA = XA;
class JA extends Kc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(t, n, s, r) {
    const i = this.state, a = i.fillStyle !== void 0, o = i.strokeStyle !== void 0, l = s.length;
    this.instructions.push(bo), this.hitDetectionInstructions.push(bo);
    for (let f = 0; f < l; ++f) {
      const d = s[f], u = this.coordinates.length, c = this.appendFlatLineCoordinates(
        t,
        n,
        d,
        r,
        !0,
        !o
      ), h = [
        Yt.MOVE_TO_LINE_TO,
        u,
        c
      ];
      this.instructions.push(h), this.hitDetectionInstructions.push(h), o && (this.instructions.push(uC), this.hitDetectionInstructions.push(uC)), n = d;
    }
    return a && (this.instructions.push(Ch), this.hitDetectionInstructions.push(Ch)), o && (this.instructions.push(Da), this.hitDetectionInstructions.push(Da)), n;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Zs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getFlatCoordinates(), o = t.getStride(), l = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      o,
      !1,
      !1
    );
    const f = [Yt.CIRCLE, l];
    this.instructions.push(bo, f), this.hitDetectionInstructions.push(bo, f), s.fillStyle !== void 0 && (this.instructions.push(Ch), this.hitDetectionInstructions.push(Ch)), s.strokeStyle !== void 0 && (this.instructions.push(Da), this.hitDetectionInstructions.push(Da)), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Zs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getEnds(), o = t.getOrientedFlatCoordinates(), l = t.getStride();
    this.drawFlatCoordinatess_(
      o,
      0,
      /** @type {Array<number>} */
      a,
      l
    ), this.endGeometry(n);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(t, n) {
    const s = this.state, r = s.fillStyle, i = s.strokeStyle;
    if (r === void 0 && i === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(t, n), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_FILL_STYLE,
      Zs
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Yt.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      s.lineDash,
      s.lineDashOffset
    ]);
    const a = t.getEndss(), o = t.getOrientedFlatCoordinates(), l = t.getStride();
    let f = 0;
    for (let d = 0, u = a.length; d < u; ++d)
      f = this.drawFlatCoordinatess_(
        o,
        f,
        a[d],
        l
      );
    this.endGeometry(n);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const t = this.tolerance;
    if (t !== 0) {
      const n = this.coordinates;
      for (let s = 0, r = n.length; s < r; ++s)
        n[s] = Eo(n[s], t);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const t = this.state;
    t.fillStyle !== void 0 && this.updateFillStyle(t, this.createFill), t.strokeStyle !== void 0 && this.updateStrokeStyle(t, this.applyStroke);
  }
}
const cC = JA;
function QA(e, t, n, s, r) {
  let i = n, a = n, o = 0, l = 0, f = n, d, u, c, h, p, g, m, v, y, E;
  for (u = n; u < s; u += r) {
    const C = t[u], x = t[u + 1];
    p !== void 0 && (y = C - p, E = x - g, h = Math.sqrt(y * y + E * E), m !== void 0 && (l += c, d = Math.acos((m * y + v * E) / (c * h)), d > e && (l > o && (o = l, i = f, a = u), l = 0, f = u - r)), c = h, m = y, v = E), p = C, g = x;
  }
  return l += h, l > o ? [f, u] : [i, a];
}
const nc = {
  left: 0,
  end: 0,
  center: 0.5,
  right: 1,
  start: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class qA extends Kc {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    super(t, n, s, r), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const t = super.finish();
    return t.textStates = this.textStates, t.fillStates = this.fillStates, t.strokeStates = this.strokeStates, t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(t, n) {
    const s = this.textFillState_, r = this.textStrokeState_, i = this.textState_;
    if (this.text_ === "" || !i || !s && !r)
      return;
    const a = this.coordinates;
    let o = a.length;
    const l = t.getType();
    let f = null, d = t.getStride();
    if (i.placement === "line" && (l == "LineString" || l == "MultiLineString" || l == "Polygon" || l == "MultiPolygon")) {
      if (!hn(this.getBufferedMaxExtent(), t.getExtent()))
        return;
      let u;
      if (f = t.getFlatCoordinates(), l == "LineString")
        u = [f.length];
      else if (l == "MultiLineString")
        u = /** @type {import("../../geom/MultiLineString.js").default} */
        t.getEnds();
      else if (l == "Polygon")
        u = /** @type {import("../../geom/Polygon.js").default} */
        t.getEnds().slice(0, 1);
      else if (l == "MultiPolygon") {
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t.getEndss()
        );
        u = [];
        for (let m = 0, v = g.length; m < v; ++m)
          u.push(g[m][0]);
      }
      this.beginGeometry(t, n);
      const c = i.textAlign;
      let h = 0, p;
      for (let g = 0, m = u.length; g < m; ++g) {
        if (c == null) {
          const y = QA(
            i.maxAngle,
            f,
            h,
            u[g],
            d
          );
          h = y[0], p = y[1];
        } else
          p = u[g];
        for (let y = h; y < p; y += d)
          a.push(f[y], f[y + 1]);
        const v = a.length;
        h = u[g], this.drawChars_(o, v), o = v;
      }
      this.endGeometry(n);
    } else {
      let u = i.overflow ? null : [];
      switch (l) {
        case "Point":
        case "MultiPoint":
          f = /** @type {import("../../geom/MultiPoint.js").default} */
          t.getFlatCoordinates();
          break;
        case "LineString":
          f = /** @type {import("../../geom/LineString.js").default} */
          t.getFlatMidpoint();
          break;
        case "Circle":
          f = /** @type {import("../../geom/Circle.js").default} */
          t.getCenter();
          break;
        case "MultiLineString":
          f = /** @type {import("../../geom/MultiLineString.js").default} */
          t.getFlatMidpoints(), d = 2;
          break;
        case "Polygon":
          f = /** @type {import("../../geom/Polygon.js").default} */
          t.getFlatInteriorPoint(), i.overflow || u.push(f[2] / this.resolution), d = 3;
          break;
        case "MultiPolygon":
          const m = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            t.getFlatInteriorPoints()
          );
          f = [];
          for (let v = 0, y = m.length; v < y; v += 3)
            i.overflow || u.push(m[v + 2] / this.resolution), f.push(m[v], m[v + 1]);
          if (f.length === 0)
            return;
          d = 2;
          break;
      }
      const c = this.appendFlatPointCoordinates(f, d);
      if (c === o)
        return;
      if (u && (c - o) / 2 !== f.length / d) {
        let m = o / 2;
        u = u.filter((v, y) => {
          const E = a[(m + y) * 2] === f[y * d] && a[(m + y) * 2 + 1] === f[y * d + 1];
          return E || --m, E;
        });
      }
      this.saveTextStates_(), (i.backgroundFill || i.backgroundStroke) && (this.setFillStrokeStyle(
        i.backgroundFill,
        i.backgroundStroke
      ), i.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), i.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(t, n);
      let h = i.padding;
      if (h != xo && (i.scale[0] < 0 || i.scale[1] < 0)) {
        let m = i.padding[0], v = i.padding[1], y = i.padding[2], E = i.padding[3];
        i.scale[0] < 0 && (v = -v, E = -E), i.scale[1] < 0 && (m = -m, y = -y), h = [m, v, y, E];
      }
      const p = this.pixelRatio;
      this.instructions.push([
        Yt.DRAW_IMAGE,
        o,
        c,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        h == xo ? xo : h.map(function(m) {
          return m * p;
        }),
        !!i.backgroundFill,
        !!i.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]);
      const g = 1 / p;
      this.hitDetectionInstructions.push([
        Yt.DRAW_IMAGE,
        o,
        c,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [g, g],
        NaN,
        void 0,
        this.declutterImageWithText_,
        h,
        !!i.backgroundFill,
        !!i.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        u
      ]), this.endGeometry(n);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const t = this.textStrokeState_, n = this.textState_, s = this.textFillState_, r = this.strokeKey_;
    t && (r in this.strokeStates || (this.strokeStates[r] = {
      strokeStyle: t.strokeStyle,
      lineCap: t.lineCap,
      lineDashOffset: t.lineDashOffset,
      lineWidth: t.lineWidth,
      lineJoin: t.lineJoin,
      miterLimit: t.miterLimit,
      lineDash: t.lineDash
    }));
    const i = this.textKey_;
    i in this.textStates || (this.textStates[i] = {
      font: n.font,
      textAlign: n.textAlign || pc,
      justify: n.justify,
      textBaseline: n.textBaseline || Id,
      scale: n.scale
    });
    const a = this.fillKey_;
    s && (a in this.fillStates || (this.fillStates[a] = {
      fillStyle: s.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(t, n) {
    const s = this.textStrokeState_, r = this.textState_, i = this.strokeKey_, a = this.textKey_, o = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, f = nc[r.textBaseline], d = this.textOffsetY_ * l, u = this.text_, c = s ? s.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
    this.instructions.push([
      Yt.DRAW_CHARS,
      t,
      n,
      f,
      r.overflow,
      o,
      r.maxAngle,
      l,
      d,
      i,
      c * l,
      u,
      a,
      1
    ]), this.hitDetectionInstructions.push([
      Yt.DRAW_CHARS,
      t,
      n,
      f,
      r.overflow,
      o,
      r.maxAngle,
      1,
      d,
      i,
      c,
      u,
      a,
      1 / l
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(t, n) {
    let s, r, i;
    if (!t)
      this.text_ = "";
    else {
      const a = t.getFill();
      a ? (r = this.textFillState_, r || (r = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = r), r.fillStyle = us(
        a.getColor() || Zs
      )) : (r = null, this.textFillState_ = r);
      const o = t.getStroke();
      if (!o)
        i = null, this.textStrokeState_ = i;
      else {
        i = this.textStrokeState_, i || (i = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = i);
        const p = o.getLineDash(), g = o.getLineDashOffset(), m = o.getWidth(), v = o.getMiterLimit();
        i.lineCap = o.getLineCap() || _d, i.lineDash = p ? p.slice() : cc, i.lineDashOffset = g === void 0 ? hc : g, i.lineJoin = o.getLineJoin() || nu, i.lineWidth = m === void 0 ? mc : m, i.miterLimit = v === void 0 ? dc : v, i.strokeStyle = us(
          o.getColor() || fc
        );
      }
      s = this.textState_;
      const l = t.getFont() || R1;
      CA(l);
      const f = t.getScaleArray();
      s.overflow = t.getOverflow(), s.font = l, s.maxAngle = t.getMaxAngle(), s.placement = t.getPlacement(), s.textAlign = t.getTextAlign(), s.justify = t.getJustify(), s.textBaseline = t.getTextBaseline() || Id, s.backgroundFill = t.getBackgroundFill(), s.backgroundStroke = t.getBackgroundStroke(), s.padding = t.getPadding() || xo, s.scale = f === void 0 ? [1, 1] : f;
      const d = t.getOffsetX(), u = t.getOffsetY(), c = t.getRotateWithView(), h = t.getRotation();
      this.text_ = t.getText() || "", this.textOffsetX_ = d === void 0 ? 0 : d, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = c === void 0 ? !1 : c, this.textRotation_ = h === void 0 ? 0 : h, this.strokeKey_ = i ? (typeof i.strokeStyle == "string" ? i.strokeStyle : Xt(i.strokeStyle)) + i.lineCap + i.lineDashOffset + "|" + i.lineWidth + i.lineJoin + i.miterLimit + "[" + i.lineDash.join() + "]" : "", this.textKey_ = s.font + s.scale + (s.textAlign || "?") + (s.justify || "?") + (s.textBaseline || "?"), this.fillKey_ = r ? typeof r.fillStyle == "string" ? r.fillStyle : "|" + Xt(r.fillStyle) : "";
    }
    this.declutterImageWithText_ = n;
  }
}
const tL = {
  Circle: cC,
  Default: Kc,
  Image: YA,
  LineString: ZA,
  Polygon: cC,
  Text: qA
};
class eL {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(t, n, s, r) {
    this.tolerance_ = t, this.maxExtent_ = n, this.pixelRatio_ = r, this.resolution_ = s, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const t = {};
    for (const n in this.buildersByZIndex_) {
      t[n] = t[n] || {};
      const s = this.buildersByZIndex_[n];
      for (const r in s) {
        const i = s[r].finish();
        t[n][r] = i;
      }
    }
    return t;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(t, n) {
    const s = t !== void 0 ? t.toString() : "0";
    let r = this.buildersByZIndex_[s];
    r === void 0 && (r = {}, this.buildersByZIndex_[s] = r);
    let i = r[n];
    if (i === void 0) {
      const a = tL[n];
      i = new a(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), r[n] = i;
    }
    return i;
  }
}
const Ld = eL;
class nL extends ZO {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = t, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(t) {
    return Gt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(t) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return Gt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    return Gt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, n, s) {
    t[n] || (t[n] = {}), t[n][s.tileCoord.toString()] = s;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(t, n, s) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */
      (function(r, i) {
        const a = this.loadedTileCallback.bind(this, s, r);
        return t.forEachLoadedTile(n, r, i, a);
      }).bind(this)
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(t) {
    /** @type {import("../Image.js").default} */
    t.target.getState() === he.LOADED && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(t) {
    let n = t.getState();
    return n != he.LOADED && n != he.ERROR && t.addEventListener(Kt.CHANGE, this.boundHandleImageChange_), n == he.IDLE && (t.load(), n = t.getState()), n == he.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const t = this.getLayer();
    t && t.getVisible() && t.getSourceState() === "ready" && t.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const iL = nL;
class rL extends Wi {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(t, n, s, r) {
    super(t), this.inversePixelTransform = n, this.frameState = s, this.context = r;
  }
}
const G1 = rL, hC = [];
let yl = null;
function sL() {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1, yl = e.getContext("2d");
}
class aL extends iL {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(t) {
    super(t), this.container = null, this.renderedResolution, this.tempTransform = tr(), this.pixelTransform = tr(), this.inversePixelTransform = tr(), this.context = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(t, n, s) {
    yl || sL(), yl.clearRect(0, 0, 1, 1);
    let r;
    try {
      yl.drawImage(t, n, s, 1, 1, 0, 0, 1, 1), r = yl.getImageData(0, 0, 1, 1).data;
    } catch {
      return yl = null, null;
    }
    return r;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(t) {
    let s = this.getLayer().getBackground();
    return typeof s == "function" && (s = s(t.viewState.resolution)), s || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(t, n, s) {
    const r = this.getLayer().getClassName();
    let i, a;
    if (t && t.className === r && (!s || t && t.style.backgroundColor && Jo(
      Sd(t.style.backgroundColor),
      Sd(s)
    ))) {
      const o = t.firstElementChild;
      o instanceof HTMLCanvasElement && (a = o.getContext("2d"));
    }
    if (a && a.canvas.style.transform === n ? (this.container = t, this.context = a, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
      i = document.createElement("div"), i.className = r;
      let o = i.style;
      o.position = "absolute", o.width = "100%", o.height = "100%", a = Di();
      const l = a.canvas;
      i.appendChild(l), o = l.style, o.position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = i, this.context = a;
    }
    !this.containerReused && s && !this.container.style.backgroundColor && (this.container.style.backgroundColor = s);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(t, n, s) {
    const r = gs(s), i = Mo(s), a = Ql(s), o = So(s);
    Ln(n.coordinateToPixelTransform, r), Ln(n.coordinateToPixelTransform, i), Ln(n.coordinateToPixelTransform, a), Ln(n.coordinateToPixelTransform, o);
    const l = this.inversePixelTransform;
    Ln(l, r), Ln(l, i), Ln(l, a), Ln(l, o), t.save(), t.beginPath(), t.moveTo(Math.round(r[0]), Math.round(r[1])), t.lineTo(Math.round(i[0]), Math.round(i[1])), t.lineTo(Math.round(a[0]), Math.round(a[1])), t.lineTo(Math.round(o[0]), Math.round(o[1])), t.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(t, n, s) {
    const r = this.getLayer();
    if (r.hasListener(t)) {
      const i = new G1(
        t,
        this.inversePixelTransform,
        s,
        n
      );
      r.dispatchEvent(i);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(t, n) {
    this.frameState = n, this.dispatchRenderEvent_(Fa.PRERENDER, t, n);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(t, n) {
    this.dispatchRenderEvent_(Fa.POSTRENDER, t, n);
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(t, n, s, r, i, a, o) {
    const l = i / 2, f = a / 2, d = r / n, u = -d, c = -t[0] + o, h = -t[1];
    return $r(
      this.tempTransform,
      l,
      f,
      d,
      u,
      -s,
      c,
      h
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const Ry = aL;
function oL(e, t, n, s, r, i, a, o, l, f, d, u) {
  let c = e[t], h = e[t + 1], p = 0, g = 0, m = 0, v = 0;
  function y() {
    p = c, g = h, t += s, c = e[t], h = e[t + 1], v += m, m = Math.sqrt((c - p) * (c - p) + (h - g) * (h - g));
  }
  do
    y();
  while (t < n - s && v + m < i);
  let E = m === 0 ? 0 : (i - v) / m;
  const C = Us(p, c, E), x = Us(g, h, E), b = t - s, P = v, O = i + o * l(f, r, d);
  for (; t < n - s && v + m < O; )
    y();
  E = m === 0 ? 0 : (O - v) / m;
  const T = Us(p, c, E), M = Us(g, h, E);
  let L;
  if (u) {
    const B = [C, x, T, M];
    dy(B, 0, 4, 2, u, B, B), L = B[0] > B[2];
  } else
    L = C > T;
  const A = Math.PI, D = [], I = b + s === t;
  t = b, m = 0, v = P, c = e[t], h = e[t + 1];
  let w;
  if (I) {
    y(), w = Math.atan2(h - g, c - p), L && (w += w > 0 ? -A : A);
    const B = (T + C) / 2, j = (M + x) / 2;
    return D[0] = [B, j, (O - i) / 2, w, r], D;
  }
  r = r.replace(/\n/g, " ");
  for (let B = 0, j = r.length; B < j; ) {
    y();
    let k = Math.atan2(h - g, c - p);
    if (L && (k += k > 0 ? -A : A), w !== void 0) {
      let vt = k - w;
      if (vt += vt > A ? -2 * A : vt < -A ? 2 * A : 0, Math.abs(vt) > a)
        return null;
    }
    w = k;
    const X = B;
    let rt = 0;
    for (; B < j; ++B) {
      const vt = L ? j - B - 1 : B, bt = o * l(f, r[vt], d);
      if (t + s < n && v + m < i + rt + bt / 2)
        break;
      rt += bt;
    }
    if (B === X)
      continue;
    const et = L ? r.substring(j - X, j - B) : r.substring(X, B);
    E = m === 0 ? 0 : (i + rt / 2 - v) / m;
    const Z = Us(p, c, E), dt = Us(g, h, E);
    D.push([Z, dt, rt / 2, k, et]), i += rt;
  }
  return D;
}
const ul = ji(), ma = [], As = [], Ls = [], ga = [];
function dC(e) {
  return e[3].declutterBox;
}
const lL = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function fC(e, t) {
  return (t === "start" || t === "end") && !lL.test(e) && (t = t === "start" ? "left" : "right"), nc[t];
}
function uL(e, t, n) {
  return n > 0 && e.push(`
`, ""), e.push(t, ""), e;
}
class cL {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(t, n, s, r) {
    this.overlaps = s, this.pixelRatio = n, this.resolution = t, this.alignFill_, this.instructions = r.instructions, this.coordinates = r.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = tr(), this.hitDetectionInstructions = r.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = r.fillStates || {}, this.strokeStates = r.strokeStates || {}, this.textStates = r.textStates || {}, this.widths_ = {}, this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(t, n, s, r) {
    const i = t + n + s + r;
    if (this.labels_[i])
      return this.labels_[i];
    const a = r ? this.strokeStates[r] : null, o = s ? this.fillStates[s] : null, l = this.textStates[n], f = this.pixelRatio, d = [
      l.scale[0] * f,
      l.scale[1] * f
    ], u = Array.isArray(t), c = l.justify ? nc[l.justify] : fC(
      Array.isArray(t) ? t[0] : t,
      l.textAlign || pc
    ), h = r && a.lineWidth ? a.lineWidth : 0, p = u ? t : t.split(`
`).reduce(uL, []), { width: g, height: m, widths: v, heights: y, lineWidths: E } = bA(
      l,
      p
    ), C = g + h, x = [], b = (C + 2) * d[0], P = (m + h) * d[1], O = {
      width: b < 0 ? Math.floor(b) : Math.ceil(b),
      height: P < 0 ? Math.floor(P) : Math.ceil(P),
      contextInstructions: x
    };
    (d[0] != 1 || d[1] != 1) && x.push("scale", d), r && (x.push("strokeStyle", a.strokeStyle), x.push("lineWidth", h), x.push("lineCap", a.lineCap), x.push("lineJoin", a.lineJoin), x.push("miterLimit", a.miterLimit), x.push("setLineDash", [a.lineDash]), x.push("lineDashOffset", a.lineDashOffset)), s && x.push("fillStyle", o.fillStyle), x.push("textBaseline", "middle"), x.push("textAlign", "center");
    const T = 0.5 - c;
    let M = c * C + T * h;
    const L = [], A = [];
    let D = 0, I = 0, w = 0, B = 0, j;
    for (let k = 0, X = p.length; k < X; k += 2) {
      const rt = p[k];
      if (rt === `
`) {
        I += D, D = 0, M = c * C + T * h, ++B;
        continue;
      }
      const et = p[k + 1] || l.font;
      et !== j && (r && L.push("font", et), s && A.push("font", et), j = et), D = Math.max(D, y[w]);
      const Z = [
        rt,
        M + T * v[w] + c * (v[w] - E[B]),
        0.5 * (h + D) + I
      ];
      M += v[w], r && L.push("strokeText", Z), s && A.push("fillText", Z), ++w;
    }
    return Array.prototype.push.apply(x, L), Array.prototype.push.apply(x, A), this.labels_[i] = O, O;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(t, n, s, r, i, a, o) {
    t.beginPath(), t.moveTo.apply(t, n), t.lineTo.apply(t, s), t.lineTo.apply(t, r), t.lineTo.apply(t, i), t.lineTo.apply(t, n), a && (this.alignFill_ = /** @type {boolean} */
    a[2], this.fill_(t)), o && (this.setStrokeStyle_(
      t,
      /** @type {Array<*>} */
      o
    ), t.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m) {
    o *= c[0], l *= c[1];
    let v = s - o, y = r - l;
    const E = i + f > t ? t - f : i, C = a + d > n ? n - d : a, x = p[3] + E * c[0] + p[1], b = p[0] + C * c[1] + p[2], P = v - p[3], O = y - p[0];
    (g || u !== 0) && (ma[0] = P, ga[0] = P, ma[1] = O, As[1] = O, As[0] = P + x, Ls[0] = As[0], Ls[1] = O + b, ga[1] = Ls[1]);
    let T;
    return u !== 0 ? (T = $r(
      tr(),
      s,
      r,
      1,
      1,
      u,
      -s,
      -r
    ), Ln(T, ma), Ln(T, As), Ln(T, Ls), Ln(T, ga), ir(
      Math.min(ma[0], As[0], Ls[0], ga[0]),
      Math.min(ma[1], As[1], Ls[1], ga[1]),
      Math.max(ma[0], As[0], Ls[0], ga[0]),
      Math.max(ma[1], As[1], Ls[1], ga[1]),
      ul
    )) : ir(
      Math.min(P, P + x),
      Math.min(O, O + b),
      Math.max(P, P + x),
      Math.max(O, O + b),
      ul
    ), h && (v = Math.round(v), y = Math.round(y)), {
      drawImageX: v,
      drawImageY: y,
      drawImageW: E,
      drawImageH: C,
      originX: f,
      originY: d,
      declutterBox: {
        minX: ul[0],
        minY: ul[1],
        maxX: ul[2],
        maxY: ul[3],
        value: m
      },
      canvasTransform: T,
      scale: c
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(t, n, s, r, i, a, o) {
    const l = !!(a || o), f = r.declutterBox, d = t.canvas, u = o ? o[2] * r.scale[0] / 2 : 0;
    return f.minX - u <= d.width / n && f.maxX + u >= 0 && f.minY - u <= d.height / n && f.maxY + u >= 0 && (l && this.replayTextBackground_(
      t,
      ma,
      As,
      Ls,
      ga,
      /** @type {Array<*>} */
      a,
      /** @type {Array<*>} */
      o
    ), TA(
      t,
      r.canvasTransform,
      i,
      s,
      r.originX,
      r.originY,
      r.drawImageW,
      r.drawImageH,
      r.drawImageX,
      r.drawImageY,
      r.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(t) {
    if (this.alignFill_) {
      const n = Ln(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
      t.save(), t.translate(n[0] % s, n[1] % s), t.rotate(this.viewRotation_);
    }
    t.fill(), this.alignFill_ && t.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(t, n) {
    t.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    n[1], t.lineWidth = /** @type {number} */
    n[2], t.lineCap = /** @type {CanvasLineCap} */
    n[3], t.lineJoin = /** @type {CanvasLineJoin} */
    n[4], t.miterLimit = /** @type {number} */
    n[5], t.lineDashOffset = /** @type {number} */
    n[7], t.setLineDash(
      /** @type {Array<number>} */
      n[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(t, n, s, r) {
    const i = this.textStates[n], a = this.createLabel(t, n, r, s), o = this.strokeStates[s], l = this.pixelRatio, f = fC(
      Array.isArray(t) ? t[0] : t,
      i.textAlign || pc
    ), d = nc[i.textBaseline || Id], u = o && o.lineWidth ? o.lineWidth : 0, c = a.width / l - 2 * i.scale[0], h = f * c + 2 * (0.5 - f) * u, p = d * a.height / l + 2 * (0.5 - d) * u;
    return {
      label: a,
      anchorX: h,
      anchorY: p
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(t, n, s, r, i, a, o, l) {
    let f;
    this.pixelCoordinates_ && Jo(s, this.renderedTransform_) ? f = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), f = Ba(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      s,
      this.pixelCoordinates_
    ), hD(this.renderedTransform_, s));
    let d = 0;
    const u = r.length;
    let c = 0, h, p, g, m, v, y, E, C, x, b, P, O, T = 0, M = 0, L = null, A = null;
    const D = this.coordinateCache_, I = this.viewRotation_, w = Math.round(Math.atan2(-s[1], s[0]) * 1e12) / 1e12, B = (
      /** @type {import("../../render.js").State} */
      {
        context: t,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: I
      }
    ), j = this.instructions != r || this.overlaps ? 0 : 200;
    let k, X, rt, et;
    for (; d < u; ) {
      const Z = r[d];
      switch (
        /** @type {import("./Instruction.js").default} */
        Z[0]
      ) {
        case Yt.BEGIN_GEOMETRY:
          k = /** @type {import("../../Feature.js").FeatureLike} */
          Z[1], et = Z[3], k.getGeometry() ? o !== void 0 && !hn(o, et.getExtent()) ? d = /** @type {number} */
          Z[2] + 1 : ++d : d = /** @type {number} */
          Z[2];
          break;
        case Yt.BEGIN_PATH:
          T > j && (this.fill_(t), T = 0), M > j && (t.stroke(), M = 0), !T && !M && (t.beginPath(), m = NaN, v = NaN), ++d;
          break;
        case Yt.CIRCLE:
          c = /** @type {number} */
          Z[1];
          const vt = f[c], bt = f[c + 1], it = f[c + 2], R = f[c + 3], V = it - vt, tt = R - bt, Y = Math.sqrt(V * V + tt * tt);
          t.moveTo(vt + Y, bt), t.arc(vt, bt, Y, 0, 2 * Math.PI, !0), ++d;
          break;
        case Yt.CLOSE_PATH:
          t.closePath(), ++d;
          break;
        case Yt.CUSTOM:
          c = /** @type {number} */
          Z[1], h = Z[2];
          const W = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            Z[3]
          ), z = Z[4], at = Z.length == 6 ? Z[5] : void 0;
          B.geometry = W, B.feature = k, d in D || (D[d] = []);
          const ct = D[d];
          at ? at(f, c, h, 2, ct) : (ct[0] = f[c], ct[1] = f[c + 1], ct.length = 2), z(ct, B), ++d;
          break;
        case Yt.DRAW_IMAGE:
          c = /** @type {number} */
          Z[1], h = /** @type {number} */
          Z[2], C = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          Z[3], p = /** @type {number} */
          Z[4], g = /** @type {number} */
          Z[5];
          let Mt = (
            /** @type {number} */
            Z[6]
          );
          const N = (
            /** @type {number} */
            Z[7]
          ), S = (
            /** @type {number} */
            Z[8]
          ), _ = (
            /** @type {number} */
            Z[9]
          ), F = (
            /** @type {boolean} */
            Z[10]
          );
          let G = (
            /** @type {number} */
            Z[11]
          );
          const nt = (
            /** @type {import("../../size.js").Size} */
            Z[12]
          );
          let lt = (
            /** @type {number} */
            Z[13]
          );
          const yt = (
            /** @type {"declutter"|"obstacle"|"none"|undefined} */
            Z[14]
          ), Lt = (
            /** @type {import("../canvas.js").DeclutterImageWithText} */
            Z[15]
          );
          if (!C && Z.length >= 20) {
            x = /** @type {string} */
            Z[19], b = /** @type {string} */
            Z[20], P = /** @type {string} */
            Z[21], O = /** @type {string} */
            Z[22];
            const we = this.drawLabelWithPointPlacement_(
              x,
              b,
              P,
              O
            );
            C = we.label, Z[3] = C;
            const vn = (
              /** @type {number} */
              Z[23]
            );
            p = (we.anchorX - vn) * this.pixelRatio, Z[4] = p;
            const ze = (
              /** @type {number} */
              Z[24]
            );
            g = (we.anchorY - ze) * this.pixelRatio, Z[5] = g, Mt = C.height, Z[6] = Mt, lt = C.width, Z[13] = lt;
          }
          let Ft;
          Z.length > 25 && (Ft = /** @type {number} */
          Z[25]);
          let Jt, J, ft;
          Z.length > 17 ? (Jt = /** @type {Array<number>} */
          Z[16], J = /** @type {boolean} */
          Z[17], ft = /** @type {boolean} */
          Z[18]) : (Jt = xo, J = !1, ft = !1), F && w ? G += I : !F && !w && (G -= I);
          let Ct = 0;
          for (; c < h; c += 2) {
            if (Ft && Ft[Ct++] < lt / this.pixelRatio)
              continue;
            const we = this.calculateImageOrLabelDimensions_(
              C.width,
              C.height,
              f[c],
              f[c + 1],
              lt,
              Mt,
              p,
              g,
              S,
              _,
              G,
              nt,
              i,
              Jt,
              J || ft,
              k
            ), vn = [
              t,
              n,
              C,
              we,
              N,
              J ? (
                /** @type {Array<*>} */
                L
              ) : null,
              ft ? (
                /** @type {Array<*>} */
                A
              ) : null
            ];
            if (l) {
              if (yt === "none")
                continue;
              if (yt === "obstacle") {
                l.insert(we.declutterBox);
                continue;
              } else {
                let ze, Tn;
                if (Lt) {
                  const tn = h - c;
                  if (!Lt[tn]) {
                    Lt[tn] = vn;
                    continue;
                  }
                  if (ze = Lt[tn], delete Lt[tn], Tn = dC(ze), l.collides(Tn))
                    continue;
                }
                if (l.collides(we.declutterBox))
                  continue;
                ze && (l.insert(Tn), this.replayImageOrLabel_.apply(this, ze)), l.insert(we.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, vn);
          }
          ++d;
          break;
        case Yt.DRAW_CHARS:
          const St = (
            /** @type {number} */
            Z[1]
          ), Tt = (
            /** @type {number} */
            Z[2]
          ), kt = (
            /** @type {number} */
            Z[3]
          ), fe = (
            /** @type {number} */
            Z[4]
          );
          O = /** @type {string} */
          Z[5];
          const Se = (
            /** @type {number} */
            Z[6]
          ), Me = (
            /** @type {number} */
            Z[7]
          ), xe = (
            /** @type {number} */
            Z[8]
          );
          P = /** @type {string} */
          Z[9];
          const We = (
            /** @type {number} */
            Z[10]
          );
          x = /** @type {string} */
          Z[11], b = /** @type {string} */
          Z[12];
          const bn = [
            /** @type {number} */
            Z[13],
            /** @type {number} */
            Z[13]
          ], Ye = this.textStates[b], Hn = Ye.font, pn = [
            Ye.scale[0] * Me,
            Ye.scale[1] * Me
          ];
          let Ne;
          Hn in this.widths_ ? Ne = this.widths_[Hn] : (Ne = {}, this.widths_[Hn] = Ne);
          const mn = S1(f, St, Tt, 2), gn = Math.abs(pn[0]) * iC(Hn, x, Ne);
          if (fe || gn <= mn) {
            const we = this.textStates[b].textAlign, vn = (mn - gn) * nc[we], ze = oL(
              f,
              St,
              Tt,
              2,
              x,
              vn,
              Se,
              Math.abs(pn[0]),
              iC,
              Hn,
              Ne,
              w ? 0 : this.viewRotation_
            );
            t:
              if (ze) {
                const Tn = [];
                let tn, ae, gi, Xe, an;
                if (P)
                  for (tn = 0, ae = ze.length; tn < ae; ++tn) {
                    an = ze[tn], gi = /** @type {string} */
                    an[4], Xe = this.createLabel(gi, b, "", P), p = /** @type {number} */
                    an[2] + (pn[0] < 0 ? -We : We), g = kt * Xe.height + (0.5 - kt) * 2 * We * pn[1] / pn[0] - xe;
                    const $e = this.calculateImageOrLabelDimensions_(
                      Xe.width,
                      Xe.height,
                      an[0],
                      an[1],
                      Xe.width,
                      Xe.height,
                      p,
                      g,
                      0,
                      0,
                      an[3],
                      bn,
                      !1,
                      xo,
                      !1,
                      k
                    );
                    if (l && l.collides($e.declutterBox))
                      break t;
                    Tn.push([
                      t,
                      n,
                      Xe,
                      $e,
                      1,
                      null,
                      null
                    ]);
                  }
                if (O)
                  for (tn = 0, ae = ze.length; tn < ae; ++tn) {
                    an = ze[tn], gi = /** @type {string} */
                    an[4], Xe = this.createLabel(gi, b, O, ""), p = /** @type {number} */
                    an[2], g = kt * Xe.height - xe;
                    const $e = this.calculateImageOrLabelDimensions_(
                      Xe.width,
                      Xe.height,
                      an[0],
                      an[1],
                      Xe.width,
                      Xe.height,
                      p,
                      g,
                      0,
                      0,
                      an[3],
                      bn,
                      !1,
                      xo,
                      !1,
                      k
                    );
                    if (l && l.collides($e.declutterBox))
                      break t;
                    Tn.push([
                      t,
                      n,
                      Xe,
                      $e,
                      1,
                      null,
                      null
                    ]);
                  }
                l && l.load(Tn.map(dC));
                for (let $e = 0, Vn = Tn.length; $e < Vn; ++$e)
                  this.replayImageOrLabel_.apply(this, Tn[$e]);
              }
          }
          ++d;
          break;
        case Yt.END_GEOMETRY:
          if (a !== void 0) {
            k = /** @type {import("../../Feature.js").FeatureLike} */
            Z[1];
            const we = a(k, et);
            if (we)
              return we;
          }
          ++d;
          break;
        case Yt.FILL:
          j ? T++ : this.fill_(t), ++d;
          break;
        case Yt.MOVE_TO_LINE_TO:
          for (c = /** @type {number} */
          Z[1], h = /** @type {number} */
          Z[2], X = f[c], rt = f[c + 1], y = X + 0.5 | 0, E = rt + 0.5 | 0, (y !== m || E !== v) && (t.moveTo(X, rt), m = y, v = E), c += 2; c < h; c += 2)
            X = f[c], rt = f[c + 1], y = X + 0.5 | 0, E = rt + 0.5 | 0, (c == h - 2 || y !== m || E !== v) && (t.lineTo(X, rt), m = y, v = E);
          ++d;
          break;
        case Yt.SET_FILL_STYLE:
          L = Z, this.alignFill_ = Z[2], T && (this.fill_(t), T = 0, M && (t.stroke(), M = 0)), t.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
          Z[1], ++d;
          break;
        case Yt.SET_STROKE_STYLE:
          A = Z, M && (t.stroke(), M = 0), this.setStrokeStyle_(
            t,
            /** @type {Array<*>} */
            Z
          ), ++d;
          break;
        case Yt.STROKE:
          j ? M++ : t.stroke(), ++d;
          break;
        default:
          ++d;
          break;
      }
    }
    T && this.fill_(t), M && t.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, n, s, r, i, a) {
    this.viewRotation_ = r, this.execute_(
      t,
      n,
      s,
      this.instructions,
      i,
      void 0,
      void 0,
      a
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(t, n, s, r, i) {
    return this.viewRotation_ = s, this.execute_(
      t,
      1,
      n,
      this.hitDetectionInstructions,
      !0,
      r,
      i
    );
  }
}
const hL = cL, Cp = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class dL {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(t, n, s, r, i, a) {
    this.maxExtent_ = t, this.overlaps_ = r, this.pixelRatio_ = s, this.resolution_ = n, this.renderBuffer_ = a, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = tr(), this.createExecutors_(i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(t, n) {
    const s = this.getClipCoords(n);
    t.beginPath(), t.moveTo(s[0], s[1]), t.lineTo(s[2], s[3]), t.lineTo(s[4], s[5]), t.lineTo(s[6], s[7]), t.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(t) {
    for (const n in t) {
      let s = this.executorsByZIndex_[n];
      s === void 0 && (s = {}, this.executorsByZIndex_[n] = s);
      const r = t[n];
      for (const i in r) {
        const a = r[i];
        s[i] = new hL(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(t) {
    for (const n in this.executorsByZIndex_) {
      const s = this.executorsByZIndex_[n];
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r] in s)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i, a) {
    r = Math.round(r);
    const o = r * 2 + 1, l = $r(
      this.hitDetectionTransform_,
      r + 0.5,
      r + 0.5,
      1 / n,
      -1 / n,
      -s,
      -t[0],
      -t[1]
    ), f = !this.hitDetectionContext_;
    f && (this.hitDetectionContext_ = Di(
      o,
      o
    ));
    const d = this.hitDetectionContext_;
    d.canvas.width !== o || d.canvas.height !== o ? (d.canvas.width = o, d.canvas.height = o) : f || d.clearRect(0, 0, o, o);
    let u;
    this.renderBuffer_ !== void 0 && (u = ji(), ec(u, t), Br(
      u,
      n * (this.renderBuffer_ + r),
      u
    ));
    const c = fL(r);
    let h;
    function p(x, b) {
      const P = d.getImageData(
        0,
        0,
        o,
        o
      ).data;
      for (let O = 0, T = c.length; O < T; O++)
        if (P[c[O]] > 0) {
          if (!a || h !== "Image" && h !== "Text" || a.includes(x)) {
            const M = (c[O] - 3) / 4, L = r - M % o, A = r - (M / o | 0), D = i(x, b, L * L + A * A);
            if (D)
              return D;
          }
          d.clearRect(0, 0, o, o);
          break;
        }
    }
    const g = Object.keys(this.executorsByZIndex_).map(Number);
    g.sort(wo);
    let m, v, y, E, C;
    for (m = g.length - 1; m >= 0; --m) {
      const x = g[m].toString();
      for (y = this.executorsByZIndex_[x], v = Cp.length - 1; v >= 0; --v)
        if (h = Cp[v], E = y[h], E !== void 0 && (C = E.executeHitDetection(
          d,
          l,
          s,
          p,
          u
        ), C))
          return C;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(t) {
    const n = this.maxExtent_;
    if (!n)
      return null;
    const s = n[0], r = n[1], i = n[2], a = n[3], o = [s, r, s, a, i, a, i, r];
    return Ba(o, 0, 8, 2, t, o), o;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Bo(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(t, n, s, r, i, a, o) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(wo), this.maxExtent_ && (t.save(), this.clip(t, s)), a = a || Cp;
    let f, d, u, c, h, p;
    for (o && l.reverse(), f = 0, d = l.length; f < d; ++f) {
      const g = l[f].toString();
      for (h = this.executorsByZIndex_[g], u = 0, c = a.length; u < c; ++u) {
        const m = a[u];
        p = h[m], p !== void 0 && p.execute(
          t,
          n,
          s,
          r,
          i,
          o
        );
      }
    }
    this.maxExtent_ && t.restore();
  }
}
const xp = {};
function fL(e) {
  if (xp[e] !== void 0)
    return xp[e];
  const t = e * 2 + 1, n = e * e, s = new Array(n + 1);
  for (let i = 0; i <= e; ++i)
    for (let a = 0; a <= e; ++a) {
      const o = i * i + a * a;
      if (o > n)
        break;
      let l = s[o];
      l || (l = [], s[o] = l), l.push(((e + i) * t + (e + a)) * 4 + 3), i > 0 && l.push(((e - i) * t + (e + a)) * 4 + 3), a > 0 && (l.push(((e + i) * t + (e - a)) * 4 + 3), i > 0 && l.push(((e - i) * t + (e - a)) * 4 + 3));
    }
  const r = [];
  for (let i = 0, a = s.length; i < a; ++i)
    s[i] && r.push(...s[i]);
  return xp[e] = r, r;
}
const Rd = dL, en = {
  ANIMATING: 0,
  INTERACTING: 1
};
class pL extends K1 {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(t, n, s, r, i, a, o) {
    super(), this.context_ = t, this.pixelRatio_ = n, this.extent_ = s, this.transform_ = r, this.viewRotation_ = i, this.squaredTolerance_ = a, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = tr();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(t, n, s, r) {
    if (!this.image_)
      return;
    const i = Ba(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_, o = this.tmpLocalTransform_, l = a.globalAlpha;
    this.imageOpacity_ != 1 && (a.globalAlpha = l * this.imageOpacity_);
    let f = this.imageRotation_;
    this.imageRotateWithView_ && (f += this.viewRotation_);
    for (let d = 0, u = i.length; d < u; d += 2) {
      const c = i[d] - this.imageAnchorX_, h = i[d + 1] - this.imageAnchorY_;
      if (f !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const p = c + this.imageAnchorX_, g = h + this.imageAnchorY_;
        $r(
          o,
          p,
          g,
          1,
          1,
          f,
          -p,
          -g
        ), a.setTransform.apply(a, o), a.translate(p, g), a.scale(this.imageScale_[0], this.imageScale_[1]), a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), a.setTransform(1, 0, 0, 1, 0, 0);
      } else
        a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          c,
          h,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (a.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(t, n, s, r) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const i = Ba(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_;
    let o = this.textRotation_;
    for (this.textRotateWithView_ && (o += this.viewRotation_); n < s; n += r) {
      const l = i[n] + this.textOffsetX_, f = i[n + 1] + this.textOffsetY_;
      o !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (a.translate(l - this.textOffsetX_, f - this.textOffsetY_), a.rotate(o), a.translate(this.textOffsetX_, this.textOffsetY_), a.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && a.strokeText(this.text_, 0, 0), this.textFillState_ && a.fillText(this.text_, 0, 0), a.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && a.strokeText(this.text_, l, f), this.textFillState_ && a.fillText(this.text_, l, f));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(t, n, s, r, i) {
    const a = this.context_, o = Ba(
      t,
      n,
      s,
      r,
      this.transform_,
      this.pixelCoordinates_
    );
    a.moveTo(o[0], o[1]);
    let l = o.length;
    i && (l -= 2);
    for (let f = 2; f < l; f += 2)
      a.lineTo(o[f], o[f + 1]);
    return i && a.closePath(), s;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(t, n, s, r) {
    for (let i = 0, a = s.length; i < a; ++i)
      n = this.moveToLineTo_(
        t,
        n,
        s[i],
        r,
        !0
      );
    return n;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(t) {
    if (hn(this.extent_, t.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = KD(
          t,
          this.transform_,
          this.pixelCoordinates_
        ), s = n[2] - n[0], r = n[3] - n[1], i = Math.sqrt(s * s + r * r), a = this.context_;
        a.beginPath(), a.arc(
          n[0],
          n[1],
          i,
          0,
          2 * Math.PI
        ), this.fillState_ && a.fill(), this.strokeState_ && a.stroke();
      }
      this.text_ !== "" && this.drawText_(t.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(t) {
    this.setFillStrokeStyle(t.getFill(), t.getStroke()), this.setImageStyle(t.getImage()), this.setTextStyle(t.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(t) {
    this.transform_ = t;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(t) {
    switch (t.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          t
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          t
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          t
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          t
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          t
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          t
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          t
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          t
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(t, n) {
    const s = n.getGeometryFunction()(t);
    !s || !hn(this.extent_, s.getExtent()) || (this.setStyle(n), this.drawGeometry(s));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(t) {
    const n = t.getGeometriesArray();
    for (let s = 0, r = n.length; s < r; ++s)
      this.drawGeometry(n[s]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/Point.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getFlatCoordinates(), s = t.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, s), this.text_ !== "" && this.drawText_(n, 0, n.length, s);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPoint.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getFlatCoordinates(), s = t.getStride();
    this.image_ && this.drawImages_(n, 0, n.length, s), this.text_ !== "" && this.drawText_(n, 0, n.length, s);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/LineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!hn(this.extent_, t.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, s = t.getFlatCoordinates();
        n.beginPath(), this.moveToLineTo_(
          s,
          0,
          s.length,
          t.getStride(),
          !1
        ), n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatMidpoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(t) {
    this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiLineString.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const n = t.getExtent();
    if (hn(this.extent_, n)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const s = this.context_, r = t.getFlatCoordinates();
        let i = 0;
        const a = (
          /** @type {Array<number>} */
          t.getEnds()
        ), o = t.getStride();
        s.beginPath();
        for (let l = 0, f = a.length; l < f; ++l)
          i = this.moveToLineTo_(
            r,
            i,
            a[l],
            o,
            !1
          );
        s.stroke();
      }
      if (this.text_ !== "") {
        const s = t.getFlatMidpoints();
        this.drawText_(s, 0, s.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/Polygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!hn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_;
        n.beginPath(), this.drawRings_(
          t.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          t.getEnds(),
          t.getStride()
        ), this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatInteriorPoint();
        this.drawText_(n, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(t) {
    if (this.squaredTolerance_ && (t = /** @type {import("../../geom/MultiPolygon.js").default} */
    t.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!hn(this.extent_, t.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, s = t.getOrientedFlatCoordinates();
        let r = 0;
        const i = t.getEndss(), a = t.getStride();
        n.beginPath();
        for (let o = 0, l = i.length; o < l; ++o) {
          const f = i[o];
          r = this.drawRings_(s, r, f, a);
        }
        this.fillState_ && n.fill(), this.strokeState_ && n.stroke();
      }
      if (this.text_ !== "") {
        const n = t.getFlatInteriorPoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(t) {
    const n = this.context_, s = this.contextFillState_;
    s ? s.fillStyle != t.fillStyle && (s.fillStyle = t.fillStyle, n.fillStyle = t.fillStyle) : (n.fillStyle = t.fillStyle, this.contextFillState_ = {
      fillStyle: t.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(t) {
    const n = this.context_, s = this.contextStrokeState_;
    s ? (s.lineCap != t.lineCap && (s.lineCap = t.lineCap, n.lineCap = t.lineCap), Jo(s.lineDash, t.lineDash) || n.setLineDash(
      s.lineDash = t.lineDash
    ), s.lineDashOffset != t.lineDashOffset && (s.lineDashOffset = t.lineDashOffset, n.lineDashOffset = t.lineDashOffset), s.lineJoin != t.lineJoin && (s.lineJoin = t.lineJoin, n.lineJoin = t.lineJoin), s.lineWidth != t.lineWidth && (s.lineWidth = t.lineWidth, n.lineWidth = t.lineWidth), s.miterLimit != t.miterLimit && (s.miterLimit = t.miterLimit, n.miterLimit = t.miterLimit), s.strokeStyle != t.strokeStyle && (s.strokeStyle = t.strokeStyle, n.strokeStyle = t.strokeStyle)) : (n.lineCap = t.lineCap, n.setLineDash(t.lineDash), n.lineDashOffset = t.lineDashOffset, n.lineJoin = t.lineJoin, n.lineWidth = t.lineWidth, n.miterLimit = t.miterLimit, n.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
      lineCap: t.lineCap,
      lineDash: t.lineDash,
      lineDashOffset: t.lineDashOffset,
      lineJoin: t.lineJoin,
      lineWidth: t.lineWidth,
      miterLimit: t.miterLimit,
      strokeStyle: t.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(t) {
    const n = this.context_, s = this.contextTextState_, r = t.textAlign ? t.textAlign : pc;
    s ? (s.font != t.font && (s.font = t.font, n.font = t.font), s.textAlign != r && (s.textAlign = r, n.textAlign = r), s.textBaseline != t.textBaseline && (s.textBaseline = t.textBaseline, n.textBaseline = t.textBaseline)) : (n.font = t.font, n.textAlign = r, n.textBaseline = t.textBaseline, this.contextTextState_ = {
      font: t.font,
      textAlign: r,
      textBaseline: t.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(t, n) {
    if (!t)
      this.fillState_ = null;
    else {
      const s = t.getColor();
      this.fillState_ = {
        fillStyle: us(
          s || Zs
        )
      };
    }
    if (!n)
      this.strokeState_ = null;
    else {
      const s = n.getColor(), r = n.getLineCap(), i = n.getLineDash(), a = n.getLineDashOffset(), o = n.getLineJoin(), l = n.getWidth(), f = n.getMiterLimit(), d = i || cc;
      this.strokeState_ = {
        lineCap: r !== void 0 ? r : _d,
        lineDash: this.pixelRatio_ === 1 ? d : d.map((u) => u * this.pixelRatio_),
        lineDashOffset: (a || hc) * this.pixelRatio_,
        lineJoin: o !== void 0 ? o : nu,
        lineWidth: (l !== void 0 ? l : mc) * this.pixelRatio_,
        miterLimit: f !== void 0 ? f : dc,
        strokeStyle: us(
          s || fc
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(t) {
    let n;
    if (!t || !(n = t.getSize())) {
      this.image_ = null;
      return;
    }
    const s = t.getPixelRatio(this.pixelRatio_), r = t.getAnchor(), i = t.getOrigin();
    this.image_ = t.getImage(this.pixelRatio_), this.imageAnchorX_ = r[0] * s, this.imageAnchorY_ = r[1] * s, this.imageHeight_ = n[1] * s, this.imageOpacity_ = t.getOpacity(), this.imageOriginX_ = i[0], this.imageOriginY_ = i[1], this.imageRotateWithView_ = t.getRotateWithView(), this.imageRotation_ = t.getRotation();
    const a = t.getScaleArray();
    this.imageScale_ = [
      a[0] * this.pixelRatio_ / s,
      a[1] * this.pixelRatio_ / s
    ], this.imageWidth_ = n[0] * s;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(t) {
    if (!t)
      this.text_ = "";
    else {
      const n = t.getFill();
      if (!n)
        this.textFillState_ = null;
      else {
        const h = n.getColor();
        this.textFillState_ = {
          fillStyle: us(
            h || Zs
          )
        };
      }
      const s = t.getStroke();
      if (!s)
        this.textStrokeState_ = null;
      else {
        const h = s.getColor(), p = s.getLineCap(), g = s.getLineDash(), m = s.getLineDashOffset(), v = s.getLineJoin(), y = s.getWidth(), E = s.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: p !== void 0 ? p : _d,
          lineDash: g || cc,
          lineDashOffset: m || hc,
          lineJoin: v !== void 0 ? v : nu,
          lineWidth: y !== void 0 ? y : mc,
          miterLimit: E !== void 0 ? E : dc,
          strokeStyle: us(
            h || fc
          )
        };
      }
      const r = t.getFont(), i = t.getOffsetX(), a = t.getOffsetY(), o = t.getRotateWithView(), l = t.getRotation(), f = t.getScaleArray(), d = t.getText(), u = t.getTextAlign(), c = t.getTextBaseline();
      this.textState_ = {
        font: r !== void 0 ? r : R1,
        textAlign: u !== void 0 ? u : pc,
        textBaseline: c !== void 0 ? c : Id
      }, this.text_ = d !== void 0 ? Array.isArray(d) ? d.reduce((h, p, g) => h += g % 2 ? " " : p, "") : d : "", this.textOffsetX_ = i !== void 0 ? this.pixelRatio_ * i : 0, this.textOffsetY_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textRotateWithView_ = o !== void 0 ? o : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * f[0],
        this.pixelRatio_ * f[1]
      ];
    }
  }
}
const k1 = pL, Qi = 0.5;
function H1(e, t, n, s, r, i, a) {
  const o = e[0] * Qi, l = e[1] * Qi, f = Di(o, l);
  f.imageSmoothingEnabled = !1;
  const d = f.canvas, u = new k1(
    f,
    Qi,
    r,
    null,
    a
  ), c = n.length, h = Math.floor((256 * 256 * 256 - 1) / c), p = {};
  for (let m = 1; m <= c; ++m) {
    const v = n[m - 1], y = v.getStyleFunction() || s;
    if (!s)
      continue;
    let E = y(v, i);
    if (!E)
      continue;
    Array.isArray(E) || (E = [E]);
    const x = "#" + ("000000" + (m * h).toString(16)).slice(-6);
    for (let b = 0, P = E.length; b < P; ++b) {
      const O = E[b], T = O.getGeometryFunction()(v);
      if (!T || !hn(r, T.getExtent()))
        continue;
      const M = O.clone(), L = M.getFill();
      L && L.setColor(x);
      const A = M.getStroke();
      A && (A.setColor(x), A.setLineDash(null)), M.setText(void 0);
      const D = O.getImage();
      if (D && D.getOpacity() !== 0) {
        const B = D.getImageSize();
        if (!B)
          continue;
        const j = Di(
          B[0],
          B[1],
          void 0,
          { alpha: !1 }
        ), k = j.canvas;
        j.fillStyle = x, j.fillRect(0, 0, k.width, k.height), M.setImage(
          new vs({
            img: k,
            imgSize: B,
            anchor: D.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: D.getOrigin(),
            opacity: 1,
            size: D.getSize(),
            scale: D.getScale(),
            rotation: D.getRotation(),
            rotateWithView: D.getRotateWithView()
          })
        );
      }
      const I = M.getZIndex() || 0;
      let w = p[I];
      w || (w = {}, p[I] = w, w.Polygon = [], w.Circle = [], w.LineString = [], w.Point = []), w[T.getType().replace("Multi", "")].push(
        T,
        M
      );
    }
  }
  const g = Object.keys(p).map(Number).sort(wo);
  for (let m = 0, v = g.length; m < v; ++m) {
    const y = p[g[m]];
    for (const E in y) {
      const C = y[E];
      for (let x = 0, b = C.length; x < b; x += 2) {
        u.setStyle(C[x + 1]);
        for (let P = 0, O = t.length; P < O; ++P)
          u.setTransform(t[P]), u.drawGeometry(C[x]);
      }
    }
  }
  return f.getImageData(0, 0, d.width, d.height);
}
function Y1(e, t, n) {
  const s = [];
  if (n) {
    const r = Math.floor(Math.round(e[0]) * Qi), i = Math.floor(Math.round(e[1]) * Qi), a = (dn(r, 0, n.width - 1) + dn(i, 0, n.height - 1) * n.width) * 4, o = n.data[a], l = n.data[a + 1], d = n.data[a + 2] + 256 * (l + 256 * o), u = Math.floor((256 * 256 * 256 - 1) / t.length);
    d && d % u === 0 && s.push(t[d / u - 1]);
  }
  return s;
}
const mL = 0.5, X1 = {
  Point: TL,
  LineString: CL,
  Polygon: PL,
  MultiPoint: OL,
  MultiLineString: xL,
  MultiPolygon: bL,
  GeometryCollection: EL,
  Circle: vL
};
function gL(e, t) {
  return parseInt(Xt(e), 10) - parseInt(Xt(t), 10);
}
function Z1(e, t) {
  const n = zg(e, t);
  return n * n;
}
function zg(e, t) {
  return mL * e / t;
}
function vL(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (i || a) {
    const l = e.getBuilder(n.getZIndex(), "Circle");
    l.setFillStrokeStyle(i, a), l.drawCircle(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
function wd(e, t, n, s, r, i, a) {
  let o = !1;
  const l = n.getImage();
  if (l) {
    const f = l.getImageState();
    f == he.LOADED || f == he.ERROR ? l.unlistenImageChange(r) : (f == he.IDLE && l.load(), l.listenImageChange(r), o = !0);
  }
  return yL(
    e,
    t,
    n,
    s,
    i,
    a
  ), o;
}
function yL(e, t, n, s, r, i) {
  const a = n.getGeometryFunction()(t);
  if (!a)
    return;
  const o = a.simplifyTransformed(
    s,
    r
  );
  if (n.getRenderer())
    J1(e, o, n, t);
  else {
    const f = X1[o.getType()];
    f(
      e,
      o,
      n,
      t,
      i
    );
  }
}
function J1(e, t, n, s) {
  if (t.getType() == "GeometryCollection") {
    const i = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      t.getGeometries()
    );
    for (let a = 0, o = i.length; a < o; ++a)
      J1(e, i[a], n, s);
    return;
  }
  e.getBuilder(n.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    t,
    s,
    n.getRenderer(),
    n.getHitDetectionRenderer()
  );
}
function EL(e, t, n, s, r) {
  const i = t.getGeometriesArray();
  let a, o;
  for (a = 0, o = i.length; a < o; ++a) {
    const l = X1[i[a].getType()];
    l(
      e,
      i[a],
      n,
      s,
      r
    );
  }
}
function CL(e, t, n, s, r) {
  const i = n.getStroke();
  if (i) {
    const o = e.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, i), o.drawLineString(t, s);
  }
  const a = n.getText();
  if (a && a.getText()) {
    const o = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(t, s);
  }
}
function xL(e, t, n, s, r) {
  const i = n.getStroke();
  if (i) {
    const o = e.getBuilder(
      n.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, i), o.drawMultiLineString(t, s);
  }
  const a = n.getText();
  if (a && a.getText()) {
    const o = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(t, s);
  }
}
function bL(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (a || i) {
    const l = e.getBuilder(n.getZIndex(), "Polygon");
    l.setFillStrokeStyle(i, a), l.drawMultiPolygon(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
function TL(e, t, n, s, r) {
  const i = n.getImage(), a = n.getText();
  let o;
  if (i) {
    if (i.getImageState() != he.LOADED)
      return;
    let l = e;
    if (r) {
      const d = i.getDeclutterMode();
      if (d !== "none")
        if (l = r, d === "obstacle") {
          const u = e.getBuilder(
            n.getZIndex(),
            "Image"
          );
          u.setImageStyle(i, o), u.drawPoint(t, s);
        } else
          a && a.getText() && (o = {});
    }
    const f = l.getBuilder(
      n.getZIndex(),
      "Image"
    );
    f.setImageStyle(i, o), f.drawPoint(t, s);
  }
  if (a && a.getText()) {
    let l = e;
    r && (l = r);
    const f = l.getBuilder(n.getZIndex(), "Text");
    f.setTextStyle(a, o), f.drawText(t, s);
  }
}
function OL(e, t, n, s, r) {
  const i = n.getImage(), a = n.getText();
  let o;
  if (i) {
    if (i.getImageState() != he.LOADED)
      return;
    let l = e;
    if (r) {
      const d = i.getDeclutterMode();
      if (d !== "none")
        if (l = r, d === "obstacle") {
          const u = e.getBuilder(
            n.getZIndex(),
            "Image"
          );
          u.setImageStyle(i, o), u.drawMultiPoint(t, s);
        } else
          a && a.getText() && (o = {});
    }
    const f = l.getBuilder(
      n.getZIndex(),
      "Image"
    );
    f.setImageStyle(i, o), f.drawMultiPoint(t, s);
  }
  if (a && a.getText()) {
    let l = e;
    r && (l = r);
    const f = l.getBuilder(n.getZIndex(), "Text");
    f.setTextStyle(a, o), f.drawText(t, s);
  }
}
function PL(e, t, n, s, r) {
  const i = n.getFill(), a = n.getStroke();
  if (i || a) {
    const l = e.getBuilder(n.getZIndex(), "Polygon");
    l.setFillStrokeStyle(i, a), l.drawPolygon(t, s);
  }
  const o = n.getText();
  if (o && o.getText()) {
    const l = (r || e).getBuilder(
      n.getZIndex(),
      "Text"
    );
    l.setTextStyle(o), l.drawText(t, s);
  }
}
class SL extends Ry {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = ji(), this.wrappedRenderedExtent_ = ji(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.declutterExecutorGroup = null, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(t, n, s) {
    const r = n.extent, i = n.viewState, a = i.center, o = i.resolution, l = i.projection, f = i.rotation, d = l.getExtent(), u = this.getLayer().getSource(), c = n.pixelRatio, h = n.viewHints, p = !(h[en.ANIMATING] || h[en.INTERACTING]), g = this.compositionContext_, m = Math.round(n.size[0] * c), v = Math.round(n.size[1] * c), y = u.getWrapX() && l.canWrapX(), E = y ? Ee(d) : null, C = y ? Math.ceil((r[2] - d[2]) / E) + 1 : 1;
    let x = y ? Math.floor((r[0] - d[0]) / E) : 0;
    do {
      const b = this.getRenderTransform(
        a,
        o,
        f,
        c,
        m,
        v,
        x * E
      );
      t.execute(
        g,
        1,
        b,
        f,
        p,
        void 0,
        s
      );
    } while (++x < C);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const t = Di(
        this.context.canvas.width,
        this.context.canvas.height,
        hC
      );
      this.compositionContext_ = t;
    } else
      this.compositionContext_ = this.context;
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const t = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = t, Py(this.compositionContext_), hC.push(this.compositionContext_.canvas), this.compositionContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(
      this.declutterExecutorGroup,
      t,
      t.declutterTree
    ), this.releaseCompositionContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = t.pixelRatio, r = t.layerStatesArray[t.layerIndex];
    dD(this.pixelTransform, 1 / s, 1 / s), If(this.inversePixelTransform, this.pixelTransform);
    const i = ey(this.pixelTransform);
    this.useContainer(n, i, this.getBackground(t));
    const a = this.context, o = a.canvas, l = this.replayGroup_, f = this.declutterExecutorGroup;
    if ((!l || l.isEmpty()) && (!f || f.isEmpty()))
      return null;
    const d = Math.round(t.size[0] * s), u = Math.round(t.size[1] * s);
    o.width != d || o.height != u ? (o.width = d, o.height = u, o.style.transform !== i && (o.style.transform = i)) : this.containerReused || a.clearRect(0, 0, d, u), this.preRender(a, t);
    const c = t.viewState;
    c.projection, this.opacity_ = r.opacity, this.setupCompositionContext_();
    let h = !1, p = !0;
    if (r.extent && this.clipping) {
      const g = Ks(r.extent);
      p = hn(g, t.extent), h = p && !Rr(g, t.extent), h && this.clipUnrotated(this.compositionContext_, t, g);
    }
    return p && this.renderWorlds(l, t), h && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(a, t), this.renderedRotation_ !== c.rotation && (this.renderedRotation_ = c.rotation, this.hitDetectionImageData_ = null), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise(
      /**
       * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
       * @this {CanvasVectorLayerRenderer}
       */
      (function(n) {
        if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const s = [this.context.canvas.width, this.context.canvas.height];
          Ln(this.pixelTransform, s);
          const r = this.renderedCenter_, i = this.renderedResolution_, a = this.renderedRotation_, o = this.renderedProjection_, l = this.wrappedRenderedExtent_, f = this.getLayer(), d = [], u = s[0] * Qi, c = s[1] * Qi;
          d.push(
            this.getRenderTransform(
              r,
              i,
              a,
              Qi,
              u,
              c,
              0
            ).slice()
          );
          const h = f.getSource(), p = o.getExtent();
          if (h.getWrapX() && o.canWrapX() && !Rr(p, l)) {
            let g = l[0];
            const m = Ee(p);
            let v = 0, y;
            for (; g < p[0]; )
              --v, y = m * v, d.push(
                this.getRenderTransform(
                  r,
                  i,
                  a,
                  Qi,
                  u,
                  c,
                  y
                ).slice()
              ), g += m;
            for (v = 0, g = l[2]; g > p[2]; )
              ++v, y = m * v, d.push(
                this.getRenderTransform(
                  r,
                  i,
                  a,
                  Qi,
                  u,
                  c,
                  y
                ).slice()
              ), g -= m;
          }
          this.hitDetectionImageData_ = H1(
            s,
            d,
            this.renderedFeatures_,
            f.getStyleFunction(),
            l,
            i,
            a
          );
        }
        n(
          Y1(t, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      }).bind(this)
    );
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
    if (!this.replayGroup_)
      return;
    const a = n.viewState.resolution, o = n.viewState.rotation, l = this.getLayer(), f = {}, d = function(h, p, g) {
      const m = Xt(h), v = f[m];
      if (v) {
        if (v !== !0 && g < v.distanceSq) {
          if (g === 0)
            return f[m] = !0, i.splice(i.lastIndexOf(v), 1), r(h, l, p);
          v.geometry = p, v.distanceSq = g;
        }
      } else {
        if (g === 0)
          return f[m] = !0, r(h, l, p);
        i.push(
          f[m] = {
            feature: h,
            layer: l,
            geometry: p,
            distanceSq: g,
            callback: r
          }
        );
      }
    };
    let u;
    const c = [this.replayGroup_];
    return this.declutterExecutorGroup && c.push(this.declutterExecutorGroup), c.some((h) => u = h.forEachFeatureAtCoordinate(
      t,
      a,
      o,
      s,
      d,
      h === this.declutterExecutorGroup && n.declutterTree ? n.declutterTree.all().map((p) => p.value) : null
    )), u;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.replayGroup_ && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = this.getLayer(), s = n.getSource();
    if (!s)
      return !1;
    const r = t.viewHints[en.ANIMATING], i = t.viewHints[en.INTERACTING], a = n.getUpdateWhileAnimating(), o = n.getUpdateWhileInteracting();
    if (this.ready && !a && r || !o && i)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = t.extent, f = t.viewState, d = f.projection, u = f.resolution, c = t.pixelRatio, h = n.getRevision(), p = n.getRenderBuffer();
    let g = n.getRenderOrder();
    g === void 0 && (g = gL);
    const m = f.center.slice(), v = Br(
      l,
      p * u
    ), y = v.slice(), E = [v.slice()], C = d.getExtent();
    if (s.getWrapX() && d.canWrapX() && !Rr(C, t.extent)) {
      const w = Ee(C), B = Math.max(Ee(v) / 2, w);
      v[0] = C[0] - B, v[2] = C[2] + B, oy(m, d);
      const j = r1(E[0], d);
      j[0] < C[0] && j[2] < C[2] ? E.push([
        j[0] + w,
        j[1],
        j[2] + w,
        j[3]
      ]) : j[0] > C[0] && j[2] > C[2] && E.push([
        j[0] - w,
        j[1],
        j[2] - w,
        j[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == h && this.renderedRenderOrder_ == g && Rr(this.wrappedRenderedExtent_, v))
      return Jo(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const x = new Ld(
      zg(u, c),
      v,
      u,
      c
    );
    let b;
    this.getLayer().getDeclutter() && (b = new Ld(
      zg(u, c),
      v,
      u,
      c
    ));
    let P;
    for (let w = 0, B = E.length; w < B; ++w)
      s.loadFeatures(E[w], u, d);
    const O = Z1(u, c);
    let T = !0;
    const M = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @this {CanvasVectorLayerRenderer}
       */
      (function(w) {
        let B;
        const j = w.getStyleFunction() || n.getStyleFunction();
        if (j && (B = j(w, u)), B) {
          const k = this.renderFeature(
            w,
            O,
            B,
            x,
            P,
            b
          );
          T = T && !k;
        }
      }).bind(this)
    ), L = f1(v), A = s.getFeaturesInExtent(L);
    g && A.sort(g);
    for (let w = 0, B = A.length; w < B; ++w)
      M(A[w]);
    this.renderedFeatures_ = A, this.ready = T;
    const D = x.finish(), I = new Rd(
      v,
      u,
      c,
      s.getOverlaps(),
      D,
      n.getRenderBuffer()
    );
    return b && (this.declutterExecutorGroup = new Rd(
      v,
      u,
      c,
      s.getOverlaps(),
      b.finish(),
      n.getRenderBuffer()
    )), this.renderedResolution_ = u, this.renderedRevision_ = h, this.renderedRenderOrder_ = g, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = m, this.renderedProjection_ = d, this.replayGroup_ = I, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, n, s, r, i, a) {
    if (!s)
      return !1;
    let o = !1;
    if (Array.isArray(s))
      for (let l = 0, f = s.length; l < f; ++l)
        o = wd(
          r,
          t,
          s[l],
          n,
          this.boundHandleStyleImageChange_,
          i,
          a
        ) || o;
    else
      o = wd(
        r,
        t,
        s,
        n,
        this.boundHandleStyleImageChange_,
        i,
        a
      );
    return o;
  }
}
const ML = SL;
class _L extends z1 {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new ML(this);
  }
}
const sr = _L;
class IL {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(t) {
    this.rbush_ = new $1(t), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(t, n) {
    const s = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3],
      value: n
    };
    this.rbush_.insert(s), this.items_[Xt(n)] = s;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(t, n) {
    const s = new Array(n.length);
    for (let r = 0, i = n.length; r < i; r++) {
      const a = t[r], o = n[r], l = {
        minX: a[0],
        minY: a[1],
        maxX: a[2],
        maxY: a[3],
        value: o
      };
      s[r] = l, this.items_[Xt(o)] = l;
    }
    this.rbush_.load(s);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(t) {
    const n = Xt(t), s = this.items_[n];
    return delete this.items_[n], this.rbush_.remove(s) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(t, n) {
    const s = this.items_[Xt(n)], r = [s.minX, s.minY, s.maxX, s.maxY];
    Fo(r, t) || (this.remove(n), this.insert(t, n));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(n) {
      return n.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(t) {
    const n = {
      minX: t[0],
      minY: t[1],
      maxX: t[2],
      maxY: t[3]
    };
    return this.rbush_.search(n).map(function(r) {
      return r.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(t) {
    return this.forEach_(this.getAll(), t);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(t, n) {
    return this.forEach_(this.getInExtent(t), n);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(t, n) {
    let s;
    for (let r = 0, i = t.length; r < i; r++)
      if (s = n(t[r]), s)
        return s;
    return s;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Bo(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(t) {
    const n = this.rbush_.toJSON();
    return ir(n.minX, n.minY, n.maxX, n.maxY, t);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(t) {
    this.rbush_.load(t.rbush_.all());
    for (const n in t.items_)
      this.items_[n] = t.items_[n];
  }
}
const pC = IL;
class DL extends xr {
  /**
   * @param {Options} options Source options.
   */
  constructor(t) {
    super(), this.projection = Wt(t.projection), this.attributions_ = mC(t.attributions), this.attributionsCollapsible_ = t.attributionsCollapsible !== void 0 ? t.attributionsCollapsible : !0, this.loading = !1, this.state_ = t.state !== void 0 ? t.state : "ready", this.wrapX_ = t.wrapX !== void 0 ? t.wrapX : !1, this.interpolate_ = !!t.interpolate, this.viewResolver = null, this.viewRejector = null;
    const n = this;
    this.viewPromise_ = new Promise(function(s, r) {
      n.viewResolver = s, n.viewRejector = r;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @abstract
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return Gt();
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(t) {
    this.attributions_ = mC(t), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(t) {
    this.state_ = t, this.changed();
  }
}
function mC(e) {
  return e ? Array.isArray(e) ? function(t) {
    return e;
  } : typeof e == "function" ? e : function(t) {
    return [e];
  } : null;
}
const wy = DL, _r = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function AL(e, t) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function Kg(e, t) {
  return [e];
}
let LL = !1;
function Q1(e, t, n, s, r, i, a) {
  const o = new XMLHttpRequest();
  o.open(
    "GET",
    typeof e == "function" ? e(n, s, r) : e,
    !0
  ), t.getType() == "arraybuffer" && (o.responseType = "arraybuffer"), o.withCredentials = LL, o.onload = function(l) {
    if (!o.status || o.status >= 200 && o.status < 300) {
      const f = t.getType();
      let d;
      f == "json" || f == "text" ? d = o.responseText : f == "xml" ? (d = o.responseXML, d || (d = new DOMParser().parseFromString(
        o.responseText,
        "application/xml"
      ))) : f == "arraybuffer" && (d = /** @type {ArrayBuffer} */
      o.response), d ? i(
        /** @type {Array<import("./Feature.js").default>} */
        t.readFeatures(d, {
          extent: n,
          featureProjection: r
        }),
        t.readProjection(d)
      ) : a();
    } else
      a();
  }, o.onerror = a, o.send();
}
function gC(e, t) {
  return function(n, s, r, i, a) {
    const o = (
      /** @type {import("./source/Vector").default} */
      this
    );
    Q1(
      e,
      t,
      n,
      s,
      r,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(l, f) {
        o.addFeatures(l), i !== void 0 && i(l);
      },
      /* FIXME handle error */
      a || Vo
    );
  };
}
class va extends Wi {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(t, n, s) {
    super(t), this.feature = n, this.features = s;
  }
}
class RL extends wy {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Vo, this.format_ = t.format, this.overlaps_ = t.overlaps === void 0 ? !0 : t.overlaps, this.url_ = t.url, t.loader !== void 0 ? this.loader_ = t.loader : this.url_ !== void 0 && (Zt(this.format_, 7), this.loader_ = gC(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = t.strategy !== void 0 ? t.strategy : AL;
    const n = t.useSpatialIndex !== void 0 ? t.useSpatialIndex : !0;
    this.featuresRtree_ = n ? new pC() : null, this.loadedExtentsRtree_ = new pC(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let s, r;
    Array.isArray(t.features) ? r = t.features : t.features && (s = t.features, r = s.getArray()), !n && s === void 0 && (s = new Fi(r)), r !== void 0 && this.addFeaturesInternal(r), s !== void 0 && this.bindFeaturesCollection_(s);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(t) {
    this.addFeatureInternal(t), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(t) {
    const n = Xt(t);
    if (!this.addToIndex_(n, t)) {
      this.featuresCollection_ && this.featuresCollection_.remove(t);
      return;
    }
    this.setupChangeEvents_(n, t);
    const s = t.getGeometry();
    if (s) {
      const r = s.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(r, t);
    } else
      this.nullGeometryFeatures_[n] = t;
    this.dispatchEvent(
      new va(_r.ADDFEATURE, t)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(t, n) {
    this.featureChangeKeys_[t] = [
      ve(n, Kt.CHANGE, this.handleFeatureChange_, this),
      ve(
        n,
        Zl.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(t, n) {
    let s = !0;
    const r = n.getId();
    return r !== void 0 && (r.toString() in this.idIndex_ ? s = !1 : this.idIndex_[r.toString()] = n), s && (Zt(!(t in this.uidIndex_), 30), this.uidIndex_[t] = n), s;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(t) {
    this.addFeaturesInternal(t), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(t) {
    const n = [], s = [], r = [];
    for (let i = 0, a = t.length; i < a; i++) {
      const o = t[i], l = Xt(o);
      this.addToIndex_(l, o) && s.push(o);
    }
    for (let i = 0, a = s.length; i < a; i++) {
      const o = s[i], l = Xt(o);
      this.setupChangeEvents_(l, o);
      const f = o.getGeometry();
      if (f) {
        const d = f.getExtent();
        n.push(d), r.push(o);
      } else
        this.nullGeometryFeatures_[l] = o;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(n, r), this.hasListener(_r.ADDFEATURE))
      for (let i = 0, a = s.length; i < a; i++)
        this.dispatchEvent(
          new va(_r.ADDFEATURE, s[i])
        );
  }
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(t) {
    let n = !1;
    this.addEventListener(
      _r.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(s) {
        n || (n = !0, t.push(s.feature), n = !1);
      }
    ), this.addEventListener(
      _r.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(s) {
        n || (n = !0, t.remove(s.feature), n = !1);
      }
    ), t.addEventListener(
      zn.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (function(s) {
        n || (n = !0, this.addFeature(s.element), n = !1);
      }).bind(this)
    ), t.addEventListener(
      zn.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (function(s) {
        n || (n = !0, this.removeFeature(s.element), n = !1);
      }).bind(this)
    ), this.featuresCollection_ = t;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(t) {
    if (t) {
      for (const s in this.featureChangeKeys_)
        this.featureChangeKeys_[s].forEach(Ue);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const s = (function(r) {
        this.removeFeatureInternal(r);
      }).bind(this);
      this.featuresRtree_.forEach(s);
      for (const r in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[r]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const n = new va(_r.CLEAR);
    this.dispatchEvent(n), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(t, n) {
    const s = [t[0], t[1], t[0], t[1]];
    return this.forEachFeatureInExtent(s, function(r) {
      if (r.getGeometry().intersectsCoordinate(t))
        return n(r);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(t, n) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(t, n);
    this.featuresCollection_ && this.featuresCollection_.forEach(n);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(t, n) {
    return this.forEachFeatureInExtent(
      t,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(s) {
        if (s.getGeometry().intersectsExtent(t)) {
          const i = n(s);
          if (i)
            return i;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let t;
    return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), Bo(this.nullGeometryFeatures_) || Kn(t, Object.values(this.nullGeometryFeatures_))), /** @type {Array<import("../Feature.js").default<Geometry>>} */
    t;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(t) {
    const n = [];
    return this.forEachFeatureAtCoordinateDirect(t, function(s) {
      n.push(s);
    }), n;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(t, n) {
    if (this.featuresRtree_) {
      if (!(n && n.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(t);
      const r = xD(t, n);
      return [].concat(
        ...r.map((i) => this.featuresRtree_.getInExtent(i))
      );
    } else
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(t, n) {
    const s = t[0], r = t[1];
    let i = null;
    const a = [NaN, NaN];
    let o = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return n = n || ms, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function(f) {
        if (n(f)) {
          const d = f.getGeometry(), u = o;
          if (o = d.closestPointXY(
            s,
            r,
            a,
            o
          ), o < u) {
            i = f;
            const c = Math.sqrt(o);
            l[0] = s - c, l[1] = r - c, l[2] = s + c, l[3] = r + c;
          }
        }
      }
    ), i;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(t) {
    return this.featuresRtree_.getExtent(t);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(t) {
    const n = this.idIndex_[t.toString()];
    return n !== void 0 ? n : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(t) {
    const n = this.uidIndex_[t];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(t) {
    const n = (
      /** @type {import("../Feature.js").default<Geometry>} */
      t.target
    ), s = Xt(n), r = n.getGeometry();
    if (!r)
      s in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(n), this.nullGeometryFeatures_[s] = n);
    else {
      const a = r.getExtent();
      s in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[s], this.featuresRtree_ && this.featuresRtree_.insert(a, n)) : this.featuresRtree_ && this.featuresRtree_.update(a, n);
    }
    const i = n.getId();
    if (i !== void 0) {
      const a = i.toString();
      this.idIndex_[a] !== n && (this.removeFromIdIndex_(n), this.idIndex_[a] = n);
    } else
      this.removeFromIdIndex_(n), this.uidIndex_[s] = n;
    this.changed(), this.dispatchEvent(
      new va(_r.CHANGEFEATURE, n)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(t) {
    const n = t.getId();
    return n !== void 0 ? n in this.idIndex_ : Xt(t) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Bo(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, n, s) {
    const r = this.loadedExtentsRtree_, i = this.strategy_(t, n, s);
    for (let a = 0, o = i.length; a < o; ++a) {
      const l = i[a];
      r.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(d) {
          return Rr(d.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new va(_r.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        n,
        s,
        (function(d) {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new va(
              _r.FEATURESLOADEND,
              void 0,
              d
            )
          );
        }).bind(this),
        (function() {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new va(_r.FEATURESLOADERROR)
          );
        }).bind(this)
      ), r.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(t) {
    const n = this.loadedExtentsRtree_;
    let s;
    n.forEachInExtent(t, function(r) {
      if (Fo(r.extent, t))
        return s = r, !0;
    }), s && n.remove(s);
  }
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(t) {
    if (!t)
      return;
    const n = Xt(t);
    n in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[n] : this.featuresRtree_ && this.featuresRtree_.remove(t), this.removeFeatureInternal(t) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(t) {
    const n = Xt(t), s = this.featureChangeKeys_[n];
    if (!s)
      return;
    s.forEach(Ue), delete this.featureChangeKeys_[n];
    const r = t.getId();
    return r !== void 0 && delete this.idIndex_[r.toString()], delete this.uidIndex_[n], this.dispatchEvent(
      new va(_r.REMOVEFEATURE, t)
    ), t;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(t) {
    let n = !1;
    for (const s in this.idIndex_)
      if (this.idIndex_[s] === t) {
        delete this.idIndex_[s], n = !0;
        break;
      }
    return n;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(t) {
    Zt(this.format_, 7), this.url_ = t, this.setLoader(gC(t, this.format_));
  }
}
const Ur = RL;
function wL(e, t) {
  const n = e.canvas;
  t = t || {};
  const s = t.pixelRatio || Mf, r = t.size;
  r && (n.width = r[0] * s, n.height = r[1] * s, n.style.width = r[0] + "px", n.style.height = r[1] + "px");
  const i = [0, 0, n.width, n.height], a = ud(tr(), s, s);
  return new k1(e, s, i, a, 0);
}
const _t = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
function q1(e) {
  return Math.pow(e, 3);
}
function qo(e) {
  return 1 - q1(1 - e);
}
function VL(e) {
  return 3 * e * e - 2 * e * e * e;
}
function tP(e) {
  return e;
}
let BL = class extends Nc {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(t, n, s) {
    super(), s = s || {}, this.tileCoord = t, this.state = n, this.interimTile = null, this.key = "", this.transition_ = s.transition === void 0 ? 250 : s.transition, this.transitionStarts_ = {}, this.interpolate = !!s.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Kt.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === _t.ERROR && this.setState(_t.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile)
      return this;
    let t = this.interimTile;
    do {
      if (t.getState() == _t.LOADED)
        return this.transition_ = 0, t;
      t = t.interimTile;
    } while (t);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile)
      return;
    let t = this.interimTile, n = this;
    do {
      if (t.getState() == _t.LOADED) {
        t.interimTile = null;
        break;
      } else
        t.getState() == _t.LOADING ? n = t : t.getState() == _t.IDLE ? n.interimTile = t.interimTile : n = t;
      t = n.interimTile;
    } while (t);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(t) {
    if (this.state !== _t.ERROR && this.state > t)
      throw new Error("Tile load sequence violation");
    this.state = t, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    Gt();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(t, n) {
    if (!this.transition_)
      return 1;
    let s = this.transitionStarts_[t];
    if (!s)
      s = n, this.transitionStarts_[t] = s;
    else if (s === -1)
      return 1;
    const r = n - s + 1e3 / 60;
    return r >= this.transition_ ? 1 : q1(r / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(t) {
    return this.transition_ ? this.transitionStarts_[t] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(t) {
    this.transition_ && (this.transitionStarts_[t] = -1);
  }
};
const Nf = BL;
class FL extends Nf {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, a), this.crossOrigin_ = r, this.src_ = s, this.key = s, this.image_ = new Image(), r !== null && (this.image_.crossOrigin = r), this.unlisten_ = null, this.tileLoadFunction_ = i;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(t) {
    this.image_ = t, this.state = _t.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = _t.ERROR, this.unlistenImage_(), this.image_ = NL(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const t = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    t.naturalWidth && t.naturalHeight ? this.state = _t.LOADED : this.state = _t.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == _t.ERROR && (this.state = _t.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == _t.IDLE && (this.state = _t.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = Ay(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function NL() {
  const e = Di(1, 1);
  return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), e.canvas;
}
const eP = FL;
class jL {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(t, n, s) {
    this.decay_ = t, this.minVelocity_ = n, this.delay_ = s, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(t, n) {
    this.points_.push(t, n, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const t = Date.now() - this.delay_, n = this.points_.length - 3;
    if (this.points_[n + 2] < t)
      return !1;
    let s = n - 3;
    for (; s > 0 && this.points_[s + 2] > t; )
      s -= 3;
    const r = this.points_[n + 2] - this.points_[s + 2];
    if (r < 1e3 / 60)
      return !1;
    const i = this.points_[n] - this.points_[s], a = this.points_[n + 1] - this.points_[s + 1];
    return this.angle_ = Math.atan2(a, i), this.initialVelocity_ = Math.sqrt(i * i + a * a) / r, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const $L = jL;
class UL extends Qv {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(), this.map_ = t;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(t, n) {
    Gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(t) {
    const n = t.viewState, s = t.coordinateToPixelTransform, r = t.pixelToCoordinateTransform;
    $r(
      s,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / n.resolution,
      -1 / n.resolution,
      -n.rotation,
      -n.center[0],
      -n.center[1]
    ), If(r, s);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(t, n, s, r, i, a, o, l) {
    let f;
    const d = n.viewState;
    function u(C, x, b, P) {
      return i.call(a, x, C ? b : null, P);
    }
    const c = d.projection, h = oy(t.slice(), c), p = [[0, 0]];
    if (c.canWrapX() && r) {
      const C = c.getExtent(), x = Ee(C);
      p.push([-x, 0], [x, 0]);
    }
    const g = n.layerStatesArray, m = g.length, v = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), y = [];
    for (let C = 0; C < p.length; C++)
      for (let x = m - 1; x >= 0; --x) {
        const b = g[x], P = b.layer;
        if (P.hasRenderer() && Dy(b, d) && o.call(l, P)) {
          const O = P.getRenderer(), T = P.getSource();
          if (O && T) {
            const M = T.getWrapX() ? h : t, L = u.bind(
              null,
              b.managed
            );
            y[0] = M[0] + p[C][0], y[1] = M[1] + p[C][1], f = O.forEachFeatureAtCoordinate(
              y,
              n,
              s,
              L,
              v
            );
          }
          if (f)
            return f;
        }
      }
    if (v.length === 0)
      return;
    const E = 1 / v.length;
    return v.forEach((C, x) => C.distanceSq += x * E), v.sort((C, x) => C.distanceSq - x.distanceSq), v.some((C) => f = C.callback(C.feature, C.layer, C.geometry)), f;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(t, n, s, r, i, a) {
    return this.forEachFeatureAtCoordinate(
      t,
      n,
      s,
      r,
      ms,
      this,
      i,
      a
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(t) {
    Gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(t) {
    Ad.canExpireCache() && t.postRenderFunctions.push(WL);
  }
}
function WL(e, t) {
  Ad.expire();
}
const zL = UL;
class KL extends zL {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(t) {
    super(t), this.fontChangeListenerKey_ = ve(
      Ns,
      Zl.PROPERTYCHANGE,
      t.redrawText.bind(t)
    ), this.element_ = document.createElement("div");
    const n = this.element_.style;
    n.position = "absolute", n.width = "100%", n.height = "100%", n.zIndex = "0", this.element_.className = Bf + " ol-layers";
    const s = t.getViewport();
    s.insertBefore(this.element_, s.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(t, n) {
    const s = this.getMap();
    if (s.hasListener(t)) {
      const r = new G1(t, void 0, n);
      s.dispatchEvent(r);
    }
  }
  disposeInternal() {
    Ue(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(t) {
    if (!t) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(t), this.dispatchRenderEvent(Fa.PRECOMPOSE, t);
    const n = t.layerStatesArray.sort(function(a, o) {
      return a.zIndex - o.zIndex;
    }), s = t.viewState;
    this.children_.length = 0;
    const r = [];
    let i = null;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a];
      t.layerIndex = a;
      const f = l.layer, d = f.getSourceState();
      if (!Dy(l, s) || d != "ready" && d != "undefined") {
        f.unrender();
        continue;
      }
      const u = f.render(t, i);
      u && (u !== i && (this.children_.push(u), i = u), "getDeclutter" in f && r.push(
        /** @type {import("../layer/BaseVector.js").default} */
        f
      ));
    }
    for (let a = r.length - 1; a >= 0; --a)
      r[a].renderDeclutter(t);
    vA(this.element_, this.children_), this.dispatchRenderEvent(Fa.POSTCOMPOSE, t), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(t);
  }
}
const GL = KL;
class ba extends Wi {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(t, n) {
    super(t), this.layer = n;
  }
}
const bp = {
  LAYERS: "layers"
};
class Vy extends N1 {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {Options} */
      Object.assign({}, t)
    );
    delete n.layers;
    let s = t.layers;
    super(n), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(bp.LAYERS, this.handleLayersChanged_), s ? Array.isArray(s) ? s = new Fi(s.slice(), { unique: !0 }) : Zt(typeof /** @type {?} */
    s.getArray == "function", 43) : s = new Fi(void 0, { unique: !0 }), this.setLayers(s);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(Ue), this.layersListenerKeys_.length = 0;
    const t = this.getLayers();
    this.layersListenerKeys_.push(
      ve(t, zn.ADD, this.handleLayersAdd_, this),
      ve(t, zn.REMOVE, this.handleLayersRemove_, this)
    );
    for (const s in this.listenerKeys_)
      this.listenerKeys_[s].forEach(Ue);
    cu(this.listenerKeys_);
    const n = t.getArray();
    for (let s = 0, r = n.length; s < r; s++) {
      const i = n[s];
      this.registerLayerListeners_(i), this.dispatchEvent(new ba("addlayer", i));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(t) {
    const n = [
      ve(
        t,
        Zl.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      ve(t, Kt.CHANGE, this.handleLayerChange_, this)
    ];
    t instanceof Vy && n.push(
      ve(t, "addlayer", this.handleLayerGroupAdd_, this),
      ve(t, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[Xt(t)] = n;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(t) {
    this.dispatchEvent(new ba("addlayer", t.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(t) {
    this.dispatchEvent(new ba("removelayer", t.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(t) {
    const n = t.element;
    this.registerLayerListeners_(n), this.dispatchEvent(new ba("addlayer", n)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(t) {
    const n = t.element, s = Xt(n);
    this.listenerKeys_[s].forEach(Ue), delete this.listenerKeys_[s], this.dispatchEvent(new ba("removelayer", n)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(bp.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(t) {
    const n = this.getLayers();
    if (n) {
      const s = n.getArray();
      for (let r = 0, i = s.length; r < i; ++r)
        this.dispatchEvent(new ba("removelayer", s[r]));
    }
    this.set(bp.LAYERS, t);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(t) {
    return t = t !== void 0 ? t : [], this.getLayers().forEach(function(n) {
      n.getLayersArray(t);
    }), t;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(t) {
    const n = t !== void 0 ? t : [], s = n.length;
    this.getLayers().forEach(function(a) {
      a.getLayerStatesArray(n);
    });
    const r = this.getLayerState();
    let i = r.zIndex;
    !t && r.zIndex === void 0 && (i = 0);
    for (let a = s, o = n.length; a < o; a++) {
      const l = n[a];
      l.opacity *= r.opacity, l.visible = l.visible && r.visible, l.maxResolution = Math.min(
        l.maxResolution,
        r.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        r.minResolution
      ), l.minZoom = Math.max(l.minZoom, r.minZoom), l.maxZoom = Math.min(l.maxZoom, r.maxZoom), r.extent !== void 0 && (l.extent !== void 0 ? l.extent = Ys(
        l.extent,
        r.extent
      ) : l.extent = r.extent), l.zIndex === void 0 && (l.zIndex = i);
    }
    return n;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const Ga = Vy;
class kL extends Wi {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(t, n, s) {
    super(t), this.map = n, this.frameState = s !== void 0 ? s : null;
  }
}
const El = kL;
class HL extends El {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, i), this.originalEvent = s, this.pixel_ = null, this.coordinate_ = null, this.dragging = r !== void 0 ? r : !1, this.activePointers = a;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(t) {
    this.pixel_ = t;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(t) {
    this.coordinate_ = t;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const js = HL, Pe = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: Kt.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: Kt.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Gg = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class YL extends Nc {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(t, n) {
    super(t), this.map_ = t, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = n === void 0 ? 1 : n, this.down_ = null;
    const s = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = s, this.pointerdownListenerKey_ = ve(
      s,
      Gg.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = ve(
      s,
      Gg.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      Kt.TOUCHMOVE,
      this.boundHandleTouchMove_,
      qO ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(t) {
    let n = new js(
      Pe.CLICK,
      this.map_,
      t
    );
    this.dispatchEvent(n), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, n = new js(
      Pe.DBLCLICK,
      this.map_,
      t
    ), this.dispatchEvent(n)) : this.clickTimeoutId_ = setTimeout(
      /** @this {MapBrowserEventHandler} */
      (function() {
        this.clickTimeoutId_ = void 0;
        const s = new js(
          Pe.SINGLECLICK,
          this.map_,
          t
        );
        this.dispatchEvent(s);
      }).bind(this),
      250
    );
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(t) {
    const n = t, s = n.pointerId;
    if (n.type == Pe.POINTERUP || n.type == Pe.POINTERCANCEL) {
      delete this.trackedTouches_[s];
      for (const r in this.trackedTouches_)
        if (this.trackedTouches_[r].target !== n.target) {
          delete this.trackedTouches_[r];
          break;
        }
    } else
      (n.type == Pe.POINTERDOWN || n.type == Pe.POINTERMOVE) && (this.trackedTouches_[s] = n);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(t) {
    this.updateActivePointers_(t);
    const n = new js(
      Pe.POINTERUP,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(n), this.emulateClicks_ && !n.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Ue), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(t) {
    return t.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(t) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(t);
    const n = new js(
      Pe.POINTERDOWN,
      this.map_,
      t,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(n), this.down_ = /** @type {PointerEvent} */
    {};
    for (const s in t) {
      const r = t[s];
      this.down_[s] = typeof r == "function" ? Vo : r;
    }
    if (this.dragListenerKeys_.length === 0) {
      const s = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        ve(
          s,
          Pe.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        ve(s, Pe.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        ve(
          this.element_,
          Pe.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== s && this.dragListenerKeys_.push(
        ve(
          this.element_.getRootNode(),
          Pe.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.isMoving_(t)) {
      this.updateActivePointers_(t), this.dragging_ = !0;
      const n = new js(
        Pe.POINTERDRAG,
        this.map_,
        t,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(n);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(t) {
    this.originalPointerMoveEvent_ = t;
    const n = !!(this.down_ && this.isMoving_(t));
    this.dispatchEvent(
      new js(
        Pe.POINTERMOVE,
        this.map_,
        t,
        n
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(t) {
    const n = this.originalPointerMoveEvent_;
    (!n || n.defaultPrevented) && (typeof t.cancelable != "boolean" || t.cancelable === !0) && t.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(t) {
    return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (Ue(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      Kt.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (Ue(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Ue), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const XL = YL, $s = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, oi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, Vd = 1 / 0;
class ZL {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(t, n) {
    this.priorityFunction_ = t, this.keyFunction_ = n, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, cu(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const t = this.elements_, n = this.priorities_, s = t[0];
    t.length == 1 ? (t.length = 0, n.length = 0) : (t[0] = t.pop(), n[0] = n.pop(), this.siftUp_(0));
    const r = this.keyFunction_(s);
    return delete this.queuedElements_[r], s;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(t) {
    Zt(!(this.keyFunction_(t) in this.queuedElements_), 31);
    const n = this.priorityFunction_(t);
    return n != Vd ? (this.elements_.push(t), this.priorities_.push(n), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(t) {
    return t * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(t) {
    return t * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(t) {
    return t - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let t;
    for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
      this.siftUp_(t);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(t) {
    return t in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(t) {
    return this.isKeyQueued(this.keyFunction_(t));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(t) {
    const n = this.elements_, s = this.priorities_, r = n.length, i = n[t], a = s[t], o = t;
    for (; t < r >> 1; ) {
      const l = this.getLeftChildIndex_(t), f = this.getRightChildIndex_(t), d = f < r && s[f] < s[l] ? f : l;
      n[t] = n[d], s[t] = s[d], t = d;
    }
    n[t] = i, s[t] = a, this.siftDown_(o, t);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(t, n) {
    const s = this.elements_, r = this.priorities_, i = s[n], a = r[n];
    for (; n > t; ) {
      const o = this.getParentIndex_(n);
      if (r[o] > a)
        s[n] = s[o], r[n] = r[o], n = o;
      else
        break;
    }
    s[n] = i, r[n] = a;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const t = this.priorityFunction_, n = this.elements_, s = this.priorities_;
    let r = 0;
    const i = n.length;
    let a, o, l;
    for (o = 0; o < i; ++o)
      a = n[o], l = t(a), l == Vd ? delete this.queuedElements_[this.keyFunction_(a)] : (s[r] = l, n[r++] = a);
    n.length = r, s.length = r, this.heapify_();
  }
}
const JL = ZL;
class QL extends JL {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(t, n) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(s) {
        return t.apply(null, s);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(s) {
        return (
          /** @type {import("./Tile.js").default} */
          s[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = n, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(t) {
    const n = super.enqueue(t);
    return n && t[0].addEventListener(Kt.CHANGE, this.boundHandleTileChange_), n;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const n = (
      /** @type {import("./Tile.js").default} */
      t.target
    ), s = n.getState();
    if (s === _t.LOADED || s === _t.ERROR || s === _t.EMPTY) {
      s !== _t.ERROR && n.removeEventListener(Kt.CHANGE, this.boundHandleTileChange_);
      const r = n.getKey();
      r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(t, n) {
    let s = 0, r, i, a;
    for (; this.tilesLoading_ < t && s < n && this.getCount() > 0; )
      i = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], a = i.getKey(), r = i.getState(), r === _t.IDLE && !(a in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[a] = !0, ++this.tilesLoading_, ++s, i.load());
  }
}
const qL = QL;
function tR(e, t, n, s, r) {
  if (!e || !(n in e.wantedTiles) || !e.wantedTiles[n][t.getKey()])
    return Vd;
  const i = e.viewState.center, a = s[0] - i[0], o = s[1] - i[1];
  return 65536 * Math.log(r) + Math.sqrt(a * a + o * o) / r;
}
const Ir = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, nP = 42, By = 256;
function vC(e, t, n) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(s, r, i, a, o) {
      if (!s)
        return;
      if (!r && !t)
        return s;
      const l = t ? 0 : i[0] * r, f = t ? 0 : i[1] * r, d = o ? o[0] : 0, u = o ? o[1] : 0;
      let c = e[0] + l / 2 + d, h = e[2] - l / 2 + d, p = e[1] + f / 2 + u, g = e[3] - f / 2 + u;
      c > h && (c = (h + c) / 2, h = c), p > g && (p = (g + p) / 2, g = p);
      let m = dn(s[0], c, h), v = dn(s[1], p, g);
      if (a && n && r) {
        const y = 30 * r;
        m += -y * Math.log(1 + Math.max(0, c - s[0]) / y) + y * Math.log(1 + Math.max(0, s[0] - h) / y), v += -y * Math.log(1 + Math.max(0, p - s[1]) / y) + y * Math.log(1 + Math.max(0, s[1] - g) / y);
      }
      return [m, v];
    }
  );
}
function eR(e) {
  return e;
}
function Fy(e, t, n, s) {
  const r = Ee(t) / n[0], i = In(t) / n[1];
  return s ? Math.min(e, Math.max(r, i)) : Math.min(e, Math.min(r, i));
}
function Ny(e, t, n) {
  let s = Math.min(e, t);
  const r = 50;
  return s *= Math.log(1 + r * Math.max(0, e / t - 1)) / r + 1, n && (s = Math.max(s, n), s /= Math.log(1 + r * Math.max(0, n / e - 1)) / r + 1), dn(s, n / 2, t * 2);
}
function nR(e, t, n, s) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, i, a, o) {
    if (r !== void 0) {
      const l = e[0], f = e[e.length - 1], d = n ? Fy(
        l,
        n,
        a,
        s
      ) : l;
      if (o)
        return t ? Ny(
          r,
          d,
          f
        ) : dn(r, f, d);
      const u = Math.min(d, r), c = Math.floor(Pf(e, u, i));
      return e[c] > d && c < e.length - 1 ? e[c + 1] : e[c];
    } else
      return;
  };
}
function iR(e, t, n, s, r, i) {
  return s = s !== void 0 ? s : !0, n = n !== void 0 ? n : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, l, f) {
    if (a !== void 0) {
      const d = r ? Fy(
        t,
        r,
        l,
        i
      ) : t;
      if (f)
        return s ? Ny(
          a,
          d,
          n
        ) : dn(a, n, d);
      const u = 1e-9, c = Math.ceil(
        Math.log(t / d) / Math.log(e) - u
      ), h = -o * (0.5 - u) + 0.5, p = Math.min(d, a), g = Math.floor(
        Math.log(t / p) / Math.log(e) + h
      ), m = Math.max(c, g), v = t / Math.pow(e, m);
      return dn(v, n, d);
    } else
      return;
  };
}
function yC(e, t, n, s, r) {
  return n = n !== void 0 ? n : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(i, a, o, l) {
    if (i !== void 0) {
      const f = s ? Fy(
        e,
        s,
        o,
        r
      ) : e;
      return !n || !l ? dn(i, t, f) : Ny(
        i,
        f,
        t
      );
    } else
      return;
  };
}
function jy(e) {
  if (e !== void 0)
    return 0;
}
function EC(e) {
  if (e !== void 0)
    return e;
}
function rR(e) {
  const t = 2 * Math.PI / e;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(n, s) {
      if (s)
        return n;
      if (n !== void 0)
        return n = Math.floor(n / t + 0.5) * t, n;
    }
  );
}
function sR(e) {
  return e = e || _o(5), /**
   * @param {number|undefined} rotation Rotation.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Rotation.
   */
  function(t, n) {
    if (n)
      return t;
    if (t !== void 0)
      return Math.abs(t) <= e ? 0 : t;
  };
}
const Tp = 0;
class aR extends xr {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = Object.assign({}, t), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = hy(t.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, t.projection && wD(), t.center && (t.center = Ar(t.center, this.projection_)), t.extent && (t.extent = Ks(t.extent, this.projection_)), this.applyOptions_(t);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(t) {
    const n = Object.assign({}, t);
    for (const o in Ir)
      delete n[o];
    this.setProperties(n, !0);
    const s = lR(t);
    this.maxResolution_ = s.maxResolution, this.minResolution_ = s.minResolution, this.zoomFactor_ = s.zoomFactor, this.resolutions_ = t.resolutions, this.padding_ = t.padding, this.minZoom_ = s.minZoom;
    const r = oR(t), i = s.constraint, a = uR(t);
    this.constraints_ = {
      center: r,
      resolution: i,
      rotation: a
    }, this.setRotation(t.rotation !== void 0 ? t.rotation : 0), this.setCenterInternal(
      t.center !== void 0 ? t.center : null
    ), t.resolution !== void 0 ? this.setResolution(t.resolution) : t.zoom !== void 0 && this.setZoom(t.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(t) {
    let n = this.padding_;
    this.padding_ = t;
    const s = this.getCenter();
    if (s) {
      const r = t || [0, 0, 0, 0];
      n = n || [0, 0, 0, 0];
      const i = this.getResolution(), a = i / 2 * (r[3] - n[3] + n[1] - r[1]), o = i / 2 * (r[0] - n[0] + n[2] - r[2]);
      this.setCenterInternal([s[0] + a, s[1] - o]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(t) {
    const n = this.getProperties();
    return n.resolution !== void 0 ? n.resolution = this.getResolution() : n.zoom = this.getZoom(), n.center = this.getCenterInternal(), n.rotation = this.getRotation(), Object.assign({}, n, t);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(t) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const n = new Array(arguments.length);
    for (let s = 0; s < n.length; ++s) {
      let r = arguments[s];
      r.center && (r = Object.assign({}, r), r.center = Ar(
        r.center,
        this.getProjection()
      )), r.anchor && (r = Object.assign({}, r), r.anchor = Ar(
        r.anchor,
        this.getProjection()
      )), n[s] = r;
    }
    this.animateInternal.apply(this, n);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(t) {
    let n = arguments.length, s;
    n > 1 && typeof arguments[n - 1] == "function" && (s = arguments[n - 1], --n);
    let r = 0;
    for (; r < n && !this.isDef(); ++r) {
      const d = arguments[r];
      d.center && this.setCenterInternal(d.center), d.zoom !== void 0 ? this.setZoom(d.zoom) : d.resolution && this.setResolution(d.resolution), d.rotation !== void 0 && this.setRotation(d.rotation);
    }
    if (r === n) {
      s && xh(s, !0);
      return;
    }
    let i = Date.now(), a = this.targetCenter_.slice(), o = this.targetResolution_, l = this.targetRotation_;
    const f = [];
    for (; r < n; ++r) {
      const d = (
        /** @type {AnimationOptions} */
        arguments[r]
      ), u = {
        start: i,
        complete: !1,
        anchor: d.anchor,
        duration: d.duration !== void 0 ? d.duration : 1e3,
        easing: d.easing || VL,
        callback: s
      };
      if (d.center && (u.sourceCenter = a, u.targetCenter = d.center.slice(), a = u.targetCenter), d.zoom !== void 0 ? (u.sourceResolution = o, u.targetResolution = this.getResolutionForZoom(d.zoom), o = u.targetResolution) : d.resolution && (u.sourceResolution = o, u.targetResolution = d.resolution, o = u.targetResolution), d.rotation !== void 0) {
        u.sourceRotation = l;
        const c = Va(d.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        u.targetRotation = l + c, l = u.targetRotation;
      }
      cR(u) ? u.complete = !0 : i += u.duration, f.push(u);
    }
    this.animations_.push(f), this.setHint(en.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[en.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[en.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(en.ANIMATING, -this.hints_[en.ANIMATING]);
    let t;
    for (let n = 0, s = this.animations_.length; n < s; ++n) {
      const r = this.animations_[n];
      if (r[0].callback && xh(r[0].callback, !1), !t)
        for (let i = 0, a = r.length; i < a; ++i) {
          const o = r[i];
          if (!o.complete) {
            t = o.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = t, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const t = Date.now();
    let n = !1;
    for (let s = this.animations_.length - 1; s >= 0; --s) {
      const r = this.animations_[s];
      let i = !0;
      for (let a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        if (l.complete)
          continue;
        const f = t - l.start;
        let d = l.duration > 0 ? f / l.duration : 1;
        d >= 1 ? (l.complete = !0, d = 1) : i = !1;
        const u = l.easing(d);
        if (l.sourceCenter) {
          const c = l.sourceCenter[0], h = l.sourceCenter[1], p = l.targetCenter[0], g = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = c + u * (p - c), v = h + u * (g - h);
          this.targetCenter_ = [m, v];
        }
        if (l.sourceResolution && l.targetResolution) {
          const c = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const h = this.getViewportSize_(this.getRotation()), p = this.constraints_.resolution(
              c,
              0,
              h,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              p,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = c, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const c = u === 1 ? Va(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const h = this.constraints_.rotation(
              c,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              h,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = c;
        }
        if (this.applyTargetState_(!0), n = !0, !l.complete)
          break;
      }
      if (i) {
        this.animations_[s] = null, this.setHint(en.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const a = r[0].callback;
        a && xh(a, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), n && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(t, n) {
    let s;
    const r = this.getCenterInternal();
    return r !== void 0 && (s = [r[0] - n[0], r[1] - n[1]], ay(s, t - this.getRotation()), o1(s, n)), s;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(t, n) {
    let s;
    const r = this.getCenterInternal(), i = this.getResolution();
    if (r !== void 0 && i !== void 0) {
      const a = n[0] - t * (n[0] - r[0]) / i, o = n[1] - t * (n[1] - r[1]) / i;
      s = [a, o];
    }
    return s;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(t) {
    const n = this.viewportSize_;
    if (t) {
      const s = n[0], r = n[1];
      return [
        Math.abs(s * Math.cos(t)) + Math.abs(r * Math.sin(t)),
        Math.abs(s * Math.sin(t)) + Math.abs(r * Math.cos(t))
      ];
    } else
      return n;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(t) {
    this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const t = this.getCenterInternal();
    return t && Fg(t, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Ir.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(t) {
    return t !== void 0 ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(t) {
    const n = this.calculateExtentInternal(t);
    return f1(n, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(t) {
    t = t || this.getViewportSizeMinusPadding_();
    const n = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Zt(n, 1);
    const s = (
      /** @type {!number} */
      this.getResolution()
    );
    Zt(s !== void 0, 2);
    const r = (
      /** @type {!number} */
      this.getRotation()
    );
    return Zt(r !== void 0, 3), $l(n, s, r, t);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(t) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(t) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Ir.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(t, n) {
    return this.getResolutionForExtentInternal(
      Ks(t, this.getProjection()),
      n
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(t, n) {
    n = n || this.getViewportSizeMinusPadding_();
    const s = Ee(t) / n[0], r = In(t) / n[1];
    return Math.max(s, r);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(t) {
    t = t || 2;
    const n = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, r = Math.log(n / s) / Math.log(t);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(i) {
        return n / Math.pow(t, i * r);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Ir.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(t) {
    const n = Math.log(t || 2), s = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, i = Math.log(s / r) / n;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(a) {
        return Math.log(s / a) / n / i;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(t) {
    let n = this.getViewportSize_(t);
    const s = this.padding_;
    return s && (n = [
      n[0] - s[1] - s[3],
      n[1] - s[0] - s[2]
    ]), n;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const t = this.getProjection(), n = this.getResolution(), s = this.getRotation();
    let r = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const i = this.padding_;
    if (i) {
      const a = this.getViewportSizeMinusPadding_();
      r = Op(
        r,
        this.getViewportSize_(),
        [a[0] / 2 + i[3], a[1] / 2 + i[0]],
        n,
        s
      );
    }
    return {
      center: r.slice(0),
      projection: t !== void 0 ? t : null,
      resolution: n,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: s,
      zoom: this.getZoom()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let t;
    const n = this.getResolution();
    return n !== void 0 && (t = this.getZoomForResolution(n)), t;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(t) {
    let n = this.minZoom_ || 0, s, r;
    if (this.resolutions_) {
      const i = Pf(this.resolutions_, t, 1);
      n = i, s = this.resolutions_[i], i == this.resolutions_.length - 1 ? r = 2 : r = s / this.resolutions_[i + 1];
    } else
      s = this.maxResolution_, r = this.zoomFactor_;
    return n + Math.log(s / t) / Math.log(r);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(t) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const n = dn(
        Math.floor(t),
        0,
        this.resolutions_.length - 2
      ), s = this.resolutions_[n] / this.resolutions_[n + 1];
      return this.resolutions_[n] / Math.pow(s, dn(t - n, 0, 1));
    } else
      return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(t, n) {
    let s;
    if (Zt(
      Array.isArray(t) || typeof /** @type {?} */
      t.getSimplifiedGeometry == "function",
      24
    ), Array.isArray(t)) {
      Zt(!Df(t), 25);
      const r = Ks(t, this.getProjection());
      s = ZE(r);
    } else if (t.getType() === "Circle") {
      const r = Ks(
        t.getExtent(),
        this.getProjection()
      );
      s = ZE(r), s.rotate(this.getRotation(), $i(r));
    } else
      s = t;
    this.fitInternal(s, n);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(t) {
    const n = this.getRotation(), s = Math.cos(n), r = Math.sin(-n), i = t.getFlatCoordinates(), a = t.getStride();
    let o = 1 / 0, l = 1 / 0, f = -1 / 0, d = -1 / 0;
    for (let u = 0, c = i.length; u < c; u += a) {
      const h = i[u] * s - i[u + 1] * r, p = i[u] * r + i[u + 1] * s;
      o = Math.min(o, h), l = Math.min(l, p), f = Math.max(f, h), d = Math.max(d, p);
    }
    return [o, l, f, d];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(t, n) {
    n = n || {};
    let s = n.size;
    s || (s = this.getViewportSizeMinusPadding_());
    const r = n.padding !== void 0 ? n.padding : [0, 0, 0, 0], i = n.nearest !== void 0 ? n.nearest : !1;
    let a;
    n.minResolution !== void 0 ? a = n.minResolution : n.maxZoom !== void 0 ? a = this.getResolutionForZoom(n.maxZoom) : a = 0;
    const o = this.rotatedExtentForGeometry(t);
    let l = this.getResolutionForExtentInternal(o, [
      s[0] - r[1] - r[3],
      s[1] - r[0] - r[2]
    ]);
    l = isNaN(l) ? a : Math.max(l, a), l = this.getConstrainedResolution(l, i ? 0 : 1);
    const f = this.getRotation(), d = Math.sin(f), u = Math.cos(f), c = $i(o);
    c[0] += (r[1] - r[3]) / 2 * l, c[1] += (r[0] - r[2]) / 2 * l;
    const h = c[0] * u - c[1] * d, p = c[1] * u + c[0] * d, g = this.getConstrainedCenter([h, p], l), m = n.callback ? n.callback : Vo;
    n.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: g,
        duration: n.duration,
        easing: n.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = g, this.applyTargetState_(!1, !0), xh(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(t, n, s) {
    this.centerOnInternal(
      Ar(t, this.getProjection()),
      n,
      s
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(t, n, s) {
    this.setCenterInternal(
      Op(
        t,
        n,
        s,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(t, n, s, r) {
    let i;
    const a = this.padding_;
    if (a && t) {
      const o = this.getViewportSizeMinusPadding_(-s), l = Op(
        t,
        r,
        [o[0] / 2 + a[3], o[1] / 2 + a[0]],
        n,
        s
      );
      i = [
        t[0] - l[0],
        t[1] - l[1]
      ];
    }
    return i;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(t) {
    const n = Fg(this.targetCenter_, this.getProjection());
    this.setCenter([
      n[0] + t[0],
      n[1] + t[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(t) {
    const n = this.targetCenter_;
    this.setCenterInternal([
      n[0] + t[0],
      n[1] + t[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(t, n) {
    n = n && Ar(n, this.getProjection()), this.adjustResolutionInternal(t, n);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(t, n) {
    const s = this.getAnimating() || this.getInteracting(), r = this.getViewportSize_(this.getRotation()), i = this.constraints_.resolution(
      this.targetResolution_ * t,
      0,
      r,
      s
    );
    n && (this.targetCenter_ = this.calculateCenterZoom(i, n)), this.targetResolution_ *= t, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(t, n) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -t), n);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(t, n) {
    n && (n = Ar(n, this.getProjection())), this.adjustRotationInternal(t, n);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(t, n) {
    const s = this.getAnimating() || this.getInteracting(), r = this.constraints_.rotation(
      this.targetRotation_ + t,
      s
    );
    n && (this.targetCenter_ = this.calculateCenterRotate(r, n)), this.targetRotation_ += t, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(t) {
    this.setCenterInternal(
      t && Ar(t, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(t) {
    this.targetCenter_ = t, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(t, n) {
    return this.hints_[t] += n, this.changed(), this.hints_[t];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(t) {
    this.targetResolution_ = t, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(t) {
    this.targetRotation_ = t, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(t) {
    this.setResolution(this.getResolutionForZoom(t));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(t, n) {
    const s = this.getAnimating() || this.getInteracting() || n, r = this.constraints_.rotation(
      this.targetRotation_,
      s
    ), i = this.getViewportSize_(r), a = this.constraints_.resolution(
      this.targetResolution_,
      0,
      i,
      s
    ), o = this.constraints_.center(
      this.targetCenter_,
      a,
      i,
      s,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        r,
        i
      )
    );
    this.get(Ir.ROTATION) !== r && this.set(Ir.ROTATION, r), this.get(Ir.RESOLUTION) !== a && (this.set(Ir.RESOLUTION, a), this.set("zoom", this.getZoom(), !0)), (!o || !this.get(Ir.CENTER) || !Ed(this.get(Ir.CENTER), o)) && this.set(Ir.CENTER, o), this.getAnimating() && !t && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(t, n, s) {
    t = t !== void 0 ? t : 200;
    const r = n || 0, i = this.constraints_.rotation(this.targetRotation_), a = this.getViewportSize_(i), o = this.constraints_.resolution(
      this.targetResolution_,
      r,
      a
    ), l = this.constraints_.center(
      this.targetCenter_,
      o,
      a,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        i,
        a
      )
    );
    if (t === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = o, this.targetRotation_ = i, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    s = s || (t === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== o || this.getRotation() !== i || !this.getCenterInternal() || !Ed(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: i,
      center: l,
      resolution: o,
      duration: t,
      easing: qo,
      anchor: s
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(en.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(t, n, s) {
    s = s && Ar(s, this.getProjection()), this.endInteractionInternal(t, n, s);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(t, n, s) {
    this.setHint(en.INTERACTING, -1), this.resolveConstraints(t, n, s);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(t, n) {
    const s = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      t,
      n || this.getResolution(),
      s
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(t, n) {
    const s = this.getResolutionForZoom(t);
    return this.getZoomForResolution(
      this.getConstrainedResolution(s, n)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(t, n) {
    n = n || 0;
    const s = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(t, n, s);
  }
}
function xh(e, t) {
  setTimeout(function() {
    e(t);
  }, 0);
}
function oR(e) {
  if (e.extent !== void 0) {
    const n = e.smoothExtentConstraint !== void 0 ? e.smoothExtentConstraint : !0;
    return vC(e.extent, e.constrainOnlyCenter, n);
  }
  const t = hy(e.projection, "EPSG:3857");
  if (e.multiWorld !== !0 && t.isGlobal()) {
    const n = t.getExtent().slice();
    return n[0] = -1 / 0, n[2] = 1 / 0, vC(n, !1, !1);
  }
  return eR;
}
function lR(e) {
  let t, n, s, a = e.minZoom !== void 0 ? e.minZoom : Tp, o = e.maxZoom !== void 0 ? e.maxZoom : 28;
  const l = e.zoomFactor !== void 0 ? e.zoomFactor : 2, f = e.multiWorld !== void 0 ? e.multiWorld : !1, d = e.smoothResolutionConstraint !== void 0 ? e.smoothResolutionConstraint : !0, u = e.showFullExtent !== void 0 ? e.showFullExtent : !1, c = hy(e.projection, "EPSG:3857"), h = c.getExtent();
  let p = e.constrainOnlyCenter, g = e.extent;
  if (!f && !g && c.isGlobal() && (p = !1, g = h), e.resolutions !== void 0) {
    const m = e.resolutions;
    n = m[a], s = m[o] !== void 0 ? m[o] : m[m.length - 1], e.constrainResolution ? t = nR(
      m,
      d,
      !p && g,
      u
    ) : t = yC(
      n,
      s,
      d,
      !p && g,
      u
    );
  } else {
    const v = (h ? Math.max(Ee(h), In(h)) : (
      // use an extent that can fit the whole world if need be
      360 * ql.degrees / c.getMetersPerUnit()
    )) / By / Math.pow(2, Tp), y = v / Math.pow(2, 28 - Tp);
    n = e.maxResolution, n !== void 0 ? a = 0 : n = v / Math.pow(l, a), s = e.minResolution, s === void 0 && (e.maxZoom !== void 0 ? e.maxResolution !== void 0 ? s = n / Math.pow(l, o) : s = v / Math.pow(l, o) : s = y), o = a + Math.floor(
      Math.log(n / s) / Math.log(l)
    ), s = n / Math.pow(l, o - a), e.constrainResolution ? t = iR(
      l,
      n,
      s,
      d,
      !p && g,
      u
    ) : t = yC(
      n,
      s,
      d,
      !p && g,
      u
    );
  }
  return {
    constraint: t,
    maxResolution: n,
    minResolution: s,
    minZoom: a,
    zoomFactor: l
  };
}
function uR(e) {
  if (e.enableRotation !== void 0 ? e.enableRotation : !0) {
    const n = e.constrainRotation;
    return n === void 0 || n === !0 ? sR() : n === !1 ? EC : typeof n == "number" ? rR(n) : EC;
  } else
    return jy;
}
function cR(e) {
  return !(e.sourceCenter && e.targetCenter && !Ed(e.sourceCenter, e.targetCenter) || e.sourceResolution !== e.targetResolution || e.sourceRotation !== e.targetRotation);
}
function Op(e, t, n, s, r) {
  const i = Math.cos(-r);
  let a = Math.sin(-r), o = e[0] * i - e[1] * a, l = e[1] * i + e[0] * a;
  o += (t[0] / 2 - n[0]) * s, l += (n[1] - t[1] / 2) * s, a = -a;
  const f = o * i - l * a, d = l * i + o * a;
  return [f, d];
}
const Ta = aR;
class hR extends xr {
  /**
   * @param {Options} options Control options.
   */
  constructor(t) {
    super();
    const n = t.element;
    n && !t.target && !n.style.pointerEvents && (n.style.pointerEvents = "auto"), this.element = n || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], t.render && (this.render = t.render), t.target && this.setTarget(t.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    Md(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.map_ && Md(this.element);
    for (let n = 0, s = this.listenerKeys.length; n < s; ++n)
      Ue(this.listenerKeys[n]);
    this.listenerKeys.length = 0, this.map_ = t, t && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Vo && this.listenerKeys.push(
      ve(t, $s.POSTRENDER, this.render, this)
    ), t.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(t) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(t) {
    this.target_ = typeof t == "string" ? document.getElementById(t) : t;
  }
}
const $y = hR;
class dR extends $y {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = t.collapsed !== void 0 ? t.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = t.collapsible !== void 0, this.collapsible_ = t.collapsible !== void 0 ? t.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const n = t.className !== void 0 ? t.className : "ol-attribution", s = t.tipLabel !== void 0 ? t.tipLabel : "Attributions", r = t.expandClassName !== void 0 ? t.expandClassName : n + "-expand", i = t.collapseLabel !== void 0 ? t.collapseLabel : "", a = t.collapseClassName !== void 0 ? t.collapseClassName : n + "-collapse";
    typeof i == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = i, this.collapseLabel_.className = a) : this.collapseLabel_ = i;
    const o = t.label !== void 0 ? t.label : "i";
    typeof o == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = r) : this.label_ = o;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = s, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const f = n + " " + Bf + " " + Sy + (this.collapsed_ && this.collapsible_ ? " " + eC : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), d = this.element;
    d.className = f, d.appendChild(this.toggleButton_), d.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(t) {
    const n = {}, s = [];
    let r = !0;
    const i = t.layerStatesArray;
    for (let a = 0, o = i.length; a < o; ++a) {
      const l = i[a];
      if (!Dy(l, t.viewState))
        continue;
      const f = (
        /** @type {import("../layer/Layer.js").default} */
        l.layer.getSource()
      );
      if (!f)
        continue;
      const d = f.getAttributions();
      if (!d)
        continue;
      const u = d(t);
      if (u)
        if (r = r && f.getAttributionsCollapsible() !== !1, Array.isArray(u))
          for (let c = 0, h = u.length; c < h; ++c)
            u[c] in n || (s.push(u[c]), n[u[c]] = !0);
        else
          u in n || (s.push(u), n[u] = !0);
    }
    return this.overrideCollapsible_ || this.setCollapsible(r), s;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(t) {
    if (!t) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const n = this.collectSourceAttributions_(t), s = n.length > 0;
    if (this.renderedVisible_ != s && (this.element.style.display = s ? "" : "none", this.renderedVisible_ = s), !Jo(n, this.renderedAttributions_)) {
      A1(this.ulElement_);
      for (let r = 0, i = n.length; r < i; ++r) {
        const a = document.createElement("li");
        a.innerHTML = n[r], this.ulElement_.appendChild(a);
      }
      this.renderedAttributions_ = n;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(eC), this.collapsed_ ? tC(this.collapseLabel_, this.label_) : tC(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(t) {
    this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(t) {
    this.userCollapsed_ = t, !(!this.collapsible_ || this.collapsed_ === t) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    this.updateElement_(t.frameState);
  }
}
const fR = dR;
class pR extends $y {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      render: t.render,
      target: t.target
    });
    const n = t.className !== void 0 ? t.className : "ol-rotate", s = t.label !== void 0 ? t.label : "", r = t.compassClassName !== void 0 ? t.compassClassName : "ol-compass";
    this.label_ = null, typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.className = r, this.label_.textContent = s) : (this.label_ = s, this.label_.classList.add(r));
    const i = t.tipLabel ? t.tipLabel : "Reset rotation", a = document.createElement("button");
    a.className = n + "-reset", a.setAttribute("type", "button"), a.title = i, a.appendChild(this.label_), a.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const o = n + " " + Bf + " " + Sy, l = this.element;
    l.className = o, l.appendChild(a), this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.autoHide_ = t.autoHide !== void 0 ? t.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(vh);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t) {
    t.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const n = this.getMap().getView();
    if (!n)
      return;
    const s = n.getRotation();
    s !== void 0 && (this.duration_ > 0 && s % (2 * Math.PI) !== 0 ? n.animate({
      rotation: 0,
      duration: this.duration_,
      easing: qo
    }) : n.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(t) {
    const n = t.frameState;
    if (!n)
      return;
    const s = n.viewState.rotation;
    if (s != this.rotation_) {
      const r = "rotate(" + s + "rad)";
      if (this.autoHide_) {
        const i = this.element.classList.contains(vh);
        !i && s === 0 ? this.element.classList.add(vh) : i && s !== 0 && this.element.classList.remove(vh);
      }
      this.label_.style.transform = r;
    }
    this.rotation_ = s;
  }
}
const mR = pR;
let gR = class extends $y {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(t) {
    t = t || {}, super({
      element: document.createElement("div"),
      target: t.target
    });
    const n = t.className !== void 0 ? t.className : "ol-zoom", s = t.delta !== void 0 ? t.delta : 1, r = t.zoomInClassName !== void 0 ? t.zoomInClassName : n + "-in", i = t.zoomOutClassName !== void 0 ? t.zoomOutClassName : n + "-out", a = t.zoomInLabel !== void 0 ? t.zoomInLabel : "+", o = t.zoomOutLabel !== void 0 ? t.zoomOutLabel : "", l = t.zoomInTipLabel !== void 0 ? t.zoomInTipLabel : "Zoom in", f = t.zoomOutTipLabel !== void 0 ? t.zoomOutTipLabel : "Zoom out", d = document.createElement("button");
    d.className = r, d.setAttribute("type", "button"), d.title = l, d.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), d.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this, s),
      !1
    );
    const u = document.createElement("button");
    u.className = i, u.setAttribute("type", "button"), u.title = f, u.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), u.addEventListener(
      Kt.CLICK,
      this.handleClick_.bind(this, -s),
      !1
    );
    const c = n + " " + Bf + " " + Sy, h = this.element;
    h.className = c, h.appendChild(d), h.appendChild(u), this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(t, n) {
    n.preventDefault(), this.zoomByDelta_(t);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(t) {
    const s = this.getMap().getView();
    if (!s)
      return;
    const r = s.getZoom();
    if (r !== void 0) {
      const i = s.getConstrainedZoom(r + t);
      this.duration_ > 0 ? (s.getAnimating() && s.cancelAnimations(), s.animate({
        zoom: i,
        duration: this.duration_,
        easing: qo
      })) : s.setZoom(i);
    }
  }
};
const vR = gR;
function yR(e) {
  e = e || {};
  const t = new Fi();
  return (e.zoom !== void 0 ? e.zoom : !0) && t.push(new vR(e.zoomOptions)), (e.rotate !== void 0 ? e.rotate : !0) && t.push(new mR(e.rotateOptions)), (e.attribution !== void 0 ? e.attribution : !0) && t.push(new fR(e.attributionOptions)), t;
}
const Bd = {
  ACTIVE: "active"
};
class ER extends xr {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t && t.handleEvent && (this.handleEvent = t.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Bd.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(t) {
    this.set(Bd.ACTIVE, t);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    this.map_ = t;
  }
}
function CR(e, t, n) {
  const s = e.getCenterInternal();
  if (s) {
    const r = [s[0] + t[0], s[1] + t[1]];
    e.animateInternal({
      duration: n !== void 0 ? n : 250,
      easing: tP,
      center: e.getConstrainedCenter(r)
    });
  }
}
function Uy(e, t, n, s) {
  const r = e.getZoom();
  if (r === void 0)
    return;
  const i = e.getConstrainedZoom(r + t), a = e.getResolutionForZoom(i);
  e.getAnimating() && e.cancelAnimations(), e.animate({
    resolution: a,
    anchor: n,
    duration: s !== void 0 ? s : 250,
    easing: qo
  });
}
const du = ER;
class xR extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Pe.DBLCLICK) {
      const s = (
        /** @type {MouseEvent} */
        t.originalEvent
      ), r = t.map, i = t.coordinate, a = s.shiftKey ? -this.delta_ : this.delta_, o = r.getView();
      Uy(o, a, i, this.duration_), s.preventDefault(), n = !0;
    }
    return !n;
  }
}
const bR = xR;
class TR extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent), t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent), t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent), t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent), t.stopDown && (this.stopDown = t.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(t) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(t) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    if (!t.originalEvent)
      return !0;
    let n = !1;
    if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
      if (t.type == Pe.POINTERDRAG)
        this.handleDragEvent(t), t.originalEvent.preventDefault();
      else if (t.type == Pe.POINTERUP) {
        const s = this.handleUpEvent(t);
        this.handlingDownUpSequence = s && this.targetPointers.length > 0;
      }
    } else if (t.type == Pe.POINTERDOWN) {
      const s = this.handleDownEvent(t);
      this.handlingDownUpSequence = s, n = this.stopDown(s);
    } else
      t.type == Pe.POINTERMOVE && this.handleMoveEvent(t);
    return !n;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(t) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(t) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(t) {
    return t;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(t) {
    t.activePointers && (this.targetPointers = t.activePointers);
  }
}
function Wy(e) {
  const t = e.length;
  let n = 0, s = 0;
  for (let r = 0; r < t; r++)
    n += e[r].clientX, s += e[r].clientY;
  return [n / t, s / t];
}
const tl = TR;
function kg(e) {
  const t = arguments;
  return function(n) {
    let s = !0;
    for (let r = 0, i = t.length; r < i && (s = s && t[r](n), !!s); ++r)
      ;
    return s;
  };
}
const OR = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, PR = function(e) {
  const t = e.map.getTargetElement(), n = e.map.getOwnerDocument().activeElement;
  return t.contains(n);
}, iP = function(e) {
  return e.map.getTargetElement().hasAttribute("tabindex") ? PR(e) : !0;
}, Fd = ms, rP = function(e) {
  const t = (
    /** @type {MouseEvent} */
    e.originalEvent
  );
  return t.button == 0 && !(uD && QO && t.ctrlKey);
}, Hg = uu, SR = function(e) {
  return e.type == "pointermove";
}, MR = function(e) {
  return e.type == Pe.SINGLECLICK;
}, zy = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && !(t.metaKey || t.ctrlKey) && !t.shiftKey;
}, _R = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && (QO ? t.metaKey : t.ctrlKey) && !t.shiftKey;
}, Ky = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  );
  return !t.altKey && !(t.metaKey || t.ctrlKey) && t.shiftKey;
}, sP = function(e) {
  const t = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    e.originalEvent
  ), n = (
    /** @type {Element} */
    t.target.tagName
  );
  return n !== "INPUT" && n !== "SELECT" && n !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !t.target.isContentEditable;
}, Pp = function(e) {
  const t = (
    /** @type {import("../MapBrowserEvent").default} */
    e.originalEvent
  );
  return Zt(t !== void 0, 56), t.pointerType == "mouse";
}, IR = function(e) {
  const t = (
    /** @type {import("../MapBrowserEvent").default} */
    e.originalEvent
  );
  return Zt(t !== void 0, 56), t.isPrimary && t.button === 0;
};
class DR extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super({
      stopDown: uu
    }), t = t || {}, this.kinetic_ = t.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const n = t.condition ? t.condition : kg(zy, IR);
    this.condition_ = t.onFocusOnly ? kg(iP, n) : n, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    this.panning_ || (this.panning_ = !0, this.getMap().getView().beginInteraction());
    const n = this.targetPointers, s = Wy(n);
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(s[0], s[1]), this.lastCentroid) {
        const r = [
          this.lastCentroid[0] - s[0],
          s[1] - this.lastCentroid[1]
        ], a = t.map.getView();
        l1(r, a.getResolution()), ay(r, a.getRotation()), a.adjustCenterInternal(r);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = s, this.lastPointersCount_ = n.length, t.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    const n = t.map, s = n.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const r = this.kinetic_.getDistance(), i = this.kinetic_.getAngle(), a = s.getCenterInternal(), o = n.getPixelFromCoordinateInternal(a), l = n.getCoordinateFromPixelInternal([
          o[0] - r * Math.cos(i),
          o[1] - r * Math.sin(i)
        ]);
        s.animateInternal({
          center: s.getConstrainedCenter(l),
          duration: 500,
          easing: qo
        });
      }
      return this.panning_ && (this.panning_ = !1, s.endInteraction()), !1;
    } else
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length > 0 && this.condition_(t)) {
      const s = t.map.getView();
      return this.lastCentroid = null, s.getAnimating() && s.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    } else
      return !1;
  }
}
const Yg = DR;
class AR extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super({
      stopDown: uu
    }), this.condition_ = t.condition ? t.condition : OR, this.lastAngle_ = void 0, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    if (!Pp(t))
      return;
    const n = t.map, s = n.getView();
    if (s.getConstraints().rotation === jy)
      return;
    const r = n.getSize(), i = t.pixel, a = Math.atan2(r[1] / 2 - i[1], i[0] - r[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const o = a - this.lastAngle_;
      s.adjustRotationInternal(-o);
    }
    this.lastAngle_ = a;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    return Pp(t) ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return Pp(t) && rP(t) && this.condition_(t) ? (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
const LR = AR;
class RR extends Qv {
  /**
   * @param {string} className CSS class name.
   */
  constructor(t) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + t, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const t = this.startPixel_, n = this.endPixel_, s = "px", r = this.element_.style;
    r.left = Math.min(t[0], n[0]) + s, r.top = Math.min(t[1], n[1]) + s, r.width = Math.abs(n[0] - t[0]) + s, r.height = Math.abs(n[1] - t[1]) + s;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(t) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const n = this.element_.style;
      n.left = "inherit", n.top = "inherit", n.width = "inherit", n.height = "inherit";
    }
    this.map_ = t, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(t, n) {
    this.startPixel_ = t, this.endPixel_ = n, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const t = this.startPixel_, n = this.endPixel_, r = [
      t,
      [t[0], n[1]],
      n,
      [n[0], t[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    r[4] = r[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([r]) : this.geometry_ = new rr([r]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const wR = RR, bh = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class Sp extends Wi {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(t, n, s) {
    super(t), this.coordinate = n, this.mapBrowserEvent = s;
  }
}
class VR extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.box_ = new wR(t.className || "ol-dragbox"), this.minArea_ = t.minArea !== void 0 ? t.minArea : 64, t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd), this.startPixel_ = null, this.condition_ = t.condition ? t.condition : rP, this.boxEndCondition_ = t.boxEndCondition ? t.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(t, n, s) {
    const r = s[0] - n[0], i = s[1] - n[1];
    return r * r + i * i >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    this.box_.setPixels(this.startPixel_, t.pixel), this.dispatchEvent(
      new Sp(
        bh.BOXDRAG,
        t.coordinate,
        t
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    this.box_.setMap(null);
    const n = this.boxEndCondition_(
      t,
      this.startPixel_,
      t.pixel
    );
    return n && this.onBoxEnd(t), this.dispatchEvent(
      new Sp(
        n ? bh.BOXEND : bh.BOXCANCEL,
        t.coordinate,
        t
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return this.condition_(t) ? (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new Sp(
        bh.BOXSTART,
        t.coordinate,
        t
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(t) {
  }
}
const BR = VR;
class FR extends BR {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = t.condition ? t.condition : Ky;
    super({
      condition: n,
      className: t.className || "ol-dragzoom",
      minArea: t.minArea
    }), this.duration_ = t.duration !== void 0 ? t.duration : 200, this.out_ = t.out !== void 0 ? t.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(t) {
    const s = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let r = this.getGeometry();
    if (this.out_) {
      const i = s.rotatedExtentForGeometry(r), a = s.getResolutionForExtentInternal(i), o = s.getResolution() / a;
      r = r.clone(), r.scale(o * o);
    }
    s.fitInternal(r, {
      duration: this.duration_,
      easing: qo
    });
  }
}
const NR = FR, ho = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
class jR extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.defaultCondition_ = function(n) {
      return zy(n) && sP(n);
    }, this.condition_ = t.condition !== void 0 ? t.condition : this.defaultCondition_, this.duration_ = t.duration !== void 0 ? t.duration : 100, this.pixelDelta_ = t.pixelDelta !== void 0 ? t.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Kt.KEYDOWN) {
      const s = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = s.keyCode;
      if (this.condition_(t) && (r == ho.DOWN || r == ho.LEFT || r == ho.RIGHT || r == ho.UP)) {
        const a = t.map.getView(), o = a.getResolution() * this.pixelDelta_;
        let l = 0, f = 0;
        r == ho.DOWN ? f = -o : r == ho.LEFT ? l = -o : r == ho.RIGHT ? l = o : f = o;
        const d = [l, f];
        ay(d, a.getRotation()), CR(a, d, this.duration_), s.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
const $R = jR;
class UR extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.condition_ = t.condition ? t.condition : sP, this.delta_ = t.delta ? t.delta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */
  handleEvent(t) {
    let n = !1;
    if (t.type == Kt.KEYDOWN || t.type == Kt.KEYPRESS) {
      const s = (
        /** @type {KeyboardEvent} */
        t.originalEvent
      ), r = s.charCode;
      if (this.condition_(t) && (r == "+".charCodeAt(0) || r == "-".charCodeAt(0))) {
        const i = t.map, a = r == "+".charCodeAt(0) ? this.delta_ : -this.delta_, o = i.getView();
        Uy(o, a, void 0, this.duration_), s.preventDefault(), n = !0;
      }
    }
    return !n;
  }
}
const WR = UR;
class zR extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      t
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = t.maxDelta !== void 0 ? t.maxDelta : 1, this.duration_ = t.duration !== void 0 ? t.duration : 250, this.timeout_ = t.timeout !== void 0 ? t.timeout : 80, this.useAnchor_ = t.useAnchor !== void 0 ? t.useAnchor : !0, this.constrainResolution_ = t.constrainResolution !== void 0 ? t.constrainResolution : !1;
    const n = t.condition ? t.condition : Fd;
    this.condition_ = t.onFocusOnly ? kg(iP, n) : n, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const t = this.getMap();
    if (!t)
      return;
    t.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(t) {
    if (!this.condition_(t) || t.type !== Kt.WHEEL)
      return !0;
    const s = t.map, r = (
      /** @type {WheelEvent} */
      t.originalEvent
    );
    r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.coordinate);
    let i;
    if (t.type == Kt.WHEEL && (i = r.deltaY, oD && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (i /= Mf), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (i *= 40)), i === 0)
      return !1;
    this.lastDelta_ = i;
    const a = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = a), (!this.mode_ || a - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(i) < 4 ? "trackpad" : "wheel");
    const o = s.getView();
    if (this.mode_ === "trackpad" && !(o.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), o.adjustZoom(-i / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = a, !1;
    this.totalDelta_ += i;
    const l = Math.max(this.timeout_ - (a - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, s),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(t) {
    const n = t.getView();
    n.getAnimating() && n.cancelAnimations();
    let s = -dn(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (n.getConstrainResolution() || this.constrainResolution_) && (s = s ? s > 0 ? 1 : -1 : 0), Uy(n, s, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(t) {
    this.useAnchor_ = t, t || (this.lastAnchor_ = null);
  }
}
const Xg = zR;
class KR extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = uu), super(n), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = t.threshold !== void 0 ? t.threshold : 0.3, this.duration_ = t.duration !== void 0 ? t.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    let n = 0;
    const s = this.targetPointers[0], r = this.targetPointers[1], i = Math.atan2(
      r.clientY - s.clientY,
      r.clientX - s.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const d = i - this.lastAngle_;
      this.rotationDelta_ += d, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), n = d;
    }
    this.lastAngle_ = i;
    const a = t.map, o = a.getView();
    if (o.getConstraints().rotation === jy)
      return;
    const l = a.getViewport().getBoundingClientRect(), f = Wy(this.targetPointers);
    f[0] -= l.left, f[1] -= l.top, this.anchor_ = a.getCoordinateFromPixelInternal(f), this.rotating_ && (a.render(), o.adjustRotationInternal(n, this.anchor_));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    return this.targetPointers.length < 2 ? (t.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const n = t.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }
}
const GR = KR;
class kR extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = uu), super(n), this.anchor_ = null, this.duration_ = t.duration !== void 0 ? t.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(t) {
    let n = 1;
    const s = this.targetPointers[0], r = this.targetPointers[1], i = s.clientX - r.clientX, a = s.clientY - r.clientY, o = Math.sqrt(i * i + a * a);
    this.lastDistance_ !== void 0 && (n = this.lastDistance_ / o), this.lastDistance_ = o;
    const l = t.map, f = l.getView();
    n != 1 && (this.lastScaleDelta_ = n);
    const d = l.getViewport().getBoundingClientRect(), u = Wy(this.targetPointers);
    u[0] -= d.left, u[1] -= d.top, this.anchor_ = l.getCoordinateFromPixelInternal(u), l.render(), f.adjustResolutionInternal(n, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    if (this.targetPointers.length < 2) {
      const s = t.map.getView(), r = this.lastScaleDelta_ > 1 ? 1 : -1;
      return s.endInteraction(this.duration_, r), !1;
    } else
      return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (this.targetPointers.length >= 2) {
      const n = t.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || n.getView().beginInteraction(), !0;
    } else
      return !1;
  }
}
const HR = kR;
function Gy(e) {
  e = e || {};
  const t = new Fi(), n = new $L(-5e-3, 0.05, 100);
  return (e.altShiftDragRotate !== void 0 ? e.altShiftDragRotate : !0) && t.push(new LR()), (e.doubleClickZoom !== void 0 ? e.doubleClickZoom : !0) && t.push(
    new bR({
      delta: e.zoomDelta,
      duration: e.zoomDuration
    })
  ), (e.dragPan !== void 0 ? e.dragPan : !0) && t.push(
    new Yg({
      onFocusOnly: e.onFocusOnly,
      kinetic: n
    })
  ), (e.pinchRotate !== void 0 ? e.pinchRotate : !0) && t.push(new GR()), (e.pinchZoom !== void 0 ? e.pinchZoom : !0) && t.push(
    new HR({
      duration: e.zoomDuration
    })
  ), (e.keyboard !== void 0 ? e.keyboard : !0) && (t.push(new $R()), t.push(
    new WR({
      delta: e.zoomDelta,
      duration: e.zoomDuration
    })
  )), (e.mouseWheelZoom !== void 0 ? e.mouseWheelZoom : !0) && t.push(
    new Xg({
      onFocusOnly: e.onFocusOnly,
      duration: e.zoomDuration
    })
  ), (e.shiftDragZoom !== void 0 ? e.shiftDragZoom : !0) && t.push(
    new NR({
      duration: e.zoomDuration
    })
  ), t;
}
function aP(e) {
  if (e instanceof hu) {
    e.setMapInternal(null);
    return;
  }
  e instanceof Ga && e.getLayers().forEach(aP);
}
function oP(e, t) {
  if (e instanceof hu) {
    e.setMapInternal(t);
    return;
  }
  if (e instanceof Ga) {
    const n = e.getLayers().getArray();
    for (let s = 0, r = n.length; s < r; ++s)
      oP(n[s], t);
  }
}
let YR = class extends xr {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(t) {
    super(), t = t || {}, this.on, this.once, this.un;
    const n = XR(t);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = t.maxTilesLoading !== void 0 ? t.maxTilesLoading : 16, this.pixelRatio_ = t.pixelRatio !== void 0 ? t.pixelRatio : Mf, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = tr(), this.pixelToCoordinateTransform_ = tr(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = t.moveTolerance, this.keyboardEventTarget_ = n.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.controls = n.controls || yR(), this.interactions = n.interactions || Gy({
      onFocusOnly: !0
    }), this.overlays_ = n.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new qL(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      oi.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(oi.VIEW, this.handleViewChanged_), this.addChangeListener(oi.SIZE, this.handleSizeChanged_), this.addChangeListener(oi.TARGET, this.handleTargetChanged_), this.setProperties(n.values);
    const s = this;
    t.view && !(t.view instanceof Ta) && t.view.then(function(r) {
      s.setView(new Ta(r));
    }), this.controls.addEventListener(
      zn.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (function(r) {
        r.element.setMap(this);
      }).bind(this)
    ), this.controls.addEventListener(
      zn.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(null);
      }).bind(this)
    ), this.interactions.addEventListener(
      zn.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(this);
      }).bind(this)
    ), this.interactions.addEventListener(
      zn.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (function(r) {
        r.element.setMap(null);
      }).bind(this)
    ), this.overlays_.addEventListener(
      zn.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (function(r) {
        this.addOverlayInternal_(r.element);
      }).bind(this)
    ), this.overlays_.addEventListener(
      zn.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (function(r) {
        const i = r.element.getId();
        i !== void 0 && delete this.overlayIdIndex_[i.toString()], r.element.setMap(null);
      }).bind(this)
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       * @this {Map}
       */
      (function(r) {
        r.setMap(this);
      }).bind(this)
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {Map}
       */
      (function(r) {
        r.setMap(this);
      }).bind(this)
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(t) {
    this.getControls().push(t);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(t) {
    this.getInteractions().push(t);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(t) {
    this.getLayerGroup().getLayers().push(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(t) {
    oP(t.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(t) {
    this.getOverlays().push(t);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(t) {
    const n = t.getId();
    n !== void 0 && (this.overlayIdIndex_[n.toString()] = t), t.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(t, n, s) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const r = this.getCoordinateFromPixelInternal(t);
    s = s !== void 0 ? s : {};
    const i = s.hitTolerance !== void 0 ? s.hitTolerance : 0, a = s.layerFilter !== void 0 ? s.layerFilter : ms, o = s.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      r,
      this.frameState_,
      i,
      o,
      n,
      null,
      a,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(t, n) {
    const s = [];
    return this.forEachFeatureAtPixel(
      t,
      function(r) {
        s.push(r);
      },
      n
    ), s;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const t = [];
    function n(s) {
      s.forEach(function(r) {
        r instanceof Ga ? n(r.getLayers()) : t.push(r);
      });
    }
    return n(this.getLayers()), t;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(t, n) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const s = this.getCoordinateFromPixelInternal(t);
    n = n !== void 0 ? n : {};
    const r = n.layerFilter !== void 0 ? n.layerFilter : ms, i = n.hitTolerance !== void 0 ? n.hitTolerance : 0, a = n.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      s,
      this.frameState_,
      i,
      a,
      r,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(t) {
    return this.getCoordinateFromPixel(this.getEventPixel(t));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(t) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(t) {
    const n = this.viewport_.getBoundingClientRect(), s = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in t ? (
        /** @type {TouchEvent} */
        t.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        t
      )
    );
    return [
      s.clientX - n.left,
      s.clientY - n.top
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(oi.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    const t = this.getTarget();
    return t !== void 0 ? typeof t == "string" ? document.getElementById(t) : t : null;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(t) {
    return Fg(
      this.getCoordinateFromPixelInternal(t),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(t) {
    const n = this.frameState_;
    return n ? Ln(
      n.pixelToCoordinateTransform,
      t.slice()
    ) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(t) {
    const n = this.overlayIdIndex_[t.toString()];
    return n !== void 0 ? n : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(oi.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(t) {
    const n = this.getLayerGroup();
    if (t instanceof Fi) {
      n.setLayers(t);
      return;
    }
    const s = n.getLayers();
    s.clear(), s.extend(t);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const t = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, s = t.length; n < s; ++n) {
      const r = t[n];
      if (!r.visible)
        continue;
      const i = r.layer.getRenderer();
      if (i && !i.ready)
        return !0;
      const a = r.layer.getSource();
      if (a && a.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(t) {
    const n = Ar(
      t,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(n);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(t) {
    const n = this.frameState_;
    return n ? Ln(
      n.coordinateToPixelTransform,
      t.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(oi.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(oi.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const t = this.getTargetElement();
    return t ? t.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(t, n, s, r) {
    return tR(
      this.frameState_,
      t,
      n,
      s,
      r
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(t, n) {
    n = n || t.type;
    const s = new js(n, this, t);
    this.handleMapBrowserEvent(s);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(t) {
    if (!this.frameState_)
      return;
    const n = (
      /** @type {PointerEvent} */
      t.originalEvent
    ), s = n.type;
    if (s === Gg.POINTERDOWN || s === Kt.WHEEL || s === Kt.KEYDOWN) {
      const r = this.getOwnerDocument(), i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r, a = (
        /** @type {Node} */
        n.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(a) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(i === r ? r.documentElement : i).contains(a)
      )
        return;
    }
    if (t.frameState = this.frameState_, this.dispatchEvent(t) !== !1) {
      const r = this.getInteractions().getArray().slice();
      for (let i = r.length - 1; i >= 0; i--) {
        const a = r[i];
        if (a.getMap() !== this || !a.getActive() || !this.getTargetElement())
          continue;
        if (!a.handleEvent(t) || t.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const t = this.frameState_, n = this.tileQueue_;
    if (!n.isEmpty()) {
      let r = this.maxTilesLoading_, i = r;
      if (t) {
        const a = t.viewHints;
        if (a[en.ANIMATING] || a[en.INTERACTING]) {
          const o = Date.now() - t.time > 8;
          r = o ? 0 : 8, i = o ? 0 : 2;
        }
      }
      n.getTilesLoading() < r && (n.reprioritize(), n.loadMoreTiles(r, i));
    }
    t && this.renderer_ && !t.animate && (this.renderComplete_ === !0 ? (this.hasListener(Fa.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Fa.RENDERCOMPLETE,
      t
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new El($s.LOADEND, this, t)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new El($s.LOADSTART, this, t)
    )));
    const s = this.postRenderFunctions_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r](this, t);
    s.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, s = this.targetChangeHandlerKeys_.length; n < s; ++n)
        Ue(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        Kt.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        Kt.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, Md(this.viewport_);
    }
    const t = this.getTargetElement();
    if (!t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new GL(this)), this.mapBrowserEventHandler_ = new XL(
        this,
        this.moveTolerance_
      );
      for (const r in Pe)
        this.mapBrowserEventHandler_.addEventListener(
          Pe[r],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        Kt.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        Kt.WHEEL,
        this.boundHandleBrowserEvent_,
        qO ? { passive: !1 } : !1
      );
      const n = this.getOwnerDocument().defaultView, s = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        ve(
          s,
          Kt.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        ve(
          s,
          Kt.KEYPRESS,
          this.handleBrowserEvent,
          this
        ),
        ve(n, Kt.RESIZE, this.updateSize, this)
      ];
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (Ue(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Ue(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const t = this.getView();
    t && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = ve(
      t,
      Zl.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = ve(
      t,
      Kt.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), t.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Ue), this.layerGroupPropertyListenerKeys_ = null);
    const t = this.getLayerGroup();
    t && (this.handleLayerAdd_(new ba("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [
      ve(t, Zl.PROPERTYCHANGE, this.render, this),
      ve(t, Kt.CHANGE, this.render, this),
      ve(t, "addlayer", this.handleLayerAdd_, this),
      ve(t, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const t = this.getLayerGroup().getLayerStatesArray();
    for (let n = 0, s = t.length; n < s; ++n) {
      const r = t[n].layer;
      r.hasRenderer() && r.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(t) {
    return this.getControls().remove(t);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(t) {
    return this.getInteractions().remove(t);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(t) {
    return this.getLayerGroup().getLayers().remove(t);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(t) {
    aP(t.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(t) {
    return this.getOverlays().remove(t);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(t) {
    const n = this.getSize(), s = this.getView(), r = this.frameState_;
    let i = null;
    if (n !== void 0 && QE(n) && s && s.isDef()) {
      const a = s.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), o = s.getState();
      if (i = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: $l(
          o.center,
          o.resolution,
          o.rotation,
          n
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: n,
        tileQueue: this.tileQueue_,
        time: t,
        usedTiles: {},
        viewState: o,
        viewHints: a,
        wantedTiles: {},
        mapId: Xt(this),
        renderTargets: {}
      }, o.nextCenter && o.nextResolution) {
        const l = isNaN(o.nextRotation) ? o.rotation : o.nextRotation;
        i.nextExtent = $l(
          o.nextCenter,
          o.nextResolution,
          l,
          n
        );
      }
    }
    this.frameState_ = i, this.renderer_.renderFrame(i), i && (i.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      i.postRenderFunctions
    ), r && (!this.previousExtent_ || !Df(this.previousExtent_) && !Fo(i.extent, this.previousExtent_)) && (this.dispatchEvent(
      new El($s.MOVESTART, this, r)
    ), this.previousExtent_ = $c(this.previousExtent_)), this.previousExtent_ && !i.viewHints[en.ANIMATING] && !i.viewHints[en.INTERACTING] && !Fo(i.extent, this.previousExtent_) && (this.dispatchEvent(
      new El($s.MOVEEND, this, i)
    ), e1(i.extent, this.previousExtent_))), this.dispatchEvent(new El($s.POSTRENDER, this, i)), this.renderComplete_ = this.hasListener($s.LOADSTART) || this.hasListener($s.LOADEND) || this.hasListener(Fa.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(t) {
    const n = this.getLayerGroup();
    n && this.handleLayerRemove_(new ba("removelayer", n)), this.set(oi.LAYERGROUP, t);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(t) {
    this.set(oi.SIZE, t);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(t) {
    this.set(oi.TARGET, t);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(t) {
    if (!t || t instanceof Ta) {
      this.set(oi.VIEW, t);
      return;
    }
    this.set(oi.VIEW, new Ta());
    const n = this;
    t.then(function(s) {
      n.setView(new Ta(s));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const t = this.getTargetElement();
    let n;
    if (t) {
      const s = getComputedStyle(t), r = t.offsetWidth - parseFloat(s.borderLeftWidth) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) - parseFloat(s.borderRightWidth), i = t.offsetHeight - parseFloat(s.borderTopWidth) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) - parseFloat(s.borderBottomWidth);
      !isNaN(r) && !isNaN(i) && (n = [r, i], !QE(n) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && console.warn(
        "No map visible because the map container's width or height are 0."
      ));
    }
    this.setSize(n), this.updateViewportSize_();
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */
  updateViewportSize_() {
    const t = this.getView();
    if (t) {
      let n;
      const s = getComputedStyle(this.viewport_);
      s.width && s.height && (n = [
        parseInt(s.width, 10),
        parseInt(s.height, 10)
      ]), t.setViewportSize(n);
    }
  }
};
function XR(e) {
  let t = null;
  e.keyboardEventTarget !== void 0 && (t = typeof e.keyboardEventTarget == "string" ? document.getElementById(e.keyboardEventTarget) : e.keyboardEventTarget);
  const n = {}, s = e.layers && typeof /** @type {?} */
  e.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    e.layers
  ) : new Ga({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      e.layers
    )
  });
  n[oi.LAYERGROUP] = s, n[oi.TARGET] = e.target, n[oi.VIEW] = e.view instanceof Ta ? e.view : new Ta();
  let r;
  e.controls !== void 0 && (Array.isArray(e.controls) ? r = new Fi(e.controls.slice()) : (Zt(
    typeof /** @type {?} */
    e.controls.getArray == "function",
    47
  ), r = e.controls));
  let i;
  e.interactions !== void 0 && (Array.isArray(e.interactions) ? i = new Fi(e.interactions.slice()) : (Zt(
    typeof /** @type {?} */
    e.interactions.getArray == "function",
    48
  ), i = e.interactions));
  let a;
  return e.overlays !== void 0 ? Array.isArray(e.overlays) ? a = new Fi(e.overlays.slice()) : (Zt(
    typeof /** @type {?} */
    e.overlays.getArray == "function",
    49
  ), a = e.overlays) : a = new Fi(), {
    controls: r,
    interactions: i,
    keyboardEventTarget: t,
    overlays: a,
    values: n
  };
}
const ta = YR, ai = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class ZR extends xr {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, this.options = t, this.id = t.id, this.insertFirst = t.insertFirst !== void 0 ? t.insertFirst : !0, this.stopEvent = t.stopEvent !== void 0 ? t.stopEvent : !0, this.element = document.createElement("div"), this.element.className = t.className !== void 0 ? t.className : "ol-overlay-container " + yA, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = t.autoPan === !0 ? {} : t.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(ai.ELEMENT, this.handleElementChanged), this.addChangeListener(ai.MAP, this.handleMapChanged), this.addChangeListener(ai.OFFSET, this.handleOffsetChanged), this.addChangeListener(ai.POSITION, this.handlePositionChanged), this.addChangeListener(ai.POSITIONING, this.handlePositioningChanged), t.element !== void 0 && this.setElement(t.element), this.setOffset(t.offset !== void 0 ? t.offset : [0, 0]), this.setPositioning(t.positioning || "top-left"), t.position !== void 0 && this.setPosition(t.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(ai.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(ai.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(ai.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ai.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(ai.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    A1(this.element);
    const t = this.getElement();
    t && this.element.appendChild(t);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (Md(this.element), Ue(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const t = this.getMap();
    if (t) {
      this.mapPostrenderListenerKey = ve(
        t,
        $s.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const n = this.stopEvent ? t.getOverlayContainerStopEvent() : t.getOverlayContainer();
      this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(t) {
    this.set(ai.ELEMENT, t);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(t) {
    this.set(ai.MAP, t);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(t) {
    this.set(ai.OFFSET, t);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(t) {
    this.set(ai.POSITION, t);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(t) {
    const n = this.getMap();
    if (!n || !n.getTargetElement() || !this.get(ai.POSITION))
      return;
    const s = this.getRect(n.getTargetElement(), n.getSize()), r = this.getElement(), i = this.getRect(r, [
      mA(r),
      gA(r)
    ]);
    t = t || {};
    const a = t.margin === void 0 ? 20 : t.margin;
    if (!Rr(s, i)) {
      const o = i[0] - s[0], l = s[2] - i[2], f = i[1] - s[1], d = s[3] - i[3], u = [0, 0];
      if (o < 0 ? u[0] = o - a : l < 0 && (u[0] = Math.abs(l) + a), f < 0 ? u[1] = f - a : d < 0 && (u[1] = Math.abs(d) + a), u[0] !== 0 || u[1] !== 0) {
        const c = (
          /** @type {import("./coordinate.js").Coordinate} */
          n.getView().getCenterInternal()
        ), h = n.getPixelFromCoordinateInternal(c);
        if (!h)
          return;
        const p = [h[0] + u[0], h[1] + u[1]], g = t.animation || {};
        n.getView().animateInternal({
          center: n.getCoordinateFromPixelInternal(p),
          duration: g.duration,
          easing: g.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(t, n) {
    const s = t.getBoundingClientRect(), r = s.left + window.pageXOffset, i = s.top + window.pageYOffset;
    return [r, i, r + n[0], i + n[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(t) {
    this.set(ai.POSITIONING, t);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(t) {
    this.rendered.visible !== t && (this.element.style.display = t ? "" : "none", this.rendered.visible = t);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const t = this.getMap(), n = this.getPosition();
    if (!t || !t.isRendered() || !n) {
      this.setVisible(!1);
      return;
    }
    const s = t.getPixelFromCoordinate(n), r = t.getSize();
    this.updateRenderedPosition(s, r);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(t, n) {
    const s = this.element.style, r = this.getOffset(), i = this.getPositioning();
    this.setVisible(!0);
    const a = Math.round(t[0] + r[0]) + "px", o = Math.round(t[1] + r[1]) + "px";
    let l = "0%", f = "0%";
    i == "bottom-right" || i == "center-right" || i == "top-right" ? l = "-100%" : (i == "bottom-center" || i == "center-center" || i == "top-center") && (l = "-50%"), i == "bottom-left" || i == "bottom-center" || i == "bottom-right" ? f = "-100%" : (i == "center-left" || i == "center-center" || i == "center-right") && (f = "-50%");
    const d = `translate(${l}, ${f}) translate(${a}, ${o})`;
    this.rendered.transform_ != d && (this.rendered.transform_ = d, s.transform = d);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const ky = ZR;
class JR {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(t) {
    this.highWaterMark = t !== void 0 ? t : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(t) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(t) {
    return this.entries_.hasOwnProperty(t);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(t) {
    let n = this.oldest_;
    for (; n; )
      t(n.value_, n.key_, this), n = n.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(t, n) {
    const s = this.entries_[t];
    return Zt(s !== void 0, 15), s === this.newest_ || (s === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (s.newer.older = s.older, s.older.newer = s.newer), s.newer = null, s.older = this.newest_, this.newest_.newer = s, this.newest_ = s), s.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(t) {
    const n = this.entries_[t];
    return Zt(n !== void 0, 15), n === this.newest_ ? (this.newest_ = /** @type {Entry} */
    n.older, this.newest_ && (this.newest_.newer = null)) : n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    n.newer, this.oldest_ && (this.oldest_.older = null)) : (n.newer.older = n.older, n.older.newer = n.newer), delete this.entries_[t], --this.count_, n.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const t = new Array(this.count_);
    let n = 0, s;
    for (s = this.newest_; s; s = s.older)
      t[n++] = s.key_;
    return t;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const t = new Array(this.count_);
    let n = 0, s;
    for (s = this.newest_; s; s = s.older)
      t[n++] = s.value_;
    return t;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(t) {
    if (this.containsKey(t))
      return this.entries_[t].value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const t = this.oldest_;
    return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(t, n) {
    this.get(t), this.entries_[t].value_ = n;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(t, n) {
    Zt(!(t in this.entries_), 16);
    const s = {
      key_: t,
      newer: null,
      older: this.newest_,
      value_: n
    };
    this.newest_ ? this.newest_.newer = s : this.oldest_ = s, this.newest_ = s, this.entries_[t] = s, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(t) {
    this.highWaterMark = t;
  }
}
const Zg = JR;
function CC(e, t, n, s) {
  return s !== void 0 ? (s[0] = e, s[1] = t, s[2] = n, s) : [e, t, n];
}
function fu(e, t, n) {
  return e + "/" + t + "/" + n;
}
function lP(e) {
  return fu(e[0], e[1], e[2]);
}
function QR(e) {
  const [t, n, s] = e.substring(e.lastIndexOf("/") + 1, e.length).split(",").map(Number);
  return fu(t, n, s);
}
function uP(e) {
  return e.split("/").map(Number);
}
function cP(e) {
  return (e[1] << e[0]) + e[2];
}
function qR(e, t) {
  const n = e[0], s = e[1], r = e[2];
  if (t.getMinZoom() > n || n > t.getMaxZoom())
    return !1;
  const i = t.getFullTileRange(n);
  return i ? i.containsXY(s, r) : !0;
}
class tw extends Zg {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in t); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const t = this.peekFirstKey(), s = uP(t)[0];
    this.forEach(
      (function(r) {
        r.tileCoord[0] !== s && (this.remove(lP(r.tileCoord)), r.release());
      }).bind(this)
    );
  }
}
const Hy = tw;
class hP {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(t, n, s, r) {
    this.minX = t, this.maxX = n, this.minY = s, this.maxY = r;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(t) {
    return this.containsXY(t[1], t[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(t) {
    return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(t, n) {
    return this.minX <= t && t <= this.maxX && this.minY <= n && n <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(t) {
    return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(t) {
    t.minX < this.minX && (this.minX = t.minX), t.maxX > this.maxX && (this.maxX = t.maxX), t.minY < this.minY && (this.minY = t.minY), t.maxY > this.maxY && (this.maxY = t.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(t) {
    return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY;
  }
}
function cl(e, t, n, s, r) {
  return r !== void 0 ? (r.minX = e, r.maxX = t, r.minY = n, r.maxY = s, r) : new hP(e, t, n, s);
}
const dP = hP, xC = [];
class ew extends Nf {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  constructor(t, n, s, r) {
    super(t, n, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.declutterExecutorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = r.bind(void 0, this), this.wrappedTileCoord = s;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  getContext(t) {
    const n = Xt(t);
    return n in this.context_ || (this.context_[n] = Di(1, 1, xC)), this.context_[n];
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */
  hasContext(t) {
    return Xt(t) in this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage(t) {
    return this.hasContext(t) ? this.getContext(t).canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(t) {
    const n = Xt(t);
    return n in this.replayState_ || (this.replayState_[n] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[n];
  }
  /**
   * Load the tile.
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    for (const t in this.context_) {
      const n = this.context_[t];
      Py(n), xC.push(n.canvas), delete this.context_[t];
    }
    super.release();
  }
}
const nw = ew;
let iw = class extends Nf {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(t, n, s, r, i, a) {
    super(t, n, a), this.extent = null, this.format_ = r, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = i, this.url_ = s, this.key = s;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == _t.IDLE && (this.setState(_t.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(t, n) {
    this.setFeatures(t);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(_t.ERROR);
  }
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */
  setFeatures(t) {
    this.features_ = t, this.setState(_t.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  setLoader(t) {
    this.loader_ = t;
  }
};
const rw = iw, fi = {
  target: "map",
  epsg: "EPSG:25832",
  backgroundImage: "",
  extent: [51e4, 585e4, 625000.4, 6e6],
  options: [
    { resolution: 66.14579761460263, scale: 25e4, zoomLevel: 0 },
    { resolution: 26.458319045841044, scale: 1e5, zoomLevel: 1 },
    { resolution: 15.874991427504629, scale: 6e4, zoomLevel: 2 },
    { resolution: 10.583327618336419, scale: 4e4, zoomLevel: 3 },
    { resolution: 5.2916638091682096, scale: 2e4, zoomLevel: 4 },
    { resolution: 2.6458319045841048, scale: 1e4, zoomLevel: 5 },
    { resolution: 1.3229159522920524, scale: 5e3, zoomLevel: 6 },
    { resolution: 0.6614579761460262, scale: 2500, zoomLevel: 7 },
    { resolution: 0.2645831904584105, scale: 1e3, zoomLevel: 8 },
    { resolution: 0.1322915952292052, scale: 500, zoomLevel: 9 }
  ],
  namedProjections: [
    ["EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"]
  ],
  startResolution: 15.874991427504629,
  startCenter: [565874, 5934140],
  layerConf: "https://geodienste.hamburg.de/services-internet.json",
  layers: [
    {
      id: "453",
      visibility: !0
    }
  ],
  gazetteerUrl: "https://geodienste.hamburg.de/HH_WFS_GAGES?service=WFS&request=GetFeature&version=2.0.0",
  showGeographicIdentifier: !1,
  sceneOptions: {
    camera: {
      enableTerrainAdjustmentWhenLoading: !0
    },
    globe: {
      depthTestAgainstTerrain: !0
      // is necessary for scene.pickedPosition and correct height of the terrain. @see {https://github.com/CesiumGS/cesium/issues/5676}
    },
    highDynamicRange: !1,
    pickTranslucentDepth: !0,
    shadowMap: {
      darkness: 0.6,
      maximumDistance: 5e3,
      size: 2048
    },
    shadows: !1
  }
};
function sw(e = {}, t = fi) {
  const n = {
    startZoomLevel: void 0,
    startResolution: void 0
  };
  return Object.prototype.hasOwnProperty.call(e, "startZoomLevel") && !Object.prototype.hasOwnProperty.call(e, "startResolution") ? n.startZoomLevel = t.startZoomLevel : n.startResolution = t.startResolution, n;
}
function fP(e) {
  const t = Object.assign({}, fi, e), n = sw(e, t);
  return new Ta({
    projection: t.epsg,
    center: t.startCenter,
    extent: t.extent,
    zoom: n.startZoomLevel,
    options: t.options,
    resolution: n.startResolution,
    resolutions: t.options.map((s) => s.resolution),
    constrainResolution: !0,
    constrainOnlyCenter: !0,
    backgroundImage: t.backgroundImage
  });
}
function aw(e) {
  e("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), e("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), e("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), e.WGS84 = e["EPSG:4326"], e["EPSG:3785"] = e["EPSG:3857"], e.GOOGLE = e["EPSG:3857"], e["EPSG:900913"] = e["EPSG:3857"], e["EPSG:102113"] = e["EPSG:3857"];
}
var No = 1, jo = 2, Wl = 3, ow = 4, Jg = 5, bC = 6378137, lw = 6356752314e-3, TC = 0.0066943799901413165, ic = 484813681109536e-20, xt = Math.PI / 2, uw = 0.16666666666666666, cw = 0.04722222222222222, hw = 0.022156084656084655, Dt = 1e-10, Qn = 0.017453292519943295, cs = 57.29577951308232, De = Math.PI / 4, yc = Math.PI * 2, Sn = 3.14159265359, zi = {};
zi.greenwich = 0;
zi.lisbon = -9.131906111111;
zi.paris = 2.337229166667;
zi.bogota = -74.080916666667;
zi.madrid = -3.687938888889;
zi.rome = 12.452333333333;
zi.bern = 7.439583333333;
zi.jakarta = 106.807719444444;
zi.ferro = -17.666666666667;
zi.brussels = 4.367975;
zi.stockholm = 18.058277777778;
zi.athens = 23.7163375;
zi.oslo = 10.722916666667;
const dw = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var OC = /[\s_\-\/\(\)]/g;
function ka(e, t) {
  if (e[t])
    return e[t];
  for (var n = Object.keys(e), s = t.toLowerCase().replace(OC, ""), r = -1, i, a; ++r < n.length; )
    if (i = n[r], a = i.toLowerCase().replace(OC, ""), a === s)
      return e[i];
}
function Qg(e) {
  var t = {}, n = e.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, l) {
    var f = l.split("=");
    return f.push(!0), o[f[0].toLowerCase()] = f[1], o;
  }, {}), s, r, i, a = {
    proj: "projName",
    datum: "datumCode",
    rf: function(o) {
      t.rf = parseFloat(o);
    },
    lat_0: function(o) {
      t.lat0 = o * Qn;
    },
    lat_1: function(o) {
      t.lat1 = o * Qn;
    },
    lat_2: function(o) {
      t.lat2 = o * Qn;
    },
    lat_ts: function(o) {
      t.lat_ts = o * Qn;
    },
    lon_0: function(o) {
      t.long0 = o * Qn;
    },
    lon_1: function(o) {
      t.long1 = o * Qn;
    },
    lon_2: function(o) {
      t.long2 = o * Qn;
    },
    alpha: function(o) {
      t.alpha = parseFloat(o) * Qn;
    },
    gamma: function(o) {
      t.rectified_grid_angle = parseFloat(o);
    },
    lonc: function(o) {
      t.longc = o * Qn;
    },
    x_0: function(o) {
      t.x0 = parseFloat(o);
    },
    y_0: function(o) {
      t.y0 = parseFloat(o);
    },
    k_0: function(o) {
      t.k0 = parseFloat(o);
    },
    k: function(o) {
      t.k0 = parseFloat(o);
    },
    a: function(o) {
      t.a = parseFloat(o);
    },
    b: function(o) {
      t.b = parseFloat(o);
    },
    r_a: function() {
      t.R_A = !0;
    },
    zone: function(o) {
      t.zone = parseInt(o, 10);
    },
    south: function() {
      t.utmSouth = !0;
    },
    towgs84: function(o) {
      t.datum_params = o.split(",").map(function(l) {
        return parseFloat(l);
      });
    },
    to_meter: function(o) {
      t.to_meter = parseFloat(o);
    },
    units: function(o) {
      t.units = o;
      var l = ka(dw, o);
      l && (t.to_meter = l.to_meter);
    },
    from_greenwich: function(o) {
      t.from_greenwich = o * Qn;
    },
    pm: function(o) {
      var l = ka(zi, o);
      t.from_greenwich = (l || parseFloat(o)) * Qn;
    },
    nadgrids: function(o) {
      o === "@null" ? t.datumCode = "none" : t.nadgrids = o;
    },
    axis: function(o) {
      var l = "ewnsud";
      o.length === 3 && l.indexOf(o.substr(0, 1)) !== -1 && l.indexOf(o.substr(1, 1)) !== -1 && l.indexOf(o.substr(2, 1)) !== -1 && (t.axis = o);
    },
    approx: function() {
      t.approx = !0;
    }
  };
  for (s in n)
    r = n[s], s in a ? (i = a[s], typeof i == "function" ? i(r) : t[i] = r) : t[s] = r;
  return typeof t.datumCode == "string" && t.datumCode !== "WGS84" && (t.datumCode = t.datumCode.toLowerCase()), t;
}
var Ec = 1, pP = 2, mP = 3, Nd = 4, gP = 5, Yy = -1, fw = /\s/, pw = /[A-Za-z]/, mw = /[A-Za-z84_]/, jf = /[,\]]/, vP = /[\d\.E\-\+]/;
function la(e) {
  if (typeof e != "string")
    throw new Error("not a string");
  this.text = e.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Ec;
}
la.prototype.readCharicter = function() {
  var e = this.text[this.place++];
  if (this.state !== Nd)
    for (; fw.test(e); ) {
      if (this.place >= this.text.length)
        return;
      e = this.text[this.place++];
    }
  switch (this.state) {
    case Ec:
      return this.neutral(e);
    case pP:
      return this.keyword(e);
    case Nd:
      return this.quoted(e);
    case gP:
      return this.afterquote(e);
    case mP:
      return this.number(e);
    case Yy:
      return;
  }
};
la.prototype.afterquote = function(e) {
  if (e === '"') {
    this.word += '"', this.state = Nd;
    return;
  }
  if (jf.test(e)) {
    this.word = this.word.trim(), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in afterquote yet, index ' + this.place);
};
la.prototype.afterItem = function(e) {
  if (e === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Ec;
    return;
  }
  if (e === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Ec, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Yy);
    return;
  }
};
la.prototype.number = function(e) {
  if (vP.test(e)) {
    this.word += e;
    return;
  }
  if (jf.test(e)) {
    this.word = parseFloat(this.word), this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in number yet, index ' + this.place);
};
la.prototype.quoted = function(e) {
  if (e === '"') {
    this.state = gP;
    return;
  }
  this.word += e;
};
la.prototype.keyword = function(e) {
  if (mw.test(e)) {
    this.word += e;
    return;
  }
  if (e === "[") {
    var t = [];
    t.push(this.word), this.level++, this.root === null ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, this.state = Ec;
    return;
  }
  if (jf.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in keyword yet, index ' + this.place);
};
la.prototype.neutral = function(e) {
  if (pw.test(e)) {
    this.word = e, this.state = pP;
    return;
  }
  if (e === '"') {
    this.word = "", this.state = Nd;
    return;
  }
  if (vP.test(e)) {
    this.word = e, this.state = mP;
    return;
  }
  if (jf.test(e)) {
    this.afterItem(e);
    return;
  }
  throw new Error(`havn't handled "` + e + '" in neutral yet, index ' + this.place);
};
la.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Yy)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function gw(e) {
  var t = new la(e);
  return t.output();
}
function PC(e, t, n) {
  Array.isArray(t) && (n.unshift(t), t = null);
  var s = t ? {} : e, r = n.reduce(function(i, a) {
    return Ml(a, i), i;
  }, s);
  t && (e[t] = r);
}
function Ml(e, t) {
  if (!Array.isArray(e)) {
    t[e] = !0;
    return;
  }
  var n = e.shift();
  if (n === "PARAMETER" && (n = e.shift()), e.length === 1) {
    if (Array.isArray(e[0])) {
      t[n] = {}, Ml(e[0], t[n]);
      return;
    }
    t[n] = e[0];
    return;
  }
  if (!e.length) {
    t[n] = !0;
    return;
  }
  if (n === "TOWGS84") {
    t[n] = e;
    return;
  }
  if (n === "AXIS") {
    n in t || (t[n] = []), t[n].push(e);
    return;
  }
  Array.isArray(n) || (t[n] = {});
  var s;
  switch (n) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      t[n] = {
        name: e[0].toLowerCase(),
        convert: e[1]
      }, e.length === 3 && Ml(e[2], t[n]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      t[n] = {
        name: e[0],
        a: e[1],
        rf: e[2]
      }, e.length === 4 && Ml(e[3], t[n]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      e[0] = ["name", e[0]], PC(t, n, e);
      return;
    default:
      for (s = -1; ++s < e.length; )
        if (!Array.isArray(e[s]))
          return Ml(e, t[n]);
      return PC(t, n, e);
  }
}
var vw = 0.017453292519943295;
function yw(e, t) {
  var n = t[0], s = t[1];
  !(n in e) && s in e && (e[n] = e[s], t.length === 3 && (e[n] = t[2](e[n])));
}
function rs(e) {
  return e * vw;
}
function Ew(e) {
  if (e.type === "GEOGCS" ? e.projName = "longlat" : e.type === "LOCAL_CS" ? (e.projName = "identity", e.local = !0) : typeof e.PROJECTION == "object" ? e.projName = Object.keys(e.PROJECTION)[0] : e.projName = e.PROJECTION, e.AXIS) {
    for (var t = "", n = 0, s = e.AXIS.length; n < s; ++n) {
      var r = [e.AXIS[n][0].toLowerCase(), e.AXIS[n][1].toLowerCase()];
      r[0].indexOf("north") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "north" ? t += "n" : r[0].indexOf("south") !== -1 || (r[0] === "y" || r[0] === "lat") && r[1] === "south" ? t += "s" : r[0].indexOf("east") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "east" ? t += "e" : (r[0].indexOf("west") !== -1 || (r[0] === "x" || r[0] === "lon") && r[1] === "west") && (t += "w");
    }
    t.length === 2 && (t += "u"), t.length === 3 && (e.axis = t);
  }
  e.UNIT && (e.units = e.UNIT.name.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.UNIT.convert && (e.type === "GEOGCS" ? e.DATUM && e.DATUM.SPHEROID && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a) : e.to_meter = e.UNIT.convert));
  var i = e.GEOGCS;
  e.type === "GEOGCS" && (i = e), i && (i.DATUM ? e.datumCode = i.DATUM.name.toLowerCase() : e.datumCode = i.name.toLowerCase(), e.datumCode.slice(0, 2) === "d_" && (e.datumCode = e.datumCode.slice(2)), (e.datumCode === "new_zealand_geodetic_datum_1949" || e.datumCode === "new_zealand_1949") && (e.datumCode = "nzgd49"), (e.datumCode === "wgs_1984" || e.datumCode === "world_geodetic_system_1984") && (e.PROJECTION === "Mercator_Auxiliary_Sphere" && (e.sphere = !0), e.datumCode = "wgs84"), e.datumCode.slice(-6) === "_ferro" && (e.datumCode = e.datumCode.slice(0, -6)), e.datumCode.slice(-8) === "_jakarta" && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge") && (e.datumCode = "rnb72"), i.DATUM && i.DATUM.SPHEROID && (e.ellps = i.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), e.ellps.toLowerCase().slice(0, 13) === "international" && (e.ellps = "intl"), e.a = i.DATUM.SPHEROID.a, e.rf = parseFloat(i.DATUM.SPHEROID.rf, 10)), i.DATUM && i.DATUM.TOWGS84 && (e.datum_params = i.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936") && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952") && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf("geodetic_datum_of_1965")) && (e.datumCode = "ire65"), e.datumCode === "ch1903+" && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel") && (e.datumCode = "isr93")), e.b && !isFinite(e.b) && (e.b = e.a);
  function a(f) {
    var d = e.to_meter || 1;
    return f * d;
  }
  var o = function(f) {
    return yw(e, f);
  }, l = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", rs],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", rs],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", rs],
    ["lat0", "latitude_of_origin", rs],
    ["lat0", "standard_parallel_1", rs],
    ["lat1", "standard_parallel_1", rs],
    ["lat2", "standard_parallel_2", rs],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", rs],
    ["srsCode", "name"]
  ];
  l.forEach(o), !e.long0 && e.longc && (e.projName === "Albers_Conic_Equal_Area" || e.projName === "Lambert_Azimuthal_Equal_Area") && (e.long0 = e.longc), !e.lat_ts && e.lat1 && (e.projName === "Stereographic_South_Pole" || e.projName === "Polar Stereographic (variant B)") ? (e.lat0 = rs(e.lat1 > 0 ? 90 : -90), e.lat_ts = e.lat1) : !e.lat_ts && e.lat0 && e.projName === "Polar_Stereographic" && (e.lat_ts = e.lat0, e.lat0 = rs(e.lat0 > 0 ? 90 : -90));
}
function yP(e) {
  var t = gw(e), n = t.shift(), s = t.shift();
  t.unshift(["name", s]), t.unshift(["type", n]);
  var r = {};
  return Ml(t, r), Ew(r), r;
}
function Oi(e) {
  var t = this;
  if (arguments.length === 2) {
    var n = arguments[1];
    typeof n == "string" ? n.charAt(0) === "+" ? Oi[e] = Qg(arguments[1]) : Oi[e] = yP(arguments[1]) : Oi[e] = n;
  } else if (arguments.length === 1) {
    if (Array.isArray(e))
      return e.map(function(s) {
        Array.isArray(s) ? Oi.apply(t, s) : Oi(s);
      });
    if (typeof e == "string") {
      if (e in Oi)
        return Oi[e];
    } else
      "EPSG" in e ? Oi["EPSG:" + e.EPSG] = e : "ESRI" in e ? Oi["ESRI:" + e.ESRI] = e : "IAU2000" in e ? Oi["IAU2000:" + e.IAU2000] = e : console.log(e);
    return;
  }
}
aw(Oi);
function Cw(e) {
  return typeof e == "string";
}
function xw(e) {
  return e in Oi;
}
var bw = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function Tw(e) {
  return bw.some(function(t) {
    return e.indexOf(t) > -1;
  });
}
var Ow = ["3857", "900913", "3785", "102113"];
function Pw(e) {
  var t = ka(e, "authority");
  if (t) {
    var n = ka(t, "epsg");
    return n && Ow.indexOf(n) > -1;
  }
}
function Sw(e) {
  var t = ka(e, "extension");
  if (t)
    return ka(t, "proj4");
}
function Mw(e) {
  return e[0] === "+";
}
function _w(e) {
  if (Cw(e)) {
    if (xw(e))
      return Oi[e];
    if (Tw(e)) {
      var t = yP(e);
      if (Pw(t))
        return Oi["EPSG:3857"];
      var n = Sw(t);
      return n ? Qg(n) : t;
    }
    if (Mw(e))
      return Qg(e);
  } else
    return e;
}
function SC(e, t) {
  e = e || {};
  var n, s;
  if (!t)
    return e;
  for (s in t)
    n = t[s], n !== void 0 && (e[s] = n);
  return e;
}
function ys(e, t, n) {
  var s = e * t;
  return n / Math.sqrt(1 - s * s);
}
function Gc(e) {
  return e < 0 ? -1 : 1;
}
function Bt(e) {
  return Math.abs(e) <= Sn ? e : e - Gc(e) * yc;
}
function Fr(e, t, n) {
  var s = e * n, r = 0.5 * e;
  return s = Math.pow((1 - s) / (1 + s), r), Math.tan(0.5 * (xt - t)) / s;
}
function Cc(e, t) {
  for (var n = 0.5 * e, s, r, i = xt - 2 * Math.atan(t), a = 0; a <= 15; a++)
    if (s = e * Math.sin(i), r = xt - 2 * Math.atan(t * Math.pow((1 - s) / (1 + s), n)) - i, i += r, Math.abs(r) <= 1e-10)
      return i;
  return -9999;
}
function Iw() {
  var e = this.b / this.a;
  this.es = 1 - e * e, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function Dw(e) {
  var t = e.x, n = e.y;
  if (n * cs > 90 && n * cs < -90 && t * cs > 180 && t * cs < -180)
    return null;
  var s, r;
  if (Math.abs(Math.abs(n) - xt) <= Dt)
    return null;
  if (this.sphere)
    s = this.x0 + this.a * this.k0 * Bt(t - this.long0), r = this.y0 + this.a * this.k0 * Math.log(Math.tan(De + 0.5 * n));
  else {
    var i = Math.sin(n), a = Fr(this.e, n, i);
    s = this.x0 + this.a * this.k0 * Bt(t - this.long0), r = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return e.x = s, e.y = r, e;
}
function Aw(e) {
  var t = e.x - this.x0, n = e.y - this.y0, s, r;
  if (this.sphere)
    r = xt - 2 * Math.atan(Math.exp(-n / (this.a * this.k0)));
  else {
    var i = Math.exp(-n / (this.a * this.k0));
    if (r = Cc(this.e, i), r === -9999)
      return null;
  }
  return s = Bt(this.long0 + t / (this.a * this.k0)), e.x = s, e.y = r, e;
}
var Lw = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const Rw = {
  init: Iw,
  forward: Dw,
  inverse: Aw,
  names: Lw
};
function ww() {
}
function MC(e) {
  return e;
}
var Vw = ["longlat", "identity"];
const Bw = {
  init: ww,
  forward: MC,
  inverse: MC,
  names: Vw
};
var Fw = [Rw, Bw], cd = {}, jd = [];
function EP(e, t) {
  var n = jd.length;
  return e.names ? (jd[n] = e, e.names.forEach(function(s) {
    cd[s.toLowerCase()] = n;
  }), this) : (console.log(t), !0);
}
function Nw(e) {
  if (!e)
    return !1;
  var t = e.toLowerCase();
  if (typeof cd[t] < "u" && jd[cd[t]])
    return jd[cd[t]];
}
function jw() {
  Fw.forEach(EP);
}
const $w = {
  start: jw,
  add: EP,
  get: Nw
};
var ne = {};
ne.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
ne.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
ne.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
ne.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
ne.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
ne.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
ne.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
ne.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
ne.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
ne.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
ne.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
ne.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
ne.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
ne.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
ne.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
ne.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
ne.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
ne.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
ne.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
ne.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
ne.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
ne.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
ne.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
ne.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
ne.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
ne.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
ne.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
ne.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
ne.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
ne.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
ne.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
ne.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
ne.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
ne.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
ne.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
ne.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
ne.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
ne.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
ne.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
ne.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
ne.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
ne.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var Uw = ne.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
ne.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function Ww(e, t, n, s) {
  var r = e * e, i = t * t, a = (r - i) / r, o = 0;
  s ? (e *= 1 - a * (uw + a * (cw + a * hw)), r = e * e, a = 0) : o = Math.sqrt(a);
  var l = (r - i) / i;
  return {
    es: a,
    e: o,
    ep2: l
  };
}
function zw(e, t, n, s, r) {
  if (!e) {
    var i = ka(ne, s);
    i || (i = Uw), e = i.a, t = i.b, n = i.rf;
  }
  return n && !t && (t = (1 - 1 / n) * e), (n === 0 || Math.abs(e - t) < Dt) && (r = !0, t = e), {
    a: e,
    b: t,
    rf: n,
    sphere: r
  };
}
var kn = {};
kn.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
kn.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
kn.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
kn.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
kn.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
kn.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
kn.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
kn.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
kn.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
kn.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
kn.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
kn.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
kn.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
kn.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
kn.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
kn.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
kn.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function Kw(e, t, n, s, r, i, a) {
  var o = {};
  return e === void 0 || e === "none" ? o.datum_type = Jg : o.datum_type = ow, t && (o.datum_params = t.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = No), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = jo, o.datum_params[3] *= ic, o.datum_params[4] *= ic, o.datum_params[5] *= ic, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = Wl, o.grids = a), o.a = n, o.b = s, o.es = r, o.ep2 = i, o;
}
var CP = {};
function Gw(e, t) {
  var n = new DataView(t), s = Yw(n), r = Xw(n, s), i = Zw(n, r, s), a = { header: r, subgrids: i };
  return CP[e] = a, a;
}
function kw(e) {
  if (e === void 0)
    return null;
  var t = e.split(",");
  return t.map(Hw);
}
function Hw(e) {
  if (e.length === 0)
    return null;
  var t = e[0] === "@";
  return t && (e = e.slice(1)), e === "null" ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : {
    name: e,
    mandatory: !t,
    grid: CP[e] || null,
    isNull: !1
  };
}
function _l(e) {
  return e / 3600 * Math.PI / 180;
}
function Yw(e) {
  var t = e.getInt32(8, !1);
  return t === 11 ? !1 : (t = e.getInt32(8, !0), t !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function Xw(e, t) {
  return {
    nFields: e.getInt32(8, t),
    nSubgridFields: e.getInt32(24, t),
    nSubgrids: e.getInt32(40, t),
    shiftType: qg(e, 56, 56 + 8).trim(),
    fromSemiMajorAxis: e.getFloat64(120, t),
    fromSemiMinorAxis: e.getFloat64(136, t),
    toSemiMajorAxis: e.getFloat64(152, t),
    toSemiMinorAxis: e.getFloat64(168, t)
  };
}
function qg(e, t, n) {
  return String.fromCharCode.apply(null, new Uint8Array(e.buffer.slice(t, n)));
}
function Zw(e, t, n) {
  for (var s = 176, r = [], i = 0; i < t.nSubgrids; i++) {
    var a = Qw(e, s, n), o = qw(e, s, a, n), l = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), f = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    r.push({
      ll: [_l(a.lowerLongitude), _l(a.lowerLatitude)],
      del: [_l(a.longitudeInterval), _l(a.latitudeInterval)],
      lim: [l, f],
      count: a.gridNodeCount,
      cvs: Jw(o)
    }), s += 176 + a.gridNodeCount * 16;
  }
  return r;
}
function Jw(e) {
  return e.map(function(t) {
    return [_l(t.longitudeShift), _l(t.latitudeShift)];
  });
}
function Qw(e, t, n) {
  return {
    name: qg(e, t + 8, t + 16).trim(),
    parent: qg(e, t + 24, t + 24 + 8).trim(),
    lowerLatitude: e.getFloat64(t + 72, n),
    upperLatitude: e.getFloat64(t + 88, n),
    lowerLongitude: e.getFloat64(t + 104, n),
    upperLongitude: e.getFloat64(t + 120, n),
    latitudeInterval: e.getFloat64(t + 136, n),
    longitudeInterval: e.getFloat64(t + 152, n),
    gridNodeCount: e.getInt32(t + 168, n)
  };
}
function qw(e, t, n, s) {
  for (var r = t + 176, i = 16, a = [], o = 0; o < n.gridNodeCount; o++) {
    var l = {
      latitudeShift: e.getFloat32(r + o * i, s),
      longitudeShift: e.getFloat32(r + o * i + 4, s),
      latitudeAccuracy: e.getFloat32(r + o * i + 8, s),
      longitudeAccuracy: e.getFloat32(r + o * i + 12, s)
    };
    a.push(l);
  }
  return a;
}
function fs(e, t) {
  if (!(this instanceof fs))
    return new fs(e);
  t = t || function(f) {
    if (f)
      throw f;
  };
  var n = _w(e);
  if (typeof n != "object") {
    t(e);
    return;
  }
  var s = fs.projections.get(n.projName);
  if (!s) {
    t(e);
    return;
  }
  if (n.datumCode && n.datumCode !== "none") {
    var r = ka(kn, n.datumCode);
    r && (n.datum_params = n.datum_params || (r.towgs84 ? r.towgs84.split(",") : null), n.ellps = r.ellipse, n.datumName = r.datumName ? r.datumName : n.datumCode);
  }
  n.k0 = n.k0 || 1, n.axis = n.axis || "enu", n.ellps = n.ellps || "wgs84", n.lat1 = n.lat1 || n.lat0;
  var i = zw(n.a, n.b, n.rf, n.ellps, n.sphere), a = Ww(i.a, i.b, i.rf, n.R_A), o = kw(n.nadgrids), l = n.datum || Kw(
    n.datumCode,
    n.datum_params,
    i.a,
    i.b,
    a.es,
    a.ep2,
    o
  );
  SC(this, n), SC(this, s), this.a = i.a, this.b = i.b, this.rf = i.rf, this.sphere = i.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = l, this.init(), t(null, this);
}
fs.projections = $w;
fs.projections.start();
function t2(e, t) {
  return e.datum_type !== t.datum_type || e.a !== t.a || Math.abs(e.es - t.es) > 5e-11 ? !1 : e.datum_type === No ? e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] : e.datum_type === jo ? e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] && e.datum_params[3] === t.datum_params[3] && e.datum_params[4] === t.datum_params[4] && e.datum_params[5] === t.datum_params[5] && e.datum_params[6] === t.datum_params[6] : !0;
}
function xP(e, t, n) {
  var s = e.x, r = e.y, i = e.z ? e.z : 0, a, o, l, f;
  if (r < -xt && r > -1.001 * xt)
    r = -xt;
  else if (r > xt && r < 1.001 * xt)
    r = xt;
  else {
    if (r < -xt)
      return { x: -1 / 0, y: -1 / 0, z: e.z };
    if (r > xt)
      return { x: 1 / 0, y: 1 / 0, z: e.z };
  }
  return s > Math.PI && (s -= 2 * Math.PI), o = Math.sin(r), f = Math.cos(r), l = o * o, a = n / Math.sqrt(1 - t * l), {
    x: (a + i) * f * Math.cos(s),
    y: (a + i) * f * Math.sin(s),
    z: (a * (1 - t) + i) * o
  };
}
function bP(e, t, n, s) {
  var r = 1e-12, i = r * r, a = 30, o, l, f, d, u, c, h, p, g, m, v, y, E, C = e.x, x = e.y, b = e.z ? e.z : 0, P, O, T;
  if (o = Math.sqrt(C * C + x * x), l = Math.sqrt(C * C + x * x + b * b), o / n < r) {
    if (P = 0, l / n < r)
      return O = xt, T = -s, {
        x: e.x,
        y: e.y,
        z: e.z
      };
  } else
    P = Math.atan2(x, C);
  f = b / l, d = o / l, u = 1 / Math.sqrt(1 - t * (2 - t) * d * d), p = d * (1 - t) * u, g = f * u, E = 0;
  do
    E++, h = n / Math.sqrt(1 - t * g * g), T = o * p + b * g - h * (1 - t * g * g), c = t * h / (h + T), u = 1 / Math.sqrt(1 - c * (2 - c) * d * d), m = d * (1 - c) * u, v = f * u, y = v * p - m * g, p = m, g = v;
  while (y * y > i && E < a);
  return O = Math.atan(v / Math.abs(m)), {
    x: P,
    y: O,
    z: T
  };
}
function e2(e, t, n) {
  if (t === No)
    return {
      x: e.x + n[0],
      y: e.y + n[1],
      z: e.z + n[2]
    };
  if (t === jo) {
    var s = n[0], r = n[1], i = n[2], a = n[3], o = n[4], l = n[5], f = n[6];
    return {
      x: f * (e.x - l * e.y + o * e.z) + s,
      y: f * (l * e.x + e.y - a * e.z) + r,
      z: f * (-o * e.x + a * e.y + e.z) + i
    };
  }
}
function n2(e, t, n) {
  if (t === No)
    return {
      x: e.x - n[0],
      y: e.y - n[1],
      z: e.z - n[2]
    };
  if (t === jo) {
    var s = n[0], r = n[1], i = n[2], a = n[3], o = n[4], l = n[5], f = n[6], d = (e.x - s) / f, u = (e.y - r) / f, c = (e.z - i) / f;
    return {
      x: d + l * u - o * c,
      y: -l * d + u + a * c,
      z: o * d - a * u + c
    };
  }
}
function Th(e) {
  return e === No || e === jo;
}
function i2(e, t, n) {
  if (t2(e, t) || e.datum_type === Jg || t.datum_type === Jg)
    return n;
  var s = e.a, r = e.es;
  if (e.datum_type === Wl) {
    var i = _C(e, !1, n);
    if (i !== 0)
      return;
    s = bC, r = TC;
  }
  var a = t.a, o = t.b, l = t.es;
  if (t.datum_type === Wl && (a = bC, o = lw, l = TC), r === l && s === a && !Th(e.datum_type) && !Th(t.datum_type))
    return n;
  if (n = xP(n, r, s), Th(e.datum_type) && (n = e2(n, e.datum_type, e.datum_params)), Th(t.datum_type) && (n = n2(n, t.datum_type, t.datum_params)), n = bP(n, l, a, o), t.datum_type === Wl) {
    var f = _C(t, !0, n);
    if (f !== 0)
      return;
  }
  return n;
}
function _C(e, t, n) {
  if (e.grids === null || e.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var s = { x: -n.x, y: n.y }, r = { x: Number.NaN, y: Number.NaN }, i = [];
  t:
    for (var a = 0; a < e.grids.length; a++) {
      var o = e.grids[a];
      if (i.push(o.name), o.isNull) {
        r = s;
        break;
      }
      if (o.mandatory, o.grid === null) {
        if (o.mandatory)
          return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
        continue;
      }
      for (var l = o.grid.subgrids, f = 0, d = l.length; f < d; f++) {
        var u = l[f], c = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, h = u.ll[0] - c, p = u.ll[1] - c, g = u.ll[0] + (u.lim[0] - 1) * u.del[0] + c, m = u.ll[1] + (u.lim[1] - 1) * u.del[1] + c;
        if (!(p > s.y || h > s.x || m < s.y || g < s.x) && (r = r2(s, t, u), !isNaN(r.x)))
          break t;
      }
    }
  return isNaN(r.x) ? (console.log("Failed to find a grid shift table for location '" + -s.x * cs + " " + s.y * cs + " tried: '" + i + "'"), -1) : (n.x = -r.x, n.y = r.y, 0);
}
function r2(e, t, n) {
  var s = { x: Number.NaN, y: Number.NaN };
  if (isNaN(e.x))
    return s;
  var r = { x: e.x, y: e.y };
  r.x -= n.ll[0], r.y -= n.ll[1], r.x = Bt(r.x - Math.PI) + Math.PI;
  var i = IC(r, n);
  if (t) {
    if (isNaN(i.x))
      return s;
    i.x = r.x - i.x, i.y = r.y - i.y;
    var a = 9, o = 1e-12, l, f;
    do {
      if (f = IC(i, n), isNaN(f.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      l = { x: r.x - (f.x + i.x), y: r.y - (f.y + i.y) }, i.x += l.x, i.y += l.y;
    } while (a-- && Math.abs(l.x) > o && Math.abs(l.y) > o);
    if (a < 0)
      return console.log("Inverse grid shift iterator failed to converge."), s;
    s.x = Bt(i.x + n.ll[0]), s.y = i.y + n.ll[1];
  } else
    isNaN(i.x) || (s.x = e.x + i.x, s.y = e.y + i.y);
  return s;
}
function IC(e, t) {
  var n = { x: e.x / t.del[0], y: e.y / t.del[1] }, s = { x: Math.floor(n.x), y: Math.floor(n.y) }, r = { x: n.x - 1 * s.x, y: n.y - 1 * s.y }, i = { x: Number.NaN, y: Number.NaN }, a;
  if (s.x < 0 || s.x >= t.lim[0] || s.y < 0 || s.y >= t.lim[1])
    return i;
  a = s.y * t.lim[0] + s.x;
  var o = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a++;
  var l = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a += t.lim[0];
  var f = { x: t.cvs[a][0], y: t.cvs[a][1] };
  a--;
  var d = { x: t.cvs[a][0], y: t.cvs[a][1] }, u = r.x * r.y, c = r.x * (1 - r.y), h = (1 - r.x) * (1 - r.y), p = (1 - r.x) * r.y;
  return i.x = h * o.x + c * l.x + p * d.x + u * f.x, i.y = h * o.y + c * l.y + p * d.y + u * f.y, i;
}
function DC(e, t, n) {
  var s = n.x, r = n.y, i = n.z || 0, a, o, l, f = {};
  for (l = 0; l < 3; l++)
    if (!(t && l === 2 && n.z === void 0))
      switch (l === 0 ? (a = s, "ew".indexOf(e.axis[l]) !== -1 ? o = "x" : o = "y") : l === 1 ? (a = r, "ns".indexOf(e.axis[l]) !== -1 ? o = "y" : o = "x") : (a = i, o = "z"), e.axis[l]) {
        case "e":
          f[o] = a;
          break;
        case "w":
          f[o] = -a;
          break;
        case "n":
          f[o] = a;
          break;
        case "s":
          f[o] = -a;
          break;
        case "u":
          n[o] !== void 0 && (f.z = a);
          break;
        case "d":
          n[o] !== void 0 && (f.z = -a);
          break;
        default:
          return null;
      }
  return f;
}
function TP(e) {
  var t = {
    x: e[0],
    y: e[1]
  };
  return e.length > 2 && (t.z = e[2]), e.length > 3 && (t.m = e[3]), t;
}
function s2(e) {
  AC(e.x), AC(e.y);
}
function AC(e) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(e))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof e != "number" || e !== e || !isFinite(e))
    throw new TypeError("coordinates must be finite numbers");
}
function a2(e, t) {
  return (e.datum.datum_type === No || e.datum.datum_type === jo || e.datum.datum_type === Wl) && t.datumCode !== "WGS84" || (t.datum.datum_type === No || t.datum.datum_type === jo || t.datum.datum_type === Wl) && e.datumCode !== "WGS84";
}
function $d(e, t, n, s) {
  var r;
  Array.isArray(n) ? n = TP(n) : n = {
    x: n.x,
    y: n.y,
    z: n.z,
    m: n.m
  };
  var i = n.z !== void 0;
  if (s2(n), e.datum && t.datum && a2(e, t) && (r = new fs("WGS84"), n = $d(e, r, n, s), e = r), s && e.axis !== "enu" && (n = DC(e, !1, n)), e.projName === "longlat")
    n = {
      x: n.x * Qn,
      y: n.y * Qn,
      z: n.z || 0
    };
  else if (e.to_meter && (n = {
    x: n.x * e.to_meter,
    y: n.y * e.to_meter,
    z: n.z || 0
  }), n = e.inverse(n), !n)
    return;
  if (e.from_greenwich && (n.x += e.from_greenwich), n = i2(e.datum, t.datum, n), !!n)
    return t.from_greenwich && (n = {
      x: n.x - t.from_greenwich,
      y: n.y,
      z: n.z || 0
    }), t.projName === "longlat" ? n = {
      x: n.x * cs,
      y: n.y * cs,
      z: n.z || 0
    } : (n = t.forward(n), t.to_meter && (n = {
      x: n.x / t.to_meter,
      y: n.y / t.to_meter,
      z: n.z || 0
    })), s && t.axis !== "enu" ? DC(t, !0, n) : (n && !i && delete n.z, n);
}
var LC = fs("WGS84");
function Mp(e, t, n, s) {
  var r, i, a;
  return Array.isArray(n) ? (r = $d(e, t, n, s) || { x: NaN, y: NaN }, n.length > 2 ? typeof e.name < "u" && e.name === "geocent" || typeof t.name < "u" && t.name === "geocent" ? typeof r.z == "number" ? [r.x, r.y, r.z].concat(n.splice(3)) : [r.x, r.y, n[2]].concat(n.splice(3)) : [r.x, r.y].concat(n.splice(2)) : [r.x, r.y]) : (i = $d(e, t, n, s), a = Object.keys(n), a.length === 2 || a.forEach(function(o) {
    if (typeof e.name < "u" && e.name === "geocent" || typeof t.name < "u" && t.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    i[o] = n[o];
  }), i);
}
function RC(e) {
  return e instanceof fs ? e : e.oProj ? e.oProj : fs(e);
}
function fn(e, t, n) {
  e = RC(e);
  var s = !1, r;
  return typeof t > "u" ? (t = e, e = LC, s = !0) : (typeof t.x < "u" || Array.isArray(t)) && (n = t, t = e, e = LC, s = !0), t = RC(t), n ? Mp(e, t, n) : (r = {
    forward: function(i, a) {
      return Mp(e, t, i, a);
    },
    inverse: function(i, a) {
      return Mp(t, e, i, a);
    }
  }, s && (r.oProj = t), r);
}
var wC = 6, OP = "AJSAJS", PP = "AFAFAF", Il = 65, Vi = 73, pr = 79, Zu = 86, Ju = 90;
const o2 = {
  forward: SP,
  inverse: l2,
  toPoint: MP
};
function SP(e, t) {
  return t = t || 5, h2(u2({
    lat: e[1],
    lon: e[0]
  }), t);
}
function l2(e) {
  var t = Xy(IP(e.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top];
}
function MP(e) {
  var t = Xy(IP(e.toUpperCase()));
  return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2];
}
function _p(e) {
  return e * (Math.PI / 180);
}
function VC(e) {
  return 180 * (e / Math.PI);
}
function u2(e) {
  var t = e.lat, n = e.lon, s = 6378137, r = 669438e-8, i = 0.9996, a, o, l, f, d, u, c, h = _p(t), p = _p(n), g, m;
  m = Math.floor((n + 180) / 6) + 1, n === 180 && (m = 60), t >= 56 && t < 64 && n >= 3 && n < 12 && (m = 32), t >= 72 && t < 84 && (n >= 0 && n < 9 ? m = 31 : n >= 9 && n < 21 ? m = 33 : n >= 21 && n < 33 ? m = 35 : n >= 33 && n < 42 && (m = 37)), a = (m - 1) * 6 - 180 + 3, g = _p(a), o = r / (1 - r), l = s / Math.sqrt(1 - r * Math.sin(h) * Math.sin(h)), f = Math.tan(h) * Math.tan(h), d = o * Math.cos(h) * Math.cos(h), u = Math.cos(h) * (p - g), c = s * ((1 - r / 4 - 3 * r * r / 64 - 5 * r * r * r / 256) * h - (3 * r / 8 + 3 * r * r / 32 + 45 * r * r * r / 1024) * Math.sin(2 * h) + (15 * r * r / 256 + 45 * r * r * r / 1024) * Math.sin(4 * h) - 35 * r * r * r / 3072 * Math.sin(6 * h));
  var v = i * l * (u + (1 - f + d) * u * u * u / 6 + (5 - 18 * f + f * f + 72 * d - 58 * o) * u * u * u * u * u / 120) + 5e5, y = i * (c + l * Math.tan(h) * (u * u / 2 + (5 - f + 9 * d + 4 * d * d) * u * u * u * u / 24 + (61 - 58 * f + f * f + 600 * d - 330 * o) * u * u * u * u * u * u / 720));
  return t < 0 && (y += 1e7), {
    northing: Math.round(y),
    easting: Math.round(v),
    zoneNumber: m,
    zoneLetter: c2(t)
  };
}
function Xy(e) {
  var t = e.northing, n = e.easting, s = e.zoneLetter, r = e.zoneNumber;
  if (r < 0 || r > 60)
    return null;
  var i = 0.9996, a = 6378137, o = 669438e-8, l, f = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), d, u, c, h, p, g, m, v, y, E = n - 5e5, C = t;
  s < "N" && (C -= 1e7), m = (r - 1) * 6 - 180 + 3, l = o / (1 - o), g = C / i, v = g / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), y = v + (3 * f / 2 - 27 * f * f * f / 32) * Math.sin(2 * v) + (21 * f * f / 16 - 55 * f * f * f * f / 32) * Math.sin(4 * v) + 151 * f * f * f / 96 * Math.sin(6 * v), d = a / Math.sqrt(1 - o * Math.sin(y) * Math.sin(y)), u = Math.tan(y) * Math.tan(y), c = l * Math.cos(y) * Math.cos(y), h = a * (1 - o) / Math.pow(1 - o * Math.sin(y) * Math.sin(y), 1.5), p = E / (d * i);
  var x = y - d * Math.tan(y) / h * (p * p / 2 - (5 + 3 * u + 10 * c - 4 * c * c - 9 * l) * p * p * p * p / 24 + (61 + 90 * u + 298 * c + 45 * u * u - 252 * l - 3 * c * c) * p * p * p * p * p * p / 720);
  x = VC(x);
  var b = (p - (1 + 2 * u + c) * p * p * p / 6 + (5 - 2 * c + 28 * u - 3 * c * c + 8 * l + 24 * u * u) * p * p * p * p * p / 120) / Math.cos(y);
  b = m + VC(b);
  var P;
  if (e.accuracy) {
    var O = Xy({
      northing: e.northing + e.accuracy,
      easting: e.easting + e.accuracy,
      zoneLetter: e.zoneLetter,
      zoneNumber: e.zoneNumber
    });
    P = {
      top: O.lat,
      right: O.lon,
      bottom: x,
      left: b
    };
  } else
    P = {
      lat: x,
      lon: b
    };
  return P;
}
function c2(e) {
  var t = "Z";
  return 84 >= e && e >= 72 ? t = "X" : 72 > e && e >= 64 ? t = "W" : 64 > e && e >= 56 ? t = "V" : 56 > e && e >= 48 ? t = "U" : 48 > e && e >= 40 ? t = "T" : 40 > e && e >= 32 ? t = "S" : 32 > e && e >= 24 ? t = "R" : 24 > e && e >= 16 ? t = "Q" : 16 > e && e >= 8 ? t = "P" : 8 > e && e >= 0 ? t = "N" : 0 > e && e >= -8 ? t = "M" : -8 > e && e >= -16 ? t = "L" : -16 > e && e >= -24 ? t = "K" : -24 > e && e >= -32 ? t = "J" : -32 > e && e >= -40 ? t = "H" : -40 > e && e >= -48 ? t = "G" : -48 > e && e >= -56 ? t = "F" : -56 > e && e >= -64 ? t = "E" : -64 > e && e >= -72 ? t = "D" : -72 > e && e >= -80 && (t = "C"), t;
}
function h2(e, t) {
  var n = "00000" + e.easting, s = "00000" + e.northing;
  return e.zoneNumber + e.zoneLetter + d2(e.easting, e.northing, e.zoneNumber) + n.substr(n.length - 5, t) + s.substr(s.length - 5, t);
}
function d2(e, t, n) {
  var s = _P(n), r = Math.floor(e / 1e5), i = Math.floor(t / 1e5) % 20;
  return f2(r, i, s);
}
function _P(e) {
  var t = e % wC;
  return t === 0 && (t = wC), t;
}
function f2(e, t, n) {
  var s = n - 1, r = OP.charCodeAt(s), i = PP.charCodeAt(s), a = r + e - 1, o = i + t, l = !1;
  a > Ju && (a = a - Ju + Il - 1, l = !0), (a === Vi || r < Vi && a > Vi || (a > Vi || r < Vi) && l) && a++, (a === pr || r < pr && a > pr || (a > pr || r < pr) && l) && (a++, a === Vi && a++), a > Ju && (a = a - Ju + Il - 1), o > Zu ? (o = o - Zu + Il - 1, l = !0) : l = !1, (o === Vi || i < Vi && o > Vi || (o > Vi || i < Vi) && l) && o++, (o === pr || i < pr && o > pr || (o > pr || i < pr) && l) && (o++, o === Vi && o++), o > Zu && (o = o - Zu + Il - 1);
  var f = String.fromCharCode(a) + String.fromCharCode(o);
  return f;
}
function IP(e) {
  if (e && e.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var t = e.length, n = null, s = "", r, i = 0; !/[A-Z]/.test(r = e.charAt(i)); ) {
    if (i >= 2)
      throw "MGRSPoint bad conversion from: " + e;
    s += r, i++;
  }
  var a = parseInt(s, 10);
  if (i === 0 || i + 3 > t)
    throw "MGRSPoint bad conversion from: " + e;
  var o = e.charAt(i++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + e;
  n = e.substring(i, i += 2);
  for (var l = _P(a), f = p2(n.charAt(0), l), d = m2(n.charAt(1), l); d < g2(o); )
    d += 2e6;
  var u = t - i;
  if (u % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + e;
  var c = u / 2, h = 0, p = 0, g, m, v, y, E;
  return c > 0 && (g = 1e5 / Math.pow(10, c), m = e.substring(i, i + c), h = parseFloat(m) * g, v = e.substring(i + c), p = parseFloat(v) * g), y = h + f, E = p + d, {
    easting: y,
    northing: E,
    zoneLetter: o,
    zoneNumber: a,
    accuracy: g
  };
}
function p2(e, t) {
  for (var n = OP.charCodeAt(t - 1), s = 1e5, r = !1; n !== e.charCodeAt(0); ) {
    if (n++, n === Vi && n++, n === pr && n++, n > Ju) {
      if (r)
        throw "Bad character: " + e;
      n = Il, r = !0;
    }
    s += 1e5;
  }
  return s;
}
function m2(e, t) {
  if (e > "V")
    throw "MGRSPoint given invalid Northing " + e;
  for (var n = PP.charCodeAt(t - 1), s = 0, r = !1; n !== e.charCodeAt(0); ) {
    if (n++, n === Vi && n++, n === pr && n++, n > Zu) {
      if (r)
        throw "Bad character: " + e;
      n = Il, r = !0;
    }
    s += 1e5;
  }
  return s;
}
function g2(e) {
  var t;
  switch (e) {
    case "C":
      t = 11e5;
      break;
    case "D":
      t = 2e6;
      break;
    case "E":
      t = 28e5;
      break;
    case "F":
      t = 37e5;
      break;
    case "G":
      t = 46e5;
      break;
    case "H":
      t = 55e5;
      break;
    case "J":
      t = 64e5;
      break;
    case "K":
      t = 73e5;
      break;
    case "L":
      t = 82e5;
      break;
    case "M":
      t = 91e5;
      break;
    case "N":
      t = 0;
      break;
    case "P":
      t = 8e5;
      break;
    case "Q":
      t = 17e5;
      break;
    case "R":
      t = 26e5;
      break;
    case "S":
      t = 35e5;
      break;
    case "T":
      t = 44e5;
      break;
    case "U":
      t = 53e5;
      break;
    case "V":
      t = 62e5;
      break;
    case "W":
      t = 7e6;
      break;
    case "X":
      t = 79e5;
      break;
    default:
      t = -1;
  }
  if (t >= 0)
    return t;
  throw "Invalid zone letter: " + e;
}
function iu(e, t, n) {
  if (!(this instanceof iu))
    return new iu(e, t, n);
  if (Array.isArray(e))
    this.x = e[0], this.y = e[1], this.z = e[2] || 0;
  else if (typeof e == "object")
    this.x = e.x, this.y = e.y, this.z = e.z || 0;
  else if (typeof e == "string" && typeof t > "u") {
    var s = e.split(",");
    this.x = parseFloat(s[0], 10), this.y = parseFloat(s[1], 10), this.z = parseFloat(s[2], 10) || 0;
  } else
    this.x = e, this.y = t, this.z = n || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
iu.fromMGRS = function(e) {
  return new iu(MP(e));
};
iu.prototype.toMGRS = function(e) {
  return SP([this.x, this.y], e);
};
var v2 = 1, y2 = 0.25, BC = 0.046875, FC = 0.01953125, NC = 0.01068115234375, E2 = 0.75, C2 = 0.46875, x2 = 0.013020833333333334, b2 = 0.007120768229166667, T2 = 0.3645833333333333, O2 = 0.005696614583333333, P2 = 0.3076171875;
function DP(e) {
  var t = [];
  t[0] = v2 - e * (y2 + e * (BC + e * (FC + e * NC))), t[1] = e * (E2 - e * (BC + e * (FC + e * NC)));
  var n = e * e;
  return t[2] = n * (C2 - e * (x2 + e * b2)), n *= e, t[3] = n * (T2 - e * O2), t[4] = n * e * P2, t;
}
function $f(e, t, n, s) {
  return n *= t, t *= t, s[0] * e - n * (s[1] + t * (s[2] + t * (s[3] + t * s[4])));
}
var S2 = 20;
function AP(e, t, n) {
  for (var s = 1 / (1 - t), r = e, i = S2; i; --i) {
    var a = Math.sin(r), o = 1 - t * a * a;
    if (o = ($f(r, a, Math.cos(r), n) - e) * (o * Math.sqrt(o)) * s, r -= o, Math.abs(o) < Dt)
      return r;
  }
  return r;
}
function M2() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = DP(this.es), this.ml0 = $f(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function _2(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r, i, a, o = Math.sin(n), l = Math.cos(n);
  if (this.es) {
    var d = l * s, u = Math.pow(d, 2), c = this.ep2 * Math.pow(l, 2), h = Math.pow(c, 2), p = Math.abs(l) > Dt ? Math.tan(n) : 0, g = Math.pow(p, 2), m = Math.pow(g, 2);
    r = 1 - this.es * Math.pow(o, 2), d = d / Math.sqrt(r);
    var v = $f(n, o, l, this.en);
    i = this.a * (this.k0 * d * (1 + u / 6 * (1 - g + c + u / 20 * (5 - 18 * g + m + 14 * c - 58 * g * c + u / 42 * (61 + 179 * m - m * g - 479 * g))))) + this.x0, a = this.a * (this.k0 * (v - this.ml0 + o * s * d / 2 * (1 + u / 12 * (5 - g + 9 * c + 4 * h + u / 30 * (61 + m - 58 * g + 270 * c - 330 * g * c + u / 56 * (1385 + 543 * m - m * g - 3111 * g)))))) + this.y0;
  } else {
    var f = l * Math.sin(s);
    if (Math.abs(Math.abs(f) - 1) < Dt)
      return 93;
    if (i = 0.5 * this.a * this.k0 * Math.log((1 + f) / (1 - f)) + this.x0, a = l * Math.cos(s) / Math.sqrt(1 - Math.pow(f, 2)), f = Math.abs(a), f >= 1) {
      if (f - 1 > Dt)
        return 93;
      a = 0;
    } else
      a = Math.acos(a);
    n < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
  }
  return e.x = i, e.y = a, e;
}
function I2(e) {
  var t, n, s, r, i = (e.x - this.x0) * (1 / this.a), a = (e.y - this.y0) * (1 / this.a);
  if (this.es)
    if (t = this.ml0 + a / this.k0, n = AP(t, this.es, this.en), Math.abs(n) < xt) {
      var u = Math.sin(n), c = Math.cos(n), h = Math.abs(c) > Dt ? Math.tan(n) : 0, p = this.ep2 * Math.pow(c, 2), g = Math.pow(p, 2), m = Math.pow(h, 2), v = Math.pow(m, 2);
      t = 1 - this.es * Math.pow(u, 2);
      var y = i * Math.sqrt(t) / this.k0, E = Math.pow(y, 2);
      t = t * h, s = n - t * E / (1 - this.es) * 0.5 * (1 - E / 12 * (5 + 3 * m - 9 * p * m + p - 4 * g - E / 30 * (61 + 90 * m - 252 * p * m + 45 * v + 46 * p - E / 56 * (1385 + 3633 * m + 4095 * v + 1574 * v * m)))), r = Bt(this.long0 + y * (1 - E / 6 * (1 + 2 * m + p - E / 20 * (5 + 28 * m + 24 * v + 8 * p * m + 6 * p - E / 42 * (61 + 662 * m + 1320 * v + 720 * v * m)))) / c);
    } else
      s = xt * Gc(a), r = 0;
  else {
    var o = Math.exp(i / this.k0), l = 0.5 * (o - 1 / o), f = this.lat0 + a / this.k0, d = Math.cos(f);
    t = Math.sqrt((1 - Math.pow(d, 2)) / (1 + Math.pow(l, 2))), s = Math.asin(t), a < 0 && (s = -s), l === 0 && d === 0 ? r = 0 : r = Bt(Math.atan2(l, d) + this.long0);
  }
  return e.x = r, e.y = s, e;
}
var D2 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const hd = {
  init: M2,
  forward: _2,
  inverse: I2,
  names: D2
};
function LP(e) {
  var t = Math.exp(e);
  return t = (t - 1 / t) / 2, t;
}
function Lr(e, t) {
  e = Math.abs(e), t = Math.abs(t);
  var n = Math.max(e, t), s = Math.min(e, t) / (n || 1);
  return n * Math.sqrt(1 + Math.pow(s, 2));
}
function A2(e) {
  var t = 1 + e, n = t - 1;
  return n === 0 ? e : e * Math.log(t) / n;
}
function L2(e) {
  var t = Math.abs(e);
  return t = A2(t * (1 + t / (Lr(1, t) + 1))), e < 0 ? -t : t;
}
function Zy(e, t) {
  for (var n = 2 * Math.cos(2 * t), s = e.length - 1, r = e[s], i = 0, a; --s >= 0; )
    a = -i + n * r + e[s], i = r, r = a;
  return t + a * Math.sin(2 * t);
}
function R2(e, t) {
  for (var n = 2 * Math.cos(t), s = e.length - 1, r = e[s], i = 0, a; --s >= 0; )
    a = -i + n * r + e[s], i = r, r = a;
  return Math.sin(t) * a;
}
function w2(e) {
  var t = Math.exp(e);
  return t = (t + 1 / t) / 2, t;
}
function RP(e, t, n) {
  for (var s = Math.sin(t), r = Math.cos(t), i = LP(n), a = w2(n), o = 2 * r * a, l = -2 * s * i, f = e.length - 1, d = e[f], u = 0, c = 0, h = 0, p, g; --f >= 0; )
    p = c, g = u, c = d, u = h, d = -p + o * c - l * u + e[f], h = -g + l * c + o * u;
  return o = s * a, l = r * i, [o * d - l * h, o * h + l * d];
}
function V2() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (hd.init.apply(this), this.forward = hd.forward, this.inverse = hd.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var e = this.es / (1 + Math.sqrt(1 - this.es)), t = e / (2 - e), n = t;
  this.cgb[0] = t * (2 + t * (-2 / 3 + t * (-2 + t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675)))))), this.cbg[0] = t * (-2 + t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725)))))), n = n * t, this.cgb[1] = n * (7 / 3 + t * (-8 / 5 + t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))))), this.cbg[1] = n * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), n = n * t, this.cgb[2] = n * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = n * (-26 / 15 + t * (34 / 21 + t * (8 / 5 + t * (-12686 / 2835)))), n = n * t, this.cgb[3] = n * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = n * (1237 / 630 + t * (-12 / 5 + t * (-24832 / 14175))), n = n * t, this.cgb[4] = n * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = n * (-734 / 315 + t * (109598 / 31185)), n = n * t, this.cgb[5] = n * (601676 / 22275), this.cbg[5] = n * (444337 / 155925), n = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + n * (1 / 4 + n * (1 / 64 + n / 256))), this.utg[0] = t * (-0.5 + t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800)))))), this.gtu[0] = t * (0.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = n * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = n * (13 / 48 + t * (-3 / 5 + t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))))), n = n * t, this.utg[2] = n * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = n * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), n = n * t, this.utg[3] = n * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = n * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), n = n * t, this.utg[4] = n * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = n * (34729 / 80640 + t * (-3418889 / 1995840)), n = n * t, this.utg[5] = n * (-20648693 / 638668800), this.gtu[5] = n * (212378941 / 319334400);
  var s = Zy(this.cbg, this.lat0);
  this.Zb = -this.Qn * (s + R2(this.gtu, 2 * s));
}
function B2(e) {
  var t = Bt(e.x - this.long0), n = e.y;
  n = Zy(this.cbg, n);
  var s = Math.sin(n), r = Math.cos(n), i = Math.sin(t), a = Math.cos(t);
  n = Math.atan2(s, a * r), t = Math.atan2(i * r, Lr(s, r * a)), t = L2(Math.tan(t));
  var o = RP(this.gtu, 2 * n, 2 * t);
  n = n + o[0], t = t + o[1];
  var l, f;
  return Math.abs(t) <= 2.623395162778 ? (l = this.a * (this.Qn * t) + this.x0, f = this.a * (this.Qn * n + this.Zb) + this.y0) : (l = 1 / 0, f = 1 / 0), e.x = l, e.y = f, e;
}
function F2(e) {
  var t = (e.x - this.x0) * (1 / this.a), n = (e.y - this.y0) * (1 / this.a);
  n = (n - this.Zb) / this.Qn, t = t / this.Qn;
  var s, r;
  if (Math.abs(t) <= 2.623395162778) {
    var i = RP(this.utg, 2 * n, 2 * t);
    n = n + i[0], t = t + i[1], t = Math.atan(LP(t));
    var a = Math.sin(n), o = Math.cos(n), l = Math.sin(t), f = Math.cos(t);
    n = Math.atan2(a * f, Lr(l, f * o)), t = Math.atan2(l, f * o), s = Bt(t + this.long0), r = Zy(this.cgb, n);
  } else
    s = 1 / 0, r = 1 / 0;
  return e.x = s, e.y = r, e;
}
var N2 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const dd = {
  init: V2,
  forward: B2,
  inverse: F2,
  names: N2
};
function j2(e, t) {
  if (e === void 0) {
    if (e = Math.floor((Bt(t) + Math.PI) * 30 / Math.PI) + 1, e < 0)
      return 0;
    if (e > 60)
      return 60;
  }
  return e;
}
var $2 = "etmerc";
function U2() {
  var e = j2(this.zone, this.long0);
  if (e === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(e) - 183) * Qn, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, dd.init.apply(this), this.forward = dd.forward, this.inverse = dd.inverse;
}
var W2 = ["Universal Transverse Mercator System", "utm"];
const z2 = {
  init: U2,
  names: W2,
  dependsOn: $2
};
function Jy(e, t) {
  return Math.pow((1 - e) / (1 + e), t);
}
var K2 = 20;
function G2() {
  var e = Math.sin(this.lat0), t = Math.cos(this.lat0);
  t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * e * e), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(e / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + De) / (Math.pow(Math.tan(0.5 * this.lat0 + De), this.C) * Jy(this.e * e, this.ratexp));
}
function k2(e) {
  var t = e.x, n = e.y;
  return e.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * n + De), this.C) * Jy(this.e * Math.sin(n), this.ratexp)) - xt, e.x = this.C * t, e;
}
function H2(e) {
  for (var t = 1e-14, n = e.x / this.C, s = e.y, r = Math.pow(Math.tan(0.5 * s + De) / this.K, 1 / this.C), i = K2; i > 0 && (s = 2 * Math.atan(r * Jy(this.e * Math.sin(e.y), -0.5 * this.e)) - xt, !(Math.abs(s - e.y) < t)); --i)
    e.y = s;
  return i ? (e.x = n, e.y = s, e) : null;
}
var Y2 = ["gauss"];
const Qy = {
  init: G2,
  forward: k2,
  inverse: H2,
  names: Y2
};
function X2() {
  Qy.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function Z2(e) {
  var t, n, s, r;
  return e.x = Bt(e.x - this.long0), Qy.forward.apply(this, [e]), t = Math.sin(e.y), n = Math.cos(e.y), s = Math.cos(e.x), r = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * n * s), e.x = r * n * Math.sin(e.x), e.y = r * (this.cosc0 * t - this.sinc0 * n * s), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function J2(e) {
  var t, n, s, r, i;
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, i = Math.sqrt(e.x * e.x + e.y * e.y)) {
    var a = 2 * Math.atan2(i, this.R2);
    t = Math.sin(a), n = Math.cos(a), r = Math.asin(n * this.sinc0 + e.y * t * this.cosc0 / i), s = Math.atan2(e.x * t, i * this.cosc0 * n - e.y * this.sinc0 * t);
  } else
    r = this.phic0, s = 0;
  return e.x = s, e.y = r, Qy.inverse.apply(this, [e]), e.x = Bt(e.x + this.long0), e;
}
var Q2 = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const q2 = {
  init: X2,
  forward: Z2,
  inverse: J2,
  names: Q2
};
function tV(e, t, n) {
  return t *= n, Math.tan(0.5 * (xt + e)) * Math.pow((1 - t) / (1 + t), 0.5 * n);
}
function eV() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Dt && (this.k0 = 0.5 * (1 + Gc(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Dt && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Dt && Math.abs(Math.cos(this.lat_ts)) > Dt && (this.k0 = 0.5 * this.cons * ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Fr(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ys(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - xt, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function nV(e) {
  var t = e.x, n = e.y, s = Math.sin(n), r = Math.cos(n), i, a, o, l, f, d, u = Bt(t - this.long0);
  return Math.abs(Math.abs(t - this.long0) - Math.PI) <= Dt && Math.abs(n + this.lat0) <= Dt ? (e.x = NaN, e.y = NaN, e) : this.sphere ? (i = 2 * this.k0 / (1 + this.sinlat0 * s + this.coslat0 * r * Math.cos(u)), e.x = this.a * i * r * Math.sin(u) + this.x0, e.y = this.a * i * (this.coslat0 * s - this.sinlat0 * r * Math.cos(u)) + this.y0, e) : (a = 2 * Math.atan(this.ssfn_(n, s, this.e)) - xt, l = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= Dt ? (f = Fr(this.e, n * this.con, this.con * s), d = 2 * this.a * this.k0 * f / this.cons, e.x = this.x0 + d * Math.sin(t - this.long0), e.y = this.y0 - this.con * d * Math.cos(t - this.long0), e) : (Math.abs(this.sinlat0) < Dt ? (i = 2 * this.a * this.k0 / (1 + l * Math.cos(u)), e.y = i * o) : (i = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * l * Math.cos(u))), e.y = i * (this.cosX0 * o - this.sinX0 * l * Math.cos(u)) + this.y0), e.x = i * l * Math.sin(u) + this.x0, e));
}
function iV(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n, s, r, i, a = Math.sqrt(e.x * e.x + e.y * e.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return t = this.long0, n = this.lat0, a <= Dt ? (e.x = t, e.y = n, e) : (n = Math.asin(Math.cos(o) * this.sinlat0 + e.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < Dt ? this.lat0 > 0 ? t = Bt(this.long0 + Math.atan2(e.x, -1 * e.y)) : t = Bt(this.long0 + Math.atan2(e.x, e.y)) : t = Bt(this.long0 + Math.atan2(e.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - e.y * this.sinlat0 * Math.sin(o))), e.x = t, e.y = n, e);
  } else if (Math.abs(this.coslat0) <= Dt) {
    if (a <= Dt)
      return n = this.lat0, t = this.long0, e.x = t, e.y = n, e;
    e.x *= this.con, e.y *= this.con, s = a * this.cons / (2 * this.a * this.k0), n = this.con * Cc(this.e, s), t = this.con * Bt(this.con * this.long0 + Math.atan2(e.x, -1 * e.y));
  } else
    r = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, a <= Dt ? i = this.X0 : (i = Math.asin(Math.cos(r) * this.sinX0 + e.y * Math.sin(r) * this.cosX0 / a), t = Bt(this.long0 + Math.atan2(e.x * Math.sin(r), a * this.cosX0 * Math.cos(r) - e.y * this.sinX0 * Math.sin(r)))), n = -1 * Cc(this.e, Math.tan(0.5 * (xt + i)));
  return e.x = t, e.y = n, e;
}
var rV = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
const sV = {
  init: eV,
  forward: nV,
  inverse: iV,
  names: rV,
  ssfn_: tV
};
function aV() {
  var e = this.lat0;
  this.lambda0 = this.long0;
  var t = Math.sin(e), n = this.a, s = this.rf, r = 1 / s, i = 2 * r - Math.pow(r, 2), a = this.e = Math.sqrt(i);
  this.R = this.k0 * n * Math.sqrt(1 - i) / (1 - i * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + i / (1 - i) * Math.pow(Math.cos(e), 4)), this.b0 = Math.asin(t / this.alpha);
  var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), l = Math.log(Math.tan(Math.PI / 4 + e / 2)), f = Math.log((1 + a * t) / (1 - a * t));
  this.K = o - this.alpha * l + this.alpha * a / 2 * f;
}
function oV(e) {
  var t = Math.log(Math.tan(Math.PI / 4 - e.y / 2)), n = this.e / 2 * Math.log((1 + this.e * Math.sin(e.y)) / (1 - this.e * Math.sin(e.y))), s = -this.alpha * (t + n) + this.K, r = 2 * (Math.atan(Math.exp(s)) - Math.PI / 4), i = this.alpha * (e.x - this.lambda0), a = Math.atan(Math.sin(i) / (Math.sin(this.b0) * Math.tan(r) + Math.cos(this.b0) * Math.cos(i))), o = Math.asin(Math.cos(this.b0) * Math.sin(r) - Math.sin(this.b0) * Math.cos(r) * Math.cos(i));
  return e.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, e.x = this.R * a + this.x0, e;
}
function lV(e) {
  for (var t = e.x - this.x0, n = e.y - this.y0, s = t / this.R, r = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), i = Math.asin(Math.cos(this.b0) * Math.sin(r) + Math.sin(this.b0) * Math.cos(r) * Math.cos(s)), a = Math.atan(Math.sin(s) / (Math.cos(this.b0) * Math.cos(s) - Math.sin(this.b0) * Math.tan(r))), o = this.lambda0 + a / this.alpha, l = 0, f = i, d = -1e3, u = 0; Math.abs(f - d) > 1e-7; ) {
    if (++u > 20)
      return;
    l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + i / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(f)) / 2)), d = f, f = 2 * Math.atan(Math.exp(l)) - Math.PI / 2;
  }
  return e.x = o, e.y = f, e;
}
var uV = ["somerc"];
const cV = {
  init: aV,
  forward: oV,
  inverse: lV,
  names: uV
};
var Cl = 1e-7;
function hV(e) {
  var t = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], n = typeof e.PROJECTION == "object" ? Object.keys(e.PROJECTION)[0] : e.PROJECTION;
  return "no_uoff" in e || "no_off" in e || t.indexOf(n) !== -1;
}
function dV() {
  var e, t, n, s, r, i, a, o, l, f, d = 0, u, c = 0, h = 0, p = 0, g = 0, m = 0, v = 0;
  this.no_off = hV(this), this.no_rot = "no_rot" in this;
  var y = !1;
  "alpha" in this && (y = !0);
  var E = !1;
  if ("rectified_grid_angle" in this && (E = !0), y && (v = this.alpha), E && (d = this.rectified_grid_angle * Qn), y || E)
    c = this.longc;
  else if (h = this.long1, g = this.lat1, p = this.long2, m = this.lat2, Math.abs(g - m) <= Cl || (e = Math.abs(g)) <= Cl || Math.abs(e - xt) <= Cl || Math.abs(Math.abs(this.lat0) - xt) <= Cl || Math.abs(Math.abs(m) - xt) <= Cl)
    throw new Error();
  var C = 1 - this.es;
  t = Math.sqrt(C), Math.abs(this.lat0) > Dt ? (o = Math.sin(this.lat0), n = Math.cos(this.lat0), e = 1 - this.es * o * o, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / C), this.A = this.B * this.k0 * t / e, s = this.B * t / (n * Math.sqrt(e)), r = s * s - 1, r <= 0 ? r = 0 : (r = Math.sqrt(r), this.lat0 < 0 && (r = -r)), this.E = r += s, this.E *= Math.pow(Fr(this.e, this.lat0, o), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = s = r = 1), y || E ? (y ? (u = Math.asin(Math.sin(v) / s), E || (d = v)) : (u = d, v = Math.asin(s * Math.sin(u))), this.lam0 = c - Math.asin(0.5 * (r - 1 / r) * Math.tan(u)) / this.B) : (i = Math.pow(Fr(this.e, g, Math.sin(g)), this.B), a = Math.pow(Fr(this.e, m, Math.sin(m)), this.B), r = this.E / i, l = (a - i) / (a + i), f = this.E * this.E, f = (f - a * i) / (f + a * i), e = h - p, e < -Math.pi ? p -= yc : e > Math.pi && (p += yc), this.lam0 = Bt(0.5 * (h + p) - Math.atan(f * Math.tan(0.5 * this.B * (h - p)) / l) / this.B), u = Math.atan(2 * Math.sin(this.B * Bt(h - this.lam0)) / (r - 1 / r)), d = v = Math.asin(s * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(d), this.cosrot = Math.cos(d), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(s * s - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), r = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(De - r)), this.v_pole_s = this.ArB * Math.log(Math.tan(De + r));
}
function fV(e) {
  var t = {}, n, s, r, i, a, o, l, f;
  if (e.x = e.x - this.lam0, Math.abs(Math.abs(e.y) - xt) > Dt) {
    if (a = this.E / Math.pow(Fr(this.e, e.y, Math.sin(e.y)), this.B), o = 1 / a, n = 0.5 * (a - o), s = 0.5 * (a + o), i = Math.sin(this.B * e.x), r = (n * this.singam - i * this.cosgam) / s, Math.abs(Math.abs(r) - 1) < Dt)
      throw new Error();
    f = 0.5 * this.ArB * Math.log((1 - r) / (1 + r)), o = Math.cos(this.B * e.x), Math.abs(o) < Cl ? l = this.A * e.x : l = this.ArB * Math.atan2(n * this.cosgam + i * this.singam, o);
  } else
    f = e.y > 0 ? this.v_pole_n : this.v_pole_s, l = this.ArB * e.y;
  return this.no_rot ? (t.x = l, t.y = f) : (l -= this.u_0, t.x = f * this.cosrot + l * this.sinrot, t.y = l * this.cosrot - f * this.sinrot), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
}
function pV(e) {
  var t, n, s, r, i, a, o, l = {};
  if (e.x = (e.x - this.x0) * (1 / this.a), e.y = (e.y - this.y0) * (1 / this.a), this.no_rot ? (n = e.y, t = e.x) : (n = e.x * this.cosrot - e.y * this.sinrot, t = e.y * this.cosrot + e.x * this.sinrot + this.u_0), s = Math.exp(-this.BrA * n), r = 0.5 * (s - 1 / s), i = 0.5 * (s + 1 / s), a = Math.sin(this.BrA * t), o = (a * this.cosgam + r * this.singam) / i, Math.abs(Math.abs(o) - 1) < Dt)
    l.x = 0, l.y = o < 0 ? -xt : xt;
  else {
    if (l.y = this.E / Math.sqrt((1 + o) / (1 - o)), l.y = Cc(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0)
      throw new Error();
    l.x = -this.rB * Math.atan2(r * this.cosgam - a * this.singam, Math.cos(this.BrA * t));
  }
  return l.x += this.lam0, l;
}
var mV = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const gV = {
  init: dV,
  forward: fV,
  inverse: pV,
  names: mV
};
function vV() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Dt)) {
    var e = this.b / this.a;
    this.e = Math.sqrt(1 - e * e);
    var t = Math.sin(this.lat1), n = Math.cos(this.lat1), s = ys(this.e, t, n), r = Fr(this.e, this.lat1, t), i = Math.sin(this.lat2), a = Math.cos(this.lat2), o = ys(this.e, i, a), l = Fr(this.e, this.lat2, i), f = Fr(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Dt ? this.ns = Math.log(s / o) / Math.log(r / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = s / (this.ns * Math.pow(r, this.ns)), this.rh = this.a * this.f0 * Math.pow(f, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function yV(e) {
  var t = e.x, n = e.y;
  Math.abs(2 * Math.abs(n) - Math.PI) <= Dt && (n = Gc(n) * (xt - 2 * Dt));
  var s = Math.abs(Math.abs(n) - xt), r, i;
  if (s > Dt)
    r = Fr(this.e, n, Math.sin(n)), i = this.a * this.f0 * Math.pow(r, this.ns);
  else {
    if (s = n * this.ns, s <= 0)
      return null;
    i = 0;
  }
  var a = this.ns * Bt(t - this.long0);
  return e.x = this.k0 * (i * Math.sin(a)) + this.x0, e.y = this.k0 * (this.rh - i * Math.cos(a)) + this.y0, e;
}
function EV(e) {
  var t, n, s, r, i, a = (e.x - this.x0) / this.k0, o = this.rh - (e.y - this.y0) / this.k0;
  this.ns > 0 ? (t = Math.sqrt(a * a + o * o), n = 1) : (t = -Math.sqrt(a * a + o * o), n = -1);
  var l = 0;
  if (t !== 0 && (l = Math.atan2(n * a, n * o)), t !== 0 || this.ns > 0) {
    if (n = 1 / this.ns, s = Math.pow(t / (this.a * this.f0), n), r = Cc(this.e, s), r === -9999)
      return null;
  } else
    r = -xt;
  return i = Bt(l / this.ns + this.long0), e.x = i, e.y = r, e;
}
var CV = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const xV = {
  init: vV,
  forward: yV,
  inverse: EV,
  names: CV
};
function bV() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function TV(e) {
  var t, n, s, r, i, a, o, l = e.x, f = e.y, d = Bt(l - this.long0);
  return t = Math.pow((1 + this.e * Math.sin(f)) / (1 - this.e * Math.sin(f)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(f / 2 + this.s45), this.alfa) / t) - this.s45), s = -d * this.alfa, r = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(s)), i = Math.asin(Math.cos(n) * Math.sin(s) / Math.cos(r)), a = this.n * i, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(r / 2 + this.s45), this.n), e.y = o * Math.cos(a) / 1, e.x = o * Math.sin(a) / 1, this.czech || (e.y *= -1, e.x *= -1), e;
}
function OV(e) {
  var t, n, s, r, i, a, o, l, f = e.x;
  e.x = e.y, e.y = f, this.czech || (e.y *= -1, e.x *= -1), a = Math.sqrt(e.x * e.x + e.y * e.y), i = Math.atan2(e.y, e.x), r = i / Math.sin(this.s0), s = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(r)), n = Math.asin(Math.cos(s) * Math.sin(r) / Math.cos(t)), e.x = this.long0 - n / this.alfa, o = t, l = 0;
  var d = 0;
  do
    e.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - e.y) < 1e-10 && (l = 1), o = e.y, d += 1;
  while (l === 0 && d < 15);
  return d >= 15 ? null : e;
}
var PV = ["Krovak", "krovak"];
const SV = {
  init: bV,
  forward: TV,
  inverse: OV,
  names: PV
};
function Mi(e, t, n, s, r) {
  return e * r - t * Math.sin(2 * r) + n * Math.sin(4 * r) - s * Math.sin(6 * r);
}
function kc(e) {
  return 1 - 0.25 * e * (1 + e / 16 * (3 + 1.25 * e));
}
function Hc(e) {
  return 0.375 * e * (1 + 0.25 * e * (1 + 0.46875 * e));
}
function Yc(e) {
  return 0.05859375 * e * e * (1 + 0.75 * e);
}
function Xc(e) {
  return e * e * e * (35 / 3072);
}
function ru(e, t, n) {
  var s = t * n;
  return e / Math.sqrt(1 - s * s);
}
function pu(e) {
  return Math.abs(e) < xt ? e : e - Gc(e) * Math.PI;
}
function Ud(e, t, n, s, r) {
  var i, a;
  i = e / t;
  for (var o = 0; o < 15; o++)
    if (a = (e - (t * i - n * Math.sin(2 * i) + s * Math.sin(4 * i) - r * Math.sin(6 * i))) / (t - 2 * n * Math.cos(2 * i) + 4 * s * Math.cos(4 * i) - 6 * r * Math.cos(6 * i)), i += a, Math.abs(a) <= 1e-10)
      return i;
  return NaN;
}
function MV() {
  this.sphere || (this.e0 = kc(this.es), this.e1 = Hc(this.es), this.e2 = Yc(this.es), this.e3 = Xc(this.es), this.ml0 = this.a * Mi(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function _V(e) {
  var t, n, s = e.x, r = e.y;
  if (s = Bt(s - this.long0), this.sphere)
    t = this.a * Math.asin(Math.cos(r) * Math.sin(s)), n = this.a * (Math.atan2(Math.tan(r), Math.cos(s)) - this.lat0);
  else {
    var i = Math.sin(r), a = Math.cos(r), o = ru(this.a, this.e, i), l = Math.tan(r) * Math.tan(r), f = s * Math.cos(r), d = f * f, u = this.es * a * a / (1 - this.es), c = this.a * Mi(this.e0, this.e1, this.e2, this.e3, r);
    t = o * f * (1 - d * l * (1 / 6 - (8 - l + 8 * u) * d / 120)), n = c - this.ml0 + o * i / a * d * (0.5 + (5 - l + 6 * u) * d / 24);
  }
  return e.x = t + this.x0, e.y = n + this.y0, e;
}
function IV(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = e.x / this.a, n = e.y / this.a, s, r;
  if (this.sphere) {
    var i = n + this.lat0;
    s = Math.asin(Math.sin(i) * Math.cos(t)), r = Math.atan2(Math.tan(t), Math.cos(i));
  } else {
    var a = this.ml0 / this.a + n, o = Ud(a, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(o) - xt) <= Dt)
      return e.x = this.long0, e.y = xt, n < 0 && (e.y *= -1), e;
    var l = ru(this.a, this.e, Math.sin(o)), f = l * l * l / this.a / this.a * (1 - this.es), d = Math.pow(Math.tan(o), 2), u = t * this.a / l, c = u * u;
    s = o - l * Math.tan(o) / f * u * u * (0.5 - (1 + 3 * d) * u * u / 24), r = u * (1 - c * (d / 3 + (1 + 3 * d) * d * c / 15)) / Math.cos(o);
  }
  return e.x = Bt(r + this.long0), e.y = pu(s), e;
}
var DV = ["Cassini", "Cassini_Soldner", "cass"];
const AV = {
  init: MV,
  forward: _V,
  inverse: IV,
  names: DV
};
function Na(e, t) {
  var n;
  return e > 1e-7 ? (n = e * t, (1 - e * e) * (t / (1 - n * n) - 0.5 / e * Math.log((1 - n) / (1 + n)))) : 2 * t;
}
var LV = 1, RV = 2, wV = 3, VV = 4;
function BV() {
  var e = Math.abs(this.lat0);
  if (Math.abs(e - xt) < Dt ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < Dt ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var t;
    switch (this.qp = Na(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = GV(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = Na(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function FV(e) {
  var t, n, s, r, i, a, o, l, f, d, u = e.x, c = e.y;
  if (u = Bt(u - this.long0), this.sphere) {
    if (i = Math.sin(c), d = Math.cos(c), s = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (n = this.mode === this.EQUIT ? 1 + d * s : 1 + this.sinph0 * i + this.cosph0 * d * s, n <= Dt)
        return null;
      n = Math.sqrt(2 / n), t = n * d * Math.sin(u), n *= this.mode === this.EQUIT ? i : this.cosph0 * i - this.sinph0 * d * s;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (s = -s), Math.abs(c + this.lat0) < Dt)
        return null;
      n = De - c * 0.5, n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n)), t = n * Math.sin(u), n *= s;
    }
  } else {
    switch (o = 0, l = 0, f = 0, s = Math.cos(u), r = Math.sin(u), i = Math.sin(c), a = Na(this.e, i), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, l = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        f = 1 + this.sinb1 * o + this.cosb1 * l * s;
        break;
      case this.EQUIT:
        f = 1 + l * s;
        break;
      case this.N_POLE:
        f = xt + c, a = this.qp - a;
        break;
      case this.S_POLE:
        f = c - xt, a = this.qp + a;
        break;
    }
    if (Math.abs(f) < Dt)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        f = Math.sqrt(2 / f), this.mode === this.OBLIQ ? n = this.ymf * f * (this.cosb1 * o - this.sinb1 * l * s) : n = (f = Math.sqrt(2 / (1 + l * s))) * o * this.ymf, t = this.xmf * f * l * r;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (t = (f = Math.sqrt(a)) * r, n = s * (this.mode === this.S_POLE ? f : -f)) : t = n = 0;
        break;
    }
  }
  return e.x = this.a * t + this.x0, e.y = this.a * n + this.y0, e;
}
function NV(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = e.x / this.a, n = e.y / this.a, s, r, i, a, o, l, f;
  if (this.sphere) {
    var d = 0, u, c = 0;
    if (u = Math.sqrt(t * t + n * n), r = u * 0.5, r > 1)
      return null;
    switch (r = 2 * Math.asin(r), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (c = Math.sin(r), d = Math.cos(r)), this.mode) {
      case this.EQUIT:
        r = Math.abs(u) <= Dt ? 0 : Math.asin(n * c / u), t *= c, n = d * u;
        break;
      case this.OBLIQ:
        r = Math.abs(u) <= Dt ? this.lat0 : Math.asin(d * this.sinph0 + n * c * this.cosph0 / u), t *= c * this.cosph0, n = (d - Math.sin(r) * this.sinph0) * u;
        break;
      case this.N_POLE:
        n = -n, r = xt - r;
        break;
      case this.S_POLE:
        r -= xt;
        break;
    }
    s = n === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(t, n);
  } else {
    if (f = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t /= this.dd, n *= this.dd, l = Math.sqrt(t * t + n * n), l < Dt)
        return e.x = this.long0, e.y = this.lat0, e;
      a = 2 * Math.asin(0.5 * l / this.rq), i = Math.cos(a), t *= a = Math.sin(a), this.mode === this.OBLIQ ? (f = i * this.sinb1 + n * a * this.cosb1 / l, o = this.qp * f, n = l * this.cosb1 * i - n * this.sinb1 * a) : (f = n * a / l, o = this.qp * f, n = l * i);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), o = t * t + n * n, !o)
        return e.x = this.long0, e.y = this.lat0, e;
      f = 1 - o / this.qp, this.mode === this.S_POLE && (f = -f);
    }
    s = Math.atan2(t, n), r = kV(Math.asin(f), this.apa);
  }
  return e.x = Bt(this.long0 + s), e.y = r, e;
}
var jV = 0.3333333333333333, $V = 0.17222222222222222, UV = 0.10257936507936508, WV = 0.06388888888888888, zV = 0.0664021164021164, KV = 0.016415012942191543;
function GV(e) {
  var t, n = [];
  return n[0] = e * jV, t = e * e, n[0] += t * $V, n[1] = t * WV, t *= e, n[0] += t * UV, n[1] += t * zV, n[2] = t * KV, n;
}
function kV(e, t) {
  var n = e + e;
  return e + t[0] * Math.sin(n) + t[1] * Math.sin(n + n) + t[2] * Math.sin(n + n + n);
}
var HV = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const YV = {
  init: BV,
  forward: FV,
  inverse: NV,
  names: HV,
  S_POLE: LV,
  N_POLE: RV,
  EQUIT: wV,
  OBLIQ: VV
};
function Ha(e) {
  return Math.abs(e) > 1 && (e = e > 1 ? 1 : -1), Math.asin(e);
}
function XV() {
  Math.abs(this.lat1 + this.lat2) < Dt || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ys(this.e3, this.sin_po, this.cos_po), this.qs1 = Na(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ys(this.e3, this.sin_po, this.cos_po), this.qs2 = Na(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Na(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Dt ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function ZV(e) {
  var t = e.x, n = e.y;
  this.sin_phi = Math.sin(n), this.cos_phi = Math.cos(n);
  var s = Na(this.e3, this.sin_phi), r = this.a * Math.sqrt(this.c - this.ns0 * s) / this.ns0, i = this.ns0 * Bt(t - this.long0), a = r * Math.sin(i) + this.x0, o = this.rh - r * Math.cos(i) + this.y0;
  return e.x = a, e.y = o, e;
}
function JV(e) {
  var t, n, s, r, i, a;
  return e.x -= this.x0, e.y = this.rh - e.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(e.x * e.x + e.y * e.y), s = 1) : (t = -Math.sqrt(e.x * e.x + e.y * e.y), s = -1), r = 0, t !== 0 && (r = Math.atan2(s * e.x, s * e.y)), s = t * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - s * s) / (2 * this.ns0)) : (n = (this.c - s * s) / this.ns0, a = this.phi1z(this.e3, n)), i = Bt(r / this.ns0 + this.long0), e.x = i, e.y = a, e;
}
function QV(e, t) {
  var n, s, r, i, a, o = Ha(0.5 * t);
  if (e < Dt)
    return o;
  for (var l = e * e, f = 1; f <= 25; f++)
    if (n = Math.sin(o), s = Math.cos(o), r = e * n, i = 1 - r * r, a = 0.5 * i * i / s * (t / (1 - l) - n / i + 0.5 / e * Math.log((1 - r) / (1 + r))), o = o + a, Math.abs(a) <= 1e-7)
      return o;
  return null;
}
var qV = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const tB = {
  init: XV,
  forward: ZV,
  inverse: JV,
  names: qV,
  phi1z: QV
};
function eB() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function nB(e) {
  var t, n, s, r, i, a, o, l, f = e.x, d = e.y;
  return s = Bt(f - this.long0), t = Math.sin(d), n = Math.cos(d), r = Math.cos(s), a = this.sin_p14 * t + this.cos_p14 * n * r, i = 1, a > 0 || Math.abs(a) <= Dt ? (o = this.x0 + this.a * i * n * Math.sin(s) / a, l = this.y0 + this.a * i * (this.cos_p14 * t - this.sin_p14 * n * r) / a) : (o = this.x0 + this.infinity_dist * n * Math.sin(s), l = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * n * r)), e.x = o, e.y = l, e;
}
function iB(e) {
  var t, n, s, r, i, a;
  return e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, (t = Math.sqrt(e.x * e.x + e.y * e.y)) ? (r = Math.atan2(t, this.rc), n = Math.sin(r), s = Math.cos(r), a = Ha(s * this.sin_p14 + e.y * n * this.cos_p14 / t), i = Math.atan2(e.x * n, t * this.cos_p14 * s - e.y * this.sin_p14 * n), i = Bt(this.long0 + i)) : (a = this.phic0, i = 0), e.x = i, e.y = a, e;
}
var rB = ["gnom"];
const sB = {
  init: eB,
  forward: nB,
  inverse: iB,
  names: rB
};
function aB(e, t) {
  var n = 1 - (1 - e * e) / (2 * e) * Math.log((1 - e) / (1 + e));
  if (Math.abs(Math.abs(t) - n) < 1e-6)
    return t < 0 ? -1 * xt : xt;
  for (var s = Math.asin(0.5 * t), r, i, a, o, l = 0; l < 30; l++)
    if (i = Math.sin(s), a = Math.cos(s), o = e * i, r = Math.pow(1 - o * o, 2) / (2 * a) * (t / (1 - e * e) - i / (1 - o * o) + 0.5 / e * Math.log((1 - o) / (1 + o))), s += r, Math.abs(r) <= 1e-10)
      return s;
  return NaN;
}
function oB() {
  this.sphere || (this.k0 = ys(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function lB(e) {
  var t = e.x, n = e.y, s, r, i = Bt(t - this.long0);
  if (this.sphere)
    s = this.x0 + this.a * i * Math.cos(this.lat_ts), r = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts);
  else {
    var a = Na(this.e, Math.sin(n));
    s = this.x0 + this.a * this.k0 * i, r = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return e.x = s, e.y = r, e;
}
function uB(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n;
  return this.sphere ? (t = Bt(this.long0 + e.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(e.y / this.a * Math.cos(this.lat_ts))) : (n = aB(this.e, 2 * e.y * this.k0 / this.a), t = Bt(this.long0 + e.x / (this.a * this.k0))), e.x = t, e.y = n, e;
}
var cB = ["cea"];
const hB = {
  init: oB,
  forward: lB,
  inverse: uB,
  names: cB
};
function dB() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function fB(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r = pu(n - this.lat0);
  return e.x = this.x0 + this.a * s * this.rc, e.y = this.y0 + this.a * r, e;
}
function pB(e) {
  var t = e.x, n = e.y;
  return e.x = Bt(this.long0 + (t - this.x0) / (this.a * this.rc)), e.y = pu(this.lat0 + (n - this.y0) / this.a), e;
}
var mB = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const gB = {
  init: dB,
  forward: fB,
  inverse: pB,
  names: mB
};
var jC = 20;
function vB() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = kc(this.es), this.e1 = Hc(this.es), this.e2 = Yc(this.es), this.e3 = Xc(this.es), this.ml0 = this.a * Mi(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function yB(e) {
  var t = e.x, n = e.y, s, r, i, a = Bt(t - this.long0);
  if (i = a * Math.sin(n), this.sphere)
    Math.abs(n) <= Dt ? (s = this.a * a, r = -1 * this.a * this.lat0) : (s = this.a * Math.sin(i) / Math.tan(n), r = this.a * (pu(n - this.lat0) + (1 - Math.cos(i)) / Math.tan(n)));
  else if (Math.abs(n) <= Dt)
    s = this.a * a, r = -1 * this.ml0;
  else {
    var o = ru(this.a, this.e, Math.sin(n)) / Math.tan(n);
    s = o * Math.sin(i), r = this.a * Mi(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + o * (1 - Math.cos(i));
  }
  return e.x = s + this.x0, e.y = r + this.y0, e;
}
function EB(e) {
  var t, n, s, r, i, a, o, l, f;
  if (s = e.x - this.x0, r = e.y - this.y0, this.sphere)
    if (Math.abs(r + this.a * this.lat0) <= Dt)
      t = Bt(s / this.a + this.long0), n = 0;
    else {
      a = this.lat0 + r / this.a, o = s * s / this.a / this.a + a * a, l = a;
      var d;
      for (i = jC; i; --i)
        if (d = Math.tan(l), f = -1 * (a * (l * d + 1) - l - 0.5 * (l * l + o) * d) / ((l - a) / d - 1), l += f, Math.abs(f) <= Dt) {
          n = l;
          break;
        }
      t = Bt(this.long0 + Math.asin(s * Math.tan(l) / this.a) / Math.sin(n));
    }
  else if (Math.abs(r + this.ml0) <= Dt)
    n = 0, t = Bt(this.long0 + s / this.a);
  else {
    a = (this.ml0 + r) / this.a, o = s * s / this.a / this.a + a * a, l = a;
    var u, c, h, p, g;
    for (i = jC; i; --i)
      if (g = this.e * Math.sin(l), u = Math.sqrt(1 - g * g) * Math.tan(l), c = this.a * Mi(this.e0, this.e1, this.e2, this.e3, l), h = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), p = c / this.a, f = (a * (u * p + 1) - p - 0.5 * u * (p * p + o)) / (this.es * Math.sin(2 * l) * (p * p + o - 2 * a * p) / (4 * u) + (a - p) * (u * h - 2 / Math.sin(2 * l)) - h), l -= f, Math.abs(f) <= Dt) {
        n = l;
        break;
      }
    u = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n), t = Bt(this.long0 + Math.asin(s * u / this.a) / Math.sin(n));
  }
  return e.x = t, e.y = n, e;
}
var CB = ["Polyconic", "poly"];
const xB = {
  init: vB,
  forward: yB,
  inverse: EB,
  names: CB
};
function bB() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function TB(e) {
  var t, n = e.x, s = e.y, r = s - this.lat0, i = n - this.long0, a = r / ic * 1e-5, o = i, l = 1, f = 0;
  for (t = 1; t <= 10; t++)
    l = l * a, f = f + this.A[t] * l;
  var d = f, u = o, c = 1, h = 0, p, g, m = 0, v = 0;
  for (t = 1; t <= 6; t++)
    p = c * d - h * u, g = h * d + c * u, c = p, h = g, m = m + this.B_re[t] * c - this.B_im[t] * h, v = v + this.B_im[t] * c + this.B_re[t] * h;
  return e.x = v * this.a + this.x0, e.y = m * this.a + this.y0, e;
}
function OB(e) {
  var t, n = e.x, s = e.y, r = n - this.x0, i = s - this.y0, a = i / this.a, o = r / this.a, l = 1, f = 0, d, u, c = 0, h = 0;
  for (t = 1; t <= 6; t++)
    d = l * a - f * o, u = f * a + l * o, l = d, f = u, c = c + this.C_re[t] * l - this.C_im[t] * f, h = h + this.C_im[t] * l + this.C_re[t] * f;
  for (var p = 0; p < this.iterations; p++) {
    var g = c, m = h, v, y, E = a, C = o;
    for (t = 2; t <= 6; t++)
      v = g * c - m * h, y = m * c + g * h, g = v, m = y, E = E + (t - 1) * (this.B_re[t] * g - this.B_im[t] * m), C = C + (t - 1) * (this.B_im[t] * g + this.B_re[t] * m);
    g = 1, m = 0;
    var x = this.B_re[1], b = this.B_im[1];
    for (t = 2; t <= 6; t++)
      v = g * c - m * h, y = m * c + g * h, g = v, m = y, x = x + t * (this.B_re[t] * g - this.B_im[t] * m), b = b + t * (this.B_im[t] * g + this.B_re[t] * m);
    var P = x * x + b * b;
    c = (E * x + C * b) / P, h = (C * x - E * b) / P;
  }
  var O = c, T = h, M = 1, L = 0;
  for (t = 1; t <= 9; t++)
    M = M * O, L = L + this.D[t] * M;
  var A = this.lat0 + L * ic * 1e5, D = this.long0 + T;
  return e.x = D, e.y = A, e;
}
var PB = ["New_Zealand_Map_Grid", "nzmg"];
const SB = {
  init: bB,
  forward: TB,
  inverse: OB,
  names: PB
};
function MB() {
}
function _B(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r = this.x0 + this.a * s, i = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
  return e.x = r, e.y = i, e;
}
function IB(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t = Bt(this.long0 + e.x / this.a), n = 2.5 * (Math.atan(Math.exp(0.8 * e.y / this.a)) - Math.PI / 4);
  return e.x = t, e.y = n, e;
}
var DB = ["Miller_Cylindrical", "mill"];
const AB = {
  init: MB,
  forward: _B,
  inverse: IB,
  names: DB
};
var LB = 20;
function RB() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = DP(this.es);
}
function wB(e) {
  var t, n, s = e.x, r = e.y;
  if (s = Bt(s - this.long0), this.sphere) {
    if (!this.m)
      r = this.n !== 1 ? Math.asin(this.n * Math.sin(r)) : r;
    else
      for (var i = this.n * Math.sin(r), a = LB; a; --a) {
        var o = (this.m * r + Math.sin(r) - i) / (this.m + Math.cos(r));
        if (r -= o, Math.abs(o) < Dt)
          break;
      }
    t = this.a * this.C_x * s * (this.m + Math.cos(r)), n = this.a * this.C_y * r;
  } else {
    var l = Math.sin(r), f = Math.cos(r);
    n = this.a * $f(r, l, f, this.en), t = this.a * s * f / Math.sqrt(1 - this.es * l * l);
  }
  return e.x = t, e.y = n, e;
}
function VB(e) {
  var t, n, s, r;
  return e.x -= this.x0, s = e.x / this.a, e.y -= this.y0, t = e.y / this.a, this.sphere ? (t /= this.C_y, s = s / (this.C_x * (this.m + Math.cos(t))), this.m ? t = Ha((this.m * t + Math.sin(t)) / this.n) : this.n !== 1 && (t = Ha(Math.sin(t) / this.n)), s = Bt(s + this.long0), t = pu(t)) : (t = AP(e.y / this.a, this.es, this.en), r = Math.abs(t), r < xt ? (r = Math.sin(t), n = this.long0 + e.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)), s = Bt(n)) : r - Dt < xt && (s = this.long0)), e.x = s, e.y = t, e;
}
var BB = ["Sinusoidal", "sinu"];
const FB = {
  init: RB,
  forward: wB,
  inverse: VB,
  names: BB
};
function NB() {
}
function jB(e) {
  for (var t = e.x, n = e.y, s = Bt(t - this.long0), r = n, i = Math.PI * Math.sin(n); ; ) {
    var a = -(r + Math.sin(r) - i) / (1 + Math.cos(r));
    if (r += a, Math.abs(a) < Dt)
      break;
  }
  r /= 2, Math.PI / 2 - Math.abs(n) < Dt && (s = 0);
  var o = 0.900316316158 * this.a * s * Math.cos(r) + this.x0, l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
  return e.x = o, e.y = l, e;
}
function $B(e) {
  var t, n;
  e.x -= this.x0, e.y -= this.y0, n = e.y / (1.4142135623731 * this.a), Math.abs(n) > 0.999999999999 && (n = 0.999999999999), t = Math.asin(n);
  var s = Bt(this.long0 + e.x / (0.900316316158 * this.a * Math.cos(t)));
  s < -Math.PI && (s = -Math.PI), s > Math.PI && (s = Math.PI), n = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(n) > 1 && (n = 1);
  var r = Math.asin(n);
  return e.x = s, e.y = r, e;
}
var UB = ["Mollweide", "moll"];
const WB = {
  init: NB,
  forward: jB,
  inverse: $B,
  names: UB
};
function zB() {
  Math.abs(this.lat1 + this.lat2) < Dt || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = kc(this.es), this.e1 = Hc(this.es), this.e2 = Yc(this.es), this.e3 = Xc(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ys(this.e, this.sinphi, this.cosphi), this.ml1 = Mi(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Dt ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ys(this.e, this.sinphi, this.cosphi), this.ml2 = Mi(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Mi(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function KB(e) {
  var t = e.x, n = e.y, s;
  if (this.sphere)
    s = this.a * (this.g - n);
  else {
    var r = Mi(this.e0, this.e1, this.e2, this.e3, n);
    s = this.a * (this.g - r);
  }
  var i = this.ns * Bt(t - this.long0), a = this.x0 + s * Math.sin(i), o = this.y0 + this.rh - s * Math.cos(i);
  return e.x = a, e.y = o, e;
}
function GB(e) {
  e.x -= this.x0, e.y = this.rh - e.y + this.y0;
  var t, n, s, r;
  this.ns >= 0 ? (n = Math.sqrt(e.x * e.x + e.y * e.y), t = 1) : (n = -Math.sqrt(e.x * e.x + e.y * e.y), t = -1);
  var i = 0;
  if (n !== 0 && (i = Math.atan2(t * e.x, t * e.y)), this.sphere)
    return r = Bt(this.long0 + i / this.ns), s = pu(this.g - n / this.a), e.x = r, e.y = s, e;
  var a = this.g - n / this.a;
  return s = Ud(a, this.e0, this.e1, this.e2, this.e3), r = Bt(this.long0 + i / this.ns), e.x = r, e.y = s, e;
}
var kB = ["Equidistant_Conic", "eqdc"];
const HB = {
  init: zB,
  forward: KB,
  inverse: GB,
  names: kB
};
function YB() {
  this.R = this.a;
}
function XB(e) {
  var t = e.x, n = e.y, s = Bt(t - this.long0), r, i;
  Math.abs(n) <= Dt && (r = this.x0 + this.R * s, i = this.y0);
  var a = Ha(2 * Math.abs(n / Math.PI));
  (Math.abs(s) <= Dt || Math.abs(Math.abs(n) - xt) <= Dt) && (r = this.x0, n >= 0 ? i = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : i = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / s - s / Math.PI), l = o * o, f = Math.sin(a), d = Math.cos(a), u = d / (f + d - 1), c = u * u, h = u * (2 / f - 1), p = h * h, g = Math.PI * this.R * (o * (u - p) + Math.sqrt(l * (u - p) * (u - p) - (p + l) * (c - p))) / (p + l);
  s < 0 && (g = -g), r = this.x0 + g;
  var m = l + u;
  return g = Math.PI * this.R * (h * m - o * Math.sqrt((p + l) * (l + 1) - m * m)) / (p + l), n >= 0 ? i = this.y0 + g : i = this.y0 - g, e.x = r, e.y = i, e;
}
function ZB(e) {
  var t, n, s, r, i, a, o, l, f, d, u, c, h;
  return e.x -= this.x0, e.y -= this.y0, u = Math.PI * this.R, s = e.x / u, r = e.y / u, i = s * s + r * r, a = -Math.abs(r) * (1 + i), o = a - 2 * r * r + s * s, l = -2 * a + 1 + 2 * r * r + i * i, h = r * r / l + (2 * o * o * o / l / l / l - 9 * a * o / l / l) / 27, f = (a - o * o / 3 / l) / l, d = 2 * Math.sqrt(-f / 3), u = 3 * h / f / d, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), c = Math.acos(u) / 3, e.y >= 0 ? n = (-d * Math.cos(c + Math.PI / 3) - o / 3 / l) * Math.PI : n = -(-d * Math.cos(c + Math.PI / 3) - o / 3 / l) * Math.PI, Math.abs(s) < Dt ? t = this.long0 : t = Bt(this.long0 + Math.PI * (i - 1 + Math.sqrt(1 + 2 * (s * s - r * r) + i * i)) / 2 / s), e.x = t, e.y = n, e;
}
var JB = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const QB = {
  init: YB,
  forward: XB,
  inverse: ZB,
  names: JB
};
function qB() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function tF(e) {
  var t = e.x, n = e.y, s = Math.sin(e.y), r = Math.cos(e.y), i = Bt(t - this.long0), a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P, O, T, M, L, A;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Dt ? (e.x = this.x0 + this.a * (xt - n) * Math.sin(i), e.y = this.y0 - this.a * (xt - n) * Math.cos(i), e) : Math.abs(this.sin_p12 + 1) <= Dt ? (e.x = this.x0 + this.a * (xt + n) * Math.sin(i), e.y = this.y0 + this.a * (xt + n) * Math.cos(i), e) : (P = this.sin_p12 * s + this.cos_p12 * r * Math.cos(i), x = Math.acos(P), b = x ? x / Math.sin(x) : 1, e.x = this.x0 + this.a * b * r * Math.sin(i), e.y = this.y0 + this.a * b * (this.cos_p12 * s - this.sin_p12 * r * Math.cos(i)), e) : (a = kc(this.es), o = Hc(this.es), l = Yc(this.es), f = Xc(this.es), Math.abs(this.sin_p12 - 1) <= Dt ? (d = this.a * Mi(a, o, l, f, xt), u = this.a * Mi(a, o, l, f, n), e.x = this.x0 + (d - u) * Math.sin(i), e.y = this.y0 - (d - u) * Math.cos(i), e) : Math.abs(this.sin_p12 + 1) <= Dt ? (d = this.a * Mi(a, o, l, f, xt), u = this.a * Mi(a, o, l, f, n), e.x = this.x0 + (d + u) * Math.sin(i), e.y = this.y0 + (d + u) * Math.cos(i), e) : (c = s / r, h = ru(this.a, this.e, this.sin_p12), p = ru(this.a, this.e, s), g = Math.atan((1 - this.es) * c + this.es * h * this.sin_p12 / (p * r)), m = Math.atan2(Math.sin(i), this.cos_p12 * Math.tan(g) - this.sin_p12 * Math.cos(i)), m === 0 ? O = Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : Math.abs(Math.abs(m) - Math.PI) <= Dt ? O = -Math.asin(this.cos_p12 * Math.sin(g) - this.sin_p12 * Math.cos(g)) : O = Math.asin(Math.sin(i) * Math.cos(g) / Math.sin(m)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = this.e * this.cos_p12 * Math.cos(m) / Math.sqrt(1 - this.es), E = v * y, C = y * y, T = O * O, M = T * O, L = M * O, A = L * O, x = h * O * (1 - T * C * (1 - C) / 6 + M / 8 * E * (1 - 2 * C) + L / 120 * (C * (4 - 7 * C) - 3 * v * v * (1 - 7 * C)) - A / 48 * E), e.x = this.x0 + x * Math.sin(m), e.y = this.y0 + x * Math.cos(m), e));
}
function eF(e) {
  e.x -= this.x0, e.y -= this.y0;
  var t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P, O;
  return this.sphere ? (t = Math.sqrt(e.x * e.x + e.y * e.y), t > 2 * xt * this.a ? void 0 : (n = t / this.a, s = Math.sin(n), r = Math.cos(n), i = this.long0, Math.abs(t) <= Dt ? a = this.lat0 : (a = Ha(r * this.sin_p12 + e.y * s * this.cos_p12 / t), o = Math.abs(this.lat0) - xt, Math.abs(o) <= Dt ? this.lat0 >= 0 ? i = Bt(this.long0 + Math.atan2(e.x, -e.y)) : i = Bt(this.long0 - Math.atan2(-e.x, e.y)) : i = Bt(this.long0 + Math.atan2(e.x * s, t * this.cos_p12 * r - e.y * this.sin_p12 * s))), e.x = i, e.y = a, e)) : (l = kc(this.es), f = Hc(this.es), d = Yc(this.es), u = Xc(this.es), Math.abs(this.sin_p12 - 1) <= Dt ? (c = this.a * Mi(l, f, d, u, xt), t = Math.sqrt(e.x * e.x + e.y * e.y), h = c - t, a = Ud(h / this.a, l, f, d, u), i = Bt(this.long0 + Math.atan2(e.x, -1 * e.y)), e.x = i, e.y = a, e) : Math.abs(this.sin_p12 + 1) <= Dt ? (c = this.a * Mi(l, f, d, u, xt), t = Math.sqrt(e.x * e.x + e.y * e.y), h = t - c, a = Ud(h / this.a, l, f, d, u), i = Bt(this.long0 + Math.atan2(e.x, e.y)), e.x = i, e.y = a, e) : (t = Math.sqrt(e.x * e.x + e.y * e.y), m = Math.atan2(e.x, e.y), p = ru(this.a, this.e, this.sin_p12), v = Math.cos(m), y = this.e * this.cos_p12 * v, E = -y * y / (1 - this.es), C = 3 * this.es * (1 - E) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), x = t / p, b = x - E * (1 + E) * Math.pow(x, 3) / 6 - C * (1 + 3 * E) * Math.pow(x, 4) / 24, P = 1 - E * b * b / 2 - x * b * b * b / 6, g = Math.asin(this.sin_p12 * Math.cos(b) + this.cos_p12 * Math.sin(b) * v), i = Bt(this.long0 + Math.asin(Math.sin(m) * Math.sin(b) / Math.cos(g))), O = Math.sin(g), a = Math.atan2((O - this.es * P * this.sin_p12) * Math.tan(g), O * (1 - this.es)), e.x = i, e.y = a, e));
}
var nF = ["Azimuthal_Equidistant", "aeqd"];
const iF = {
  init: qB,
  forward: tF,
  inverse: eF,
  names: nF
};
function rF() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function sF(e) {
  var t, n, s, r, i, a, o, l, f = e.x, d = e.y;
  return s = Bt(f - this.long0), t = Math.sin(d), n = Math.cos(d), r = Math.cos(s), a = this.sin_p14 * t + this.cos_p14 * n * r, i = 1, (a > 0 || Math.abs(a) <= Dt) && (o = this.a * i * n * Math.sin(s), l = this.y0 + this.a * i * (this.cos_p14 * t - this.sin_p14 * n * r)), e.x = o, e.y = l, e;
}
function aF(e) {
  var t, n, s, r, i, a, o;
  return e.x -= this.x0, e.y -= this.y0, t = Math.sqrt(e.x * e.x + e.y * e.y), n = Ha(t / this.a), s = Math.sin(n), r = Math.cos(n), a = this.long0, Math.abs(t) <= Dt ? (o = this.lat0, e.x = a, e.y = o, e) : (o = Ha(r * this.sin_p14 + e.y * s * this.cos_p14 / t), i = Math.abs(this.lat0) - xt, Math.abs(i) <= Dt ? (this.lat0 >= 0 ? a = Bt(this.long0 + Math.atan2(e.x, -e.y)) : a = Bt(this.long0 - Math.atan2(-e.x, e.y)), e.x = a, e.y = o, e) : (a = Bt(this.long0 + Math.atan2(e.x * s, t * this.cos_p14 * r - e.y * this.sin_p14 * s)), e.x = a, e.y = o, e));
}
var oF = ["ortho"];
const lF = {
  init: rF,
  forward: sF,
  inverse: aF,
  names: oF
};
var cn = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, Ae = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function uF() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= xt - De / 2 ? this.face = cn.TOP : this.lat0 <= -(xt - De / 2) ? this.face = cn.BOTTOM : Math.abs(this.long0) <= De ? this.face = cn.FRONT : Math.abs(this.long0) <= xt + De ? this.face = this.long0 > 0 ? cn.RIGHT : cn.LEFT : this.face = cn.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function cF(e) {
  var t = { x: 0, y: 0 }, n, s, r, i, a, o, l = { value: 0 };
  if (e.x -= this.long0, this.es !== 0 ? n = Math.atan(this.one_minus_f_squared * Math.tan(e.y)) : n = e.y, s = e.x, this.face === cn.TOP)
    i = xt - n, s >= De && s <= xt + De ? (l.value = Ae.AREA_0, r = s - xt) : s > xt + De || s <= -(xt + De) ? (l.value = Ae.AREA_1, r = s > 0 ? s - Sn : s + Sn) : s > -(xt + De) && s <= -De ? (l.value = Ae.AREA_2, r = s + xt) : (l.value = Ae.AREA_3, r = s);
  else if (this.face === cn.BOTTOM)
    i = xt + n, s >= De && s <= xt + De ? (l.value = Ae.AREA_0, r = -s + xt) : s < De && s >= -De ? (l.value = Ae.AREA_1, r = -s) : s < -De && s >= -(xt + De) ? (l.value = Ae.AREA_2, r = -s - xt) : (l.value = Ae.AREA_3, r = s > 0 ? -s + Sn : -s - Sn);
  else {
    var f, d, u, c, h, p, g;
    this.face === cn.RIGHT ? s = zl(s, +xt) : this.face === cn.BACK ? s = zl(s, +Sn) : this.face === cn.LEFT && (s = zl(s, -xt)), c = Math.sin(n), h = Math.cos(n), p = Math.sin(s), g = Math.cos(s), f = h * g, d = h * p, u = c, this.face === cn.FRONT ? (i = Math.acos(f), r = Oh(i, u, d, l)) : this.face === cn.RIGHT ? (i = Math.acos(d), r = Oh(i, u, -f, l)) : this.face === cn.BACK ? (i = Math.acos(-f), r = Oh(i, u, -d, l)) : this.face === cn.LEFT ? (i = Math.acos(-d), r = Oh(i, u, f, l)) : (i = r = 0, l.value = Ae.AREA_0);
  }
  return o = Math.atan(12 / Sn * (r + Math.acos(Math.sin(r) * Math.cos(De)) - xt)), a = Math.sqrt((1 - Math.cos(i)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === Ae.AREA_1 ? o += xt : l.value === Ae.AREA_2 ? o += Sn : l.value === Ae.AREA_3 && (o += 1.5 * Sn), t.x = a * Math.cos(o), t.y = a * Math.sin(o), t.x = t.x * this.a + this.x0, t.y = t.y * this.a + this.y0, e.x = t.x, e.y = t.y, e;
}
function hF(e) {
  var t = { lam: 0, phi: 0 }, n, s, r, i, a, o, l, f, d, u = { value: 0 };
  if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, s = Math.atan(Math.sqrt(e.x * e.x + e.y * e.y)), n = Math.atan2(e.y, e.x), e.x >= 0 && e.x >= Math.abs(e.y) ? u.value = Ae.AREA_0 : e.y >= 0 && e.y >= Math.abs(e.x) ? (u.value = Ae.AREA_1, n -= xt) : e.x < 0 && -e.x >= Math.abs(e.y) ? (u.value = Ae.AREA_2, n = n < 0 ? n + Sn : n - Sn) : (u.value = Ae.AREA_3, n += xt), d = Sn / 12 * Math.tan(n), a = Math.sin(d) / (Math.cos(d) - 1 / Math.sqrt(2)), o = Math.atan(a), r = Math.cos(n), i = Math.tan(s), l = 1 - r * r * i * i * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), l < -1 ? l = -1 : l > 1 && (l = 1), this.face === cn.TOP)
    f = Math.acos(l), t.phi = xt - f, u.value === Ae.AREA_0 ? t.lam = o + xt : u.value === Ae.AREA_1 ? t.lam = o < 0 ? o + Sn : o - Sn : u.value === Ae.AREA_2 ? t.lam = o - xt : t.lam = o;
  else if (this.face === cn.BOTTOM)
    f = Math.acos(l), t.phi = f - xt, u.value === Ae.AREA_0 ? t.lam = -o + xt : u.value === Ae.AREA_1 ? t.lam = -o : u.value === Ae.AREA_2 ? t.lam = -o - xt : t.lam = o < 0 ? -o - Sn : -o + Sn;
  else {
    var c, h, p;
    c = l, d = c * c, d >= 1 ? p = 0 : p = Math.sqrt(1 - d) * Math.sin(o), d += p * p, d >= 1 ? h = 0 : h = Math.sqrt(1 - d), u.value === Ae.AREA_1 ? (d = h, h = -p, p = d) : u.value === Ae.AREA_2 ? (h = -h, p = -p) : u.value === Ae.AREA_3 && (d = h, h = p, p = -d), this.face === cn.RIGHT ? (d = c, c = -h, h = d) : this.face === cn.BACK ? (c = -c, h = -h) : this.face === cn.LEFT && (d = c, c = h, h = -d), t.phi = Math.acos(-p) - xt, t.lam = Math.atan2(h, c), this.face === cn.RIGHT ? t.lam = zl(t.lam, -xt) : this.face === cn.BACK ? t.lam = zl(t.lam, -Sn) : this.face === cn.LEFT && (t.lam = zl(t.lam, +xt));
  }
  if (this.es !== 0) {
    var g, m, v;
    g = t.phi < 0 ? 1 : 0, m = Math.tan(t.phi), v = this.b / Math.sqrt(m * m + this.one_minus_f_squared), t.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), g && (t.phi = -t.phi);
  }
  return t.lam += this.long0, e.x = t.lam, e.y = t.phi, e;
}
function Oh(e, t, n, s) {
  var r;
  return e < Dt ? (s.value = Ae.AREA_0, r = 0) : (r = Math.atan2(t, n), Math.abs(r) <= De ? s.value = Ae.AREA_0 : r > De && r <= xt + De ? (s.value = Ae.AREA_1, r -= xt) : r > xt + De || r <= -(xt + De) ? (s.value = Ae.AREA_2, r = r >= 0 ? r - Sn : r + Sn) : (s.value = Ae.AREA_3, r += xt)), r;
}
function zl(e, t) {
  var n = e + t;
  return n < -Sn ? n += yc : n > +Sn && (n -= yc), n;
}
var dF = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const fF = {
  init: uF,
  forward: cF,
  inverse: hF,
  names: dF
};
var tv = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], Qu = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], wP = 0.8487, VP = 1.3523, BP = cs / 5, pF = 1 / BP, Dl = 18, Wd = function(e, t) {
  return e[0] + t * (e[1] + t * (e[2] + t * e[3]));
}, mF = function(e, t) {
  return e[1] + t * (2 * e[2] + t * 3 * e[3]);
};
function gF(e, t, n, s) {
  for (var r = t; s; --s) {
    var i = e(r);
    if (r -= i, Math.abs(i) < n)
      break;
  }
  return r;
}
function vF() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function yF(e) {
  var t = Bt(e.x - this.long0), n = Math.abs(e.y), s = Math.floor(n * BP);
  s < 0 ? s = 0 : s >= Dl && (s = Dl - 1), n = cs * (n - pF * s);
  var r = {
    x: Wd(tv[s], n) * t,
    y: Wd(Qu[s], n)
  };
  return e.y < 0 && (r.y = -r.y), r.x = r.x * this.a * wP + this.x0, r.y = r.y * this.a * VP + this.y0, r;
}
function EF(e) {
  var t = {
    x: (e.x - this.x0) / (this.a * wP),
    y: Math.abs(e.y - this.y0) / (this.a * VP)
  };
  if (t.y >= 1)
    t.x /= tv[Dl][0], t.y = e.y < 0 ? -xt : xt;
  else {
    var n = Math.floor(t.y * Dl);
    for (n < 0 ? n = 0 : n >= Dl && (n = Dl - 1); ; )
      if (Qu[n][0] > t.y)
        --n;
      else if (Qu[n + 1][0] <= t.y)
        ++n;
      else
        break;
    var s = Qu[n], r = 5 * (t.y - s[0]) / (Qu[n + 1][0] - s[0]);
    r = gF(function(i) {
      return (Wd(s, i) - t.y) / mF(s, i);
    }, r, Dt, 100), t.x /= Wd(tv[n], r), t.y = (5 * n + r) * Qn, e.y < 0 && (t.y = -t.y);
  }
  return t.x = Bt(t.x + this.long0), t;
}
var CF = ["Robinson", "robin"];
const xF = {
  init: vF,
  forward: yF,
  inverse: EF,
  names: CF
};
function bF() {
  this.name = "geocent";
}
function TF(e) {
  var t = xP(e, this.es, this.a);
  return t;
}
function OF(e) {
  var t = bP(e, this.es, this.a, this.b);
  return t;
}
var PF = ["Geocentric", "geocentric", "geocent", "Geocent"];
const SF = {
  init: bF,
  forward: TF,
  inverse: OF,
  names: PF
};
var ui = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Nu = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function MF() {
  if (Object.keys(Nu).forEach((function(n) {
    if (typeof this[n] > "u")
      this[n] = Nu[n].def;
    else {
      if (Nu[n].num && isNaN(this[n]))
        throw new Error("Invalid parameter value, must be numeric " + n + " = " + this[n]);
      Nu[n].num && (this[n] = parseFloat(this[n]));
    }
    Nu[n].degrees && (this[n] = this[n] * Qn);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - xt) < Dt ? this.mode = this.lat0 < 0 ? ui.S_POLE : ui.N_POLE : Math.abs(this.lat0) < Dt ? this.mode = ui.EQUIT : (this.mode = ui.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var e = this.tilt, t = this.azi;
  this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(e), this.sw = Math.sin(e);
}
function _F(e) {
  e.x -= this.long0;
  var t = Math.sin(e.y), n = Math.cos(e.y), s = Math.cos(e.x), r, i;
  switch (this.mode) {
    case ui.OBLIQ:
      i = this.sinph0 * t + this.cosph0 * n * s;
      break;
    case ui.EQUIT:
      i = n * s;
      break;
    case ui.S_POLE:
      i = -t;
      break;
    case ui.N_POLE:
      i = t;
      break;
  }
  switch (i = this.pn1 / (this.p - i), r = i * n * Math.sin(e.x), this.mode) {
    case ui.OBLIQ:
      i *= this.cosph0 * t - this.sinph0 * n * s;
      break;
    case ui.EQUIT:
      i *= t;
      break;
    case ui.N_POLE:
      i *= -(n * s);
      break;
    case ui.S_POLE:
      i *= n * s;
      break;
  }
  var a, o;
  return a = i * this.cg + r * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), r = (r * this.cg - i * this.sg) * this.cw * o, i = a * o, e.x = r * this.a, e.y = i * this.a, e;
}
function IF(e) {
  e.x /= this.a, e.y /= this.a;
  var t = { x: e.x, y: e.y }, n, s, r;
  r = 1 / (this.pn1 - e.y * this.sw), n = this.pn1 * e.x * r, s = this.pn1 * e.y * this.cw * r, e.x = n * this.cg + s * this.sg, e.y = s * this.cg - n * this.sg;
  var i = Lr(e.x, e.y);
  if (Math.abs(i) < Dt)
    t.x = 0, t.y = e.y;
  else {
    var a, o;
    switch (o = 1 - i * i * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / i + i / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case ui.OBLIQ:
        t.y = Math.asin(a * this.sinph0 + e.y * o * this.cosph0 / i), e.y = (a - this.sinph0 * Math.sin(t.y)) * i, e.x *= o * this.cosph0;
        break;
      case ui.EQUIT:
        t.y = Math.asin(e.y * o / i), e.y = a * i, e.x *= o;
        break;
      case ui.N_POLE:
        t.y = Math.asin(a), e.y = -e.y;
        break;
      case ui.S_POLE:
        t.y = -Math.asin(a);
        break;
    }
    t.x = Math.atan2(e.x, e.y);
  }
  return e.x = t.x + this.long0, e.y = t.y, e;
}
var DF = ["Tilted_Perspective", "tpers"];
const AF = {
  init: MF,
  forward: _F,
  inverse: IF,
  names: DF
};
function LF() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var e = 1 - this.es, t = 1 / e;
    this.radius_p = Math.sqrt(e), this.radius_p2 = e, this.radius_p_inv2 = t, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function RF(e) {
  var t = e.x, n = e.y, s, r, i, a;
  if (t = t - this.long0, this.shape === "ellipse") {
    n = Math.atan(this.radius_p2 * Math.tan(n));
    var o = this.radius_p / Lr(this.radius_p * Math.cos(n), Math.sin(n));
    if (r = o * Math.cos(t) * Math.cos(n), i = o * Math.sin(t) * Math.cos(n), a = o * Math.sin(n), (this.radius_g - r) * r - i * i - a * a * this.radius_p_inv2 < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    s = this.radius_g - r, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(i / Lr(a, s)), e.y = this.radius_g_1 * Math.atan(a / s)) : (e.x = this.radius_g_1 * Math.atan(i / s), e.y = this.radius_g_1 * Math.atan(a / Lr(i, s)));
  } else
    this.shape === "sphere" && (s = Math.cos(n), r = Math.cos(t) * s, i = Math.sin(t) * s, a = Math.sin(n), s = this.radius_g - r, this.flip_axis ? (e.x = this.radius_g_1 * Math.atan(i / Lr(a, s)), e.y = this.radius_g_1 * Math.atan(a / s)) : (e.x = this.radius_g_1 * Math.atan(i / s), e.y = this.radius_g_1 * Math.atan(a / Lr(i, s))));
  return e.x = e.x * this.a, e.y = e.y * this.a, e;
}
function wF(e) {
  var t = -1, n = 0, s = 0, r, i, a, o;
  if (e.x = e.x / this.a, e.y = e.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (s = Math.tan(e.y / this.radius_g_1), n = Math.tan(e.x / this.radius_g_1) * Lr(1, s)) : (n = Math.tan(e.x / this.radius_g_1), s = Math.tan(e.y / this.radius_g_1) * Lr(1, n));
    var l = s / this.radius_p;
    if (r = n * n + l * l + t * t, i = 2 * this.radius_g * t, a = i * i - 4 * r * this.C, a < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    o = (-i - Math.sqrt(a)) / (2 * r), t = this.radius_g + o * t, n *= o, s *= o, e.x = Math.atan2(n, t), e.y = Math.atan(s * Math.cos(e.x) / t), e.y = Math.atan(this.radius_p_inv2 * Math.tan(e.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (s = Math.tan(e.y / this.radius_g_1), n = Math.tan(e.x / this.radius_g_1) * Math.sqrt(1 + s * s)) : (n = Math.tan(e.x / this.radius_g_1), s = Math.tan(e.y / this.radius_g_1) * Math.sqrt(1 + n * n)), r = n * n + s * s + t * t, i = 2 * this.radius_g * t, a = i * i - 4 * r * this.C, a < 0)
      return e.x = Number.NaN, e.y = Number.NaN, e;
    o = (-i - Math.sqrt(a)) / (2 * r), t = this.radius_g + o * t, n *= o, s *= o, e.x = Math.atan2(n, t), e.y = Math.atan(s * Math.cos(e.x) / t);
  }
  return e.x = e.x + this.long0, e;
}
var VF = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const BF = {
  init: LF,
  forward: RF,
  inverse: wF,
  names: VF
};
function FF(e) {
  e.Proj.projections.add(hd), e.Proj.projections.add(dd), e.Proj.projections.add(z2), e.Proj.projections.add(q2), e.Proj.projections.add(sV), e.Proj.projections.add(cV), e.Proj.projections.add(gV), e.Proj.projections.add(xV), e.Proj.projections.add(SV), e.Proj.projections.add(AV), e.Proj.projections.add(YV), e.Proj.projections.add(tB), e.Proj.projections.add(sB), e.Proj.projections.add(hB), e.Proj.projections.add(gB), e.Proj.projections.add(xB), e.Proj.projections.add(SB), e.Proj.projections.add(AB), e.Proj.projections.add(FB), e.Proj.projections.add(WB), e.Proj.projections.add(HB), e.Proj.projections.add(QB), e.Proj.projections.add(iF), e.Proj.projections.add(lF), e.Proj.projections.add(fF), e.Proj.projections.add(xF), e.Proj.projections.add(SF), e.Proj.projections.add(AF), e.Proj.projections.add(BF);
}
fn.defaultDatum = "WGS84";
fn.Proj = fs;
fn.WGS84 = new fn.Proj("WGS84");
fn.Point = iu;
fn.toPoint = TP;
fn.defs = Oi;
fn.nadgrid = Gw;
fn.transform = $d;
fn.mgrs = o2;
fn.version = "__VERSION__";
FF(fn);
function FP(e) {
  const t = Object.keys(e.defs), n = t.length;
  let s, r;
  for (s = 0; s < n; ++s) {
    const i = t[s];
    if (!Wt(i)) {
      const a = e.defs(i);
      let o = a.units;
      !o && a.projName === "longlat" && (o = "degrees"), cy(
        new Af({
          code: i,
          axisOrientation: a.axis,
          metersPerUnit: a.to_meter,
          units: o
        })
      );
    }
  }
  for (s = 0; s < n; ++s) {
    const i = t[s], a = Wt(i);
    for (r = 0; r < n; ++r) {
      const o = t[r], l = Wt(o);
      if (!s1(i, o))
        if (e.defs[i] === e.defs[o])
          Bg([a, l]);
        else {
          const f = e(i, o);
          FD(
            a,
            l,
            kE(a, l, f.forward),
            kE(l, a, f.inverse)
          );
        }
    }
  }
}
function NF(e) {
  const t = e.split(":")[1];
  fn.defs("http://www.opengis.net/gml/srs/epsg.xml#" + t, fn.defs(e)), FP(fn);
}
function qy(e) {
  return fn.defs(e);
}
function NP(e = fi.namedProjections) {
  fn.defs(e), FP(fn), e.forEach((t) => {
    cy(Wt(t[0])), NF(t[0]), qy(t[0]).masterportal = !0;
  });
}
function jF() {
  return Object.keys(fn.defs).map((t) => Object.assign(fn.defs(t), { name: t })).filter(function(t, n, s) {
    return n === s.indexOf(t) && t.masterportal === !0;
  });
}
function t0(e) {
  return e.getView().getProjection().getCode();
}
function $C(e) {
  return typeof e == "string" ? qy(e) : e;
}
function e0(e, t, n) {
  const s = $C(e), r = $C(t);
  if (s && r && n)
    return fn(s, r, n);
  console.error(`Cancelled coordinate transformation with invalid parameters: ${e}; ${t}; ${n}`);
}
function $F(e, t, n) {
  return e0(t, t0(e), n);
}
function UF(e, t, n) {
  return e0(t0(e), t, n);
}
const WF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getMapProjection: t0,
  getProjection: qy,
  getProjections: jF,
  registerProjections: NP,
  transform: e0,
  transformFromMapProjection: UF,
  transformToMapProjection: $F
}, Symbol.toStringTag, { value: "Module" }));
let Al = [];
function jP(e = fi.layerConf, t) {
  if (Array.isArray(e)) {
    if (Al = e, typeof t == "function") {
      t(Al);
      return;
    }
    return;
  }
  const n = new XMLHttpRequest();
  n.open("GET", e), n.timeout = 1e4, n.send(), n.onload = function() {
    try {
      Al = JSON.parse(n.responseText);
    } catch (s) {
      return console.error("An error occured when parsing the response after loading '" + e + "':", s), t(!1, s);
    }
    return typeof t == "function" ? t(Al) : !0;
  }, n.onerror = function(s) {
    console.error("An error occured when trying to fetch services from '" + e + "':", s), t(!1, s);
  };
}
function ea(e) {
  const t = Object.keys(e);
  return Al.find((n) => t.every((s) => n[s] === e[s])) || null;
}
function zF() {
  return Al;
}
function KF(e, t) {
  const n = ea({ id: e });
  if (n && typeof t == "string") {
    const s = n.gfiAttributes && n.gfiAttributes[t];
    return typeof s == "string" ? s : null;
  } else if (n)
    return n.gfiAttributes || null;
  return null;
}
const GF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDisplayNamesOfFeatureAttributes: KF,
  getLayerList: zF,
  getLayerWhere: ea,
  initializeLayerList: jP
}, Symbol.toStringTag, { value: "Module" })), Aa = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class kF extends hu {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    t = t || {};
    const n = Object.assign({}, t);
    delete n.preload, delete n.useInterimTilesOnError, super(n), this.on, this.once, this.un, this.setPreload(t.preload !== void 0 ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Aa.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set(Aa.PRELOAD, t);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Aa.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set(Aa.USE_INTERIM_TILES_ON_ERROR, t);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(t) {
    return super.getData(t);
  }
}
const HF = kF, $P = 0.5, YF = 10, UC = 0.25;
class XF {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(t, n, s, r, i, a) {
    this.sourceProj_ = t, this.targetProj_ = n;
    let o = {};
    const l = Ka(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(y) {
      const E = y[0] + "/" + y[1];
      return o[E] || (o[E] = l(y)), o[E];
    }, this.maxSourceExtent_ = r, this.errorThresholdSquared_ = i * i, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && Ee(r) == Ee(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Ee(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? Ee(this.targetProj_.getExtent()) : null;
    const f = gs(s), d = Mo(s), u = Ql(s), c = So(s), h = this.transformInv_(f), p = this.transformInv_(d), g = this.transformInv_(u), m = this.transformInv_(c), v = YF + (a ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          Lg(s) / (a * a * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      f,
      d,
      u,
      c,
      h,
      p,
      g,
      m,
      v
    ), this.wrapsXInSource_) {
      let y = 1 / 0;
      this.triangles_.forEach(function(E, C, x) {
        y = Math.min(
          y,
          E.source[0][0],
          E.source[1][0],
          E.source[2][0]
        );
      }), this.triangles_.forEach(
        (function(E) {
          if (Math.max(
            E.source[0][0],
            E.source[1][0],
            E.source[2][0]
          ) - y > this.sourceWorldWidth_ / 2) {
            const C = [
              [E.source[0][0], E.source[0][1]],
              [E.source[1][0], E.source[1][1]],
              [E.source[2][0], E.source[2][1]]
            ];
            C[0][0] - y > this.sourceWorldWidth_ / 2 && (C[0][0] -= this.sourceWorldWidth_), C[1][0] - y > this.sourceWorldWidth_ / 2 && (C[1][0] -= this.sourceWorldWidth_), C[2][0] - y > this.sourceWorldWidth_ / 2 && (C[2][0] -= this.sourceWorldWidth_);
            const x = Math.min(
              C[0][0],
              C[1][0],
              C[2][0]
            );
            Math.max(
              C[0][0],
              C[1][0],
              C[2][0]
            ) - x < this.sourceWorldWidth_ / 2 && (E.source = C);
          }
        }).bind(this)
      );
    }
    o = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(t, n, s, r, i, a) {
    this.triangles_.push({
      source: [r, i, a],
      target: [t, n, s]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(t, n, s, r, i, a, o, l, f) {
    const d = Jl([i, a, o, l]), u = this.sourceWorldWidth_ ? Ee(d) / this.sourceWorldWidth_ : null, c = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), h = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
    let p = !1;
    if (f > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = Jl([t, n, s, r]);
        p = Ee(m) / this.targetWorldWidth_ > UC || p;
      }
      !h && this.sourceProj_.isGlobal() && u && (p = u > UC || p);
    }
    if (!p && this.maxSourceExtent_ && isFinite(d[0]) && isFinite(d[1]) && isFinite(d[2]) && isFinite(d[3]) && !hn(d, this.maxSourceExtent_))
      return;
    let g = 0;
    if (!p && (!isFinite(i[0]) || !isFinite(i[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (f > 0)
        p = !0;
      else if (g = (!isFinite(i[0]) || !isFinite(i[1]) ? 8 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 4 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), g != 1 && g != 2 && g != 4 && g != 8)
        return;
    }
    if (f > 0) {
      if (!p) {
        const m = [(t[0] + s[0]) / 2, (t[1] + s[1]) / 2], v = this.transformInv_(m);
        let y;
        h ? y = (Va(i[0], c) + Va(o[0], c)) / 2 - Va(v[0], c) : y = (i[0] + o[0]) / 2 - v[0];
        const E = (i[1] + o[1]) / 2 - v[1];
        p = y * y + E * E > this.errorThresholdSquared_;
      }
      if (p) {
        if (Math.abs(t[0] - s[0]) <= Math.abs(t[1] - s[1])) {
          const m = [(n[0] + s[0]) / 2, (n[1] + s[1]) / 2], v = this.transformInv_(m), y = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2], E = this.transformInv_(y);
          this.addQuad_(
            t,
            n,
            m,
            y,
            i,
            a,
            v,
            E,
            f - 1
          ), this.addQuad_(
            y,
            m,
            s,
            r,
            E,
            v,
            o,
            l,
            f - 1
          );
        } else {
          const m = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], v = this.transformInv_(m), y = [(s[0] + r[0]) / 2, (s[1] + r[1]) / 2], E = this.transformInv_(y);
          this.addQuad_(
            t,
            m,
            y,
            r,
            i,
            v,
            E,
            l,
            f - 1
          ), this.addQuad_(
            m,
            n,
            s,
            y,
            v,
            a,
            o,
            E,
            f - 1
          );
        }
        return;
      }
    }
    if (h) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    g & 11 || this.addTriangle_(t, s, r, i, o, l), g & 14 || this.addTriangle_(t, s, n, i, o, a), g && (g & 13 || this.addTriangle_(n, r, t, a, l, i), g & 7 || this.addTriangle_(n, r, s, a, l, o));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const t = ji();
    return this.triangles_.forEach(function(n, s, r) {
      const i = n.source;
      ec(t, i[0]), ec(t, i[1]), ec(t, i[2]);
    }), t;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const UP = XF;
let Ip;
const WP = [];
function WC(e, t, n, s, r) {
  e.beginPath(), e.moveTo(0, 0), e.lineTo(t, n), e.lineTo(s, r), e.closePath(), e.save(), e.clip(), e.fillRect(0, 0, Math.max(t, s) + 1, Math.max(n, r)), e.restore();
}
function Dp(e, t) {
  return Math.abs(e[t * 4] - 210) > 2 || Math.abs(e[t * 4 + 3] - 0.75 * 255) > 2;
}
function ZF() {
  if (Ip === void 0) {
    const e = document.createElement("canvas").getContext("2d");
    e.globalCompositeOperation = "lighter", e.fillStyle = "rgba(210, 0, 0, 0.75)", WC(e, 4, 5, 4, 0), WC(e, 4, 5, 0, 5);
    const t = e.getImageData(0, 0, 3, 3).data;
    Ip = Dp(t, 0) || Dp(t, 4) || Dp(t, 8);
  }
  return Ip;
}
function xc(e, t, n, s) {
  const r = Ui(n, t, e);
  let i = KE(
    t,
    s,
    n
  );
  const a = t.getMetersPerUnit();
  a !== void 0 && (i *= a);
  const o = e.getMetersPerUnit();
  o !== void 0 && (i /= o);
  const l = e.getExtent();
  if (!l || jc(l, r)) {
    const f = KE(e, i, r) / i;
    isFinite(f) && f > 0 && (i /= f);
  }
  return i;
}
function JF(e, t, n, s) {
  const r = $i(n);
  let i = xc(
    e,
    t,
    r,
    s
  );
  return (!isFinite(i) || i <= 0) && sy(n, function(a) {
    return i = xc(
      e,
      t,
      a,
      s
    ), isFinite(i) && i > 0;
  }), i;
}
function zP(e, t, n, s, r, i, a, o, l, f, d, u) {
  const c = Di(
    Math.round(n * e),
    Math.round(n * t),
    WP
  );
  if (u || (c.imageSmoothingEnabled = !1), l.length === 0)
    return c.canvas;
  c.scale(n, n);
  function h(C) {
    return Math.round(C * n) / n;
  }
  c.globalCompositeOperation = "lighter";
  const p = ji();
  l.forEach(function(C, x, b) {
    n1(p, C.extent);
  });
  const g = Ee(p), m = In(p), v = Di(
    Math.round(n * g / s),
    Math.round(n * m / s)
  );
  u || (v.imageSmoothingEnabled = !1);
  const y = n / s;
  l.forEach(function(C, x, b) {
    const P = C.extent[0] - p[0], O = -(C.extent[3] - p[3]), T = Ee(C.extent), M = In(C.extent);
    C.image.width > 0 && C.image.height > 0 && v.drawImage(
      C.image,
      f,
      f,
      C.image.width - 2 * f,
      C.image.height - 2 * f,
      P * y,
      O * y,
      T * y,
      M * y
    );
  });
  const E = gs(a);
  return o.getTriangles().forEach(function(C, x, b) {
    const P = C.source, O = C.target;
    let T = P[0][0], M = P[0][1], L = P[1][0], A = P[1][1], D = P[2][0], I = P[2][1];
    const w = h((O[0][0] - E[0]) / i), B = h(
      -(O[0][1] - E[1]) / i
    ), j = h((O[1][0] - E[0]) / i), k = h(
      -(O[1][1] - E[1]) / i
    ), X = h((O[2][0] - E[0]) / i), rt = h(
      -(O[2][1] - E[1]) / i
    ), et = T, Z = M;
    T = 0, M = 0, L -= et, A -= Z, D -= et, I -= Z;
    const dt = [
      [L, A, 0, 0, j - w],
      [D, I, 0, 0, X - w],
      [0, 0, L, A, k - B],
      [0, 0, D, I, rt - B]
    ], vt = LD(dt);
    if (vt) {
      if (c.save(), c.beginPath(), ZF() || !u) {
        c.moveTo(j, k);
        const bt = 4, it = w - j, R = B - k;
        for (let V = 0; V < bt; V++)
          c.lineTo(
            j + h((V + 1) * it / bt),
            k + h(V * R / (bt - 1))
          ), V != bt - 1 && c.lineTo(
            j + h((V + 1) * it / bt),
            k + h((V + 1) * R / (bt - 1))
          );
        c.lineTo(X, rt);
      } else
        c.moveTo(j, k), c.lineTo(w, B), c.lineTo(X, rt);
      c.clip(), c.transform(
        vt[0],
        vt[2],
        vt[1],
        vt[3],
        w,
        B
      ), c.translate(
        p[0] - et,
        p[3] - Z
      ), c.scale(
        s / n,
        -s / n
      ), c.drawImage(v.canvas, 0, 0), c.restore();
    }
  }), d && (c.save(), c.globalCompositeOperation = "source-over", c.strokeStyle = "black", c.lineWidth = 1, o.getTriangles().forEach(function(C, x, b) {
    const P = C.target, O = (P[0][0] - E[0]) / i, T = -(P[0][1] - E[1]) / i, M = (P[1][0] - E[0]) / i, L = -(P[1][1] - E[1]) / i, A = (P[2][0] - E[0]) / i, D = -(P[2][1] - E[1]) / i;
    c.beginPath(), c.moveTo(M, L), c.lineTo(O, T), c.lineTo(A, D), c.closePath(), c.stroke();
  }), c.restore()), c.canvas;
}
class QF extends Nf {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(t, n, s, r, i, a, o, l, f, d, u, c) {
    super(i, _t.IDLE, { interpolate: !!c }), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = o, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = n, this.targetTileGrid_ = r, this.wrappedTileCoord_ = a || i, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const h = r.getTileCoordExtent(
      this.wrappedTileCoord_
    ), p = this.targetTileGrid_.getExtent();
    let g = this.sourceTileGrid_.getExtent();
    const m = p ? Ys(h, p) : h;
    if (Lg(m) === 0) {
      this.state = _t.EMPTY;
      return;
    }
    const v = t.getExtent();
    v && (g ? g = Ys(g, v) : g = v);
    const y = r.getResolution(
      this.wrappedTileCoord_[0]
    ), E = JF(
      t,
      s,
      m,
      y
    );
    if (!isFinite(E) || E <= 0) {
      this.state = _t.EMPTY;
      return;
    }
    const C = d !== void 0 ? d : $P;
    if (this.triangulation_ = new UP(
      t,
      s,
      m,
      g,
      E * C,
      y
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = _t.EMPTY;
      return;
    }
    this.sourceZ_ = n.getZForResolution(E);
    let x = this.triangulation_.calculateSourceExtent();
    if (g && (t.canWrapX() ? (x[1] = dn(
      x[1],
      g[1],
      g[3]
    ), x[3] = dn(
      x[3],
      g[1],
      g[3]
    )) : x = Ys(x, g)), !Lg(x))
      this.state = _t.EMPTY;
    else {
      const b = n.getTileRangeForExtentAndZ(
        x,
        this.sourceZ_
      );
      for (let P = b.minX; P <= b.maxX; P++)
        for (let O = b.minY; O <= b.maxY; O++) {
          const T = f(this.sourceZ_, P, O, o);
          T && this.sourceTiles_.push(T);
        }
      this.sourceTiles_.length === 0 && (this.state = _t.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = [];
    if (this.sourceTiles_.forEach(
      (function(n, s, r) {
        n && n.getState() == _t.LOADED && t.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(n.tileCoord),
          image: n.getImage()
        });
      }).bind(this)
    ), this.sourceTiles_.length = 0, t.length === 0)
      this.state = _t.ERROR;
    else {
      const n = this.wrappedTileCoord_[0], s = this.targetTileGrid_.getTileSize(n), r = typeof s == "number" ? s : s[0], i = typeof s == "number" ? s : s[1], a = this.targetTileGrid_.getResolution(n), o = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = zP(
        r,
        i,
        this.pixelRatio_,
        o,
        this.sourceTileGrid_.getExtent(),
        a,
        l,
        this.triangulation_,
        t,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = _t.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == _t.IDLE) {
      this.state = _t.LOADING, this.changed();
      let t = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(
        (function(n, s, r) {
          const i = n.getState();
          if (i == _t.IDLE || i == _t.LOADING) {
            t++;
            const a = ve(
              n,
              Kt.CHANGE,
              function(o) {
                const l = n.getState();
                (l == _t.LOADED || l == _t.ERROR || l == _t.EMPTY) && (Ue(a), t--, t === 0 && (this.unlistenSources_(), this.reproject_()));
              },
              this
            );
            this.sourcesListenerKeys_.push(a);
          }
        }).bind(this)
      ), t === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(n, s, r) {
        n.getState() == _t.IDLE && n.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(Ue), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (Py(this.canvas_.getContext("2d")), WP.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const ev = QF;
class qF extends Ry {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(t) {
    super(t), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = ji(), this.tmpTileRange_ = new dP(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(t) {
    const n = this.getLayer(), s = t.getState(), r = n.getUseInterimTilesOnError();
    return s == _t.LOADED || s == _t.EMPTY || s == _t.ERROR && !r;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(t, n, s, r) {
    const i = r.pixelRatio, a = r.viewState.projection, o = this.getLayer();
    let f = o.getSource().getTile(t, n, s, i, a);
    return f.getState() == _t.ERROR && o.getUseInterimTilesOnError() && o.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(f) || (f = f.getInterimTile()), f;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(t) {
    const n = this.frameState;
    if (!n)
      return null;
    const s = this.getLayer(), r = Ln(
      n.pixelToCoordinateTransform,
      t.slice()
    ), i = s.getExtent();
    if (i && !jc(i, r))
      return null;
    const a = n.pixelRatio, o = n.viewState.projection, l = n.viewState, f = s.getRenderSource(), d = f.getTileGridForProjection(l.projection), u = f.getTilePixelRatio(n.pixelRatio);
    for (let c = d.getZForResolution(l.resolution); c >= d.getMinZoom(); --c) {
      const h = d.getTileCoordForCoordAndZ(r, c), p = f.getTile(
        c,
        h[1],
        h[2],
        a,
        o
      );
      if (!(p instanceof eP || p instanceof ev) || p instanceof ev && p.getState() === _t.EMPTY)
        return null;
      if (p.getState() !== _t.LOADED)
        continue;
      const g = d.getOrigin(c), m = ti(d.getTileSize(c)), v = d.getResolution(c), y = Math.floor(
        u * ((r[0] - g[0]) / v - h[1] * m[0])
      ), E = Math.floor(
        u * ((g[1] - r[1]) / v - h[2] * m[1])
      ), C = Math.round(
        u * f.getGutterForProjection(l.projection)
      );
      return this.getImageData(p.getImage(), y + C, E + C);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(t, n, s) {
    return this.isDrawableTile(s) ? super.loadedTileCallback(t, n, s) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = t.layerStatesArray[t.layerIndex], r = t.viewState, i = r.projection, a = r.resolution, o = r.center, l = r.rotation, f = t.pixelRatio, d = this.getLayer(), u = d.getSource(), c = u.getRevision(), h = u.getTileGridForProjection(i), p = h.getZForResolution(a, u.zDirection), g = h.getResolution(p);
    let m = t.extent;
    const v = t.viewState.resolution, y = u.getTilePixelRatio(f), E = Math.round(Ee(m) / v * f), C = Math.round(In(m) / v * f), x = s.extent && Ks(s.extent);
    x && (m = Ys(
      m,
      Ks(s.extent)
    ));
    const b = g * E / 2 / y, P = g * C / 2 / y, O = [
      o[0] - b,
      o[1] - P,
      o[0] + b,
      o[1] + P
    ], T = h.getTileRangeForExtentAndZ(m, p), M = {};
    M[p] = {};
    const L = this.createLoadedTileFinder(
      u,
      i,
      M
    ), A = this.tmpExtent, D = this.tmpTileRange_;
    this.newTiles_ = !1;
    const I = l ? Rg(
      r.center,
      v,
      l,
      t.size
    ) : void 0;
    for (let dt = T.minX; dt <= T.maxX; ++dt)
      for (let vt = T.minY; vt <= T.maxY; ++vt) {
        if (l && !h.tileCoordIntersectsViewport([p, dt, vt], I))
          continue;
        const bt = this.getTile(p, dt, vt, t);
        if (this.isDrawableTile(bt)) {
          const V = Xt(this);
          if (bt.getState() == _t.LOADED) {
            M[p][bt.tileCoord.toString()] = bt;
            let tt = bt.inTransition(V);
            tt && s.opacity !== 1 && (bt.endTransition(V), tt = !1), !this.newTiles_ && (tt || !this.renderedTiles.includes(bt)) && (this.newTiles_ = !0);
          }
          if (bt.getAlpha(V, t.time) === 1)
            continue;
        }
        const it = h.getTileCoordChildTileRange(
          bt.tileCoord,
          D,
          A
        );
        let R = !1;
        it && (R = L(p + 1, it)), R || h.forEachTileCoordParentTileRange(
          bt.tileCoord,
          L,
          D,
          A
        );
      }
    const w = g / a * f / y;
    $r(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / f,
      1 / f,
      l,
      -E / 2,
      -C / 2
    );
    const B = ey(this.pixelTransform);
    this.useContainer(n, B, this.getBackground(t));
    const j = this.context, k = j.canvas;
    If(this.inversePixelTransform, this.pixelTransform), $r(
      this.tempTransform,
      E / 2,
      C / 2,
      w,
      w,
      0,
      -E / 2,
      -C / 2
    ), k.width != E || k.height != C ? (k.width = E, k.height = C) : this.containerReused || j.clearRect(0, 0, E, C), x && this.clipUnrotated(j, t, x), u.getInterpolate() || (j.imageSmoothingEnabled = !1), this.preRender(j, t), this.renderedTiles.length = 0;
    let X = Object.keys(M).map(Number);
    X.sort(wo);
    let rt, et, Z;
    s.opacity === 1 && (!this.containerReused || u.getOpaque(t.viewState.projection)) ? X = X.reverse() : (rt = [], et = []);
    for (let dt = X.length - 1; dt >= 0; --dt) {
      const vt = X[dt], bt = u.getTilePixelSize(
        vt,
        f,
        i
      ), R = h.getResolution(vt) / g, V = bt[0] * R * w, tt = bt[1] * R * w, Y = h.getTileCoordForCoordAndZ(
        gs(O),
        vt
      ), W = h.getTileCoordExtent(Y), z = Ln(this.tempTransform, [
        y * (W[0] - O[0]) / g,
        y * (O[3] - W[3]) / g
      ]), at = y * u.getGutterForProjection(i), ct = M[vt];
      for (const Mt in ct) {
        const N = (
          /** @type {import("../../ImageTile.js").default} */
          ct[Mt]
        ), S = N.tileCoord, _ = Y[1] - S[1], F = Math.round(z[0] - (_ - 1) * V), G = Y[2] - S[2], nt = Math.round(z[1] - (G - 1) * tt), lt = Math.round(z[0] - _ * V), yt = Math.round(z[1] - G * tt), Lt = F - lt, Ft = nt - yt, Jt = p === vt, J = Jt && N.getAlpha(Xt(this), t.time) !== 1;
        let ft = !1;
        if (!J)
          if (rt) {
            Z = [lt, yt, lt + Lt, yt, lt + Lt, yt + Ft, lt, yt + Ft];
            for (let Ct = 0, St = rt.length; Ct < St; ++Ct)
              if (p !== vt && vt < et[Ct]) {
                const Tt = rt[Ct];
                hn(
                  [lt, yt, lt + Lt, yt + Ft],
                  [Tt[0], Tt[3], Tt[4], Tt[7]]
                ) && (ft || (j.save(), ft = !0), j.beginPath(), j.moveTo(Z[0], Z[1]), j.lineTo(Z[2], Z[3]), j.lineTo(Z[4], Z[5]), j.lineTo(Z[6], Z[7]), j.moveTo(Tt[6], Tt[7]), j.lineTo(Tt[4], Tt[5]), j.lineTo(Tt[2], Tt[3]), j.lineTo(Tt[0], Tt[1]), j.clip());
              }
            rt.push(Z), et.push(vt);
          } else
            j.clearRect(lt, yt, Lt, Ft);
        this.drawTileImage(
          N,
          t,
          lt,
          yt,
          Lt,
          Ft,
          at,
          Jt
        ), rt && !J ? (ft && j.restore(), this.renderedTiles.unshift(N)) : this.renderedTiles.push(N), this.updateUsedTiles(t.usedTiles, u, N);
      }
    }
    return this.renderedRevision = c, this.renderedResolution = g, this.extentChanged = !this.renderedExtent_ || !Fo(this.renderedExtent_, O), this.renderedExtent_ = O, this.renderedPixelRatio = f, this.renderedProjection = i, this.manageTilePyramid(
      t,
      u,
      h,
      f,
      i,
      m,
      p,
      d.getPreload()
    ), this.scheduleExpireCache(t, u), this.postRender(j, t), s.extent && j.restore(), j.imageSmoothingEnabled = !0, B !== k.style.transform && (k.style.transform = B), this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(t, n, s, r, i, a, o, l) {
    const f = this.getTileImage(t);
    if (!f)
      return;
    const d = Xt(this), u = n.layerStatesArray[n.layerIndex], c = u.opacity * (l ? t.getAlpha(d, n.time) : 1), h = c !== this.context.globalAlpha;
    h && (this.context.save(), this.context.globalAlpha = c), this.context.drawImage(
      f,
      o,
      o,
      f.width - 2 * o,
      f.height - 2 * o,
      s,
      r,
      i,
      a
    ), h && this.context.restore(), c !== u.opacity ? n.animate = !0 : l && t.endTransition(d);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const t = this.context;
    return t ? t.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(t) {
    return t.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(t, n) {
    if (n.canExpireCache()) {
      const s = (function(r, i, a) {
        const o = Xt(r);
        o in a.usedTiles && r.expireCache(
          a.viewState.projection,
          a.usedTiles[o]
        );
      }).bind(null, n);
      t.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        s
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(t, n, s) {
    const r = Xt(n);
    r in t || (t[r] = {}), t[r][s.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(t, n, s, r, i, a, o, l, f) {
    const d = Xt(n);
    d in t.wantedTiles || (t.wantedTiles[d] = {});
    const u = t.wantedTiles[d], c = t.tileQueue, h = s.getMinZoom(), p = t.viewState.rotation, g = p ? Rg(
      t.viewState.center,
      t.viewState.resolution,
      p,
      t.size
    ) : void 0;
    let m = 0, v, y, E, C, x, b;
    for (b = h; b <= o; ++b)
      for (y = s.getTileRangeForExtentAndZ(a, b, y), E = s.getResolution(b), C = y.minX; C <= y.maxX; ++C)
        for (x = y.minY; x <= y.maxY; ++x)
          p && !s.tileCoordIntersectsViewport([b, C, x], g) || (o - b <= l ? (++m, v = n.getTile(b, C, x, r, i), v.getState() == _t.IDLE && (u[v.getKey()] = !0, c.isKeyQueued(v.getKey()) || c.enqueue([
            v,
            d,
            s.getTileCoordCenter(v.tileCoord),
            E
          ])), f !== void 0 && f(v)) : n.useTile(b, C, x, i));
    n.updateCacheSize(m, i);
  }
}
const KP = qF;
class tN extends HF {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new KP(this);
  }
}
const Zc = tN;
class eN extends hu {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    t = t || {}, super(t);
  }
}
const nN = eN;
class iN extends Ry {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(t) {
    super(t), this.image_ = null;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = t.layerStatesArray[t.layerIndex], s = t.pixelRatio, r = t.viewState, i = r.resolution, a = this.getLayer().getSource(), o = t.viewHints;
    let l = t.extent;
    if (n.extent !== void 0 && (l = Ys(
      l,
      Ks(n.extent, r.projection)
    )), !o[en.ANIMATING] && !o[en.INTERACTING] && !Df(l))
      if (a) {
        const f = r.projection, d = a.getImage(
          l,
          i,
          s,
          f
        );
        d && (this.loadImage(d) ? this.image_ = d : d.getState() === he.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(t) {
    const n = this.frameState;
    if (!n)
      return null;
    const s = this.getLayer(), r = Ln(
      n.pixelToCoordinateTransform,
      t.slice()
    ), i = s.getExtent();
    if (i && !jc(i, r))
      return null;
    const a = this.image_.getExtent(), o = this.image_.getImage(), l = Ee(a), f = Math.floor(
      o.width * ((r[0] - a[0]) / l)
    );
    if (f < 0 || f >= o.width)
      return null;
    const d = In(a), u = Math.floor(
      o.height * ((a[3] - r[1]) / d)
    );
    return u < 0 || u >= o.height ? null : this.getImageData(o, f, u);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(t, n) {
    const s = this.image_, r = s.getExtent(), i = s.getResolution(), a = s.getPixelRatio(), o = t.layerStatesArray[t.layerIndex], l = t.pixelRatio, f = t.viewState, d = f.center, u = f.resolution, c = l * i / (u * a), h = t.extent, p = f.resolution, g = f.rotation, m = Math.round(Ee(h) / p * l), v = Math.round(In(h) / p * l);
    $r(
      this.pixelTransform,
      t.size[0] / 2,
      t.size[1] / 2,
      1 / l,
      1 / l,
      g,
      -m / 2,
      -v / 2
    ), If(this.inversePixelTransform, this.pixelTransform);
    const y = ey(this.pixelTransform);
    this.useContainer(n, y, this.getBackground(t));
    const E = this.context, C = E.canvas;
    C.width != m || C.height != v ? (C.width = m, C.height = v) : this.containerReused || E.clearRect(0, 0, m, v);
    let x = !1, b = !0;
    if (o.extent) {
      const L = Ks(
        o.extent,
        f.projection
      );
      b = hn(L, t.extent), x = b && !Rr(L, t.extent), x && this.clipUnrotated(E, t, L);
    }
    const P = s.getImage(), O = $r(
      this.tempTransform,
      m / 2,
      v / 2,
      c,
      c,
      0,
      a * (r[0] - d[0]) / i,
      a * (d[1] - r[3]) / i
    );
    this.renderedResolution = i * l / a;
    const T = P.width * O[0], M = P.height * O[3];
    if (this.getLayer().getSource().getInterpolate() || (E.imageSmoothingEnabled = !1), this.preRender(E, t), b && T >= 0.5 && M >= 0.5) {
      const L = O[4], A = O[5], D = o.opacity;
      let I;
      D !== 1 && (I = E.globalAlpha, E.globalAlpha = D), E.drawImage(P, 0, 0, +P.width, +P.height, L, A, T, M), D !== 1 && (E.globalAlpha = I);
    }
    return this.postRender(E, t), x && E.restore(), E.imageSmoothingEnabled = !0, y !== C.style.transform && (C.style.transform = y), this.container;
  }
}
const rN = iN;
class sN extends nN {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(t) {
    super(t);
  }
  createRenderer() {
    return new rN(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(t) {
    return super.getData(t);
  }
}
const Uf = sN, Ap = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
}, aN = [0, 0, 0], ya = 5;
class oN {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(t) {
    this.minZoom = t.minZoom !== void 0 ? t.minZoom : 0, this.resolutions_ = t.resolutions, Zt(
      qI(
        this.resolutions_,
        function(r, i) {
          return i - r;
        },
        !0
      ),
      17
    );
    let n;
    if (!t.origins) {
      for (let r = 0, i = this.resolutions_.length - 1; r < i; ++r)
        if (!n)
          n = this.resolutions_[r] / this.resolutions_[r + 1];
        else if (this.resolutions_[r] / this.resolutions_[r + 1] !== n) {
          n = void 0;
          break;
        }
    }
    this.zoomFactor_ = n, this.maxZoom = this.resolutions_.length - 1, this.origin_ = t.origin !== void 0 ? t.origin : null, this.origins_ = null, t.origins !== void 0 && (this.origins_ = t.origins, Zt(this.origins_.length == this.resolutions_.length, 20));
    const s = t.extent;
    s !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = gs(s)), Zt(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    ), this.tileSizes_ = null, t.tileSizes !== void 0 && (this.tileSizes_ = t.tileSizes, Zt(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = t.tileSize !== void 0 ? t.tileSize : this.tileSizes_ ? null : By, Zt(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    ), this.extent_ = s !== void 0 ? s : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], t.sizes !== void 0 ? this.fullTileRanges_ = t.sizes.map(function(r, i) {
      const a = new dP(
        Math.min(0, r[0]),
        Math.max(r[0] - 1, -1),
        Math.min(0, r[1]),
        Math.max(r[1] - 1, -1)
      );
      if (s) {
        const o = this.getTileRangeForExtentAndZ(s, i);
        a.minX = Math.max(o.minX, a.minX), a.maxX = Math.min(o.maxX, a.maxX), a.minY = Math.max(o.minY, a.minY), a.maxY = Math.min(o.maxY, a.maxY);
      }
      return a;
    }, this) : s && this.calculateTileRanges_(s);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(t, n, s) {
    const r = this.getTileRangeForExtentAndZ(t, n);
    for (let i = r.minX, a = r.maxX; i <= a; ++i)
      for (let o = r.minY, l = r.maxY; o <= l; ++o)
        s([n, i, o]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(t, n, s, r) {
    let i, a, o, l = null, f = t[0] - 1;
    for (this.zoomFactor_ === 2 ? (a = t[1], o = t[2]) : l = this.getTileCoordExtent(t, r); f >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (a = Math.floor(a / 2), o = Math.floor(o / 2), i = cl(a, a, o, o, s)) : i = this.getTileRangeForExtentAndZ(
        l,
        f,
        s
      ), n(f, i))
        return !0;
      --f;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(t) {
    return this.origin_ ? this.origin_ : this.origins_[t];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(t) {
    return this.resolutions_[t];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(t, n, s) {
    if (t[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const i = t[1] * 2, a = t[2] * 2;
        return cl(
          i,
          i + 1,
          a,
          a + 1,
          n
        );
      }
      const r = this.getTileCoordExtent(
        t,
        s || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        r,
        t[0] + 1,
        n
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(t, n, s) {
    if (n > this.maxZoom || n < this.minZoom)
      return null;
    const r = t[0], i = t[1], a = t[2];
    if (n === r)
      return cl(
        i,
        a,
        i,
        a,
        s
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, n - r), f = Math.floor(i * l), d = Math.floor(a * l);
      if (n < r)
        return cl(f, f, d, d, s);
      const u = Math.floor(l * (i + 1)) - 1, c = Math.floor(l * (a + 1)) - 1;
      return cl(f, u, d, c, s);
    }
    const o = this.getTileCoordExtent(t, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(o, n, s);
  }
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */
  getTileRangeExtent(t, n, s) {
    const r = this.getOrigin(t), i = this.getResolution(t), a = ti(this.getTileSize(t), this.tmpSize_), o = r[0] + n.minX * a[0] * i, l = r[0] + (n.maxX + 1) * a[0] * i, f = r[1] + n.minY * a[1] * i, d = r[1] + (n.maxY + 1) * a[1] * i;
    return ir(o, f, l, d, s);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(t, n, s) {
    const r = aN;
    this.getTileCoordForXYAndZ_(t[0], t[3], n, !1, r);
    const i = r[1], a = r[2];
    return this.getTileCoordForXYAndZ_(t[2], t[1], n, !0, r), cl(
      i,
      r[1],
      a,
      r[2],
      s
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(t) {
    const n = this.getOrigin(t[0]), s = this.getResolution(t[0]), r = ti(this.getTileSize(t[0]), this.tmpSize_);
    return [
      n[0] + (t[1] + 0.5) * r[0] * s,
      n[1] - (t[2] + 0.5) * r[1] * s
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(t, n) {
    const s = this.getOrigin(t[0]), r = this.getResolution(t[0]), i = ti(this.getTileSize(t[0]), this.tmpSize_), a = s[0] + t[1] * i[0] * r, o = s[1] - (t[2] + 1) * i[1] * r, l = a + i[0] * r, f = o + i[1] * r;
    return ir(a, o, l, f, n);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(t, n, s) {
    return this.getTileCoordForXYAndResolution_(
      t[0],
      t[1],
      n,
      !1,
      s
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(t, n, s, r, i) {
    const a = this.getZForResolution(s), o = s / this.getResolution(a), l = this.getOrigin(a), f = ti(this.getTileSize(a), this.tmpSize_);
    let d = o * (t - l[0]) / s / f[0], u = o * (l[1] - n) / s / f[1];
    return r ? (d = Ma(d, ya) - 1, u = Ma(u, ya) - 1) : (d = Sl(d, ya), u = Sl(u, ya)), CC(a, d, u, i);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(t, n, s, r, i) {
    const a = this.getOrigin(s), o = this.getResolution(s), l = ti(this.getTileSize(s), this.tmpSize_);
    let f = (t - a[0]) / o / l[0], d = (a[1] - n) / o / l[1];
    return r ? (f = Ma(f, ya) - 1, d = Ma(d, ya) - 1) : (f = Sl(f, ya), d = Sl(d, ya)), CC(s, f, d, i);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(t, n, s) {
    return this.getTileCoordForXYAndZ_(
      t[0],
      t[1],
      n,
      !1,
      s
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(t) {
    return this.resolutions_[t[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(t) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(t) {
    return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(t, n) {
    const s = Pf(
      this.resolutions_,
      t,
      n || 0
    );
    return dn(s, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(t, n) {
    return b1(
      n,
      0,
      n.length,
      2,
      this.getTileCoordExtent(t)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(t) {
    const n = this.resolutions_.length, s = new Array(n);
    for (let r = this.minZoom; r < n; ++r)
      s[r] = this.getTileRangeForExtentAndZ(t, r);
    this.fullTileRanges_ = s;
  }
}
const mu = oN;
function n0(e) {
  let t = e.getDefaultTileGrid();
  return t || (t = hN(e), e.setDefaultTileGrid(t)), t;
}
function lN(e, t, n) {
  const s = t[0], r = e.getTileCoordCenter(t), i = Wf(n);
  if (jc(i, r))
    return t;
  {
    const a = Ee(i), o = Math.ceil(
      (i[0] - r[0]) / a
    );
    return r[0] += a * o, e.getTileCoordForCoordAndZ(r, s);
  }
}
function uN(e, t, n, s) {
  s = s !== void 0 ? s : "top-left";
  const r = GP(e, t, n);
  return new mu({
    extent: e,
    origin: vD(e, s),
    resolutions: r,
    tileSize: n
  });
}
function cN(e) {
  const t = e || {}, n = t.extent || Wt("EPSG:3857").getExtent(), s = {
    extent: n,
    minZoom: t.minZoom,
    tileSize: t.tileSize,
    resolutions: GP(
      n,
      t.maxZoom,
      t.tileSize,
      t.maxResolution
    )
  };
  return new mu(s);
}
function GP(e, t, n, s) {
  t = t !== void 0 ? t : nP, n = ti(n !== void 0 ? n : By);
  const r = In(e), i = Ee(e);
  s = s > 0 ? s : Math.max(i / n[0], r / n[1]);
  const a = t + 1, o = new Array(a);
  for (let l = 0; l < a; ++l)
    o[l] = s / Math.pow(2, l);
  return o;
}
function hN(e, t, n, s) {
  const r = Wf(e);
  return uN(r, t, n, s);
}
function Wf(e) {
  e = Wt(e);
  let t = e.getExtent();
  if (!t) {
    const n = 180 * ql.degrees / e.getMetersPerUnit();
    t = ir(-n, -n, n, n);
  }
  return t;
}
class dN extends wy {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      projection: t.projection,
      state: t.state,
      wrapX: t.wrapX,
      interpolate: t.interpolate
    }), this.on, this.once, this.un, this.opaque_ = t.opaque !== void 0 ? t.opaque : !1, this.tilePixelRatio_ = t.tilePixelRatio !== void 0 ? t.tilePixelRatio : 1, this.tileGrid = t.tileGrid !== void 0 ? t.tileGrid : null;
    const n = [256, 256];
    this.tileGrid && ti(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), n), this.tileCache = new Hy(t.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = t.key || "", this.tileOptions = {
      transition: t.transition,
      interpolate: t.interpolate
    }, this.zDirection = t.zDirection ? t.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t);
    s && s.expireCache(n);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(t, n, s, r) {
    const i = this.getTileCacheForProjection(t);
    if (!i)
      return !1;
    let a = !0, o, l, f;
    for (let d = s.minX; d <= s.maxX; ++d)
      for (let u = s.minY; u <= s.maxY; ++u)
        l = fu(n, d, u), f = !1, i.containsKey(l) && (o = /** @type {!import("../Tile.js").default} */
        i.get(l), f = o.getState() === _t.LOADED, f && (f = r(o) !== !1)), f || (a = !1);
    return a;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(t) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(t) {
    this.key_ !== t && (this.key_ = t, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(t) {
    return this.opaque_;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.tileGrid ? this.tileGrid.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(t, n, s, r, i) {
    return Gt();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    return this.tileGrid ? this.tileGrid : n0(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(t) {
    const n = this.getProjection();
    return Zt(
      n === null || mr(n, t),
      68
      // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(t, n, s) {
    const r = this.getTileGridForProjection(s), i = this.getTilePixelRatio(n), a = ti(r.getTileSize(t), this.tmpSize);
    return i == 1 ? a : M1(a, i, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(t, n) {
    n = n !== void 0 ? n : this.getProjection();
    const s = this.getTileGridForProjection(n);
    return this.getWrapX() && n.isGlobal() && (t = lN(s, t, n)), qR(t, s) ? t : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(t, n) {
    const s = this.getTileCacheForProjection(n);
    t > s.highWaterMark && (s.highWaterMark = t);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(t, n, s, r) {
  }
}
class fN extends Wi {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(t, n) {
    super(t), this.tile = n;
  }
}
const kP = dN;
function pN(e, t) {
  const n = /\{z\}/g, s = /\{x\}/g, r = /\{y\}/g, i = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(a, o, l) {
      if (a)
        return e.replace(n, a[0].toString()).replace(s, a[1].toString()).replace(r, a[2].toString()).replace(i, function() {
          const f = a[0], d = t.getFullTileRange(f);
          return Zt(d, 55), (d.getHeight() - a[2] - 1).toString();
        });
    }
  );
}
function HP(e, t) {
  const n = e.length, s = new Array(n);
  for (let r = 0; r < n; ++r)
    s[r] = pN(e[r], t);
  return nv(s);
}
function nv(e) {
  return e.length === 1 ? e[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(t, n, s) {
      if (t) {
        const r = cP(t), i = Va(r, e.length);
        return e[i](t, n, s);
      } else
        return;
    }
  );
}
function YP(e) {
  const t = [];
  let n = /\{([a-z])-([a-z])\}/.exec(e);
  if (n) {
    const s = n[1].charCodeAt(0), r = n[2].charCodeAt(0);
    let i;
    for (i = s; i <= r; ++i)
      t.push(e.replace(n[0], String.fromCharCode(i)));
    return t;
  }
  if (n = /\{(\d+)-(\d+)\}/.exec(e), n) {
    const s = parseInt(n[2], 10);
    for (let r = parseInt(n[1], 10); r <= s; r++)
      t.push(e.replace(n[0], r.toString()));
    return t;
  }
  return t.push(e), t;
}
class i0 extends kP {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      opaque: t.opaque,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tilePixelRatio: t.tilePixelRatio,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === i0.prototype.tileUrlFunction, this.tileLoadFunction = t.tileLoadFunction, t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction), this.urls = null, t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(t) {
    const n = (
      /** @type {import("../Tile.js").default} */
      t.target
    ), s = Xt(n), r = n.getState();
    let i;
    r == _t.LOADING ? (this.tileLoadingKeys_[s] = !0, i = Ap.TILELOADSTART) : s in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[s], i = r == _t.ERROR ? Ap.TILELOADERROR : r == _t.LOADED ? Ap.TILELOADEND : void 0), i != null && this.dispatchEvent(new fN(i, n));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(t) {
    this.tileCache.clear(), this.tileLoadFunction = t, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(t, n) {
    this.tileUrlFunction = t, this.tileCache.pruneExceptNewestZ(), typeof n < "u" ? this.setKey(n) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(t) {
    const n = YP(t);
    this.urls = n, this.setUrls(n);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(t) {
    this.urls = t;
    const n = t.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(HP(t, this.tileGrid), n) : this.setKey(n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(t, n, s) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(t, n, s) {
    const r = fu(t, n, s);
    this.tileCache.containsKey(r) && this.tileCache.get(r);
  }
}
const XP = i0;
class mN extends XP {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      cacheSize: t.cacheSize,
      opaque: t.opaque,
      projection: t.projection,
      state: t.state,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : gN,
      tilePixelRatio: t.tilePixelRatio,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX,
      transition: t.transition,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0,
      key: t.key,
      attributionsCollapsible: t.attributionsCollapsible,
      zDirection: t.zDirection
    }), this.crossOrigin = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.tileClass = t.tileClass !== void 0 ? t.tileClass : eP, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const t in this.tileCacheForProjection)
      if (this.tileCacheForProjection[t].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t);
    this.tileCache.expireCache(
      this.tileCache == s ? n : {}
    );
    for (const r in this.tileCacheForProjection) {
      const i = this.tileCacheForProjection[r];
      i.expireCache(i == s ? n : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(t) {
    return this.getProjection() && t && !mr(this.getProjection(), t) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let t = super.getKey();
    return this.getInterpolate() || (t += ":disable-interpolation"), t;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(t) {
    return this.getProjection() && t && !mr(this.getProjection(), t) ? !1 : super.getOpaque(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    const n = this.getProjection();
    if (this.tileGrid && (!n || mr(n, t)))
      return this.tileGrid;
    {
      const s = Xt(t);
      return s in this.tileGridForProjection || (this.tileGridForProjection[s] = n0(t)), this.tileGridForProjection[s];
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(t) {
    const n = this.getProjection();
    if (!n || mr(n, t))
      return this.tileCache;
    {
      const s = Xt(t);
      return s in this.tileCacheForProjection || (this.tileCacheForProjection[s] = new Hy(
        this.tileCache.highWaterMark
      )), this.tileCacheForProjection[s];
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(t, n, s, r, i, a) {
    const o = [t, n, s], l = this.getTileCoordForTileUrlFunction(
      o,
      i
    ), f = l ? this.tileUrlFunction(l, r, i) : void 0, d = new this.tileClass(
      o,
      f !== void 0 ? _t.IDLE : _t.EMPTY,
      f !== void 0 ? f : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return d.key = a, d.addEventListener(Kt.CHANGE, this.handleTileChange.bind(this)), d;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(t, n, s, r, i) {
    const a = this.getProjection();
    if (!a || !i || mr(a, i))
      return this.getTileInternal(
        t,
        n,
        s,
        r,
        a || i
      );
    {
      const o = this.getTileCacheForProjection(i), l = [t, n, s];
      let f;
      const d = lP(l);
      o.containsKey(d) && (f = o.get(d));
      const u = this.getKey();
      if (f && f.key == u)
        return f;
      {
        const c = this.getTileGridForProjection(a), h = this.getTileGridForProjection(i), p = this.getTileCoordForTileUrlFunction(
          l,
          i
        ), g = new ev(
          a,
          c,
          i,
          h,
          l,
          p,
          this.getTilePixelRatio(r),
          this.getGutter(),
          (function(m, v, y, E) {
            return this.getTileInternal(m, v, y, E, a);
          }).bind(this),
          this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_,
          this.getInterpolate()
        );
        return g.key = u, f ? (g.interimTile = f, g.refreshInterimChain(), o.replace(d, g)) : o.set(d, g), g;
      }
    }
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @protected
   */
  getTileInternal(t, n, s, r, i) {
    let a = null;
    const o = fu(t, n, s), l = this.getKey();
    if (!this.tileCache.containsKey(o))
      a = this.createTile_(t, n, s, r, i, l), this.tileCache.set(o, a);
    else if (a = this.tileCache.get(o), a.key != l) {
      const f = a;
      a = this.createTile_(t, n, s, r, i, l), f.getState() == _t.IDLE ? a.interimTile = f.interimTile : a.interimTile = f, a.refreshInterimChain(), this.tileCache.replace(o, a);
    }
    return a;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(t) {
    if (this.renderReprojectionEdges_ != t) {
      this.renderReprojectionEdges_ = t;
      for (const n in this.tileCacheForProjection)
        this.tileCacheForProjection[n].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(t, n) {
    const s = Wt(t);
    if (s) {
      const r = Xt(s);
      r in this.tileGridForProjection || (this.tileGridForProjection[r] = n);
    }
  }
  clear() {
    super.clear();
    for (const t in this.tileCacheForProjection)
      this.tileCacheForProjection[t].clear();
  }
}
function gN(e, t) {
  e.getImage().src = t;
}
const r0 = mN, La = "1.3.0";
function su(e, t) {
  const n = [];
  Object.keys(t).forEach(function(r) {
    t[r] !== null && t[r] !== void 0 && n.push(r + "=" + encodeURIComponent(t[r]));
  });
  const s = n.join("&");
  return e = e.replace(/[?&]$/, ""), e += e.includes("?") ? "&" : "?", e + s;
}
class vN extends r0 {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(t) {
    t = t || /** @type {Options} */
    {};
    const n = Object.assign({}, t.params), s = "TRANSPARENT" in n ? n.TRANSPARENT : !0;
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      opaque: !s,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: t.tileGrid,
      tileLoadFunction: t.tileLoadFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !0,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.gutter_ = t.gutter !== void 0 ? t.gutter : 0, this.params_ = n, this.v13_ = !0, this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.tmpExtent_ = ji(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, n, s, r) {
    const i = Wt(s), a = this.getProjection();
    let o = this.getTileGrid();
    o || (o = this.getTileGridForProjection(i));
    const l = o.getZForResolution(n, this.zDirection), f = o.getTileCoordForCoordAndZ(t, l);
    if (o.getResolutions().length <= f[0])
      return;
    let d = o.getResolution(f[0]), u = o.getTileCoordExtent(f, this.tmpExtent_), c = ti(o.getTileSize(f[0]), this.tmpSize);
    const h = this.gutter_;
    h !== 0 && (c = JE(c, h, this.tmpSize), u = Br(u, d * h, u)), a && a !== i && (d = xc(
      a,
      i,
      t,
      d
    ), u = Wc(
      u,
      i,
      a
    ), t = Ui(t, i, a));
    const p = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(p, this.params_, r);
    const g = Math.floor((t[0] - u[0]) / d), m = Math.floor((u[3] - t[1]) / d);
    return p[this.v13_ ? "I" : "X"] = g, p[this.v13_ ? "J" : "Y"] = m, this.getRequestUrl_(
      f,
      c,
      u,
      1,
      a || i,
      p
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, n) {
    if (this.urls[0] === void 0)
      return;
    const s = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (n === void 0 || n.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      s.LAYER = r;
    }
    if (t !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, i = 28e-5;
      s.SCALE = t * r / i;
    }
    return Object.assign(s, n), su(
      /** @type {string} */
      this.urls[0],
      s
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(t, n, s, r, i, a) {
    const o = this.urls;
    if (!o)
      return;
    if (a.WIDTH = n[0], a.HEIGHT = n[1], a[this.v13_ ? "CRS" : "SRS"] = i.getCode(), "STYLES" in this.params_ || (a.STYLES = ""), r != 1)
      switch (this.serverType_) {
        case "geoserver":
          const u = 90 * r + 0.5 | 0;
          "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + u : a.FORMAT_OPTIONS = "dpi:" + u;
          break;
        case "mapserver":
          a.MAP_RESOLUTION = 90 * r;
          break;
        case "carmentaserver":
        case "qgis":
          a.DPI = 90 * r;
          break;
        default:
          Zt(!1, 52);
          break;
      }
    const l = i.getAxisOrientation(), f = s;
    if (this.v13_ && l.substr(0, 2) == "ne") {
      let u;
      u = s[0], f[0] = s[1], f[1] = u, u = s[2], f[2] = s[3], f[3] = u;
    }
    a.BBOX = f.join(",");
    let d;
    if (o.length == 1)
      d = o[0];
    else {
      const u = Va(cP(t), o.length);
      d = o[u];
    }
    return su(d, a);
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : t;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let t = 0;
    const n = [];
    for (const s in this.params_)
      n[t++] = s + "-" + this.params_[s];
    return n.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(t) {
    Object.assign(this.params_, t), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const t = this.params_.VERSION || La;
    this.v13_ = a1(t, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(t, n, s) {
    let r = this.getTileGrid();
    if (r || (r = this.getTileGridForProjection(s)), r.getResolutions().length <= t[0])
      return;
    n != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (n = 1);
    const i = r.getResolution(t[0]);
    let a = r.getTileCoordExtent(t, this.tmpExtent_), o = ti(r.getTileSize(t[0]), this.tmpSize);
    const l = this.gutter_;
    l !== 0 && (o = JE(o, l, this.tmpSize), a = Br(a, i * l, a)), n != 1 && (o = M1(o, n, this.tmpSize));
    const f = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    return Object.assign(f, this.params_), this.getRequestUrl_(
      t,
      o,
      a,
      n,
      s,
      f
    );
  }
}
const s0 = vN;
class yN extends U1 {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(t, n, s, r, i, a, o) {
    const l = t.getExtent(), f = n.getExtent(), d = f ? Ys(s, f) : s, u = $i(d), c = xc(
      t,
      n,
      u,
      r
    ), h = $P, p = new UP(
      t,
      n,
      d,
      l,
      c * h,
      r
    ), g = p.calculateSourceExtent(), m = a(
      g,
      c,
      i
    ), v = m ? he.IDLE : he.EMPTY, y = m ? m.getPixelRatio() : 1;
    super(s, r, y, v), this.targetProj_ = n, this.maxSourceExtent_ = l, this.triangulation_ = p, this.targetResolution_ = r, this.targetExtent_ = s, this.sourceImage_ = m, this.sourcePixelRatio_ = y, this.interpolate_ = o, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == he.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const t = this.sourceImage_.getState();
    if (t == he.LOADED) {
      const n = Ee(this.targetExtent_) / this.targetResolution_, s = In(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = zP(
        n,
        s,
        this.sourcePixelRatio_,
        this.sourceImage_.getResolution(),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_
      );
    }
    this.state = t, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == he.IDLE) {
      this.state = he.LOADING, this.changed();
      const t = this.sourceImage_.getState();
      t == he.LOADED || t == he.ERROR ? this.reproject_() : (this.sourceListenerKey_ = ve(
        this.sourceImage_,
        Kt.CHANGE,
        function(n) {
          const s = this.sourceImage_.getState();
          (s == he.LOADED || s == he.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    Ue(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const EN = yN, Lp = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class CN extends Wi {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(t, n) {
    super(t), this.image = n;
  }
}
class xN extends wy {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      projection: t.projection,
      state: t.state,
      interpolate: t.interpolate !== void 0 ? t.interpolate : !0
    }), this.on, this.once, this.un, this.resolutions_ = t.resolutions !== void 0 ? t.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(t) {
    if (this.resolutions_) {
      const n = Pf(this.resolutions_, t, 0);
      t = this.resolutions_[n];
    }
    return t;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */
  getImage(t, n, s, r) {
    const i = this.getProjection();
    if (!i || !r || mr(i, r))
      return i && (r = i), this.getImageInternal(t, n, s, r);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && mr(this.reprojectedImage_.getProjection(), r) && this.reprojectedImage_.getResolution() == n && Fo(this.reprojectedImage_.getExtent(), t))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new EN(
      i,
      r,
      t,
      n,
      s,
      (function(a, o, l) {
        return this.getImageInternal(
          a,
          o,
          l,
          i
        );
      }).bind(this),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */
  getImageInternal(t, n, s, r) {
    return Gt();
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(t) {
    const n = (
      /** @type {import("../Image.js").default} */
      t.target
    );
    let s;
    switch (n.getState()) {
      case he.LOADING:
        this.loading = !0, s = Lp.IMAGELOADSTART;
        break;
      case he.LOADED:
        this.loading = !1, s = Lp.IMAGELOADEND;
        break;
      case he.ERROR:
        this.loading = !1, s = Lp.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(s) && this.dispatchEvent(new CN(s, n));
  }
}
function a0(e, t) {
  e.getImage().src = t;
}
const ZP = xN, Ea = 4, zC = [101, 101];
class bN extends ZP {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(t) {
    t = t || {}, super({
      attributions: t.attributions,
      interpolate: t.interpolate,
      projection: t.projection,
      resolutions: t.resolutions
    }), this.crossOrigin_ = t.crossOrigin !== void 0 ? t.crossOrigin : null, this.url_ = t.url, this.imageLoadFunction_ = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : a0, this.params_ = Object.assign({}, t.params), this.v13_ = !0, this.updateV13_(), this.serverType_ = t.serverType, this.hidpi_ = t.hidpi !== void 0 ? t.hidpi : !0, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = t.ratio !== void 0 ? t.ratio : 1.5;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(t, n, s, r) {
    if (this.url_ === void 0)
      return;
    const i = Wt(s), a = this.getProjection();
    a && a !== i && (n = xc(
      a,
      i,
      t,
      n
    ), t = Ui(t, i, a));
    const o = $l(
      t,
      n,
      0,
      zC
    ), l = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(l, this.params_, r);
    const f = Sl((t[0] - o[0]) / n, Ea), d = Sl((o[3] - t[1]) / n, Ea);
    return l[this.v13_ ? "I" : "X"] = f, l[this.v13_ ? "J" : "Y"] = d, this.getRequestUrl_(
      o,
      zC,
      1,
      a || i,
      l
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(t, n) {
    if (this.url_ === void 0)
      return;
    const s = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (n === void 0 || n.LAYER === void 0) {
      const r = this.params_.LAYERS;
      if (!(!Array.isArray(r) || r.length === 1))
        return;
      s.LAYER = r;
    }
    if (t !== void 0) {
      const r = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, i = 28e-5;
      s.SCALE = t * r / i;
    }
    return Object.assign(s, n), su(
      /** @type {string} */
      this.url_,
      s
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(t, n, s, r) {
    if (this.url_ === void 0)
      return null;
    n = this.findNearestResolution(n), s != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (s = 1);
    const i = n / s, a = $i(t), o = Ma(Ee(t) / i, Ea), l = Ma(In(t) / i, Ea), f = $l(a, i, 0, [
      o,
      l
    ]), d = Ma(
      this.ratio_ * Ee(t) / i,
      Ea
    ), u = Ma(
      this.ratio_ * In(t) / i,
      Ea
    ), c = $l(a, i, 0, [
      d,
      u
    ]), h = this.image_;
    if (h && this.renderedRevision_ == this.getRevision() && h.getResolution() == n && h.getPixelRatio() == s && Rr(h.getExtent(), f))
      return h;
    const p = {
      SERVICE: "WMS",
      VERSION: La,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    Object.assign(p, this.params_), this.imageSize_[0] = WE(
      Ee(c) / i,
      Ea
    ), this.imageSize_[1] = WE(
      In(c) / i,
      Ea
    );
    const g = this.getRequestUrl_(
      c,
      this.imageSize_,
      s,
      r,
      p
    );
    return this.image_ = new W1(
      c,
      n,
      s,
      g,
      this.crossOrigin_,
      this.imageLoadFunction_
    ), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(
      Kt.CHANGE,
      this.handleImageChange.bind(this)
    ), this.image_;
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */
  getRequestUrl_(t, n, s, r, i) {
    if (Zt(this.url_ !== void 0, 9), i[this.v13_ ? "CRS" : "SRS"] = r.getCode(), "STYLES" in this.params_ || (i.STYLES = ""), s != 1)
      switch (this.serverType_) {
        case "geoserver":
          const l = 90 * s + 0.5 | 0;
          "FORMAT_OPTIONS" in i ? i.FORMAT_OPTIONS += ";dpi:" + l : i.FORMAT_OPTIONS = "dpi:" + l;
          break;
        case "mapserver":
          i.MAP_RESOLUTION = 90 * s;
          break;
        case "carmentaserver":
        case "qgis":
          i.DPI = 90 * s;
          break;
        default:
          Zt(!1, 8);
          break;
      }
    i.WIDTH = n[0], i.HEIGHT = n[1];
    const a = r.getAxisOrientation();
    let o;
    return this.v13_ && a.substr(0, 2) == "ne" ? o = [t[1], t[0], t[3], t[2]] : o = t, i.BBOX = o.join(","), su(
      /** @type {string} */
      this.url_,
      i
    );
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(t) {
    this.image_ = null, this.imageLoadFunction_ = t, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(t) {
    t != this.url_ && (this.url_ = t, this.image_ = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(t) {
    Object.assign(this.params_, t), this.updateV13_(), this.image_ = null, this.changed();
  }
  /**
   * @private
   */
  updateV13_() {
    const t = this.params_.VERSION || La;
    this.v13_ = a1(t, "1.3") >= 0;
  }
}
const o0 = bN, TN = "EPSG:3857";
function l0() {
  return Math.floor(Math.random() * 9999999);
}
function JP(e, t) {
  const n = { ...e }, s = {}, r = [
    "STYLES",
    "TIME",
    "CRS"
  ];
  return Object.keys(t).forEach((i) => {
    s[i.toUpperCase()] = t[i];
  }), r.forEach((i) => {
    t[i] && (n[i] = t[i]);
  }), n;
}
function QP(e) {
  let t = {};
  return t = Object.assign({
    CACHEID: l0(),
    FORMAT: e.format || "image/png",
    LAYERS: e.layers,
    VERSION: e.version,
    TRANSPARENT: e.transparent,
    SINGLETILE: e.singleTile
  }, e.singleTile ? {} : { WIDTH: e.tilesize, HEIGHT: e.tilesize }), t = JP(t, e), t;
}
function qP(e, t) {
  const n = QP(e), s = e.crs ? Wt(e.crs) : void 0;
  let r = null;
  return e.singleTile ? new o0({
    url: e.url,
    params: n,
    serverType: e.serverType,
    projection: s,
    attributions: e.olAttribution
  }) : (t && t.resolutions && (r = new mu({
    resolutions: t.resolutions,
    origin: t.origin ? t.origin : void 0,
    tileSize: parseInt(e.tilesize, 10)
  })), new s0({
    url: e.url,
    params: n,
    gutter: e.gutter || 0,
    tileGrid: r,
    projection: s,
    attributions: e.olAttribution
  }));
}
function ON(e, t = {}, n) {
  const s = qP(e, n), r = e.singleTile ? Uf : Zc;
  return s.set("olcs.projection", Wt(TN)), new r(Object.assign({
    source: s,
    minResolution: e.minScale,
    maxResolution: e.maxScale,
    id: e.id
  }, t));
}
function PN(e) {
  const t = e.getSource().getParams().SESSIONID;
  let n = t;
  for (; t === n; )
    n = l0();
  return e.getSource().updateParams({ SESSIONID: n }), n;
}
function SN(e, t, n) {
  const s = ea({ Id: e.get("id") }), r = t.getView().getResolution(), i = t.getView().getProjection(), a = Object.assign({
    INFO_FORMAT: s && s.infoFormat || "text/xml"
  }, s && typeof s.featureCount < "u" ? { FEATURE_COUNT: s.featureCount } : {});
  return e.getSource().getFeatureInfoUrl(n, r, i, a);
}
const tS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addOptionalParams: JP,
  createLayer: ON,
  createLayerSource: qP,
  generateSessionId: l0,
  getGfiURL: SN,
  makeParams: QP,
  updateSource: PN
}, Symbol.toStringTag, { value: "Module" }));
class eS extends mu {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    super({
      extent: t.extent,
      origin: t.origin,
      origins: t.origins,
      resolutions: t.resolutions,
      tileSize: t.tileSize,
      tileSizes: t.tileSizes,
      sizes: t.sizes
    }), this.matrixIds_ = t.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(t) {
    return this.matrixIds_[t];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
const MN = eS;
function _N(e, t, n) {
  const s = [], r = [], i = [], a = [], o = [];
  n = n !== void 0 ? n : [];
  const l = "SupportedCRS", f = "TileMatrix", d = "Identifier", u = "ScaleDenominator", c = "TopLeftCorner", h = "TileWidth", p = "TileHeight", g = e[l], m = Wt(g), v = m.getMetersPerUnit(), y = m.getAxisOrientation().substr(0, 2) == "ne";
  return e[f].sort(function(E, C) {
    return C[u] - E[u];
  }), e[f].forEach(function(E) {
    let C;
    if (n.length > 0 ? C = n.find(function(x) {
      return E[d] == x[f] ? !0 : E[d].includes(":") ? !1 : e[d] + ":" + E[d] === x[f];
    }) : C = !0, C) {
      r.push(E[d]);
      const x = E[u] * 28e-5 / v, b = E[h], P = E[p];
      y ? i.push([
        E[c][1],
        E[c][0]
      ]) : i.push(E[c]), s.push(x), a.push(
        b == P ? b : [b, P]
      ), o.push([E.MatrixWidth, E.MatrixHeight]);
    }
  }), new eS({
    extent: t,
    origins: i,
    resolutions: s,
    matrixIds: r,
    tileSizes: a,
    sizes: o
  });
}
class IN extends r0 {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(t) {
    const n = t.requestEncoding !== void 0 ? t.requestEncoding : "KVP", s = t.tileGrid;
    let r = t.urls;
    r === void 0 && t.url !== void 0 && (r = YP(t.url)), super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      crossOrigin: t.crossOrigin,
      interpolate: t.interpolate,
      projection: t.projection,
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      tileClass: t.tileClass,
      tileGrid: s,
      tileLoadFunction: t.tileLoadFunction,
      tilePixelRatio: t.tilePixelRatio,
      urls: r,
      wrapX: t.wrapX !== void 0 ? t.wrapX : !1,
      transition: t.transition,
      zDirection: t.zDirection
    }), this.version_ = t.version !== void 0 ? t.version : "1.0.0", this.format_ = t.format !== void 0 ? t.format : "image/jpeg", this.dimensions_ = t.dimensions !== void 0 ? t.dimensions : {}, this.layer_ = t.layer, this.matrixSet_ = t.matrixSet, this.style_ = t.style, this.requestEncoding_ = n, this.setKey(this.getKeyForDimensions_()), r && r.length > 0 && (this.tileUrlFunction = nv(
      r.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(t) {
    this.urls = t;
    const n = t.join(`
`);
    this.setTileUrlFunction(
      nv(
        t.map(this.createFromWMTSTemplate.bind(this))
      ),
      n
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    let t = 0;
    const n = [];
    for (const s in this.dimensions_)
      n[t++] = s + "-" + this.dimensions_[s];
    return n.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(t) {
    Object.assign(this.dimensions_, t), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(t) {
    const n = this.requestEncoding_, s = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    n == "KVP" && Object.assign(s, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), t = n == "KVP" ? su(t, s) : t.replace(/\{(\w+?)\}/g, function(a, o) {
      return o.toLowerCase() in s ? s[o.toLowerCase()] : a;
    });
    const r = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), i = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(a, o, l) {
        if (a) {
          const f = {
            TileMatrix: r.getMatrixId(a[0]),
            TileCol: a[1],
            TileRow: a[2]
          };
          Object.assign(f, i);
          let d = t;
          return n == "KVP" ? d = su(d, f) : d = d.replace(/\{(\w+?)\}/g, function(u, c) {
            return f[c];
          }), d;
        } else
          return;
      }
    );
  }
}
const zf = IN;
function DN(e, t) {
  const s = e.Contents.Layer.find(function(A) {
    return A.Identifier == t.layer;
  });
  if (!s)
    return null;
  const r = e.Contents.TileMatrixSet;
  let i;
  s.TileMatrixSetLink.length > 1 ? "projection" in t ? i = s.TileMatrixSetLink.findIndex(function(A) {
    const I = r.find(function(j) {
      return j.Identifier == A.TileMatrixSet;
    }).SupportedCRS, w = Wt(I), B = Wt(t.projection);
    return w && B ? mr(w, B) : I == t.projection;
  }) : i = s.TileMatrixSetLink.findIndex(function(A) {
    return A.TileMatrixSet == t.matrixSet;
  }) : i = 0, i < 0 && (i = 0);
  const a = (
    /** @type {string} */
    s.TileMatrixSetLink[i].TileMatrixSet
  ), o = (
    /** @type {Array<Object>} */
    s.TileMatrixSetLink[i].TileMatrixSetLimits
  );
  let l = (
    /** @type {string} */
    s.Format[0]
  );
  "format" in t && (l = t.format), i = s.Style.findIndex(function(A) {
    return "style" in t ? A.Title == t.style : A.isDefault;
  }), i < 0 && (i = 0);
  const f = (
    /** @type {string} */
    s.Style[i].Identifier
  ), d = {};
  "Dimension" in s && s.Dimension.forEach(function(A, D, I) {
    const w = A.Identifier;
    let B = A.Default;
    B === void 0 && (B = A.Value[0]), d[w] = B;
  });
  const c = e.Contents.TileMatrixSet.find(function(A) {
    return A.Identifier == a;
  });
  let h;
  const p = c.SupportedCRS;
  if (p && (h = Wt(p)), "projection" in t) {
    const A = Wt(t.projection);
    A && (!h || mr(A, h)) && (h = A);
  }
  let g = !1;
  const m = h.getAxisOrientation().substr(0, 2) == "ne";
  let v = c.TileMatrix[0], y = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: v.MatrixWidth - 1,
    MaxTileRow: v.MatrixHeight - 1
  };
  if (o) {
    y = o[o.length - 1];
    const A = c.TileMatrix.find(
      (D) => D.Identifier === y.TileMatrix || c.Identifier + ":" + D.Identifier === y.TileMatrix
    );
    A && (v = A);
  }
  const E = v.ScaleDenominator * 28e-5 / h.getMetersPerUnit(), C = m ? [v.TopLeftCorner[1], v.TopLeftCorner[0]] : v.TopLeftCorner, x = v.TileWidth * E, b = v.TileHeight * E;
  let P = c.BoundingBox;
  P && m && (P = [
    P[1],
    P[0],
    P[3],
    P[2]
  ]);
  let O = [
    C[0] + x * y.MinTileCol,
    // add one to get proper bottom/right coordinate
    C[1] - b * (1 + y.MaxTileRow),
    C[0] + x * (1 + y.MaxTileCol),
    C[1] - b * y.MinTileRow
  ];
  if (P !== void 0 && !Rr(P, O)) {
    const A = s.WGS84BoundingBox, D = Wt("EPSG:4326").getExtent();
    if (O = P, A)
      g = A[0] === D[0] && A[2] === D[2];
    else {
      const I = Wc(
        P,
        c.SupportedCRS,
        "EPSG:4326"
      );
      g = I[0] - 1e-10 <= D[0] && I[2] + 1e-10 >= D[2];
    }
  }
  const T = _N(
    c,
    O,
    o
  ), M = [];
  let L = t.requestEncoding;
  if (L = L !== void 0 ? L : "", "OperationsMetadata" in e && "GetTile" in e.OperationsMetadata) {
    const A = e.OperationsMetadata.GetTile.DCP.HTTP.Get;
    for (let D = 0, I = A.length; D < I; ++D)
      if (A[D].Constraint) {
        const B = A[D].Constraint.find(function(j) {
          return j.name == "GetEncoding";
        }).AllowedValues.Value;
        if (L === "" && (L = B[0]), L === "KVP")
          B.includes("KVP") && M.push(
            /** @type {string} */
            A[D].href
          );
        else
          break;
      } else
        A[D].href && (L = "KVP", M.push(
          /** @type {string} */
          A[D].href
        ));
  }
  return M.length === 0 && (L = "REST", s.ResourceURL.forEach(function(A) {
    A.resourceType === "tile" && (l = A.format, M.push(
      /** @type {string} */
      A.template
    ));
  })), {
    urls: M,
    layer: t.layer,
    matrixSet: a,
    format: l,
    projection: h,
    requestEncoding: L,
    tileGrid: T,
    style: f,
    dimensions: d,
    wrapX: g,
    crossOrigin: t.crossOrigin
  };
}
const iv = "http://www.w3.org/2001/XMLSchema-instance";
function ue(e, t) {
  return sS().createElementNS(e, t);
}
function $o(e, t) {
  return nS(e, t, []).join("");
}
function nS(e, t, n) {
  if (e.nodeType == Node.CDATA_SECTION_NODE || e.nodeType == Node.TEXT_NODE)
    t ? n.push(String(e.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : n.push(e.nodeValue);
  else {
    let s;
    for (s = e.firstChild; s; s = s.nextSibling)
      nS(s, t, n);
  }
  return n;
}
function To(e) {
  return "documentElement" in e;
}
function AN(e, t, n) {
  return e.getAttributeNS(t, n) || "";
}
function Oo(e) {
  return new DOMParser().parseFromString(e, "application/xml");
}
function iS(e, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      if (r !== void 0) {
        const i = (
          /** @type {Array<*>} */
          s[s.length - 1]
        );
        Kn(i, r);
      }
    }
  );
}
function Ht(e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      r !== void 0 && /** @type {Array<*>} */
      s[s.length - 1].push(r);
    }
  );
}
function zt(e, t) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, s) {
      const r = e.call(
        t !== void 0 ? t : this,
        n,
        s
      );
      r !== void 0 && (s[s.length - 1] = r);
    }
  );
}
function ke(e, t, n) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(s, r) {
      const i = e.call(
        n !== void 0 ? n : this,
        s,
        r
      );
      if (i !== void 0) {
        const a = (
          /** @type {!Object} */
          r[r.length - 1]
        ), o = t !== void 0 ? t : s.localName;
        let l;
        o in a ? l = a[o] : (l = [], a[o] = l), l.push(i);
      }
    }
  );
}
function mt(e, t, n) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(s, r) {
      const i = e.call(
        n !== void 0 ? n : this,
        s,
        r
      );
      if (i !== void 0) {
        const a = (
          /** @type {!Object} */
          r[r.length - 1]
        ), o = t !== void 0 ? t : s.localName;
        a[o] = i;
      }
    }
  );
}
function gt(e, t) {
  return function(n, s, r) {
    e.call(
      t !== void 0 ? t : this,
      n,
      s,
      r
    ), /** @type {NodeStackItem} */
    r[r.length - 1].node.appendChild(n);
  };
}
function nr(e, t) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(n, s, r) {
      const a = /** @type {NodeStackItem} */ s[s.length - 1].node;
      let o = e;
      o === void 0 && (o = r);
      const l = t !== void 0 ? t : a.namespaceURI;
      return ue(
        l,
        /** @type {string} */
        o
      );
    }
  );
}
const rS = nr();
function qt(e, t, n) {
  n = n !== void 0 ? n : {};
  let s, r;
  for (s = 0, r = e.length; s < r; ++s)
    n[e[s]] = t;
  return n;
}
function Io(e, t, n, s) {
  let r;
  for (r = t.firstElementChild; r; r = r.nextElementSibling) {
    const i = e[r.namespaceURI];
    if (i !== void 0) {
      const a = i[r.localName];
      a !== void 0 && a.call(s, r, n);
    }
  }
}
function At(e, t, n, s, r) {
  return s.push(e), Io(t, n, s, r), /** @type {T} */
  s.pop();
}
function LN(e, t, n, s, r, i) {
  const a = (r !== void 0 ? r : n).length;
  let o, l;
  for (let f = 0; f < a; ++f)
    o = n[f], o !== void 0 && (l = t.call(
      i !== void 0 ? i : this,
      o,
      s,
      r !== void 0 ? r[f] : void 0
    ), l !== void 0 && e[l.namespaceURI][l.localName].call(
      i,
      l,
      o,
      s
    ));
}
function Cn(e, t, n, s, r, i, a) {
  return r.push(e), LN(t, n, s, r, i, a), /** @type {O|undefined} */
  r.pop();
}
let Rp;
function RN() {
  return Rp === void 0 && typeof XMLSerializer < "u" && (Rp = new XMLSerializer()), Rp;
}
let wp;
function sS() {
  return wp === void 0 && typeof document < "u" && (wp = document.implementation.createDocument("", "", null)), wp;
}
class wN {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object} An object representing the source.
   * @api
   */
  read(t) {
    if (t)
      if (typeof t == "string") {
        const n = Oo(t);
        return this.readFromDocument(n);
      } else
        return To(t) ? this.readFromDocument(
          /** @type {Document} */
          t
        ) : this.readFromNode(
          /** @type {Element} */
          t
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @return {Object} Object
   */
  readFromDocument(t) {
    for (let n = t.firstChild; n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          n
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
  }
}
const u0 = wN, VN = "http://www.w3.org/1999/xlink";
function gu(e) {
  return e.getAttributeNS(VN, "href");
}
function Kl(e) {
  const t = /^\s*(true|1)|(false|0)\s*$/.exec(e);
  if (t)
    return t[1] !== void 0 || !1;
}
function Po(e) {
  const t = $o(e, !1);
  return Ws(t);
}
function Ws(e) {
  const t = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(e);
  if (t)
    return parseFloat(t[1]);
}
function qn(e) {
  const t = $o(e, !1);
  return Gs(t);
}
function Gs(e) {
  const t = /^\s*(\d+)\s*$/.exec(e);
  if (t)
    return parseInt(t[1], 10);
}
function Nt(e) {
  return $o(e, !1).trim();
}
function Rn(e, t) {
  e.appendChild(sS().createTextNode(t));
}
const Ki = [null, "http://www.opengis.net/ows/1.1"], BN = qt(Ki, {
  ServiceIdentification: mt(oj),
  ServiceProvider: mt(uj),
  OperationsMetadata: mt(sj)
});
class FN extends u0 {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    const n = At({}, BN, t, []);
    return n || null;
  }
}
const NN = qt(Ki, {
  DeliveryPoint: mt(Nt),
  City: mt(Nt),
  AdministrativeArea: mt(Nt),
  PostalCode: mt(Nt),
  Country: mt(Nt),
  ElectronicMailAddress: mt(Nt)
}), jN = qt(Ki, {
  Value: ke(cj)
}), $N = qt(Ki, {
  AllowedValues: mt(QN)
}), UN = qt(Ki, {
  Phone: mt(aj),
  Address: mt(JN)
}), WN = qt(Ki, {
  HTTP: mt(ij)
}), zN = qt(Ki, {
  Get: ke(nj),
  Post: void 0
  // TODO
}), KN = qt(Ki, {
  DCP: mt(ej)
}), GN = qt(Ki, {
  Operation: rj
}), kN = qt(Ki, {
  Voice: mt(Nt),
  Facsimile: mt(Nt)
}), HN = qt(Ki, {
  Constraint: ke(qN)
}), YN = qt(Ki, {
  IndividualName: mt(Nt),
  PositionName: mt(Nt),
  ContactInfo: mt(tj)
}), XN = qt(Ki, {
  Abstract: mt(Nt),
  AccessConstraints: mt(Nt),
  Fees: mt(Nt),
  Title: mt(Nt),
  ServiceTypeVersion: mt(Nt),
  ServiceType: mt(Nt)
}), ZN = qt(Ki, {
  ProviderName: mt(Nt),
  ProviderSite: mt(gu),
  ServiceContact: mt(lj)
});
function JN(e, t) {
  return At({}, NN, e, t);
}
function QN(e, t) {
  return At({}, jN, e, t);
}
function qN(e, t) {
  const n = e.getAttribute("name");
  if (n)
    return At({ name: n }, $N, e, t);
}
function tj(e, t) {
  return At({}, UN, e, t);
}
function ej(e, t) {
  return At({}, WN, e, t);
}
function nj(e, t) {
  const n = gu(e);
  if (n)
    return At(
      { href: n },
      HN,
      e,
      t
    );
}
function ij(e, t) {
  return At({}, zN, e, t);
}
function rj(e, t) {
  const n = e.getAttribute("name"), s = At({}, KN, e, t);
  if (!s)
    return;
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  );
  r[n] = s;
}
function sj(e, t) {
  return At({}, GN, e, t);
}
function aj(e, t) {
  return At({}, kN, e, t);
}
function oj(e, t) {
  return At({}, XN, e, t);
}
function lj(e, t) {
  return At({}, YN, e, t);
}
function uj(e, t) {
  return At({}, ZN, e, t);
}
function cj(e, t) {
  return Nt(e);
}
const hj = FN, Ts = [null, "http://www.opengis.net/wmts/1.0"], vu = [null, "http://www.opengis.net/ows/1.1"], dj = qt(Ts, {
  Contents: mt(Oj)
});
class fj extends u0 {
  constructor() {
    super(), this.owsParser_ = new hj();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    let n = t.getAttribute("version");
    n && (n = n.trim());
    let s = this.owsParser_.readFromNode(t);
    return s ? (s.version = n, s = At(
      s,
      dj,
      t,
      []
    ), s || null) : null;
  }
}
const pj = qt(Ts, {
  Layer: ke(Pj),
  TileMatrixSet: ke(Sj)
}), mj = qt(
  Ts,
  {
    Style: ke(Mj),
    Format: ke(Nt),
    TileMatrixSetLink: ke(_j),
    Dimension: ke(Ij),
    ResourceURL: ke(Dj)
  },
  qt(vu, {
    Title: mt(Nt),
    Abstract: mt(Nt),
    WGS84BoundingBox: mt(aS),
    Identifier: mt(Nt)
  })
), gj = qt(
  Ts,
  {
    LegendURL: ke(Aj)
  },
  qt(vu, {
    Title: mt(Nt),
    Identifier: mt(Nt)
  })
), vj = qt(Ts, {
  TileMatrixSet: mt(Nt),
  TileMatrixSetLimits: mt(Rj)
}), yj = qt(Ts, {
  TileMatrixLimits: Ht(wj)
}), Ej = qt(Ts, {
  TileMatrix: mt(Nt),
  MinTileRow: mt(qn),
  MaxTileRow: mt(qn),
  MinTileCol: mt(qn),
  MaxTileCol: mt(qn)
}), Cj = qt(
  Ts,
  {
    Default: mt(Nt),
    Value: ke(Nt)
  },
  qt(vu, {
    Identifier: mt(Nt)
  })
), xj = qt(vu, {
  LowerCorner: Ht(rv),
  UpperCorner: Ht(rv)
}), bj = qt(
  Ts,
  {
    WellKnownScaleSet: mt(Nt),
    TileMatrix: ke(Lj)
  },
  qt(vu, {
    SupportedCRS: mt(Nt),
    Identifier: mt(Nt),
    BoundingBox: mt(aS)
  })
), Tj = qt(
  Ts,
  {
    TopLeftCorner: mt(rv),
    ScaleDenominator: mt(Po),
    TileWidth: mt(qn),
    TileHeight: mt(qn),
    MatrixWidth: mt(qn),
    MatrixHeight: mt(qn)
  },
  qt(vu, {
    Identifier: mt(Nt)
  })
);
function Oj(e, t) {
  return At({}, pj, e, t);
}
function Pj(e, t) {
  return At({}, mj, e, t);
}
function Sj(e, t) {
  return At({}, bj, e, t);
}
function Mj(e, t) {
  const n = At({}, gj, e, t);
  if (!n)
    return;
  const s = e.getAttribute("isDefault") === "true";
  return n.isDefault = s, n;
}
function _j(e, t) {
  return At({}, vj, e, t);
}
function Ij(e, t) {
  return At({}, Cj, e, t);
}
function Dj(e, t) {
  const n = e.getAttribute("format"), s = e.getAttribute("template"), r = e.getAttribute("resourceType"), i = {};
  return n && (i.format = n), s && (i.template = s), r && (i.resourceType = r), i;
}
function aS(e, t) {
  const n = At(
    [],
    xj,
    e,
    t
  );
  if (n.length == 2)
    return Jl(n);
}
function Aj(e, t) {
  const n = {};
  return n.format = e.getAttribute("format"), n.href = gu(e), n;
}
function rv(e, t) {
  const n = Nt(e).split(/\s+/);
  if (!n || n.length != 2)
    return;
  const s = +n[0], r = +n[1];
  if (!(isNaN(s) || isNaN(r)))
    return [s, r];
}
function Lj(e, t) {
  return At({}, Tj, e, t);
}
function Rj(e, t) {
  return At([], yj, e, t);
}
function wj(e, t) {
  return At({}, Ej, e, t);
}
const Vj = fj;
function zd(e, t) {
  console.error("content: Layer " + t + ": " + e);
}
function oS(e, t, n, s) {
  for (let r = 0; r < n; ++r)
    e[r] = s / Math.pow(2, r), t[r] = r;
}
function lS(e) {
  return fetch(e).then((t) => {
    if (t && t.status === 200)
      return t.text();
    throw console.error(t), new Error(`Failing WMTS request to ${e}. Status: ${t == null ? void 0 : t.status}`);
  }).then((t) => new Vj().read(t));
}
function uS(e, t) {
  const n = Wt(e.coordinateSystem), s = n.getExtent(), r = e.style, i = e.format, a = e.wrapX ? e.wrapX : !1, o = e.urls, l = s ? Ee(s) / parseInt(e.tileSize, 10) : null, f = parseInt(e.resLength, 10), d = new Array(f), u = new Array(f), c = new zf({
    projection: n,
    attributions: e.olAttribution,
    tileGrid: new MN({
      origin: e.origin,
      resolutions: d,
      matrixIds: u,
      tileSize: e.tileSize
    }),
    tilePixelRatio: Mf,
    urls: o,
    matrixSet: e.tileMatrixSet,
    matrixSizes: e.matrixSizes,
    layer: e.layers,
    format: i,
    style: r,
    version: e.version,
    transparent: e.transparent.toString(),
    wrapX: a,
    requestEncoding: e.requestEncoding,
    scales: e.scales
  });
  l ? oS(d, u, f, l) : zd(e.name, `${n.getCode()} has been given as projection to wmts.js for layer with id ${e.id}, but only "EPSG:4326" and "EPSG:3857" are supported. Please use the "capabilitiesUrl" and "optionsFromCapabilities" configuration parameters on this layer.`), c.matrixSizes = e.matrixSizes, c.scales = e.scales, t.setSource(c), t.getSource().refresh();
}
function cS(e, t) {
  const n = e.layers, s = e.capabilitiesUrl, r = e.tileMatrixSet, i = {
    layer: n
  };
  r && r.length > 0 ? i.matrixSet = r : i.projection = "EPSG:3857", lS(s).then((a) => {
    const o = DN(a, i), l = a.Contents.TileMatrixSet.filter((u) => u.Identifier === o.matrixSet)[0], f = [], d = [];
    if (l.TileMatrix.forEach(({ MatrixHeight: u, MatrixWidth: c, ScaleDenominator: h }) => {
      f.push([c, u]), d.push(h);
    }), o !== null) {
      const u = new zf(o);
      u.matrixSizes = f, u.scales = d, t.set("options", o), t.setSource(u), t.getSource().refresh();
    } else {
      const u = "Cannot get options from WMTS-Capabilities";
      throw zd(u, e.name || e.id), new Error(u);
    }
  }).catch((a) => {
    a !== "Fetch error" && zd(a, e.name || e.id);
  });
}
function Bj(e) {
  const t = new Zc({
    id: e.id,
    source: new zf({}),
    name: e.name,
    minResolution: e.minScale,
    maxResolution: e.maxScale,
    supported: ["2D", "3D"],
    showSettings: !0,
    extent: null,
    typ: e.typ,
    legendURL: e.legendURL,
    infoFormat: e.infoFormat
  });
  return e.optionsFromCapabilities === void 0 ? uS(e, t) : cS(e, t), t;
}
const hS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: Bj,
  createLayerSourceByCapabilities: cS,
  createLayerSourceByDefinitions: uS,
  generateArrays: oS,
  getWMTSCapabilities: lS,
  showErrorMessage: zd
}, Symbol.toStringTag, { value: "Module" }));
class Fj {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(t, n) {
    if (n) {
      let s = n.dataProjection ? Wt(n.dataProjection) : this.readProjection(t);
      n.extent && s && s.getUnits() === "tile-pixels" && (s = Wt(s), s.setWorldExtent(n.extent)), n = {
        dataProjection: s,
        featureProjection: n.featureProjection
      };
    }
    return this.adaptOptions(n);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(t) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection
      },
      t
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return Gt();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */
  readFeature(t, n) {
    return Gt();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  readFeatures(t, n) {
    return Gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(t, n) {
    return Gt();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(t) {
    return Gt();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(t, n) {
    return Gt();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(t, n) {
    return Gt();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(t, n) {
    return Gt();
  }
}
const c0 = Fj;
function yu(e, t, n) {
  const s = n ? Wt(n.featureProjection) : null, r = n ? Wt(n.dataProjection) : null;
  let i;
  if (s && r && !mr(s, r) ? i = (t ? e.clone() : e).transform(
    t ? s : r,
    t ? r : s
  ) : i = e, t && n && /** @type {WriteOptions} */
  n.decimals !== void 0) {
    const a = Math.pow(
      10,
      /** @type {WriteOptions} */
      n.decimals
    ), o = function(l) {
      for (let f = 0, d = l.length; f < d; ++f)
        l[f] = Math.round(l[f] * a) / a;
      return l;
    };
    i === e && (i = e.clone()), i.applyTransform(o);
  }
  return i;
}
function h0(e, t) {
  const n = t ? Wt(t.featureProjection) : null, s = t ? Wt(t.dataProjection) : null;
  return n && s && !mr(n, s) ? Wc(e, s, n) : e;
}
class Nj extends c0 {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(t, n) {
    return this.readFeatureFromObject(
      Ph(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(t, n) {
    return this.readFeaturesFromObject(
      Ph(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(t, n) {
    return Gt();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(t, n) {
    return Gt();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(t, n) {
    return this.readGeometryFromObject(
      Ph(t),
      this.getReadOptions(t, n)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(t, n) {
    return Gt();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    return this.readProjectionFromObject(Ph(t));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(t) {
    return Gt();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(t, n) {
    return JSON.stringify(this.writeFeatureObject(t, n));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(t, n) {
    return Gt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(t, n) {
    return JSON.stringify(this.writeFeaturesObject(t, n));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(t, n) {
    return Gt();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(t, n) {
    return JSON.stringify(this.writeGeometryObject(t, n));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(t, n) {
    return Gt();
  }
}
function Ph(e) {
  if (typeof e == "string") {
    const t = JSON.parse(e);
    return t || null;
  } else
    return e !== null ? e : null;
}
const jj = Nj;
class Kd extends oa {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(t, n, s) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(t[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        t,
        n
      );
    else if (n !== void 0 && s)
      this.setFlatCoordinates(
        n,
        /** @type {Array<number>} */
        t
      ), this.ends_ = s;
    else {
      let r = this.getLayout();
      const i = (
        /** @type {Array<LineString>} */
        t
      ), a = [], o = [];
      for (let l = 0, f = i.length; l < f; ++l) {
        const d = i[l];
        l === 0 && (r = d.getLayout()), Kn(a, d.getFlatCoordinates()), o.push(a.length);
      }
      this.setFlatCoordinates(r, a), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const t = new Kd(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Qo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      py(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), gy(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(t, n, s) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (n = n !== void 0 ? n : !1, s = s !== void 0 ? s : !1, uA(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      n,
      s
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return uc(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(t) {
    return t < 0 || this.ends_.length <= t ? null : new er(
      this.flatCoordinates.slice(
        t === 0 ? 0 : this.ends_[t - 1],
        this.ends_[t]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const t = this.flatCoordinates, n = this.ends_, s = this.layout, r = [];
    let i = 0;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a], f = new er(
        t.slice(i, l),
        s
      );
      r.push(f), i = l;
    }
    return r;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const t = [], n = this.flatCoordinates;
    let s = 0;
    const r = this.ends_, i = this.stride;
    for (let a = 0, o = r.length; a < o; ++a) {
      const l = r[a], f = Od(
        n,
        s,
        l,
        i,
        0.5
      );
      Kn(t, f), s = l;
    }
    return t;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = YD(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t,
      n,
      0,
      s
    ), new Kd(n, "XY", s);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return eA(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const s = vy(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1], this.changed();
  }
}
const na = Kd;
class d0 extends oa {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n) {
    super(), n && !Array.isArray(t[0]) ? this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      t,
      n
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(t) {
    this.flatCoordinates ? Kn(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const t = new d0(
      this.flatCoordinates.slice(),
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    if (r < Qo(this.getExtent(), t, n))
      return r;
    const i = this.flatCoordinates, a = this.stride;
    for (let o = 0, l = i.length; o < l; o += a) {
      const f = Xs(
        t,
        n,
        i[o],
        i[o + 1]
      );
      if (f < r) {
        r = f;
        for (let d = 0; d < a; ++d)
          s[d] = i[o + d];
        s.length = a;
      }
    }
    return r;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return _a(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(t) {
    const n = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
    return t < 0 || n <= t ? null : new hi(
      this.flatCoordinates.slice(
        t * this.stride,
        (t + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const t = this.flatCoordinates, n = this.layout, s = this.stride, r = [];
    for (let i = 0, a = t.length; i < a; i += s) {
      const o = new hi(t.slice(i, i + s), n);
      r.push(o);
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.flatCoordinates, s = this.stride;
    for (let r = 0, i = n.length; r < i; r += s) {
      const a = n[r], o = n[r + 1];
      if (ny(t, a, o))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = wf(
      this.flatCoordinates,
      0,
      t,
      this.stride
    ), this.changed();
  }
}
const Eu = d0;
function dS(e, t, n, s) {
  const r = [];
  let i = ji();
  for (let a = 0, o = n.length; a < o; ++a) {
    const l = n[a];
    i = ry(
      e,
      t,
      l[0],
      s
    ), r.push((i[0] + i[2]) / 2, (i[1] + i[3]) / 2), t = l[l.length - 1];
  }
  return r;
}
class Gd extends oa {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(t, n, s) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !s && !Array.isArray(t[0])) {
      let r = this.getLayout();
      const i = (
        /** @type {Array<Polygon>} */
        t
      ), a = [], o = [];
      for (let l = 0, f = i.length; l < f; ++l) {
        const d = i[l];
        l === 0 && (r = d.getLayout());
        const u = a.length, c = d.getEnds();
        for (let h = 0, p = c.length; h < p; ++h)
          c[h] += u;
        Kn(a, d.getFlatCoordinates()), o.push(c);
      }
      n = r, t = a, s = o;
    }
    n !== void 0 && s ? (this.setFlatCoordinates(
      n,
      /** @type {Array<number>} */
      t
    ), this.endss_ = s) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      t,
      n
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(t) {
    let n;
    if (!this.flatCoordinates)
      this.flatCoordinates = t.getFlatCoordinates().slice(), n = t.getEnds().slice(), this.endss_.push();
    else {
      const s = this.flatCoordinates.length;
      Kn(this.flatCoordinates, t.getFlatCoordinates()), n = t.getEnds().slice();
      for (let r = 0, i = n.length; r < i; ++r)
        n[r] += s;
    }
    this.endss_.push(n), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const t = this.endss_.length, n = new Array(t);
    for (let r = 0; r < t; ++r)
      n[r] = this.endss_[r].slice();
    const s = new Gd(
      this.flatCoordinates.slice(),
      this.layout,
      n
    );
    return s.applyProperties(this), s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    return r < Qo(this.getExtent(), t, n) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      GD(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), kD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      t,
      n,
      s,
      r
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    return tA(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t,
      n
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return JD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(t) {
    let n;
    return t !== void 0 ? (n = this.getOrientedFlatCoordinates().slice(), XE(
      n,
      0,
      this.endss_,
      this.stride,
      t
    )) : n = this.flatCoordinates, Ng(
      n,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const t = dS(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = C1(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new Eu(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const t = this.flatCoordinates;
      rA(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = XE(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(t) {
    const n = [], s = [];
    return n.length = ZD(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(t),
      n,
      0,
      s
    ), new Gd(n, "XY", s);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(t) {
    if (t < 0 || this.endss_.length <= t)
      return null;
    let n;
    if (t === 0)
      n = 0;
    else {
      const i = this.endss_[t - 1];
      n = i[i.length - 1];
    }
    const s = this.endss_[t].slice(), r = s[s.length - 1];
    if (n !== 0)
      for (let i = 0, a = s.length; i < a; ++i)
        s[i] -= n;
    return new rr(
      this.flatCoordinates.slice(n, r),
      this.layout,
      s
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const t = this.layout, n = this.flatCoordinates, s = this.endss_, r = [];
    let i = 0;
    for (let a = 0, o = s.length; a < o; ++a) {
      const l = s[a].slice(), f = l[l.length - 1];
      if (i !== 0)
        for (let u = 0, c = l.length; u < c; ++u)
          l[u] -= i;
      const d = new rr(
        n.slice(i, f),
        t,
        l
      );
      r.push(d), i = f;
    }
    return r;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    return nA(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      t
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(t, n) {
    this.setLayout(n, t, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const s = HD(
      this.flatCoordinates,
      0,
      t,
      this.stride,
      this.endss_
    );
    if (s.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const r = s[s.length - 1];
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1];
    }
    this.changed();
  }
}
const ia = Gd;
class kd extends Cd {
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  constructor(t) {
    super(), this.geometries_ = t || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(Ue), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    if (this.geometries_)
      for (let t = 0, n = this.geometries_.length; t < n; ++t)
        this.changeEventsKeys_.push(
          ve(this.geometries_[t], Kt.CHANGE, this.changed, this)
        );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const t = new kd(null);
    return t.setGeometries(this.geometries_), t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    if (r < Qo(this.getExtent(), t, n))
      return r;
    const i = this.geometries_;
    for (let a = 0, o = i.length; a < o; ++a)
      r = i[a].closestPointXY(
        t,
        n,
        s,
        r
      );
    return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      if (s[r].containsXY(t, n))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    $c(t);
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      n1(t, n[s].getExtent());
    return t;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return KC(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let t = [];
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      n[s].getType() === this.getType() ? t = t.concat(
        /** @type {GeometryCollection} */
        n[s].getGeometriesArrayRecursive()
      ) : t.push(n[s]);
    return t;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(t) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && t < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const n = [], s = this.geometries_;
    let r = !1;
    for (let i = 0, a = s.length; i < a; ++i) {
      const o = s[i], l = o.getSimplifiedGeometry(t);
      n.push(l), l !== o && (r = !0);
    }
    if (r) {
      const i = new kd(null);
      return i.setGeometriesArray(n), i;
    } else
      return this.simplifiedGeometryMaxMinSquaredTolerance = t, this;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      if (n[s].intersectsExtent(t))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r].rotate(t, n);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(t, n, s) {
    s || (s = $i(this.getExtent()));
    const r = this.geometries_;
    for (let i = 0, a = r.length; i < a; ++i)
      r[i].scale(t, n, s);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(t) {
    this.setGeometriesArray(KC(t));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(t) {
    this.unlistenGeometriesChange_(), this.geometries_ = t, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(t) {
    const n = this.geometries_;
    for (let s = 0, r = n.length; s < r; ++s)
      n[s].applyTransform(t);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.geometries_;
    for (let r = 0, i = s.length; r < i; ++r)
      s[r].translate(t, n);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function KC(e) {
  const t = [];
  for (let n = 0, s = e.length; n < s; ++n)
    t.push(e[n].clone());
  return t;
}
const fS = kd;
class $j extends jj {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(), this.dataProjection = Wt(
      t.dataProjection ? t.dataProjection : "EPSG:4326"
    ), t.featureProjection && (this.defaultFeatureProjection = Wt(t.featureProjection)), this.geometryName_ = t.geometryName, this.extractGeometryName_ = t.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(t, n) {
    let s = null;
    t.type === "Feature" ? s = /** @type {GeoJSONFeature} */
    t : s = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        t
      ),
      properties: null
    };
    const r = sv(s.geometry, n), i = new Pi();
    return this.geometryName_ ? i.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in s !== void 0 && i.setGeometryName(s.geometry_name), i.setGeometry(r), "id" in s && i.setId(s.id), s.properties && i.setProperties(s.properties, !0), i;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(t, n) {
    const s = (
      /** @type {GeoJSONObject} */
      t
    );
    let r = null;
    if (s.type === "FeatureCollection") {
      const i = (
        /** @type {GeoJSONFeatureCollection} */
        t
      );
      r = [];
      const a = i.features;
      for (let o = 0, l = a.length; o < l; ++o)
        r.push(this.readFeatureFromObject(a[o], n));
    } else
      r = [this.readFeatureFromObject(t, n)];
    return r;
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(t, n) {
    return sv(t, n);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(t) {
    const n = t.crs;
    let s;
    return n ? n.type == "name" ? s = Wt(n.properties.name) : n.type === "EPSG" ? s = Wt("EPSG:" + n.properties.code) : Zt(!1, 36) : s = this.dataProjection, /** @type {import("../proj/Projection.js").default} */
    s;
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(t, n) {
    n = this.adaptOptions(n);
    const s = {
      type: "Feature",
      geometry: null,
      properties: null
    }, r = t.getId();
    if (r !== void 0 && (s.id = r), !t.hasProperties())
      return s;
    const i = t.getProperties(), a = t.getGeometry();
    return a && (s.geometry = av(a, n), delete i[t.getGeometryName()]), Bo(i) || (s.properties = i), s;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(t, n) {
    n = this.adaptOptions(n);
    const s = [];
    for (let r = 0, i = t.length; r < i; ++r)
      s.push(this.writeFeatureObject(t[r], n));
    return {
      type: "FeatureCollection",
      features: s
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(t, n) {
    return av(t, this.adaptOptions(n));
  }
}
function sv(e, t) {
  if (!e)
    return null;
  let n;
  switch (e.type) {
    case "Point": {
      n = Wj(
        /** @type {GeoJSONPoint} */
        e
      );
      break;
    }
    case "LineString": {
      n = zj(
        /** @type {GeoJSONLineString} */
        e
      );
      break;
    }
    case "Polygon": {
      n = Hj(
        /** @type {GeoJSONPolygon} */
        e
      );
      break;
    }
    case "MultiPoint": {
      n = Gj(
        /** @type {GeoJSONMultiPoint} */
        e
      );
      break;
    }
    case "MultiLineString": {
      n = Kj(
        /** @type {GeoJSONMultiLineString} */
        e
      );
      break;
    }
    case "MultiPolygon": {
      n = kj(
        /** @type {GeoJSONMultiPolygon} */
        e
      );
      break;
    }
    case "GeometryCollection": {
      n = Uj(
        /** @type {GeoJSONGeometryCollection} */
        e
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + e.type);
  }
  return yu(n, !1, t);
}
function Uj(e, t) {
  const n = e.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function(s) {
      return sv(s, t);
    }
  );
  return new fS(n);
}
function Wj(e) {
  return new hi(e.coordinates);
}
function zj(e) {
  return new er(e.coordinates);
}
function Kj(e) {
  return new na(e.coordinates);
}
function Gj(e) {
  return new Eu(e.coordinates);
}
function kj(e) {
  return new ia(e.coordinates);
}
function Hj(e) {
  return new rr(e.coordinates);
}
function av(e, t) {
  e = yu(e, !0, t);
  const n = e.getType();
  let s;
  switch (n) {
    case "Point": {
      s = qj(
        /** @type {Point} */
        e
      );
      break;
    }
    case "LineString": {
      s = Xj(
        /** @type {LineString} */
        e
      );
      break;
    }
    case "Polygon": {
      s = t$(
        /** @type {Polygon} */
        e,
        t
      );
      break;
    }
    case "MultiPoint": {
      s = Jj(
        /** @type {MultiPoint} */
        e
      );
      break;
    }
    case "MultiLineString": {
      s = Zj(
        /** @type {MultiLineString} */
        e
      );
      break;
    }
    case "MultiPolygon": {
      s = Qj(
        /** @type {MultiPolygon} */
        e,
        t
      );
      break;
    }
    case "GeometryCollection": {
      s = Yj(
        /** @type {GeometryCollection} */
        e,
        t
      );
      break;
    }
    case "Circle": {
      s = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + n);
  }
  return s;
}
function Yj(e, t) {
  return t = Object.assign({}, t), delete t.featureProjection, {
    type: "GeometryCollection",
    geometries: e.getGeometriesArray().map(function(s) {
      return av(s, t);
    })
  };
}
function Xj(e, t) {
  return {
    type: "LineString",
    coordinates: e.getCoordinates()
  };
}
function Zj(e, t) {
  return {
    type: "MultiLineString",
    coordinates: e.getCoordinates()
  };
}
function Jj(e, t) {
  return {
    type: "MultiPoint",
    coordinates: e.getCoordinates()
  };
}
function Qj(e, t) {
  let n;
  return t && (n = t.rightHanded), {
    type: "MultiPolygon",
    coordinates: e.getCoordinates(n)
  };
}
function qj(e, t) {
  return {
    type: "Point",
    coordinates: e.getCoordinates()
  };
}
function t$(e, t) {
  let n;
  return t && (n = t.rightHanded), {
    type: "Polygon",
    coordinates: e.getCoordinates(n)
  };
}
const Wr = $j;
class e$ extends c0 {
  constructor() {
    super(), this.xmlSerializer_ = RN();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = Oo(t);
        return this.readFeatureFromDocument(s, n);
      } else
        return To(t) ? this.readFeatureFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readFeatureFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(t, n) {
    const s = this.readFeaturesFromDocument(t, n);
    return s.length > 0 ? s[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(t, n) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = Oo(t);
        return this.readFeaturesFromDocument(s, n);
      } else
        return To(t) ? this.readFeaturesFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readFeaturesFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return [];
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(t, n) {
    const s = [];
    for (let r = t.firstChild; r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && Kn(
        s,
        this.readFeaturesFromNode(
          /** @type {Element} */
          r,
          n
        )
      );
    return s;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    return Gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(t, n) {
    if (t)
      if (typeof t == "string") {
        const s = Oo(t);
        return this.readGeometryFromDocument(s, n);
      } else
        return To(t) ? this.readGeometryFromDocument(
          /** @type {Document} */
          t,
          n
        ) : this.readGeometryFromNode(
          /** @type {Element} */
          t,
          n
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(t, n) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(t, n) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    if (t)
      if (typeof t == "string") {
        const n = Oo(t);
        return this.readProjectionFromDocument(n);
      } else
        return To(t) ? this.readProjectionFromDocument(
          /** @type {Document} */
          t
        ) : this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    else
      return null;
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(t) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(t, n) {
    const s = this.writeFeatureNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(t, n) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(t, n) {
    const s = this.writeFeaturesNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(t, n) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(t, n) {
    const s = this.writeGeometryNode(t, n);
    return this.xmlSerializer_.serializeToString(s);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(t, n) {
    return null;
  }
}
const pS = e$, Js = "http://www.opengis.net/gml", n$ = /^\s*$/;
class xn extends pS {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(t) {
    super(), t = t || {}, this.featureType = t.featureType, this.featureNS = t.featureNS, this.srsName = t.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: Ht(this.readFeaturesInternal),
      featureMembers: zt(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(t, n) {
    const s = t.localName;
    let r = null;
    if (s == "FeatureCollection")
      r = At(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        t,
        n,
        this
      );
    else if (s == "featureMembers" || s == "featureMember" || s == "member") {
      const i = n[0];
      let a = i.featureType, o = i.featureNS;
      const l = "p", f = "p0";
      if (!a && t.childNodes) {
        a = [], o = {};
        for (let c = 0, h = t.childNodes.length; c < h; ++c) {
          const p = (
            /** @type {Element} */
            t.childNodes[c]
          );
          if (p.nodeType === 1) {
            const g = p.nodeName.split(":").pop();
            if (!a.includes(g)) {
              let m = "", v = 0;
              const y = p.namespaceURI;
              for (const E in o) {
                if (o[E] === y) {
                  m = E;
                  break;
                }
                ++v;
              }
              m || (m = l + v, o[m] = y), a.push(m + ":" + g);
            }
          }
        }
        s != "featureMember" && (i.featureType = a, i.featureNS = o);
      }
      if (typeof o == "string") {
        const c = o;
        o = {}, o[f] = c;
      }
      const d = {}, u = Array.isArray(a) ? a : [a];
      for (const c in o) {
        const h = {};
        for (let p = 0, g = u.length; p < g; ++p)
          (u[p].includes(":") ? u[p].split(":")[0] : f) === c && (h[u[p].split(":").pop()] = s == "featureMembers" ? Ht(this.readFeatureElement, this) : zt(this.readFeatureElement, this));
        d[o[c]] = h;
      }
      s == "featureMember" || s == "member" ? r = At(void 0, d, t, n) : r = At([], d, t, n);
    }
    return r === null && (r = []), r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    );
    return s.srsName = t.firstElementChild.getAttribute("srsName"), s.srsDimension = t.firstElementChild.getAttribute("srsDimension"), At(
      null,
      this.GEOMETRY_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    ), r = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(t, n)
    );
    return r ? h0(r, s) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(t, n) {
    const s = (
      /** @type {Object} */
      n[0]
    ), r = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(t, n)
    );
    return r ? yu(r, !1, s) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(t, n, s) {
    let r;
    const i = {};
    for (let a = t.firstElementChild; a; a = a.nextElementSibling) {
      let o;
      const l = a.localName;
      a.childNodes.length === 0 || a.childNodes.length === 1 && (a.firstChild.nodeType === 3 || a.firstChild.nodeType === 4) ? (o = $o(a, !1), n$.test(o) && (o = void 0)) : (s && (o = l === "boundedBy" ? this.readExtentElement(a, n) : this.readGeometryElement(a, n)), o ? l !== "boundedBy" && (r = l) : o = this.readFeatureElementInternal(a, n, !1));
      const f = a.attributes.length;
      if (f > 0) {
        o = { _content_: o };
        for (let d = 0; d < f; d++) {
          const u = a.attributes[d].name;
          o[u] = a.attributes[d].value;
        }
      }
      i[l] ? (i[l] instanceof Array || (i[l] = [i[l]]), i[l].push(o)) : i[l] = o;
    }
    if (s) {
      const a = new Pi(i);
      r && a.setGeometryName(r);
      const o = t.getAttribute("fid") || AN(t, this.namespace, "id");
      return o && a.setId(o), a;
    } else
      return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(t, n) {
    return this.readFeatureElementInternal(t, n, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new hi(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(t, n) {
    const s = At(
      [],
      this.MULTIPOINT_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new Eu(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(t, n) {
    const s = At(
      [],
      this.MULTILINESTRING_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new na(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(t, n) {
    const s = At(
      [],
      this.MULTIPOLYGON_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new ia(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(t, n) {
    Io(this.POINTMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(t, n) {
    Io(this.LINESTRINGMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(t, n) {
    Io(this.POLYGONMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new er(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(t, n) {
    const s = At(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(t, n) {
    const s = this.readFlatCoordinatesFromNode(t, n);
    if (s)
      return new Td(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(t, n) {
    const s = At(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      t,
      n,
      this
    );
    if (s && s[0]) {
      const r = s[0], i = [r.length];
      let a, o;
      for (a = 1, o = s.length; a < o; ++a)
        Kn(r, s[a]), i.push(r.length);
      return new rr(r, "XYZ", i);
    } else
      return;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(t, n) {
    return At(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(t, n) {
    const s = this.readGeometryElement(t, [
      this.getReadOptions(t, n || {})
    ]);
    return s || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    const s = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return s && Object.assign(s, this.getReadOptions(t, n)), this.readFeaturesInternal(t, [s]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    return Wt(
      this.srsName ? this.srsName : t.firstElementChild.getAttribute("srsName")
    );
  }
}
xn.prototype.namespace = Js;
xn.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
xn.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
xn.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
xn.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: Ht(xn.prototype.pointMemberParser),
    pointMembers: Ht(xn.prototype.pointMemberParser)
  }
};
xn.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: Ht(
      xn.prototype.lineStringMemberParser
    ),
    lineStringMembers: Ht(
      xn.prototype.lineStringMemberParser
    )
  }
};
xn.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: Ht(xn.prototype.polygonMemberParser),
    polygonMembers: Ht(xn.prototype.polygonMemberParser)
  }
};
xn.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: Ht(xn.prototype.readFlatCoordinatesFromNode)
  }
};
xn.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: Ht(xn.prototype.readLineString)
  }
};
xn.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: Ht(xn.prototype.readPolygon)
  }
};
xn.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: zt(xn.prototype.readFlatLinearRing)
  }
};
const de = xn, i$ = Js + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", r$ = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class ye extends de {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.FEATURE_COLLECTION_PARSERS[Js].featureMember = Ht(
      this.readFeaturesInternal
    ), this.schemaLocation = t.schemaLocation ? t.schemaLocation : i$;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(t, n) {
    const s = $o(t, !1).replace(/^\s*|\s*$/g, ""), i = /** @type {import("../xml.js").NodeStackItem} */ n[0].srsName;
    let a = "enu";
    if (i) {
      const f = Wt(i);
      f && (a = f.getAxisOrientation());
    }
    const o = s.trim().split(/\s+/), l = [];
    for (let f = 0, d = o.length; f < d; f++) {
      const u = o[f].split(/,+/), c = parseFloat(u[0]), h = parseFloat(u[1]), p = u.length === 3 ? parseFloat(u[2]) : 0;
      a.substr(0, 2) === "en" ? l.push(c, h, p) : l.push(h, c, p);
    }
    return l;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(t, n) {
    const s = At(
      [null],
      this.BOX_PARSERS_,
      t,
      n,
      this
    );
    return ir(
      s[1][0],
      s[1][1],
      s[1][3],
      s[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    s && /** @type {Array<Array<number>>} */
    n[n.length - 1].push(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    if (s) {
      const r = (
        /** @type {Array<Array<number>>} */
        n[n.length - 1]
      );
      r[0] = s;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.multiSurface, a = r.surface, o = r.multiCurve;
    return Array.isArray(t) ? s = "Envelope" : (s = /** @type {import("../geom/Geometry.js").default} */
    t.getType(), s === "MultiPolygon" && i === !0 ? s = "MultiSurface" : s === "Polygon" && a === !0 ? s = "Surface" : s === "MultiLineString" && o === !0 && (s = "MultiCurve")), ue("http://www.opengis.net/gml", s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(t, n, s) {
    const r = n.getId();
    r && t.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const i = (
      /** @type {Object} */
      s[s.length - 1]
    ), a = i.featureNS, o = n.getGeometryName();
    i.serializers || (i.serializers = {}, i.serializers[a] = {});
    const l = [], f = [];
    if (n.hasProperties()) {
      const u = n.getProperties();
      for (const c in u) {
        const h = u[c];
        h !== null && (l.push(c), f.push(h), c == o || typeof /** @type {?} */
        h.getSimplifiedGeometry == "function" ? c in i.serializers[a] || (i.serializers[a][c] = gt(
          this.writeGeometryElement,
          this
        )) : c in i.serializers[a] || (i.serializers[a][c] = gt(Rn)));
      }
    }
    const d = Object.assign({}, i);
    d.node = t, Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      i.serializers,
      nr(void 0, a),
      f,
      s,
      l
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(t, n, s) {
    const i = s[s.length - 1].srsName;
    if (t.nodeName !== "LineStringSegment" && i && t.setAttribute("srsName", i), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
      const a = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(a), this.writeCoordinates_(a, n, s);
    } else if (t.nodeName === "Curve") {
      const a = ue(t.namespaceURI, "segments");
      t.appendChild(a), this.writeCurveSegments_(a, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeCurveOrLineString(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.curve;
    a && t.setAttribute("srsName", a);
    const l = n.getLineStrings();
    Cn(
      { node: t, hasZ: i, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(t, n, s) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      s[s.length - 1]
    ), i = Object.assign({}, r);
    i.node = t;
    let a;
    Array.isArray(n) ? a = h0(
      /** @type {import("../extent.js").Extent} */
      n,
      r
    ) : a = yu(
      /** @type {import("../geom/Geometry.js").default} */
      n,
      !0,
      r
    ), Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      i,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      s,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(t) {
    const n = ue(t, "coordinates");
    return n.setAttribute("decimal", "."), n.setAttribute("cs", ","), n.setAttribute("ts", " "), n;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = n.getCoordinates(), l = o.length, f = new Array(l);
    for (let d = 0; d < l; ++d) {
      const u = o[d];
      f[d] = this.getCoords_(u, a, i);
    }
    Rn(t, f.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(t, n, s) {
    const r = ue(t.namespaceURI, "LineStringSegment");
    t.appendChild(r), this.writeCurveOrLineString(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
      const o = n.getLinearRings();
      Cn(
        { node: t, hasZ: i, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        s,
        void 0,
        this
      );
    } else if (t.nodeName === "Surface") {
      const o = ue(t.namespaceURI, "patches");
      t.appendChild(o), this.writeSurfacePatches_(o, n, s);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.node, a = r.exteriorWritten;
    return a === void 0 && (r.exteriorWritten = !0), ue(
      i.namespaceURI,
      a !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(t, n, s) {
    const r = ue(t.namespaceURI, "PolygonPatch");
    t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(t, n, s) {
    const r = ue(t.namespaceURI, "LinearRing");
    t.appendChild(r), this.writeLinearRing(r, n, s);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(t, n, s) {
    let r = "enu";
    n && (r = Wt(n).getAxisOrientation());
    let i = r.substr(0, 2) === "en" ? t[0] + "," + t[1] : t[1] + "," + t[0];
    if (s) {
      const a = t[2] || 0;
      i += "," + a;
    }
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    a && t.setAttribute("srsName", a);
    const o = this.createCoordinatesNode_(t.namespaceURI);
    t.appendChild(o);
    const l = n.getCoordinates(), f = this.getCoords_(l, a, i);
    Rn(o, f);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    a && t.setAttribute("srsName", a);
    const o = n.getPoints();
    Cn(
      { node: t, hasZ: i, srsName: a },
      this.POINTMEMBER_SERIALIZERS,
      nr("pointMember"),
      o,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(t, n, s) {
    const r = ue(t.namespaceURI, "Point");
    t.appendChild(r), this.writePoint(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = this.createCoordinatesNode_(t.namespaceURI);
    t.appendChild(a), this.writeCoordinates_(a, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.surface;
    a && t.setAttribute("srsName", a);
    const l = n.getPolygons();
    Cn(
      { node: t, hasZ: i, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ["lowerCorner", "upperCorner"], o = [n[0] + " " + n[1], n[2] + " " + n[3]];
    Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: t },
      this.ENVELOPE_SERIALIZERS,
      rS,
      o,
      s,
      a,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1].node;
    return ue(
      "http://www.opengis.net/gml",
      r$[r.nodeName]
    );
  }
}
ye.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: zt(ye.prototype.readFlatCoordinates)
  }
};
ye.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: ye.prototype.innerBoundaryIsParser,
    outerBoundaryIs: ye.prototype.outerBoundaryIsParser
  }
};
ye.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: Ht(ye.prototype.readFlatCoordinates)
  }
};
ye.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: zt(de.prototype.readPoint),
    MultiPoint: zt(de.prototype.readMultiPoint),
    LineString: zt(de.prototype.readLineString),
    MultiLineString: zt(de.prototype.readMultiLineString),
    LinearRing: zt(de.prototype.readLinearRing),
    Polygon: zt(de.prototype.readPolygon),
    MultiPolygon: zt(de.prototype.readMultiPolygon),
    Box: zt(ye.prototype.readBox)
  }
};
ye.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: gt(ye.prototype.writeCurveOrLineString),
    MultiCurve: gt(ye.prototype.writeMultiCurveOrLineString),
    Point: gt(ye.prototype.writePoint),
    MultiPoint: gt(ye.prototype.writeMultiPoint),
    LineString: gt(ye.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      ye.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(ye.prototype.writeLinearRing),
    Polygon: gt(ye.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      ye.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(ye.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      ye.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(ye.prototype.writeEnvelope)
  }
};
ye.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: gt(
      ye.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      ye.prototype.writeLineStringOrCurveMember
    )
  }
};
ye.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: gt(ye.prototype.writeRing),
    innerBoundaryIs: gt(ye.prototype.writeRing)
  }
};
ye.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: gt(ye.prototype.writePointMember)
  }
};
ye.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: gt(
      ye.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      ye.prototype.writeSurfaceOrPolygonMember
    )
  }
};
ye.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: gt(Rn),
    upperCorner: gt(Rn)
  }
};
const el = ye, s$ = Js + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", a$ = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class jt extends de {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.surface_ = t.surface !== void 0 ? t.surface : !1, this.curve_ = t.curve !== void 0 ? t.curve : !1, this.multiCurve_ = t.multiCurve !== void 0 ? t.multiCurve : !0, this.multiSurface_ = t.multiSurface !== void 0 ? t.multiSurface : !0, this.schemaLocation = t.schemaLocation ? t.schemaLocation : s$, this.hasZ = t.hasZ !== void 0 ? t.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(t, n) {
    const s = At(
      [],
      this.MULTICURVE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new na(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(t, n) {
    const s = At(
      [],
      this.MULTICURVE_PARSERS,
      t,
      n,
      this
    ), r = [];
    for (let i = 0, a = s.length; i < a; ++i)
      Kn(r, s[i].getFlatCoordinates());
    return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(t, n) {
    const s = At(
      [],
      this.MULTISURFACE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new ia(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(t, n) {
    Io(this.CURVEMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(t, n) {
    Io(this.SURFACEMEMBER_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(t, n) {
    return At(
      [null],
      this.PATCHES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(t, n) {
    return At([], this.SEGMENTS_PARSERS, t, n, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(t, n) {
    return At(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(t, n) {
    return At(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      t,
      n,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    s && /** @type {Array<Array<number>>} */
    n[n.length - 1].push(s);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(t, n) {
    const s = At(
      void 0,
      this.RING_PARSERS,
      t,
      n,
      this
    );
    if (s) {
      const r = (
        /** @type {Array<Array<number>>} */
        n[n.length - 1]
      );
      r[0] = s;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(t, n) {
    const s = At(
      [null],
      this.SURFACE_PARSERS,
      t,
      n,
      this
    );
    if (s && s[0]) {
      const r = s[0], i = [r.length];
      let a, o;
      for (a = 1, o = s.length; a < o; ++a)
        Kn(r, s[a]), i.push(r.length);
      return new rr(r, "XYZ", i);
    } else
      return;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(t, n) {
    const s = At(
      [null],
      this.CURVE_PARSERS,
      t,
      n,
      this
    );
    if (s)
      return new er(s, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(t, n) {
    const s = At(
      [null],
      this.ENVELOPE_PARSERS,
      t,
      n,
      this
    );
    return ir(
      s[1][0],
      s[1][1],
      s[2][0],
      s[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(t, n) {
    let s = $o(t, !1);
    const r = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, i = [];
    let a;
    for (; a = r.exec(s); )
      i.push(parseFloat(a[1])), s = s.substr(a[0].length);
    if (s !== "")
      return;
    const l = n[0].srsName;
    let f = "enu";
    if (l && (f = Wt(l).getAxisOrientation()), f === "neu") {
      let u, c;
      for (u = 0, c = i.length; u < c; u += 3) {
        const h = i[u], p = i[u + 1];
        i[u] = p, i[u + 1] = h;
      }
    }
    const d = i.length;
    if (d == 2 && i.push(0), d !== 0)
      return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(t, n) {
    const s = $o(t, !1).replace(/^\s*|\s*$/g, ""), r = n[0], i = r.srsName, a = r.srsDimension;
    let o = "enu";
    i && (o = Wt(i).getAxisOrientation());
    const l = s.split(/\s+/);
    let f = 2;
    t.getAttribute("srsDimension") ? f = Gs(t.getAttribute("srsDimension")) : t.getAttribute("dimension") ? f = Gs(t.getAttribute("dimension")) : /** @type {Element} */ t.parentNode.getAttribute("srsDimension") ? f = Gs(
      /** @type {Element} */
      t.parentNode.getAttribute("srsDimension")
    ) : a && (f = Gs(a));
    let d, u, c;
    const h = [];
    for (let p = 0, g = l.length; p < g; p += f)
      d = parseFloat(l[p]), u = parseFloat(l[p + 1]), c = f === 3 ? parseFloat(l[p + 2]) : 0, o.substr(0, 2) === "en" ? h.push(d, u, c) : h.push(u, d, c);
    return h;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = i ? "3" : "2";
    t.setAttribute("srsDimension", a);
    const o = r.srsName;
    let l = "enu";
    o && (l = Wt(o).getAxisOrientation());
    const f = n.getCoordinates();
    let d;
    if (l.substr(0, 2) === "en" ? d = f[0] + " " + f[1] : d = f[1] + " " + f[0], i) {
      const u = f[2] || 0;
      d += " " + u;
    }
    Rn(t, d);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(t, n, s) {
    let r = "enu";
    n && (r = Wt(n).getAxisOrientation());
    let i = r.substr(0, 2) === "en" ? t[0] + " " + t[1] : t[1] + " " + t[0];
    if (s) {
      const a = t[2] || 0;
      i += " " + a;
    }
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = i ? "3" : "2";
    t.setAttribute("srsDimension", a);
    const o = r.srsName, l = n.getCoordinates(), f = l.length, d = new Array(f);
    let u;
    for (let c = 0; c < f; ++c)
      u = l[c], d[c] = this.getCoords_(u, o, i);
    Rn(t, d.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ue(t.namespaceURI, "pos");
    t.appendChild(a), this.writePos_(a, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ["lowerCorner", "upperCorner"], o = [n[0] + " " + n[1], n[2] + " " + n[3]];
    Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: t },
      this.ENVELOPE_SERIALIZERS,
      rS,
      o,
      s,
      a,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(t, n, s) {
    const i = s[s.length - 1].srsName;
    i && t.setAttribute("srsName", i);
    const a = ue(t.namespaceURI, "posList");
    t.appendChild(a), this.writePosList_(a, n, s);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.node, a = r.exteriorWritten;
    return a === void 0 && (r.exteriorWritten = !0), ue(
      i.namespaceURI,
      a !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName;
    if (t.nodeName !== "PolygonPatch" && a && t.setAttribute("srsName", a), t.nodeName === "Polygon" || t.nodeName === "PolygonPatch") {
      const o = n.getLinearRings();
      Cn(
        { node: t, hasZ: i, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        s,
        void 0,
        this
      );
    } else if (t.nodeName === "Surface") {
      const o = ue(t.namespaceURI, "patches");
      t.appendChild(o), this.writeSurfacePatches_(o, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(t, n, s) {
    const i = s[s.length - 1].srsName;
    if (t.nodeName !== "LineStringSegment" && i && t.setAttribute("srsName", i), t.nodeName === "LineString" || t.nodeName === "LineStringSegment") {
      const a = ue(t.namespaceURI, "posList");
      t.appendChild(a), this.writePosList_(a, n, s);
    } else if (t.nodeName === "Curve") {
      const a = ue(t.namespaceURI, "segments");
      t.appendChild(a), this.writeCurveSegments_(a, n, s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.surface;
    a && t.setAttribute("srsName", a);
    const l = n.getPolygons();
    Cn(
      { node: t, hasZ: i, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(t, n, s) {
    const r = s[s.length - 1], i = r.srsName, a = r.hasZ;
    i && t.setAttribute("srsName", i);
    const o = n.getPoints();
    Cn(
      { node: t, hasZ: a, srsName: i },
      this.POINTMEMBER_SERIALIZERS,
      nr("pointMember"),
      o,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(t, n, s) {
    const r = s[s.length - 1], i = r.hasZ, a = r.srsName, o = r.curve;
    a && t.setAttribute("srsName", a);
    const l = n.getLineStrings();
    Cn(
      { node: t, hasZ: i, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      l,
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(t, n, s) {
    const r = ue(t.namespaceURI, "LinearRing");
    t.appendChild(r), this.writeLinearRing(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(t, n, s) {
    const r = ue(t.namespaceURI, "Point");
    t.appendChild(r), this.writePoint(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(t, n, s) {
    const r = this.GEOMETRY_NODE_FACTORY_(n, s);
    r && (t.appendChild(r), this.writeCurveOrLineString(r, n, s));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(t, n, s) {
    const r = ue(t.namespaceURI, "PolygonPatch");
    t.appendChild(r), this.writeSurfaceOrPolygon(r, n, s);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(t, n, s) {
    const r = ue(t.namespaceURI, "LineStringSegment");
    t.appendChild(r), this.writeCurveOrLineString(r, n, s);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(t, n, s) {
    const r = (
      /** @type {import("./Feature.js").WriteOptions} */
      s[s.length - 1]
    ), i = Object.assign({}, r);
    i.node = t;
    let a;
    Array.isArray(n) ? a = h0(
      /** @type {import("../extent.js").Extent} */
      n,
      r
    ) : a = yu(
      /** @type {import("../geom/Geometry.js").default} */
      n,
      !0,
      r
    ), Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      i,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      s,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(t, n, s) {
    const r = n.getId();
    r && t.setAttribute(
      "fid",
      /** @type {string} */
      r
    );
    const i = (
      /** @type {Object} */
      s[s.length - 1]
    ), a = i.featureNS, o = n.getGeometryName();
    i.serializers || (i.serializers = {}, i.serializers[a] = {});
    const l = [], f = [];
    if (n.hasProperties()) {
      const u = n.getProperties();
      for (const c in u) {
        const h = u[c];
        h !== null && (l.push(c), f.push(h), c == o || typeof /** @type {?} */
        h.getSimplifiedGeometry == "function" ? c in i.serializers[a] || (i.serializers[a][c] = gt(
          this.writeGeometryElement,
          this
        )) : c in i.serializers[a] || (i.serializers[a][c] = gt(Rn)));
      }
    }
    const d = Object.assign({}, i);
    d.node = t, Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      i.serializers,
      nr(void 0, a),
      f,
      s,
      l
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(t, n, s) {
    const r = (
      /** @type {Object} */
      s[s.length - 1]
    ), i = r.featureType, a = r.featureNS, o = {};
    o[a] = {}, o[a][i] = gt(
      this.writeFeatureElement,
      this
    );
    const l = Object.assign({}, r);
    l.node = t, Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      l,
      o,
      nr(i, a),
      n,
      s
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1].node;
    return ue(
      this.namespace,
      a$[r.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(t, n, s) {
    const r = n[n.length - 1], i = r.multiSurface, a = r.surface, o = r.curve, l = r.multiCurve;
    return Array.isArray(t) ? s = "Envelope" : (s = /** @type {import("../geom/Geometry.js").default} */
    t.getType(), s === "MultiPolygon" && i === !0 ? s = "MultiSurface" : s === "Polygon" && a === !0 ? s = "Surface" : s === "LineString" && o === !0 ? s = "Curve" : s === "MultiLineString" && l === !0 && (s = "MultiCurve")), ue(this.namespace, s);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(t, n) {
    n = this.adaptOptions(n);
    const s = ue(this.namespace, "geom"), r = {
      node: s,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return n && Object.assign(r, n), this.writeGeometryElement(s, t, [r]), s;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(t, n) {
    n = this.adaptOptions(n);
    const s = ue(this.namespace, "featureMembers");
    s.setAttributeNS(
      iv,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const r = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return n && Object.assign(r, n), this.writeFeatureMembers_(s, t, [r]), s;
  }
}
jt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: zt(jt.prototype.readFlatPos),
    posList: zt(jt.prototype.readFlatPosList),
    coordinates: zt(el.prototype.readFlatCoordinates)
  }
};
jt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: jt.prototype.interiorParser,
    exterior: jt.prototype.exteriorParser
  }
};
jt.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: zt(de.prototype.readPoint),
    MultiPoint: zt(de.prototype.readMultiPoint),
    LineString: zt(de.prototype.readLineString),
    MultiLineString: zt(de.prototype.readMultiLineString),
    LinearRing: zt(de.prototype.readLinearRing),
    Polygon: zt(de.prototype.readPolygon),
    MultiPolygon: zt(de.prototype.readMultiPolygon),
    Surface: zt(jt.prototype.readSurface),
    MultiSurface: zt(jt.prototype.readMultiSurface),
    Curve: zt(jt.prototype.readCurve),
    MultiCurve: zt(jt.prototype.readMultiCurve),
    Envelope: zt(jt.prototype.readEnvelope)
  }
};
jt.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: Ht(jt.prototype.curveMemberParser),
    curveMembers: Ht(jt.prototype.curveMemberParser)
  }
};
jt.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: Ht(jt.prototype.surfaceMemberParser),
    surfaceMembers: Ht(jt.prototype.surfaceMemberParser)
  }
};
jt.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: Ht(de.prototype.readLineString),
    Curve: Ht(jt.prototype.readCurve)
  }
};
jt.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: Ht(de.prototype.readPolygon),
    Surface: Ht(jt.prototype.readSurface)
  }
};
jt.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: zt(jt.prototype.readPatch)
  }
};
jt.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: zt(jt.prototype.readSegment)
  }
};
jt.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: Ht(jt.prototype.readFlatPosList),
    upperCorner: Ht(jt.prototype.readFlatPosList)
  }
};
jt.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: zt(jt.prototype.readPolygonPatch)
  }
};
jt.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: iS(
      jt.prototype.readLineStringSegment
    )
  }
};
de.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: zt(de.prototype.readFlatLinearRing),
    Ring: zt(jt.prototype.readFlatCurveRing)
  }
};
jt.prototype.writeFeatures;
jt.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: gt(jt.prototype.writeRing),
    interior: gt(jt.prototype.writeRing)
  }
};
jt.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: gt(Rn),
    upperCorner: gt(Rn)
  }
};
jt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: gt(
      jt.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      jt.prototype.writeSurfaceOrPolygonMember
    )
  }
};
jt.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: gt(jt.prototype.writePointMember)
  }
};
jt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: gt(
      jt.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      jt.prototype.writeLineStringOrCurveMember
    )
  }
};
jt.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: gt(jt.prototype.writeCurveOrLineString),
    MultiCurve: gt(jt.prototype.writeMultiCurveOrLineString),
    Point: gt(jt.prototype.writePoint),
    MultiPoint: gt(jt.prototype.writeMultiPoint),
    LineString: gt(jt.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      jt.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(jt.prototype.writeLinearRing),
    Polygon: gt(jt.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      jt.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(jt.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      jt.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(jt.prototype.writeEnvelope)
  }
};
const se = jt, f0 = se;
f0.prototype.writeFeatures;
f0.prototype.writeFeaturesNode;
const mS = f0;
var It = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function gS(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function s() {
      return this instanceof s ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(s) {
    var r = Object.getOwnPropertyDescriptor(e, s);
    Object.defineProperty(n, s, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[s];
      }
    });
  }), n;
}
var Kf = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Kf.read = function(e, t, n, s, r) {
  var i, a, o = r * 8 - s - 1, l = (1 << o) - 1, f = l >> 1, d = -7, u = n ? r - 1 : 0, c = n ? -1 : 1, h = e[t + u];
  for (u += c, i = h & (1 << -d) - 1, h >>= -d, d += o; d > 0; i = i * 256 + e[t + u], u += c, d -= 8)
    ;
  for (a = i & (1 << -d) - 1, i >>= -d, d += s; d > 0; a = a * 256 + e[t + u], u += c, d -= 8)
    ;
  if (i === 0)
    i = 1 - f;
  else {
    if (i === l)
      return a ? NaN : (h ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, s), i = i - f;
  }
  return (h ? -1 : 1) * a * Math.pow(2, i - s);
};
Kf.write = function(e, t, n, s, r, i) {
  var a, o, l, f = i * 8 - r - 1, d = (1 << f) - 1, u = d >> 1, c = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = s ? 0 : i - 1, p = s ? 1 : -1, g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, a = d) : (a = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + u >= 1 ? t += c / l : t += c * Math.pow(2, 1 - u), t * l >= 2 && (a++, l /= 2), a + u >= d ? (o = 0, a = d) : a + u >= 1 ? (o = (t * l - 1) * Math.pow(2, r), a = a + u) : (o = t * Math.pow(2, u - 1) * Math.pow(2, r), a = 0)); r >= 8; e[n + h] = o & 255, h += p, o /= 256, r -= 8)
    ;
  for (a = a << r | o, f += r; f > 0; e[n + h] = a & 255, h += p, a /= 256, f -= 8)
    ;
  e[n + h - p] |= g * 128;
};
var o$ = Oe, Sh = Kf;
function Oe(e) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
}
Oe.Varint = 0;
Oe.Fixed64 = 1;
Oe.Bytes = 2;
Oe.Fixed32 = 5;
var ov = 65536 * 65536, GC = 1 / ov, l$ = 12, vS = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
Oe.prototype = {
  destroy: function() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function(e, t, n) {
    for (n = n || this.length; this.pos < n; ) {
      var s = this.readVarint(), r = s >> 3, i = this.pos;
      this.type = s & 7, e(r, t, this), this.pos === i && this.skip(s);
    }
    return t;
  },
  readMessage: function(e, t) {
    return this.readFields(e, t, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var e = Mh(this.buf, this.pos);
    return this.pos += 4, e;
  },
  readSFixed32: function() {
    var e = HC(this.buf, this.pos);
    return this.pos += 4, e;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function() {
    var e = Mh(this.buf, this.pos) + Mh(this.buf, this.pos + 4) * ov;
    return this.pos += 8, e;
  },
  readSFixed64: function() {
    var e = Mh(this.buf, this.pos) + HC(this.buf, this.pos + 4) * ov;
    return this.pos += 8, e;
  },
  readFloat: function() {
    var e = Sh.read(this.buf, this.pos, !0, 23, 4);
    return this.pos += 4, e;
  },
  readDouble: function() {
    var e = Sh.read(this.buf, this.pos, !0, 52, 8);
    return this.pos += 8, e;
  },
  readVarint: function(e) {
    var t = this.buf, n, s;
    return s = t[this.pos++], n = s & 127, s < 128 || (s = t[this.pos++], n |= (s & 127) << 7, s < 128) || (s = t[this.pos++], n |= (s & 127) << 14, s < 128) || (s = t[this.pos++], n |= (s & 127) << 21, s < 128) ? n : (s = t[this.pos], n |= (s & 15) << 28, u$(n, e, this));
  },
  readVarint64: function() {
    return this.readVarint(!0);
  },
  readSVarint: function() {
    var e = this.readVarint();
    return e % 2 === 1 ? (e + 1) / -2 : e / 2;
  },
  readBoolean: function() {
    return !!this.readVarint();
  },
  readString: function() {
    var e = this.readVarint() + this.pos, t = this.pos;
    return this.pos = e, e - t >= l$ && vS ? T$(this.buf, t, e) : b$(this.buf, t, e);
  },
  readBytes: function() {
    var e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e);
    return this.pos = e, t;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function(e, t) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readVarint(t));
    var n = Rs(this);
    for (e = e || []; this.pos < n; )
      e.push(this.readVarint(t));
    return e;
  },
  readPackedSVarint: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSVarint());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSVarint());
    return e;
  },
  readPackedBoolean: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readBoolean());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readBoolean());
    return e;
  },
  readPackedFloat: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFloat());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFloat());
    return e;
  },
  readPackedDouble: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readDouble());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readDouble());
    return e;
  },
  readPackedFixed32: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFixed32());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFixed32());
    return e;
  },
  readPackedSFixed32: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSFixed32());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSFixed32());
    return e;
  },
  readPackedFixed64: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readFixed64());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readFixed64());
    return e;
  },
  readPackedSFixed64: function(e) {
    if (this.type !== Oe.Bytes)
      return e.push(this.readSFixed64());
    var t = Rs(this);
    for (e = e || []; this.pos < t; )
      e.push(this.readSFixed64());
    return e;
  },
  skip: function(e) {
    var t = e & 7;
    if (t === Oe.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (t === Oe.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (t === Oe.Fixed32)
      this.pos += 4;
    else if (t === Oe.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + t);
  },
  // === WRITING =================================================================
  writeTag: function(e, t) {
    this.writeVarint(e << 3 | t);
  },
  realloc: function(e) {
    for (var t = this.length || 16; t < this.pos + e; )
      t *= 2;
    if (t !== this.length) {
      var n = new Uint8Array(t);
      n.set(this.buf), this.buf = n, this.length = t;
    }
  },
  finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  },
  writeFixed32: function(e) {
    this.realloc(4), dl(this.buf, e, this.pos), this.pos += 4;
  },
  writeSFixed32: function(e) {
    this.realloc(4), dl(this.buf, e, this.pos), this.pos += 4;
  },
  writeFixed64: function(e) {
    this.realloc(8), dl(this.buf, e & -1, this.pos), dl(this.buf, Math.floor(e * GC), this.pos + 4), this.pos += 8;
  },
  writeSFixed64: function(e) {
    this.realloc(8), dl(this.buf, e & -1, this.pos), dl(this.buf, Math.floor(e * GC), this.pos + 4), this.pos += 8;
  },
  writeVarint: function(e) {
    if (e = +e || 0, e > 268435455 || e < 0) {
      c$(e, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = e & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = e >>> 7 & 127)));
  },
  writeSVarint: function(e) {
    this.writeVarint(e < 0 ? -e * 2 - 1 : e * 2);
  },
  writeBoolean: function(e) {
    this.writeVarint(!!e);
  },
  writeString: function(e) {
    e = String(e), this.realloc(e.length * 4), this.pos++;
    var t = this.pos;
    this.pos = O$(this.buf, e, this.pos);
    var n = this.pos - t;
    n >= 128 && kC(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
  },
  writeFloat: function(e) {
    this.realloc(4), Sh.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4;
  },
  writeDouble: function(e) {
    this.realloc(8), Sh.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8;
  },
  writeBytes: function(e) {
    var t = e.length;
    this.writeVarint(t), this.realloc(t);
    for (var n = 0; n < t; n++)
      this.buf[this.pos++] = e[n];
  },
  writeRawMessage: function(e, t) {
    this.pos++;
    var n = this.pos;
    e(t, this);
    var s = this.pos - n;
    s >= 128 && kC(n, s, this), this.pos = n - 1, this.writeVarint(s), this.pos += s;
  },
  writeMessage: function(e, t, n) {
    this.writeTag(e, Oe.Bytes), this.writeRawMessage(t, n);
  },
  writePackedVarint: function(e, t) {
    t.length && this.writeMessage(e, f$, t);
  },
  writePackedSVarint: function(e, t) {
    t.length && this.writeMessage(e, p$, t);
  },
  writePackedBoolean: function(e, t) {
    t.length && this.writeMessage(e, v$, t);
  },
  writePackedFloat: function(e, t) {
    t.length && this.writeMessage(e, m$, t);
  },
  writePackedDouble: function(e, t) {
    t.length && this.writeMessage(e, g$, t);
  },
  writePackedFixed32: function(e, t) {
    t.length && this.writeMessage(e, y$, t);
  },
  writePackedSFixed32: function(e, t) {
    t.length && this.writeMessage(e, E$, t);
  },
  writePackedFixed64: function(e, t) {
    t.length && this.writeMessage(e, C$, t);
  },
  writePackedSFixed64: function(e, t) {
    t.length && this.writeMessage(e, x$, t);
  },
  writeBytesField: function(e, t) {
    this.writeTag(e, Oe.Bytes), this.writeBytes(t);
  },
  writeFixed32Field: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeFixed32(t);
  },
  writeSFixed32Field: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeSFixed32(t);
  },
  writeFixed64Field: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeFixed64(t);
  },
  writeSFixed64Field: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeSFixed64(t);
  },
  writeVarintField: function(e, t) {
    this.writeTag(e, Oe.Varint), this.writeVarint(t);
  },
  writeSVarintField: function(e, t) {
    this.writeTag(e, Oe.Varint), this.writeSVarint(t);
  },
  writeStringField: function(e, t) {
    this.writeTag(e, Oe.Bytes), this.writeString(t);
  },
  writeFloatField: function(e, t) {
    this.writeTag(e, Oe.Fixed32), this.writeFloat(t);
  },
  writeDoubleField: function(e, t) {
    this.writeTag(e, Oe.Fixed64), this.writeDouble(t);
  },
  writeBooleanField: function(e, t) {
    this.writeVarintField(e, !!t);
  }
};
function u$(e, t, n) {
  var s = n.buf, r, i;
  if (i = s[n.pos++], r = (i & 112) >> 4, i < 128 || (i = s[n.pos++], r |= (i & 127) << 3, i < 128) || (i = s[n.pos++], r |= (i & 127) << 10, i < 128) || (i = s[n.pos++], r |= (i & 127) << 17, i < 128) || (i = s[n.pos++], r |= (i & 127) << 24, i < 128) || (i = s[n.pos++], r |= (i & 1) << 31, i < 128))
    return hl(e, r, t);
  throw new Error("Expected varint not more than 10 bytes");
}
function Rs(e) {
  return e.type === Oe.Bytes ? e.readVarint() + e.pos : e.pos + 1;
}
function hl(e, t, n) {
  return n ? t * 4294967296 + (e >>> 0) : (t >>> 0) * 4294967296 + (e >>> 0);
}
function c$(e, t) {
  var n, s;
  if (e >= 0 ? (n = e % 4294967296 | 0, s = e / 4294967296 | 0) : (n = ~(-e % 4294967296), s = ~(-e / 4294967296), n ^ 4294967295 ? n = n + 1 | 0 : (n = 0, s = s + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  t.realloc(10), h$(n, s, t), d$(s, t);
}
function h$(e, t, n) {
  n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos++] = e & 127 | 128, e >>>= 7, n.buf[n.pos] = e & 127;
}
function d$(e, t) {
  var n = (e & 7) << 4;
  t.buf[t.pos++] |= n | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127 | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = e & 127)))));
}
function kC(e, t, n) {
  var s = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (Math.LN2 * 7));
  n.realloc(s);
  for (var r = n.pos - 1; r >= e; r--)
    n.buf[r + s] = n.buf[r];
}
function f$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeVarint(e[n]);
}
function p$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSVarint(e[n]);
}
function m$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFloat(e[n]);
}
function g$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeDouble(e[n]);
}
function v$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeBoolean(e[n]);
}
function y$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFixed32(e[n]);
}
function E$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSFixed32(e[n]);
}
function C$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeFixed64(e[n]);
}
function x$(e, t) {
  for (var n = 0; n < e.length; n++)
    t.writeSFixed64(e[n]);
}
function Mh(e, t) {
  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + e[t + 3] * 16777216;
}
function dl(e, t, n) {
  e[n] = t, e[n + 1] = t >>> 8, e[n + 2] = t >>> 16, e[n + 3] = t >>> 24;
}
function HC(e, t) {
  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24);
}
function b$(e, t, n) {
  for (var s = "", r = t; r < n; ) {
    var i = e[r], a = null, o = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
    if (r + o > n)
      break;
    var l, f, d;
    o === 1 ? i < 128 && (a = i) : o === 2 ? (l = e[r + 1], (l & 192) === 128 && (a = (i & 31) << 6 | l & 63, a <= 127 && (a = null))) : o === 3 ? (l = e[r + 1], f = e[r + 2], (l & 192) === 128 && (f & 192) === 128 && (a = (i & 15) << 12 | (l & 63) << 6 | f & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : o === 4 && (l = e[r + 1], f = e[r + 2], d = e[r + 3], (l & 192) === 128 && (f & 192) === 128 && (d & 192) === 128 && (a = (i & 15) << 18 | (l & 63) << 12 | (f & 63) << 6 | d & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, o = 1) : a > 65535 && (a -= 65536, s += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), s += String.fromCharCode(a), r += o;
  }
  return s;
}
function T$(e, t, n) {
  return vS.decode(e.subarray(t, n));
}
function O$(e, t, n) {
  for (var s = 0, r, i; s < t.length; s++) {
    if (r = t.charCodeAt(s), r > 55295 && r < 57344)
      if (i)
        if (r < 56320) {
          e[n++] = 239, e[n++] = 191, e[n++] = 189, i = r;
          continue;
        } else
          r = i - 55296 << 10 | r - 56320 | 65536, i = null;
      else {
        r > 56319 || s + 1 === t.length ? (e[n++] = 239, e[n++] = 191, e[n++] = 189) : i = r;
        continue;
      }
    else
      i && (e[n++] = 239, e[n++] = 191, e[n++] = 189, i = null);
    r < 128 ? e[n++] = r : (r < 2048 ? e[n++] = r >> 6 | 192 : (r < 65536 ? e[n++] = r >> 12 | 224 : (e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128), e[n++] = r >> 6 & 63 | 128), e[n++] = r & 63 | 128);
  }
  return n;
}
const P$ = /* @__PURE__ */ nl(o$);
class Gf extends oa {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(t, n, s) {
    super(), s !== void 0 && n === void 0 ? this.setFlatCoordinates(s, t) : (n = n || 0, this.setCenterAndRadius(t, n, s));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const t = new Gf(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return t.applyProperties(this), t;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(t, n, s, r) {
    const i = this.flatCoordinates, a = t - i[0], o = n - i[1], l = a * a + o * o;
    if (l < r) {
      if (l === 0)
        for (let f = 0; f < this.stride; ++f)
          s[f] = i[f];
      else {
        const f = this.getRadius() / Math.sqrt(l);
        s[0] = i[0] + f * a, s[1] = i[1] + f * o;
        for (let d = 2; d < this.stride; ++d)
          s[d] = i[d];
      }
      return s.length = this.stride, l;
    } else
      return r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(t, n) {
    const s = this.flatCoordinates, r = t - s[0], i = n - s[1];
    return r * r + i * i <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(t) {
    const n = this.flatCoordinates, s = n[this.stride] - n[0];
    return ir(
      n[0] - s,
      n[1] - s,
      n[0] + s,
      n[1] + s,
      t
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0], n = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return t * t + n * n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(t) {
    const n = this.getExtent();
    if (hn(t, n)) {
      const s = this.getCenter();
      return t[0] <= s[0] && t[2] >= s[0] || t[1] <= s[1] && t[3] >= s[1] ? !0 : sy(t, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(t) {
    const n = this.stride, s = this.flatCoordinates[n] - this.flatCoordinates[0], r = t.slice();
    r[n] = r[0] + s;
    for (let i = 1; i < n; ++i)
      r[n + i] = t[i];
    this.setFlatCoordinates(this.layout, r), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(t, n, s) {
    this.setLayout(s, t, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const r = this.flatCoordinates;
    let i = m1(r, 0, t, this.stride);
    r[i++] = r[0] + n;
    for (let a = 1, o = this.stride; a < o; ++a)
      r[i++] = r[a];
    r.length = i, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(t, n) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(t) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(t, n) {
    const s = this.getCenter(), r = this.getStride();
    this.setCenter(
      dy(s, 0, s.length, r, t, n, s)
    ), this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(t, n) {
    const s = this.getCenter(), r = this.getStride();
    this.setCenter(
      p1(s, 0, s.length, r, t, n, s)
    ), this.changed();
  }
}
Gf.prototype.transform;
const yS = Gf, YC = tr();
class bc {
  /**
   * @param {import("../geom/Geometry.js").Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(t, n, s, r, i) {
    this.styleFunction, this.extent_, this.id_ = i, this.type_ = t, this.flatCoordinates_ = n, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = s, this.properties_ = r;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(t) {
    return this.properties_[t];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? iy(this.flatCoordinates_) : ry(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const t = $i(this.getExtent());
      this.flatInteriorPoints_ = Cy(
        this.flatCoordinates_,
        0,
        /** @type {Array<number>} */
        this.ends_,
        2,
        t,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const t = dS(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2
      );
      this.flatInteriorPoints_ = C1(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = Od(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const t = this.flatCoordinates_;
      let n = 0;
      const s = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let r = 0, i = s.length; r < i; ++r) {
        const a = s[r], o = Od(t, n, a, 2, 0.5);
        Kn(this.flatMidpoints_, o), n = a;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(t) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(t, n) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return 2;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(t) {
    t = Wt(t);
    const n = t.getExtent(), s = t.getWorldExtent();
    if (n && s) {
      const r = In(s) / In(n);
      $r(
        YC,
        s[0],
        s[3],
        r,
        -r,
        0,
        0,
        0
      ), Ba(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        YC,
        this.flatCoordinates_
      );
    }
  }
  /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */
  getEnds() {
    return this.ends_;
  }
}
bc.prototype.getEndss = bc.prototype.getEnds;
bc.prototype.getFlatCoordinates = bc.prototype.getOrientedFlatCoordinates;
const Tc = bc;
class S$ extends c0 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), t = t || {}, this.dataProjection = new Af({
      code: "",
      units: "tile-pixels"
    }), this.featureClass_ = t.featureClass ? t.featureClass : Tc, this.geometryName_ = t.geometryName, this.layerName_ = t.layerName ? t.layerName : "layer", this.layers_ = t.layers ? t.layers : null, this.idProperty_ = t.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(t, n, s, r) {
    t.pos = n.geometry;
    const i = t.readVarint() + t.pos;
    let a = 1, o = 0, l = 0, f = 0, d = 0, u = 0;
    for (; t.pos < i; ) {
      if (!o) {
        const c = t.readVarint();
        a = c & 7, o = c >> 3;
      }
      o--, a === 1 || a === 2 ? (l += t.readSVarint(), f += t.readSVarint(), a === 1 && d > u && (r.push(d), u = d), s.push(l, f), d += 2) : a === 7 ? d > u && (s.push(
        s[u],
        s[u + 1]
      ), d += 2) : Zt(!1, 59);
    }
    d > u && (r.push(d), u = d);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(t, n, s) {
    const r = n.type;
    if (r === 0)
      return null;
    let i;
    const a = n.properties;
    let o;
    this.idProperty_ ? (o = a[this.idProperty_], delete a[this.idProperty_]) : o = n.id, a[this.layerName_] = n.layer.name;
    const l = (
      /** @type {Array<number>} */
      []
    ), f = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(t, n, l, f);
    const d = A$(r, f.length);
    if (this.featureClass_ === Tc)
      i = new this.featureClass_(
        d,
        l,
        f,
        a,
        o
      ), i.transform(s.dataProjection);
    else {
      let u;
      if (d == "Polygon") {
        const p = sA(l, f);
        u = p.length > 1 ? new ia(l, "XY", p) : new rr(l, "XY", f);
      } else
        u = d === "Point" ? new hi(l, "XY") : d === "LineString" ? new er(l, "XY") : d === "MultiPoint" ? new Eu(l, "XY") : d === "MultiLineString" ? new na(l, "XY", f) : null;
      const c = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass_
      );
      i = new c(), this.geometryName_ && i.setGeometryName(this.geometryName_);
      const h = yu(u, !1, s);
      i.setGeometry(h), o !== void 0 && i.setId(o), i.setProperties(a, !0);
    }
    return i;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  readFeatures(t, n) {
    const s = this.layers_;
    n = this.adaptOptions(n);
    const r = Wt(n.dataProjection);
    r.setWorldExtent(n.extent), n.dataProjection = r;
    const i = new P$(
      /** @type {ArrayBuffer} */
      t
    ), a = i.readFields(M$, {}), o = [];
    for (const l in a) {
      if (s && !s.includes(l))
        continue;
      const f = a[l], d = f ? [0, 0, f.extent, f.extent] : null;
      r.setExtent(d);
      for (let u = 0, c = f.length; u < c; ++u) {
        const h = D$(i, f, u), p = this.createFeature_(i, h, n);
        p !== null && o.push(p);
      }
    }
    return o;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(t) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(t) {
    this.layers_ = t;
  }
}
function M$(e, t, n) {
  if (e === 3) {
    const s = {
      keys: [],
      values: [],
      features: []
    }, r = n.readVarint() + n.pos;
    n.readFields(_$, s, r), s.length = s.features.length, s.length && (t[s.name] = s);
  }
}
function _$(e, t, n) {
  if (e === 15)
    t.version = n.readVarint();
  else if (e === 1)
    t.name = n.readString();
  else if (e === 5)
    t.extent = n.readVarint();
  else if (e === 2)
    t.features.push(n.pos);
  else if (e === 3)
    t.keys.push(n.readString());
  else if (e === 4) {
    let s = null;
    const r = n.readVarint() + n.pos;
    for (; n.pos < r; )
      e = n.readVarint() >> 3, s = e === 1 ? n.readString() : e === 2 ? n.readFloat() : e === 3 ? n.readDouble() : e === 4 ? n.readVarint64() : e === 5 ? n.readVarint() : e === 6 ? n.readSVarint() : e === 7 ? n.readBoolean() : null;
    t.values.push(s);
  }
}
function I$(e, t, n) {
  if (e == 1)
    t.id = n.readVarint();
  else if (e == 2) {
    const s = n.readVarint() + n.pos;
    for (; n.pos < s; ) {
      const r = t.layer.keys[n.readVarint()], i = t.layer.values[n.readVarint()];
      t.properties[r] = i;
    }
  } else
    e == 3 ? t.type = n.readVarint() : e == 4 && (t.geometry = n.pos);
}
function D$(e, t, n) {
  e.pos = t.features[n];
  const s = e.readVarint() + e.pos, r = {
    layer: t,
    type: 0,
    properties: {}
  };
  return e.readFields(I$, r, s), r;
}
function A$(e, t) {
  let n;
  return e === 1 ? n = t === 1 ? "Point" : "MultiPoint" : e === 2 ? n = t === 1 ? "LineString" : "MultiLineString" : e === 3 && (n = "Polygon"), n;
}
const ES = S$;
class Te extends se {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(t) {
    t = t || {}, super(t), this.schemaLocation = t.schemaLocation ? t.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
}
Te.prototype.namespace = "http://www.opengis.net/gml/3.2";
Te.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: zt(se.prototype.readFlatPos),
    posList: zt(se.prototype.readFlatPosList),
    coordinates: zt(el.prototype.readFlatCoordinates)
  }
};
Te.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: se.prototype.interiorParser,
    exterior: se.prototype.exteriorParser
  }
};
Te.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: zt(de.prototype.readPoint),
    MultiPoint: zt(de.prototype.readMultiPoint),
    LineString: zt(de.prototype.readLineString),
    MultiLineString: zt(de.prototype.readMultiLineString),
    LinearRing: zt(de.prototype.readLinearRing),
    Polygon: zt(de.prototype.readPolygon),
    MultiPolygon: zt(de.prototype.readMultiPolygon),
    Surface: zt(Te.prototype.readSurface),
    MultiSurface: zt(se.prototype.readMultiSurface),
    Curve: zt(Te.prototype.readCurve),
    MultiCurve: zt(se.prototype.readMultiCurve),
    Envelope: zt(Te.prototype.readEnvelope)
  }
};
Te.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: Ht(se.prototype.curveMemberParser),
    curveMembers: Ht(se.prototype.curveMemberParser)
  }
};
Te.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: Ht(se.prototype.surfaceMemberParser),
    surfaceMembers: Ht(se.prototype.surfaceMemberParser)
  }
};
Te.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: Ht(de.prototype.readLineString),
    Curve: Ht(se.prototype.readCurve)
  }
};
Te.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: Ht(de.prototype.readPolygon),
    Surface: Ht(se.prototype.readSurface)
  }
};
Te.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: zt(se.prototype.readPatch)
  }
};
Te.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: zt(se.prototype.readSegment)
  }
};
Te.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: Ht(se.prototype.readFlatPosList),
    upperCorner: Ht(se.prototype.readFlatPosList)
  }
};
Te.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: zt(se.prototype.readPolygonPatch)
  }
};
Te.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: iS(
      se.prototype.readLineStringSegment
    )
  }
};
Te.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: Ht(de.prototype.pointMemberParser),
    pointMembers: Ht(de.prototype.pointMemberParser)
  }
};
Te.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: Ht(
      de.prototype.lineStringMemberParser
    ),
    lineStringMembers: Ht(
      de.prototype.lineStringMemberParser
    )
  }
};
Te.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: Ht(de.prototype.polygonMemberParser),
    polygonMembers: Ht(de.prototype.polygonMemberParser)
  }
};
Te.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: Ht(de.prototype.readFlatCoordinatesFromNode)
  }
};
Te.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: Ht(de.prototype.readLineString)
  }
};
Te.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: Ht(de.prototype.readPolygon)
  }
};
Te.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: zt(de.prototype.readFlatLinearRing),
    Ring: zt(Te.prototype.readFlatCurveRing)
  }
};
Te.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: gt(se.prototype.writeRing),
    interior: gt(se.prototype.writeRing)
  }
};
Te.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: gt(Rn),
    upperCorner: gt(Rn)
  }
};
Te.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: gt(
      se.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: gt(
      se.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Te.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: gt(se.prototype.writePointMember)
  }
};
Te.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: gt(
      se.prototype.writeLineStringOrCurveMember
    ),
    curveMember: gt(
      se.prototype.writeLineStringOrCurveMember
    )
  }
};
Te.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: gt(se.prototype.writeCurveOrLineString),
    MultiCurve: gt(se.prototype.writeMultiCurveOrLineString),
    Point: gt(Te.prototype.writePoint),
    MultiPoint: gt(se.prototype.writeMultiPoint),
    LineString: gt(se.prototype.writeCurveOrLineString),
    MultiLineString: gt(
      se.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: gt(se.prototype.writeLinearRing),
    Polygon: gt(se.prototype.writeSurfaceOrPolygon),
    MultiPolygon: gt(
      se.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: gt(se.prototype.writeSurfaceOrPolygon),
    MultiSurface: gt(
      se.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: gt(se.prototype.writeEnvelope)
  }
};
const Jc = Te;
let L$ = class {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(t) {
    this.tagName_ = t;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
};
const CS = L$;
class R$ extends CS {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(t, n) {
    super(t), this.conditions = n, Zt(this.conditions.length >= 2, 57);
  }
}
const w$ = R$;
class V$ extends w$ {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(t) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
const B$ = V$;
class F$ extends CS {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(t, n, s) {
    if (super("BBOX"), this.geometryName = t, this.extent = n, n.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = s;
  }
}
const N$ = F$;
function j$(e) {
  const t = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(B$, t))();
}
function $$(e, t, n) {
  return new N$(e, t, n);
}
const XC = {
  "http://www.opengis.net/gml": {
    boundedBy: mt(
      de.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: Ht(de.prototype.readFeaturesInternal)
  }
}, U$ = {
  "http://www.opengis.net/wfs": {
    totalInserted: mt(qn),
    totalUpdated: mt(qn),
    totalDeleted: mt(qn)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: mt(qn),
    totalUpdated: mt(qn),
    totalDeleted: mt(qn)
  }
}, W$ = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: mt(
      JC,
      "transactionSummary"
    ),
    InsertResults: mt(qC, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: mt(
      JC,
      "transactionSummary"
    ),
    InsertResults: mt(qC, "insertIds")
  }
}, z$ = {
  "http://www.opengis.net/wfs": {
    PropertyName: gt(Rn)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: gt(Rn)
  }
}, xS = {
  "http://www.opengis.net/wfs": {
    Insert: gt(tx),
    Update: gt(nx),
    Delete: gt(ex),
    Property: gt(ix),
    Native: gt(rx)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: gt(tx),
    Update: gt(nx),
    Delete: gt(ex),
    Property: gt(ix),
    Native: gt(rx)
  }
}, bS = "feature", p0 = "http://www.w3.org/2000/xmlns/", m0 = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, lv = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, g0 = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, ZC = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, v0 = {
  "2.0.0": Jc,
  "1.1.0": se,
  "1.0.0": el
}, K$ = "1.1.0";
class G$ extends pS {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(t) {
    super(), t = t || {}, this.version_ = t.version ? t.version : K$, this.featureType_ = t.featureType, this.featureNS_ = t.featureNS, this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new v0[this.version_](), this.schemaLocation_ = t.schemaLocation ? t.schemaLocation : ZC[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(t) {
    this.featureType_ = t;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(t, n) {
    const s = {
      node: t
    };
    Object.assign(s, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(s, this.getReadOptions(t, n || {}));
    const r = [s];
    let i;
    this.version_ === "2.0.0" ? i = XC : i = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let a = At(
      [],
      i,
      t,
      r,
      this.gmlFormat_
    );
    return a || (a = []), a;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(t) {
    if (t)
      if (typeof t == "string") {
        const n = Oo(t);
        return this.readTransactionResponseFromDocument(n);
      } else
        return To(t) ? this.readTransactionResponseFromDocument(
          /** @type {Document} */
          t
        ) : this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
    else
      return;
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(t) {
    if (t)
      if (typeof t == "string") {
        const n = Oo(t);
        return this.readFeatureCollectionMetadataFromDocument(n);
      } else
        return To(t) ? this.readFeatureCollectionMetadataFromDocument(
          /** @type {Document} */
          t
        ) : this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
    else
      return;
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(t) {
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          n
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(t) {
    const n = {}, s = Gs(
      t.getAttribute("numberOfFeatures")
    );
    return n.numberOfFeatures = s, At(
      /** @type {FeatureCollectionMetadata} */
      n,
      XC,
      t,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(t) {
    for (let n = (
      /** @type {Node} */
      t.firstChild
    ); n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          n
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(t) {
    return At(
      /** @type {TransactionResponse} */
      {},
      W$,
      t,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(t) {
    const n = ue(lv[this.version_], "GetFeature");
    n.setAttribute("service", "WFS"), n.setAttribute("version", this.version_), t.handle && n.setAttribute("handle", t.handle), t.outputFormat && n.setAttribute("outputFormat", t.outputFormat), t.maxFeatures !== void 0 && n.setAttribute("maxFeatures", String(t.maxFeatures)), t.resultType && n.setAttribute("resultType", t.resultType), t.startIndex !== void 0 && n.setAttribute("startIndex", String(t.startIndex)), t.count !== void 0 && n.setAttribute("count", String(t.count)), t.viewParams !== void 0 && n.setAttribute("viewParams", t.viewParams), n.setAttributeNS(
      iv,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const s = {
      node: n
    };
    if (Object.assign(s, {
      version: this.version_,
      srsName: t.srsName,
      featureNS: t.featureNS ? t.featureNS : this.featureNS_,
      featurePrefix: t.featurePrefix,
      propertyNames: t.propertyNames ? t.propertyNames : []
    }), Zt(Array.isArray(t.featureTypes), 11), typeof t.featureTypes[0] == "string") {
      let r = t.filter;
      t.bbox && (Zt(t.geometryName, 12), r = this.combineBboxAndFilter(
        t.geometryName,
        t.bbox,
        t.srsName,
        r
      )), Object.assign(s, {
        geometryName: t.geometryName,
        filter: r
      }), px(
        n,
        /** @type {!Array<string>} */
        t.featureTypes,
        [s]
      );
    } else
      t.featureTypes.forEach((r) => {
        const i = this.combineBboxAndFilter(
          r.geometryName,
          r.bbox,
          t.srsName,
          t.filter
        );
        Object.assign(s, {
          geometryName: r.geometryName,
          filter: i
        }), px(n, [r.name], [s]);
      });
    return n;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(t, n, s, r) {
    const i = $$(t, n, s);
    return r ? j$(r, i) : i;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(t, n, s, r) {
    const i = [], a = r.version ? r.version : this.version_, o = ue(lv[a], "Transaction");
    o.setAttribute("service", "WFS"), o.setAttribute("version", a);
    let l;
    r && (l = r.gmlOptions ? r.gmlOptions : {}, r.handle && o.setAttribute("handle", r.handle)), o.setAttributeNS(
      iv,
      "xsi:schemaLocation",
      ZC[a]
    );
    const f = k$(o, l, a, r);
    return t && _h("Insert", t, i, f), n && _h("Update", n, i, f), s && _h("Delete", s, i, f), r.nativeElements && _h(
      "Native",
      r.nativeElements,
      i,
      f
    ), o;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(t) {
    for (let n = t.firstChild; n; n = n.nextSibling)
      if (n.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          n
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(t) {
    if (t.firstElementChild && t.firstElementChild.firstElementChild) {
      t = t.firstElementChild.firstElementChild;
      for (let n = t.firstElementChild; n; n = n.nextElementSibling)
        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
          const s = [{}];
          return this.gmlFormat_.readGeometryElement(n, s), Wt(s.pop().srsName);
        }
    }
    return null;
  }
}
function k$(e, t, n, s) {
  const r = s.featurePrefix ? s.featurePrefix : bS;
  let i;
  return n === "1.0.0" ? i = 2 : n === "1.1.0" ? i = 3 : n === "2.0.0" && (i = 3.2), Object.assign(
    { node: e },
    {
      version: n,
      featureNS: s.featureNS,
      featureType: s.featureType,
      featurePrefix: r,
      gmlVersion: i,
      hasZ: s.hasZ,
      srsName: s.srsName
    },
    t
  );
}
function _h(e, t, n, s) {
  Cn(
    s,
    xS,
    nr(e),
    t,
    n
  );
}
function JC(e, t) {
  return At({}, U$, e, t);
}
const H$ = {
  "http://www.opengis.net/ogc": {
    FeatureId: Ht(function(e, t) {
      return e.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: Ht(function(e, t) {
      return e.getAttribute("fid");
    })
  }
};
function QC(e, t) {
  Io(H$, e, t);
}
const Y$ = {
  "http://www.opengis.net/wfs": {
    Feature: QC
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: QC
  }
};
function qC(e, t) {
  return At([], Y$, e, t);
}
function tx(e, t, n) {
  const s = n[n.length - 1], r = s.featureType, i = s.featureNS, a = s.gmlVersion, o = ue(i, r);
  e.appendChild(o), a === 2 ? el.prototype.writeFeatureElement(o, t, n) : a === 3 ? se.prototype.writeFeatureElement(o, t, n) : Jc.prototype.writeFeatureElement(o, t, n);
}
function TS(e, t, n) {
  const r = n[n.length - 1].version, i = m0[r], a = ue(i, "Filter"), o = ue(i, "FeatureId");
  a.appendChild(o), o.setAttribute(
    "fid",
    /** @type {string} */
    t
  ), e.appendChild(a);
}
function y0(e, t) {
  e = e || bS;
  const n = e + ":";
  return t.startsWith(n) ? t : n + t;
}
function ex(e, t, n) {
  const s = n[n.length - 1];
  Zt(t.getId() !== void 0, 26);
  const r = s.featureType, i = s.featurePrefix, a = s.featureNS, o = y0(i, r);
  e.setAttribute("typeName", o), e.setAttributeNS(p0, "xmlns:" + i, a);
  const l = t.getId();
  l !== void 0 && TS(e, l, n);
}
function nx(e, t, n) {
  const s = n[n.length - 1];
  Zt(t.getId() !== void 0, 27);
  const r = s.version, i = s.featureType, a = s.featurePrefix, o = s.featureNS, l = y0(a, i), f = t.getGeometryName();
  e.setAttribute("typeName", l), e.setAttributeNS(p0, "xmlns:" + a, o);
  const d = t.getId();
  if (d !== void 0) {
    const u = t.getKeys(), c = [];
    for (let h = 0, p = u.length; h < p; h++) {
      const g = t.get(u[h]);
      if (g !== void 0) {
        let m = u[h];
        g && typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" && (m = f), c.push({ name: m, value: g });
      }
    }
    Cn(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: r,
        gmlVersion: s.gmlVersion,
        node: e,
        hasZ: s.hasZ,
        srsName: s.srsName
      },
      xS,
      nr("Property"),
      c,
      n
    ), TS(e, d, n);
  }
}
function ix(e, t, n) {
  const s = n[n.length - 1], r = s.version, i = lv[r], a = ue(i, "Name"), o = s.gmlVersion;
  if (e.appendChild(a), Rn(a, t.name), t.value !== void 0 && t.value !== null) {
    const l = ue(i, "Value");
    e.appendChild(l), t.value && typeof /** @type {?} */
    t.value.getSimplifiedGeometry == "function" ? o === 2 ? el.prototype.writeGeometryElement(l, t.value, n) : o === 3 ? se.prototype.writeGeometryElement(l, t.value, n) : Jc.prototype.writeGeometryElement(l, t.value, n) : Rn(l, t.value);
  }
}
function rx(e, t, n) {
  t.vendorId && e.setAttribute("vendorId", t.vendorId), t.safeToIgnore !== void 0 && e.setAttribute("safeToIgnore", String(t.safeToIgnore)), t.value !== void 0 && Rn(e, t.value);
}
const kf = {
  "http://www.opengis.net/wfs": {
    Query: gt(sx)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: gt(sx)
  },
  "http://www.opengis.net/ogc": {
    During: gt(lx),
    And: gt(Ih),
    Or: gt(Ih),
    Not: gt(ux),
    BBOX: gt(ax),
    Contains: gt(xa),
    Intersects: gt(xa),
    Within: gt(xa),
    DWithin: gt(ox),
    PropertyIsEqualTo: gt(dr),
    PropertyIsNotEqualTo: gt(dr),
    PropertyIsLessThan: gt(dr),
    PropertyIsLessThanOrEqualTo: gt(dr),
    PropertyIsGreaterThan: gt(dr),
    PropertyIsGreaterThanOrEqualTo: gt(dr),
    PropertyIsNull: gt(cx),
    PropertyIsBetween: gt(hx),
    PropertyIsLike: gt(dx)
  },
  "http://www.opengis.net/fes/2.0": {
    During: gt(lx),
    And: gt(Ih),
    Or: gt(Ih),
    Not: gt(ux),
    BBOX: gt(ax),
    Contains: gt(xa),
    Disjoint: gt(xa),
    Intersects: gt(xa),
    ResourceId: gt(Z$),
    Within: gt(xa),
    DWithin: gt(ox),
    PropertyIsEqualTo: gt(dr),
    PropertyIsNotEqualTo: gt(dr),
    PropertyIsLessThan: gt(dr),
    PropertyIsLessThanOrEqualTo: gt(dr),
    PropertyIsGreaterThan: gt(dr),
    PropertyIsGreaterThanOrEqualTo: gt(dr),
    PropertyIsNull: gt(cx),
    PropertyIsBetween: gt(hx),
    PropertyIsLike: gt(dx)
  }
};
function sx(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = s.version, i = s.featurePrefix, a = s.featureNS, o = s.propertyNames, l = s.srsName;
  let f;
  i ? f = y0(i, t) : f = t;
  let d;
  r === "2.0.0" ? d = "typeNames" : d = "typeName", e.setAttribute(d, f), l && e.setAttribute("srsName", l), a && e.setAttributeNS(p0, "xmlns:" + i, a);
  const u = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, s)
  );
  u.node = e, Cn(
    u,
    z$,
    nr("PropertyName"),
    o,
    n
  );
  const c = s.filter;
  if (c) {
    const h = ue(Hf(r), "Filter");
    e.appendChild(h), X$(h, c, n);
  }
}
function X$(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = { node: e };
  Object.assign(r, { context: s }), Cn(
    r,
    kf,
    nr(t.getTagName()),
    [t],
    n
  );
}
function ax(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), i = s.context.version;
  s.srsName = t.srsName;
  const a = v0[i];
  Cu(i, e, t.geometryName), a.prototype.writeGeometryElement(e, t.extent, n);
}
function Z$(e, t, n) {
  e.setAttribute(
    "rid",
    /** @type {string} */
    t.rid
  );
}
function xa(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), i = s.context.version;
  s.srsName = t.srsName;
  const a = v0[i];
  Cu(i, e, t.geometryName), a.prototype.writeGeometryElement(e, t.geometry, n);
}
function ox(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  xa(e, t, n);
  const a = ue(Hf(i), "Distance");
  Rn(a, t.distance.toString()), i === "2.0.0" ? a.setAttribute("uom", t.unit) : a.setAttribute("units", t.unit), e.appendChild(a);
}
function lx(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  Hd(g0[i], "ValueReference", e, t.propertyName);
  const a = ue(Js, "TimePeriod");
  e.appendChild(a);
  const o = ue(Js, "begin");
  a.appendChild(o), fx(o, t.begin);
  const l = ue(Js, "end");
  a.appendChild(l), fx(l, t.end);
}
function Ih(e, t, n) {
  const r = /** @type {Object} */ n[n.length - 1].context, i = { node: e };
  Object.assign(i, { context: r });
  const a = t.conditions;
  for (let o = 0, l = a.length; o < l; ++o) {
    const f = a[o];
    Cn(
      i,
      kf,
      nr(f.getTagName()),
      [f],
      n
    );
  }
}
function ux(e, t, n) {
  const r = /** @type {Object} */ n[n.length - 1].context, i = { node: e };
  Object.assign(i, { context: r });
  const a = t.condition;
  Cn(
    i,
    kf,
    nr(a.getTagName()),
    [a],
    n
  );
}
function dr(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  t.matchCase !== void 0 && e.setAttribute("matchCase", t.matchCase.toString()), Cu(i, e, t.propertyName), Yd(i, e, "" + t.expression);
}
function cx(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  Cu(i, e, t.propertyName);
}
function hx(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version, a = Hf(i);
  Cu(i, e, t.propertyName);
  const o = ue(a, "LowerBoundary");
  e.appendChild(o), Yd(i, o, "" + t.lowerBoundary);
  const l = ue(a, "UpperBoundary");
  e.appendChild(l), Yd(i, l, "" + t.upperBoundary);
}
function dx(e, t, n) {
  const i = /** @type {Object} */ n[n.length - 1].context.version;
  e.setAttribute("wildCard", t.wildCard), e.setAttribute("singleChar", t.singleChar), e.setAttribute("escapeChar", t.escapeChar), t.matchCase !== void 0 && e.setAttribute("matchCase", t.matchCase.toString()), Cu(i, e, t.propertyName), Yd(i, e, "" + t.pattern);
}
function Hd(e, t, n, s) {
  const r = ue(e, t);
  Rn(r, s), n.appendChild(r);
}
function Yd(e, t, n) {
  Hd(Hf(e), "Literal", t, n);
}
function Cu(e, t, n) {
  e === "2.0.0" ? Hd(g0[e], "ValueReference", t, n) : Hd(m0[e], "PropertyName", t, n);
}
function fx(e, t) {
  const n = ue(Js, "TimeInstant");
  e.appendChild(n);
  const s = ue(Js, "timePosition");
  n.appendChild(s), Rn(s, t);
}
function px(e, t, n) {
  const s = (
    /** @type {Object} */
    n[n.length - 1]
  ), r = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, s)
  );
  r.node = e, Cn(
    r,
    kf,
    nr("Query"),
    t,
    n
  );
}
function Hf(e) {
  let t;
  return e === "2.0.0" ? t = g0[e] : t = m0[e], t;
}
const Qc = G$, ni = [null, "http://www.opengis.net/wms"], J$ = qt(ni, {
  Service: mt(yU),
  Capability: mt(vU)
}), Q$ = qt(ni, {
  Request: mt(PU),
  Exception: mt(bU),
  Layer: mt(TU)
});
class q$ extends u0 {
  constructor() {
    super(), this.version = void 0;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(t) {
    this.version = t.getAttribute("version").trim();
    const n = At(
      {
        version: this.version
      },
      J$,
      t,
      []
    );
    return n || null;
  }
}
const tU = qt(ni, {
  Name: mt(Nt),
  Title: mt(Nt),
  Abstract: mt(Nt),
  KeywordList: mt(MS),
  OnlineResource: mt(gu),
  ContactInformation: mt(EU),
  Fees: mt(Nt),
  AccessConstraints: mt(Nt),
  LayerLimit: mt(qn),
  MaxWidth: mt(qn),
  MaxHeight: mt(qn)
}), eU = qt(ni, {
  ContactPersonPrimary: mt(CU),
  ContactPosition: mt(Nt),
  ContactAddress: mt(xU),
  ContactVoiceTelephone: mt(Nt),
  ContactFacsimileTelephone: mt(Nt),
  ContactElectronicMailAddress: mt(Nt)
}), nU = qt(ni, {
  ContactPerson: mt(Nt),
  ContactOrganization: mt(Nt)
}), iU = qt(ni, {
  AddressType: mt(Nt),
  Address: mt(Nt),
  City: mt(Nt),
  StateOrProvince: mt(Nt),
  PostCode: mt(Nt),
  Country: mt(Nt)
}), rU = qt(ni, {
  Format: Ht(Nt)
}), OS = qt(ni, {
  Name: mt(Nt),
  Title: mt(Nt),
  Abstract: mt(Nt),
  KeywordList: mt(MS),
  CRS: ke(Nt),
  EX_GeographicBoundingBox: mt(
    gU
  ),
  BoundingBox: ke(mU),
  Dimension: ke(OU),
  Attribution: mt(pU),
  AuthorityURL: ke(_U),
  Identifier: ke(Nt),
  MetadataURL: ke(IU),
  DataURL: ke(ra),
  FeatureListURL: ke(ra),
  Style: ke(DU),
  MinScaleDenominator: mt(Po),
  MaxScaleDenominator: mt(Po),
  Layer: ke(PS)
}), sU = qt(ni, {
  Title: mt(Nt),
  OnlineResource: mt(gu),
  LogoURL: mt(SS)
}), aU = qt(ni, {
  westBoundLongitude: mt(Po),
  eastBoundLongitude: mt(Po),
  southBoundLatitude: mt(Po),
  northBoundLatitude: mt(Po)
}), oU = qt(ni, {
  GetCapabilities: mt(Vp),
  GetMap: mt(Vp),
  GetFeatureInfo: mt(Vp)
}), lU = qt(ni, {
  Format: ke(Nt),
  DCPType: ke(SU)
}), uU = qt(ni, {
  HTTP: mt(MU)
}), cU = qt(ni, {
  Get: mt(ra),
  Post: mt(ra)
}), hU = qt(ni, {
  Name: mt(Nt),
  Title: mt(Nt),
  Abstract: mt(Nt),
  LegendURL: ke(SS),
  StyleSheetURL: mt(ra),
  StyleURL: mt(ra)
}), dU = qt(ni, {
  Format: mt(Nt),
  OnlineResource: mt(gu)
}), fU = qt(ni, {
  Keyword: Ht(Nt)
});
function pU(e, t) {
  return At({}, sU, e, t);
}
function mU(e, t) {
  const n = [
    Ws(e.getAttribute("minx")),
    Ws(e.getAttribute("miny")),
    Ws(e.getAttribute("maxx")),
    Ws(e.getAttribute("maxy"))
  ], s = [
    Ws(e.getAttribute("resx")),
    Ws(e.getAttribute("resy"))
  ];
  return {
    crs: e.getAttribute("CRS"),
    extent: n,
    res: s
  };
}
function gU(e, t) {
  const n = At(
    {},
    aU,
    e,
    t
  );
  if (!n)
    return;
  const s = (
    /** @type {number|undefined} */
    n.westBoundLongitude
  ), r = (
    /** @type {number|undefined} */
    n.southBoundLatitude
  ), i = (
    /** @type {number|undefined} */
    n.eastBoundLongitude
  ), a = (
    /** @type {number|undefined} */
    n.northBoundLatitude
  );
  if (!(s === void 0 || r === void 0 || i === void 0 || a === void 0))
    return [
      s,
      r,
      i,
      a
    ];
}
function vU(e, t) {
  return At({}, Q$, e, t);
}
function yU(e, t) {
  return At({}, tU, e, t);
}
function EU(e, t) {
  return At({}, eU, e, t);
}
function CU(e, t) {
  return At({}, nU, e, t);
}
function xU(e, t) {
  return At({}, iU, e, t);
}
function bU(e, t) {
  return At([], rU, e, t);
}
function TU(e, t) {
  const n = At({}, OS, e, t);
  return n.Layer === void 0 ? Object.assign(n, PS(e, t)) : n;
}
function PS(e, t) {
  const n = (
    /**  @type {!Object<string,*>} */
    t[t.length - 1]
  ), s = At({}, OS, e, t);
  if (!s)
    return;
  let r = Kl(e.getAttribute("queryable"));
  r === void 0 && (r = n.queryable), s.queryable = r !== void 0 ? r : !1;
  let i = Gs(e.getAttribute("cascaded"));
  i === void 0 && (i = n.cascaded), s.cascaded = i;
  let a = Kl(e.getAttribute("opaque"));
  a === void 0 && (a = n.opaque), s.opaque = a !== void 0 ? a : !1;
  let o = Kl(e.getAttribute("noSubsets"));
  o === void 0 && (o = n.noSubsets), s.noSubsets = o !== void 0 ? o : !1;
  let l = Ws(e.getAttribute("fixedWidth"));
  l || (l = n.fixedWidth), s.fixedWidth = l;
  let f = Ws(e.getAttribute("fixedHeight"));
  return f || (f = n.fixedHeight), s.fixedHeight = f, ["Style", "CRS", "AuthorityURL"].forEach(function(c) {
    if (c in n) {
      const h = s[c] || [];
      s[c] = h.concat(n[c]);
    }
  }), [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ].forEach(function(c) {
    if (!(c in s)) {
      const h = n[c];
      s[c] = h;
    }
  }), s;
}
function OU(e, t) {
  return {
    name: e.getAttribute("name"),
    units: e.getAttribute("units"),
    unitSymbol: e.getAttribute("unitSymbol"),
    default: e.getAttribute("default"),
    multipleValues: Kl(e.getAttribute("multipleValues")),
    nearestValue: Kl(e.getAttribute("nearestValue")),
    current: Kl(e.getAttribute("current")),
    values: Nt(e)
  };
}
function ra(e, t) {
  return At({}, dU, e, t);
}
function PU(e, t) {
  return At({}, oU, e, t);
}
function SU(e, t) {
  return At({}, uU, e, t);
}
function MU(e, t) {
  return At({}, cU, e, t);
}
function Vp(e, t) {
  return At({}, lU, e, t);
}
function SS(e, t) {
  const n = ra(e, t);
  if (n) {
    const s = [
      Gs(e.getAttribute("width")),
      Gs(e.getAttribute("height"))
    ];
    return n.size = s, n;
  }
}
function _U(e, t) {
  const n = ra(e, t);
  if (n)
    return n.name = e.getAttribute("name"), n;
}
function IU(e, t) {
  const n = ra(e, t);
  if (n)
    return n.type = e.getAttribute("type"), n;
}
function DU(e, t) {
  return At({}, hU, e, t);
}
function MS(e, t) {
  return At([], fU, e, t);
}
const AU = q$;
class LU extends Ur {
  /**
   * @param {Options} options Cluster options.
   */
  constructor(t) {
    super({
      attributions: t.attributions,
      wrapX: t.wrapX
    }), this.resolution = void 0, this.distance = t.distance !== void 0 ? t.distance : 20, this.minDistance = t.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = t.geometryFunction || function(n) {
      const s = (
        /** @type {Point} */
        n.getGeometry()
      );
      return Zt(s.getType() == "Point", 10), s;
    }, this.createCustomCluster_ = t.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(t.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(t) {
    this.features.length = 0, super.clear(t);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(t, n, s) {
    this.source.loadFeatures(t, n, s), n !== this.resolution && (this.resolution = n, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(t) {
    this.updateDistance(t, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(t) {
    this.updateDistance(this.distance, t);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource|null} source The new source for this instance.
   * @api
   */
  setSource(t) {
    this.source && this.source.removeEventListener(Kt.CHANGE, this.boundRefresh_), this.source = t, t && t.addEventListener(Kt.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(t, n) {
    const s = t === 0 ? 0 : Math.min(n, t) / t, r = t !== this.distance || this.interpolationRatio !== s;
    this.distance = t, this.minDistance = n, this.interpolationRatio = s, r && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const t = ji(), n = this.distance * this.resolution, s = this.source.getFeatures(), r = {};
    for (let i = 0, a = s.length; i < a; i++) {
      const o = s[i];
      if (!(Xt(o) in r)) {
        const l = this.geometryFunction(o);
        if (l) {
          const f = l.getCoordinates();
          iy(f, t), Br(t, n, t);
          const d = this.source.getFeaturesInExtent(t).filter(function(u) {
            const c = Xt(u);
            return c in r ? !1 : (r[c] = !0, !0);
          });
          this.features.push(this.createCluster(d, t));
        }
      }
    }
  }
  /**
   * @param {Array<Feature>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(t, n) {
    const s = [0, 0];
    for (let o = t.length - 1; o >= 0; --o) {
      const l = this.geometryFunction(t[o]);
      l ? o1(s, l.getCoordinates()) : t.splice(o, 1);
    }
    l1(s, 1 / t.length);
    const r = $i(n), i = this.interpolationRatio, a = new hi([
      s[0] * (1 - i) + r[0] * i,
      s[1] * (1 - i) + r[1] * i
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(a, t) : new Pi({
      geometry: a,
      features: t
    });
  }
}
const E0 = LU;
function C0(e, t, n) {
  let s, r, i;
  return typeof e == "string" ? r = e : typeof e == "function" ? s = e : typeof e == "object" && (i = n.readFeatures(e, {
    dataProjection: "EPSG:4326",
    featureProjection: "EPSG:25832"
  })), new Ur({
    loader: s,
    features: i,
    url: r,
    strategy: t,
    format: n
  });
}
function x0(e, t, n) {
  return new E0({
    source: e,
    distance: t,
    geometryFunction: n
  });
}
function RU(e, t) {
  const n = ["1.0.0", "1.1.0", "2.0.0"];
  let s = t.version || e.version;
  return n.includes(s) || (s = n[1], console.warn(`The "${e.typ}" layer with the id: "${e.id}" is configured in version: ${s}. OpenLayers accepts "${e.typ}" only in the versions: ${n}, It tries to load the layer with the id: "${e.id}" in version ${n[1]}!`)), s;
}
function rc(e, t = {}, n) {
  throw t.onLoadingError && t.onLoadingError(e), n(e), Error(e);
}
function b0(e, t, n, s, r, i = {}) {
  let a = t;
  try {
    i.featuresFilter && (a = i.featuresFilter(t)), e.addFeatures(a), i.afterLoading && i.afterLoading(a), s(a);
  } catch (o) {
    console.error(o), n(o, i, r);
  }
}
function _S(e, t, n, s) {
  return e.ok ? e : t(`Request to wfs-filter failed. Response status is ${e.status}`, n, s);
}
function wU(e) {
  return {
    method: "POST",
    headers: {
      "Content-Type": "text/xml"
    },
    body: e
  };
}
function IS(e, t, n, { onErrorFn: s, success: r, failure: i }, a) {
  fetch(e, t).then((o) => _S(o, s, a, i)).then((o) => o.text()).then((o) => n.getFormat().readFeatures(o)).then((o) => b0(n, o, s, r, i, a)).catch((o) => {
    console.error(o);
  });
}
function VU(e, t, n, { onErrorFn: s, success: r, failure: i }, a) {
  fetch(e).then((o) => _S(o, s, a, i)).then((o) => o.text()).then((o) => IS(t, wU(o), n, { onErrorFn: s, success: r, failure: i }, a)).catch((o) => {
    console.error(o);
  });
}
function BU(e, t, n, s) {
  let r = `${e.url}?service=WFS&version=${t}&request=GetFeature&srsName=${n.getCode()}${s}`;
  return t === "1.0.0" || t === "1.1.0" ? r = `${r}&typeName=${e.featureType}` : t === "2.0.0" && (r = `${r}&typeNames=${e.featureType}`), r;
}
function DS(e, t = {}) {
  t.loadingStrategy || (t.loadingStrategy = Kg);
  const n = RU(e, t), s = new Qc({
    featureNS: e.featureNS,
    version: n
  });
  let r = null;
  function i(a, o, l, f, d) {
    if (t.doNotLoadInitially)
      b0(r, [], rc, f, d, t);
    else if (t.wfsFilter)
      VU(t.wfsFilter, e.url, r, { onErrorFn: rc, success: f, failure: d }, t);
    else {
      const u = t.loadingStrategy === Kg ? `&bbox=${a.join(",")},${l.getCode()}` : "";
      let c = BU(e, n, l, u);
      if (t.loadingParams)
        for (const h in t.loadingParams) {
          const p = Array.isArray(t.loadingParams[h]) ? t.loadingParams[h].join(",") : t.loadingParams[h];
          p !== void 0 && h === "bbox" ? c += `&${h}=${p},${l.getCode()}` : p !== void 0 && (c += `&${h}=${p}`);
        }
      IS(c, {}, r, { onErrorFn: rc, success: f, failure: d }, t);
    }
  }
  return s.featureType = e.featureType, r = C0(i, t.loadingStrategy, s), t.beforeLoading && r.once("featuresloadstart", () => t.beforeLoading()), e.clusterDistance ? x0(r, e.clusterDistance, t.clusterGeometryFunction) : r;
}
function FU(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = DS(e, n), r = new sr(Object.assign({
    source: s,
    id: e.id
  }, t));
  return n.style ? r.setStyle(n.style) : e.style && r.setStyle(e.style), r;
}
const AS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: FU,
  createLayerSource: DS
}, Symbol.toStringTag, { value: "Module" })), NU = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMCA0MyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+REI2QzQ5NEUtODhFOC00OUYxLTg5Q0UtOTdDQkVDM0E1MjQwPC90aXRsZT48cGF0aCBkPSJNMTQuNTg0IDFDNy4xMDEgMSAxIDcuMTAxIDEgMTQuNTg0YzAgOC4xMDMgNy44NjUgMjAuNDQ4IDExLjYzIDI1LjkzYTIuMzYgMi4zNiAwIDAgMCAzLjkwOCAwYzMuNzY2LTUuNDgyIDExLjYzLTE3LjkyMiAxMS42My0yNS45M0MyOC4xNjggNy4wNTQgMjIuMDY4IDEgMTQuNTg0IDF6IiBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0iIzAwNUNBOSIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9zdmc+DQo=";
let LS = {};
function jU(e) {
  LS = e;
}
const RS = new vs({
  crossOrigin: "anonymous",
  src: NU,
  // center bottom of marker  is intended to show the spot
  anchor: [0.5, 1]
}), Yf = new vr({
  width: 2,
  color: "#005CA9"
}), T0 = new wr({
  color: "#005CA915"
}), mx = new Mn({ image: RS }), gx = new Mn({ stroke: Yf }), vx = new Mn({ stroke: Yf, fill: T0 }), $U = new Mn({ stroke: Yf, fill: T0 }), UU = new Mn({ stroke: Yf, fill: T0, image: RS }), WU = {
  Point: mx,
  LineString: gx,
  MultiLineString: gx,
  MultiPoint: mx,
  MultiPolygon: vx,
  Polygon: vx,
  GeometryCollection: UU,
  Circle: $U
};
function zU(e) {
  const t = e.getGeometry().getType();
  return LS[t] || WU[t];
}
function wS({ url: e, features: t, clusterDistance: n }, s) {
  const r = new Wr();
  let i = null;
  return i = C0(e || t, s.loadingStrategy, r), n ? x0(i, n, s.clusterGeometryFunction) : (i.once("featuresloadend", (a) => {
    typeof s.afterLoading == "function" && s.afterLoading(a == null ? void 0 : a.features);
  }), i);
}
function KU(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = new sr(Object.assign({
    id: e.id,
    source: wS(e, n)
  }, t));
  return n.style ? s.setStyle(n.style) : e.style ? s.setStyle(e.style) : s.setStyle(zU), s;
}
function GU(e) {
  e.getSource().refresh();
}
function Xf(e, t) {
  e.forEach((n) => n.setStyle(t));
}
function VS(e) {
  Xf(e.getSource().getFeatures(), () => null);
}
function kU(e) {
  Xf(e.getSource().getFeatures(), void 0);
}
function HU(e, t) {
  const n = e.getSource().getFeatures().filter((s) => t.indexOf(s.getId()) >= 0);
  VS(e), Xf(n, void 0);
}
const BS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: KU,
  createLayerSource: wS,
  hideAllFeatures: VS,
  setCustomStyles: jU,
  setFeatureStyle: Xf,
  showAllFeatures: kU,
  showFeaturesById: HU,
  updateSource: GU
}, Symbol.toStringTag, { value: "Module" }));
function YU(e) {
  return new Ur({
    features: e.features
  });
}
function XU(e, t) {
  e.getSource().clear(!0), e.getSource().addFeatures(t);
}
function ZU(e) {
  const t = this.createLayerSource(e);
  return new sr({
    source: t,
    name: e.name,
    typ: e.typ,
    gfiAttributes: e.gfiAttributes,
    id: e.id
  });
}
const FS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: ZU,
  createLayerSource: YU,
  updateSource: XU
}, Symbol.toStringTag, { value: "Module" })), JU = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, QU = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class qU extends KP {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(t) {
    super(t), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.tmpTransform_ = tr();
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(t, n, s) {
    let r;
    const i = t.getState();
    return (i === _t.LOADED || i === _t.ERROR) && (this.updateExecutorGroup_(t, n, s), this.tileImageNeedsRender_(t) && (r = !0)), r;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(t, n, s, r) {
    const i = r.pixelRatio, a = r.viewState, o = a.resolution, l = a.projection, f = this.getLayer(), d = f.getSource().getTile(t, n, s, i, l), u = r.viewHints, c = !(u[en.ANIMATING] || u[en.INTERACTING]);
    return (c || !d.wantedResolution) && (d.wantedResolution = o), this.prepareTile(d, i, l) && (c || Date.now() - r.time < 8) && f.getRenderMode() !== "vector" && this.renderTileImage_(d, r), super.getTile(t, n, s, r);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(t) {
    const n = this.getLayer();
    return super.isDrawableTile(t) && (n.getRenderMode() === "vector" ? Xt(n) in t.executorGroups : t.hasContext(n));
  }
  /**
   * @inheritDoc
   */
  getTileImage(t) {
    return t.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(t) {
    const n = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== n && (this.renderedLayerRevision_ = n, this.renderedTiles.length = 0), super.prepareFrame(t);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(t, n, s) {
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), i = r.getRevision(), a = r.getRenderOrder() || null, o = t.wantedResolution, l = t.getReplayState(r);
    if (!l.dirty && l.renderedResolution === o && l.renderedRevision == i && l.renderedRenderOrder == a)
      return;
    const f = r.getSource(), d = r.getDeclutter(), u = f.getTileGrid(), h = f.getTileGridForProjection(s).getTileCoordExtent(t.wrappedTileCoord), p = f.getSourceTiles(n, s, t), g = Xt(r);
    delete t.hitDetectionImageData[g], t.executorGroups[g] = [], d && (t.declutterExecutorGroups[g] = []), l.dirty = !1;
    for (let m = 0, v = p.length; m < v; ++m) {
      const y = p[m];
      if (y.getState() != _t.LOADED)
        continue;
      const E = y.tileCoord, C = u.getTileCoordExtent(E), x = Ys(h, C), b = Br(
        x,
        r.getRenderBuffer() * o,
        this.tmpExtent
      ), P = Fo(C, x) ? null : b, O = new Ld(
        0,
        b,
        o,
        n
      ), T = d ? new Ld(0, x, o, n) : void 0, M = Z1(
        o,
        n
      ), L = function(B) {
        let j;
        const k = B.getStyleFunction() || r.getStyleFunction();
        if (k && (j = k(B, o)), j) {
          const X = this.renderFeature(
            B,
            M,
            j,
            O,
            T
          );
          l.dirty = l.dirty || X;
        }
      }, A = y.getFeatures();
      a && a !== l.renderedRenderOrder && A.sort(a);
      for (let B = 0, j = A.length; B < j; ++B) {
        const k = A[B];
        (!P || hn(P, k.getGeometry().getExtent())) && L.call(this, k);
      }
      const D = O.finish(), I = r.getRenderMode() !== "vector" && d && p.length === 1 ? null : x, w = new Rd(
        I,
        o,
        n,
        f.getOverlaps(),
        D,
        r.getRenderBuffer()
      );
      if (t.executorGroups[g].push(w), T) {
        const B = new Rd(
          null,
          o,
          n,
          f.getOverlaps(),
          T.finish(),
          r.getRenderBuffer()
        );
        t.declutterExecutorGroups[g].push(B);
      }
    }
    l.renderedRevision = i, l.renderedRenderOrder = a, l.renderedResolution = o;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(t, n, s, r, i) {
    const a = n.viewState.resolution, o = n.viewState.rotation;
    s = s ?? 0;
    const l = this.getLayer(), d = l.getSource().getTileGridForProjection(
      n.viewState.projection
    ), u = Jl([t]);
    Br(u, a * s, u);
    const c = {}, h = function(m, v, y) {
      let E = m.getId();
      E === void 0 && (E = Xt(m));
      const C = c[E];
      if (C) {
        if (C !== !0 && y < C.distanceSq) {
          if (y === 0)
            return c[E] = !0, i.splice(i.lastIndexOf(C), 1), r(m, l, v);
          C.geometry = v, C.distanceSq = y;
        }
      } else {
        if (y === 0)
          return c[E] = !0, r(m, l, v);
        i.push(
          c[E] = {
            feature: m,
            layer: l,
            geometry: v,
            distanceSq: y,
            callback: r
          }
        );
      }
    }, p = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let g;
    for (let m = 0, v = p.length; !g && m < v; ++m) {
      const y = p[m], E = d.getTileCoordExtent(y.wrappedTileCoord);
      if (!hn(E, u))
        continue;
      const C = Xt(l), x = [y.executorGroups[C]], b = y.declutterExecutorGroups[C];
      b && x.push(b), x.some((P) => {
        const O = P === b ? n.declutterTree.all().map((T) => T.value) : null;
        for (let T = 0, M = P.length; T < M; ++T)
          if (g = P[T].forEachFeatureAtCoordinate(
            t,
            a,
            o,
            s,
            h,
            O
          ), g)
            return !0;
      });
    }
    return g;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */
  getFeatures(t) {
    return new Promise(
      (function(n, s) {
        const r = (
          /** @type {import("../../layer/VectorTile.js").default} */
          this.getLayer()
        ), i = Xt(r), a = r.getSource(), o = this.renderedProjection, l = o.getExtent(), f = this.renderedResolution, d = a.getTileGridForProjection(o), u = Ln(
          this.renderedPixelToCoordinateTransform_,
          t.slice()
        ), c = d.getTileCoordForCoordAndResolution(
          u,
          f
        );
        let h;
        for (let E = 0, C = this.renderedTiles.length; E < C; ++E)
          if (c.toString() === this.renderedTiles[E].tileCoord.toString()) {
            if (h = this.renderedTiles[E], h.getState() === _t.LOADED) {
              const x = d.getTileCoordExtent(h.tileCoord);
              a.getWrapX() && o.canWrapX() && !Rr(l, x) && oy(u, o);
              break;
            }
            h = void 0;
          }
        if (!h || h.loadingSourceTiles > 0) {
          n([]);
          return;
        }
        const p = d.getTileCoordExtent(h.wrappedTileCoord), g = gs(p), m = [
          (u[0] - g[0]) / f,
          (g[1] - u[1]) / f
        ], v = h.getSourceTiles().reduce(function(E, C) {
          return E.concat(C.getFeatures());
        }, []);
        let y = h.hitDetectionImageData[i];
        if (!y && !this.animatingOrInteracting_) {
          const E = ti(
            d.getTileSize(
              d.getZForResolution(f, a.zDirection)
            )
          ), C = this.renderedRotation_, x = [
            this.getRenderTransform(
              d.getTileCoordCenter(h.wrappedTileCoord),
              f,
              0,
              Qi,
              E[0] * Qi,
              E[1] * Qi,
              0
            )
          ];
          y = H1(
            E,
            x,
            v,
            r.getStyleFunction(),
            d.getTileCoordExtent(h.wrappedTileCoord),
            h.getReplayState(r).renderedResolution,
            C
          ), h.hitDetectionImageData[i] = y;
        }
        n(Y1(m, v, y));
      }).bind(this)
    );
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const t = this.getLayer();
    t.getVisible() && this.renderedLayerRevision_ !== void 0 && t.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(t) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(t) {
    const n = this.context, s = n.globalAlpha;
    n.globalAlpha = this.getLayer().getOpacity();
    const r = t.viewHints, i = !(r[en.ANIMATING] || r[en.INTERACTING]), a = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let o = 0, l = a.length; o < l; ++o) {
      const f = a[o], d = f.declutterExecutorGroups[Xt(this.getLayer())];
      if (d)
        for (let u = d.length - 1; u >= 0; --u)
          d[u].execute(
            this.context,
            1,
            this.getTileRenderTransform(f, t),
            t.viewState.rotation,
            i,
            void 0,
            t.declutterTree
          );
    }
    n.globalAlpha = s;
  }
  getTileRenderTransform(t, n) {
    const s = n.pixelRatio, r = n.viewState, i = r.center, a = r.resolution, o = r.rotation, l = n.size, f = Math.round(l[0] * s), d = Math.round(l[1] * s), c = this.getLayer().getSource().getTileGridForProjection(
      n.viewState.projection
    ), h = t.tileCoord, p = c.getTileCoordExtent(t.wrappedTileCoord), g = c.getTileCoordExtent(h, this.tmpExtent)[0] - p[0];
    return ty(
      ud(this.inversePixelTransform.slice(), 1 / s, 1 / s),
      this.getRenderTransform(
        i,
        a,
        o,
        s,
        f,
        d,
        g
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(t, n) {
    const s = n.viewHints, r = !(s[en.ANIMATING] || s[en.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = n.pixelToCoordinateTransform.slice(), this.renderedRotation_ = n.viewState.rotation;
    const i = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), a = i.getRenderMode(), o = t.globalAlpha;
    t.globalAlpha = i.getOpacity();
    const l = QU[a], f = n.viewState, d = f.rotation, u = i.getSource(), h = u.getTileGridForProjection(f.projection).getZForResolution(
      f.resolution,
      u.zDirection
    ), p = this.renderedTiles, g = [], m = [];
    let v = !0;
    for (let y = p.length - 1; y >= 0; --y) {
      const E = (
        /** @type {import("../../VectorRenderTile.js").default} */
        p[y]
      );
      v = v && !E.getReplayState(i).dirty;
      const C = E.executorGroups[Xt(i)].filter(
        (T) => T.hasExecutors(l)
      );
      if (C.length === 0)
        continue;
      const x = this.getTileRenderTransform(E, n), b = E.tileCoord[0];
      let P = !1;
      const O = C[0].getClipCoords(x);
      if (O) {
        for (let T = 0, M = g.length; T < M; ++T)
          if (h !== b && b < m[T]) {
            const L = g[T];
            hn(
              [
                O[0],
                O[3],
                O[4],
                O[7]
              ],
              [L[0], L[3], L[4], L[7]]
            ) && (P || (t.save(), P = !0), t.beginPath(), t.moveTo(O[0], O[1]), t.lineTo(O[2], O[3]), t.lineTo(O[4], O[5]), t.lineTo(O[6], O[7]), t.moveTo(L[6], L[7]), t.lineTo(L[4], L[5]), t.lineTo(L[2], L[3]), t.lineTo(L[0], L[1]), t.clip());
          }
        g.push(O), m.push(b);
      }
      for (let T = 0, M = C.length; T < M; ++T)
        C[T].execute(
          t,
          1,
          x,
          d,
          r,
          l
        );
      P && t.restore();
    }
    t.globalAlpha = o, this.ready = v, super.postRender(t, n);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(t, n, s, r, i) {
    if (!s)
      return !1;
    let a = !1;
    if (Array.isArray(s))
      for (let o = 0, l = s.length; o < l; ++o)
        a = wd(
          r,
          t,
          s[o],
          n,
          this.boundHandleStyleImageChange_,
          void 0,
          i
        ) || a;
    else
      a = wd(
        r,
        t,
        s,
        n,
        this.boundHandleStyleImageChange_,
        void 0,
        i
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(t) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (n.getRenderMode() === "vector")
      return !1;
    const s = t.getReplayState(n), r = n.getRevision(), i = t.wantedResolution;
    return s.renderedTileResolution !== i || s.renderedTileRevision !== r;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(t, n) {
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), r = t.getReplayState(s), i = s.getRevision(), a = t.executorGroups[Xt(s)];
    r.renderedTileRevision = i;
    const o = t.wrappedTileCoord, l = o[0], f = s.getSource();
    let d = n.pixelRatio;
    const c = n.viewState.projection, h = f.getTileGridForProjection(c), p = h.getResolution(t.tileCoord[0]), g = n.pixelRatio / t.wantedResolution * p, m = h.getResolution(l), v = t.getContext(s);
    d = Math.round(
      Math.max(d, g / d)
    );
    const y = f.getTilePixelSize(l, d, c);
    v.canvas.width = y[0], v.canvas.height = y[1];
    const E = d / g;
    if (E !== 1) {
      const P = BE(this.tmpTransform_);
      ud(P, E, E), v.setTransform.apply(v, P);
    }
    const C = h.getTileCoordExtent(o, this.tmpExtent), x = g / m, b = BE(this.tmpTransform_);
    ud(b, x, -x), fD(b, -C[0], -C[3]);
    for (let P = 0, O = a.length; P < O; ++P)
      a[P].execute(
        v,
        E,
        b,
        0,
        !0,
        JU[s.getRenderMode()]
      );
    r.renderedTileResolution = t.wantedResolution;
  }
}
const tW = qU;
class eW extends z1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {};
    const n = (
      /** @type {Object} */
      Object.assign({}, t)
    );
    delete n.preload, delete n.useInterimTilesOnError, super(
      /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
      n
    ), this.on, this.once, this.un;
    const s = t.renderMode || "hybrid";
    Zt(s == "hybrid" || s == "vector", 28), this.renderMode_ = s, this.setPreload(t.preload ? t.preload : 0), this.setUseInterimTilesOnError(
      t.useInterimTilesOnError !== void 0 ? t.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new tW(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(t) {
    return super.getFeatures(t);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Aa.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Aa.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(t) {
    this.set(Aa.PRELOAD, t);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(t) {
    this.set(Aa.USE_INTERIM_TILES_ON_ERROR, t);
  }
}
const O0 = eW;
class nW extends XP {
  /**
   * @param {!Options} options Vector tile options.
   */
  constructor(t) {
    const n = t.projection || "EPSG:3857", s = t.extent || Wf(n), r = t.tileGrid || cN({
      extent: s,
      maxResolution: t.maxResolution,
      maxZoom: t.maxZoom !== void 0 ? t.maxZoom : 22,
      minZoom: t.minZoom,
      tileSize: t.tileSize || 512
    });
    super({
      attributions: t.attributions,
      attributionsCollapsible: t.attributionsCollapsible,
      cacheSize: t.cacheSize,
      interpolate: !0,
      opaque: !1,
      projection: n,
      state: t.state,
      tileGrid: r,
      tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : iW,
      tileUrlFunction: t.tileUrlFunction,
      url: t.url,
      urls: t.urls,
      wrapX: t.wrapX === void 0 ? !0 : t.wrapX,
      transition: t.transition,
      zDirection: t.zDirection === void 0 ? 1 : t.zDirection
    }), this.format_ = t.format ? t.format : null, this.sourceTileCache = new Hy(this.tileCache.highWaterMark), this.overlaps_ = t.overlaps == null ? !0 : t.overlaps, this.tileClass = t.tileClass ? t.tileClass : rw, this.tileGrids_ = {};
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeaturesInExtent(t) {
    const n = [], s = this.tileCache;
    if (s.getCount() === 0)
      return n;
    const r = uP(s.peekFirstKey())[0], i = this.tileGrid;
    return s.forEach(function(a) {
      if (a.tileCoord[0] !== r || a.getState() !== _t.LOADED)
        return;
      const o = a.getSourceTiles();
      for (let l = 0, f = o.length; l < f; ++l) {
        const d = o[l], u = d.tileCoord;
        if (hn(t, i.getTileCoordExtent(u))) {
          const c = d.getFeatures();
          if (c)
            for (let h = 0, p = c.length; h < p; ++h) {
              const g = c[h], m = g.getGeometry();
              hn(t, m.getExtent()) && n.push(g);
            }
        }
      }
    }), n;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  clear() {
    this.tileCache.clear(), this.sourceTileCache.clear();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(t, n) {
    const s = this.getTileCacheForProjection(t), r = Object.keys(n).reduce((i, a) => {
      const o = QR(a), l = s.peek(o);
      if (l) {
        const f = l.sourceTiles;
        for (let d = 0, u = f.length; d < u; ++d)
          i[f[d].getKey()] = !0;
      }
      return i;
    }, {});
    super.expireCache(t, n), this.sourceTileCache.expireCache(r);
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(t, n, s) {
    if (s.getState() === _t.IDLE) {
      s.setState(_t.LOADING);
      const r = s.wrappedTileCoord, i = this.getTileGridForProjection(n), a = i.getTileCoordExtent(r), o = r[0], l = i.getResolution(o);
      Br(a, -l, a);
      const f = this.tileGrid, d = f.getExtent();
      d && Ys(a, d, a);
      const u = f.getZForResolution(
        l,
        this.zDirection
      );
      f.forEachTileCoord(a, u, (c) => {
        const h = this.tileUrlFunction(
          c,
          t,
          n
        ), p = this.sourceTileCache.containsKey(h) ? this.sourceTileCache.get(h) : new this.tileClass(
          c,
          h ? _t.IDLE : _t.EMPTY,
          h,
          this.format_,
          this.tileLoadFunction
        );
        s.sourceTiles.push(p);
        const g = p.getState();
        if (g < _t.LOADED) {
          const m = (v) => {
            this.handleTileChange(v);
            const y = p.getState();
            if (y === _t.LOADED || y === _t.ERROR) {
              const E = p.getKey();
              E in s.errorTileKeys ? p.getState() === _t.LOADED && delete s.errorTileKeys[E] : s.loadingSourceTiles--, y === _t.ERROR ? s.errorTileKeys[E] = !0 : p.removeEventListener(Kt.CHANGE, m), s.loadingSourceTiles === 0 && s.setState(
                Bo(s.errorTileKeys) ? _t.LOADED : _t.ERROR
              );
            }
          };
          p.addEventListener(Kt.CHANGE, m), s.loadingSourceTiles++;
        }
        g === _t.IDLE && (p.extent = f.getTileCoordExtent(c), p.projection = n, p.resolution = f.getResolution(
          c[0]
        ), this.sourceTileCache.set(h, p), p.load());
      }), s.loadingSourceTiles || s.setState(
        s.sourceTiles.some(
          (c) => c.getState() === _t.ERROR
        ) ? _t.ERROR : _t.LOADED
      );
    }
    return s.sourceTiles;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */
  getTile(t, n, s, r, i) {
    const a = fu(t, n, s), o = this.getKey();
    let l;
    if (this.tileCache.containsKey(a) && (l = this.tileCache.get(a), l.key === o))
      return l;
    const f = [t, n, s];
    let d = this.getTileCoordForTileUrlFunction(
      f,
      i
    );
    const u = this.getTileGrid().getExtent(), c = this.getTileGridForProjection(i);
    if (d && u) {
      const g = c.getTileCoordExtent(d);
      Br(g, -c.getResolution(t), g), hn(u, g) || (d = null);
    }
    let h = !0;
    if (d !== null) {
      const g = this.tileGrid, m = c.getResolution(t), v = g.getZForResolution(m, 1), y = c.getTileCoordExtent(d);
      Br(y, -m, y), g.forEachTileCoord(
        y,
        v,
        (function(E) {
          h = h && !this.tileUrlFunction(E, r, i);
        }).bind(this)
      );
    }
    const p = new nw(
      f,
      h ? _t.EMPTY : _t.IDLE,
      d,
      this.getSourceTiles.bind(this, r, i)
    );
    return p.key = o, l ? (p.interimTile = l, p.refreshInterimChain(), this.tileCache.replace(a, p)) : this.tileCache.set(a, p), p;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(t) {
    const n = t.getCode();
    let s = this.tileGrids_[n];
    if (!s) {
      const r = this.tileGrid, i = r.getResolutions().slice(), a = i.map(function(f, d) {
        return r.getOrigin(d);
      }), o = i.map(function(f, d) {
        return r.getTileSize(d);
      }), l = nP + 1;
      for (let f = i.length; f < l; ++f)
        i.push(i[f - 1] / 2), a.push(a[f - 1]), o.push(o[f - 1]);
      s = new mu({
        extent: r.getExtent(),
        origins: a,
        resolutions: i,
        tileSizes: o
      }), this.tileGrids_[n] = s;
    }
    return s;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(t) {
    return t;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(t, n, s) {
    const r = this.getTileGridForProjection(s), i = ti(r.getTileSize(t), this.tmpSize);
    return [
      Math.round(i[0] * n),
      Math.round(i[1] * n)
    ];
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(t, n) {
    super.updateCacheSize(t * 2, n), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(n).highWaterMark;
  }
}
const NS = nW;
function iW(e, t) {
  e.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(n, s, r) {
      Q1(
        t,
        e.getFormat(),
        n,
        s,
        r,
        e.onLoad.bind(e),
        e.onError.bind(e)
      );
    }
  );
}
var rW = {}, jS, yx = {
  transparent: [
    0,
    0,
    0,
    0
  ],
  aliceblue: [
    240,
    248,
    255,
    1
  ],
  antiquewhite: [
    250,
    235,
    215,
    1
  ],
  aqua: [
    0,
    255,
    255,
    1
  ],
  aquamarine: [
    127,
    255,
    212,
    1
  ],
  azure: [
    240,
    255,
    255,
    1
  ],
  beige: [
    245,
    245,
    220,
    1
  ],
  bisque: [
    255,
    228,
    196,
    1
  ],
  black: [
    0,
    0,
    0,
    1
  ],
  blanchedalmond: [
    255,
    235,
    205,
    1
  ],
  blue: [
    0,
    0,
    255,
    1
  ],
  blueviolet: [
    138,
    43,
    226,
    1
  ],
  brown: [
    165,
    42,
    42,
    1
  ],
  burlywood: [
    222,
    184,
    135,
    1
  ],
  cadetblue: [
    95,
    158,
    160,
    1
  ],
  chartreuse: [
    127,
    255,
    0,
    1
  ],
  chocolate: [
    210,
    105,
    30,
    1
  ],
  coral: [
    255,
    127,
    80,
    1
  ],
  cornflowerblue: [
    100,
    149,
    237,
    1
  ],
  cornsilk: [
    255,
    248,
    220,
    1
  ],
  crimson: [
    220,
    20,
    60,
    1
  ],
  cyan: [
    0,
    255,
    255,
    1
  ],
  darkblue: [
    0,
    0,
    139,
    1
  ],
  darkcyan: [
    0,
    139,
    139,
    1
  ],
  darkgoldenrod: [
    184,
    134,
    11,
    1
  ],
  darkgray: [
    169,
    169,
    169,
    1
  ],
  darkgreen: [
    0,
    100,
    0,
    1
  ],
  darkgrey: [
    169,
    169,
    169,
    1
  ],
  darkkhaki: [
    189,
    183,
    107,
    1
  ],
  darkmagenta: [
    139,
    0,
    139,
    1
  ],
  darkolivegreen: [
    85,
    107,
    47,
    1
  ],
  darkorange: [
    255,
    140,
    0,
    1
  ],
  darkorchid: [
    153,
    50,
    204,
    1
  ],
  darkred: [
    139,
    0,
    0,
    1
  ],
  darksalmon: [
    233,
    150,
    122,
    1
  ],
  darkseagreen: [
    143,
    188,
    143,
    1
  ],
  darkslateblue: [
    72,
    61,
    139,
    1
  ],
  darkslategray: [
    47,
    79,
    79,
    1
  ],
  darkslategrey: [
    47,
    79,
    79,
    1
  ],
  darkturquoise: [
    0,
    206,
    209,
    1
  ],
  darkviolet: [
    148,
    0,
    211,
    1
  ],
  deeppink: [
    255,
    20,
    147,
    1
  ],
  deepskyblue: [
    0,
    191,
    255,
    1
  ],
  dimgray: [
    105,
    105,
    105,
    1
  ],
  dimgrey: [
    105,
    105,
    105,
    1
  ],
  dodgerblue: [
    30,
    144,
    255,
    1
  ],
  firebrick: [
    178,
    34,
    34,
    1
  ],
  floralwhite: [
    255,
    250,
    240,
    1
  ],
  forestgreen: [
    34,
    139,
    34,
    1
  ],
  fuchsia: [
    255,
    0,
    255,
    1
  ],
  gainsboro: [
    220,
    220,
    220,
    1
  ],
  ghostwhite: [
    248,
    248,
    255,
    1
  ],
  gold: [
    255,
    215,
    0,
    1
  ],
  goldenrod: [
    218,
    165,
    32,
    1
  ],
  gray: [
    128,
    128,
    128,
    1
  ],
  green: [
    0,
    128,
    0,
    1
  ],
  greenyellow: [
    173,
    255,
    47,
    1
  ],
  grey: [
    128,
    128,
    128,
    1
  ],
  honeydew: [
    240,
    255,
    240,
    1
  ],
  hotpink: [
    255,
    105,
    180,
    1
  ],
  indianred: [
    205,
    92,
    92,
    1
  ],
  indigo: [
    75,
    0,
    130,
    1
  ],
  ivory: [
    255,
    255,
    240,
    1
  ],
  khaki: [
    240,
    230,
    140,
    1
  ],
  lavender: [
    230,
    230,
    250,
    1
  ],
  lavenderblush: [
    255,
    240,
    245,
    1
  ],
  lawngreen: [
    124,
    252,
    0,
    1
  ],
  lemonchiffon: [
    255,
    250,
    205,
    1
  ],
  lightblue: [
    173,
    216,
    230,
    1
  ],
  lightcoral: [
    240,
    128,
    128,
    1
  ],
  lightcyan: [
    224,
    255,
    255,
    1
  ],
  lightgoldenrodyellow: [
    250,
    250,
    210,
    1
  ],
  lightgray: [
    211,
    211,
    211,
    1
  ],
  lightgreen: [
    144,
    238,
    144,
    1
  ],
  lightgrey: [
    211,
    211,
    211,
    1
  ],
  lightpink: [
    255,
    182,
    193,
    1
  ],
  lightsalmon: [
    255,
    160,
    122,
    1
  ],
  lightseagreen: [
    32,
    178,
    170,
    1
  ],
  lightskyblue: [
    135,
    206,
    250,
    1
  ],
  lightslategray: [
    119,
    136,
    153,
    1
  ],
  lightslategrey: [
    119,
    136,
    153,
    1
  ],
  lightsteelblue: [
    176,
    196,
    222,
    1
  ],
  lightyellow: [
    255,
    255,
    224,
    1
  ],
  lime: [
    0,
    255,
    0,
    1
  ],
  limegreen: [
    50,
    205,
    50,
    1
  ],
  linen: [
    250,
    240,
    230,
    1
  ],
  magenta: [
    255,
    0,
    255,
    1
  ],
  maroon: [
    128,
    0,
    0,
    1
  ],
  mediumaquamarine: [
    102,
    205,
    170,
    1
  ],
  mediumblue: [
    0,
    0,
    205,
    1
  ],
  mediumorchid: [
    186,
    85,
    211,
    1
  ],
  mediumpurple: [
    147,
    112,
    219,
    1
  ],
  mediumseagreen: [
    60,
    179,
    113,
    1
  ],
  mediumslateblue: [
    123,
    104,
    238,
    1
  ],
  mediumspringgreen: [
    0,
    250,
    154,
    1
  ],
  mediumturquoise: [
    72,
    209,
    204,
    1
  ],
  mediumvioletred: [
    199,
    21,
    133,
    1
  ],
  midnightblue: [
    25,
    25,
    112,
    1
  ],
  mintcream: [
    245,
    255,
    250,
    1
  ],
  mistyrose: [
    255,
    228,
    225,
    1
  ],
  moccasin: [
    255,
    228,
    181,
    1
  ],
  navajowhite: [
    255,
    222,
    173,
    1
  ],
  navy: [
    0,
    0,
    128,
    1
  ],
  oldlace: [
    253,
    245,
    230,
    1
  ],
  olive: [
    128,
    128,
    0,
    1
  ],
  olivedrab: [
    107,
    142,
    35,
    1
  ],
  orange: [
    255,
    165,
    0,
    1
  ],
  orangered: [
    255,
    69,
    0,
    1
  ],
  orchid: [
    218,
    112,
    214,
    1
  ],
  palegoldenrod: [
    238,
    232,
    170,
    1
  ],
  palegreen: [
    152,
    251,
    152,
    1
  ],
  paleturquoise: [
    175,
    238,
    238,
    1
  ],
  palevioletred: [
    219,
    112,
    147,
    1
  ],
  papayawhip: [
    255,
    239,
    213,
    1
  ],
  peachpuff: [
    255,
    218,
    185,
    1
  ],
  peru: [
    205,
    133,
    63,
    1
  ],
  pink: [
    255,
    192,
    203,
    1
  ],
  plum: [
    221,
    160,
    221,
    1
  ],
  powderblue: [
    176,
    224,
    230,
    1
  ],
  purple: [
    128,
    0,
    128,
    1
  ],
  rebeccapurple: [
    102,
    51,
    153,
    1
  ],
  red: [
    255,
    0,
    0,
    1
  ],
  rosybrown: [
    188,
    143,
    143,
    1
  ],
  royalblue: [
    65,
    105,
    225,
    1
  ],
  saddlebrown: [
    139,
    69,
    19,
    1
  ],
  salmon: [
    250,
    128,
    114,
    1
  ],
  sandybrown: [
    244,
    164,
    96,
    1
  ],
  seagreen: [
    46,
    139,
    87,
    1
  ],
  seashell: [
    255,
    245,
    238,
    1
  ],
  sienna: [
    160,
    82,
    45,
    1
  ],
  silver: [
    192,
    192,
    192,
    1
  ],
  skyblue: [
    135,
    206,
    235,
    1
  ],
  slateblue: [
    106,
    90,
    205,
    1
  ],
  slategray: [
    112,
    128,
    144,
    1
  ],
  slategrey: [
    112,
    128,
    144,
    1
  ],
  snow: [
    255,
    250,
    250,
    1
  ],
  springgreen: [
    0,
    255,
    127,
    1
  ],
  steelblue: [
    70,
    130,
    180,
    1
  ],
  tan: [
    210,
    180,
    140,
    1
  ],
  teal: [
    0,
    128,
    128,
    1
  ],
  thistle: [
    216,
    191,
    216,
    1
  ],
  tomato: [
    255,
    99,
    71,
    1
  ],
  turquoise: [
    64,
    224,
    208,
    1
  ],
  violet: [
    238,
    130,
    238,
    1
  ],
  wheat: [
    245,
    222,
    179,
    1
  ],
  white: [
    255,
    255,
    255,
    1
  ],
  whitesmoke: [
    245,
    245,
    245,
    1
  ],
  yellow: [
    255,
    255,
    0,
    1
  ],
  yellowgreen: [
    154,
    205,
    50,
    1
  ]
};
function sc(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function Ex(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function Bp(e) {
  return e[e.length - 1] === "%" ? sc(parseFloat(e) / 100 * 255) : sc(parseInt(e));
}
function Dh(e) {
  return e[e.length - 1] === "%" ? Ex(parseFloat(e) / 100) : Ex(parseFloat(e));
}
function Fp(e, t, n) {
  return n < 0 ? n += 1 : n > 1 && (n -= 1), n * 6 < 1 ? e + (t - e) * n * 6 : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function sW(e) {
  var t = e.replace(/ /g, "").toLowerCase();
  if (t in yx)
    return yx[t].slice();
  if (t[0] === "#") {
    if (t.length === 4) {
      var n = parseInt(t.substr(1), 16);
      return n >= 0 && n <= 4095 ? [
        (n & 3840) >> 4 | (n & 3840) >> 8,
        n & 240 | (n & 240) >> 4,
        n & 15 | (n & 15) << 4,
        1
      ] : null;
    } else if (t.length === 7) {
      var n = parseInt(t.substr(1), 16);
      return n >= 0 && n <= 16777215 ? [
        (n & 16711680) >> 16,
        (n & 65280) >> 8,
        n & 255,
        1
      ] : null;
    }
    return null;
  }
  var s = t.indexOf("("), r = t.indexOf(")");
  if (s !== -1 && r + 1 === t.length) {
    var i = t.substr(0, s), a = t.substr(s + 1, r - (s + 1)).split(","), o = 1;
    switch (i) {
      case "rgba":
        if (a.length !== 4)
          return null;
        o = Dh(a.pop());
      case "rgb":
        return a.length !== 3 ? null : [
          Bp(a[0]),
          Bp(a[1]),
          Bp(a[2]),
          o
        ];
      case "hsla":
        if (a.length !== 4)
          return null;
        o = Dh(a.pop());
      case "hsl":
        if (a.length !== 3)
          return null;
        var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360, f = Dh(a[1]), d = Dh(a[2]), u = d <= 0.5 ? d * (f + 1) : d + f - d * f, c = d * 2 - u;
        return [
          sc(Fp(c, u, l + 1 / 3) * 255),
          sc(Fp(c, u, l) * 255),
          sc(Fp(c, u, l - 1 / 3) * 255),
          o
        ];
      default:
        return null;
    }
  }
  return null;
}
try {
  jS = rW.parseCSSColor = sW;
} catch {
}
var Re = function(t, n, s, r) {
  r === void 0 && (r = 1), this.r = t, this.g = n, this.b = s, this.a = r;
};
Re.parse = function(t) {
  if (t) {
    if (t instanceof Re)
      return t;
    if (typeof t == "string") {
      var n = jS(t);
      if (n)
        return new Re(n[0] / 255 * n[3], n[1] / 255 * n[3], n[2] / 255 * n[3], n[3]);
    }
  }
};
Re.prototype.toString = function() {
  var t = this.toArray(), n = t[0], s = t[1], r = t[2], i = t[3];
  return "rgba(" + Math.round(n) + "," + Math.round(s) + "," + Math.round(r) + "," + i + ")";
};
Re.prototype.toArray = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return i === 0 ? [
    0,
    0,
    0,
    0
  ] : [
    n * 255 / i,
    s * 255 / i,
    r * 255 / i,
    i
  ];
};
Re.prototype.toArray01 = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return i === 0 ? [
    0,
    0,
    0,
    0
  ] : [
    n / i,
    s / i,
    r / i,
    i
  ];
};
Re.prototype.toArray01PremultipliedAlpha = function() {
  var t = this, n = t.r, s = t.g, r = t.b, i = t.a;
  return [
    n,
    s,
    r,
    i
  ];
};
Re.black = new Re(0, 0, 0, 1);
Re.white = new Re(1, 1, 1, 1);
Re.transparent = new Re(0, 0, 0, 0);
Re.red = new Re(1, 0, 0, 1);
Re.blue = new Re(0, 0, 1, 1);
function Oc(e) {
  return typeof e == "object" ? [
    "literal",
    e
  ] : e;
}
function aW(e, t) {
  var n = e.stops;
  if (!n)
    return oW(e, t);
  var s = n && typeof n[0][0] == "object", r = s || e.property !== void 0, i = s || !r;
  return n = n.map(function(a) {
    return !r && t.tokens && typeof a[1] == "string" ? [
      a[0],
      hW(a[1])
    ] : [
      a[0],
      Oc(a[1])
    ];
  }), s ? lW(e, t, n) : i ? cW(e, t, n) : uv(e, t, n);
}
function oW(e, t) {
  var n = [
    "get",
    e.property
  ];
  if (e.default === void 0)
    return t.type === "string" ? [
      "string",
      n
    ] : n;
  if (t.type === "enum")
    return [
      "match",
      n,
      Object.keys(t.values),
      n,
      e.default
    ];
  var s = [
    t.type === "color" ? "to-color" : t.type,
    n,
    Oc(e.default)
  ];
  return t.type === "array" && s.splice(1, 0, t.value, t.length || null), s;
}
function P0(e) {
  switch (e.colorSpace) {
    case "hcl":
      return "interpolate-hcl";
    case "lab":
      return "interpolate-lab";
    default:
      return "interpolate";
  }
}
function lW(e, t, n) {
  for (var s = {}, r = {}, i = [], a = 0; a < n.length; a++) {
    var o = n[a], l = o[0].zoom;
    s[l] === void 0 && (s[l] = {
      zoom: l,
      type: e.type,
      property: e.property,
      default: e.default
    }, r[l] = [], i.push(l)), r[l].push([
      o[0].value,
      o[1]
    ]);
  }
  var f = M0({}, t);
  if (f === "exponential") {
    for (var d = [
      P0(e),
      ["linear"],
      ["zoom"]
    ], u = 0, c = i; u < c.length; u += 1) {
      var h = c[u], p = uv(s[h], t, r[h]);
      Gl(d, h, p, !1);
    }
    return d;
  } else {
    for (var g = [
      "step",
      ["zoom"]
    ], m = 0, v = i; m < v.length; m += 1) {
      var y = v[m], E = uv(s[y], t, r[y]);
      Gl(g, y, E, !0);
    }
    return S0(g), g;
  }
}
function uW(e, t) {
  if (e !== void 0)
    return e;
  if (t !== void 0)
    return t;
}
function Cx(e, t) {
  var n = Oc(uW(e.default, t.default));
  return n === void 0 && t.type === "resolvedImage" ? "" : n;
}
function uv(e, t, n) {
  var s = M0(e, t), r = [
    "get",
    e.property
  ];
  if (s === "categorical" && typeof n[0][0] == "boolean") {
    for (var i = ["case"], a = 0, o = n; a < o.length; a += 1) {
      var l = o[a];
      i.push([
        "==",
        r,
        l[0]
      ], l[1]);
    }
    return i.push(Cx(e, t)), i;
  } else if (s === "categorical") {
    for (var f = [
      "match",
      r
    ], d = 0, u = n; d < u.length; d += 1) {
      var c = u[d];
      Gl(f, c[0], c[1], !1);
    }
    return f.push(Cx(e, t)), f;
  } else if (s === "interval") {
    for (var h = [
      "step",
      [
        "number",
        r
      ]
    ], p = 0, g = n; p < g.length; p += 1) {
      var m = g[p];
      Gl(h, m[0], m[1], !0);
    }
    return S0(h), e.default === void 0 ? h : [
      "case",
      [
        "==",
        [
          "typeof",
          r
        ],
        "number"
      ],
      h,
      Oc(e.default)
    ];
  } else if (s === "exponential") {
    for (var v = e.base !== void 0 ? e.base : 1, y = [
      P0(e),
      v === 1 ? ["linear"] : [
        "exponential",
        v
      ],
      [
        "number",
        r
      ]
    ], E = 0, C = n; E < C.length; E += 1) {
      var x = C[E];
      Gl(y, x[0], x[1], !1);
    }
    return e.default === void 0 ? y : [
      "case",
      [
        "==",
        [
          "typeof",
          r
        ],
        "number"
      ],
      y,
      Oc(e.default)
    ];
  } else
    throw new Error("Unknown property function type " + s);
}
function cW(e, t, n, s) {
  s === void 0 && (s = ["zoom"]);
  var r = M0(e, t), i, a = !1;
  if (r === "interval")
    i = [
      "step",
      s
    ], a = !0;
  else if (r === "exponential") {
    var o = e.base !== void 0 ? e.base : 1;
    i = [
      P0(e),
      o === 1 ? ["linear"] : [
        "exponential",
        o
      ],
      s
    ];
  } else
    throw new Error('Unknown zoom function type "' + r + '"');
  for (var l = 0, f = n; l < f.length; l += 1) {
    var d = f[l];
    Gl(i, d[0], d[1], a);
  }
  return S0(i), i;
}
function S0(e) {
  e[0] === "step" && e.length === 3 && (e.push(0), e.push(e[3]));
}
function Gl(e, t, n, s) {
  e.length > 3 && t === e[e.length - 2] || (s && e.length === 2 || e.push(t), e.push(n));
}
function M0(e, t) {
  return e.type ? e.type : t.expression.interpolated ? "exponential" : "interval";
}
function hW(e) {
  for (var t = ["concat"], n = /{([^{}]+)}/g, s = 0, r = n.exec(e); r !== null; r = n.exec(e)) {
    var i = e.slice(s, n.lastIndex - r[0].length);
    s = n.lastIndex, i.length > 0 && t.push(i), t.push([
      "get",
      r[1]
    ]);
  }
  if (t.length === 1)
    return e;
  if (s < e.length)
    t.push(e.slice(s));
  else if (t.length === 2)
    return [
      "to-string",
      t[1]
    ];
  return t;
}
var ls = /* @__PURE__ */ function(e) {
  function t(n, s) {
    e.call(this, s), this.message = s, this.key = n;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t;
}(Error), Pc = function(t, n) {
  n === void 0 && (n = []), this.parent = t, this.bindings = {};
  for (var s = 0, r = n; s < r.length; s += 1) {
    var i = r[s], a = i[0], o = i[1];
    this.bindings[a] = o;
  }
};
Pc.prototype.concat = function(t) {
  return new Pc(this, t);
};
Pc.prototype.get = function(t) {
  if (this.bindings[t])
    return this.bindings[t];
  if (this.parent)
    return this.parent.get(t);
  throw new Error(t + " not found in scope.");
};
Pc.prototype.has = function(t) {
  return this.bindings[t] ? !0 : this.parent ? this.parent.has(t) : !1;
};
var Zf = { kind: "null" }, Pt = { kind: "number" }, me = { kind: "string" }, oe = { kind: "boolean" }, Qs = { kind: "color" }, kl = { kind: "object" }, le = { kind: "value" }, dW = { kind: "error" }, Jf = { kind: "collator" }, Qf = { kind: "formatted" }, qc = { kind: "resolvedImage" };
function gr(e, t) {
  return {
    kind: "array",
    itemType: e,
    N: t
  };
}
function rn(e) {
  if (e.kind === "array") {
    var t = rn(e.itemType);
    return typeof e.N == "number" ? "array<" + t + ", " + e.N + ">" : e.itemType.kind === "value" ? "array" : "array<" + t + ">";
  } else
    return e.kind;
}
var fW = [
  Zf,
  Pt,
  me,
  oe,
  Qs,
  Qf,
  kl,
  gr(le),
  qc
];
function Sc(e, t) {
  if (t.kind === "error")
    return null;
  if (e.kind === "array") {
    if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Sc(e.itemType, t.itemType)) && (typeof e.N != "number" || e.N === t.N))
      return null;
  } else {
    if (e.kind === t.kind)
      return null;
    if (e.kind === "value")
      for (var n = 0, s = fW; n < s.length; n += 1) {
        var r = s[n];
        if (!Sc(r, t))
          return null;
      }
  }
  return "Expected " + rn(e) + " but found " + rn(t) + " instead.";
}
function _0(e, t) {
  return t.some(function(n) {
    return n.kind === e.kind;
  });
}
function Mc(e, t) {
  return t.some(function(n) {
    return n === "null" ? e === null : n === "array" ? Array.isArray(e) : n === "object" ? e && !Array.isArray(e) && typeof e == "object" : n === typeof e;
  });
}
var th = function(t, n, s) {
  t ? this.sensitivity = n ? "variant" : "case" : this.sensitivity = n ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
    sensitivity: this.sensitivity,
    usage: "search"
  });
};
th.prototype.compare = function(t, n) {
  return this.collator.compare(t, n);
};
th.prototype.resolvedLocale = function() {
  return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
};
var cv = function(t, n, s, r, i) {
  this.text = t.normalize ? t.normalize() : t, this.image = n, this.scale = s, this.fontStack = r, this.textColor = i;
}, Ni = function(t) {
  this.sections = t;
};
Ni.fromString = function(t) {
  return new Ni([new cv(t, null, null, null, null)]);
};
Ni.prototype.isEmpty = function() {
  return this.sections.length === 0 ? !0 : !this.sections.some(function(t) {
    return t.text.length !== 0 || t.image && t.image.name.length !== 0;
  });
};
Ni.factory = function(t) {
  return t instanceof Ni ? t : Ni.fromString(t);
};
Ni.prototype.toString = function() {
  return this.sections.length === 0 ? "" : this.sections.map(function(t) {
    return t.text;
  }).join("");
};
Ni.prototype.serialize = function() {
  for (var t = ["format"], n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    if (r.image) {
      t.push([
        "image",
        r.image.name
      ]);
      continue;
    }
    t.push(r.text);
    var i = {};
    r.fontStack && (i["text-font"] = [
      "literal",
      r.fontStack.split(",")
    ]), r.scale && (i["font-scale"] = r.scale), r.textColor && (i["text-color"] = ["rgba"].concat(r.textColor.toArray())), t.push(i);
  }
  return t;
};
var Es = function(t) {
  this.name = t.name, this.available = t.available;
};
Es.prototype.toString = function() {
  return this.name;
};
Es.fromString = function(t) {
  return t ? new Es({
    name: t,
    available: !1
  }) : null;
};
Es.prototype.serialize = function() {
  return [
    "image",
    this.name
  ];
};
function $S(e, t, n, s) {
  if (!(typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255)) {
    var r = typeof s == "number" ? [
      e,
      t,
      n,
      s
    ] : [
      e,
      t,
      n
    ];
    return "Invalid rgba value [" + r.join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
  }
  return typeof s > "u" || typeof s == "number" && s >= 0 && s <= 1 ? null : "Invalid rgba value [" + [
    e,
    t,
    n,
    s
  ].join(", ") + "]: 'a' must be between 0 and 1.";
}
function Xd(e) {
  if (e === null)
    return !0;
  if (typeof e == "string")
    return !0;
  if (typeof e == "boolean")
    return !0;
  if (typeof e == "number")
    return !0;
  if (e instanceof Re)
    return !0;
  if (e instanceof th)
    return !0;
  if (e instanceof Ni)
    return !0;
  if (e instanceof Es)
    return !0;
  if (Array.isArray(e)) {
    for (var t = 0, n = e; t < n.length; t += 1) {
      var s = n[t];
      if (!Xd(s))
        return !1;
    }
    return !0;
  } else if (typeof e == "object") {
    for (var r in e)
      if (!Xd(e[r]))
        return !1;
    return !0;
  } else
    return !1;
}
function Bn(e) {
  if (e === null)
    return Zf;
  if (typeof e == "string")
    return me;
  if (typeof e == "boolean")
    return oe;
  if (typeof e == "number")
    return Pt;
  if (e instanceof Re)
    return Qs;
  if (e instanceof th)
    return Jf;
  if (e instanceof Ni)
    return Qf;
  if (e instanceof Es)
    return qc;
  if (Array.isArray(e)) {
    for (var t = e.length, n, s = 0, r = e; s < r.length; s += 1) {
      var i = r[s], a = Bn(i);
      if (!n)
        n = a;
      else {
        if (n === a)
          continue;
        n = le;
        break;
      }
    }
    return gr(n || le, t);
  } else
    return kl;
}
function ac(e) {
  var t = typeof e;
  return e === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(e) : e instanceof Re || e instanceof Ni || e instanceof Es ? e.toString() : JSON.stringify(e);
}
var Cs = function(t, n) {
  this.type = t, this.value = n;
};
Cs.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("'literal' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");
  if (!Xd(t[1]))
    return n.error("invalid value");
  var s = t[1], r = Bn(s), i = n.expectedType;
  return r.kind === "array" && r.N === 0 && i && i.kind === "array" && (typeof i.N != "number" || i.N === 0) && (r = i), new Cs(r, s);
};
Cs.prototype.evaluate = function() {
  return this.value;
};
Cs.prototype.eachChild = function() {
};
Cs.prototype.outputDefined = function() {
  return !0;
};
Cs.prototype.serialize = function() {
  return this.type.kind === "array" || this.type.kind === "object" ? [
    "literal",
    this.value
  ] : this.value instanceof Re ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Ni ? this.value.serialize() : this.value;
};
var Gn = function(t) {
  this.name = "ExpressionEvaluationError", this.message = t;
};
Gn.prototype.toJSON = function() {
  return this.message;
};
var Np = {
  string: me,
  number: Pt,
  boolean: oe,
  object: kl
}, Si = function(t, n) {
  this.type = t, this.args = n;
};
Si.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = 1, r, i = t[0];
  if (i === "array") {
    var a;
    if (t.length > 2) {
      var o = t[1];
      if (typeof o != "string" || !(o in Np) || o === "object")
        return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
      a = Np[o], s++;
    } else
      a = le;
    var l;
    if (t.length > 3) {
      if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2])))
        return n.error('The length argument to "array" must be a positive integer literal', 2);
      l = t[2], s++;
    }
    r = gr(a, l);
  } else
    r = Np[i];
  for (var f = []; s < t.length; s++) {
    var d = n.parse(t[s], s, le);
    if (!d)
      return null;
    f.push(d);
  }
  return new Si(r, f);
};
Si.prototype.evaluate = function(t) {
  for (var n = 0; n < this.args.length; n++) {
    var s = this.args[n].evaluate(t), r = Sc(this.type, Bn(s));
    if (r) {
      if (n === this.args.length - 1)
        throw new Gn("Expected value to be of type " + rn(this.type) + ", but found " + rn(Bn(s)) + " instead.");
    } else
      return s;
  }
  return null;
};
Si.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
Si.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
Si.prototype.serialize = function() {
  var t = this.type, n = [t.kind];
  if (t.kind === "array") {
    var s = t.itemType;
    if (s.kind === "string" || s.kind === "number" || s.kind === "boolean") {
      n.push(s.kind);
      var r = t.N;
      (typeof r == "number" || this.args.length > 1) && n.push(r);
    }
  }
  return n.concat(this.args.map(function(i) {
    return i.serialize();
  }));
};
var Ya = function(t) {
  this.type = Qf, this.sections = t;
};
Ya.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = t[1];
  if (!Array.isArray(s) && typeof s == "object")
    return n.error("First argument must be an image or text section.");
  for (var r = [], i = !1, a = 1; a <= t.length - 1; ++a) {
    var o = t[a];
    if (i && typeof o == "object" && !Array.isArray(o)) {
      i = !1;
      var l = null;
      if (o["font-scale"] && (l = n.parse(o["font-scale"], 1, Pt), !l))
        return null;
      var f = null;
      if (o["text-font"] && (f = n.parse(o["text-font"], 1, gr(me)), !f))
        return null;
      var d = null;
      if (o["text-color"] && (d = n.parse(o["text-color"], 1, Qs), !d))
        return null;
      var u = r[r.length - 1];
      u.scale = l, u.font = f, u.textColor = d;
    } else {
      var c = n.parse(t[a], 1, le);
      if (!c)
        return null;
      var h = c.type.kind;
      if (h !== "string" && h !== "value" && h !== "null" && h !== "resolvedImage")
        return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
      i = !0, r.push({
        content: c,
        scale: null,
        font: null,
        textColor: null
      });
    }
  }
  return new Ya(r);
};
Ya.prototype.evaluate = function(t) {
  var n = function(s) {
    var r = s.content.evaluate(t);
    return Bn(r) === qc ? new cv("", r, null, null, null) : new cv(ac(r), null, s.scale ? s.scale.evaluate(t) : null, s.font ? s.font.evaluate(t).join(",") : null, s.textColor ? s.textColor.evaluate(t) : null);
  };
  return new Ni(this.sections.map(n));
};
Ya.prototype.eachChild = function(t) {
  for (var n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    t(r.content), r.scale && t(r.scale), r.font && t(r.font), r.textColor && t(r.textColor);
  }
};
Ya.prototype.outputDefined = function() {
  return !1;
};
Ya.prototype.serialize = function() {
  for (var t = ["format"], n = 0, s = this.sections; n < s.length; n += 1) {
    var r = s[n];
    t.push(r.content.serialize());
    var i = {};
    r.scale && (i["font-scale"] = r.scale.serialize()), r.font && (i["text-font"] = r.font.serialize()), r.textColor && (i["text-color"] = r.textColor.serialize()), t.push(i);
  }
  return t;
};
var Xa = function(t) {
  this.type = qc, this.input = t;
};
Xa.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected two arguments.");
  var s = n.parse(t[1], 1, me);
  return s ? new Xa(s) : n.error("No image name provided.");
};
Xa.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = Es.fromString(n);
  return s && t.availableImages && (s.available = t.availableImages.indexOf(n) > -1), s;
};
Xa.prototype.eachChild = function(t) {
  t(this.input);
};
Xa.prototype.outputDefined = function() {
  return !1;
};
Xa.prototype.serialize = function() {
  return [
    "image",
    this.input.serialize()
  ];
};
var pW = {
  "to-boolean": oe,
  "to-color": Qs,
  "to-number": Pt,
  "to-string": me
}, yr = function(t, n) {
  this.type = t, this.args = n;
};
yr.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expected at least one argument.");
  var s = t[0];
  if ((s === "to-boolean" || s === "to-string") && t.length !== 2)
    return n.error("Expected one argument.");
  for (var r = pW[s], i = [], a = 1; a < t.length; a++) {
    var o = n.parse(t[a], a, le);
    if (!o)
      return null;
    i.push(o);
  }
  return new yr(r, i);
};
yr.prototype.evaluate = function(t) {
  if (this.type.kind === "boolean")
    return !!this.args[0].evaluate(t);
  if (this.type.kind === "color") {
    for (var n, s, r = 0, i = this.args; r < i.length; r += 1) {
      var a = i[r];
      if (n = a.evaluate(t), s = null, n instanceof Re)
        return n;
      if (typeof n == "string") {
        var o = t.parseColor(n);
        if (o)
          return o;
      } else if (Array.isArray(n) && (n.length < 3 || n.length > 4 ? s = "Invalid rbga value " + JSON.stringify(n) + ": expected an array containing either three or four numeric values." : s = $S(n[0], n[1], n[2], n[3]), !s))
        return new Re(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
    }
    throw new Gn(s || "Could not parse color from value '" + (typeof n == "string" ? n : String(JSON.stringify(n))) + "'");
  } else if (this.type.kind === "number") {
    for (var l = null, f = 0, d = this.args; f < d.length; f += 1) {
      var u = d[f];
      if (l = u.evaluate(t), l === null)
        return 0;
      var c = Number(l);
      if (!isNaN(c))
        return c;
    }
    throw new Gn("Could not convert " + JSON.stringify(l) + " to number.");
  } else
    return this.type.kind === "formatted" ? Ni.fromString(ac(this.args[0].evaluate(t))) : this.type.kind === "resolvedImage" ? Es.fromString(ac(this.args[0].evaluate(t))) : ac(this.args[0].evaluate(t));
};
yr.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
yr.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
yr.prototype.serialize = function() {
  if (this.type.kind === "formatted")
    return new Ya([{
      content: this.args[0],
      scale: null,
      font: null,
      textColor: null
    }]).serialize();
  if (this.type.kind === "resolvedImage")
    return new Xa(this.args[0]).serialize();
  var t = ["to-" + this.type.kind];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var mW = [
  "Unknown",
  "Point",
  "LineString",
  "Polygon"
], ua = function() {
  this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
};
ua.prototype.id = function() {
  return this.feature && "id" in this.feature && this.feature.id ? this.feature.id : null;
};
ua.prototype.geometryType = function() {
  return this.feature ? typeof this.feature.type == "number" ? mW[this.feature.type] : this.feature.type : null;
};
ua.prototype.geometry = function() {
  return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
};
ua.prototype.canonicalID = function() {
  return this.canonical;
};
ua.prototype.properties = function() {
  return this.feature && this.feature.properties || {};
};
ua.prototype.distanceFromCenter = function() {
  if (this.featureTileCoord && this.featureDistanceData) {
    var t = this.featureDistanceData.center, n = this.featureDistanceData.scale, s = this.featureTileCoord, r = s.x, i = s.y, a = r * n - t[0], o = i * n - t[1], l = this.featureDistanceData.bearing[0], f = this.featureDistanceData.bearing[1], d = l * a + f * o;
    return d;
  }
  return 0;
};
ua.prototype.parseColor = function(t) {
  var n = this._parseColorCache[t];
  return n || (n = this._parseColorCache[t] = Re.parse(t)), n;
};
var di = function(t, n, s, r) {
  this.name = t, this.type = n, this._evaluate = s, this.args = r;
};
di.prototype.evaluate = function(t) {
  return this._evaluate(t, this.args);
};
di.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
di.prototype.outputDefined = function() {
  return !1;
};
di.prototype.serialize = function() {
  return [this.name].concat(this.args.map(function(t) {
    return t.serialize();
  }));
};
di.parse = function(t, n) {
  var s, r = t[0], i = di.definitions[r];
  if (!i)
    return n.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0);
  for (var a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[
    i[1],
    i[2]
  ]] : i.overloads, l = o.filter(
    function(D) {
      var I = D[0];
      return !Array.isArray(I) || // varags
      I.length === t.length - 1;
    }
    // correct param count
  ), f = null, d = 0, u = l; d < u.length; d += 1) {
    var c = u[d], h = c[0], p = c[1];
    f = new Qa(n.registry, n.path, null, n.scope);
    for (var g = [], m = !1, v = 1; v < t.length; v++) {
      var y = t[v], E = Array.isArray(h) ? h[v - 1] : h.type, C = f.parse(y, 1 + g.length, E);
      if (!C) {
        m = !0;
        break;
      }
      g.push(C);
    }
    if (!m) {
      if (Array.isArray(h) && h.length !== g.length) {
        f.error("Expected " + h.length + " arguments, but found " + g.length + " instead.");
        continue;
      }
      for (var x = 0; x < g.length; x++) {
        var b = Array.isArray(h) ? h[x] : h.type, P = g[x];
        f.concat(x + 1).checkSubtype(b, P.type);
      }
      if (f.errors.length === 0)
        return new di(r, a, p, g);
    }
  }
  if (l.length === 1)
    (s = n.errors).push.apply(s, f.errors);
  else {
    for (var O = l.length ? l : o, T = O.map(function(D) {
      var I = D[0];
      return gW(I);
    }).join(" | "), M = [], L = 1; L < t.length; L++) {
      var A = n.parse(t[L], 1 + M.length);
      if (!A)
        return null;
      M.push(rn(A.type));
    }
    n.error("Expected arguments of type " + T + ", but found (" + M.join(", ") + ") instead.");
  }
  return null;
};
di.register = function(t, n) {
  di.definitions = n;
  for (var s in n)
    t[s] = di;
};
function gW(e) {
  return Array.isArray(e) ? "(" + e.map(rn).join(", ") + ")" : "(" + rn(e.type) + "...)";
}
var Za = function(t, n, s) {
  this.type = Jf, this.locale = s, this.caseSensitive = t, this.diacriticSensitive = n;
};
Za.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected one argument.");
  var s = t[1];
  if (typeof s != "object" || Array.isArray(s))
    return n.error("Collator options argument must be an object.");
  var r = n.parse(s["case-sensitive"] === void 0 ? !1 : s["case-sensitive"], 1, oe);
  if (!r)
    return null;
  var i = n.parse(s["diacritic-sensitive"] === void 0 ? !1 : s["diacritic-sensitive"], 1, oe);
  if (!i)
    return null;
  var a = null;
  return s.locale && (a = n.parse(s.locale, 1, me), !a) ? null : new Za(r, i, a);
};
Za.prototype.evaluate = function(t) {
  return new th(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
};
Za.prototype.eachChild = function(t) {
  t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
};
Za.prototype.outputDefined = function() {
  return !1;
};
Za.prototype.serialize = function() {
  var t = {};
  return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [
    "collator",
    t
  ];
};
var ja = 8192;
function I0(e, t) {
  e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1]);
}
function vW(e) {
  return (180 + e) / 360;
}
function yW(e) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360;
}
function Zd(e, t) {
  return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
}
function EW(e, t) {
  var n = vW(e[0]), s = yW(e[1]), r = Math.pow(2, t.z);
  return [
    Math.round(n * r * ja),
    Math.round(s * r * ja)
  ];
}
function CW(e, t, n) {
  var s = e[0] - t[0], r = e[1] - t[1], i = e[0] - n[0], a = e[1] - n[1];
  return s * a - i * r === 0 && s * i <= 0 && r * a <= 0;
}
function xW(e, t, n) {
  return t[1] > e[1] != n[1] > e[1] && e[0] < (n[0] - t[0]) * (e[1] - t[1]) / (n[1] - t[1]) + t[0];
}
function D0(e, t) {
  for (var n = !1, s = 0, r = t.length; s < r; s++)
    for (var i = t[s], a = 0, o = i.length; a < o - 1; a++) {
      if (CW(e, i[a], i[a + 1]))
        return !1;
      xW(e, i[a], i[a + 1]) && (n = !n);
    }
  return n;
}
function bW(e, t) {
  for (var n = 0; n < t.length; n++)
    if (D0(e, t[n]))
      return !0;
  return !1;
}
function TW(e, t) {
  return e[0] * t[1] - e[1] * t[0];
}
function xx(e, t, n, s) {
  var r = e[0] - n[0], i = e[1] - n[1], a = t[0] - n[0], o = t[1] - n[1], l = s[0] - n[0], f = s[1] - n[1], d = r * f - l * i, u = a * f - l * o;
  return d > 0 && u < 0 || d < 0 && u > 0;
}
function OW(e, t, n, s) {
  var r = [
    t[0] - e[0],
    t[1] - e[1]
  ], i = [
    s[0] - n[0],
    s[1] - n[1]
  ];
  return TW(i, r) === 0 ? !1 : !!(xx(e, t, n, s) && xx(n, s, e, t));
}
function PW(e, t, n) {
  for (var s = 0, r = n; s < r.length; s += 1)
    for (var i = r[s], a = 0; a < i.length - 1; ++a)
      if (OW(e, t, i[a], i[a + 1]))
        return !0;
  return !1;
}
function US(e, t) {
  for (var n = 0; n < e.length; ++n)
    if (!D0(e[n], t))
      return !1;
  for (var s = 0; s < e.length - 1; ++s)
    if (PW(e[s], e[s + 1], t))
      return !1;
  return !0;
}
function SW(e, t) {
  for (var n = 0; n < t.length; n++)
    if (US(e, t[n]))
      return !0;
  return !1;
}
function A0(e, t, n) {
  for (var s = [], r = 0; r < e.length; r++) {
    for (var i = [], a = 0; a < e[r].length; a++) {
      var o = EW(e[r][a], n);
      I0(t, o), i.push(o);
    }
    s.push(i);
  }
  return s;
}
function WS(e, t, n) {
  for (var s = [], r = 0; r < e.length; r++) {
    var i = A0(e[r], t, n);
    s.push(i);
  }
  return s;
}
function zS(e, t, n, s) {
  if (e[0] < n[0] || e[0] > n[2]) {
    var r = s * 0.5, i = e[0] - n[0] > r ? -s : n[0] - e[0] > r ? s : 0;
    i === 0 && (i = e[0] - n[2] > r ? -s : n[2] - e[0] > r ? s : 0), e[0] += i;
  }
  I0(t, e);
}
function MW(e) {
  e[0] = e[1] = 1 / 0, e[2] = e[3] = -1 / 0;
}
function bx(e, t, n, s) {
  var r = Math.pow(2, s.z) * ja, i = [
    s.x * ja,
    s.y * ja
  ], a = [];
  if (!e)
    return a;
  for (var o = 0, l = e; o < l.length; o += 1)
    for (var f = l[o], d = 0, u = f; d < u.length; d += 1) {
      var c = u[d], h = [
        c.x + i[0],
        c.y + i[1]
      ];
      zS(h, t, n, r), a.push(h);
    }
  return a;
}
function Tx(e, t, n, s) {
  var r = Math.pow(2, s.z) * ja, i = [
    s.x * ja,
    s.y * ja
  ], a = [];
  if (!e)
    return a;
  for (var o = 0, l = e; o < l.length; o += 1) {
    for (var f = l[o], d = [], u = 0, c = f; u < c.length; u += 1) {
      var h = c[u], p = [
        h.x + i[0],
        h.y + i[1]
      ];
      I0(t, p), d.push(p);
    }
    a.push(d);
  }
  if (t[2] - t[0] <= r / 2) {
    MW(t);
    for (var g = 0, m = a; g < m.length; g += 1)
      for (var v = m[g], y = 0, E = v; y < E.length; y += 1) {
        var C = E[y];
        zS(C, t, n, r);
      }
  }
  return a;
}
function _W(e, t) {
  var n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], s = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], r = e.canonicalID();
  if (!r)
    return !1;
  if (t.type === "Polygon") {
    var i = A0(t.coordinates, s, r), a = bx(e.geometry(), n, s, r);
    if (!Zd(n, s))
      return !1;
    for (var o = 0, l = a; o < l.length; o += 1) {
      var f = l[o];
      if (!D0(f, i))
        return !1;
    }
  }
  if (t.type === "MultiPolygon") {
    var d = WS(t.coordinates, s, r), u = bx(e.geometry(), n, s, r);
    if (!Zd(n, s))
      return !1;
    for (var c = 0, h = u; c < h.length; c += 1) {
      var p = h[c];
      if (!bW(p, d))
        return !1;
    }
  }
  return !0;
}
function IW(e, t) {
  var n = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], s = [
    1 / 0,
    1 / 0,
    -1 / 0,
    -1 / 0
  ], r = e.canonicalID();
  if (!r)
    return !1;
  if (t.type === "Polygon") {
    var i = A0(t.coordinates, s, r), a = Tx(e.geometry(), n, s, r);
    if (!Zd(n, s))
      return !1;
    for (var o = 0, l = a; o < l.length; o += 1) {
      var f = l[o];
      if (!US(f, i))
        return !1;
    }
  }
  if (t.type === "MultiPolygon") {
    var d = WS(t.coordinates, s, r), u = Tx(e.geometry(), n, s, r);
    if (!Zd(n, s))
      return !1;
    for (var c = 0, h = u; c < h.length; c += 1) {
      var p = h[c];
      if (!SW(p, d))
        return !1;
    }
  }
  return !0;
}
var Vr = function(t, n) {
  this.type = oe, this.geojson = t, this.geometries = n;
};
Vr.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("'within' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");
  if (Xd(t[1])) {
    var s = t[1];
    if (s.type === "FeatureCollection")
      for (var r = 0; r < s.features.length; ++r) {
        var i = s.features[r].geometry.type;
        if (i === "Polygon" || i === "MultiPolygon")
          return new Vr(s, s.features[r].geometry);
      }
    else if (s.type === "Feature") {
      var a = s.geometry.type;
      if (a === "Polygon" || a === "MultiPolygon")
        return new Vr(s, s.geometry);
    } else if (s.type === "Polygon" || s.type === "MultiPolygon")
      return new Vr(s, s);
  }
  return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
};
Vr.prototype.evaluate = function(t) {
  if (t.geometry() != null && t.canonicalID() != null) {
    if (t.geometryType() === "Point")
      return _W(t, this.geometries);
    if (t.geometryType() === "LineString")
      return IW(t, this.geometries);
  }
  return !1;
};
Vr.prototype.eachChild = function() {
};
Vr.prototype.outputDefined = function() {
  return !0;
};
Vr.prototype.serialize = function() {
  return [
    "within",
    this.geojson
  ];
};
function qf(e) {
  if (e instanceof di) {
    if (e.name === "get" && e.args.length === 1)
      return !1;
    if (e.name === "feature-state")
      return !1;
    if (e.name === "has" && e.args.length === 1)
      return !1;
    if (e.name === "properties" || e.name === "geometry-type" || e.name === "id")
      return !1;
    if (/^filter-/.test(e.name))
      return !1;
  }
  if (e instanceof Vr)
    return !1;
  var t = !0;
  return e.eachChild(function(n) {
    t && !qf(n) && (t = !1);
  }), t;
}
function L0(e) {
  if (e instanceof di && e.name === "feature-state")
    return !1;
  var t = !0;
  return e.eachChild(function(n) {
    t && !L0(n) && (t = !1);
  }), t;
}
function R0(e, t) {
  if (e instanceof di && t.indexOf(e.name) >= 0)
    return !1;
  var n = !0;
  return e.eachChild(function(s) {
    n && !R0(s, t) && (n = !1);
  }), n;
}
var Ja = function(t, n) {
  this.type = n.type, this.name = t, this.boundExpression = n;
};
Ja.parse = function(t, n) {
  if (t.length !== 2 || typeof t[1] != "string")
    return n.error("'var' expression requires exactly one string literal argument.");
  var s = t[1];
  return n.scope.has(s) ? new Ja(s, n.scope.get(s)) : n.error('Unknown variable "' + s + '". Make sure "' + s + '" has been bound in an enclosing "let" expression before using it.', 1);
};
Ja.prototype.evaluate = function(t) {
  return this.boundExpression.evaluate(t);
};
Ja.prototype.eachChild = function() {
};
Ja.prototype.outputDefined = function() {
  return !1;
};
Ja.prototype.serialize = function() {
  return [
    "var",
    this.name
  ];
};
var Qa = function(t, n, s, r, i) {
  n === void 0 && (n = []), r === void 0 && (r = new Pc()), i === void 0 && (i = []), this.registry = t, this.path = n, this.key = n.map(function(a) {
    return "[" + a + "]";
  }).join(""), this.scope = r, this.errors = i, this.expectedType = s;
};
Qa.prototype.parse = function(t, n, s, r, i) {
  return i === void 0 && (i = {}), n ? this.concat(n, s, r)._parse(t, i) : this._parse(t, i);
};
Qa.prototype._parse = function(t, n) {
  (t === null || typeof t == "string" || typeof t == "boolean" || typeof t == "number") && (t = [
    "literal",
    t
  ]);
  function s(d, u, c) {
    return c === "assert" ? new Si(u, [d]) : c === "coerce" ? new yr(u, [d]) : d;
  }
  if (Array.isArray(t)) {
    if (t.length === 0)
      return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
    var r = t[0];
    if (typeof r != "string")
      return this.error("Expression name must be a string, but found " + typeof r + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
    var i = this.registry[r];
    if (i) {
      var a = i.parse(t, this);
      if (!a)
        return null;
      if (this.expectedType) {
        var o = this.expectedType, l = a.type;
        if ((o.kind === "string" || o.kind === "number" || o.kind === "boolean" || o.kind === "object" || o.kind === "array") && l.kind === "value")
          a = s(a, o, n.typeAnnotation || "assert");
        else if ((o.kind === "color" || o.kind === "formatted" || o.kind === "resolvedImage") && (l.kind === "value" || l.kind === "string"))
          a = s(a, o, n.typeAnnotation || "coerce");
        else if (this.checkSubtype(o, l))
          return null;
      }
      if (!(a instanceof Cs) && a.type.kind !== "resolvedImage" && hv(a)) {
        var f = new ua();
        try {
          a = new Cs(a.type, a.evaluate(f));
        } catch (d) {
          return this.error(d.message), null;
        }
      }
      return a;
    }
    return this.error('Unknown expression "' + r + '". If you wanted a literal array, use ["literal", [...]].', 0);
  } else
    return typeof t > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof t == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found " + typeof t + " instead.");
};
Qa.prototype.concat = function(t, n, s) {
  var r = typeof t == "number" ? this.path.concat(t) : this.path, i = s ? this.scope.concat(s) : this.scope;
  return new Qa(this.registry, r, n || null, i, this.errors);
};
Qa.prototype.error = function(t) {
  for (var n = [], s = arguments.length - 1; s-- > 0; )
    n[s] = arguments[s + 1];
  var r = "" + this.key + n.map(function(i) {
    return "[" + i + "]";
  }).join("");
  this.errors.push(new ls(r, t));
};
Qa.prototype.checkSubtype = function(t, n) {
  var s = Sc(t, n);
  return s && this.error(s), s;
};
function hv(e) {
  if (e instanceof Ja)
    return hv(e.boundExpression);
  if (e instanceof di && e.name === "error")
    return !1;
  if (e instanceof Za)
    return !1;
  if (e instanceof Vr)
    return !1;
  var t = e instanceof yr || e instanceof Si, n = !0;
  return e.eachChild(function(s) {
    t ? n = n && hv(s) : n = n && s instanceof Cs;
  }), n ? qf(e) && R0(e, [
    "zoom",
    "heatmap-density",
    "line-progress",
    "sky-radial-progress",
    "accumulated",
    "is-supported-script",
    "pitch",
    "distance-from-center"
  ]) : !1;
}
function KS(e, t) {
  for (var n = e.length - 1, s = 0, r = n, i = 0, a, o; s <= r; )
    if (i = Math.floor((s + r) / 2), a = e[i], o = e[i + 1], a <= t) {
      if (i === n || t < o)
        return i;
      s = i + 1;
    } else if (a > t)
      r = i - 1;
    else
      throw new Gn("Input is not a number.");
  return 0;
}
var qa = function(t, n, s) {
  this.type = t, this.input = n, this.labels = [], this.outputs = [];
  for (var r = 0, i = s; r < i.length; r += 1) {
    var a = i[r], o = a[0], l = a[1];
    this.labels.push(o), this.outputs.push(l);
  }
};
qa.parse = function(t, n) {
  if (t.length - 1 < 4)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if ((t.length - 1) % 2 !== 0)
    return n.error("Expected an even number of arguments.");
  var s = n.parse(t[1], 1, Pt);
  if (!s)
    return null;
  var r = [], i = null;
  n.expectedType && n.expectedType.kind !== "value" && (i = n.expectedType);
  for (var a = 1; a < t.length; a += 2) {
    var o = a === 1 ? -1 / 0 : t[a], l = t[a + 1], f = a, d = a + 1;
    if (typeof o != "number")
      return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f);
    if (r.length && r[r.length - 1][0] >= o)
      return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', f);
    var u = n.parse(l, d, i);
    if (!u)
      return null;
    i = i || u.type, r.push([
      o,
      u
    ]);
  }
  return new qa(i, s, r);
};
qa.prototype.evaluate = function(t) {
  var n = this.labels, s = this.outputs;
  if (n.length === 1)
    return s[0].evaluate(t);
  var r = this.input.evaluate(t);
  if (r <= n[0])
    return s[0].evaluate(t);
  var i = n.length;
  if (r >= n[i - 1])
    return s[i - 1].evaluate(t);
  var a = KS(n, r);
  return s[a].evaluate(t);
};
qa.prototype.eachChild = function(t) {
  t(this.input);
  for (var n = 0, s = this.outputs; n < s.length; n += 1) {
    var r = s[n];
    t(r);
  }
};
qa.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  });
};
qa.prototype.serialize = function() {
  for (var t = [
    "step",
    this.input.serialize()
  ], n = 0; n < this.labels.length; n++)
    n > 0 && t.push(this.labels[n]), t.push(this.outputs[n].serialize());
  return t;
};
var DW = xu;
function xu(e, t, n, s) {
  this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (s - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = s, this.p2x = n, this.p2y = s;
}
xu.prototype.sampleCurveX = function(e) {
  return ((this.ax * e + this.bx) * e + this.cx) * e;
};
xu.prototype.sampleCurveY = function(e) {
  return ((this.ay * e + this.by) * e + this.cy) * e;
};
xu.prototype.sampleCurveDerivativeX = function(e) {
  return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
};
xu.prototype.solveCurveX = function(e, t) {
  typeof t > "u" && (t = 1e-6);
  var n, s, r, i, a;
  for (r = e, a = 0; a < 8; a++) {
    if (i = this.sampleCurveX(r) - e, Math.abs(i) < t)
      return r;
    var o = this.sampleCurveDerivativeX(r);
    if (Math.abs(o) < 1e-6)
      break;
    r = r - i / o;
  }
  if (n = 0, s = 1, r = e, r < n)
    return n;
  if (r > s)
    return s;
  for (; n < s; ) {
    if (i = this.sampleCurveX(r), Math.abs(i - e) < t)
      return r;
    e > i ? n = r : s = r, r = (s - n) * 0.5 + n;
  }
  return r;
};
xu.prototype.solve = function(e, t) {
  return this.sampleCurveY(this.solveCurveX(e, t));
};
function qi(e, t, n) {
  return e * (1 - n) + t * n;
}
function AW(e, t, n) {
  return new Re(qi(e.r, t.r, n), qi(e.g, t.g, n), qi(e.b, t.b, n), qi(e.a, t.a, n));
}
function LW(e, t, n) {
  return e.map(function(s, r) {
    return qi(s, t[r], n);
  });
}
var RW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  number: qi,
  color: AW,
  array: LW
}), GS = 0.95047, kS = 1, HS = 1.08883, YS = 4 / 29, Hl = 6 / 29, XS = 3 * Hl * Hl, wW = Hl * Hl * Hl, VW = Math.PI / 180, BW = 180 / Math.PI;
function jp(e) {
  return e > wW ? Math.pow(e, 1 / 3) : e / XS + YS;
}
function $p(e) {
  return e > Hl ? e * e * e : XS * (e - YS);
}
function Up(e) {
  return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
}
function Wp(e) {
  return e /= 255, e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
}
function ZS(e) {
  var t = Wp(e.r), n = Wp(e.g), s = Wp(e.b), r = jp((0.4124564 * t + 0.3575761 * n + 0.1804375 * s) / GS), i = jp((0.2126729 * t + 0.7151522 * n + 0.072175 * s) / kS), a = jp((0.0193339 * t + 0.119192 * n + 0.9503041 * s) / HS);
  return {
    l: 116 * i - 16,
    a: 500 * (r - i),
    b: 200 * (i - a),
    alpha: e.a
  };
}
function JS(e) {
  var t = (e.l + 16) / 116, n = isNaN(e.a) ? t : t + e.a / 500, s = isNaN(e.b) ? t : t - e.b / 200;
  return t = kS * $p(t), n = GS * $p(n), s = HS * $p(s), new Re(
    Up(3.2404542 * n - 1.5371385 * t - 0.4985314 * s),
    // D65 -> sRGB
    Up(-0.969266 * n + 1.8760108 * t + 0.041556 * s),
    Up(0.0556434 * n - 0.2040259 * t + 1.0572252 * s),
    e.alpha
  );
}
function FW(e, t, n) {
  return {
    l: qi(e.l, t.l, n),
    a: qi(e.a, t.a, n),
    b: qi(e.b, t.b, n),
    alpha: qi(e.alpha, t.alpha, n)
  };
}
function NW(e) {
  var t = ZS(e), n = t.l, s = t.a, r = t.b, i = Math.atan2(r, s) * BW;
  return {
    h: i < 0 ? i + 360 : i,
    c: Math.sqrt(s * s + r * r),
    l: n,
    alpha: e.a
  };
}
function jW(e) {
  var t = e.h * VW, n = e.c, s = e.l;
  return JS({
    l: s,
    a: Math.cos(t) * n,
    b: Math.sin(t) * n,
    alpha: e.alpha
  });
}
function $W(e, t, n) {
  var s = t - e;
  return e + n * (s > 180 || s < -180 ? s - 360 * Math.round(s / 360) : s);
}
function UW(e, t, n) {
  return {
    h: $W(e.h, t.h, n),
    c: qi(e.c, t.c, n),
    l: qi(e.l, t.l, n),
    alpha: qi(e.alpha, t.alpha, n)
  };
}
var Ah = {
  forward: ZS,
  reverse: JS,
  interpolate: FW
}, Lh = {
  forward: NW,
  reverse: jW,
  interpolate: UW
}, _i = function(t, n, s, r, i) {
  this.type = t, this.operator = n, this.interpolation = s, this.input = r, this.labels = [], this.outputs = [];
  for (var a = 0, o = i; a < o.length; a += 1) {
    var l = o[a], f = l[0], d = l[1];
    this.labels.push(f), this.outputs.push(d);
  }
};
_i.interpolationFactor = function(t, n, s, r) {
  var i = 0;
  if (t.name === "exponential")
    i = zp(n, t.base, s, r);
  else if (t.name === "linear")
    i = zp(n, 1, s, r);
  else if (t.name === "cubic-bezier") {
    var a = t.controlPoints, o = new DW(a[0], a[1], a[2], a[3]);
    i = o.solve(zp(n, 1, s, r));
  }
  return i;
};
_i.parse = function(t, n) {
  var s = t[0], r = t[1], i = t[2], a = t.slice(3);
  if (!Array.isArray(r) || r.length === 0)
    return n.error("Expected an interpolation type expression.", 1);
  if (r[0] === "linear")
    r = { name: "linear" };
  else if (r[0] === "exponential") {
    var o = r[1];
    if (typeof o != "number")
      return n.error("Exponential interpolation requires a numeric base.", 1, 1);
    r = {
      name: "exponential",
      base: o
    };
  } else if (r[0] === "cubic-bezier") {
    var l = r.slice(1);
    if (l.length !== 4 || l.some(function(v) {
      return typeof v != "number" || v < 0 || v > 1;
    }))
      return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
    r = {
      name: "cubic-bezier",
      controlPoints: l
    };
  } else
    return n.error("Unknown interpolation type " + String(r[0]), 1, 0);
  if (t.length - 1 < 4)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if ((t.length - 1) % 2 !== 0)
    return n.error("Expected an even number of arguments.");
  if (i = n.parse(i, 2, Pt), !i)
    return null;
  var f = [], d = null;
  s === "interpolate-hcl" || s === "interpolate-lab" ? d = Qs : n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType);
  for (var u = 0; u < a.length; u += 2) {
    var c = a[u], h = a[u + 1], p = u + 3, g = u + 4;
    if (typeof c != "number")
      return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', p);
    if (f.length && f[f.length - 1][0] >= c)
      return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', p);
    var m = n.parse(h, g, d);
    if (!m)
      return null;
    d = d || m.type, f.push([
      c,
      m
    ]);
  }
  return d.kind !== "number" && d.kind !== "color" && !(d.kind === "array" && d.itemType.kind === "number" && typeof d.N == "number") ? n.error("Type " + rn(d) + " is not interpolatable.") : new _i(d, s, r, i, f);
};
_i.prototype.evaluate = function(t) {
  var n = this.labels, s = this.outputs;
  if (n.length === 1)
    return s[0].evaluate(t);
  var r = this.input.evaluate(t);
  if (r <= n[0])
    return s[0].evaluate(t);
  var i = n.length;
  if (r >= n[i - 1])
    return s[i - 1].evaluate(t);
  var a = KS(n, r), o = n[a], l = n[a + 1], f = _i.interpolationFactor(this.interpolation, r, o, l), d = s[a].evaluate(t), u = s[a + 1].evaluate(t);
  return this.operator === "interpolate" ? RW[this.type.kind.toLowerCase()](d, u, f) : this.operator === "interpolate-hcl" ? Lh.reverse(Lh.interpolate(Lh.forward(d), Lh.forward(u), f)) : Ah.reverse(Ah.interpolate(Ah.forward(d), Ah.forward(u), f));
};
_i.prototype.eachChild = function(t) {
  t(this.input);
  for (var n = 0, s = this.outputs; n < s.length; n += 1) {
    var r = s[n];
    t(r);
  }
};
_i.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  });
};
_i.prototype.serialize = function() {
  var t;
  this.interpolation.name === "linear" ? t = ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? t = ["linear"] : t = [
    "exponential",
    this.interpolation.base
  ] : t = ["cubic-bezier"].concat(this.interpolation.controlPoints);
  for (var n = [
    this.operator,
    t,
    this.input.serialize()
  ], s = 0; s < this.labels.length; s++)
    n.push(this.labels[s], this.outputs[s].serialize());
  return n;
};
function zp(e, t, n, s) {
  var r = s - n, i = e - n;
  return r === 0 ? 0 : t === 1 ? i / r : (Math.pow(t, i) - 1) / (Math.pow(t, r) - 1);
}
var qs = function(t, n) {
  this.type = t, this.args = n;
};
qs.parse = function(t, n) {
  if (t.length < 2)
    return n.error("Expectected at least one argument.");
  var s = null, r = n.expectedType;
  r && r.kind !== "value" && (s = r);
  for (var i = [], a = 0, o = t.slice(1); a < o.length; a += 1) {
    var l = o[a], f = n.parse(l, 1 + i.length, s, void 0, { typeAnnotation: "omit" });
    if (!f)
      return null;
    s = s || f.type, i.push(f);
  }
  var d = r && i.some(function(u) {
    return Sc(r, u.type);
  });
  return d ? new qs(le, i) : new qs(s, i);
};
qs.prototype.evaluate = function(t) {
  for (var n = null, s = 0, r, i = 0, a = this.args; i < a.length; i += 1) {
    var o = a[i];
    if (s++, n = o.evaluate(t), n && n instanceof Es && !n.available && (r || (r = n), n = null, s === this.args.length))
      return r;
    if (n !== null)
      break;
  }
  return n;
};
qs.prototype.eachChild = function(t) {
  this.args.forEach(t);
};
qs.prototype.outputDefined = function() {
  return this.args.every(function(t) {
    return t.outputDefined();
  });
};
qs.prototype.serialize = function() {
  var t = ["coalesce"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var to = function(t, n) {
  this.type = n.type, this.bindings = [].concat(t), this.result = n;
};
to.prototype.evaluate = function(t) {
  return this.result.evaluate(t);
};
to.prototype.eachChild = function(t) {
  for (var n = 0, s = this.bindings; n < s.length; n += 1) {
    var r = s[n];
    t(r[1]);
  }
  t(this.result);
};
to.parse = function(t, n) {
  if (t.length < 4)
    return n.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead.");
  for (var s = [], r = 1; r < t.length - 1; r += 2) {
    var i = t[r];
    if (typeof i != "string")
      return n.error("Expected string, but found " + typeof i + " instead.", r);
    if (/[^a-zA-Z0-9_]/.test(i))
      return n.error("Variable names must contain only alphanumeric characters or '_'.", r);
    var a = n.parse(t[r + 1], r + 1);
    if (!a)
      return null;
    s.push([
      i,
      a
    ]);
  }
  var o = n.parse(t[t.length - 1], t.length - 1, n.expectedType, s);
  return o ? new to(s, o) : null;
};
to.prototype.outputDefined = function() {
  return this.result.outputDefined();
};
to.prototype.serialize = function() {
  for (var t = ["let"], n = 0, s = this.bindings; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    t.push(i, a.serialize());
  }
  return t.push(this.result.serialize()), t;
};
var Uo = function(t, n, s) {
  this.type = t, this.index = n, this.input = s;
};
Uo.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, Pt), r = n.parse(t[2], 2, gr(n.expectedType || le));
  if (!s || !r)
    return null;
  var i = r.type;
  return new Uo(i.itemType, s, r);
};
Uo.prototype.evaluate = function(t) {
  var n = this.index.evaluate(t), s = this.input.evaluate(t);
  if (n < 0)
    throw new Gn("Array index out of bounds: " + n + " < 0.");
  if (n >= s.length)
    throw new Gn("Array index out of bounds: " + n + " > " + (s.length - 1) + ".");
  if (n !== Math.floor(n))
    throw new Gn("Array index must be an integer, but found " + n + " instead.");
  return s[n];
};
Uo.prototype.eachChild = function(t) {
  t(this.index), t(this.input);
};
Uo.prototype.outputDefined = function() {
  return !1;
};
Uo.prototype.serialize = function() {
  return [
    "at",
    this.index.serialize(),
    this.input.serialize()
  ];
};
var Wo = function(t, n) {
  this.type = oe, this.needle = t, this.haystack = n;
};
Wo.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, le), r = n.parse(t[2], 2, le);
  return !s || !r ? null : _0(s.type, [
    oe,
    me,
    Pt,
    Zf,
    le
  ]) ? new Wo(s, r) : n.error("Expected first argument to be of type boolean, string, number or null, but found " + rn(s.type) + " instead");
};
Wo.prototype.evaluate = function(t) {
  var n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
  if (s == null)
    return !1;
  if (!Mc(n, [
    "boolean",
    "string",
    "number",
    "null"
  ]))
    throw new Gn("Expected first argument to be of type boolean, string, number or null, but found " + rn(Bn(n)) + " instead.");
  if (!Mc(s, [
    "string",
    "array"
  ]))
    throw new Gn("Expected second argument to be of type array or string, but found " + rn(Bn(s)) + " instead.");
  return s.indexOf(n) >= 0;
};
Wo.prototype.eachChild = function(t) {
  t(this.needle), t(this.haystack);
};
Wo.prototype.outputDefined = function() {
  return !0;
};
Wo.prototype.serialize = function() {
  return [
    "in",
    this.needle.serialize(),
    this.haystack.serialize()
  ];
};
var $a = function(t, n, s) {
  this.type = Pt, this.needle = t, this.haystack = n, this.fromIndex = s;
};
$a.parse = function(t, n) {
  if (t.length <= 2 || t.length >= 5)
    return n.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, le), r = n.parse(t[2], 2, le);
  if (!s || !r)
    return null;
  if (!_0(s.type, [
    oe,
    me,
    Pt,
    Zf,
    le
  ]))
    return n.error("Expected first argument to be of type boolean, string, number or null, but found " + rn(s.type) + " instead");
  if (t.length === 4) {
    var i = n.parse(t[3], 3, Pt);
    return i ? new $a(s, r, i) : null;
  } else
    return new $a(s, r);
};
$a.prototype.evaluate = function(t) {
  var n = this.needle.evaluate(t), s = this.haystack.evaluate(t);
  if (!Mc(n, [
    "boolean",
    "string",
    "number",
    "null"
  ]))
    throw new Gn("Expected first argument to be of type boolean, string, number or null, but found " + rn(Bn(n)) + " instead.");
  if (!Mc(s, [
    "string",
    "array"
  ]))
    throw new Gn("Expected second argument to be of type array or string, but found " + rn(Bn(s)) + " instead.");
  if (this.fromIndex) {
    var r = this.fromIndex.evaluate(t);
    return s.indexOf(n, r);
  }
  return s.indexOf(n);
};
$a.prototype.eachChild = function(t) {
  t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
};
$a.prototype.outputDefined = function() {
  return !1;
};
$a.prototype.serialize = function() {
  if (this.fromIndex != null && this.fromIndex !== void 0) {
    var t = this.fromIndex.serialize();
    return [
      "index-of",
      this.needle.serialize(),
      this.haystack.serialize(),
      t
    ];
  }
  return [
    "index-of",
    this.needle.serialize(),
    this.haystack.serialize()
  ];
};
var zo = function(t, n, s, r, i, a) {
  this.inputType = t, this.type = n, this.input = s, this.cases = r, this.outputs = i, this.otherwise = a;
};
zo.parse = function(t, n) {
  if (t.length < 5)
    return n.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");
  if (t.length % 2 !== 1)
    return n.error("Expected an even number of arguments.");
  var s, r;
  n.expectedType && n.expectedType.kind !== "value" && (r = n.expectedType);
  for (var i = {}, a = [], o = 2; o < t.length - 1; o += 2) {
    var l = t[o], f = t[o + 1];
    Array.isArray(l) || (l = [l]);
    var d = n.concat(o);
    if (l.length === 0)
      return d.error("Expected at least one branch label.");
    for (var u = 0, c = l; u < c.length; u += 1) {
      var h = c[u];
      if (typeof h != "number" && typeof h != "string")
        return d.error("Branch labels must be numbers or strings.");
      if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER)
        return d.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
      if (typeof h == "number" && Math.floor(h) !== h)
        return d.error("Numeric branch labels must be integer values.");
      if (!s)
        s = Bn(h);
      else if (d.checkSubtype(s, Bn(h)))
        return null;
      if (typeof i[String(h)] < "u")
        return d.error("Branch labels must be unique.");
      i[String(h)] = a.length;
    }
    var p = n.parse(f, o, r);
    if (!p)
      return null;
    r = r || p.type, a.push(p);
  }
  var g = n.parse(t[1], 1, le);
  if (!g)
    return null;
  var m = n.parse(t[t.length - 1], t.length - 1, r);
  return !m || g.type.kind !== "value" && n.concat(1).checkSubtype(s, g.type) ? null : new zo(s, r, g, i, a, m);
};
zo.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = Bn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise;
  return s.evaluate(t);
};
zo.prototype.eachChild = function(t) {
  t(this.input), this.outputs.forEach(t), t(this.otherwise);
};
zo.prototype.outputDefined = function() {
  return this.outputs.every(function(t) {
    return t.outputDefined();
  }) && this.otherwise.outputDefined();
};
zo.prototype.serialize = function() {
  for (var t = this, n = [
    "match",
    this.input.serialize()
  ], s = Object.keys(this.cases).sort(), r = [], i = {}, a = 0, o = s; a < o.length; a += 1) {
    var l = o[a], f = i[this.cases[l]];
    f === void 0 ? (i[this.cases[l]] = r.length, r.push([
      this.cases[l],
      [l]
    ])) : r[f][1].push(l);
  }
  for (var d = function(g) {
    return t.inputType.kind === "number" ? Number(g) : g;
  }, u = 0, c = r; u < c.length; u += 1) {
    var h = c[u], f = h[0], p = h[1];
    p.length === 1 ? n.push(d(p[0])) : n.push(p.map(d)), n.push(this.outputs[outputIndex$1].serialize());
  }
  return n.push(this.otherwise.serialize()), n;
};
var Ko = function(t, n, s) {
  this.type = t, this.branches = n, this.otherwise = s;
};
Ko.parse = function(t, n) {
  if (t.length < 4)
    return n.error("Expected at least 3 arguments, but found only " + (t.length - 1) + ".");
  if (t.length % 2 !== 0)
    return n.error("Expected an odd number of arguments.");
  var s;
  n.expectedType && n.expectedType.kind !== "value" && (s = n.expectedType);
  for (var r = [], i = 1; i < t.length - 1; i += 2) {
    var a = n.parse(t[i], i, oe);
    if (!a)
      return null;
    var o = n.parse(t[i + 1], i + 1, s);
    if (!o)
      return null;
    r.push([
      a,
      o
    ]), s = s || o.type;
  }
  var l = n.parse(t[t.length - 1], t.length - 1, s);
  return l ? new Ko(s, r, l) : null;
};
Ko.prototype.evaluate = function(t) {
  for (var n = 0, s = this.branches; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    if (i.evaluate(t))
      return a.evaluate(t);
  }
  return this.otherwise.evaluate(t);
};
Ko.prototype.eachChild = function(t) {
  for (var n = 0, s = this.branches; n < s.length; n += 1) {
    var r = s[n], i = r[0], a = r[1];
    t(i), t(a);
  }
  t(this.otherwise);
};
Ko.prototype.outputDefined = function() {
  return this.branches.every(function(t) {
    t[0];
    var n = t[1];
    return n.outputDefined();
  }) && this.otherwise.outputDefined();
};
Ko.prototype.serialize = function() {
  var t = ["case"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var Ua = function(t, n, s, r) {
  this.type = t, this.input = n, this.beginIndex = s, this.endIndex = r;
};
Ua.parse = function(t, n) {
  if (t.length <= 2 || t.length >= 5)
    return n.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1, le), r = n.parse(t[2], 2, Pt);
  if (!s || !r)
    return null;
  if (!_0(s.type, [
    gr(le),
    me,
    le
  ]))
    return n.error("Expected first argument to be of type array or string, but found " + rn(s.type) + " instead");
  if (t.length === 4) {
    var i = n.parse(t[3], 3, Pt);
    return i ? new Ua(s.type, s, r, i) : null;
  } else
    return new Ua(s.type, s, r);
};
Ua.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t), s = this.beginIndex.evaluate(t);
  if (!Mc(n, [
    "string",
    "array"
  ]))
    throw new Gn("Expected first argument to be of type array or string, but found " + rn(Bn(n)) + " instead.");
  if (this.endIndex) {
    var r = this.endIndex.evaluate(t);
    return n.slice(s, r);
  }
  return n.slice(s);
};
Ua.prototype.eachChild = function(t) {
  t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
};
Ua.prototype.outputDefined = function() {
  return !1;
};
Ua.prototype.serialize = function() {
  if (this.endIndex != null && this.endIndex !== void 0) {
    var t = this.endIndex.serialize();
    return [
      "slice",
      this.input.serialize(),
      this.beginIndex.serialize(),
      t
    ];
  }
  return [
    "slice",
    this.input.serialize(),
    this.beginIndex.serialize()
  ];
};
function Ox(e, t) {
  return e === "==" || e === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
}
function WW(e, t, n) {
  return t === n;
}
function zW(e, t, n) {
  return t !== n;
}
function KW(e, t, n) {
  return t < n;
}
function GW(e, t, n) {
  return t > n;
}
function kW(e, t, n) {
  return t <= n;
}
function HW(e, t, n) {
  return t >= n;
}
function QS(e, t, n, s) {
  return s.compare(t, n) === 0;
}
function YW(e, t, n, s) {
  return !QS(e, t, n, s);
}
function XW(e, t, n, s) {
  return s.compare(t, n) < 0;
}
function ZW(e, t, n, s) {
  return s.compare(t, n) > 0;
}
function JW(e, t, n, s) {
  return s.compare(t, n) <= 0;
}
function QW(e, t, n, s) {
  return s.compare(t, n) >= 0;
}
function bu(e, t, n) {
  var s = e !== "==" && e !== "!=";
  return /* @__PURE__ */ function() {
    function r(i, a, o) {
      this.type = oe, this.lhs = i, this.rhs = a, this.collator = o, this.hasUntypedArgument = i.type.kind === "value" || a.type.kind === "value";
    }
    return r.parse = function(a, o) {
      if (a.length !== 3 && a.length !== 4)
        return o.error("Expected two or three arguments.");
      var l = a[0], f = o.parse(a[1], 1, le);
      if (!f)
        return null;
      if (!Ox(l, f.type))
        return o.concat(1).error('"' + l + `" comparisons are not supported for type '` + rn(f.type) + "'.");
      var d = o.parse(a[2], 2, le);
      if (!d)
        return null;
      if (!Ox(l, d.type))
        return o.concat(2).error('"' + l + `" comparisons are not supported for type '` + rn(d.type) + "'.");
      if (f.type.kind !== d.type.kind && f.type.kind !== "value" && d.type.kind !== "value")
        return o.error("Cannot compare types '" + rn(f.type) + "' and '" + rn(d.type) + "'.");
      s && (f.type.kind === "value" && d.type.kind !== "value" ? f = new Si(d.type, [f]) : f.type.kind !== "value" && d.type.kind === "value" && (d = new Si(f.type, [d])));
      var u = null;
      if (a.length === 4) {
        if (f.type.kind !== "string" && d.type.kind !== "string" && f.type.kind !== "value" && d.type.kind !== "value")
          return o.error("Cannot use collator to compare non-string types.");
        if (u = o.parse(a[3], 3, Jf), !u)
          return null;
      }
      return new r(f, d, u);
    }, r.prototype.evaluate = function(a) {
      var o = this.lhs.evaluate(a), l = this.rhs.evaluate(a);
      if (s && this.hasUntypedArgument) {
        var f = Bn(o), d = Bn(l);
        if (f.kind !== d.kind || !(f.kind === "string" || f.kind === "number"))
          throw new Gn('Expected arguments for "' + e + '" to be (string, string) or (number, number), but found (' + f.kind + ", " + d.kind + ") instead.");
      }
      if (this.collator && !s && this.hasUntypedArgument) {
        var u = Bn(o), c = Bn(l);
        if (u.kind !== "string" || c.kind !== "string")
          return t(a, o, l);
      }
      return this.collator ? n(a, o, l, this.collator.evaluate(a)) : t(a, o, l);
    }, r.prototype.eachChild = function(a) {
      a(this.lhs), a(this.rhs), this.collator && a(this.collator);
    }, r.prototype.outputDefined = function() {
      return !0;
    }, r.prototype.serialize = function() {
      var a = [e];
      return this.eachChild(function(o) {
        a.push(o.serialize());
      }), a;
    }, r;
  }();
}
var qW = bu("==", WW, QS), t3 = bu("!=", zW, YW), e3 = bu("<", KW, XW), n3 = bu(">", GW, ZW), i3 = bu("<=", kW, JW), r3 = bu(">=", HW, QW), Go = function(t, n, s, r, i) {
  this.type = me, this.number = t, this.locale = n, this.currency = s, this.minFractionDigits = r, this.maxFractionDigits = i;
};
Go.parse = function(t, n) {
  if (t.length !== 3)
    return n.error("Expected two arguments.");
  var s = n.parse(t[1], 1, Pt);
  if (!s)
    return null;
  var r = t[2];
  if (typeof r != "object" || Array.isArray(r))
    return n.error("NumberFormat options argument must be an object.");
  var i = null;
  if (r.locale && (i = n.parse(r.locale, 1, me), !i))
    return null;
  var a = null;
  if (r.currency && (a = n.parse(r.currency, 1, me), !a))
    return null;
  var o = null;
  if (r["min-fraction-digits"] && (o = n.parse(r["min-fraction-digits"], 1, Pt), !o))
    return null;
  var l = null;
  return r["max-fraction-digits"] && (l = n.parse(r["max-fraction-digits"], 1, Pt), !l) ? null : new Go(s, i, a, o, l);
};
Go.prototype.evaluate = function(t) {
  return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
    style: this.currency ? "currency" : "decimal",
    currency: this.currency ? this.currency.evaluate(t) : void 0,
    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
  }).format(this.number.evaluate(t));
};
Go.prototype.eachChild = function(t) {
  t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
};
Go.prototype.outputDefined = function() {
  return !1;
};
Go.prototype.serialize = function() {
  var t = {};
  return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
    "number-format",
    this.number.serialize(),
    t
  ];
};
var ko = function(t) {
  this.type = Pt, this.input = t;
};
ko.parse = function(t, n) {
  if (t.length !== 2)
    return n.error("Expected 1 argument, but found " + (t.length - 1) + " instead.");
  var s = n.parse(t[1], 1);
  return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? n.error("Expected argument of type string or array, but found " + rn(s.type) + " instead.") : new ko(s) : null;
};
ko.prototype.evaluate = function(t) {
  var n = this.input.evaluate(t);
  if (typeof n == "string")
    return n.length;
  if (Array.isArray(n))
    return n.length;
  throw new Gn("Expected value to be of type string or array, but found " + rn(Bn(n)) + " instead.");
};
ko.prototype.eachChild = function(t) {
  t(this.input);
};
ko.prototype.outputDefined = function() {
  return !1;
};
ko.prototype.serialize = function() {
  var t = ["length"];
  return this.eachChild(function(n) {
    t.push(n.serialize());
  }), t;
};
var w0 = {
  // special forms
  "==": qW,
  "!=": t3,
  ">": n3,
  "<": e3,
  ">=": r3,
  "<=": i3,
  array: Si,
  at: Uo,
  boolean: Si,
  case: Ko,
  coalesce: qs,
  collator: Za,
  format: Ya,
  image: Xa,
  in: Wo,
  "index-of": $a,
  interpolate: _i,
  "interpolate-hcl": _i,
  "interpolate-lab": _i,
  length: ko,
  let: to,
  literal: Cs,
  match: zo,
  number: Si,
  "number-format": Go,
  object: Si,
  slice: Ua,
  step: qa,
  string: Si,
  "to-boolean": yr,
  "to-color": yr,
  "to-number": yr,
  "to-string": yr,
  var: Ja,
  within: Vr
};
function Px(e, t) {
  var n = t[0], s = t[1], r = t[2], i = t[3];
  n = n.evaluate(e), s = s.evaluate(e), r = r.evaluate(e);
  var a = i ? i.evaluate(e) : 1, o = $S(n, s, r, a);
  if (o)
    throw new Gn(o);
  return new Re(n / 255 * a, s / 255 * a, r / 255 * a, a);
}
function Sx(e, t) {
  return e in t;
}
function Kp(e, t) {
  var n = t[e];
  return typeof n > "u" ? null : n;
}
function s3(e, t, n, s) {
  for (; n <= s; ) {
    var r = n + s >> 1;
    if (t[r] === e)
      return !0;
    t[r] > e ? s = r - 1 : n = r + 1;
  }
  return !1;
}
function fo(e) {
  return { type: e };
}
di.register(w0, {
  error: [
    dW,
    [me],
    function(e, t) {
      var n = t[0];
      throw new Gn(n.evaluate(e));
    }
  ],
  typeof: [
    me,
    [le],
    function(e, t) {
      var n = t[0];
      return rn(Bn(n.evaluate(e)));
    }
  ],
  "to-rgba": [
    gr(Pt, 4),
    [Qs],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toArray();
    }
  ],
  rgb: [
    Qs,
    [
      Pt,
      Pt,
      Pt
    ],
    Px
  ],
  rgba: [
    Qs,
    [
      Pt,
      Pt,
      Pt,
      Pt
    ],
    Px
  ],
  has: {
    type: oe,
    overloads: [
      [
        [me],
        function(e, t) {
          var n = t[0];
          return Sx(n.evaluate(e), e.properties());
        }
      ],
      [
        [
          me,
          kl
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return Sx(n.evaluate(e), s.evaluate(e));
        }
      ]
    ]
  },
  get: {
    type: le,
    overloads: [
      [
        [me],
        function(e, t) {
          var n = t[0];
          return Kp(n.evaluate(e), e.properties());
        }
      ],
      [
        [
          me,
          kl
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return Kp(n.evaluate(e), s.evaluate(e));
        }
      ]
    ]
  },
  "feature-state": [
    le,
    [me],
    function(e, t) {
      var n = t[0];
      return Kp(n.evaluate(e), e.featureState || {});
    }
  ],
  properties: [
    kl,
    [],
    function(e) {
      return e.properties();
    }
  ],
  "geometry-type": [
    me,
    [],
    function(e) {
      return e.geometryType();
    }
  ],
  id: [
    le,
    [],
    function(e) {
      return e.id();
    }
  ],
  zoom: [
    Pt,
    [],
    function(e) {
      return e.globals.zoom;
    }
  ],
  pitch: [
    Pt,
    [],
    function(e) {
      return e.globals.pitch || 0;
    }
  ],
  "distance-from-center": [
    Pt,
    [],
    function(e) {
      return e.distanceFromCenter();
    }
  ],
  "heatmap-density": [
    Pt,
    [],
    function(e) {
      return e.globals.heatmapDensity || 0;
    }
  ],
  "line-progress": [
    Pt,
    [],
    function(e) {
      return e.globals.lineProgress || 0;
    }
  ],
  "sky-radial-progress": [
    Pt,
    [],
    function(e) {
      return e.globals.skyRadialProgress || 0;
    }
  ],
  accumulated: [
    le,
    [],
    function(e) {
      return e.globals.accumulated === void 0 ? null : e.globals.accumulated;
    }
  ],
  "+": [
    Pt,
    fo(Pt),
    function(e, t) {
      for (var n = 0, s = 0, r = t; s < r.length; s += 1) {
        var i = r[s];
        n += i.evaluate(e);
      }
      return n;
    }
  ],
  "*": [
    Pt,
    fo(Pt),
    function(e, t) {
      for (var n = 1, s = 0, r = t; s < r.length; s += 1) {
        var i = r[s];
        n *= i.evaluate(e);
      }
      return n;
    }
  ],
  "-": {
    type: Pt,
    overloads: [
      [
        [
          Pt,
          Pt
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) - s.evaluate(e);
        }
      ],
      [
        [Pt],
        function(e, t) {
          var n = t[0];
          return -n.evaluate(e);
        }
      ]
    ]
  },
  "/": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return n.evaluate(e) / s.evaluate(e);
    }
  ],
  "%": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return n.evaluate(e) % s.evaluate(e);
    }
  ],
  ln2: [
    Pt,
    [],
    function() {
      return Math.LN2;
    }
  ],
  pi: [
    Pt,
    [],
    function() {
      return Math.PI;
    }
  ],
  e: [
    Pt,
    [],
    function() {
      return Math.E;
    }
  ],
  "^": [
    Pt,
    [
      Pt,
      Pt
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return Math.pow(n.evaluate(e), s.evaluate(e));
    }
  ],
  sqrt: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.sqrt(n.evaluate(e));
    }
  ],
  log10: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e)) / Math.LN10;
    }
  ],
  ln: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e));
    }
  ],
  log2: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.log(n.evaluate(e)) / Math.LN2;
    }
  ],
  sin: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.sin(n.evaluate(e));
    }
  ],
  cos: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.cos(n.evaluate(e));
    }
  ],
  tan: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.tan(n.evaluate(e));
    }
  ],
  asin: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.asin(n.evaluate(e));
    }
  ],
  acos: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.acos(n.evaluate(e));
    }
  ],
  atan: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.atan(n.evaluate(e));
    }
  ],
  min: [
    Pt,
    fo(Pt),
    function(e, t) {
      return Math.min.apply(Math, t.map(function(n) {
        return n.evaluate(e);
      }));
    }
  ],
  max: [
    Pt,
    fo(Pt),
    function(e, t) {
      return Math.max.apply(Math, t.map(function(n) {
        return n.evaluate(e);
      }));
    }
  ],
  abs: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.abs(n.evaluate(e));
    }
  ],
  round: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0], s = n.evaluate(e);
      return s < 0 ? -Math.round(-s) : Math.round(s);
    }
  ],
  floor: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.floor(n.evaluate(e));
    }
  ],
  ceil: [
    Pt,
    [Pt],
    function(e, t) {
      var n = t[0];
      return Math.ceil(n.evaluate(e));
    }
  ],
  "filter-==": [
    oe,
    [
      me,
      le
    ],
    function(e, t) {
      var n = t[0], s = t[1];
      return e.properties()[n.value] === s.value;
    }
  ],
  "filter-id-==": [
    oe,
    [le],
    function(e, t) {
      var n = t[0];
      return e.id() === n.value;
    }
  ],
  "filter-type-==": [
    oe,
    [me],
    function(e, t) {
      var n = t[0];
      return e.geometryType() === n.value;
    }
  ],
  "filter-<": [
    oe,
    [
      me,
      le
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r < i;
    }
  ],
  "filter-id-<": [
    oe,
    [le],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s < r;
    }
  ],
  "filter->": [
    oe,
    [
      me,
      le
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r > i;
    }
  ],
  "filter-id->": [
    oe,
    [le],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s > r;
    }
  ],
  "filter-<=": [
    oe,
    [
      me,
      le
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r <= i;
    }
  ],
  "filter-id-<=": [
    oe,
    [le],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s <= r;
    }
  ],
  "filter->=": [
    oe,
    [
      me,
      le
    ],
    function(e, t) {
      var n = t[0], s = t[1], r = e.properties()[n.value], i = s.value;
      return typeof r == typeof i && r >= i;
    }
  ],
  "filter-id->=": [
    oe,
    [le],
    function(e, t) {
      var n = t[0], s = e.id(), r = n.value;
      return typeof s == typeof r && s >= r;
    }
  ],
  "filter-has": [
    oe,
    [le],
    function(e, t) {
      var n = t[0];
      return n.value in e.properties();
    }
  ],
  "filter-has-id": [
    oe,
    [],
    function(e) {
      return e.id() !== null && e.id() !== void 0;
    }
  ],
  "filter-type-in": [
    oe,
    [gr(me)],
    function(e, t) {
      var n = t[0];
      return n.value.indexOf(e.geometryType()) >= 0;
    }
  ],
  "filter-id-in": [
    oe,
    [gr(le)],
    function(e, t) {
      var n = t[0];
      return n.value.indexOf(e.id()) >= 0;
    }
  ],
  "filter-in-small": [
    oe,
    [
      me,
      gr(le)
    ],
    // assumes v is an array literal
    function(e, t) {
      var n = t[0], s = t[1];
      return s.value.indexOf(e.properties()[n.value]) >= 0;
    }
  ],
  "filter-in-large": [
    oe,
    [
      me,
      gr(le)
    ],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    function(e, t) {
      var n = t[0], s = t[1];
      return s3(e.properties()[n.value], s.value, 0, s.value.length - 1);
    }
  ],
  all: {
    type: oe,
    overloads: [
      [
        [
          oe,
          oe
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) && s.evaluate(e);
        }
      ],
      [
        fo(oe),
        function(e, t) {
          for (var n = 0, s = t; n < s.length; n += 1) {
            var r = s[n];
            if (!r.evaluate(e))
              return !1;
          }
          return !0;
        }
      ]
    ]
  },
  any: {
    type: oe,
    overloads: [
      [
        [
          oe,
          oe
        ],
        function(e, t) {
          var n = t[0], s = t[1];
          return n.evaluate(e) || s.evaluate(e);
        }
      ],
      [
        fo(oe),
        function(e, t) {
          for (var n = 0, s = t; n < s.length; n += 1) {
            var r = s[n];
            if (r.evaluate(e))
              return !0;
          }
          return !1;
        }
      ]
    ]
  },
  "!": [
    oe,
    [oe],
    function(e, t) {
      var n = t[0];
      return !n.evaluate(e);
    }
  ],
  "is-supported-script": [
    oe,
    [me],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    function(e, t) {
      var n = t[0], s = e.globals && e.globals.isSupportedScript;
      return s ? s(n.evaluate(e)) : !0;
    }
  ],
  upcase: [
    me,
    [me],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toUpperCase();
    }
  ],
  downcase: [
    me,
    [me],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).toLowerCase();
    }
  ],
  concat: [
    me,
    fo(le),
    function(e, t) {
      return t.map(function(n) {
        return ac(n.evaluate(e));
      }).join("");
    }
  ],
  "resolved-locale": [
    me,
    [Jf],
    function(e, t) {
      var n = t[0];
      return n.evaluate(e).resolvedLocale();
    }
  ]
});
function dv(e) {
  return {
    result: "success",
    value: e
  };
}
function xl(e) {
  return {
    result: "error",
    value: e
  };
}
function a3(e) {
  return e["property-type"] === "data-driven" || e["property-type"] === "cross-faded-data-driven";
}
function o3(e) {
  return !!e.expression && e.expression.parameters.indexOf("zoom") > -1;
}
function l3(e) {
  return !!e.expression && e.expression.interpolated;
}
function qS(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var V0 = function(t, n) {
  this.expression = t, this._warningHistory = {}, this._evaluator = new ua(), this._defaultValue = n ? d3(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null;
};
V0.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a, o, l) {
  return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = s, this._evaluator.canonical = r || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = l || null, this.expression.evaluate(this._evaluator);
};
V0.prototype.evaluate = function(t, n, s, r, i, a, o, l) {
  this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = s || null, this._evaluator.canonical = r || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = l || null;
  try {
    var f = this.expression.evaluate(this._evaluator);
    if (f == null || typeof f == "number" && f !== f)
      return this._defaultValue;
    if (this._enumValues && !(f in this._enumValues))
      throw new Gn("Expected value to be one of " + Object.keys(this._enumValues).map(function(d) {
        return JSON.stringify(d);
      }).join(", ") + ", but found " + JSON.stringify(f) + " instead.");
    return f;
  } catch (d) {
    return this._warningHistory[d.message] || (this._warningHistory[d.message] = !0, typeof console < "u" && console.warn(d.message)), this._defaultValue;
  }
};
function u3(e) {
  return Array.isArray(e) && e.length > 0 && typeof e[0] == "string" && e[0] in w0;
}
function fv(e, t) {
  var n = new Qa(w0, [], t ? h3(t) : void 0), s = n.parse(e, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return s ? dv(new V0(s, t)) : xl(n.errors);
}
var Jd = function(t, n) {
  this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !L0(n.expression);
};
Jd.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, r, i, a);
};
Jd.prototype.evaluate = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluate(t, n, s, r, i, a);
};
var _c = function(t, n, s, r) {
  this.kind = t, this.zoomStops = s, this._styleExpression = n, this.isStateDependent = t !== "camera" && !L0(n.expression), this.interpolationType = r;
};
_c.prototype.evaluateWithoutErrorHandling = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, r, i, a);
};
_c.prototype.evaluate = function(t, n, s, r, i, a) {
  return this._styleExpression.evaluate(t, n, s, r, i, a);
};
_c.prototype.interpolationFactor = function(t, n, s) {
  return this.interpolationType ? _i.interpolationFactor(this.interpolationType, t, n, s) : 0;
};
function c3(e, t) {
  if (e = fv(e, t), e.result === "error")
    return e;
  var n = e.value.expression, s = qf(n);
  if (!s && !a3(t))
    return xl([new ls("", "data expressions not supported")]);
  var r = R0(n, [
    "zoom",
    "pitch",
    "distance-from-center"
  ]);
  if (!r && !o3(t))
    return xl([new ls("", "zoom expressions not supported")]);
  var i = fd(n);
  if (!i && !r)
    return xl([new ls("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (i instanceof ls)
    return xl([i]);
  if (i instanceof _i && !l3(t))
    return xl([new ls("", '"interpolate" expressions cannot be used with this property')]);
  if (!i)
    return dv(s ? new Jd("constant", e.value) : new Jd("source", e.value));
  var a = i instanceof _i ? i.interpolation : void 0;
  return dv(s ? new _c("camera", e.value, i.labels, a) : new _c("composite", e.value, i.labels, a));
}
function fd(e) {
  var t = null;
  if (e instanceof to)
    t = fd(e.result);
  else if (e instanceof qs)
    for (var n = 0, s = e.args; n < s.length; n += 1) {
      var r = s[n];
      if (t = fd(r), t)
        break;
    }
  else
    (e instanceof qa || e instanceof _i) && e.input instanceof di && e.input.name === "zoom" && (t = e);
  return t instanceof ls || e.eachChild(function(i) {
    var a = fd(i);
    a instanceof ls ? t = a : !t && a ? t = new ls("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && a && t !== a && (t = new ls("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), t;
}
function h3(e) {
  var t = {
    color: Qs,
    string: me,
    number: Pt,
    enum: me,
    boolean: oe,
    formatted: Qf,
    resolvedImage: qc
  };
  return e.type === "array" ? gr(t[e.value] || le, e.length) : t[e.type];
}
function d3(e) {
  return e.type === "color" && (qS(e.default) || Array.isArray(e.default)) ? new Re(0, 0, 0, 0) : e.type === "color" ? Re.parse(e.default) || null : e.default === void 0 ? null : e.default;
}
function f3(e) {
  return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
}
function pv(e) {
  if (Array.isArray(e))
    return e.map(pv);
  if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
    var t = {};
    for (var n in e)
      t[n] = pv(e[n]);
    return t;
  }
  return f3(e);
}
var tM = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, fog: { type: "fog" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, projection: { type: "projection" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {}, sky: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_sky: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_symbol: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature", "pitch", "distance-from-center"] } }, filter_fill: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_line: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_circle: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, "filter_fill-extrusion": { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_heatmap: { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, expression_name: { type: "enum", values: { let: { group: "Variable binding" }, var: { group: "Variable binding" }, literal: { group: "Types" }, array: { group: "Types" }, at: { group: "Lookup" }, in: { group: "Lookup" }, "index-of": { group: "Lookup" }, slice: { group: "Lookup" }, case: { group: "Decision" }, match: { group: "Decision" }, coalesce: { group: "Decision" }, step: { group: "Ramps, scales, curves" }, interpolate: { group: "Ramps, scales, curves" }, "interpolate-hcl": { group: "Ramps, scales, curves" }, "interpolate-lab": { group: "Ramps, scales, curves" }, ln2: { group: "Math" }, pi: { group: "Math" }, e: { group: "Math" }, typeof: { group: "Types" }, string: { group: "Types" }, number: { group: "Types" }, boolean: { group: "Types" }, object: { group: "Types" }, collator: { group: "Types" }, format: { group: "Types" }, image: { group: "Types" }, "number-format": { group: "Types" }, "to-string": { group: "Types" }, "to-number": { group: "Types" }, "to-boolean": { group: "Types" }, "to-rgba": { group: "Color" }, "to-color": { group: "Types" }, rgb: { group: "Color" }, rgba: { group: "Color" }, get: { group: "Lookup" }, has: { group: "Lookup" }, length: { group: "Lookup" }, properties: { group: "Feature data" }, "feature-state": { group: "Feature data" }, "geometry-type": { group: "Feature data" }, id: { group: "Feature data" }, zoom: { group: "Camera" }, pitch: { group: "Camera" }, "distance-from-center": { group: "Camera" }, "heatmap-density": { group: "Heatmap" }, "line-progress": { group: "Feature data" }, "sky-radial-progress": { group: "sky" }, accumulated: { group: "Feature data" }, "+": { group: "Math" }, "*": { group: "Math" }, "-": { group: "Math" }, "/": { group: "Math" }, "%": { group: "Math" }, "^": { group: "Math" }, sqrt: { group: "Math" }, log10: { group: "Math" }, ln: { group: "Math" }, log2: { group: "Math" }, sin: { group: "Math" }, cos: { group: "Math" }, tan: { group: "Math" }, asin: { group: "Math" }, acos: { group: "Math" }, atan: { group: "Math" }, min: { group: "Math" }, max: { group: "Math" }, round: { group: "Math" }, abs: { group: "Math" }, ceil: { group: "Math" }, floor: { group: "Math" }, distance: { group: "Math" }, "==": { group: "Decision" }, "!=": { group: "Decision" }, ">": { group: "Decision" }, "<": { group: "Decision" }, ">=": { group: "Decision" }, "<=": { group: "Decision" }, all: { group: "Decision" }, any: { group: "Decision" }, "!": { group: "Decision" }, within: { group: "Decision" }, "is-supported-script": { group: "String" }, upcase: { group: "String" }, downcase: { group: "String" }, concat: { group: "String" }, "resolved-locale": { group: "String" } } }, fog: { range: { type: "array", default: [0.5, 10], minimum: -20, maximum: 20, length: 2, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "high-color": { type: "color", "property-type": "data-constant", default: "#245cdf", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "space-color": { type: "color", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 4, "#010b19", 7, "#367ab9"], expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-blend": { type: "number", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 4, 0.2, 7, 0.1], minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "star-intensity": { type: "number", "property-type": "data-constant", default: ["interpolate", ["linear"], ["zoom"], 5, 0.35, 6, 0], minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, projection: { name: { type: "enum", values: { albers: {}, equalEarth: {}, equirectangular: {}, lambertConformalConic: {}, mercator: {}, naturalEarth: {}, winkelTripel: {}, globe: {} }, default: "mercator", required: !0 }, center: { type: "array", length: 2, value: "number", "property-type": "data-constant", minimum: [-180, -90], maximum: [180, 90], transition: !1, requires: [{ name: ["albers", "lambertConformalConic"] }] }, parallels: { type: "array", length: 2, value: "number", "property-type": "data-constant", minimum: [-90, -90], maximum: [90, 90], transition: !1, requires: [{ name: ["albers", "lambertConformalConic"] }] } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", "property-type": "data-constant", default: 1, minimum: 0, maximum: 1e3, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0, requires: ["source"] } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" }, "line-trim-offset": { type: "array", value: "number", length: 2, default: [0, 0], minimum: [0, 0], maximum: [1, 1], transition: !1, requires: [{ source: "geojson", has: { lineMetrics: !0 } }], "property-type": "constant" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_sky: { "sky-type": { type: "enum", values: { gradient: {}, atmosphere: {} }, default: "atmosphere", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun": { type: "array", value: "number", length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: !1, requires: [{ "sky-type": "atmosphere" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun-intensity": { type: "number", requires: [{ "sky-type": "atmosphere" }], default: 10, minimum: 0, maximum: 100, transition: !1, "property-type": "data-constant" }, "sky-gradient-center": { type: "array", requires: [{ "sky-type": "gradient" }], value: "number", default: [0, 0], length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient-radius": { type: "number", requires: [{ "sky-type": "gradient" }], default: 90, minimum: 0, maximum: 180, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient": { type: "color", default: ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"], transition: !1, requires: [{ "sky-type": "gradient" }], expression: { interpolated: !0, parameters: ["sky-radial-progress"] }, "property-type": "color-ramp" }, "sky-atmosphere-halo-color": { type: "color", default: "white", transition: !1, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-atmosphere-color": { type: "color", default: "white", transition: !1, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
function eM(e) {
  if (e === !0 || e === !1)
    return !0;
  if (!Array.isArray(e) || e.length === 0)
    return !1;
  switch (e[0]) {
    case "has":
      return e.length >= 2 && e[1] !== "$id" && e[1] !== "$type";
    case "in":
      return e.length >= 3 && (typeof e[1] != "string" || Array.isArray(e[2]));
    case "!in":
    case "!has":
    case "none":
      return !1;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return e.length !== 3 || Array.isArray(e[1]) || Array.isArray(e[2]);
    case "any":
    case "all":
      for (var t = 0, n = e.slice(1); t < n.length; t += 1) {
        var s = n[t];
        if (!eM(s) && typeof s != "boolean")
          return !1;
      }
      return !0;
    default:
      return !0;
  }
}
function p3(e, t) {
  if (t === void 0 && (t = "fill"), e == null)
    return {
      filter: function() {
        return !0;
      },
      needGeometry: !1,
      needFeature: !1
    };
  eM(e) || (e = Qd(e));
  var n = e, s = !0;
  try {
    s = m3(n);
  } catch {
    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
` + JSON.stringify(n, null, 2) + `
        `);
  }
  var r = tM["filter_" + t], i = fv(s, r), a = null;
  if (i.result === "error")
    throw new Error(i.value.map(function(u) {
      return u.key + ": " + u.message;
    }).join(", "));
  a = function(u, c, h) {
    return i.value.evaluate(u, c, {}, h);
  };
  var o = null, l = null;
  if (s !== n) {
    var f = fv(n, r);
    if (f.result === "error")
      throw new Error(f.value.map(function(u) {
        return u.key + ": " + u.message;
      }).join(", "));
    o = function(u, c, h, p, g) {
      return f.value.evaluate(u, c, {}, h, void 0, void 0, p, g);
    }, l = !qf(f.value.expression);
  }
  a = a;
  var d = rM(s);
  return {
    filter: a,
    dynamicFilter: o || void 0,
    needGeometry: d,
    needFeature: !!l
  };
}
function m3(e) {
  if (!Yl(e))
    return e;
  var t = pv(e);
  return iM(t), t = nM(t), t;
}
function nM(e) {
  if (!Array.isArray(e))
    return e;
  var t = y3(e);
  return t === !0 ? t : t.map(function(n) {
    return nM(n);
  });
}
function iM(e) {
  var t = !1, n = [];
  if (e[0] === "case") {
    for (var s = 1; s < e.length - 1; s += 2)
      t = t || Yl(e[s]), n.push(e[s + 1]);
    n.push(e[e.length - 1]);
  } else if (e[0] === "match") {
    t = t || Yl(e[1]);
    for (var r = 2; r < e.length - 1; r += 2)
      n.push(e[r + 1]);
    n.push(e[e.length - 1]);
  } else if (e[0] === "step") {
    t = t || Yl(e[1]);
    for (var i = 1; i < e.length - 1; i += 2)
      n.push(e[i + 1]);
  }
  t && (e.length = 0, e.push.apply(e, ["any"].concat(n)));
  for (var a = 1; a < e.length; a++)
    iM(e[a]);
}
function Yl(e) {
  if (!Array.isArray(e))
    return !1;
  if (g3(e[0]))
    return !0;
  for (var t = 1; t < e.length; t++) {
    var n = e[t];
    if (Yl(n))
      return !0;
  }
  return !1;
}
function g3(e) {
  return e === "pitch" || e === "distance-from-center";
}
var v3 = /* @__PURE__ */ new Set([
  "in",
  "==",
  "!=",
  ">",
  ">=",
  "<",
  "<=",
  "to-boolean"
]);
function y3(e) {
  if (v3.has(e[0]))
    for (var t = 1; t < e.length; t++) {
      var n = e[t];
      if (Yl(n))
        return !0;
    }
  return e;
}
function E3(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function rM(e) {
  if (!Array.isArray(e))
    return !1;
  if (e[0] === "within")
    return !0;
  for (var t = 1; t < e.length; t++)
    if (rM(e[t]))
      return !0;
  return !1;
}
function Qd(e) {
  if (!e)
    return !0;
  var t = e[0];
  if (e.length <= 1)
    return t !== "any";
  var n = t === "==" ? Gp(e[1], e[2], "==") : t === "!=" ? Rh(Gp(e[1], e[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Gp(e[1], e[2], t) : t === "any" ? C3(e.slice(1)) : t === "all" ? ["all"].concat(e.slice(1).map(Qd)) : t === "none" ? ["all"].concat(e.slice(1).map(Qd).map(Rh)) : t === "in" ? Mx(e[1], e.slice(2)) : t === "!in" ? Rh(Mx(e[1], e.slice(2))) : t === "has" ? _x(e[1]) : t === "!has" ? Rh(_x(e[1])) : t === "within" ? e : !0;
  return n;
}
function Gp(e, t, n) {
  switch (e) {
    case "$type":
      return [
        "filter-type-" + n,
        t
      ];
    case "$id":
      return [
        "filter-id-" + n,
        t
      ];
    default:
      return [
        "filter-" + n,
        e,
        t
      ];
  }
}
function C3(e) {
  return ["any"].concat(e.map(Qd));
}
function Mx(e, t) {
  if (t.length === 0)
    return !1;
  switch (e) {
    case "$type":
      return [
        "filter-type-in",
        [
          "literal",
          t
        ]
      ];
    case "$id":
      return [
        "filter-id-in",
        [
          "literal",
          t
        ]
      ];
    default:
      return t.length > 200 && !t.some(function(n) {
        return typeof n != typeof t[0];
      }) ? [
        "filter-in-large",
        e,
        [
          "literal",
          t.sort(E3)
        ]
      ] : [
        "filter-in-small",
        e,
        [
          "literal",
          t
        ]
      ];
  }
}
function _x(e) {
  switch (e) {
    case "$type":
      return !0;
    case "$id":
      return ["filter-has-id"];
    default:
      return [
        "filter-has",
        e
      ];
  }
}
function Rh(e) {
  return [
    "!",
    e
  ];
}
var x3 = [
  "type",
  "source",
  "source-layer",
  "minzoom",
  "maxzoom",
  "filter",
  "layout"
];
function b3(e, t) {
  var n = {};
  for (var s in e)
    s !== "ref" && (n[s] = e[s]);
  return x3.forEach(function(r) {
    r in t && (n[r] = t[r]);
  }), n;
}
function T3(e) {
  e = e.slice();
  for (var t = /* @__PURE__ */ Object.create(null), n = 0; n < e.length; n++)
    t[e[n].id] = e[n];
  for (var s = 0; s < e.length; s++)
    "ref" in e[s] && (e[s] = b3(e[s], t[e[s].ref]));
  return e;
}
var Ix = {
  thin: 100,
  hairline: 100,
  "ultra-light": 100,
  "extra-light": 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  "semi-bold": 600,
  "demi-bold": 600,
  bold: 700,
  heavy: 800,
  black: 800,
  "extra-bold": 800,
  "ultra-black": 900,
  "extra-black": 900,
  "ultra-bold": 900,
  "heavy-black": 900,
  fat: 900,
  poster: 900
}, ju = " ", Dx = /(italic|oblique)$/i, Ax = {}, Lx = function(e, t, n) {
  var s = Ax[e];
  if (!s) {
    Array.isArray(e) || (e = [e]);
    for (var r = 400, i = "normal", a = [], o, l, f = 0, d = e.length; f < d; ++f) {
      var u = e[f], c = u.split(" "), h = c[c.length - 1].toLowerCase();
      h == "normal" || h == "italic" || h == "oblique" ? (i = l ? i : h, c.pop(), h = c[c.length - 1].toLowerCase()) : Dx.test(h) && (h = h.replace(Dx, ""), i = l ? i : c[c.length - 1].replace(h, ""));
      for (var p in Ix) {
        var g = c.length > 1 ? c[c.length - 2].toLowerCase() : "";
        if (h == p || h == p.replace("-", "") || g + "-" + h == p) {
          r = o ? r : Ix[p], c.pop(), g && p.startsWith(g) && c.pop();
          break;
        }
      }
      !o && typeof h == "number" && (r = h);
      var m = c.join(ju).replace("Klokantech Noto Sans", "Noto Sans");
      m.indexOf(ju) !== -1 && (m = '"' + m + '"'), a.push(m);
    }
    s = Ax[e] = [
      i,
      r,
      a
    ];
  }
  return s[0] + ju + s[1] + ju + t + "px" + (n ? "/" + n : "") + ju + s[2];
};
function kp(e) {
  return e * Math.PI / 180;
}
var O3 = function() {
  for (var e = [], t = 78271.51696402048; e.length <= 24; t /= 2)
    e.push(t);
  return e;
}();
function sM(e, t) {
  if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas < "u")
    return new OffscreenCanvas(e, t);
  var n = document.createElement("canvas");
  return n.width = e, n.height = t, n;
}
function P3(e, t) {
  for (var n = 0, s = t.length; n < s; ++n) {
    var r = t[n];
    if (r < e && n + 1 < s) {
      var i = t[n] / t[n + 1];
      return n + Math.log(t[n] / e) / Math.log(i);
    }
  }
  return s - 1;
}
var S3 = Array(256).join("");
function mv(e, t) {
  if (t >= 0.05) {
    for (var n = "", s = e.split(`
`), r = S3.slice(0, Math.round(t / 0.1)), i = 0, a = s.length; i < a; ++i)
      i > 0 && (n += `
`), n += s[i].split("").join(r);
    return n;
  }
  return e;
}
var Hp;
function aM() {
  return Hp || (Hp = sM(1, 1).getContext("2d")), Hp;
}
function po(e, t) {
  return aM().measureText(e).width + (e.length - 1) * t;
}
var Rx = {};
function gv(e, t, n, s) {
  if (e.indexOf(`
`) !== -1) {
    for (var r = e.split(`
`), i = [], a = 0, o = r.length; a < o; ++a)
      i.push(gv(r[a], t, n, s));
    return i.join(`
`);
  }
  var l = n + "," + t + "," + e + "," + s, f = Rx[l];
  if (!f) {
    var d = e.split(" ");
    if (d.length > 1) {
      var u = aM();
      u.font = t;
      for (var c = u.measureText("M").width, h = c * n, p = "", g = [], m = 0, v = d.length; m < v; ++m) {
        var y = d[m], E = p + (p ? " " : "") + y;
        po(E, s) <= h ? p = E : (p && g.push(p), p = y);
      }
      p && g.push(p);
      for (var C = 0, x = g.length; C < x && x > 1; ++C) {
        var b = g[C];
        if (po(b, s) < h * 0.35) {
          var P = C > 0 ? po(g[C - 1], s) : 1 / 0, O = C < x - 1 ? po(g[C + 1], s) : 1 / 0;
          g.splice(C, 1), x -= 1, P < O ? (g[C - 1] += " " + b, C -= 1) : g[C] = b + " " + g[C];
        }
      }
      for (var T = 0, M = g.length - 1; T < M; ++T) {
        var L = g[T], A = g[T + 1];
        if (po(L, s) > h * 0.7 && po(A, s) < h * 0.6) {
          var D = L.split(" "), I = D.pop();
          po(I, s) < h * 0.2 && (g[T] = D.join(" "), g[T + 1] = I + " " + A), M -= 1;
        }
      }
      f = g.join(`
`);
    } else
      f = e;
    f = mv(f, s), Rx[l] = f;
  }
  return f;
}
var M3 = {
  Point: 1,
  MultiPoint: 1,
  LineString: 2,
  MultiLineString: 2,
  Polygon: 3,
  MultiPolygon: 3
}, _3 = {
  center: [
    0.5,
    0.5
  ],
  left: [
    0,
    0.5
  ],
  right: [
    1,
    0.5
  ],
  top: [
    0.5,
    0
  ],
  bottom: [
    0.5,
    1
  ],
  "top-left": [
    0,
    0
  ],
  "top-right": [
    1,
    0
  ],
  "bottom-left": [
    0,
    1
  ],
  "bottom-right": [
    1,
    1
  ]
}, I3 = function(e, t) {
  var n = c3(e, t);
  if (n.result === "error")
    throw new Error(n.value.map(function(s) {
      return s.key + ": " + s.message;
    }).join(", "));
  return n.value;
}, vv = {}, qd = { zoom: 0 }, wh, Yp;
function Qt(e, t, n, s, r, i, a) {
  var o = e.id;
  i || (i = {}, console.warn("No functionCache provided to getValue()")), i[o] || (i[o] = {});
  var l = i[o];
  if (!l[n]) {
    var f = (e[t] || vv)[n], d = tM[t + "_" + e.type][n];
    f === void 0 && (f = d.default);
    var u = u3(f);
    if (!u && qS(f) && (f = aW(f, d), u = !0), u) {
      var c = I3(f, d);
      l[n] = c.evaluate.bind(c);
    } else
      d.type == "color" && (f = Re.parse(f)), l[n] = function() {
        return f;
      };
  }
  return qd.zoom = s, l[n](qd, r, a);
}
function D3(e, t, n, s) {
  var r = Qt(e, "layout", "icon-allow-overlap", t, n, s);
  if (!r)
    return "declutter";
  var i = Qt(e, "layout", "icon-ignore-placement", t, n, s);
  return i ? "none" : "obstacle";
}
function A3(e, t, n, s, r) {
  return r || console.warn("No filterCache provided to evaluateFilter()"), e in r || (r[e] = p3(t).filter), qd.zoom = s, r[e](qd, n);
}
function mo(e, t) {
  if (e) {
    if (e.a === 0 || t === 0)
      return;
    var n = e.a;
    return t = t === void 0 ? 1 : t, n === 0 ? "transparent" : "rgba(" + Math.round(e.r * 255 / n) + "," + Math.round(e.g * 255 / n) + "," + Math.round(e.b * 255 / n) + "," + n * t + ")";
  }
  return e;
}
var L3 = /\{[^{}}]*\}/g;
function Xp(e, t) {
  return e.replace(L3, function(n) {
    return t[n.slice(1, -1)] || "";
  });
}
function R3(e, t, n, s, r, i, a) {
  if (s === void 0 && (s = O3), r === void 0 && (r = void 0), i === void 0 && (i = void 0), a === void 0 && (a = void 0), typeof t == "string" && (t = JSON.parse(t)), t.version != 8)
    throw new Error("glStyle version 8 required.");
  var o, l;
  if (i) {
    if (typeof Image < "u") {
      var f = new Image();
      f.crossOrigin = "anonymous", f.onload = function() {
        o = f, l = [
          f.width,
          f.height
        ], e.changed(), f.onload = null;
      }, f.src = i;
    } else if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope) {
      var d = self;
      d.postMessage({
        action: "loadImage",
        src: i
      }), d.addEventListener("message", function(B) {
        B.data.action === "imageLoaded" && B.data.src === i && (o = B.data.image, l = [
          o.width,
          o.height
        ]);
      });
    }
  }
  for (var u = T3(t.layers), c = {}, h = [], p = {}, g = {}, m = {}, v = {}, y, E = 0, C = u.length; E < C; ++E) {
    var x = u[E], b = x.id;
    if (typeof n == "string" && x.source == n || n.indexOf(b) !== -1) {
      var P = x["source-layer"];
      if (y) {
        if (x.source !== y)
          throw new Error('Layer "' + b + '" does not use source "' + y);
      } else {
        y = x.source;
        var O = t.sources[y];
        if (!O)
          throw new Error('Source "' + y + '" is not defined');
        var T = O.type;
        if (T !== "vector" && T !== "geojson")
          throw new Error('Source "' + y + '" is not of type "vector" or "geojson", but "' + T + '"');
      }
      var M = c[P];
      M || (M = [], c[P] = M), M.push({
        layer: x,
        index: E
      }), h.push(b);
    }
  }
  var L = new vr(), A = new wr(), D = [], I = function(w, B) {
    var j = w.getProperties(), k = c[j.layer];
    if (k) {
      var X = s.indexOf(B);
      X == -1 && (X = P3(B, s));
      for (var rt = M3[w.getGeometry().getType()], et = {
        properties: j,
        type: rt
      }, Z = e.get("mapbox-featurestate")[w.getId()], dt = -1, vt = 0, bt = k.length; vt < bt; ++vt) {
        var it = k[vt], R = it.layer, V = R.id, tt = R.layout || vv, Y = R.paint || vv;
        if (!(tt.visibility === "none" || "minzoom" in R && X < R.minzoom || "maxzoom" in R && X >= R.maxzoom)) {
          var W = R.filter;
          if (!W || A3(V, W, et, X, v)) {
            var z = void 0, at = void 0, ct = void 0, Mt = void 0, N = void 0, S = void 0, _ = it.index;
            if (rt == 3 && (R.type == "fill" || R.type == "fill-extrusion"))
              if (at = Qt(R, "paint", R.type + "-opacity", X, et, m, Z), R.type + "-pattern" in Y) {
                var F = Qt(R, "paint", R.type + "-pattern", X, et, m, Z);
                if (F) {
                  var G = typeof F == "string" ? Xp(F, j) : F.toString();
                  if (o && r && r[G]) {
                    ++dt, S = D[dt], (!S || !S.getFill() || S.getStroke() || S.getText()) && (S = new Mn({ fill: new wr() }), D[dt] = S), ct = S.getFill(), S.setZIndex(_);
                    var nt = G + "." + at, lt = g[nt];
                    if (!lt) {
                      var yt = r[G], Lt = sM(yt.width, yt.height), Ft = Lt.getContext("2d");
                      Ft.globalAlpha = at, Ft.drawImage(o, yt.x, yt.y, yt.width, yt.height, 0, 0, yt.width, yt.height), lt = Ft.createPattern(Lt, "repeat"), g[nt] = lt;
                    }
                    ct.setColor(lt);
                  }
                }
              } else
                z = mo(Qt(R, "paint", R.type + "-color", X, et, m, Z), at), R.type + "-outline-color" in Y && (N = mo(Qt(R, "paint", R.type + "-outline-color", X, et, m, Z), at)), N || (N = z), (z || N) && (++dt, S = D[dt], (!S || z && !S.getFill() || !z && S.getFill() || N && !S.getStroke() || !N && S.getStroke() || S.getText()) && (S = new Mn({
                  fill: z ? new wr() : void 0,
                  stroke: N ? new vr() : void 0
                }), D[dt] = S), z && (ct = S.getFill(), ct.setColor(z)), N && (Mt = S.getStroke(), Mt.setColor(N), Mt.setWidth(0.5)), S.setZIndex(_));
            if (rt != 1 && R.type == "line") {
              z = !("line-pattern" in Y) && "line-color" in Y ? mo(Qt(R, "paint", "line-color", X, et, m, Z), Qt(R, "paint", "line-opacity", X, et, m, Z)) : void 0;
              var Jt = Qt(R, "paint", "line-width", X, et, m, Z);
              z && Jt > 0 && (++dt, S = D[dt], (!S || !S.getStroke() || S.getFill() || S.getText()) && (S = new Mn({ stroke: new vr() }), D[dt] = S), Mt = S.getStroke(), Mt.setLineCap(Qt(R, "layout", "line-cap", X, et, m, Z)), Mt.setLineJoin(Qt(R, "layout", "line-join", X, et, m, Z)), Mt.setMiterLimit(Qt(R, "layout", "line-miter-limit", X, et, m, Z)), Mt.setColor(z), Mt.setWidth(Jt), Mt.setLineDash(Y["line-dasharray"] ? Qt(R, "paint", "line-dasharray", X, et, m, Z).map(function(_e) {
                return _e * Jt;
              }) : null), S.setZIndex(_));
            }
            var J = !1, ft = null, Ct = 0, St = void 0, Tt = void 0, kt = void 0;
            if ((rt == 1 || rt == 2) && "icon-image" in tt) {
              var fe = Qt(R, "layout", "icon-image", X, et, m, Z);
              if (fe) {
                St = typeof fe == "string" ? Xp(fe, j) : fe.toString();
                var Se = void 0;
                if (o && r && r[St]) {
                  var Me = Qt(R, "layout", "icon-rotation-alignment", X, et, m, Z);
                  if (rt == 2) {
                    var xe = w.getGeometry();
                    if (xe.getFlatMidpoint || xe.getFlatMidpoints) {
                      var We = xe.getExtent(), bn = Math.sqrt(Math.max(Math.pow((We[2] - We[0]) / B, 2), Math.pow((We[3] - We[1]) / B, 2)));
                      if (bn > 150) {
                        var Ye = xe.getType() === "MultiLineString" ? xe.getFlatMidpoints() : xe.getFlatMidpoint();
                        Yp || (wh = [
                          NaN,
                          NaN
                        ], Yp = new Tc("Point", wh, [], {}, null)), Se = Yp, wh[0] = Ye[0], wh[1] = Ye[1];
                        var Hn = Qt(R, "layout", "symbol-placement", X, et, m, Z);
                        if (Hn === "line" && Me === "map")
                          for (var pn = xe.getStride(), Ne = xe.getFlatCoordinates(), mn = 0, gn = Ne.length - pn; mn < gn; mn += pn) {
                            var we = Ne[mn], vn = Ne[mn + 1], ze = Ne[mn + pn], Tn = Ne[mn + pn + 1], tn = Math.min(we, ze), ae = Math.min(vn, Tn), gi = Math.max(we, ze), Xe = Math.max(vn, Tn);
                            if (Ye[0] >= tn && Ye[0] <= gi && Ye[1] >= ae && Ye[1] <= Xe) {
                              Ct = Math.atan2(vn - Tn, ze - we);
                              break;
                            }
                          }
                      }
                    }
                  }
                  if (rt !== 2 || Se) {
                    var an = Qt(R, "layout", "icon-size", X, et, m, Z), $e = Y["icon-color"] !== void 0 ? Qt(R, "paint", "icon-color", X, et, m, Z) : null;
                    if (!$e || $e.a !== 0) {
                      var Vn = St + "." + an;
                      if ($e !== null && (Vn += "." + $e), Tt = p[Vn], !Tt) {
                        var ii = r[St], da = D3(R, X, et, m), Os = void 0;
                        "icon-offset" in tt && (Os = Qt(R, "layout", "icon-offset", X, et, m, Z), Os[1] *= -1), Tt = new vs({
                          color: $e ? [
                            $e.r * 255,
                            $e.g * 255,
                            $e.b * 255,
                            $e.a
                          ] : void 0,
                          img: o,
                          imgSize: l,
                          size: [
                            ii.width,
                            ii.height
                          ],
                          offset: [
                            ii.x,
                            ii.y
                          ],
                          rotateWithView: Me === "map",
                          scale: an / ii.pixelRatio,
                          displacement: Os,
                          declutterMode: da
                        }), p[Vn] = Tt;
                      }
                    }
                    Tt && (++dt, S = D[dt], (!S || !S.getImage() || S.getFill() || S.getStroke()) && (S = new Mn(), D[dt] = S), S.setGeometry(Se), Tt.setRotation(Ct + kp(Qt(R, "layout", "icon-rotate", X, et, m, Z))), Tt.setOpacity(Qt(R, "paint", "icon-opacity", X, et, m, Z)), Tt.setAnchor(_3[Qt(R, "layout", "icon-anchor", X, et, m, Z)]), S.setImage(Tt), ft = S.getText(), S.setText(void 0), S.setZIndex(_), J = !0, kt = !1);
                  } else
                    kt = !0;
                }
              }
            }
            if (rt == 1 && R.type === "circle") {
              ++dt, S = D[dt], (!S || !S.getImage() || S.getFill() || S.getStroke()) && (S = new Mn(), D[dt] = S);
              var Ps = "circle-radius" in Y ? Qt(R, "paint", "circle-radius", X, et, m, Z) : 5, Hr = mo(Qt(R, "paint", "circle-stroke-color", X, et, m, Z), Qt(R, "paint", "circle-stroke-opacity", X, et, m, Z)), Fn = mo(Qt(R, "paint", "circle-color", X, et, m, Z), Qt(R, "paint", "circle-opacity", X, et, m, Z)), vi = Qt(R, "paint", "circle-stroke-width", X, et, m, Z), Yr = Ps + "." + Hr + "." + Fn + "." + vi;
              Tt = p[Yr], Tt || (Tt = new Ff({
                radius: Ps,
                stroke: Hr && vi > 0 ? new vr({
                  width: vi,
                  color: Hr
                }) : void 0,
                fill: Fn ? new wr({ color: Fn }) : void 0,
                declutterMode: "none"
              }), p[Yr] = Tt), S.setImage(Tt), ft = S.getText(), S.setText(void 0), S.setGeometry(void 0), S.setZIndex(_), J = !0;
            }
            var Ve = void 0, yi = void 0, Ei = void 0, Ze = void 0, Yi = void 0, Pr = void 0;
            if ("text-field" in tt) {
              Ze = Math.round(Qt(R, "layout", "text-size", X, et, m, Z));
              var Ss = Qt(R, "layout", "text-font", X, et, m, Z);
              Ei = Qt(R, "layout", "text-line-height", X, et, m, Z), yi = Lx(a ? a(Ss) : Ss, Ze, Ei), yi.includes("sans-serif") || (yi += ",sans-serif"), Yi = Qt(R, "layout", "text-letter-spacing", X, et, m, Z), Pr = Qt(R, "layout", "text-max-width", X, et, m, Z);
              var Nn = Qt(R, "layout", "text-field", X, et, m, Z);
              typeof Nn == "object" && Nn.sections ? Nn.sections.length === 1 ? Ve = Nn.toString() : Ve = Nn.sections.reduce(function(_e, Zn, Ms) {
                var Qr = Zn.fontStack ? Zn.fontStack.split(",") : Ss, qr = Lx(a ? a(Qr) : Qr, Ze * (Zn.scale || 1), Ei), Zi = Zn.text;
                if (Zi === `
`)
                  return _e.push(`
`, ""), _e;
                if (rt == 2) {
                  _e.push(mv(Zi, Yi), qr);
                  return;
                }
                Zi = gv(Zi, qr, Pr, Yi).split(`
`);
                for (var ts = 0, $ = Zi.length; ts < $; ++ts)
                  ts > 0 && _e.push(`
`, ""), _e.push(Zi[ts], qr);
                return _e;
              }, []) : Ve = Xp(Nn, j).trim(), at = Qt(R, "paint", "text-opacity", X, et, m, Z);
            }
            if (Ve && at && !kt) {
              J || (++dt, S = D[dt], (!S || !S.getText() || S.getFill() || S.getStroke()) && (S = new Mn(), D[dt] = S), S.setImage(void 0), S.setGeometry(void 0)), S.getText() || S.setText(ft || new F1({
                padding: [
                  2,
                  2,
                  2,
                  2
                ]
              })), ft = S.getText();
              var On = tt["text-transform"];
              On == "uppercase" ? Ve = Array.isArray(Ve) ? Ve.map(function(_e, Zn) {
                return Zn % 2 ? _e : _e.toUpperCase();
              }) : Ve.toUpperCase() : On == "lowercase" && (Ve = Array.isArray(Ve) ? Ve.map(function(_e, Zn) {
                return Zn % 2 ? _e : _e.toLowerCase();
              }) : Ve.toLowerCase());
              var ri = Array.isArray(Ve) ? Ve : rt == 2 ? mv(Ve, Yi) : gv(Ve, yi, Pr, Yi);
              ft.setText(ri), ft.setFont(yi), ft.setRotation(kp(Qt(R, "layout", "text-rotate", X, et, m, Z)));
              var An = Qt(R, "layout", "text-anchor", X, et, m, Z), jn = J || rt == 1 ? "point" : Qt(R, "layout", "symbol-placement", X, et, m, Z);
              ft.setPlacement(jn), ft.setOverflow(jn === "point");
              var Je = Qt(R, "paint", "text-halo-width", X, et, m, Z), Yn = Qt(R, "layout", "text-offset", X, et, m, Z), si = Qt(R, "paint", "text-translate", X, et, m, Z), Sr = 0, Xr = 0;
              if (jn == "point") {
                var lr = "center";
                An.indexOf("left") !== -1 ? (lr = "left", Xr = Je) : An.indexOf("right") !== -1 && (lr = "right", Xr = -Je), ft.setTextAlign(lr);
                var Xn = Qt(R, "layout", "text-rotation-alignment", X, et, m, Z);
                ft.setRotateWithView(Xn == "map");
              } else
                ft.setMaxAngle(kp(Qt(R, "layout", "text-max-angle", X, et, m, Z)) * Ve.length / ri.length), ft.setTextAlign(), ft.setRotateWithView(!1);
              var Ci = "middle";
              An.indexOf("bottom") == 0 ? (Ci = "bottom", Sr = -Je - 0.5 * (Ei - 1) * Ze) : An.indexOf("top") == 0 && (Ci = "top", Sr = Je + 0.5 * (Ei - 1) * Ze), ft.setTextBaseline(Ci);
              var Zr = Qt(R, "layout", "text-justify", X, et, m, Z);
              ft.setJustify(Zr === "auto" ? void 0 : Zr), ft.setOffsetX(Yn[0] * Ze + Xr + si[0]), ft.setOffsetY(Yn[1] * Ze + Sr + si[1]), A.setColor(mo(Qt(R, "paint", "text-color", X, et, m, Z), at)), ft.setFill(A);
              var Jr = mo(Qt(R, "paint", "text-halo-color", X, et, m, Z), at);
              if (Jr) {
                L.setColor(Jr), Je *= 2;
                var Mr = 0.5 * Ze;
                L.setWidth(Je <= Mr ? Je : Mr), ft.setStroke(L);
              } else
                ft.setStroke(void 0);
              var Xi = Qt(R, "layout", "text-padding", X, et, m, Z), Li = ft.getPadding();
              Xi !== Li[0] && (Li[0] = Xi, Li[1] = Xi, Li[2] = Xi, Li[3] = Xi), S.setZIndex(_);
            }
          }
        }
      }
      if (dt > -1)
        return D.length = dt + 1, D;
    }
  };
  return e.setStyle(I), e.set("mapbox-source", y), e.set("mapbox-layers", h), e.set("mapbox-featurestate", {}), I;
}
new Wr();
const w3 = "EPSG:3857";
function oM(e = {}) {
  const t = e.epsg ? e.epsg : fi.epsg, n = e.extent ? e.extent : Wf(t), s = e.tileSize ? e.tileSize : 512, r = e.resolutions ? e.resolutions : fi.options.map((a) => a.resolution), i = {
    extent: n,
    resolutions: r,
    minZoom: e.minZoom,
    tileSize: new Array(2).fill(s)
  };
  return e.origins ? i.origins = e.origins : i.origin = e.origin ? e.origin : [i.extent[0], i.extent[3]], new mu(i);
}
function V3(e = {}) {
  const t = [e.extent, e.tileSize, e.resolutions, e.origin, e.origins, e.minZoom], n = e.epsg ? e.epsg.toUpperCase() : e.epsg;
  return !t.every((s) => typeof s > "u") || n !== w3;
}
function lM(e, t = {}) {
  t.epsg = t.epsg ? t.epsg : fi.epsg;
  const n = {
    projection: t.epsg,
    format: new ES(),
    url: e,
    tileSize: t.tileSize,
    zDirection: t.zDirection,
    minZoom: t.minZoom,
    maxZoom: t.maxZoom
  };
  return V3(t) && (n.tileGrid = oM(t)), new NS(n);
}
function B3(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  if ([e.id, e.name, e.url].some((i) => typeof i > "u")) {
    console.error(`Cancelled creation of layer "${e.id}"(${e.name}) because of missing required parameters`);
    return;
  }
  const s = lM(e.url, e), r = new O0(Object.assign({
    id: e.id,
    name: e.name,
    attribution: e.olAttribution,
    extent: s.getTileGrid().getExtent(),
    minZoom: e.minZoom,
    maxZoom: e.maxZoom,
    source: s,
    declutter: !0
  }, t));
  return n.style && r.setStyle(n.style), r;
}
function F3(e, t, { options: n = {} } = {}) {
  R3(
    e,
    t,
    n.sourceId ? n.sourceId : Object.keys(t.sources)[0],
    n.resolutions,
    n.spriteData,
    n.spriteImageUrl,
    n.getFonts
  );
}
const uM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: B3,
  createLayerSource: lM,
  createTileGrid: oM,
  setStyle: F3
}, Symbol.toStringTag, { value: "Module" }));
function N3(e) {
  if (!e || typeof e != "object" || e.constructor !== Object || !Object.keys(e).length)
    return "";
  let t = "";
  return Object.entries(e).forEach(([n, s]) => {
    t += "&" + n + "=" + s;
  }), t;
}
function j3(e, t, n, s) {
  return e.ok ? e : t(`Request to wfs-filter failed. Response status is ${e.statusText}`, n, s);
}
function $3(e) {
  if (typeof e != "object" || e === null || !Array.isArray(e.links))
    return !1;
  for (let t = 0; t < e.links.length; t++)
    if (typeof e.links[t] == "object" && e.links[t] !== null && typeof e.links[t].href == "string" && e.links[t].rel === "next" && e.links[t].type === "application/geo+json")
      return e.links[t].href;
  return !1;
}
function cM(e, t, { onErrorFn: n, success: s, failure: r }, i, a = []) {
  fetch(e, {
    headers: {
      Accept: "application/geo+json"
    },
    method: "GET"
  }).then((l) => j3(l, n, i, r)).then((l) => l.json()).then((l) => {
    const f = $3(l);
    if (l.features.forEach((d) => a.push(d)), typeof f == "string") {
      cM(f, t, { onErrorFn: rc, success: s, failure: r }, i, a);
      return;
    }
    l.features = a, l.numberReturned = l.numberMatched, b0(t, t.getFormat().readFeatures(l), n, s, r, i);
  }).catch((l) => {
    n(l, i, r);
  });
}
function U3(e, t, n) {
  const s = new Wr();
  let r = null;
  function i(a, o, l, f, d) {
    cM(n, r, { onErrorFn: rc, success: f, failure: d }, t);
  }
  return r = C0(i, t.loadingStrategy, s), t.beforeLoading && r.once("featuresloadstart", () => t.beforeLoading()), e.clusterDistance ? x0(r, e.clusterDistance, t.clusterGeometryFunction) : r;
}
function W3(e) {
  let t = e.url, n;
  const s = "";
  return t += typeof e.collection == "string" ? "/collections/" + e.collection + "/items?" : "", t += typeof e.limit == "number" ? "limit=" + e.limit + "&" : "", Array.isArray(e.bbox) && e.bbox.length === 4 && (n = "", e.bbox.forEach((r, i) => {
    n += i !== e.bbox.length - 1 ? r + "," : r;
  }), t += "bbox=" + n + "&"), t += typeof e.bboxCrs == "string" && e.bboxCrs !== "" ? "bbox-crs=" + encodeURIComponent(e.bboxCrs) + "&" : "", e.crs !== !1 && (t += "crs=" + encodeURIComponent(typeof e.crs == "string" && e.crs !== "" ? e.crs : s) + "&"), t += typeof e.datetime == "string" && e.datetime !== "" ? "datetime=" + e.datetime + "&" : "", t += N3(e.params), t;
}
function hM(e, t = {}) {
  t.loadingStrategy || (t.loadingStrategy = Kg);
  const n = W3(e);
  return U3(e, t, n);
}
function z3(e = {}, { layerParams: t = {}, options: n = {} } = {}) {
  const s = hM(e, n), r = new sr(Object.assign({
    source: s,
    id: e.id
  }, t));
  return n.style ? r.setStyle(n.style) : e.style && r.setStyle(e.style), r;
}
const dM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: z3,
  createLayerSource: hM
}, Symbol.toStringTag, { value: "Module" }));
function K3(e) {
  const t = {};
  return e.cesiumTerrainProviderOptions && Object.assign(t, e.cesiumTerrainProviderOptions), t.url = e.url, new Cesium.CesiumTerrainProvider(t);
}
function G3(e, t, n) {
  n && typeof n.getCesiumScene == "function" && (e ? n.getCesiumScene().terrainProvider = K3(t) : n.getCesiumScene().terrainProvider = new Cesium.EllipsoidTerrainProvider({}));
}
function k3(e) {
  return this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, this;
}
function H3(e) {
  if (this.values)
    return this.values[e];
}
const Y3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayer: k3,
  get: H3,
  setVisible: G3
}, Symbol.toStringTag, { value: "Module" }));
function X3(e, t, n) {
  if (n && typeof n.getDataSources == "function") {
    const s = n.getDataSources(), r = s.getByName(t == null ? void 0 : t.id);
    r.length === 0 ? console.warn("Cannot change visibility of 3D entity for layer with id ", t.id, ". Datasource is not available.") : r[0].show = typeof e == "boolean" ? e : !1;
  }
}
function Z3(e, t, n) {
  if (typeof e.url != "string")
    return console.warn("Url of entity must be a string, but is:", e.url), null;
  if (![e.longitude, e.latitude, e.height].every((p) => typeof p == "number"))
    return console.warn("longitude, latitude and height of entity must be a number."), null;
  const s = Cesium.Cartesian3.fromDegrees(e.longitude, e.latitude, e.height), r = typeof e.allowPicking == "boolean" ? e.allowPicking : !0, i = e.attributes ? e.attributes : {};
  let a = "", o = "", l = "", f = null, d = "", u = 0, c = 0, h = 0;
  return typeof e.heading == "number" && (u = e.heading / 180 * Math.PI), typeof e.pitch == "number" && (c = e.pitch / 180 * Math.PI), typeof e.roll == "number" && (h = e.roll / 180 * Math.PI), a = new Cesium.HeadingPitchRoll(u, c, h), o = Cesium.Transforms.headingPitchRollQuaternion(s, a), l = Object.assign(e.modelOptions || {}, {
    uri: e.url,
    scale: typeof e.scale == "number" ? e.scale : 1,
    show: typeof e.show == "boolean" ? e.show : !1
  }), f = {
    name: e.url,
    position: s,
    orientation: o,
    show: typeof e.show == "boolean" ? e.show : !1,
    model: l
  }, d = t.entities.add(f), d.attributes = i, d.allowPicking = r, d.layerReferenceId = n.id, d;
}
function wx(e, t) {
  e.entities && e.entities.forEach((n) => {
    Z3(n, Array.isArray(t) ? t[0] : t, e);
  });
}
function fM(e, t, n) {
  if (!e)
    console.warn("Cannot add entities to rawLayer which is null!");
  else if (t && typeof t.getDataSources == "function") {
    const s = t.getDataSources();
    let r = s.getByName(e.id);
    if (r.length === 0)
      r = new Cesium.CustomDataSource(e.id), s.add(r).then(function(i) {
        return wx(e, i), n ? n() : null;
      });
    else if (wx(e, r), n)
      return n();
  }
  return null;
}
function J3(e, t) {
  return fM(e, t), this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, this;
}
function Q3(e) {
  if (this.values)
    return this.values[e];
}
const q3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDataSource: fM,
  createLayer: J3,
  get: Q3,
  setVisible: X3
}, Symbol.toStringTag, { value: "Module" }));
function t5(e) {
  const t = e.url.split("?")[0] + "/tileset.json", n = {};
  return e.cesium3DTilesetOptions && Object.assign(n, e.cesium3DTilesetOptions), n.url = t, new Cesium.Cesium3DTileset(n);
}
function B0(e) {
  this.values = {
    name: e.name,
    id: e.id,
    typ: e.typ
  }, Cesium && (this.tileset = t5(e), this.tileset.layerReferenceId = e.id);
}
B0.prototype.setVisible = function(e, t) {
  t && typeof t.getCesiumScene == "function" && (e ? (t.getCesiumScene().primitives.contains(this.tileset) || t.getCesiumScene().primitives.add(this.tileset), this.tileset.show = !0) : this.tileset.show = !1);
};
B0.prototype.get = function(e) {
  if (this.values)
    return this.values[e];
};
function e5(e, { resolution: t, map: n }) {
  const s = typeof t > "u" ? n.getView().getResolution() : t;
  return e.getMaxResolution() >= s && s >= e.getMinResolution();
}
function n5({ legendURL: e, layers: t = "", url: n, typ: s, format: r, version: i }) {
  return e ? e === "ignore" ? [] : [e] : t.split(",").filter(
    (a) => a
    /* filters empty string since it's falsy */
  ).map((a) => `${n}?SERVICE=${s}&REQUEST=GetLegendGraphic&FORMAT=${r || "image/png"}&VERSION=${i}&LAYER=${a}`);
}
const i5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getLegendURLs: n5,
  isLayerVisibleInResolution: e5
}, Symbol.toStringTag, { value: "Module" }));
function r5(e) {
  const t = e.map(parseFloat), n = [];
  for (; t.length; )
    n.push(t.splice(0, 2));
  return n;
}
function s5(e, t, n = {}) {
  e.getView().fit(t, n);
}
function a5(e, t, n = {}) {
  let s;
  switch (t.geometry.type) {
    case "Polygon":
      s = new rr([r5(t.geometry.coordinates)]);
      break;
    case "Point":
      s = new hi(t.geometry.coordinates.map(parseFloat));
      break;
    default:
      console.warn(`ZoomTo for type ${t.geometry.type} not implemented.`);
      return;
  }
  s5(e, s, n);
}
var os = {}, Zp = {}, Vx;
function F0() {
  return Vx || (Vx = 1, (function() {
    Zp.defaults = {
      "0.1": {
        explicitCharkey: !1,
        trim: !0,
        normalize: !0,
        normalizeTags: !1,
        attrkey: "@",
        charkey: "#",
        explicitArray: !1,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !1,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        childkey: "@@",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: ""
      },
      "0.2": {
        explicitCharkey: !1,
        trim: !1,
        normalize: !1,
        normalizeTags: !1,
        attrkey: "$",
        charkey: "_",
        explicitArray: !0,
        ignoreAttrs: !1,
        mergeAttrs: !1,
        explicitRoot: !0,
        validator: null,
        xmlns: !1,
        explicitChildren: !1,
        preserveChildrenOrder: !1,
        childkey: "$$",
        charsAsChildren: !1,
        includeWhiteChars: !1,
        async: !1,
        strict: !0,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: "root",
        xmldec: {
          version: "1.0",
          encoding: "UTF-8",
          standalone: !0
        },
        doctype: null,
        renderOpts: {
          pretty: !0,
          indent: "  ",
          newline: `
`
        },
        headless: !1,
        chunkSize: 1e4,
        emptyTag: "",
        cdata: !1
      }
    };
  }).call(It)), Zp;
}
var Jp = {}, ws = {}, Vs = {}, Bx;
function ca() {
  return Bx || (Bx = 1, (function() {
    var e, t, n, s, r, i, a, o = [].slice, l = {}.hasOwnProperty;
    e = function() {
      var f, d, u, c, h, p;
      if (p = arguments[0], h = 2 <= arguments.length ? o.call(arguments, 1) : [], r(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (f = 0, u = h.length; f < u; f++)
          if (c = h[f], c != null)
            for (d in c)
              l.call(c, d) && (p[d] = c[d]);
      return p;
    }, r = function(f) {
      return !!f && Object.prototype.toString.call(f) === "[object Function]";
    }, i = function(f) {
      var d;
      return !!f && ((d = typeof f) == "function" || d === "object");
    }, n = function(f) {
      return r(Array.isArray) ? Array.isArray(f) : Object.prototype.toString.call(f) === "[object Array]";
    }, s = function(f) {
      var d;
      if (n(f))
        return !f.length;
      for (d in f)
        if (l.call(f, d))
          return !1;
      return !0;
    }, a = function(f) {
      var d, u;
      return i(f) && (u = Object.getPrototypeOf(f)) && (d = u.constructor) && typeof d == "function" && d instanceof d && Function.prototype.toString.call(d) === Function.prototype.toString.call(Object);
    }, t = function(f) {
      return r(f.valueOf) ? f.valueOf() : f;
    }, Vs.assign = e, Vs.isFunction = r, Vs.isObject = i, Vs.isArray = n, Vs.isEmpty = s, Vs.isPlainObject = a, Vs.getValue = t;
  }).call(It)), Vs;
}
var Qp = { exports: {} }, Fx;
function pM() {
  return Fx || (Fx = 1, (function() {
    Qp.exports = function() {
      function e() {
      }
      return e.prototype.hasFeature = function(t, n) {
        return !0;
      }, e.prototype.createDocumentType = function(t, n, s) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.createDocument = function(t, n, s) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.createHTMLDocument = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.getFeature = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e;
    }();
  }).call(It)), Qp.exports;
}
var qp = { exports: {} }, tm = { exports: {} }, em = { exports: {} }, Nx;
function o5() {
  return Nx || (Nx = 1, (function() {
    em.exports = function() {
      function e() {
      }
      return e.prototype.handleError = function(t) {
        throw new Error(t);
      }, e;
    }();
  }).call(It)), em.exports;
}
var nm = { exports: {} }, jx;
function l5() {
  return jx || (jx = 1, (function() {
    nm.exports = function() {
      function e(t) {
        this.arr = t || [];
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return this.arr.length;
        }
      }), e.prototype.item = function(t) {
        return this.arr[t] || null;
      }, e.prototype.contains = function(t) {
        return this.arr.indexOf(t) !== -1;
      }, e;
    }();
  }).call(It)), nm.exports;
}
var $x;
function u5() {
  return $x || ($x = 1, (function() {
    var e, t;
    e = o5(), t = l5(), tm.exports = function() {
      function n() {
        this.defaultParams = {
          "canonical-form": !1,
          "cdata-sections": !1,
          comments: !1,
          "datatype-normalization": !1,
          "element-content-whitespace": !0,
          entities: !0,
          "error-handler": new e(),
          infoset: !0,
          "validate-if-schema": !1,
          namespaces: !0,
          "namespace-declarations": !0,
          "normalize-characters": !1,
          "schema-location": "",
          "schema-type": "",
          "split-cdata-sections": !0,
          validate: !1,
          "well-formed": !0
        }, this.params = Object.create(this.defaultParams);
      }
      return Object.defineProperty(n.prototype, "parameterNames", {
        get: function() {
          return new t(Object.keys(this.defaultParams));
        }
      }), n.prototype.getParameter = function(s) {
        return this.params.hasOwnProperty(s) ? this.params[s] : null;
      }, n.prototype.canSetParameter = function(s, r) {
        return !0;
      }, n.prototype.setParameter = function(s, r) {
        return r != null ? this.params[s] = r : delete this.params[s];
      }, n;
    }();
  }).call(It)), tm.exports;
}
var im = { exports: {} }, rm = { exports: {} }, sm = { exports: {} }, Ux;
function wn() {
  return Ux || (Ux = 1, (function() {
    sm.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205
    };
  }).call(It)), sm.exports;
}
var am = { exports: {} }, Wx;
function mM() {
  return Wx || (Wx = 1, (function() {
    var e;
    e = wn(), br(), am.exports = function() {
      function t(n, s, r) {
        if (this.parent = n, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), s == null)
          throw new Error("Missing attribute name. " + this.debugInfo(s));
        this.name = this.stringify.name(s), this.value = this.stringify.attValue(r), this.type = e.Attribute, this.isId = !1, this.schemaTypeInfo = null;
      }
      return Object.defineProperty(t.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(t.prototype, "ownerElement", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(t.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(n) {
          return this.value = n || "";
        }
      }), Object.defineProperty(t.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(t.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(t.prototype, "specified", {
        get: function() {
          return !0;
        }
      }), t.prototype.clone = function() {
        return Object.create(this);
      }, t.prototype.toString = function(n) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(n));
      }, t.prototype.debugInfo = function(n) {
        return n = n || this.name, n == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + n + "}, parent: <" + this.parent.name + ">";
      }, t.prototype.isEqualNode = function(n) {
        return !(n.namespaceURI !== this.namespaceURI || n.prefix !== this.prefix || n.localName !== this.localName || n.value !== this.value);
      }, t;
    }();
  }).call(It)), am.exports;
}
var om = { exports: {} }, zx;
function N0() {
  return zx || (zx = 1, (function() {
    om.exports = function() {
      function e(t) {
        this.nodes = t;
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return Object.keys(this.nodes).length || 0;
        }
      }), e.prototype.clone = function() {
        return this.nodes = null;
      }, e.prototype.getNamedItem = function(t) {
        return this.nodes[t];
      }, e.prototype.setNamedItem = function(t) {
        var n;
        return n = this.nodes[t.nodeName], this.nodes[t.nodeName] = t, n || null;
      }, e.prototype.removeNamedItem = function(t) {
        var n;
        return n = this.nodes[t], delete this.nodes[t], n || null;
      }, e.prototype.item = function(t) {
        return this.nodes[Object.keys(this.nodes)[t]] || null;
      }, e.prototype.getNamedItemNS = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.setNamedItemNS = function(t) {
        throw new Error("This DOM method is not implemented.");
      }, e.prototype.removeNamedItemNS = function(t, n) {
        throw new Error("This DOM method is not implemented.");
      }, e;
    }();
  }).call(It)), om.exports;
}
var Kx;
function j0() {
  return Kx || (Kx = 1, (function() {
    var e, t, n, s, r, i, a, o, l = function(d, u) {
      for (var c in u)
        f.call(u, c) && (d[c] = u[c]);
      function h() {
        this.constructor = d;
      }
      return h.prototype = u.prototype, d.prototype = new h(), d.__super__ = u.prototype, d;
    }, f = {}.hasOwnProperty;
    o = ca(), a = o.isObject, i = o.isFunction, r = o.getValue, s = br(), e = wn(), t = mM(), n = N0(), rm.exports = function(d) {
      l(u, d);
      function u(c, h, p) {
        var g, m, v, y;
        if (u.__super__.constructor.call(this, c), h == null)
          throw new Error("Missing element name. " + this.debugInfo());
        if (this.name = this.stringify.name(h), this.type = e.Element, this.attribs = {}, this.schemaTypeInfo = null, p != null && this.attribute(p), c.type === e.Document && (this.isRoot = !0, this.documentObject = c, c.rootObject = this, c.children)) {
          for (y = c.children, m = 0, v = y.length; m < v; m++)
            if (g = y[m], g.type === e.DocType) {
              g.name = this.name;
              break;
            }
        }
      }
      return Object.defineProperty(u.prototype, "tagName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(u.prototype, "namespaceURI", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(u.prototype, "prefix", {
        get: function() {
          return "";
        }
      }), Object.defineProperty(u.prototype, "localName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(u.prototype, "id", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "className", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "classList", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(u.prototype, "attributes", {
        get: function() {
          return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new n(this.attribs)), this.attributeMap;
        }
      }), u.prototype.clone = function() {
        var c, h, p, g;
        p = Object.create(this), p.isRoot && (p.documentObject = null), p.attribs = {}, g = this.attribs;
        for (h in g)
          f.call(g, h) && (c = g[h], p.attribs[h] = c.clone());
        return p.children = [], this.children.forEach(function(m) {
          var v;
          return v = m.clone(), v.parent = p, p.children.push(v);
        }), p;
      }, u.prototype.attribute = function(c, h) {
        var p, g;
        if (c != null && (c = r(c)), a(c))
          for (p in c)
            f.call(c, p) && (g = c[p], this.attribute(p, g));
        else
          i(h) && (h = h.apply()), this.options.keepNullAttributes && h == null ? this.attribs[c] = new t(this, c, "") : h != null && (this.attribs[c] = new t(this, c, h));
        return this;
      }, u.prototype.removeAttribute = function(c) {
        var h, p, g;
        if (c == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (c = r(c), Array.isArray(c))
          for (p = 0, g = c.length; p < g; p++)
            h = c[p], delete this.attribs[h];
        else
          delete this.attribs[c];
        return this;
      }, u.prototype.toString = function(c) {
        return this.options.writer.element(this, this.options.writer.filterOptions(c));
      }, u.prototype.att = function(c, h) {
        return this.attribute(c, h);
      }, u.prototype.a = function(c, h) {
        return this.attribute(c, h);
      }, u.prototype.getAttribute = function(c) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c].value : null;
      }, u.prototype.setAttribute = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNode = function(c) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c] : null;
      }, u.prototype.setAttributeNode = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.removeAttributeNode = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setAttributeNS = function(c, h, p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.removeAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getAttributeNodeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setAttributeNodeNS = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagNameNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.hasAttribute = function(c) {
        return this.attribs.hasOwnProperty(c);
      }, u.prototype.hasAttributeNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setIdAttribute = function(c, h) {
        return this.attribs.hasOwnProperty(c) ? this.attribs[c].isId : h;
      }, u.prototype.setIdAttributeNS = function(c, h, p) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.setIdAttributeNode = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByTagNameNS = function(c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.getElementsByClassName = function(c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, u.prototype.isEqualNode = function(c) {
        var h, p, g;
        if (!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(c) || c.namespaceURI !== this.namespaceURI || c.prefix !== this.prefix || c.localName !== this.localName || c.attribs.length !== this.attribs.length)
          return !1;
        for (h = p = 0, g = this.attribs.length - 1; 0 <= g ? p <= g : p >= g; h = 0 <= g ? ++p : --p)
          if (!this.attribs[h].isEqualNode(c.attribs[h]))
            return !1;
        return !0;
      }, u;
    }(s);
  }).call(It)), rm.exports;
}
var lm = { exports: {} }, um = { exports: {} }, Gx;
function tp() {
  return Gx || (Gx = 1, (function() {
    var e, t = function(s, r) {
      for (var i in r)
        n.call(r, i) && (s[i] = r[i]);
      function a() {
        this.constructor = s;
      }
      return a.prototype = r.prototype, s.prototype = new a(), s.__super__ = r.prototype, s;
    }, n = {}.hasOwnProperty;
    e = br(), um.exports = function(s) {
      t(r, s);
      function r(i) {
        r.__super__.constructor.call(this, i), this.value = "";
      }
      return Object.defineProperty(r.prototype, "data", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), Object.defineProperty(r.prototype, "length", {
        get: function() {
          return this.value.length;
        }
      }), Object.defineProperty(r.prototype, "textContent", {
        get: function() {
          return this.value;
        },
        set: function(i) {
          return this.value = i || "";
        }
      }), r.prototype.clone = function() {
        return Object.create(this);
      }, r.prototype.substringData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.appendData = function(i) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.insertData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.deleteData = function(i, a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.replaceData = function(i, a, o) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, r.prototype.isEqualNode = function(i) {
        return !(!r.__super__.isEqualNode.apply(this, arguments).isEqualNode(i) || i.data !== this.data);
      }, r;
    }(e);
  }).call(It)), um.exports;
}
var kx;
function $0() {
  return kx || (kx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = wn(), t = tp(), lm.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.name = "#cdata-section", this.type = e.CData, this.value = this.stringify.cdata(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.cdata(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), lm.exports;
}
var cm = { exports: {} }, Hx;
function U0() {
  return Hx || (Hx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = wn(), t = tp(), cm.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.name = "#comment", this.type = e.Comment, this.value = this.stringify.comment(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.comment(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), cm.exports;
}
var hm = { exports: {} }, Yx;
function W0() {
  return Yx || (Yx = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    n = ca().isObject, t = br(), e = wn(), hm.exports = function(i) {
      s(a, i);
      function a(o, l, f, d) {
        var u;
        a.__super__.constructor.call(this, o), n(l) && (u = l, l = u.version, f = u.encoding, d = u.standalone), l || (l = "1.0"), this.type = e.Declaration, this.version = this.stringify.xmlVersion(l), f != null && (this.encoding = this.stringify.xmlEncoding(f)), d != null && (this.standalone = this.stringify.xmlStandalone(d));
      }
      return a.prototype.toString = function(o) {
        return this.options.writer.declaration(this, this.options.writer.filterOptions(o));
      }, a;
    }(t);
  }).call(It)), hm.exports;
}
var dm = { exports: {} }, fm = { exports: {} }, Xx;
function z0() {
  return Xx || (Xx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = br(), e = wn(), fm.exports = function(r) {
      n(i, r);
      function i(a, o, l, f, d, u) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (l == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(o));
        if (!f)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(o));
        if (!d)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(o));
        if (d.indexOf("#") !== 0 && (d = "#" + d), !d.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(o));
        if (u && !d.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(o));
        this.elementName = this.stringify.name(o), this.type = e.AttributeDeclaration, this.attributeName = this.stringify.name(l), this.attributeType = this.stringify.dtdAttType(f), u && (this.defaultValue = this.stringify.dtdAttDefault(u)), this.defaultValueType = d;
      }
      return i.prototype.toString = function(a) {
        return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), fm.exports;
}
var pm = { exports: {} }, Zx;
function K0() {
  return Zx || (Zx = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    n = ca().isObject, t = br(), e = wn(), pm.exports = function(i) {
      s(a, i);
      function a(o, l, f, d) {
        if (a.__super__.constructor.call(this, o), f == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(f));
        if (d == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(f));
        if (this.pe = !!l, this.name = this.stringify.name(f), this.type = e.EntityDeclaration, !n(d))
          this.value = this.stringify.dtdEntityValue(d), this.internal = !0;
        else {
          if (!d.pubID && !d.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(f));
          if (d.pubID && !d.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(f));
          if (this.internal = !1, d.pubID != null && (this.pubID = this.stringify.dtdPubID(d.pubID)), d.sysID != null && (this.sysID = this.stringify.dtdSysID(d.sysID)), d.nData != null && (this.nData = this.stringify.dtdNData(d.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(f));
        }
      }
      return Object.defineProperty(a.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(a.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(a.prototype, "notationName", {
        get: function() {
          return this.nData || null;
        }
      }), Object.defineProperty(a.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(a.prototype, "xmlEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(a.prototype, "xmlVersion", {
        get: function() {
          return null;
        }
      }), a.prototype.toString = function(o) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(o));
      }, a;
    }(t);
  }).call(It)), pm.exports;
}
var mm = { exports: {} }, Jx;
function G0() {
  return Jx || (Jx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = br(), e = wn(), mm.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        l || (l = "(#PCDATA)"), Array.isArray(l) && (l = "(" + l.join(",") + ")"), this.name = this.stringify.name(o), this.type = e.ElementDeclaration, this.value = this.stringify.dtdElementValue(l);
      }
      return i.prototype.toString = function(a) {
        return this.options.writer.dtdElement(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), mm.exports;
}
var gm = { exports: {} }, Qx;
function k0() {
  return Qx || (Qx = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = br(), e = wn(), gm.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(o));
        if (!l.pubID && !l.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(o));
        this.name = this.stringify.name(o), this.type = e.NotationDeclaration, l.pubID != null && (this.pubID = this.stringify.dtdPubID(l.pubID)), l.sysID != null && (this.sysID = this.stringify.dtdSysID(l.sysID));
      }
      return Object.defineProperty(i.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(i.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), i.prototype.toString = function(a) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), gm.exports;
}
var qx;
function H0() {
  return qx || (qx = 1, (function() {
    var e, t, n, s, r, i, a, o, l = function(d, u) {
      for (var c in u)
        f.call(u, c) && (d[c] = u[c]);
      function h() {
        this.constructor = d;
      }
      return h.prototype = u.prototype, d.prototype = new h(), d.__super__ = u.prototype, d;
    }, f = {}.hasOwnProperty;
    o = ca().isObject, a = br(), e = wn(), t = z0(), s = K0(), n = G0(), r = k0(), i = N0(), dm.exports = function(d) {
      l(u, d);
      function u(c, h, p) {
        var g, m, v, y, E, C;
        if (u.__super__.constructor.call(this, c), this.type = e.DocType, c.children) {
          for (y = c.children, m = 0, v = y.length; m < v; m++)
            if (g = y[m], g.type === e.Element) {
              this.name = g.name;
              break;
            }
        }
        this.documentObject = c, o(h) && (E = h, h = E.pubID, p = E.sysID), p == null && (C = [h, p], p = C[0], h = C[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), p != null && (this.sysID = this.stringify.dtdSysID(p));
      }
      return Object.defineProperty(u.prototype, "entities", {
        get: function() {
          var c, h, p, g, m;
          for (g = {}, m = this.children, h = 0, p = m.length; h < p; h++)
            c = m[h], c.type === e.EntityDeclaration && !c.pe && (g[c.name] = c);
          return new i(g);
        }
      }), Object.defineProperty(u.prototype, "notations", {
        get: function() {
          var c, h, p, g, m;
          for (g = {}, m = this.children, h = 0, p = m.length; h < p; h++)
            c = m[h], c.type === e.NotationDeclaration && (g[c.name] = c);
          return new i(g);
        }
      }), Object.defineProperty(u.prototype, "publicId", {
        get: function() {
          return this.pubID;
        }
      }), Object.defineProperty(u.prototype, "systemId", {
        get: function() {
          return this.sysID;
        }
      }), Object.defineProperty(u.prototype, "internalSubset", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), u.prototype.element = function(c, h) {
        var p;
        return p = new n(this, c, h), this.children.push(p), this;
      }, u.prototype.attList = function(c, h, p, g, m) {
        var v;
        return v = new t(this, c, h, p, g, m), this.children.push(v), this;
      }, u.prototype.entity = function(c, h) {
        var p;
        return p = new s(this, !1, c, h), this.children.push(p), this;
      }, u.prototype.pEntity = function(c, h) {
        var p;
        return p = new s(this, !0, c, h), this.children.push(p), this;
      }, u.prototype.notation = function(c, h) {
        var p;
        return p = new r(this, c, h), this.children.push(p), this;
      }, u.prototype.toString = function(c) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(c));
      }, u.prototype.ele = function(c, h) {
        return this.element(c, h);
      }, u.prototype.att = function(c, h, p, g, m) {
        return this.attList(c, h, p, g, m);
      }, u.prototype.ent = function(c, h) {
        return this.entity(c, h);
      }, u.prototype.pent = function(c, h) {
        return this.pEntity(c, h);
      }, u.prototype.not = function(c, h) {
        return this.notation(c, h);
      }, u.prototype.up = function() {
        return this.root() || this.documentObject;
      }, u.prototype.isEqualNode = function(c) {
        return !(!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(c) || c.name !== this.name || c.publicId !== this.publicId || c.systemId !== this.systemId);
      }, u;
    }(a);
  }).call(It)), dm.exports;
}
var vm = { exports: {} }, tb;
function Y0() {
  return tb || (tb = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = wn(), t = br(), vm.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.type = e.Raw, this.value = this.stringify.raw(o);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.raw(this, this.options.writer.filterOptions(a));
      }, i;
    }(t);
  }).call(It)), vm.exports;
}
var ym = { exports: {} }, eb;
function X0() {
  return eb || (eb = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = wn(), t = tp(), ym.exports = function(r) {
      n(i, r);
      function i(a, o) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.name = "#text", this.type = e.Text, this.value = this.stringify.text(o);
      }
      return Object.defineProperty(i.prototype, "isElementContentWhitespace", {
        get: function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), Object.defineProperty(i.prototype, "wholeText", {
        get: function() {
          var a, o, l;
          for (l = "", o = this.previousSibling; o; )
            l = o.data + l, o = o.previousSibling;
          for (l += this.data, a = this.nextSibling; a; )
            l = l + a.data, a = a.nextSibling;
          return l;
        }
      }), i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.text(this, this.options.writer.filterOptions(a));
      }, i.prototype.splitText = function(a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i.prototype.replaceWholeText = function(a) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, i;
    }(t);
  }).call(It)), ym.exports;
}
var Em = { exports: {} }, nb;
function Z0() {
  return nb || (nb = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    e = wn(), t = tp(), Em.exports = function(r) {
      n(i, r);
      function i(a, o, l) {
        if (i.__super__.constructor.call(this, a), o == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.type = e.ProcessingInstruction, this.target = this.stringify.insTarget(o), this.name = this.target, l && (this.value = this.stringify.insValue(l));
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(a));
      }, i.prototype.isEqualNode = function(a) {
        return !(!i.__super__.isEqualNode.apply(this, arguments).isEqualNode(a) || a.target !== this.target);
      }, i;
    }(t);
  }).call(It)), Em.exports;
}
var Cm = { exports: {} }, ib;
function gM() {
  return ib || (ib = 1, (function() {
    var e, t, n = function(r, i) {
      for (var a in i)
        s.call(i, a) && (r[a] = i[a]);
      function o() {
        this.constructor = r;
      }
      return o.prototype = i.prototype, r.prototype = new o(), r.__super__ = i.prototype, r;
    }, s = {}.hasOwnProperty;
    t = br(), e = wn(), Cm.exports = function(r) {
      n(i, r);
      function i(a) {
        i.__super__.constructor.call(this, a), this.type = e.Dummy;
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(a) {
        return "";
      }, i;
    }(t);
  }).call(It)), Cm.exports;
}
var xm = { exports: {} }, rb;
function c5() {
  return rb || (rb = 1, (function() {
    xm.exports = function() {
      function e(t) {
        this.nodes = t;
      }
      return Object.defineProperty(e.prototype, "length", {
        get: function() {
          return this.nodes.length || 0;
        }
      }), e.prototype.clone = function() {
        return this.nodes = null;
      }, e.prototype.item = function(t) {
        return this.nodes[t] || null;
      }, e;
    }();
  }).call(It)), xm.exports;
}
var bm = { exports: {} }, sb;
function h5() {
  return sb || (sb = 1, (function() {
    bm.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32
    };
  }).call(It)), bm.exports;
}
var ab;
function br() {
  return ab || (ab = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v = {}.hasOwnProperty;
    m = ca(), g = m.isObject, p = m.isFunction, h = m.isEmpty, c = m.getValue, o = null, n = null, s = null, r = null, i = null, d = null, u = null, f = null, a = null, t = null, l = null, e = null, im.exports = function() {
      function y(E) {
        this.parent = E, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, o || (o = j0(), n = $0(), s = U0(), r = W0(), i = H0(), d = Y0(), u = X0(), f = Z0(), a = gM(), t = wn(), l = c5(), N0(), e = h5());
      }
      return Object.defineProperty(y.prototype, "nodeName", {
        get: function() {
          return this.name;
        }
      }), Object.defineProperty(y.prototype, "nodeType", {
        get: function() {
          return this.type;
        }
      }), Object.defineProperty(y.prototype, "nodeValue", {
        get: function() {
          return this.value;
        }
      }), Object.defineProperty(y.prototype, "parentNode", {
        get: function() {
          return this.parent;
        }
      }), Object.defineProperty(y.prototype, "childNodes", {
        get: function() {
          return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new l(this.children)), this.childNodeList;
        }
      }), Object.defineProperty(y.prototype, "firstChild", {
        get: function() {
          return this.children[0] || null;
        }
      }), Object.defineProperty(y.prototype, "lastChild", {
        get: function() {
          return this.children[this.children.length - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "previousSibling", {
        get: function() {
          var E;
          return E = this.parent.children.indexOf(this), this.parent.children[E - 1] || null;
        }
      }), Object.defineProperty(y.prototype, "nextSibling", {
        get: function() {
          var E;
          return E = this.parent.children.indexOf(this), this.parent.children[E + 1] || null;
        }
      }), Object.defineProperty(y.prototype, "ownerDocument", {
        get: function() {
          return this.document() || null;
        }
      }), Object.defineProperty(y.prototype, "textContent", {
        get: function() {
          var E, C, x, b, P;
          if (this.nodeType === t.Element || this.nodeType === t.DocumentFragment) {
            for (P = "", b = this.children, C = 0, x = b.length; C < x; C++)
              E = b[C], E.textContent && (P += E.textContent);
            return P;
          } else
            return null;
        },
        set: function(E) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }
      }), y.prototype.setParent = function(E) {
        var C, x, b, P, O;
        for (this.parent = E, E && (this.options = E.options, this.stringify = E.stringify), P = this.children, O = [], x = 0, b = P.length; x < b; x++)
          C = P[x], O.push(C.setParent(this));
        return O;
      }, y.prototype.element = function(E, C, x) {
        var b, P, O, T, M, L, A, D, I, w, B;
        if (L = null, C === null && x == null && (I = [{}, null], C = I[0], x = I[1]), C == null && (C = {}), C = c(C), g(C) || (w = [C, x], x = w[0], C = w[1]), E != null && (E = c(E)), Array.isArray(E))
          for (O = 0, A = E.length; O < A; O++)
            P = E[O], L = this.element(P);
        else if (p(E))
          L = this.element(E.apply());
        else if (g(E)) {
          for (M in E)
            if (v.call(E, M))
              if (B = E[M], p(B) && (B = B.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && M.indexOf(this.stringify.convertAttKey) === 0)
                L = this.attribute(M.substr(this.stringify.convertAttKey.length), B);
              else if (!this.options.separateArrayItems && Array.isArray(B) && h(B))
                L = this.dummy();
              else if (g(B) && h(B))
                L = this.element(M);
              else if (!this.options.keepNullNodes && B == null)
                L = this.dummy();
              else if (!this.options.separateArrayItems && Array.isArray(B))
                for (T = 0, D = B.length; T < D; T++)
                  P = B[T], b = {}, b[M] = P, L = this.element(b);
              else
                g(B) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && M.indexOf(this.stringify.convertTextKey) === 0 ? L = this.element(B) : (L = this.element(M), L.element(B)) : L = this.element(M, B);
        } else
          !this.options.keepNullNodes && x === null ? L = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && E.indexOf(this.stringify.convertTextKey) === 0 ? L = this.text(x) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && E.indexOf(this.stringify.convertCDataKey) === 0 ? L = this.cdata(x) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && E.indexOf(this.stringify.convertCommentKey) === 0 ? L = this.comment(x) : !this.options.ignoreDecorators && this.stringify.convertRawKey && E.indexOf(this.stringify.convertRawKey) === 0 ? L = this.raw(x) : !this.options.ignoreDecorators && this.stringify.convertPIKey && E.indexOf(this.stringify.convertPIKey) === 0 ? L = this.instruction(E.substr(this.stringify.convertPIKey.length), x) : L = this.node(E, C, x);
        if (L == null)
          throw new Error("Could not create any elements with: " + E + ". " + this.debugInfo());
        return L;
      }, y.prototype.insertBefore = function(E, C, x) {
        var b, P, O, T, M;
        if (E != null && E.type)
          return O = E, T = C, O.setParent(this), T ? (P = children.indexOf(T), M = children.splice(P), children.push(O), Array.prototype.push.apply(children, M)) : children.push(O), O;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(E));
        return P = this.parent.children.indexOf(this), M = this.parent.children.splice(P), b = this.parent.element(E, C, x), Array.prototype.push.apply(this.parent.children, M), b;
      }, y.prototype.insertAfter = function(E, C, x) {
        var b, P, O;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(E));
        return P = this.parent.children.indexOf(this), O = this.parent.children.splice(P + 1), b = this.parent.element(E, C, x), Array.prototype.push.apply(this.parent.children, O), b;
      }, y.prototype.remove = function() {
        var E;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return E = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [E, E - E + 1].concat([])), this.parent;
      }, y.prototype.node = function(E, C, x) {
        var b, P;
        return E != null && (E = c(E)), C || (C = {}), C = c(C), g(C) || (P = [C, x], x = P[0], C = P[1]), b = new o(this, E, C), x != null && b.text(x), this.children.push(b), b;
      }, y.prototype.text = function(E) {
        var C;
        return g(E) && this.element(E), C = new u(this, E), this.children.push(C), this;
      }, y.prototype.cdata = function(E) {
        var C;
        return C = new n(this, E), this.children.push(C), this;
      }, y.prototype.comment = function(E) {
        var C;
        return C = new s(this, E), this.children.push(C), this;
      }, y.prototype.commentBefore = function(E) {
        var C, x;
        return C = this.parent.children.indexOf(this), x = this.parent.children.splice(C), this.parent.comment(E), Array.prototype.push.apply(this.parent.children, x), this;
      }, y.prototype.commentAfter = function(E) {
        var C, x;
        return C = this.parent.children.indexOf(this), x = this.parent.children.splice(C + 1), this.parent.comment(E), Array.prototype.push.apply(this.parent.children, x), this;
      }, y.prototype.raw = function(E) {
        var C;
        return C = new d(this, E), this.children.push(C), this;
      }, y.prototype.dummy = function() {
        var E;
        return E = new a(this), E;
      }, y.prototype.instruction = function(E, C) {
        var x, b, P, O, T;
        if (E != null && (E = c(E)), C != null && (C = c(C)), Array.isArray(E))
          for (O = 0, T = E.length; O < T; O++)
            x = E[O], this.instruction(x);
        else if (g(E))
          for (x in E)
            v.call(E, x) && (b = E[x], this.instruction(x, b));
        else
          p(C) && (C = C.apply()), P = new f(this, E, C), this.children.push(P);
        return this;
      }, y.prototype.instructionBefore = function(E, C) {
        var x, b;
        return x = this.parent.children.indexOf(this), b = this.parent.children.splice(x), this.parent.instruction(E, C), Array.prototype.push.apply(this.parent.children, b), this;
      }, y.prototype.instructionAfter = function(E, C) {
        var x, b;
        return x = this.parent.children.indexOf(this), b = this.parent.children.splice(x + 1), this.parent.instruction(E, C), Array.prototype.push.apply(this.parent.children, b), this;
      }, y.prototype.declaration = function(E, C, x) {
        var b, P;
        return b = this.document(), P = new r(b, E, C, x), b.children.length === 0 ? b.children.unshift(P) : b.children[0].type === t.Declaration ? b.children[0] = P : b.children.unshift(P), b.root() || b;
      }, y.prototype.dtd = function(E, C) {
        var x, b, P, O, T, M, L, A, D, I;
        for (b = this.document(), P = new i(b, E, C), D = b.children, O = T = 0, L = D.length; T < L; O = ++T)
          if (x = D[O], x.type === t.DocType)
            return b.children[O] = P, P;
        for (I = b.children, O = M = 0, A = I.length; M < A; O = ++M)
          if (x = I[O], x.isRoot)
            return b.children.splice(O, 0, P), P;
        return b.children.push(P), P;
      }, y.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, y.prototype.root = function() {
        var E;
        for (E = this; E; ) {
          if (E.type === t.Document)
            return E.rootObject;
          if (E.isRoot)
            return E;
          E = E.parent;
        }
      }, y.prototype.document = function() {
        var E;
        for (E = this; E; ) {
          if (E.type === t.Document)
            return E;
          E = E.parent;
        }
      }, y.prototype.end = function(E) {
        return this.document().end(E);
      }, y.prototype.prev = function() {
        var E;
        if (E = this.parent.children.indexOf(this), E < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[E - 1];
      }, y.prototype.next = function() {
        var E;
        if (E = this.parent.children.indexOf(this), E === -1 || E === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[E + 1];
      }, y.prototype.importDocument = function(E) {
        var C;
        return C = E.root().clone(), C.parent = this, C.isRoot = !1, this.children.push(C), this;
      }, y.prototype.debugInfo = function(E) {
        var C, x;
        return E = E || this.name, E == null && !((C = this.parent) != null && C.name) ? "" : E == null ? "parent: <" + this.parent.name + ">" : (x = this.parent) != null && x.name ? "node: <" + E + ">, parent: <" + this.parent.name + ">" : "node: <" + E + ">";
      }, y.prototype.ele = function(E, C, x) {
        return this.element(E, C, x);
      }, y.prototype.nod = function(E, C, x) {
        return this.node(E, C, x);
      }, y.prototype.txt = function(E) {
        return this.text(E);
      }, y.prototype.dat = function(E) {
        return this.cdata(E);
      }, y.prototype.com = function(E) {
        return this.comment(E);
      }, y.prototype.ins = function(E, C) {
        return this.instruction(E, C);
      }, y.prototype.doc = function() {
        return this.document();
      }, y.prototype.dec = function(E, C, x) {
        return this.declaration(E, C, x);
      }, y.prototype.e = function(E, C, x) {
        return this.element(E, C, x);
      }, y.prototype.n = function(E, C, x) {
        return this.node(E, C, x);
      }, y.prototype.t = function(E) {
        return this.text(E);
      }, y.prototype.d = function(E) {
        return this.cdata(E);
      }, y.prototype.c = function(E) {
        return this.comment(E);
      }, y.prototype.r = function(E) {
        return this.raw(E);
      }, y.prototype.i = function(E, C) {
        return this.instruction(E, C);
      }, y.prototype.u = function() {
        return this.up();
      }, y.prototype.importXMLBuilder = function(E) {
        return this.importDocument(E);
      }, y.prototype.replaceChild = function(E, C) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.removeChild = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.appendChild = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.hasChildNodes = function() {
        return this.children.length !== 0;
      }, y.prototype.cloneNode = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.normalize = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isSupported = function(E, C) {
        return !0;
      }, y.prototype.hasAttributes = function() {
        return this.attribs.length !== 0;
      }, y.prototype.compareDocumentPosition = function(E) {
        var C, x;
        return C = this, C === E ? 0 : this.document() !== E.document() ? (x = e.Disconnected | e.ImplementationSpecific, Math.random() < 0.5 ? x |= e.Preceding : x |= e.Following, x) : C.isAncestor(E) ? e.Contains | e.Preceding : C.isDescendant(E) ? e.Contains | e.Following : C.isPreceding(E) ? e.Preceding : e.Following;
      }, y.prototype.isSameNode = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.lookupPrefix = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isDefaultNamespace = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.lookupNamespaceURI = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.isEqualNode = function(E) {
        var C, x, b;
        if (E.nodeType !== this.nodeType || E.children.length !== this.children.length)
          return !1;
        for (C = x = 0, b = this.children.length - 1; 0 <= b ? x <= b : x >= b; C = 0 <= b ? ++x : --x)
          if (!this.children[C].isEqualNode(E.children[C]))
            return !1;
        return !0;
      }, y.prototype.getFeature = function(E, C) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.setUserData = function(E, C, x) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.getUserData = function(E) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, y.prototype.contains = function(E) {
        return E ? E === this || this.isDescendant(E) : !1;
      }, y.prototype.isDescendant = function(E) {
        var C, x, b, P, O;
        for (O = this.children, b = 0, P = O.length; b < P; b++)
          if (C = O[b], E === C || (x = C.isDescendant(E), x))
            return !0;
        return !1;
      }, y.prototype.isAncestor = function(E) {
        return E.isDescendant(this);
      }, y.prototype.isPreceding = function(E) {
        var C, x;
        return C = this.treePosition(E), x = this.treePosition(this), C === -1 || x === -1 ? !1 : C < x;
      }, y.prototype.isFollowing = function(E) {
        var C, x;
        return C = this.treePosition(E), x = this.treePosition(this), C === -1 || x === -1 ? !1 : C > x;
      }, y.prototype.treePosition = function(E) {
        var C, x;
        return x = 0, C = !1, this.foreachTreeNode(this.document(), function(b) {
          if (x++, !C && b === E)
            return C = !0;
        }), C ? x : -1;
      }, y.prototype.foreachTreeNode = function(E, C) {
        var x, b, P, O, T;
        for (E || (E = this.document()), O = E.children, b = 0, P = O.length; b < P; b++) {
          if (x = O[b], T = C(x))
            return T;
          if (T = this.foreachTreeNode(x, C), T)
            return T;
        }
      }, y;
    }();
  }).call(It)), im.exports;
}
var Tm = { exports: {} }, ob;
function vM() {
  return ob || (ob = 1, (function() {
    var e = function(n, s) {
      return function() {
        return n.apply(s, arguments);
      };
    }, t = {}.hasOwnProperty;
    Tm.exports = function() {
      function n(s) {
        this.assertLegalName = e(this.assertLegalName, this), this.assertLegalChar = e(this.assertLegalChar, this);
        var r, i, a;
        s || (s = {}), this.options = s, this.options.version || (this.options.version = "1.0"), i = s.stringify || {};
        for (r in i)
          t.call(i, r) && (a = i[r], this[r] = a);
      }
      return n.prototype.name = function(s) {
        return this.options.noValidation ? s : this.assertLegalName("" + s || "");
      }, n.prototype.text = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar(this.textEscape("" + s || ""));
      }, n.prototype.cdata = function(s) {
        return this.options.noValidation ? s : (s = "" + s || "", s = s.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(s));
      }, n.prototype.comment = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", s.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.raw = function(s) {
        return this.options.noValidation ? s : "" + s || "";
      }, n.prototype.attValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar(this.attEscape(s = "" + s || ""));
      }, n.prototype.insTarget = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.insValue = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", s.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.xmlVersion = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", !s.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + s);
        return s;
      }, n.prototype.xmlEncoding = function(s) {
        if (this.options.noValidation)
          return s;
        if (s = "" + s || "", !s.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + s);
        return this.assertLegalChar(s);
      }, n.prototype.xmlStandalone = function(s) {
        return this.options.noValidation ? s : s ? "yes" : "no";
      }, n.prototype.dtdPubID = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdSysID = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdElementValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdAttType = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdAttDefault = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdEntityValue = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.dtdNData = function(s) {
        return this.options.noValidation ? s : this.assertLegalChar("" + s || "");
      }, n.prototype.convertAttKey = "@", n.prototype.convertPIKey = "?", n.prototype.convertTextKey = "#text", n.prototype.convertCDataKey = "#cdata", n.prototype.convertCommentKey = "#comment", n.prototype.convertRawKey = "#raw", n.prototype.assertLegalChar = function(s) {
        var r, i;
        if (this.options.noValidation)
          return s;
        if (r = "", this.options.version === "1.0") {
          if (r = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = s.match(r))
            throw new Error("Invalid character in string: " + s + " at index " + i.index);
        } else if (this.options.version === "1.1" && (r = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, i = s.match(r)))
          throw new Error("Invalid character in string: " + s + " at index " + i.index);
        return s;
      }, n.prototype.assertLegalName = function(s) {
        var r;
        if (this.options.noValidation)
          return s;
        if (this.assertLegalChar(s), r = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !s.match(r))
          throw new Error("Invalid character in name");
        return s;
      }, n.prototype.textEscape = function(s) {
        var r;
        return this.options.noValidation ? s : (r = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, s.replace(r, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
      }, n.prototype.attEscape = function(s) {
        var r;
        return this.options.noValidation ? s : (r = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, s.replace(r, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
      }, n;
    }();
  }).call(It)), Tm.exports;
}
var Om = { exports: {} }, Pm = { exports: {} }, Sm = { exports: {} }, lb;
function ep() {
  return lb || (lb = 1, (function() {
    Sm.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3
    };
  }).call(It)), Sm.exports;
}
var ub;
function yM() {
  return ub || (ub = 1, (function() {
    var e, t, n, s = {}.hasOwnProperty;
    n = ca().assign, e = wn(), W0(), H0(), $0(), U0(), j0(), Y0(), X0(), Z0(), gM(), z0(), G0(), K0(), k0(), t = ep(), Pm.exports = function() {
      function r(i) {
        var a, o, l;
        i || (i = {}), this.options = i, o = i.writer || {};
        for (a in o)
          s.call(o, a) && (l = o[a], this["_" + a] = this[a], this[a] = l);
      }
      return r.prototype.filterOptions = function(i) {
        var a, o, l, f, d, u, c, h;
        return i || (i = {}), i = n({}, this.options, i), a = {
          writer: this
        }, a.pretty = i.pretty || !1, a.allowEmpty = i.allowEmpty || !1, a.indent = (o = i.indent) != null ? o : "  ", a.newline = (l = i.newline) != null ? l : `
`, a.offset = (f = i.offset) != null ? f : 0, a.dontPrettyTextNodes = (d = (u = i.dontPrettyTextNodes) != null ? u : i.dontprettytextnodes) != null ? d : 0, a.spaceBeforeSlash = (c = (h = i.spaceBeforeSlash) != null ? h : i.spacebeforeslash) != null ? c : "", a.spaceBeforeSlash === !0 && (a.spaceBeforeSlash = " "), a.suppressPrettyCount = 0, a.user = {}, a.state = t.None, a;
      }, r.prototype.indent = function(i, a, o) {
        var l;
        return !a.pretty || a.suppressPrettyCount ? "" : a.pretty && (l = (o || 0) + a.offset + 1, l > 0) ? new Array(l).join(a.indent) : "";
      }, r.prototype.endline = function(i, a, o) {
        return !a.pretty || a.suppressPrettyCount ? "" : a.newline;
      }, r.prototype.attribute = function(i, a, o) {
        var l;
        return this.openAttribute(i, a, o), l = " " + i.name + '="' + i.value + '"', this.closeAttribute(i, a, o), l;
      }, r.prototype.cdata = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<![CDATA[", a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += "]]>" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.comment = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!-- ", a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += " -->" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.declaration = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<?xml", a.state = t.InsideTag, l += ' version="' + i.version + '"', i.encoding != null && (l += ' encoding="' + i.encoding + '"'), i.standalone != null && (l += ' standalone="' + i.standalone + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + "?>", l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.docType = function(i, a, o) {
        var l, f, d, u, c;
        if (o || (o = 0), this.openNode(i, a, o), a.state = t.OpenTag, u = this.indent(i, a, o), u += "<!DOCTYPE " + i.root().name, i.pubID && i.sysID ? u += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (u += ' SYSTEM "' + i.sysID + '"'), i.children.length > 0) {
          for (u += " [", u += this.endline(i, a, o), a.state = t.InsideTag, c = i.children, f = 0, d = c.length; f < d; f++)
            l = c[f], u += this.writeChildNode(l, a, o + 1);
          a.state = t.CloseTag, u += "]";
        }
        return a.state = t.CloseTag, u += a.spaceBeforeSlash + ">", u += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), u;
      }, r.prototype.element = function(i, a, o) {
        var l, f, d, u, c, h, p, g, m, v, y, E, C, x;
        o || (o = 0), v = !1, y = "", this.openNode(i, a, o), a.state = t.OpenTag, y += this.indent(i, a, o) + "<" + i.name, E = i.attribs;
        for (m in E)
          s.call(E, m) && (l = E[m], y += this.attribute(l, a, o));
        if (d = i.children.length, u = d === 0 ? null : i.children[0], d === 0 || i.children.every(function(b) {
          return (b.type === e.Text || b.type === e.Raw) && b.value === "";
        }))
          a.allowEmpty ? (y += ">", a.state = t.CloseTag, y += "</" + i.name + ">" + this.endline(i, a, o)) : (a.state = t.CloseTag, y += a.spaceBeforeSlash + "/>" + this.endline(i, a, o));
        else if (a.pretty && d === 1 && (u.type === e.Text || u.type === e.Raw) && u.value != null)
          y += ">", a.state = t.InsideTag, a.suppressPrettyCount++, v = !0, y += this.writeChildNode(u, a, o + 1), a.suppressPrettyCount--, v = !1, a.state = t.CloseTag, y += "</" + i.name + ">" + this.endline(i, a, o);
        else {
          if (a.dontPrettyTextNodes) {
            for (C = i.children, c = 0, p = C.length; c < p; c++)
              if (f = C[c], (f.type === e.Text || f.type === e.Raw) && f.value != null) {
                a.suppressPrettyCount++, v = !0;
                break;
              }
          }
          for (y += ">" + this.endline(i, a, o), a.state = t.InsideTag, x = i.children, h = 0, g = x.length; h < g; h++)
            f = x[h], y += this.writeChildNode(f, a, o + 1);
          a.state = t.CloseTag, y += this.indent(i, a, o) + "</" + i.name + ">", v && a.suppressPrettyCount--, y += this.endline(i, a, o), a.state = t.None;
        }
        return this.closeNode(i, a, o), y;
      }, r.prototype.writeChildNode = function(i, a, o) {
        switch (i.type) {
          case e.CData:
            return this.cdata(i, a, o);
          case e.Comment:
            return this.comment(i, a, o);
          case e.Element:
            return this.element(i, a, o);
          case e.Raw:
            return this.raw(i, a, o);
          case e.Text:
            return this.text(i, a, o);
          case e.ProcessingInstruction:
            return this.processingInstruction(i, a, o);
          case e.Dummy:
            return "";
          case e.Declaration:
            return this.declaration(i, a, o);
          case e.DocType:
            return this.docType(i, a, o);
          case e.AttributeDeclaration:
            return this.dtdAttList(i, a, o);
          case e.ElementDeclaration:
            return this.dtdElement(i, a, o);
          case e.EntityDeclaration:
            return this.dtdEntity(i, a, o);
          case e.NotationDeclaration:
            return this.dtdNotation(i, a, o);
          default:
            throw new Error("Unknown XML node type: " + i.constructor.name);
        }
      }, r.prototype.processingInstruction = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<?", a.state = t.InsideTag, l += i.target, i.value && (l += " " + i.value), a.state = t.CloseTag, l += a.spaceBeforeSlash + "?>", l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.raw = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o), a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.text = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o), a.state = t.InsideTag, l += i.value, a.state = t.CloseTag, l += this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdAttList = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ATTLIST", a.state = t.InsideTag, l += " " + i.elementName + " " + i.attributeName + " " + i.attributeType, i.defaultValueType !== "#DEFAULT" && (l += " " + i.defaultValueType), i.defaultValue && (l += ' "' + i.defaultValue + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdElement = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ELEMENT", a.state = t.InsideTag, l += " " + i.name + " " + i.value, a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdEntity = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!ENTITY", a.state = t.InsideTag, i.pe && (l += " %"), l += " " + i.name, i.value ? l += ' "' + i.value + '"' : (i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), i.nData && (l += " NDATA " + i.nData)), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.dtdNotation = function(i, a, o) {
        var l;
        return this.openNode(i, a, o), a.state = t.OpenTag, l = this.indent(i, a, o) + "<!NOTATION", a.state = t.InsideTag, l += " " + i.name, i.pubID && i.sysID ? l += ' PUBLIC "' + i.pubID + '" "' + i.sysID + '"' : i.pubID ? l += ' PUBLIC "' + i.pubID + '"' : i.sysID && (l += ' SYSTEM "' + i.sysID + '"'), a.state = t.CloseTag, l += a.spaceBeforeSlash + ">" + this.endline(i, a, o), a.state = t.None, this.closeNode(i, a, o), l;
      }, r.prototype.openNode = function(i, a, o) {
      }, r.prototype.closeNode = function(i, a, o) {
      }, r.prototype.openAttribute = function(i, a, o) {
      }, r.prototype.closeAttribute = function(i, a, o) {
      }, r;
    }();
  }).call(It)), Pm.exports;
}
var cb;
function J0() {
  return cb || (cb = 1, (function() {
    var e, t = function(s, r) {
      for (var i in r)
        n.call(r, i) && (s[i] = r[i]);
      function a() {
        this.constructor = s;
      }
      return a.prototype = r.prototype, s.prototype = new a(), s.__super__ = r.prototype, s;
    }, n = {}.hasOwnProperty;
    e = yM(), Om.exports = function(s) {
      t(r, s);
      function r(i) {
        r.__super__.constructor.call(this, i);
      }
      return r.prototype.document = function(i, a) {
        var o, l, f, d, u;
        for (a = this.filterOptions(a), d = "", u = i.children, l = 0, f = u.length; l < f; l++)
          o = u[l], d += this.writeChildNode(o, a, 0);
        return a.pretty && d.slice(-a.newline.length) === a.newline && (d = d.slice(0, -a.newline.length)), d;
      }, r;
    }(e);
  }).call(It)), Om.exports;
}
var hb;
function EM() {
  return hb || (hb = 1, (function() {
    var e, t, n, s, r, i, a, o = function(f, d) {
      for (var u in d)
        l.call(d, u) && (f[u] = d[u]);
      function c() {
        this.constructor = f;
      }
      return c.prototype = d.prototype, f.prototype = new c(), f.__super__ = d.prototype, f;
    }, l = {}.hasOwnProperty;
    a = ca().isPlainObject, n = pM(), t = u5(), s = br(), e = wn(), i = vM(), r = J0(), qp.exports = function(f) {
      o(d, f);
      function d(u) {
        d.__super__.constructor.call(this, null), this.name = "#document", this.type = e.Document, this.documentURI = null, this.domConfig = new t(), u || (u = {}), u.writer || (u.writer = new r()), this.options = u, this.stringify = new i(u);
      }
      return Object.defineProperty(d.prototype, "implementation", {
        value: new n()
      }), Object.defineProperty(d.prototype, "doctype", {
        get: function() {
          var u, c, h, p;
          for (p = this.children, c = 0, h = p.length; c < h; c++)
            if (u = p[c], u.type === e.DocType)
              return u;
          return null;
        }
      }), Object.defineProperty(d.prototype, "documentElement", {
        get: function() {
          return this.rootObject || null;
        }
      }), Object.defineProperty(d.prototype, "inputEncoding", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "strictErrorChecking", {
        get: function() {
          return !1;
        }
      }), Object.defineProperty(d.prototype, "xmlEncoding", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].encoding : null;
        }
      }), Object.defineProperty(d.prototype, "xmlStandalone", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].standalone === "yes" : !1;
        }
      }), Object.defineProperty(d.prototype, "xmlVersion", {
        get: function() {
          return this.children.length !== 0 && this.children[0].type === e.Declaration ? this.children[0].version : "1.0";
        }
      }), Object.defineProperty(d.prototype, "URL", {
        get: function() {
          return this.documentURI;
        }
      }), Object.defineProperty(d.prototype, "origin", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "compatMode", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "characterSet", {
        get: function() {
          return null;
        }
      }), Object.defineProperty(d.prototype, "contentType", {
        get: function() {
          return null;
        }
      }), d.prototype.end = function(u) {
        var c;
        return c = {}, u ? a(u) && (c = u, u = this.options.writer) : u = this.options.writer, u.document(this, u.filterOptions(c));
      }, d.prototype.toString = function(u) {
        return this.options.writer.document(this, this.options.writer.filterOptions(u));
      }, d.prototype.createElement = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createDocumentFragment = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createTextNode = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createComment = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createCDATASection = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createProcessingInstruction = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createAttribute = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createEntityReference = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByTagName = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.importNode = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createElementNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createAttributeNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByTagNameNS = function(u, c) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementById = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.adoptNode = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.normalizeDocument = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.renameNode = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.getElementsByClassName = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createEvent = function(u) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createRange = function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createNodeIterator = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d.prototype.createTreeWalker = function(u, c, h) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }, d;
    }(s);
  }).call(It)), qp.exports;
}
var Mm = { exports: {} }, db;
function d5() {
  return db || (db = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f, d, u, c, h, p, g, m, v, y, E, C, x, b, P = {}.hasOwnProperty;
    b = ca(), C = b.isObject, E = b.isFunction, x = b.isPlainObject, y = b.getValue, e = wn(), u = EM(), c = j0(), s = $0(), r = U0(), p = Y0(), v = X0(), h = Z0(), f = W0(), d = H0(), i = z0(), o = K0(), a = G0(), l = k0(), n = mM(), m = vM(), g = J0(), t = ep(), Mm.exports = function() {
      function O(T, M, L) {
        var A;
        this.name = "?xml", this.type = e.Document, T || (T = {}), A = {}, T.writer ? x(T.writer) && (A = T.writer, T.writer = new g()) : T.writer = new g(), this.options = T, this.writer = T.writer, this.writerOptions = this.writer.filterOptions(A), this.stringify = new m(T), this.onDataCallback = M || function() {
        }, this.onEndCallback = L || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return O.prototype.createChildNode = function(T) {
        var M, L, A, D, I, w, B, j;
        switch (T.type) {
          case e.CData:
            this.cdata(T.value);
            break;
          case e.Comment:
            this.comment(T.value);
            break;
          case e.Element:
            A = {}, B = T.attribs;
            for (L in B)
              P.call(B, L) && (M = B[L], A[L] = M.value);
            this.node(T.name, A);
            break;
          case e.Dummy:
            this.dummy();
            break;
          case e.Raw:
            this.raw(T.value);
            break;
          case e.Text:
            this.text(T.value);
            break;
          case e.ProcessingInstruction:
            this.instruction(T.target, T.value);
            break;
          default:
            throw new Error("This XML node type is not supported in a JS object: " + T.constructor.name);
        }
        for (j = T.children, I = 0, w = j.length; I < w; I++)
          D = j[I], this.createChildNode(D), D.type === e.Element && this.up();
        return this;
      }, O.prototype.dummy = function() {
        return this;
      }, O.prototype.node = function(T, M, L) {
        var A;
        if (T == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(T));
        return this.openCurrent(), T = y(T), M == null && (M = {}), M = y(M), C(M) || (A = [M, L], L = A[0], M = A[1]), this.currentNode = new c(this, T, M), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, L != null && this.text(L), this;
      }, O.prototype.element = function(T, M, L) {
        var A, D, I, w, B, j;
        if (this.currentNode && this.currentNode.type === e.DocType)
          this.dtdElement.apply(this, arguments);
        else if (Array.isArray(T) || C(T) || E(T))
          for (w = this.options.noValidation, this.options.noValidation = !0, j = new u(this.options).element("TEMP_ROOT"), j.element(T), this.options.noValidation = w, B = j.children, D = 0, I = B.length; D < I; D++)
            A = B[D], this.createChildNode(A), A.type === e.Element && this.up();
        else
          this.node(T, M, L);
        return this;
      }, O.prototype.attribute = function(T, M) {
        var L, A;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(T));
        if (T != null && (T = y(T)), C(T))
          for (L in T)
            P.call(T, L) && (A = T[L], this.attribute(L, A));
        else
          E(M) && (M = M.apply()), this.options.keepNullAttributes && M == null ? this.currentNode.attribs[T] = new n(this, T, "") : M != null && (this.currentNode.attribs[T] = new n(this, T, M));
        return this;
      }, O.prototype.text = function(T) {
        var M;
        return this.openCurrent(), M = new v(this, T), this.onData(this.writer.text(M, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.cdata = function(T) {
        var M;
        return this.openCurrent(), M = new s(this, T), this.onData(this.writer.cdata(M, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.comment = function(T) {
        var M;
        return this.openCurrent(), M = new r(this, T), this.onData(this.writer.comment(M, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.raw = function(T) {
        var M;
        return this.openCurrent(), M = new p(this, T), this.onData(this.writer.raw(M, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.instruction = function(T, M) {
        var L, A, D, I, w;
        if (this.openCurrent(), T != null && (T = y(T)), M != null && (M = y(M)), Array.isArray(T))
          for (L = 0, I = T.length; L < I; L++)
            A = T[L], this.instruction(A);
        else if (C(T))
          for (A in T)
            P.call(T, A) && (D = T[A], this.instruction(A, D));
        else
          E(M) && (M = M.apply()), w = new h(this, T, M), this.onData(this.writer.processingInstruction(w, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, O.prototype.declaration = function(T, M, L) {
        var A;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return A = new f(this, T, M, L), this.onData(this.writer.declaration(A, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.doctype = function(T, M, L) {
        if (this.openCurrent(), T == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new d(this, M, L), this.currentNode.rootNodeName = T, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, O.prototype.dtdElement = function(T, M) {
        var L;
        return this.openCurrent(), L = new a(this, T, M), this.onData(this.writer.dtdElement(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.attList = function(T, M, L, A, D) {
        var I;
        return this.openCurrent(), I = new i(this, T, M, L, A, D), this.onData(this.writer.dtdAttList(I, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.entity = function(T, M) {
        var L;
        return this.openCurrent(), L = new o(this, !1, T, M), this.onData(this.writer.dtdEntity(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.pEntity = function(T, M) {
        var L;
        return this.openCurrent(), L = new o(this, !0, T, M), this.onData(this.writer.dtdEntity(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.notation = function(T, M) {
        var L;
        return this.openCurrent(), L = new l(this, T, M), this.onData(this.writer.dtdNotation(L, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
      }, O.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, O.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, O.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, O.prototype.openNode = function(T) {
        var M, L, A, D;
        if (!T.isOpen) {
          if (!this.root && this.currentLevel === 0 && T.type === e.Element && (this.root = T), L = "", T.type === e.Element) {
            this.writerOptions.state = t.OpenTag, L = this.writer.indent(T, this.writerOptions, this.currentLevel) + "<" + T.name, D = T.attribs;
            for (A in D)
              P.call(D, A) && (M = D[A], L += this.writer.attribute(M, this.writerOptions, this.currentLevel));
            L += (T.children ? ">" : "/>") + this.writer.endline(T, this.writerOptions, this.currentLevel), this.writerOptions.state = t.InsideTag;
          } else
            this.writerOptions.state = t.OpenTag, L = this.writer.indent(T, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + T.rootNodeName, T.pubID && T.sysID ? L += ' PUBLIC "' + T.pubID + '" "' + T.sysID + '"' : T.sysID && (L += ' SYSTEM "' + T.sysID + '"'), T.children ? (L += " [", this.writerOptions.state = t.InsideTag) : (this.writerOptions.state = t.CloseTag, L += ">"), L += this.writer.endline(T, this.writerOptions, this.currentLevel);
          return this.onData(L, this.currentLevel), T.isOpen = !0;
        }
      }, O.prototype.closeNode = function(T) {
        var M;
        if (!T.isClosed)
          return M = "", this.writerOptions.state = t.CloseTag, T.type === e.Element ? M = this.writer.indent(T, this.writerOptions, this.currentLevel) + "</" + T.name + ">" + this.writer.endline(T, this.writerOptions, this.currentLevel) : M = this.writer.indent(T, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(T, this.writerOptions, this.currentLevel), this.writerOptions.state = t.None, this.onData(M, this.currentLevel), T.isClosed = !0;
      }, O.prototype.onData = function(T, M) {
        return this.documentStarted = !0, this.onDataCallback(T, M + 1);
      }, O.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, O.prototype.debugInfo = function(T) {
        return T == null ? "" : "node: <" + T + ">";
      }, O.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, O.prototype.nod = function(T, M, L) {
        return this.node(T, M, L);
      }, O.prototype.txt = function(T) {
        return this.text(T);
      }, O.prototype.dat = function(T) {
        return this.cdata(T);
      }, O.prototype.com = function(T) {
        return this.comment(T);
      }, O.prototype.ins = function(T, M) {
        return this.instruction(T, M);
      }, O.prototype.dec = function(T, M, L) {
        return this.declaration(T, M, L);
      }, O.prototype.dtd = function(T, M, L) {
        return this.doctype(T, M, L);
      }, O.prototype.e = function(T, M, L) {
        return this.element(T, M, L);
      }, O.prototype.n = function(T, M, L) {
        return this.node(T, M, L);
      }, O.prototype.t = function(T) {
        return this.text(T);
      }, O.prototype.d = function(T) {
        return this.cdata(T);
      }, O.prototype.c = function(T) {
        return this.comment(T);
      }, O.prototype.r = function(T) {
        return this.raw(T);
      }, O.prototype.i = function(T, M) {
        return this.instruction(T, M);
      }, O.prototype.att = function() {
        return this.currentNode && this.currentNode.type === e.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, O.prototype.a = function() {
        return this.currentNode && this.currentNode.type === e.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, O.prototype.ent = function(T, M) {
        return this.entity(T, M);
      }, O.prototype.pent = function(T, M) {
        return this.pEntity(T, M);
      }, O.prototype.not = function(T, M) {
        return this.notation(T, M);
      }, O;
    }();
  }).call(It)), Mm.exports;
}
var _m = { exports: {} }, fb;
function f5() {
  return fb || (fb = 1, (function() {
    var e, t, n, s = function(i, a) {
      for (var o in a)
        r.call(a, o) && (i[o] = a[o]);
      function l() {
        this.constructor = i;
      }
      return l.prototype = a.prototype, i.prototype = new l(), i.__super__ = a.prototype, i;
    }, r = {}.hasOwnProperty;
    e = wn(), n = yM(), t = ep(), _m.exports = function(i) {
      s(a, i);
      function a(o, l) {
        this.stream = o, a.__super__.constructor.call(this, l);
      }
      return a.prototype.endline = function(o, l, f) {
        return o.isLastRootNode && l.state === t.CloseTag ? "" : a.__super__.endline.call(this, o, l, f);
      }, a.prototype.document = function(o, l) {
        var f, d, u, c, h, p, g, m, v;
        for (g = o.children, d = u = 0, h = g.length; u < h; d = ++u)
          f = g[d], f.isLastRootNode = d === o.children.length - 1;
        for (l = this.filterOptions(l), m = o.children, v = [], c = 0, p = m.length; c < p; c++)
          f = m[c], v.push(this.writeChildNode(f, l, 0));
        return v;
      }, a.prototype.attribute = function(o, l, f) {
        return this.stream.write(a.__super__.attribute.call(this, o, l, f));
      }, a.prototype.cdata = function(o, l, f) {
        return this.stream.write(a.__super__.cdata.call(this, o, l, f));
      }, a.prototype.comment = function(o, l, f) {
        return this.stream.write(a.__super__.comment.call(this, o, l, f));
      }, a.prototype.declaration = function(o, l, f) {
        return this.stream.write(a.__super__.declaration.call(this, o, l, f));
      }, a.prototype.docType = function(o, l, f) {
        var d, u, c, h;
        if (f || (f = 0), this.openNode(o, l, f), l.state = t.OpenTag, this.stream.write(this.indent(o, l, f)), this.stream.write("<!DOCTYPE " + o.root().name), o.pubID && o.sysID ? this.stream.write(' PUBLIC "' + o.pubID + '" "' + o.sysID + '"') : o.sysID && this.stream.write(' SYSTEM "' + o.sysID + '"'), o.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(o, l, f)), l.state = t.InsideTag, h = o.children, u = 0, c = h.length; u < c; u++)
            d = h[u], this.writeChildNode(d, l, f + 1);
          l.state = t.CloseTag, this.stream.write("]");
        }
        return l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + ">"), this.stream.write(this.endline(o, l, f)), l.state = t.None, this.closeNode(o, l, f);
      }, a.prototype.element = function(o, l, f) {
        var d, u, c, h, p, g, m, v, y;
        f || (f = 0), this.openNode(o, l, f), l.state = t.OpenTag, this.stream.write(this.indent(o, l, f) + "<" + o.name), v = o.attribs;
        for (m in v)
          r.call(v, m) && (d = v[m], this.attribute(d, l, f));
        if (c = o.children.length, h = c === 0 ? null : o.children[0], c === 0 || o.children.every(function(E) {
          return (E.type === e.Text || E.type === e.Raw) && E.value === "";
        }))
          l.allowEmpty ? (this.stream.write(">"), l.state = t.CloseTag, this.stream.write("</" + o.name + ">")) : (l.state = t.CloseTag, this.stream.write(l.spaceBeforeSlash + "/>"));
        else if (l.pretty && c === 1 && (h.type === e.Text || h.type === e.Raw) && h.value != null)
          this.stream.write(">"), l.state = t.InsideTag, l.suppressPrettyCount++, this.writeChildNode(h, l, f + 1), l.suppressPrettyCount--, l.state = t.CloseTag, this.stream.write("</" + o.name + ">");
        else {
          for (this.stream.write(">" + this.endline(o, l, f)), l.state = t.InsideTag, y = o.children, p = 0, g = y.length; p < g; p++)
            u = y[p], this.writeChildNode(u, l, f + 1);
          l.state = t.CloseTag, this.stream.write(this.indent(o, l, f) + "</" + o.name + ">");
        }
        return this.stream.write(this.endline(o, l, f)), l.state = t.None, this.closeNode(o, l, f);
      }, a.prototype.processingInstruction = function(o, l, f) {
        return this.stream.write(a.__super__.processingInstruction.call(this, o, l, f));
      }, a.prototype.raw = function(o, l, f) {
        return this.stream.write(a.__super__.raw.call(this, o, l, f));
      }, a.prototype.text = function(o, l, f) {
        return this.stream.write(a.__super__.text.call(this, o, l, f));
      }, a.prototype.dtdAttList = function(o, l, f) {
        return this.stream.write(a.__super__.dtdAttList.call(this, o, l, f));
      }, a.prototype.dtdElement = function(o, l, f) {
        return this.stream.write(a.__super__.dtdElement.call(this, o, l, f));
      }, a.prototype.dtdEntity = function(o, l, f) {
        return this.stream.write(a.__super__.dtdEntity.call(this, o, l, f));
      }, a.prototype.dtdNotation = function(o, l, f) {
        return this.stream.write(a.__super__.dtdNotation.call(this, o, l, f));
      }, a;
    }(n);
  }).call(It)), _m.exports;
}
var pb;
function p5() {
  return pb || (pb = 1, (function() {
    var e, t, n, s, r, i, a, o, l, f;
    f = ca(), o = f.assign, l = f.isFunction, n = pM(), s = EM(), r = d5(), a = J0(), i = f5(), e = wn(), t = ep(), ws.create = function(d, u, c, h) {
      var p, g;
      if (d == null)
        throw new Error("Root element needs a name.");
      return h = o({}, u, c, h), p = new s(h), g = p.element(d), h.headless || (p.declaration(h), (h.pubID != null || h.sysID != null) && p.dtd(h)), g;
    }, ws.begin = function(d, u, c) {
      var h;
      return l(d) && (h = [d, u], u = h[0], c = h[1], d = {}), u ? new r(d, u, c) : new s(d);
    }, ws.stringWriter = function(d) {
      return new a(d);
    }, ws.streamWriter = function(d, u) {
      return new i(d, u);
    }, ws.implementation = new n(), ws.nodeType = e, ws.writerState = t;
  }).call(It)), ws;
}
var mb;
function m5() {
  return mb || (mb = 1, (function() {
    var e, t, n, s, r, i = {}.hasOwnProperty;
    e = p5(), t = F0().defaults, s = function(a) {
      return typeof a == "string" && (a.indexOf("&") >= 0 || a.indexOf(">") >= 0 || a.indexOf("<") >= 0);
    }, r = function(a) {
      return "<![CDATA[" + n(a) + "]]>";
    }, n = function(a) {
      return a.replace("]]>", "]]]]><![CDATA[>");
    }, Jp.Builder = function() {
      function a(o) {
        var l, f, d;
        this.options = {}, f = t["0.2"];
        for (l in f)
          i.call(f, l) && (d = f[l], this.options[l] = d);
        for (l in o)
          i.call(o, l) && (d = o[l], this.options[l] = d);
      }
      return a.prototype.buildObject = function(o) {
        var l, f, d, u, c;
        return l = this.options.attrkey, f = this.options.charkey, Object.keys(o).length === 1 && this.options.rootName === t["0.2"].rootName ? (c = Object.keys(o)[0], o = o[c]) : c = this.options.rootName, d = function(h) {
          return function(p, g) {
            var m, v, y, E, C, x;
            if (typeof g != "object")
              h.options.cdata && s(g) ? p.raw(r(g)) : p.txt(g);
            else if (Array.isArray(g)) {
              for (E in g)
                if (i.call(g, E)) {
                  v = g[E];
                  for (C in v)
                    y = v[C], p = d(p.ele(C), y).up();
                }
            } else
              for (C in g)
                if (i.call(g, C))
                  if (v = g[C], C === l) {
                    if (typeof v == "object")
                      for (m in v)
                        x = v[m], p = p.att(m, x);
                  } else if (C === f)
                    h.options.cdata && s(v) ? p = p.raw(r(v)) : p = p.txt(v);
                  else if (Array.isArray(v))
                    for (E in v)
                      i.call(v, E) && (y = v[E], typeof y == "string" ? h.options.cdata && s(y) ? p = p.ele(C).raw(r(y)).up() : p = p.ele(C, y).up() : p = d(p.ele(C), y).up());
                  else
                    typeof v == "object" ? p = d(p.ele(C), v).up() : typeof v == "string" && h.options.cdata && s(v) ? p = p.ele(C).raw(r(v)).up() : (v == null && (v = ""), p = p.ele(C, v.toString()).up());
            return p;
          };
        }(this), u = e.create(c, this.options.xmldec, this.options.doctype, {
          headless: this.options.headless,
          allowSurrogateChars: this.options.allowSurrogateChars
        }), d(u, o).end(this.options.renderOpts);
      }, a;
    }();
  }).call(It)), Jp;
}
var Im = {}, Dm = {}, Vh = { exports: {} }, gb;
function np() {
  if (gb)
    return Vh.exports;
  gb = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(x, b, P) {
    return Function.prototype.apply.call(x, b, P);
  }, n;
  e && typeof e.ownKeys == "function" ? n = e.ownKeys : Object.getOwnPropertySymbols ? n = function(x) {
    return Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));
  } : n = function(x) {
    return Object.getOwnPropertyNames(x);
  };
  function s(C) {
    console && console.warn && console.warn(C);
  }
  var r = Number.isNaN || function(x) {
    return x !== x;
  };
  function i() {
    i.init.call(this);
  }
  Vh.exports = i, Vh.exports.once = v, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
  var a = 10;
  function o(C) {
    if (typeof C != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof C);
  }
  Object.defineProperty(i, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(C) {
      if (typeof C != "number" || C < 0 || r(C))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + C + ".");
      a = C;
    }
  }), i.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, i.prototype.setMaxListeners = function(x) {
    if (typeof x != "number" || x < 0 || r(x))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + x + ".");
    return this._maxListeners = x, this;
  };
  function l(C) {
    return C._maxListeners === void 0 ? i.defaultMaxListeners : C._maxListeners;
  }
  i.prototype.getMaxListeners = function() {
    return l(this);
  }, i.prototype.emit = function(x) {
    for (var b = [], P = 1; P < arguments.length; P++)
      b.push(arguments[P]);
    var O = x === "error", T = this._events;
    if (T !== void 0)
      O = O && T.error === void 0;
    else if (!O)
      return !1;
    if (O) {
      var M;
      if (b.length > 0 && (M = b[0]), M instanceof Error)
        throw M;
      var L = new Error("Unhandled error." + (M ? " (" + M.message + ")" : ""));
      throw L.context = M, L;
    }
    var A = T[x];
    if (A === void 0)
      return !1;
    if (typeof A == "function")
      t(A, this, b);
    else
      for (var D = A.length, I = p(A, D), P = 0; P < D; ++P)
        t(I[P], this, b);
    return !0;
  };
  function f(C, x, b, P) {
    var O, T, M;
    if (o(b), T = C._events, T === void 0 ? (T = C._events = /* @__PURE__ */ Object.create(null), C._eventsCount = 0) : (T.newListener !== void 0 && (C.emit(
      "newListener",
      x,
      b.listener ? b.listener : b
    ), T = C._events), M = T[x]), M === void 0)
      M = T[x] = b, ++C._eventsCount;
    else if (typeof M == "function" ? M = T[x] = P ? [b, M] : [M, b] : P ? M.unshift(b) : M.push(b), O = l(C), O > 0 && M.length > O && !M.warned) {
      M.warned = !0;
      var L = new Error("Possible EventEmitter memory leak detected. " + M.length + " " + String(x) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      L.name = "MaxListenersExceededWarning", L.emitter = C, L.type = x, L.count = M.length, s(L);
    }
    return C;
  }
  i.prototype.addListener = function(x, b) {
    return f(this, x, b, !1);
  }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(x, b) {
    return f(this, x, b, !0);
  };
  function d() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function u(C, x, b) {
    var P = { fired: !1, wrapFn: void 0, target: C, type: x, listener: b }, O = d.bind(P);
    return O.listener = b, P.wrapFn = O, O;
  }
  i.prototype.once = function(x, b) {
    return o(b), this.on(x, u(this, x, b)), this;
  }, i.prototype.prependOnceListener = function(x, b) {
    return o(b), this.prependListener(x, u(this, x, b)), this;
  }, i.prototype.removeListener = function(x, b) {
    var P, O, T, M, L;
    if (o(b), O = this._events, O === void 0)
      return this;
    if (P = O[x], P === void 0)
      return this;
    if (P === b || P.listener === b)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete O[x], O.removeListener && this.emit("removeListener", x, P.listener || b));
    else if (typeof P != "function") {
      for (T = -1, M = P.length - 1; M >= 0; M--)
        if (P[M] === b || P[M].listener === b) {
          L = P[M].listener, T = M;
          break;
        }
      if (T < 0)
        return this;
      T === 0 ? P.shift() : g(P, T), P.length === 1 && (O[x] = P[0]), O.removeListener !== void 0 && this.emit("removeListener", x, L || b);
    }
    return this;
  }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(x) {
    var b, P, O;
    if (P = this._events, P === void 0)
      return this;
    if (P.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : P[x] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete P[x]), this;
    if (arguments.length === 0) {
      var T = Object.keys(P), M;
      for (O = 0; O < T.length; ++O)
        M = T[O], M !== "removeListener" && this.removeAllListeners(M);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (b = P[x], typeof b == "function")
      this.removeListener(x, b);
    else if (b !== void 0)
      for (O = b.length - 1; O >= 0; O--)
        this.removeListener(x, b[O]);
    return this;
  };
  function c(C, x, b) {
    var P = C._events;
    if (P === void 0)
      return [];
    var O = P[x];
    return O === void 0 ? [] : typeof O == "function" ? b ? [O.listener || O] : [O] : b ? m(O) : p(O, O.length);
  }
  i.prototype.listeners = function(x) {
    return c(this, x, !0);
  }, i.prototype.rawListeners = function(x) {
    return c(this, x, !1);
  }, i.listenerCount = function(C, x) {
    return typeof C.listenerCount == "function" ? C.listenerCount(x) : h.call(C, x);
  }, i.prototype.listenerCount = h;
  function h(C) {
    var x = this._events;
    if (x !== void 0) {
      var b = x[C];
      if (typeof b == "function")
        return 1;
      if (b !== void 0)
        return b.length;
    }
    return 0;
  }
  i.prototype.eventNames = function() {
    return this._eventsCount > 0 ? n(this._events) : [];
  };
  function p(C, x) {
    for (var b = new Array(x), P = 0; P < x; ++P)
      b[P] = C[P];
    return b;
  }
  function g(C, x) {
    for (; x + 1 < C.length; x++)
      C[x] = C[x + 1];
    C.pop();
  }
  function m(C) {
    for (var x = new Array(C.length), b = 0; b < x.length; ++b)
      x[b] = C[b].listener || C[b];
    return x;
  }
  function v(C, x) {
    return new Promise(function(b, P) {
      function O(M) {
        C.removeListener(x, T), P(M);
      }
      function T() {
        typeof C.removeListener == "function" && C.removeListener("error", O), b([].slice.call(arguments));
      }
      E(C, x, T, { once: !0 }), x !== "error" && y(C, O, { once: !0 });
    });
  }
  function y(C, x, b) {
    typeof C.on == "function" && E(C, "error", x, b);
  }
  function E(C, x, b, P) {
    if (typeof C.on == "function")
      P.once ? C.once(x, b) : C.on(x, b);
    else if (typeof C.addEventListener == "function")
      C.addEventListener(x, function O(T) {
        P.once && C.removeEventListener(x, O), b(T);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof C);
  }
  return Vh.exports;
}
var Bh = { exports: {} }, vb;
function Tu() {
  return vb || (vb = 1, typeof Object.create == "function" ? Bh.exports = function(t, n) {
    n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Bh.exports = function(t, n) {
    if (n) {
      t.super_ = n;
      var s = function() {
      };
      s.prototype = n.prototype, t.prototype = new s(), t.prototype.constructor = t;
    }
  }), Bh.exports;
}
var Am, yb;
function CM() {
  return yb || (yb = 1, Am = np().EventEmitter), Am;
}
var Lm = {}, $u = {}, Eb;
function g5() {
  if (Eb)
    return $u;
  Eb = 1, $u.byteLength = o, $u.toByteArray = f, $u.fromByteArray = c;
  for (var e = [], t = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0, i = s.length; r < i; ++r)
    e[r] = s[r], t[s.charCodeAt(r)] = r;
  t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
  function a(h) {
    var p = h.length;
    if (p % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var g = h.indexOf("=");
    g === -1 && (g = p);
    var m = g === p ? 0 : 4 - g % 4;
    return [g, m];
  }
  function o(h) {
    var p = a(h), g = p[0], m = p[1];
    return (g + m) * 3 / 4 - m;
  }
  function l(h, p, g) {
    return (p + g) * 3 / 4 - g;
  }
  function f(h) {
    var p, g = a(h), m = g[0], v = g[1], y = new n(l(h, m, v)), E = 0, C = v > 0 ? m - 4 : m, x;
    for (x = 0; x < C; x += 4)
      p = t[h.charCodeAt(x)] << 18 | t[h.charCodeAt(x + 1)] << 12 | t[h.charCodeAt(x + 2)] << 6 | t[h.charCodeAt(x + 3)], y[E++] = p >> 16 & 255, y[E++] = p >> 8 & 255, y[E++] = p & 255;
    return v === 2 && (p = t[h.charCodeAt(x)] << 2 | t[h.charCodeAt(x + 1)] >> 4, y[E++] = p & 255), v === 1 && (p = t[h.charCodeAt(x)] << 10 | t[h.charCodeAt(x + 1)] << 4 | t[h.charCodeAt(x + 2)] >> 2, y[E++] = p >> 8 & 255, y[E++] = p & 255), y;
  }
  function d(h) {
    return e[h >> 18 & 63] + e[h >> 12 & 63] + e[h >> 6 & 63] + e[h & 63];
  }
  function u(h, p, g) {
    for (var m, v = [], y = p; y < g; y += 3)
      m = (h[y] << 16 & 16711680) + (h[y + 1] << 8 & 65280) + (h[y + 2] & 255), v.push(d(m));
    return v.join("");
  }
  function c(h) {
    for (var p, g = h.length, m = g % 3, v = [], y = 16383, E = 0, C = g - m; E < C; E += y)
      v.push(u(h, E, E + y > C ? C : E + y));
    return m === 1 ? (p = h[g - 1], v.push(
      e[p >> 2] + e[p << 4 & 63] + "=="
    )) : m === 2 && (p = (h[g - 2] << 8) + h[g - 1], v.push(
      e[p >> 10] + e[p >> 4 & 63] + e[p << 2 & 63] + "="
    )), v.join("");
  }
  return $u;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var Cb;
function ip() {
  return Cb || (Cb = 1, function(e) {
    var t = g5(), n = Kf, s = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = o, e.SlowBuffer = y, e.INSPECT_MAX_BYTES = 50;
    var r = 2147483647;
    e.kMaxLength = r, o.TYPED_ARRAY_SUPPORT = i(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function i() {
      try {
        var N = new Uint8Array(1), S = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(S, Uint8Array.prototype), Object.setPrototypeOf(N, S), N.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function a(N) {
      if (N > r)
        throw new RangeError('The value "' + N + '" is invalid for option "size"');
      var S = new Uint8Array(N);
      return Object.setPrototypeOf(S, o.prototype), S;
    }
    function o(N, S, _) {
      if (typeof N == "number") {
        if (typeof S == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return u(N);
      }
      return l(N, S, _);
    }
    o.poolSize = 8192;
    function l(N, S, _) {
      if (typeof N == "string")
        return c(N, S);
      if (ArrayBuffer.isView(N))
        return p(N);
      if (N == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
        );
      if (at(N, ArrayBuffer) || N && at(N.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (at(N, SharedArrayBuffer) || N && at(N.buffer, SharedArrayBuffer)))
        return g(N, S, _);
      if (typeof N == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var F = N.valueOf && N.valueOf();
      if (F != null && F !== N)
        return o.from(F, S, _);
      var G = m(N);
      if (G)
        return G;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof N[Symbol.toPrimitive] == "function")
        return o.from(
          N[Symbol.toPrimitive]("string"),
          S,
          _
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
      );
    }
    o.from = function(N, S, _) {
      return l(N, S, _);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function f(N) {
      if (typeof N != "number")
        throw new TypeError('"size" argument must be of type number');
      if (N < 0)
        throw new RangeError('The value "' + N + '" is invalid for option "size"');
    }
    function d(N, S, _) {
      return f(N), N <= 0 ? a(N) : S !== void 0 ? typeof _ == "string" ? a(N).fill(S, _) : a(N).fill(S) : a(N);
    }
    o.alloc = function(N, S, _) {
      return d(N, S, _);
    };
    function u(N) {
      return f(N), a(N < 0 ? 0 : v(N) | 0);
    }
    o.allocUnsafe = function(N) {
      return u(N);
    }, o.allocUnsafeSlow = function(N) {
      return u(N);
    };
    function c(N, S) {
      if ((typeof S != "string" || S === "") && (S = "utf8"), !o.isEncoding(S))
        throw new TypeError("Unknown encoding: " + S);
      var _ = E(N, S) | 0, F = a(_), G = F.write(N, S);
      return G !== _ && (F = F.slice(0, G)), F;
    }
    function h(N) {
      for (var S = N.length < 0 ? 0 : v(N.length) | 0, _ = a(S), F = 0; F < S; F += 1)
        _[F] = N[F] & 255;
      return _;
    }
    function p(N) {
      if (at(N, Uint8Array)) {
        var S = new Uint8Array(N);
        return g(S.buffer, S.byteOffset, S.byteLength);
      }
      return h(N);
    }
    function g(N, S, _) {
      if (S < 0 || N.byteLength < S)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (N.byteLength < S + (_ || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var F;
      return S === void 0 && _ === void 0 ? F = new Uint8Array(N) : _ === void 0 ? F = new Uint8Array(N, S) : F = new Uint8Array(N, S, _), Object.setPrototypeOf(F, o.prototype), F;
    }
    function m(N) {
      if (o.isBuffer(N)) {
        var S = v(N.length) | 0, _ = a(S);
        return _.length === 0 || N.copy(_, 0, 0, S), _;
      }
      if (N.length !== void 0)
        return typeof N.length != "number" || ct(N.length) ? a(0) : h(N);
      if (N.type === "Buffer" && Array.isArray(N.data))
        return h(N.data);
    }
    function v(N) {
      if (N >= r)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
      return N | 0;
    }
    function y(N) {
      return +N != N && (N = 0), o.alloc(+N);
    }
    o.isBuffer = function(S) {
      return S != null && S._isBuffer === !0 && S !== o.prototype;
    }, o.compare = function(S, _) {
      if (at(S, Uint8Array) && (S = o.from(S, S.offset, S.byteLength)), at(_, Uint8Array) && (_ = o.from(_, _.offset, _.byteLength)), !o.isBuffer(S) || !o.isBuffer(_))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (S === _)
        return 0;
      for (var F = S.length, G = _.length, nt = 0, lt = Math.min(F, G); nt < lt; ++nt)
        if (S[nt] !== _[nt]) {
          F = S[nt], G = _[nt];
          break;
        }
      return F < G ? -1 : G < F ? 1 : 0;
    }, o.isEncoding = function(S) {
      switch (String(S).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(S, _) {
      if (!Array.isArray(S))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (S.length === 0)
        return o.alloc(0);
      var F;
      if (_ === void 0)
        for (_ = 0, F = 0; F < S.length; ++F)
          _ += S[F].length;
      var G = o.allocUnsafe(_), nt = 0;
      for (F = 0; F < S.length; ++F) {
        var lt = S[F];
        if (at(lt, Uint8Array))
          nt + lt.length > G.length ? o.from(lt).copy(G, nt) : Uint8Array.prototype.set.call(
            G,
            lt,
            nt
          );
        else if (o.isBuffer(lt))
          lt.copy(G, nt);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        nt += lt.length;
      }
      return G;
    };
    function E(N, S) {
      if (o.isBuffer(N))
        return N.length;
      if (ArrayBuffer.isView(N) || at(N, ArrayBuffer))
        return N.byteLength;
      if (typeof N != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof N
        );
      var _ = N.length, F = arguments.length > 2 && arguments[2] === !0;
      if (!F && _ === 0)
        return 0;
      for (var G = !1; ; )
        switch (S) {
          case "ascii":
          case "latin1":
          case "binary":
            return _;
          case "utf8":
          case "utf-8":
            return V(N).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return _ * 2;
          case "hex":
            return _ >>> 1;
          case "base64":
            return W(N).length;
          default:
            if (G)
              return F ? -1 : V(N).length;
            S = ("" + S).toLowerCase(), G = !0;
        }
    }
    o.byteLength = E;
    function C(N, S, _) {
      var F = !1;
      if ((S === void 0 || S < 0) && (S = 0), S > this.length || ((_ === void 0 || _ > this.length) && (_ = this.length), _ <= 0) || (_ >>>= 0, S >>>= 0, _ <= S))
        return "";
      for (N || (N = "utf8"); ; )
        switch (N) {
          case "hex":
            return X(this, S, _);
          case "utf8":
          case "utf-8":
            return I(this, S, _);
          case "ascii":
            return j(this, S, _);
          case "latin1":
          case "binary":
            return k(this, S, _);
          case "base64":
            return D(this, S, _);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return rt(this, S, _);
          default:
            if (F)
              throw new TypeError("Unknown encoding: " + N);
            N = (N + "").toLowerCase(), F = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function x(N, S, _) {
      var F = N[S];
      N[S] = N[_], N[_] = F;
    }
    o.prototype.swap16 = function() {
      var S = this.length;
      if (S % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var _ = 0; _ < S; _ += 2)
        x(this, _, _ + 1);
      return this;
    }, o.prototype.swap32 = function() {
      var S = this.length;
      if (S % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var _ = 0; _ < S; _ += 4)
        x(this, _, _ + 3), x(this, _ + 1, _ + 2);
      return this;
    }, o.prototype.swap64 = function() {
      var S = this.length;
      if (S % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var _ = 0; _ < S; _ += 8)
        x(this, _, _ + 7), x(this, _ + 1, _ + 6), x(this, _ + 2, _ + 5), x(this, _ + 3, _ + 4);
      return this;
    }, o.prototype.toString = function() {
      var S = this.length;
      return S === 0 ? "" : arguments.length === 0 ? I(this, 0, S) : C.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(S) {
      if (!o.isBuffer(S))
        throw new TypeError("Argument must be a Buffer");
      return this === S ? !0 : o.compare(this, S) === 0;
    }, o.prototype.inspect = function() {
      var S = "", _ = e.INSPECT_MAX_BYTES;
      return S = this.toString("hex", 0, _).replace(/(.{2})/g, "$1 ").trim(), this.length > _ && (S += " ... "), "<Buffer " + S + ">";
    }, s && (o.prototype[s] = o.prototype.inspect), o.prototype.compare = function(S, _, F, G, nt) {
      if (at(S, Uint8Array) && (S = o.from(S, S.offset, S.byteLength)), !o.isBuffer(S))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof S
        );
      if (_ === void 0 && (_ = 0), F === void 0 && (F = S ? S.length : 0), G === void 0 && (G = 0), nt === void 0 && (nt = this.length), _ < 0 || F > S.length || G < 0 || nt > this.length)
        throw new RangeError("out of range index");
      if (G >= nt && _ >= F)
        return 0;
      if (G >= nt)
        return -1;
      if (_ >= F)
        return 1;
      if (_ >>>= 0, F >>>= 0, G >>>= 0, nt >>>= 0, this === S)
        return 0;
      for (var lt = nt - G, yt = F - _, Lt = Math.min(lt, yt), Ft = this.slice(G, nt), Jt = S.slice(_, F), J = 0; J < Lt; ++J)
        if (Ft[J] !== Jt[J]) {
          lt = Ft[J], yt = Jt[J];
          break;
        }
      return lt < yt ? -1 : yt < lt ? 1 : 0;
    };
    function b(N, S, _, F, G) {
      if (N.length === 0)
        return -1;
      if (typeof _ == "string" ? (F = _, _ = 0) : _ > 2147483647 ? _ = 2147483647 : _ < -2147483648 && (_ = -2147483648), _ = +_, ct(_) && (_ = G ? 0 : N.length - 1), _ < 0 && (_ = N.length + _), _ >= N.length) {
        if (G)
          return -1;
        _ = N.length - 1;
      } else if (_ < 0)
        if (G)
          _ = 0;
        else
          return -1;
      if (typeof S == "string" && (S = o.from(S, F)), o.isBuffer(S))
        return S.length === 0 ? -1 : P(N, S, _, F, G);
      if (typeof S == "number")
        return S = S & 255, typeof Uint8Array.prototype.indexOf == "function" ? G ? Uint8Array.prototype.indexOf.call(N, S, _) : Uint8Array.prototype.lastIndexOf.call(N, S, _) : P(N, [S], _, F, G);
      throw new TypeError("val must be string, number or Buffer");
    }
    function P(N, S, _, F, G) {
      var nt = 1, lt = N.length, yt = S.length;
      if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
        if (N.length < 2 || S.length < 2)
          return -1;
        nt = 2, lt /= 2, yt /= 2, _ /= 2;
      }
      function Lt(Ct, St) {
        return nt === 1 ? Ct[St] : Ct.readUInt16BE(St * nt);
      }
      var Ft;
      if (G) {
        var Jt = -1;
        for (Ft = _; Ft < lt; Ft++)
          if (Lt(N, Ft) === Lt(S, Jt === -1 ? 0 : Ft - Jt)) {
            if (Jt === -1 && (Jt = Ft), Ft - Jt + 1 === yt)
              return Jt * nt;
          } else
            Jt !== -1 && (Ft -= Ft - Jt), Jt = -1;
      } else
        for (_ + yt > lt && (_ = lt - yt), Ft = _; Ft >= 0; Ft--) {
          for (var J = !0, ft = 0; ft < yt; ft++)
            if (Lt(N, Ft + ft) !== Lt(S, ft)) {
              J = !1;
              break;
            }
          if (J)
            return Ft;
        }
      return -1;
    }
    o.prototype.includes = function(S, _, F) {
      return this.indexOf(S, _, F) !== -1;
    }, o.prototype.indexOf = function(S, _, F) {
      return b(this, S, _, F, !0);
    }, o.prototype.lastIndexOf = function(S, _, F) {
      return b(this, S, _, F, !1);
    };
    function O(N, S, _, F) {
      _ = Number(_) || 0;
      var G = N.length - _;
      F ? (F = Number(F), F > G && (F = G)) : F = G;
      var nt = S.length;
      F > nt / 2 && (F = nt / 2);
      for (var lt = 0; lt < F; ++lt) {
        var yt = parseInt(S.substr(lt * 2, 2), 16);
        if (ct(yt))
          return lt;
        N[_ + lt] = yt;
      }
      return lt;
    }
    function T(N, S, _, F) {
      return z(V(S, N.length - _), N, _, F);
    }
    function M(N, S, _, F) {
      return z(tt(S), N, _, F);
    }
    function L(N, S, _, F) {
      return z(W(S), N, _, F);
    }
    function A(N, S, _, F) {
      return z(Y(S, N.length - _), N, _, F);
    }
    o.prototype.write = function(S, _, F, G) {
      if (_ === void 0)
        G = "utf8", F = this.length, _ = 0;
      else if (F === void 0 && typeof _ == "string")
        G = _, F = this.length, _ = 0;
      else if (isFinite(_))
        _ = _ >>> 0, isFinite(F) ? (F = F >>> 0, G === void 0 && (G = "utf8")) : (G = F, F = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var nt = this.length - _;
      if ((F === void 0 || F > nt) && (F = nt), S.length > 0 && (F < 0 || _ < 0) || _ > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      G || (G = "utf8");
      for (var lt = !1; ; )
        switch (G) {
          case "hex":
            return O(this, S, _, F);
          case "utf8":
          case "utf-8":
            return T(this, S, _, F);
          case "ascii":
          case "latin1":
          case "binary":
            return M(this, S, _, F);
          case "base64":
            return L(this, S, _, F);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return A(this, S, _, F);
          default:
            if (lt)
              throw new TypeError("Unknown encoding: " + G);
            G = ("" + G).toLowerCase(), lt = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function D(N, S, _) {
      return S === 0 && _ === N.length ? t.fromByteArray(N) : t.fromByteArray(N.slice(S, _));
    }
    function I(N, S, _) {
      _ = Math.min(N.length, _);
      for (var F = [], G = S; G < _; ) {
        var nt = N[G], lt = null, yt = nt > 239 ? 4 : nt > 223 ? 3 : nt > 191 ? 2 : 1;
        if (G + yt <= _) {
          var Lt, Ft, Jt, J;
          switch (yt) {
            case 1:
              nt < 128 && (lt = nt);
              break;
            case 2:
              Lt = N[G + 1], (Lt & 192) === 128 && (J = (nt & 31) << 6 | Lt & 63, J > 127 && (lt = J));
              break;
            case 3:
              Lt = N[G + 1], Ft = N[G + 2], (Lt & 192) === 128 && (Ft & 192) === 128 && (J = (nt & 15) << 12 | (Lt & 63) << 6 | Ft & 63, J > 2047 && (J < 55296 || J > 57343) && (lt = J));
              break;
            case 4:
              Lt = N[G + 1], Ft = N[G + 2], Jt = N[G + 3], (Lt & 192) === 128 && (Ft & 192) === 128 && (Jt & 192) === 128 && (J = (nt & 15) << 18 | (Lt & 63) << 12 | (Ft & 63) << 6 | Jt & 63, J > 65535 && J < 1114112 && (lt = J));
          }
        }
        lt === null ? (lt = 65533, yt = 1) : lt > 65535 && (lt -= 65536, F.push(lt >>> 10 & 1023 | 55296), lt = 56320 | lt & 1023), F.push(lt), G += yt;
      }
      return B(F);
    }
    var w = 4096;
    function B(N) {
      var S = N.length;
      if (S <= w)
        return String.fromCharCode.apply(String, N);
      for (var _ = "", F = 0; F < S; )
        _ += String.fromCharCode.apply(
          String,
          N.slice(F, F += w)
        );
      return _;
    }
    function j(N, S, _) {
      var F = "";
      _ = Math.min(N.length, _);
      for (var G = S; G < _; ++G)
        F += String.fromCharCode(N[G] & 127);
      return F;
    }
    function k(N, S, _) {
      var F = "";
      _ = Math.min(N.length, _);
      for (var G = S; G < _; ++G)
        F += String.fromCharCode(N[G]);
      return F;
    }
    function X(N, S, _) {
      var F = N.length;
      (!S || S < 0) && (S = 0), (!_ || _ < 0 || _ > F) && (_ = F);
      for (var G = "", nt = S; nt < _; ++nt)
        G += Mt[N[nt]];
      return G;
    }
    function rt(N, S, _) {
      for (var F = N.slice(S, _), G = "", nt = 0; nt < F.length - 1; nt += 2)
        G += String.fromCharCode(F[nt] + F[nt + 1] * 256);
      return G;
    }
    o.prototype.slice = function(S, _) {
      var F = this.length;
      S = ~~S, _ = _ === void 0 ? F : ~~_, S < 0 ? (S += F, S < 0 && (S = 0)) : S > F && (S = F), _ < 0 ? (_ += F, _ < 0 && (_ = 0)) : _ > F && (_ = F), _ < S && (_ = S);
      var G = this.subarray(S, _);
      return Object.setPrototypeOf(G, o.prototype), G;
    };
    function et(N, S, _) {
      if (N % 1 !== 0 || N < 0)
        throw new RangeError("offset is not uint");
      if (N + S > _)
        throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(S, _, F) {
      S = S >>> 0, _ = _ >>> 0, F || et(S, _, this.length);
      for (var G = this[S], nt = 1, lt = 0; ++lt < _ && (nt *= 256); )
        G += this[S + lt] * nt;
      return G;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(S, _, F) {
      S = S >>> 0, _ = _ >>> 0, F || et(S, _, this.length);
      for (var G = this[S + --_], nt = 1; _ > 0 && (nt *= 256); )
        G += this[S + --_] * nt;
      return G;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(S, _) {
      return S = S >>> 0, _ || et(S, 1, this.length), this[S];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(S, _) {
      return S = S >>> 0, _ || et(S, 2, this.length), this[S] | this[S + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(S, _) {
      return S = S >>> 0, _ || et(S, 2, this.length), this[S] << 8 | this[S + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), (this[S] | this[S + 1] << 8 | this[S + 2] << 16) + this[S + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), this[S] * 16777216 + (this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3]);
    }, o.prototype.readIntLE = function(S, _, F) {
      S = S >>> 0, _ = _ >>> 0, F || et(S, _, this.length);
      for (var G = this[S], nt = 1, lt = 0; ++lt < _ && (nt *= 256); )
        G += this[S + lt] * nt;
      return nt *= 128, G >= nt && (G -= Math.pow(2, 8 * _)), G;
    }, o.prototype.readIntBE = function(S, _, F) {
      S = S >>> 0, _ = _ >>> 0, F || et(S, _, this.length);
      for (var G = _, nt = 1, lt = this[S + --G]; G > 0 && (nt *= 256); )
        lt += this[S + --G] * nt;
      return nt *= 128, lt >= nt && (lt -= Math.pow(2, 8 * _)), lt;
    }, o.prototype.readInt8 = function(S, _) {
      return S = S >>> 0, _ || et(S, 1, this.length), this[S] & 128 ? (255 - this[S] + 1) * -1 : this[S];
    }, o.prototype.readInt16LE = function(S, _) {
      S = S >>> 0, _ || et(S, 2, this.length);
      var F = this[S] | this[S + 1] << 8;
      return F & 32768 ? F | 4294901760 : F;
    }, o.prototype.readInt16BE = function(S, _) {
      S = S >>> 0, _ || et(S, 2, this.length);
      var F = this[S + 1] | this[S] << 8;
      return F & 32768 ? F | 4294901760 : F;
    }, o.prototype.readInt32LE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), this[S] | this[S + 1] << 8 | this[S + 2] << 16 | this[S + 3] << 24;
    }, o.prototype.readInt32BE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), this[S] << 24 | this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3];
    }, o.prototype.readFloatLE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), n.read(this, S, !0, 23, 4);
    }, o.prototype.readFloatBE = function(S, _) {
      return S = S >>> 0, _ || et(S, 4, this.length), n.read(this, S, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(S, _) {
      return S = S >>> 0, _ || et(S, 8, this.length), n.read(this, S, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(S, _) {
      return S = S >>> 0, _ || et(S, 8, this.length), n.read(this, S, !1, 52, 8);
    };
    function Z(N, S, _, F, G, nt) {
      if (!o.isBuffer(N))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (S > G || S < nt)
        throw new RangeError('"value" argument is out of bounds');
      if (_ + F > N.length)
        throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(S, _, F, G) {
      if (S = +S, _ = _ >>> 0, F = F >>> 0, !G) {
        var nt = Math.pow(2, 8 * F) - 1;
        Z(this, S, _, F, nt, 0);
      }
      var lt = 1, yt = 0;
      for (this[_] = S & 255; ++yt < F && (lt *= 256); )
        this[_ + yt] = S / lt & 255;
      return _ + F;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(S, _, F, G) {
      if (S = +S, _ = _ >>> 0, F = F >>> 0, !G) {
        var nt = Math.pow(2, 8 * F) - 1;
        Z(this, S, _, F, nt, 0);
      }
      var lt = F - 1, yt = 1;
      for (this[_ + lt] = S & 255; --lt >= 0 && (yt *= 256); )
        this[_ + lt] = S / yt & 255;
      return _ + F;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 1, 255, 0), this[_] = S & 255, _ + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 2, 65535, 0), this[_] = S & 255, this[_ + 1] = S >>> 8, _ + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 2, 65535, 0), this[_] = S >>> 8, this[_ + 1] = S & 255, _ + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 4, 4294967295, 0), this[_ + 3] = S >>> 24, this[_ + 2] = S >>> 16, this[_ + 1] = S >>> 8, this[_] = S & 255, _ + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 4, 4294967295, 0), this[_] = S >>> 24, this[_ + 1] = S >>> 16, this[_ + 2] = S >>> 8, this[_ + 3] = S & 255, _ + 4;
    }, o.prototype.writeIntLE = function(S, _, F, G) {
      if (S = +S, _ = _ >>> 0, !G) {
        var nt = Math.pow(2, 8 * F - 1);
        Z(this, S, _, F, nt - 1, -nt);
      }
      var lt = 0, yt = 1, Lt = 0;
      for (this[_] = S & 255; ++lt < F && (yt *= 256); )
        S < 0 && Lt === 0 && this[_ + lt - 1] !== 0 && (Lt = 1), this[_ + lt] = (S / yt >> 0) - Lt & 255;
      return _ + F;
    }, o.prototype.writeIntBE = function(S, _, F, G) {
      if (S = +S, _ = _ >>> 0, !G) {
        var nt = Math.pow(2, 8 * F - 1);
        Z(this, S, _, F, nt - 1, -nt);
      }
      var lt = F - 1, yt = 1, Lt = 0;
      for (this[_ + lt] = S & 255; --lt >= 0 && (yt *= 256); )
        S < 0 && Lt === 0 && this[_ + lt + 1] !== 0 && (Lt = 1), this[_ + lt] = (S / yt >> 0) - Lt & 255;
      return _ + F;
    }, o.prototype.writeInt8 = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 1, 127, -128), S < 0 && (S = 255 + S + 1), this[_] = S & 255, _ + 1;
    }, o.prototype.writeInt16LE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 2, 32767, -32768), this[_] = S & 255, this[_ + 1] = S >>> 8, _ + 2;
    }, o.prototype.writeInt16BE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 2, 32767, -32768), this[_] = S >>> 8, this[_ + 1] = S & 255, _ + 2;
    }, o.prototype.writeInt32LE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 4, 2147483647, -2147483648), this[_] = S & 255, this[_ + 1] = S >>> 8, this[_ + 2] = S >>> 16, this[_ + 3] = S >>> 24, _ + 4;
    }, o.prototype.writeInt32BE = function(S, _, F) {
      return S = +S, _ = _ >>> 0, F || Z(this, S, _, 4, 2147483647, -2147483648), S < 0 && (S = 4294967295 + S + 1), this[_] = S >>> 24, this[_ + 1] = S >>> 16, this[_ + 2] = S >>> 8, this[_ + 3] = S & 255, _ + 4;
    };
    function dt(N, S, _, F, G, nt) {
      if (_ + F > N.length)
        throw new RangeError("Index out of range");
      if (_ < 0)
        throw new RangeError("Index out of range");
    }
    function vt(N, S, _, F, G) {
      return S = +S, _ = _ >>> 0, G || dt(N, S, _, 4), n.write(N, S, _, F, 23, 4), _ + 4;
    }
    o.prototype.writeFloatLE = function(S, _, F) {
      return vt(this, S, _, !0, F);
    }, o.prototype.writeFloatBE = function(S, _, F) {
      return vt(this, S, _, !1, F);
    };
    function bt(N, S, _, F, G) {
      return S = +S, _ = _ >>> 0, G || dt(N, S, _, 8), n.write(N, S, _, F, 52, 8), _ + 8;
    }
    o.prototype.writeDoubleLE = function(S, _, F) {
      return bt(this, S, _, !0, F);
    }, o.prototype.writeDoubleBE = function(S, _, F) {
      return bt(this, S, _, !1, F);
    }, o.prototype.copy = function(S, _, F, G) {
      if (!o.isBuffer(S))
        throw new TypeError("argument should be a Buffer");
      if (F || (F = 0), !G && G !== 0 && (G = this.length), _ >= S.length && (_ = S.length), _ || (_ = 0), G > 0 && G < F && (G = F), G === F || S.length === 0 || this.length === 0)
        return 0;
      if (_ < 0)
        throw new RangeError("targetStart out of bounds");
      if (F < 0 || F >= this.length)
        throw new RangeError("Index out of range");
      if (G < 0)
        throw new RangeError("sourceEnd out of bounds");
      G > this.length && (G = this.length), S.length - _ < G - F && (G = S.length - _ + F);
      var nt = G - F;
      return this === S && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(_, F, G) : Uint8Array.prototype.set.call(
        S,
        this.subarray(F, G),
        _
      ), nt;
    }, o.prototype.fill = function(S, _, F, G) {
      if (typeof S == "string") {
        if (typeof _ == "string" ? (G = _, _ = 0, F = this.length) : typeof F == "string" && (G = F, F = this.length), G !== void 0 && typeof G != "string")
          throw new TypeError("encoding must be a string");
        if (typeof G == "string" && !o.isEncoding(G))
          throw new TypeError("Unknown encoding: " + G);
        if (S.length === 1) {
          var nt = S.charCodeAt(0);
          (G === "utf8" && nt < 128 || G === "latin1") && (S = nt);
        }
      } else
        typeof S == "number" ? S = S & 255 : typeof S == "boolean" && (S = Number(S));
      if (_ < 0 || this.length < _ || this.length < F)
        throw new RangeError("Out of range index");
      if (F <= _)
        return this;
      _ = _ >>> 0, F = F === void 0 ? this.length : F >>> 0, S || (S = 0);
      var lt;
      if (typeof S == "number")
        for (lt = _; lt < F; ++lt)
          this[lt] = S;
      else {
        var yt = o.isBuffer(S) ? S : o.from(S, G), Lt = yt.length;
        if (Lt === 0)
          throw new TypeError('The value "' + S + '" is invalid for argument "value"');
        for (lt = 0; lt < F - _; ++lt)
          this[lt + _] = yt[lt % Lt];
      }
      return this;
    };
    var it = /[^+/0-9A-Za-z-_]/g;
    function R(N) {
      if (N = N.split("=")[0], N = N.trim().replace(it, ""), N.length < 2)
        return "";
      for (; N.length % 4 !== 0; )
        N = N + "=";
      return N;
    }
    function V(N, S) {
      S = S || 1 / 0;
      for (var _, F = N.length, G = null, nt = [], lt = 0; lt < F; ++lt) {
        if (_ = N.charCodeAt(lt), _ > 55295 && _ < 57344) {
          if (!G) {
            if (_ > 56319) {
              (S -= 3) > -1 && nt.push(239, 191, 189);
              continue;
            } else if (lt + 1 === F) {
              (S -= 3) > -1 && nt.push(239, 191, 189);
              continue;
            }
            G = _;
            continue;
          }
          if (_ < 56320) {
            (S -= 3) > -1 && nt.push(239, 191, 189), G = _;
            continue;
          }
          _ = (G - 55296 << 10 | _ - 56320) + 65536;
        } else
          G && (S -= 3) > -1 && nt.push(239, 191, 189);
        if (G = null, _ < 128) {
          if ((S -= 1) < 0)
            break;
          nt.push(_);
        } else if (_ < 2048) {
          if ((S -= 2) < 0)
            break;
          nt.push(
            _ >> 6 | 192,
            _ & 63 | 128
          );
        } else if (_ < 65536) {
          if ((S -= 3) < 0)
            break;
          nt.push(
            _ >> 12 | 224,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else if (_ < 1114112) {
          if ((S -= 4) < 0)
            break;
          nt.push(
            _ >> 18 | 240,
            _ >> 12 & 63 | 128,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return nt;
    }
    function tt(N) {
      for (var S = [], _ = 0; _ < N.length; ++_)
        S.push(N.charCodeAt(_) & 255);
      return S;
    }
    function Y(N, S) {
      for (var _, F, G, nt = [], lt = 0; lt < N.length && !((S -= 2) < 0); ++lt)
        _ = N.charCodeAt(lt), F = _ >> 8, G = _ % 256, nt.push(G), nt.push(F);
      return nt;
    }
    function W(N) {
      return t.toByteArray(R(N));
    }
    function z(N, S, _, F) {
      for (var G = 0; G < F && !(G + _ >= S.length || G >= N.length); ++G)
        S[G + _] = N[G];
      return G;
    }
    function at(N, S) {
      return N instanceof S || N != null && N.constructor != null && N.constructor.name != null && N.constructor.name === S.name;
    }
    function ct(N) {
      return N !== N;
    }
    var Mt = function() {
      for (var N = "0123456789abcdef", S = new Array(256), _ = 0; _ < 16; ++_)
        for (var F = _ * 16, G = 0; G < 16; ++G)
          S[F + G] = N[_] + N[G];
      return S;
    }();
  }(Lm)), Lm;
}
const v5 = {}, y5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: v5
}, Symbol.toStringTag, { value: "Module" })), xM = /* @__PURE__ */ gS(y5);
var Rm, xb;
function E5() {
  if (xb)
    return Rm;
  xb = 1;
  function e(p, g) {
    var m = Object.keys(p);
    if (Object.getOwnPropertySymbols) {
      var v = Object.getOwnPropertySymbols(p);
      g && (v = v.filter(function(y) {
        return Object.getOwnPropertyDescriptor(p, y).enumerable;
      })), m.push.apply(m, v);
    }
    return m;
  }
  function t(p) {
    for (var g = 1; g < arguments.length; g++) {
      var m = arguments[g] != null ? arguments[g] : {};
      g % 2 ? e(Object(m), !0).forEach(function(v) {
        n(p, v, m[v]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(p, Object.getOwnPropertyDescriptors(m)) : e(Object(m)).forEach(function(v) {
        Object.defineProperty(p, v, Object.getOwnPropertyDescriptor(m, v));
      });
    }
    return p;
  }
  function n(p, g, m) {
    return g = a(g), g in p ? Object.defineProperty(p, g, { value: m, enumerable: !0, configurable: !0, writable: !0 }) : p[g] = m, p;
  }
  function s(p, g) {
    if (!(p instanceof g))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(p, g) {
    for (var m = 0; m < g.length; m++) {
      var v = g[m];
      v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(p, a(v.key), v);
    }
  }
  function i(p, g, m) {
    return g && r(p.prototype, g), m && r(p, m), Object.defineProperty(p, "prototype", { writable: !1 }), p;
  }
  function a(p) {
    var g = o(p, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function o(p, g) {
    if (typeof p != "object" || p === null)
      return p;
    var m = p[Symbol.toPrimitive];
    if (m !== void 0) {
      var v = m.call(p, g || "default");
      if (typeof v != "object")
        return v;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(p);
  }
  var l = ip(), f = l.Buffer, d = xM, u = d.inspect, c = u && u.custom || "inspect";
  function h(p, g, m) {
    f.prototype.copy.call(p, g, m);
  }
  return Rm = /* @__PURE__ */ function() {
    function p() {
      s(this, p), this.head = null, this.tail = null, this.length = 0;
    }
    return i(p, [{
      key: "push",
      value: function(m) {
        var v = {
          data: m,
          next: null
        };
        this.length > 0 ? this.tail.next = v : this.head = v, this.tail = v, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(m) {
        var v = {
          data: m,
          next: this.head
        };
        this.length === 0 && (this.tail = v), this.head = v, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var m = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, m;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(m) {
        if (this.length === 0)
          return "";
        for (var v = this.head, y = "" + v.data; v = v.next; )
          y += m + v.data;
        return y;
      }
    }, {
      key: "concat",
      value: function(m) {
        if (this.length === 0)
          return f.alloc(0);
        for (var v = f.allocUnsafe(m >>> 0), y = this.head, E = 0; y; )
          h(y.data, v, E), E += y.data.length, y = y.next;
        return v;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(m, v) {
        var y;
        return m < this.head.data.length ? (y = this.head.data.slice(0, m), this.head.data = this.head.data.slice(m)) : m === this.head.data.length ? y = this.shift() : y = v ? this._getString(m) : this._getBuffer(m), y;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(m) {
        var v = this.head, y = 1, E = v.data;
        for (m -= E.length; v = v.next; ) {
          var C = v.data, x = m > C.length ? C.length : m;
          if (x === C.length ? E += C : E += C.slice(0, m), m -= x, m === 0) {
            x === C.length ? (++y, v.next ? this.head = v.next : this.head = this.tail = null) : (this.head = v, v.data = C.slice(x));
            break;
          }
          ++y;
        }
        return this.length -= y, E;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(m) {
        var v = f.allocUnsafe(m), y = this.head, E = 1;
        for (y.data.copy(v), m -= y.data.length; y = y.next; ) {
          var C = y.data, x = m > C.length ? C.length : m;
          if (C.copy(v, v.length - m, 0, x), m -= x, m === 0) {
            x === C.length ? (++E, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = C.slice(x));
            break;
          }
          ++E;
        }
        return this.length -= E, v;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: c,
      value: function(m, v) {
        return u(this, t(t({}, v), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), p;
  }(), Rm;
}
var wm, bb;
function bM() {
  if (bb)
    return wm;
  bb = 1;
  function e(a, o) {
    var l = this, f = this._readableState && this._readableState.destroyed, d = this._writableState && this._writableState.destroyed;
    return f || d ? (o ? o(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(r, this, a)) : process.nextTick(r, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(u) {
      !o && u ? l._writableState ? l._writableState.errorEmitted ? process.nextTick(n, l) : (l._writableState.errorEmitted = !0, process.nextTick(t, l, u)) : process.nextTick(t, l, u) : o ? (process.nextTick(n, l), o(u)) : process.nextTick(n, l);
    }), this);
  }
  function t(a, o) {
    r(a, o), n(a);
  }
  function n(a) {
    a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
  }
  function s() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(a, o) {
    a.emit("error", o);
  }
  function i(a, o) {
    var l = a._readableState, f = a._writableState;
    l && l.autoDestroy || f && f.autoDestroy ? a.destroy(o) : a.emit("error", o);
  }
  return wm = {
    destroy: e,
    undestroy: s,
    errorOrDestroy: i
  }, wm;
}
var Vm = {}, Tb;
function Ou() {
  if (Tb)
    return Vm;
  Tb = 1;
  function e(o, l) {
    o.prototype = Object.create(l.prototype), o.prototype.constructor = o, o.__proto__ = l;
  }
  var t = {};
  function n(o, l, f) {
    f || (f = Error);
    function d(c, h, p) {
      return typeof l == "string" ? l : l(c, h, p);
    }
    var u = /* @__PURE__ */ function(c) {
      e(h, c);
      function h(p, g, m) {
        return c.call(this, d(p, g, m)) || this;
      }
      return h;
    }(f);
    u.prototype.name = f.name, u.prototype.code = o, t[o] = u;
  }
  function s(o, l) {
    if (Array.isArray(o)) {
      var f = o.length;
      return o = o.map(function(d) {
        return String(d);
      }), f > 2 ? "one of ".concat(l, " ").concat(o.slice(0, f - 1).join(", "), ", or ") + o[f - 1] : f === 2 ? "one of ".concat(l, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(l, " ").concat(o[0]);
    } else
      return "of ".concat(l, " ").concat(String(o));
  }
  function r(o, l, f) {
    return o.substr(!f || f < 0 ? 0 : +f, l.length) === l;
  }
  function i(o, l, f) {
    return (f === void 0 || f > o.length) && (f = o.length), o.substring(f - l.length, f) === l;
  }
  function a(o, l, f) {
    return typeof f != "number" && (f = 0), f + l.length > o.length ? !1 : o.indexOf(l, f) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(o, l) {
    return 'The value "' + l + '" is invalid for option "' + o + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(o, l, f) {
    var d;
    typeof l == "string" && r(l, "not ") ? (d = "must not be", l = l.replace(/^not /, "")) : d = "must be";
    var u;
    if (i(o, " argument"))
      u = "The ".concat(o, " ").concat(d, " ").concat(s(l, "type"));
    else {
      var c = a(o, ".") ? "property" : "argument";
      u = 'The "'.concat(o, '" ').concat(c, " ").concat(d, " ").concat(s(l, "type"));
    }
    return u += ". Received type ".concat(typeof f), u;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Vm.codes = t, Vm;
}
var Bm, Ob;
function TM() {
  if (Ob)
    return Bm;
  Ob = 1;
  var e = Ou().codes.ERR_INVALID_OPT_VALUE;
  function t(s, r, i) {
    return s.highWaterMark != null ? s.highWaterMark : r ? s[i] : null;
  }
  function n(s, r, i, a) {
    var o = t(r, a, i);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var l = a ? i : "highWaterMark";
        throw new e(l, o);
      }
      return Math.floor(o);
    }
    return s.objectMode ? 16 : 16 * 1024;
  }
  return Bm = {
    getHighWaterMark: n
  }, Bm;
}
var Fm, Pb;
function C5() {
  if (Pb)
    return Fm;
  Pb = 1, Fm = e;
  function e(n, s) {
    if (t("noDeprecation"))
      return n;
    var r = !1;
    function i() {
      if (!r) {
        if (t("throwDeprecation"))
          throw new Error(s);
        t("traceDeprecation") ? console.trace(s) : console.warn(s), r = !0;
      }
      return n.apply(this, arguments);
    }
    return i;
  }
  function t(n) {
    try {
      if (!It.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var s = It.localStorage[n];
    return s == null ? !1 : String(s).toLowerCase() === "true";
  }
  return Fm;
}
var Nm, Sb;
function OM() {
  if (Sb)
    return Nm;
  Sb = 1, Nm = O;
  function e(it) {
    var R = this;
    this.next = null, this.entry = null, this.finish = function() {
      bt(R, it);
    };
  }
  var t;
  O.WritableState = b;
  var n = {
    deprecate: C5()
  }, s = CM(), r = ip().Buffer, i = (typeof It < "u" ? It : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(it) {
    return r.from(it);
  }
  function o(it) {
    return r.isBuffer(it) || it instanceof i;
  }
  var l = bM(), f = TM(), d = f.getHighWaterMark, u = Ou().codes, c = u.ERR_INVALID_ARG_TYPE, h = u.ERR_METHOD_NOT_IMPLEMENTED, p = u.ERR_MULTIPLE_CALLBACK, g = u.ERR_STREAM_CANNOT_PIPE, m = u.ERR_STREAM_DESTROYED, v = u.ERR_STREAM_NULL_VALUES, y = u.ERR_STREAM_WRITE_AFTER_END, E = u.ERR_UNKNOWN_ENCODING, C = l.errorOrDestroy;
  Tu()(O, s);
  function x() {
  }
  function b(it, R, V) {
    t = t || au(), it = it || {}, typeof V != "boolean" && (V = R instanceof t), this.objectMode = !!it.objectMode, V && (this.objectMode = this.objectMode || !!it.writableObjectMode), this.highWaterMark = d(this, it, "writableHighWaterMark", V), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var tt = it.decodeStrings === !1;
    this.decodeStrings = !tt, this.defaultEncoding = it.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Y) {
      B(R, Y);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = it.emitClose !== !1, this.autoDestroy = !!it.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  b.prototype.getBuffer = function() {
    for (var R = this.bufferedRequest, V = []; R; )
      V.push(R), R = R.next;
    return V;
  }, function() {
    try {
      Object.defineProperty(b.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var P;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (P = Function.prototype[Symbol.hasInstance], Object.defineProperty(O, Symbol.hasInstance, {
    value: function(R) {
      return P.call(this, R) ? !0 : this !== O ? !1 : R && R._writableState instanceof b;
    }
  })) : P = function(R) {
    return R instanceof this;
  };
  function O(it) {
    t = t || au();
    var R = this instanceof t;
    if (!R && !P.call(O, this))
      return new O(it);
    this._writableState = new b(it, this, R), this.writable = !0, it && (typeof it.write == "function" && (this._write = it.write), typeof it.writev == "function" && (this._writev = it.writev), typeof it.destroy == "function" && (this._destroy = it.destroy), typeof it.final == "function" && (this._final = it.final)), s.call(this);
  }
  O.prototype.pipe = function() {
    C(this, new g());
  };
  function T(it, R) {
    var V = new y();
    C(it, V), process.nextTick(R, V);
  }
  function M(it, R, V, tt) {
    var Y;
    return V === null ? Y = new v() : typeof V != "string" && !R.objectMode && (Y = new c("chunk", ["string", "Buffer"], V)), Y ? (C(it, Y), process.nextTick(tt, Y), !1) : !0;
  }
  O.prototype.write = function(it, R, V) {
    var tt = this._writableState, Y = !1, W = !tt.objectMode && o(it);
    return W && !r.isBuffer(it) && (it = a(it)), typeof R == "function" && (V = R, R = null), W ? R = "buffer" : R || (R = tt.defaultEncoding), typeof V != "function" && (V = x), tt.ending ? T(this, V) : (W || M(this, tt, it, V)) && (tt.pendingcb++, Y = A(this, tt, W, it, R, V)), Y;
  }, O.prototype.cork = function() {
    this._writableState.corked++;
  }, O.prototype.uncork = function() {
    var it = this._writableState;
    it.corked && (it.corked--, !it.writing && !it.corked && !it.bufferProcessing && it.bufferedRequest && X(this, it));
  }, O.prototype.setDefaultEncoding = function(R) {
    if (typeof R == "string" && (R = R.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((R + "").toLowerCase()) > -1))
      throw new E(R);
    return this._writableState.defaultEncoding = R, this;
  }, Object.defineProperty(O.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function L(it, R, V) {
    return !it.objectMode && it.decodeStrings !== !1 && typeof R == "string" && (R = r.from(R, V)), R;
  }
  Object.defineProperty(O.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function A(it, R, V, tt, Y, W) {
    if (!V) {
      var z = L(R, tt, Y);
      tt !== z && (V = !0, Y = "buffer", tt = z);
    }
    var at = R.objectMode ? 1 : tt.length;
    R.length += at;
    var ct = R.length < R.highWaterMark;
    if (ct || (R.needDrain = !0), R.writing || R.corked) {
      var Mt = R.lastBufferedRequest;
      R.lastBufferedRequest = {
        chunk: tt,
        encoding: Y,
        isBuf: V,
        callback: W,
        next: null
      }, Mt ? Mt.next = R.lastBufferedRequest : R.bufferedRequest = R.lastBufferedRequest, R.bufferedRequestCount += 1;
    } else
      D(it, R, !1, at, tt, Y, W);
    return ct;
  }
  function D(it, R, V, tt, Y, W, z) {
    R.writelen = tt, R.writecb = z, R.writing = !0, R.sync = !0, R.destroyed ? R.onwrite(new m("write")) : V ? it._writev(Y, R.onwrite) : it._write(Y, W, R.onwrite), R.sync = !1;
  }
  function I(it, R, V, tt, Y) {
    --R.pendingcb, V ? (process.nextTick(Y, tt), process.nextTick(dt, it, R), it._writableState.errorEmitted = !0, C(it, tt)) : (Y(tt), it._writableState.errorEmitted = !0, C(it, tt), dt(it, R));
  }
  function w(it) {
    it.writing = !1, it.writecb = null, it.length -= it.writelen, it.writelen = 0;
  }
  function B(it, R) {
    var V = it._writableState, tt = V.sync, Y = V.writecb;
    if (typeof Y != "function")
      throw new p();
    if (w(V), R)
      I(it, V, tt, R, Y);
    else {
      var W = rt(V) || it.destroyed;
      !W && !V.corked && !V.bufferProcessing && V.bufferedRequest && X(it, V), tt ? process.nextTick(j, it, V, W, Y) : j(it, V, W, Y);
    }
  }
  function j(it, R, V, tt) {
    V || k(it, R), R.pendingcb--, tt(), dt(it, R);
  }
  function k(it, R) {
    R.length === 0 && R.needDrain && (R.needDrain = !1, it.emit("drain"));
  }
  function X(it, R) {
    R.bufferProcessing = !0;
    var V = R.bufferedRequest;
    if (it._writev && V && V.next) {
      var tt = R.bufferedRequestCount, Y = new Array(tt), W = R.corkedRequestsFree;
      W.entry = V;
      for (var z = 0, at = !0; V; )
        Y[z] = V, V.isBuf || (at = !1), V = V.next, z += 1;
      Y.allBuffers = at, D(it, R, !0, R.length, Y, "", W.finish), R.pendingcb++, R.lastBufferedRequest = null, W.next ? (R.corkedRequestsFree = W.next, W.next = null) : R.corkedRequestsFree = new e(R), R.bufferedRequestCount = 0;
    } else {
      for (; V; ) {
        var ct = V.chunk, Mt = V.encoding, N = V.callback, S = R.objectMode ? 1 : ct.length;
        if (D(it, R, !1, S, ct, Mt, N), V = V.next, R.bufferedRequestCount--, R.writing)
          break;
      }
      V === null && (R.lastBufferedRequest = null);
    }
    R.bufferedRequest = V, R.bufferProcessing = !1;
  }
  O.prototype._write = function(it, R, V) {
    V(new h("_write()"));
  }, O.prototype._writev = null, O.prototype.end = function(it, R, V) {
    var tt = this._writableState;
    return typeof it == "function" ? (V = it, it = null, R = null) : typeof R == "function" && (V = R, R = null), it != null && this.write(it, R), tt.corked && (tt.corked = 1, this.uncork()), tt.ending || vt(this, tt, V), this;
  }, Object.defineProperty(O.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function rt(it) {
    return it.ending && it.length === 0 && it.bufferedRequest === null && !it.finished && !it.writing;
  }
  function et(it, R) {
    it._final(function(V) {
      R.pendingcb--, V && C(it, V), R.prefinished = !0, it.emit("prefinish"), dt(it, R);
    });
  }
  function Z(it, R) {
    !R.prefinished && !R.finalCalled && (typeof it._final == "function" && !R.destroyed ? (R.pendingcb++, R.finalCalled = !0, process.nextTick(et, it, R)) : (R.prefinished = !0, it.emit("prefinish")));
  }
  function dt(it, R) {
    var V = rt(R);
    if (V && (Z(it, R), R.pendingcb === 0 && (R.finished = !0, it.emit("finish"), R.autoDestroy))) {
      var tt = it._readableState;
      (!tt || tt.autoDestroy && tt.endEmitted) && it.destroy();
    }
    return V;
  }
  function vt(it, R, V) {
    R.ending = !0, dt(it, R), V && (R.finished ? process.nextTick(V) : it.once("finish", V)), R.ended = !0, it.writable = !1;
  }
  function bt(it, R, V) {
    var tt = it.entry;
    for (it.entry = null; tt; ) {
      var Y = tt.callback;
      R.pendingcb--, Y(V), tt = tt.next;
    }
    R.corkedRequestsFree.next = it;
  }
  return Object.defineProperty(O.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(R) {
      this._writableState && (this._writableState.destroyed = R);
    }
  }), O.prototype.destroy = l.destroy, O.prototype._undestroy = l.undestroy, O.prototype._destroy = function(it, R) {
    R(it);
  }, Nm;
}
var jm, Mb;
function au() {
  if (Mb)
    return jm;
  Mb = 1;
  var e = Object.keys || function(f) {
    var d = [];
    for (var u in f)
      d.push(u);
    return d;
  };
  jm = a;
  var t = PM(), n = OM();
  Tu()(a, t);
  for (var s = e(n.prototype), r = 0; r < s.length; r++) {
    var i = s[r];
    a.prototype[i] || (a.prototype[i] = n.prototype[i]);
  }
  function a(f) {
    if (!(this instanceof a))
      return new a(f);
    t.call(this, f), n.call(this, f), this.allowHalfOpen = !0, f && (f.readable === !1 && (this.readable = !1), f.writable === !1 && (this.writable = !1), f.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(f) {
    f.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(d) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = d, this._writableState.destroyed = d);
    }
  }), jm;
}
var $m = {}, Fh = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var _b;
function x5() {
  return _b || (_b = 1, function(e, t) {
    var n = ip(), s = n.Buffer;
    function r(a, o) {
      for (var l in a)
        o[l] = a[l];
    }
    s.from && s.alloc && s.allocUnsafe && s.allocUnsafeSlow ? e.exports = n : (r(n, t), t.Buffer = i);
    function i(a, o, l) {
      return s(a, o, l);
    }
    i.prototype = Object.create(s.prototype), r(s, i), i.from = function(a, o, l) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return s(a, o, l);
    }, i.alloc = function(a, o, l) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var f = s(a);
      return o !== void 0 ? typeof l == "string" ? f.fill(o, l) : f.fill(o) : f.fill(0), f;
    }, i.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return s(a);
    }, i.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(a);
    };
  }(Fh, Fh.exports)), Fh.exports;
}
var Ib;
function yv() {
  if (Ib)
    return $m;
  Ib = 1;
  var e = x5().Buffer, t = e.isEncoding || function(v) {
    switch (v = "" + v, v && v.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(v) {
    if (!v)
      return "utf8";
    for (var y; ; )
      switch (v) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return v;
        default:
          if (y)
            return;
          v = ("" + v).toLowerCase(), y = !0;
      }
  }
  function s(v) {
    var y = n(v);
    if (typeof y != "string" && (e.isEncoding === t || !t(v)))
      throw new Error("Unknown encoding: " + v);
    return y || v;
  }
  $m.StringDecoder = r;
  function r(v) {
    this.encoding = s(v);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = u, this.end = c, y = 4;
        break;
      case "utf8":
        this.fillLast = l, y = 4;
        break;
      case "base64":
        this.text = h, this.end = p, y = 3;
        break;
      default:
        this.write = g, this.end = m;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(y);
  }
  r.prototype.write = function(v) {
    if (v.length === 0)
      return "";
    var y, E;
    if (this.lastNeed) {
      if (y = this.fillLast(v), y === void 0)
        return "";
      E = this.lastNeed, this.lastNeed = 0;
    } else
      E = 0;
    return E < v.length ? y ? y + this.text(v, E) : this.text(v, E) : y || "";
  }, r.prototype.end = d, r.prototype.text = f, r.prototype.fillLast = function(v) {
    if (this.lastNeed <= v.length)
      return v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, v.length), this.lastNeed -= v.length;
  };
  function i(v) {
    return v <= 127 ? 0 : v >> 5 === 6 ? 2 : v >> 4 === 14 ? 3 : v >> 3 === 30 ? 4 : v >> 6 === 2 ? -1 : -2;
  }
  function a(v, y, E) {
    var C = y.length - 1;
    if (C < E)
      return 0;
    var x = i(y[C]);
    return x >= 0 ? (x > 0 && (v.lastNeed = x - 1), x) : --C < E || x === -2 ? 0 : (x = i(y[C]), x >= 0 ? (x > 0 && (v.lastNeed = x - 2), x) : --C < E || x === -2 ? 0 : (x = i(y[C]), x >= 0 ? (x > 0 && (x === 2 ? x = 0 : v.lastNeed = x - 3), x) : 0));
  }
  function o(v, y, E) {
    if ((y[0] & 192) !== 128)
      return v.lastNeed = 0, "";
    if (v.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return v.lastNeed = 1, "";
      if (v.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return v.lastNeed = 2, "";
    }
  }
  function l(v) {
    var y = this.lastTotal - this.lastNeed, E = o(this, v);
    if (E !== void 0)
      return E;
    if (this.lastNeed <= v.length)
      return v.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    v.copy(this.lastChar, y, 0, v.length), this.lastNeed -= v.length;
  }
  function f(v, y) {
    var E = a(this, v, y);
    if (!this.lastNeed)
      return v.toString("utf8", y);
    this.lastTotal = E;
    var C = v.length - (E - this.lastNeed);
    return v.copy(this.lastChar, 0, C), v.toString("utf8", y, C);
  }
  function d(v) {
    var y = v && v.length ? this.write(v) : "";
    return this.lastNeed ? y + "" : y;
  }
  function u(v, y) {
    if ((v.length - y) % 2 === 0) {
      var E = v.toString("utf16le", y);
      if (E) {
        var C = E.charCodeAt(E.length - 1);
        if (C >= 55296 && C <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1], E.slice(0, -1);
      }
      return E;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = v[v.length - 1], v.toString("utf16le", y, v.length - 1);
  }
  function c(v) {
    var y = v && v.length ? this.write(v) : "";
    if (this.lastNeed) {
      var E = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, E);
    }
    return y;
  }
  function h(v, y) {
    var E = (v.length - y) % 3;
    return E === 0 ? v.toString("base64", y) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = v[v.length - 1] : (this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1]), v.toString("base64", y, v.length - E));
  }
  function p(v) {
    var y = v && v.length ? this.write(v) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function g(v) {
    return v.toString(this.encoding);
  }
  function m(v) {
    return v && v.length ? this.write(v) : "";
  }
  return $m;
}
var Um, Db;
function Q0() {
  if (Db)
    return Um;
  Db = 1;
  var e = Ou().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(i) {
    var a = !1;
    return function() {
      if (!a) {
        a = !0;
        for (var o = arguments.length, l = new Array(o), f = 0; f < o; f++)
          l[f] = arguments[f];
        i.apply(this, l);
      }
    };
  }
  function n() {
  }
  function s(i) {
    return i.setHeader && typeof i.abort == "function";
  }
  function r(i, a, o) {
    if (typeof a == "function")
      return r(i, null, a);
    a || (a = {}), o = t(o || n);
    var l = a.readable || a.readable !== !1 && i.readable, f = a.writable || a.writable !== !1 && i.writable, d = function() {
      i.writable || c();
    }, u = i._writableState && i._writableState.finished, c = function() {
      f = !1, u = !0, l || o.call(i);
    }, h = i._readableState && i._readableState.endEmitted, p = function() {
      l = !1, h = !0, f || o.call(i);
    }, g = function(E) {
      o.call(i, E);
    }, m = function() {
      var E;
      if (l && !h)
        return (!i._readableState || !i._readableState.ended) && (E = new e()), o.call(i, E);
      if (f && !u)
        return (!i._writableState || !i._writableState.ended) && (E = new e()), o.call(i, E);
    }, v = function() {
      i.req.on("finish", c);
    };
    return s(i) ? (i.on("complete", c), i.on("abort", m), i.req ? v() : i.on("request", v)) : f && !i._writableState && (i.on("end", d), i.on("close", d)), i.on("end", p), i.on("finish", c), a.error !== !1 && i.on("error", g), i.on("close", m), function() {
      i.removeListener("complete", c), i.removeListener("abort", m), i.removeListener("request", v), i.req && i.req.removeListener("finish", c), i.removeListener("end", d), i.removeListener("close", d), i.removeListener("finish", c), i.removeListener("end", p), i.removeListener("error", g), i.removeListener("close", m);
    };
  }
  return Um = r, Um;
}
var Wm, Ab;
function b5() {
  if (Ab)
    return Wm;
  Ab = 1;
  var e;
  function t(E, C, x) {
    return C = n(C), C in E ? Object.defineProperty(E, C, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : E[C] = x, E;
  }
  function n(E) {
    var C = s(E, "string");
    return typeof C == "symbol" ? C : String(C);
  }
  function s(E, C) {
    if (typeof E != "object" || E === null)
      return E;
    var x = E[Symbol.toPrimitive];
    if (x !== void 0) {
      var b = x.call(E, C || "default");
      if (typeof b != "object")
        return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (C === "string" ? String : Number)(E);
  }
  var r = Q0(), i = Symbol("lastResolve"), a = Symbol("lastReject"), o = Symbol("error"), l = Symbol("ended"), f = Symbol("lastPromise"), d = Symbol("handlePromise"), u = Symbol("stream");
  function c(E, C) {
    return {
      value: E,
      done: C
    };
  }
  function h(E) {
    var C = E[i];
    if (C !== null) {
      var x = E[u].read();
      x !== null && (E[f] = null, E[i] = null, E[a] = null, C(c(x, !1)));
    }
  }
  function p(E) {
    process.nextTick(h, E);
  }
  function g(E, C) {
    return function(x, b) {
      E.then(function() {
        if (C[l]) {
          x(c(void 0, !0));
          return;
        }
        C[d](x, b);
      }, b);
    };
  }
  var m = Object.getPrototypeOf(function() {
  }), v = Object.setPrototypeOf((e = {
    get stream() {
      return this[u];
    },
    next: function() {
      var C = this, x = this[o];
      if (x !== null)
        return Promise.reject(x);
      if (this[l])
        return Promise.resolve(c(void 0, !0));
      if (this[u].destroyed)
        return new Promise(function(T, M) {
          process.nextTick(function() {
            C[o] ? M(C[o]) : T(c(void 0, !0));
          });
        });
      var b = this[f], P;
      if (b)
        P = new Promise(g(b, this));
      else {
        var O = this[u].read();
        if (O !== null)
          return Promise.resolve(c(O, !1));
        P = new Promise(this[d]);
      }
      return this[f] = P, P;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var C = this;
    return new Promise(function(x, b) {
      C[u].destroy(null, function(P) {
        if (P) {
          b(P);
          return;
        }
        x(c(void 0, !0));
      });
    });
  }), e), m), y = function(C) {
    var x, b = Object.create(v, (x = {}, t(x, u, {
      value: C,
      writable: !0
    }), t(x, i, {
      value: null,
      writable: !0
    }), t(x, a, {
      value: null,
      writable: !0
    }), t(x, o, {
      value: null,
      writable: !0
    }), t(x, l, {
      value: C._readableState.endEmitted,
      writable: !0
    }), t(x, d, {
      value: function(O, T) {
        var M = b[u].read();
        M ? (b[f] = null, b[i] = null, b[a] = null, O(c(M, !1))) : (b[i] = O, b[a] = T);
      },
      writable: !0
    }), x));
    return b[f] = null, r(C, function(P) {
      if (P && P.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var O = b[a];
        O !== null && (b[f] = null, b[i] = null, b[a] = null, O(P)), b[o] = P;
        return;
      }
      var T = b[i];
      T !== null && (b[f] = null, b[i] = null, b[a] = null, T(c(void 0, !0))), b[l] = !0;
    }), C.on("readable", p.bind(null, b)), b;
  };
  return Wm = y, Wm;
}
var zm, Lb;
function T5() {
  return Lb || (Lb = 1, zm = function() {
    throw new Error("Readable.from is not available in the browser");
  }), zm;
}
var Km, Rb;
function PM() {
  if (Rb)
    return Km;
  Rb = 1, Km = T;
  var e;
  T.ReadableState = O, np().EventEmitter;
  var t = function(z, at) {
    return z.listeners(at).length;
  }, n = CM(), s = ip().Buffer, r = (typeof It < "u" ? It : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function i(W) {
    return s.from(W);
  }
  function a(W) {
    return s.isBuffer(W) || W instanceof r;
  }
  var o = xM, l;
  o && o.debuglog ? l = o.debuglog("stream") : l = function() {
  };
  var f = E5(), d = bM(), u = TM(), c = u.getHighWaterMark, h = Ou().codes, p = h.ERR_INVALID_ARG_TYPE, g = h.ERR_STREAM_PUSH_AFTER_EOF, m = h.ERR_METHOD_NOT_IMPLEMENTED, v = h.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, y, E, C;
  Tu()(T, n);
  var x = d.errorOrDestroy, b = ["error", "close", "destroy", "pause", "resume"];
  function P(W, z, at) {
    if (typeof W.prependListener == "function")
      return W.prependListener(z, at);
    !W._events || !W._events[z] ? W.on(z, at) : Array.isArray(W._events[z]) ? W._events[z].unshift(at) : W._events[z] = [at, W._events[z]];
  }
  function O(W, z, at) {
    e = e || au(), W = W || {}, typeof at != "boolean" && (at = z instanceof e), this.objectMode = !!W.objectMode, at && (this.objectMode = this.objectMode || !!W.readableObjectMode), this.highWaterMark = c(this, W, "readableHighWaterMark", at), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = W.emitClose !== !1, this.autoDestroy = !!W.autoDestroy, this.destroyed = !1, this.defaultEncoding = W.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, W.encoding && (y || (y = yv().StringDecoder), this.decoder = new y(W.encoding), this.encoding = W.encoding);
  }
  function T(W) {
    if (e = e || au(), !(this instanceof T))
      return new T(W);
    var z = this instanceof e;
    this._readableState = new O(W, this, z), this.readable = !0, W && (typeof W.read == "function" && (this._read = W.read), typeof W.destroy == "function" && (this._destroy = W.destroy)), n.call(this);
  }
  Object.defineProperty(T.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(z) {
      this._readableState && (this._readableState.destroyed = z);
    }
  }), T.prototype.destroy = d.destroy, T.prototype._undestroy = d.undestroy, T.prototype._destroy = function(W, z) {
    z(W);
  }, T.prototype.push = function(W, z) {
    var at = this._readableState, ct;
    return at.objectMode ? ct = !0 : typeof W == "string" && (z = z || at.defaultEncoding, z !== at.encoding && (W = s.from(W, z), z = ""), ct = !0), M(this, W, z, !1, ct);
  }, T.prototype.unshift = function(W) {
    return M(this, W, null, !0, !1);
  };
  function M(W, z, at, ct, Mt) {
    l("readableAddChunk", z);
    var N = W._readableState;
    if (z === null)
      N.reading = !1, B(W, N);
    else {
      var S;
      if (Mt || (S = A(N, z)), S)
        x(W, S);
      else if (N.objectMode || z && z.length > 0)
        if (typeof z != "string" && !N.objectMode && Object.getPrototypeOf(z) !== s.prototype && (z = i(z)), ct)
          N.endEmitted ? x(W, new v()) : L(W, N, z, !0);
        else if (N.ended)
          x(W, new g());
        else {
          if (N.destroyed)
            return !1;
          N.reading = !1, N.decoder && !at ? (z = N.decoder.write(z), N.objectMode || z.length !== 0 ? L(W, N, z, !1) : X(W, N)) : L(W, N, z, !1);
        }
      else
        ct || (N.reading = !1, X(W, N));
    }
    return !N.ended && (N.length < N.highWaterMark || N.length === 0);
  }
  function L(W, z, at, ct) {
    z.flowing && z.length === 0 && !z.sync ? (z.awaitDrain = 0, W.emit("data", at)) : (z.length += z.objectMode ? 1 : at.length, ct ? z.buffer.unshift(at) : z.buffer.push(at), z.needReadable && j(W)), X(W, z);
  }
  function A(W, z) {
    var at;
    return !a(z) && typeof z != "string" && z !== void 0 && !W.objectMode && (at = new p("chunk", ["string", "Buffer", "Uint8Array"], z)), at;
  }
  T.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, T.prototype.setEncoding = function(W) {
    y || (y = yv().StringDecoder);
    var z = new y(W);
    this._readableState.decoder = z, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var at = this._readableState.buffer.head, ct = ""; at !== null; )
      ct += z.write(at.data), at = at.next;
    return this._readableState.buffer.clear(), ct !== "" && this._readableState.buffer.push(ct), this._readableState.length = ct.length, this;
  };
  var D = 1073741824;
  function I(W) {
    return W >= D ? W = D : (W--, W |= W >>> 1, W |= W >>> 2, W |= W >>> 4, W |= W >>> 8, W |= W >>> 16, W++), W;
  }
  function w(W, z) {
    return W <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : W !== W ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (W > z.highWaterMark && (z.highWaterMark = I(W)), W <= z.length ? W : z.ended ? z.length : (z.needReadable = !0, 0));
  }
  T.prototype.read = function(W) {
    l("read", W), W = parseInt(W, 10);
    var z = this._readableState, at = W;
    if (W !== 0 && (z.emittedReadable = !1), W === 0 && z.needReadable && ((z.highWaterMark !== 0 ? z.length >= z.highWaterMark : z.length > 0) || z.ended))
      return l("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? V(this) : j(this), null;
    if (W = w(W, z), W === 0 && z.ended)
      return z.length === 0 && V(this), null;
    var ct = z.needReadable;
    l("need readable", ct), (z.length === 0 || z.length - W < z.highWaterMark) && (ct = !0, l("length less than watermark", ct)), z.ended || z.reading ? (ct = !1, l("reading or ended", ct)) : ct && (l("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (W = w(at, z)));
    var Mt;
    return W > 0 ? Mt = R(W, z) : Mt = null, Mt === null ? (z.needReadable = z.length <= z.highWaterMark, W = 0) : (z.length -= W, z.awaitDrain = 0), z.length === 0 && (z.ended || (z.needReadable = !0), at !== W && z.ended && V(this)), Mt !== null && this.emit("data", Mt), Mt;
  };
  function B(W, z) {
    if (l("onEofChunk"), !z.ended) {
      if (z.decoder) {
        var at = z.decoder.end();
        at && at.length && (z.buffer.push(at), z.length += z.objectMode ? 1 : at.length);
      }
      z.ended = !0, z.sync ? j(W) : (z.needReadable = !1, z.emittedReadable || (z.emittedReadable = !0, k(W)));
    }
  }
  function j(W) {
    var z = W._readableState;
    l("emitReadable", z.needReadable, z.emittedReadable), z.needReadable = !1, z.emittedReadable || (l("emitReadable", z.flowing), z.emittedReadable = !0, process.nextTick(k, W));
  }
  function k(W) {
    var z = W._readableState;
    l("emitReadable_", z.destroyed, z.length, z.ended), !z.destroyed && (z.length || z.ended) && (W.emit("readable"), z.emittedReadable = !1), z.needReadable = !z.flowing && !z.ended && z.length <= z.highWaterMark, it(W);
  }
  function X(W, z) {
    z.readingMore || (z.readingMore = !0, process.nextTick(rt, W, z));
  }
  function rt(W, z) {
    for (; !z.reading && !z.ended && (z.length < z.highWaterMark || z.flowing && z.length === 0); ) {
      var at = z.length;
      if (l("maybeReadMore read 0"), W.read(0), at === z.length)
        break;
    }
    z.readingMore = !1;
  }
  T.prototype._read = function(W) {
    x(this, new m("_read()"));
  }, T.prototype.pipe = function(W, z) {
    var at = this, ct = this._readableState;
    switch (ct.pipesCount) {
      case 0:
        ct.pipes = W;
        break;
      case 1:
        ct.pipes = [ct.pipes, W];
        break;
      default:
        ct.pipes.push(W);
        break;
    }
    ct.pipesCount += 1, l("pipe count=%d opts=%j", ct.pipesCount, z);
    var Mt = (!z || z.end !== !1) && W !== process.stdout && W !== process.stderr, N = Mt ? _ : Jt;
    ct.endEmitted ? process.nextTick(N) : at.once("end", N), W.on("unpipe", S);
    function S(J, ft) {
      l("onunpipe"), J === at && ft && ft.hasUnpiped === !1 && (ft.hasUnpiped = !0, nt());
    }
    function _() {
      l("onend"), W.end();
    }
    var F = et(at);
    W.on("drain", F);
    var G = !1;
    function nt() {
      l("cleanup"), W.removeListener("close", Lt), W.removeListener("finish", Ft), W.removeListener("drain", F), W.removeListener("error", yt), W.removeListener("unpipe", S), at.removeListener("end", _), at.removeListener("end", Jt), at.removeListener("data", lt), G = !0, ct.awaitDrain && (!W._writableState || W._writableState.needDrain) && F();
    }
    at.on("data", lt);
    function lt(J) {
      l("ondata");
      var ft = W.write(J);
      l("dest.write", ft), ft === !1 && ((ct.pipesCount === 1 && ct.pipes === W || ct.pipesCount > 1 && Y(ct.pipes, W) !== -1) && !G && (l("false write response, pause", ct.awaitDrain), ct.awaitDrain++), at.pause());
    }
    function yt(J) {
      l("onerror", J), Jt(), W.removeListener("error", yt), t(W, "error") === 0 && x(W, J);
    }
    P(W, "error", yt);
    function Lt() {
      W.removeListener("finish", Ft), Jt();
    }
    W.once("close", Lt);
    function Ft() {
      l("onfinish"), W.removeListener("close", Lt), Jt();
    }
    W.once("finish", Ft);
    function Jt() {
      l("unpipe"), at.unpipe(W);
    }
    return W.emit("pipe", at), ct.flowing || (l("pipe resume"), at.resume()), W;
  };
  function et(W) {
    return function() {
      var at = W._readableState;
      l("pipeOnDrain", at.awaitDrain), at.awaitDrain && at.awaitDrain--, at.awaitDrain === 0 && t(W, "data") && (at.flowing = !0, it(W));
    };
  }
  T.prototype.unpipe = function(W) {
    var z = this._readableState, at = {
      hasUnpiped: !1
    };
    if (z.pipesCount === 0)
      return this;
    if (z.pipesCount === 1)
      return W && W !== z.pipes ? this : (W || (W = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, W && W.emit("unpipe", this, at), this);
    if (!W) {
      var ct = z.pipes, Mt = z.pipesCount;
      z.pipes = null, z.pipesCount = 0, z.flowing = !1;
      for (var N = 0; N < Mt; N++)
        ct[N].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var S = Y(z.pipes, W);
    return S === -1 ? this : (z.pipes.splice(S, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), W.emit("unpipe", this, at), this);
  }, T.prototype.on = function(W, z) {
    var at = n.prototype.on.call(this, W, z), ct = this._readableState;
    return W === "data" ? (ct.readableListening = this.listenerCount("readable") > 0, ct.flowing !== !1 && this.resume()) : W === "readable" && !ct.endEmitted && !ct.readableListening && (ct.readableListening = ct.needReadable = !0, ct.flowing = !1, ct.emittedReadable = !1, l("on readable", ct.length, ct.reading), ct.length ? j(this) : ct.reading || process.nextTick(dt, this)), at;
  }, T.prototype.addListener = T.prototype.on, T.prototype.removeListener = function(W, z) {
    var at = n.prototype.removeListener.call(this, W, z);
    return W === "readable" && process.nextTick(Z, this), at;
  }, T.prototype.removeAllListeners = function(W) {
    var z = n.prototype.removeAllListeners.apply(this, arguments);
    return (W === "readable" || W === void 0) && process.nextTick(Z, this), z;
  };
  function Z(W) {
    var z = W._readableState;
    z.readableListening = W.listenerCount("readable") > 0, z.resumeScheduled && !z.paused ? z.flowing = !0 : W.listenerCount("data") > 0 && W.resume();
  }
  function dt(W) {
    l("readable nexttick read 0"), W.read(0);
  }
  T.prototype.resume = function() {
    var W = this._readableState;
    return W.flowing || (l("resume"), W.flowing = !W.readableListening, vt(this, W)), W.paused = !1, this;
  };
  function vt(W, z) {
    z.resumeScheduled || (z.resumeScheduled = !0, process.nextTick(bt, W, z));
  }
  function bt(W, z) {
    l("resume", z.reading), z.reading || W.read(0), z.resumeScheduled = !1, W.emit("resume"), it(W), z.flowing && !z.reading && W.read(0);
  }
  T.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function it(W) {
    var z = W._readableState;
    for (l("flow", z.flowing); z.flowing && W.read() !== null; )
      ;
  }
  T.prototype.wrap = function(W) {
    var z = this, at = this._readableState, ct = !1;
    W.on("end", function() {
      if (l("wrapped end"), at.decoder && !at.ended) {
        var S = at.decoder.end();
        S && S.length && z.push(S);
      }
      z.push(null);
    }), W.on("data", function(S) {
      if (l("wrapped data"), at.decoder && (S = at.decoder.write(S)), !(at.objectMode && S == null) && !(!at.objectMode && (!S || !S.length))) {
        var _ = z.push(S);
        _ || (ct = !0, W.pause());
      }
    });
    for (var Mt in W)
      this[Mt] === void 0 && typeof W[Mt] == "function" && (this[Mt] = function(_) {
        return function() {
          return W[_].apply(W, arguments);
        };
      }(Mt));
    for (var N = 0; N < b.length; N++)
      W.on(b[N], this.emit.bind(this, b[N]));
    return this._read = function(S) {
      l("wrapped _read", S), ct && (ct = !1, W.resume());
    }, this;
  }, typeof Symbol == "function" && (T.prototype[Symbol.asyncIterator] = function() {
    return E === void 0 && (E = b5()), E(this);
  }), Object.defineProperty(T.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(T.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(T.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(z) {
      this._readableState && (this._readableState.flowing = z);
    }
  }), T._fromList = R, Object.defineProperty(T.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function R(W, z) {
    if (z.length === 0)
      return null;
    var at;
    return z.objectMode ? at = z.buffer.shift() : !W || W >= z.length ? (z.decoder ? at = z.buffer.join("") : z.buffer.length === 1 ? at = z.buffer.first() : at = z.buffer.concat(z.length), z.buffer.clear()) : at = z.buffer.consume(W, z.decoder), at;
  }
  function V(W) {
    var z = W._readableState;
    l("endReadable", z.endEmitted), z.endEmitted || (z.ended = !0, process.nextTick(tt, z, W));
  }
  function tt(W, z) {
    if (l("endReadableNT", W.endEmitted, W.length), !W.endEmitted && W.length === 0 && (W.endEmitted = !0, z.readable = !1, z.emit("end"), W.autoDestroy)) {
      var at = z._writableState;
      (!at || at.autoDestroy && at.finished) && z.destroy();
    }
  }
  typeof Symbol == "function" && (T.from = function(W, z) {
    return C === void 0 && (C = T5()), C(T, W, z);
  });
  function Y(W, z) {
    for (var at = 0, ct = W.length; at < ct; at++)
      if (W[at] === z)
        return at;
    return -1;
  }
  return Km;
}
var Gm, wb;
function SM() {
  if (wb)
    return Gm;
  wb = 1, Gm = o;
  var e = Ou().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, n = e.ERR_MULTIPLE_CALLBACK, s = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, r = e.ERR_TRANSFORM_WITH_LENGTH_0, i = au();
  Tu()(o, i);
  function a(d, u) {
    var c = this._transformState;
    c.transforming = !1;
    var h = c.writecb;
    if (h === null)
      return this.emit("error", new n());
    c.writechunk = null, c.writecb = null, u != null && this.push(u), h(d);
    var p = this._readableState;
    p.reading = !1, (p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
  }
  function o(d) {
    if (!(this instanceof o))
      return new o(d);
    i.call(this, d), this._transformState = {
      afterTransform: a.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, d && (typeof d.transform == "function" && (this._transform = d.transform), typeof d.flush == "function" && (this._flush = d.flush)), this.on("prefinish", l);
  }
  function l() {
    var d = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
      f(d, u, c);
    }) : f(this, null, null);
  }
  o.prototype.push = function(d, u) {
    return this._transformState.needTransform = !1, i.prototype.push.call(this, d, u);
  }, o.prototype._transform = function(d, u, c) {
    c(new t("_transform()"));
  }, o.prototype._write = function(d, u, c) {
    var h = this._transformState;
    if (h.writecb = c, h.writechunk = d, h.writeencoding = u, !h.transforming) {
      var p = this._readableState;
      (h.needTransform || p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
    }
  }, o.prototype._read = function(d) {
    var u = this._transformState;
    u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
  }, o.prototype._destroy = function(d, u) {
    i.prototype._destroy.call(this, d, function(c) {
      u(c);
    });
  };
  function f(d, u, c) {
    if (u)
      return d.emit("error", u);
    if (c != null && d.push(c), d._writableState.length)
      throw new r();
    if (d._transformState.transforming)
      throw new s();
    return d.push(null);
  }
  return Gm;
}
var km, Vb;
function O5() {
  if (Vb)
    return km;
  Vb = 1, km = t;
  var e = SM();
  Tu()(t, e);
  function t(n) {
    if (!(this instanceof t))
      return new t(n);
    e.call(this, n);
  }
  return t.prototype._transform = function(n, s, r) {
    r(null, n);
  }, km;
}
var Hm, Bb;
function P5() {
  if (Bb)
    return Hm;
  Bb = 1;
  var e;
  function t(c) {
    var h = !1;
    return function() {
      h || (h = !0, c.apply(void 0, arguments));
    };
  }
  var n = Ou().codes, s = n.ERR_MISSING_ARGS, r = n.ERR_STREAM_DESTROYED;
  function i(c) {
    if (c)
      throw c;
  }
  function a(c) {
    return c.setHeader && typeof c.abort == "function";
  }
  function o(c, h, p, g) {
    g = t(g);
    var m = !1;
    c.on("close", function() {
      m = !0;
    }), e === void 0 && (e = Q0()), e(c, {
      readable: h,
      writable: p
    }, function(y) {
      if (y)
        return g(y);
      m = !0, g();
    });
    var v = !1;
    return function(y) {
      if (!m && !v) {
        if (v = !0, a(c))
          return c.abort();
        if (typeof c.destroy == "function")
          return c.destroy();
        g(y || new r("pipe"));
      }
    };
  }
  function l(c) {
    c();
  }
  function f(c, h) {
    return c.pipe(h);
  }
  function d(c) {
    return !c.length || typeof c[c.length - 1] != "function" ? i : c.pop();
  }
  function u() {
    for (var c = arguments.length, h = new Array(c), p = 0; p < c; p++)
      h[p] = arguments[p];
    var g = d(h);
    if (Array.isArray(h[0]) && (h = h[0]), h.length < 2)
      throw new s("streams");
    var m, v = h.map(function(y, E) {
      var C = E < h.length - 1, x = E > 0;
      return o(y, C, x, function(b) {
        m || (m = b), b && v.forEach(l), !C && (v.forEach(l), g(m));
      });
    });
    return h.reduce(f);
  }
  return Hm = u, Hm;
}
var Ym, Fb;
function S5() {
  if (Fb)
    return Ym;
  Fb = 1, Ym = n;
  var e = np().EventEmitter, t = Tu();
  t(n, e), n.Readable = PM(), n.Writable = OM(), n.Duplex = au(), n.Transform = SM(), n.PassThrough = O5(), n.finished = Q0(), n.pipeline = P5(), n.Stream = n;
  function n() {
    e.call(this);
  }
  return n.prototype.pipe = function(s, r) {
    var i = this;
    function a(h) {
      s.writable && s.write(h) === !1 && i.pause && i.pause();
    }
    i.on("data", a);
    function o() {
      i.readable && i.resume && i.resume();
    }
    s.on("drain", o), !s._isStdio && (!r || r.end !== !1) && (i.on("end", f), i.on("close", d));
    var l = !1;
    function f() {
      l || (l = !0, s.end());
    }
    function d() {
      l || (l = !0, typeof s.destroy == "function" && s.destroy());
    }
    function u(h) {
      if (c(), e.listenerCount(this, "error") === 0)
        throw h;
    }
    i.on("error", u), s.on("error", u);
    function c() {
      i.removeListener("data", a), s.removeListener("drain", o), i.removeListener("end", f), i.removeListener("close", d), i.removeListener("error", u), s.removeListener("error", u), i.removeListener("end", c), i.removeListener("close", c), s.removeListener("close", c);
    }
    return i.on("end", c), i.on("close", c), s.on("close", c), s.emit("pipe", i), s;
  }, Ym;
}
var Nb;
function M5() {
  return Nb || (Nb = 1, function(e) {
    (function(t) {
      t.parser = function(R, V) {
        return new s(R, V);
      }, t.SAXParser = s, t.SAXStream = d, t.createStream = f, t.MAX_BUFFER_LENGTH = 64 * 1024;
      var n = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      t.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function s(R, V) {
        if (!(this instanceof s))
          return new s(R, V);
        var tt = this;
        i(tt), tt.q = tt.c = "", tt.bufferCheckPosition = t.MAX_BUFFER_LENGTH, tt.opt = V || {}, tt.opt.lowercase = tt.opt.lowercase || tt.opt.lowercasetags, tt.looseCase = tt.opt.lowercase ? "toLowerCase" : "toUpperCase", tt.tags = [], tt.closed = tt.closedRoot = tt.sawRoot = !1, tt.tag = tt.error = null, tt.strict = !!R, tt.noscript = !!(R || tt.opt.noscript), tt.state = T.BEGIN, tt.strictEntities = tt.opt.strictEntities, tt.ENTITIES = tt.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), tt.attribList = [], tt.opt.xmlns && (tt.ns = Object.create(g)), tt.trackPosition = tt.opt.position !== !1, tt.trackPosition && (tt.position = tt.line = tt.column = 0), L(tt, "onready");
      }
      Object.create || (Object.create = function(R) {
        function V() {
        }
        V.prototype = R;
        var tt = new V();
        return tt;
      }), Object.keys || (Object.keys = function(R) {
        var V = [];
        for (var tt in R)
          R.hasOwnProperty(tt) && V.push(tt);
        return V;
      });
      function r(R) {
        for (var V = Math.max(t.MAX_BUFFER_LENGTH, 10), tt = 0, Y = 0, W = n.length; Y < W; Y++) {
          var z = R[n[Y]].length;
          if (z > V)
            switch (n[Y]) {
              case "textNode":
                D(R);
                break;
              case "cdata":
                A(R, "oncdata", R.cdata), R.cdata = "";
                break;
              case "script":
                A(R, "onscript", R.script), R.script = "";
                break;
              default:
                w(R, "Max buffer length exceeded: " + n[Y]);
            }
          tt = Math.max(tt, z);
        }
        var at = t.MAX_BUFFER_LENGTH - tt;
        R.bufferCheckPosition = at + R.position;
      }
      function i(R) {
        for (var V = 0, tt = n.length; V < tt; V++)
          R[n[V]] = "";
      }
      function a(R) {
        D(R), R.cdata !== "" && (A(R, "oncdata", R.cdata), R.cdata = ""), R.script !== "" && (A(R, "onscript", R.script), R.script = "");
      }
      s.prototype = {
        end: function() {
          B(this);
        },
        write: it,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          a(this);
        }
      };
      var o;
      try {
        o = S5().Stream;
      } catch {
        o = function() {
        };
      }
      o || (o = function() {
      });
      var l = t.EVENTS.filter(function(R) {
        return R !== "error" && R !== "end";
      });
      function f(R, V) {
        return new d(R, V);
      }
      function d(R, V) {
        if (!(this instanceof d))
          return new d(R, V);
        o.apply(this), this._parser = new s(R, V), this.writable = !0, this.readable = !0;
        var tt = this;
        this._parser.onend = function() {
          tt.emit("end");
        }, this._parser.onerror = function(Y) {
          tt.emit("error", Y), tt._parser.error = null;
        }, this._decoder = null, l.forEach(function(Y) {
          Object.defineProperty(tt, "on" + Y, {
            get: function() {
              return tt._parser["on" + Y];
            },
            set: function(W) {
              if (!W)
                return tt.removeAllListeners(Y), tt._parser["on" + Y] = W, W;
              tt.on(Y, W);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      d.prototype = Object.create(o.prototype, {
        constructor: {
          value: d
        }
      }), d.prototype.write = function(R) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(R)) {
          if (!this._decoder) {
            var V = yv().StringDecoder;
            this._decoder = new V("utf8");
          }
          R = this._decoder.write(R);
        }
        return this._parser.write(R.toString()), this.emit("data", R), !0;
      }, d.prototype.end = function(R) {
        return R && R.length && this.write(R), this._parser.end(), !0;
      }, d.prototype.on = function(R, V) {
        var tt = this;
        return !tt._parser["on" + R] && l.indexOf(R) !== -1 && (tt._parser["on" + R] = function() {
          var Y = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          Y.splice(0, 0, R), tt.emit.apply(tt, Y);
        }), o.prototype.on.call(tt, R, V);
      };
      var u = "[CDATA[", c = "DOCTYPE", h = "http://www.w3.org/XML/1998/namespace", p = "http://www.w3.org/2000/xmlns/", g = { xml: h, xmlns: p }, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, v = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function C(R) {
        return R === " " || R === `
` || R === "\r" || R === "	";
      }
      function x(R) {
        return R === '"' || R === "'";
      }
      function b(R) {
        return R === ">" || C(R);
      }
      function P(R, V) {
        return R.test(V);
      }
      function O(R, V) {
        return !P(R, V);
      }
      var T = 0;
      t.STATE = {
        BEGIN: T++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: T++,
        // leading whitespace
        TEXT: T++,
        // general stuff
        TEXT_ENTITY: T++,
        // &amp and such.
        OPEN_WAKA: T++,
        // <
        SGML_DECL: T++,
        // <!BLARG
        SGML_DECL_QUOTED: T++,
        // <!BLARG foo "bar
        DOCTYPE: T++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: T++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: T++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: T++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: T++,
        // <!-
        COMMENT: T++,
        // <!--
        COMMENT_ENDING: T++,
        // <!-- blah -
        COMMENT_ENDED: T++,
        // <!-- blah --
        CDATA: T++,
        // <![CDATA[ something
        CDATA_ENDING: T++,
        // ]
        CDATA_ENDING_2: T++,
        // ]]
        PROC_INST: T++,
        // <?hi
        PROC_INST_BODY: T++,
        // <?hi there
        PROC_INST_ENDING: T++,
        // <?hi "there" ?
        OPEN_TAG: T++,
        // <strong
        OPEN_TAG_SLASH: T++,
        // <strong /
        ATTRIB: T++,
        // <a
        ATTRIB_NAME: T++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: T++,
        // <a foo _
        ATTRIB_VALUE: T++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: T++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: T++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: T++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: T++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: T++,
        // <foo bar=&quot
        CLOSE_TAG: T++,
        // </a
        CLOSE_TAG_SAW_WHITE: T++,
        // </a   >
        SCRIPT: T++,
        // <script> ...
        SCRIPT_ENDING: T++
        // <script> ... <
      }, t.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(t.ENTITIES).forEach(function(R) {
        var V = t.ENTITIES[R], tt = typeof V == "number" ? String.fromCharCode(V) : V;
        t.ENTITIES[R] = tt;
      });
      for (var M in t.STATE)
        t.STATE[t.STATE[M]] = M;
      T = t.STATE;
      function L(R, V, tt) {
        R[V] && R[V](tt);
      }
      function A(R, V, tt) {
        R.textNode && D(R), L(R, V, tt);
      }
      function D(R) {
        R.textNode = I(R.opt, R.textNode), R.textNode && L(R, "ontext", R.textNode), R.textNode = "";
      }
      function I(R, V) {
        return R.trim && (V = V.trim()), R.normalize && (V = V.replace(/\s+/g, " ")), V;
      }
      function w(R, V) {
        return D(R), R.trackPosition && (V += `
Line: ` + R.line + `
Column: ` + R.column + `
Char: ` + R.c), V = new Error(V), R.error = V, L(R, "onerror", V), R;
      }
      function B(R) {
        return R.sawRoot && !R.closedRoot && j(R, "Unclosed root tag"), R.state !== T.BEGIN && R.state !== T.BEGIN_WHITESPACE && R.state !== T.TEXT && w(R, "Unexpected end"), D(R), R.c = "", R.closed = !0, L(R, "onend"), s.call(R, R.strict, R.opt), R;
      }
      function j(R, V) {
        if (typeof R != "object" || !(R instanceof s))
          throw new Error("bad call to strictFail");
        R.strict && w(R, V);
      }
      function k(R) {
        R.strict || (R.tagName = R.tagName[R.looseCase]());
        var V = R.tags[R.tags.length - 1] || R, tt = R.tag = { name: R.tagName, attributes: {} };
        R.opt.xmlns && (tt.ns = V.ns), R.attribList.length = 0, A(R, "onopentagstart", tt);
      }
      function X(R, V) {
        var tt = R.indexOf(":"), Y = tt < 0 ? ["", R] : R.split(":"), W = Y[0], z = Y[1];
        return V && R === "xmlns" && (W = "xmlns", z = ""), { prefix: W, local: z };
      }
      function rt(R) {
        if (R.strict || (R.attribName = R.attribName[R.looseCase]()), R.attribList.indexOf(R.attribName) !== -1 || R.tag.attributes.hasOwnProperty(R.attribName)) {
          R.attribName = R.attribValue = "";
          return;
        }
        if (R.opt.xmlns) {
          var V = X(R.attribName, !0), tt = V.prefix, Y = V.local;
          if (tt === "xmlns")
            if (Y === "xml" && R.attribValue !== h)
              j(
                R,
                "xml: prefix must be bound to " + h + `
Actual: ` + R.attribValue
              );
            else if (Y === "xmlns" && R.attribValue !== p)
              j(
                R,
                "xmlns: prefix must be bound to " + p + `
Actual: ` + R.attribValue
              );
            else {
              var W = R.tag, z = R.tags[R.tags.length - 1] || R;
              W.ns === z.ns && (W.ns = Object.create(z.ns)), W.ns[Y] = R.attribValue;
            }
          R.attribList.push([R.attribName, R.attribValue]);
        } else
          R.tag.attributes[R.attribName] = R.attribValue, A(R, "onattribute", {
            name: R.attribName,
            value: R.attribValue
          });
        R.attribName = R.attribValue = "";
      }
      function et(R, V) {
        if (R.opt.xmlns) {
          var tt = R.tag, Y = X(R.tagName);
          tt.prefix = Y.prefix, tt.local = Y.local, tt.uri = tt.ns[Y.prefix] || "", tt.prefix && !tt.uri && (j(R, "Unbound namespace prefix: " + JSON.stringify(R.tagName)), tt.uri = Y.prefix);
          var W = R.tags[R.tags.length - 1] || R;
          tt.ns && W.ns !== tt.ns && Object.keys(tt.ns).forEach(function(lt) {
            A(R, "onopennamespace", {
              prefix: lt,
              uri: tt.ns[lt]
            });
          });
          for (var z = 0, at = R.attribList.length; z < at; z++) {
            var ct = R.attribList[z], Mt = ct[0], N = ct[1], S = X(Mt, !0), _ = S.prefix, F = S.local, G = _ === "" ? "" : tt.ns[_] || "", nt = {
              name: Mt,
              value: N,
              prefix: _,
              local: F,
              uri: G
            };
            _ && _ !== "xmlns" && !G && (j(R, "Unbound namespace prefix: " + JSON.stringify(_)), nt.uri = _), R.tag.attributes[Mt] = nt, A(R, "onattribute", nt);
          }
          R.attribList.length = 0;
        }
        R.tag.isSelfClosing = !!V, R.sawRoot = !0, R.tags.push(R.tag), A(R, "onopentag", R.tag), V || (!R.noscript && R.tagName.toLowerCase() === "script" ? R.state = T.SCRIPT : R.state = T.TEXT, R.tag = null, R.tagName = ""), R.attribName = R.attribValue = "", R.attribList.length = 0;
      }
      function Z(R) {
        if (!R.tagName) {
          j(R, "Weird empty close tag."), R.textNode += "</>", R.state = T.TEXT;
          return;
        }
        if (R.script) {
          if (R.tagName !== "script") {
            R.script += "</" + R.tagName + ">", R.tagName = "", R.state = T.SCRIPT;
            return;
          }
          A(R, "onscript", R.script), R.script = "";
        }
        var V = R.tags.length, tt = R.tagName;
        R.strict || (tt = tt[R.looseCase]());
        for (var Y = tt; V--; ) {
          var W = R.tags[V];
          if (W.name !== Y)
            j(R, "Unexpected close tag");
          else
            break;
        }
        if (V < 0) {
          j(R, "Unmatched closing tag: " + R.tagName), R.textNode += "</" + R.tagName + ">", R.state = T.TEXT;
          return;
        }
        R.tagName = tt;
        for (var z = R.tags.length; z-- > V; ) {
          var at = R.tag = R.tags.pop();
          R.tagName = R.tag.name, A(R, "onclosetag", R.tagName);
          var ct = {};
          for (var Mt in at.ns)
            ct[Mt] = at.ns[Mt];
          var N = R.tags[R.tags.length - 1] || R;
          R.opt.xmlns && at.ns !== N.ns && Object.keys(at.ns).forEach(function(S) {
            var _ = at.ns[S];
            A(R, "onclosenamespace", { prefix: S, uri: _ });
          });
        }
        V === 0 && (R.closedRoot = !0), R.tagName = R.attribValue = R.attribName = "", R.attribList.length = 0, R.state = T.TEXT;
      }
      function dt(R) {
        var V = R.entity, tt = V.toLowerCase(), Y, W = "";
        return R.ENTITIES[V] ? R.ENTITIES[V] : R.ENTITIES[tt] ? R.ENTITIES[tt] : (V = tt, V.charAt(0) === "#" && (V.charAt(1) === "x" ? (V = V.slice(2), Y = parseInt(V, 16), W = Y.toString(16)) : (V = V.slice(1), Y = parseInt(V, 10), W = Y.toString(10))), V = V.replace(/^0+/, ""), isNaN(Y) || W.toLowerCase() !== V ? (j(R, "Invalid character entity"), "&" + R.entity + ";") : String.fromCodePoint(Y));
      }
      function vt(R, V) {
        V === "<" ? (R.state = T.OPEN_WAKA, R.startTagPosition = R.position) : C(V) || (j(R, "Non-whitespace before first tag."), R.textNode = V, R.state = T.TEXT);
      }
      function bt(R, V) {
        var tt = "";
        return V < R.length && (tt = R.charAt(V)), tt;
      }
      function it(R) {
        var V = this;
        if (this.error)
          throw this.error;
        if (V.closed)
          return w(
            V,
            "Cannot write after close. Assign an onready handler."
          );
        if (R === null)
          return B(V);
        typeof R == "object" && (R = R.toString());
        for (var tt = 0, Y = ""; Y = bt(R, tt++), V.c = Y, !!Y; )
          switch (V.trackPosition && (V.position++, Y === `
` ? (V.line++, V.column = 0) : V.column++), V.state) {
            case T.BEGIN:
              if (V.state = T.BEGIN_WHITESPACE, Y === "\uFEFF")
                continue;
              vt(V, Y);
              continue;
            case T.BEGIN_WHITESPACE:
              vt(V, Y);
              continue;
            case T.TEXT:
              if (V.sawRoot && !V.closedRoot) {
                for (var W = tt - 1; Y && Y !== "<" && Y !== "&"; )
                  Y = bt(R, tt++), Y && V.trackPosition && (V.position++, Y === `
` ? (V.line++, V.column = 0) : V.column++);
                V.textNode += R.substring(W, tt - 1);
              }
              Y === "<" && !(V.sawRoot && V.closedRoot && !V.strict) ? (V.state = T.OPEN_WAKA, V.startTagPosition = V.position) : (!C(Y) && (!V.sawRoot || V.closedRoot) && j(V, "Text data outside of root node."), Y === "&" ? V.state = T.TEXT_ENTITY : V.textNode += Y);
              continue;
            case T.SCRIPT:
              Y === "<" ? V.state = T.SCRIPT_ENDING : V.script += Y;
              continue;
            case T.SCRIPT_ENDING:
              Y === "/" ? V.state = T.CLOSE_TAG : (V.script += "<" + Y, V.state = T.SCRIPT);
              continue;
            case T.OPEN_WAKA:
              if (Y === "!")
                V.state = T.SGML_DECL, V.sgmlDecl = "";
              else if (!C(Y))
                if (P(m, Y))
                  V.state = T.OPEN_TAG, V.tagName = Y;
                else if (Y === "/")
                  V.state = T.CLOSE_TAG, V.tagName = "";
                else if (Y === "?")
                  V.state = T.PROC_INST, V.procInstName = V.procInstBody = "";
                else {
                  if (j(V, "Unencoded <"), V.startTagPosition + 1 < V.position) {
                    var z = V.position - V.startTagPosition;
                    Y = new Array(z).join(" ") + Y;
                  }
                  V.textNode += "<" + Y, V.state = T.TEXT;
                }
              continue;
            case T.SGML_DECL:
              (V.sgmlDecl + Y).toUpperCase() === u ? (A(V, "onopencdata"), V.state = T.CDATA, V.sgmlDecl = "", V.cdata = "") : V.sgmlDecl + Y === "--" ? (V.state = T.COMMENT, V.comment = "", V.sgmlDecl = "") : (V.sgmlDecl + Y).toUpperCase() === c ? (V.state = T.DOCTYPE, (V.doctype || V.sawRoot) && j(
                V,
                "Inappropriately located doctype declaration"
              ), V.doctype = "", V.sgmlDecl = "") : Y === ">" ? (A(V, "onsgmldeclaration", V.sgmlDecl), V.sgmlDecl = "", V.state = T.TEXT) : (x(Y) && (V.state = T.SGML_DECL_QUOTED), V.sgmlDecl += Y);
              continue;
            case T.SGML_DECL_QUOTED:
              Y === V.q && (V.state = T.SGML_DECL, V.q = ""), V.sgmlDecl += Y;
              continue;
            case T.DOCTYPE:
              Y === ">" ? (V.state = T.TEXT, A(V, "ondoctype", V.doctype), V.doctype = !0) : (V.doctype += Y, Y === "[" ? V.state = T.DOCTYPE_DTD : x(Y) && (V.state = T.DOCTYPE_QUOTED, V.q = Y));
              continue;
            case T.DOCTYPE_QUOTED:
              V.doctype += Y, Y === V.q && (V.q = "", V.state = T.DOCTYPE);
              continue;
            case T.DOCTYPE_DTD:
              V.doctype += Y, Y === "]" ? V.state = T.DOCTYPE : x(Y) && (V.state = T.DOCTYPE_DTD_QUOTED, V.q = Y);
              continue;
            case T.DOCTYPE_DTD_QUOTED:
              V.doctype += Y, Y === V.q && (V.state = T.DOCTYPE_DTD, V.q = "");
              continue;
            case T.COMMENT:
              Y === "-" ? V.state = T.COMMENT_ENDING : V.comment += Y;
              continue;
            case T.COMMENT_ENDING:
              Y === "-" ? (V.state = T.COMMENT_ENDED, V.comment = I(V.opt, V.comment), V.comment && A(V, "oncomment", V.comment), V.comment = "") : (V.comment += "-" + Y, V.state = T.COMMENT);
              continue;
            case T.COMMENT_ENDED:
              Y !== ">" ? (j(V, "Malformed comment"), V.comment += "--" + Y, V.state = T.COMMENT) : V.state = T.TEXT;
              continue;
            case T.CDATA:
              Y === "]" ? V.state = T.CDATA_ENDING : V.cdata += Y;
              continue;
            case T.CDATA_ENDING:
              Y === "]" ? V.state = T.CDATA_ENDING_2 : (V.cdata += "]" + Y, V.state = T.CDATA);
              continue;
            case T.CDATA_ENDING_2:
              Y === ">" ? (V.cdata && A(V, "oncdata", V.cdata), A(V, "onclosecdata"), V.cdata = "", V.state = T.TEXT) : Y === "]" ? V.cdata += "]" : (V.cdata += "]]" + Y, V.state = T.CDATA);
              continue;
            case T.PROC_INST:
              Y === "?" ? V.state = T.PROC_INST_ENDING : C(Y) ? V.state = T.PROC_INST_BODY : V.procInstName += Y;
              continue;
            case T.PROC_INST_BODY:
              if (!V.procInstBody && C(Y))
                continue;
              Y === "?" ? V.state = T.PROC_INST_ENDING : V.procInstBody += Y;
              continue;
            case T.PROC_INST_ENDING:
              Y === ">" ? (A(V, "onprocessinginstruction", {
                name: V.procInstName,
                body: V.procInstBody
              }), V.procInstName = V.procInstBody = "", V.state = T.TEXT) : (V.procInstBody += "?" + Y, V.state = T.PROC_INST_BODY);
              continue;
            case T.OPEN_TAG:
              P(v, Y) ? V.tagName += Y : (k(V), Y === ">" ? et(V) : Y === "/" ? V.state = T.OPEN_TAG_SLASH : (C(Y) || j(V, "Invalid character in tag name"), V.state = T.ATTRIB));
              continue;
            case T.OPEN_TAG_SLASH:
              Y === ">" ? (et(V, !0), Z(V)) : (j(V, "Forward-slash in opening tag not followed by >"), V.state = T.ATTRIB);
              continue;
            case T.ATTRIB:
              if (C(Y))
                continue;
              Y === ">" ? et(V) : Y === "/" ? V.state = T.OPEN_TAG_SLASH : P(m, Y) ? (V.attribName = Y, V.attribValue = "", V.state = T.ATTRIB_NAME) : j(V, "Invalid attribute name");
              continue;
            case T.ATTRIB_NAME:
              Y === "=" ? V.state = T.ATTRIB_VALUE : Y === ">" ? (j(V, "Attribute without value"), V.attribValue = V.attribName, rt(V), et(V)) : C(Y) ? V.state = T.ATTRIB_NAME_SAW_WHITE : P(v, Y) ? V.attribName += Y : j(V, "Invalid attribute name");
              continue;
            case T.ATTRIB_NAME_SAW_WHITE:
              if (Y === "=")
                V.state = T.ATTRIB_VALUE;
              else {
                if (C(Y))
                  continue;
                j(V, "Attribute without value"), V.tag.attributes[V.attribName] = "", V.attribValue = "", A(V, "onattribute", {
                  name: V.attribName,
                  value: ""
                }), V.attribName = "", Y === ">" ? et(V) : P(m, Y) ? (V.attribName = Y, V.state = T.ATTRIB_NAME) : (j(V, "Invalid attribute name"), V.state = T.ATTRIB);
              }
              continue;
            case T.ATTRIB_VALUE:
              if (C(Y))
                continue;
              x(Y) ? (V.q = Y, V.state = T.ATTRIB_VALUE_QUOTED) : (j(V, "Unquoted attribute value"), V.state = T.ATTRIB_VALUE_UNQUOTED, V.attribValue = Y);
              continue;
            case T.ATTRIB_VALUE_QUOTED:
              if (Y !== V.q) {
                Y === "&" ? V.state = T.ATTRIB_VALUE_ENTITY_Q : V.attribValue += Y;
                continue;
              }
              rt(V), V.q = "", V.state = T.ATTRIB_VALUE_CLOSED;
              continue;
            case T.ATTRIB_VALUE_CLOSED:
              C(Y) ? V.state = T.ATTRIB : Y === ">" ? et(V) : Y === "/" ? V.state = T.OPEN_TAG_SLASH : P(m, Y) ? (j(V, "No whitespace between attributes"), V.attribName = Y, V.attribValue = "", V.state = T.ATTRIB_NAME) : j(V, "Invalid attribute name");
              continue;
            case T.ATTRIB_VALUE_UNQUOTED:
              if (!b(Y)) {
                Y === "&" ? V.state = T.ATTRIB_VALUE_ENTITY_U : V.attribValue += Y;
                continue;
              }
              rt(V), Y === ">" ? et(V) : V.state = T.ATTRIB;
              continue;
            case T.CLOSE_TAG:
              if (V.tagName)
                Y === ">" ? Z(V) : P(v, Y) ? V.tagName += Y : V.script ? (V.script += "</" + V.tagName, V.tagName = "", V.state = T.SCRIPT) : (C(Y) || j(V, "Invalid tagname in closing tag"), V.state = T.CLOSE_TAG_SAW_WHITE);
              else {
                if (C(Y))
                  continue;
                O(m, Y) ? V.script ? (V.script += "</" + Y, V.state = T.SCRIPT) : j(V, "Invalid tagname in closing tag.") : V.tagName = Y;
              }
              continue;
            case T.CLOSE_TAG_SAW_WHITE:
              if (C(Y))
                continue;
              Y === ">" ? Z(V) : j(V, "Invalid characters in closing tag");
              continue;
            case T.TEXT_ENTITY:
            case T.ATTRIB_VALUE_ENTITY_Q:
            case T.ATTRIB_VALUE_ENTITY_U:
              var at, ct;
              switch (V.state) {
                case T.TEXT_ENTITY:
                  at = T.TEXT, ct = "textNode";
                  break;
                case T.ATTRIB_VALUE_ENTITY_Q:
                  at = T.ATTRIB_VALUE_QUOTED, ct = "attribValue";
                  break;
                case T.ATTRIB_VALUE_ENTITY_U:
                  at = T.ATTRIB_VALUE_UNQUOTED, ct = "attribValue";
                  break;
              }
              if (Y === ";")
                if (V.opt.unparsedEntities) {
                  var Mt = dt(V);
                  V.entity = "", V.state = at, V.write(Mt);
                } else
                  V[ct] += dt(V), V.entity = "", V.state = at;
              else
                P(V.entity.length ? E : y, Y) ? V.entity += Y : (j(V, "Invalid character in entity name"), V[ct] += "&" + V.entity + Y, V.entity = "", V.state = at);
              continue;
            default:
              throw new Error(V, "Unknown state: " + V.state);
          }
        return V.position >= V.bufferCheckPosition && r(V), V;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var R = String.fromCharCode, V = Math.floor, tt = function() {
          var Y = 16384, W = [], z, at, ct = -1, Mt = arguments.length;
          if (!Mt)
            return "";
          for (var N = ""; ++ct < Mt; ) {
            var S = Number(arguments[ct]);
            if (!isFinite(S) || // `NaN`, `+Infinity`, or `-Infinity`
            S < 0 || // not a valid Unicode code point
            S > 1114111 || // not a valid Unicode code point
            V(S) !== S)
              throw RangeError("Invalid code point: " + S);
            S <= 65535 ? W.push(S) : (S -= 65536, z = (S >> 10) + 55296, at = S % 1024 + 56320, W.push(z, at)), (ct + 1 === Mt || W.length > Y) && (N += R.apply(null, W), W.length = 0);
          }
          return N;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: tt,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = tt;
      }();
    })(e);
  }(Dm)), Dm;
}
var Xm = {}, jb;
function _5() {
  return jb || (jb = 1, (function() {
    Xm.stripBOM = function(e) {
      return e[0] === "\uFEFF" ? e.substring(1) : e;
    };
  }).call(It)), Xm;
}
var go = {}, $b;
function MM() {
  return $b || ($b = 1, (function() {
    var e;
    e = new RegExp(/(?!xmlns)^.*:/), go.normalize = function(t) {
      return t.toLowerCase();
    }, go.firstCharLowerCase = function(t) {
      return t.charAt(0).toLowerCase() + t.slice(1);
    }, go.stripPrefix = function(t) {
      return t.replace(e, "");
    }, go.parseNumbers = function(t) {
      return isNaN(t) || (t = t % 1 === 0 ? parseInt(t, 10) : parseFloat(t)), t;
    }, go.parseBooleans = function(t) {
      return /^(?:true|false)$/i.test(t) && (t = t.toLowerCase() === "true"), t;
    };
  }).call(It)), go;
}
var fr = {}, Ub = {}, Wb;
function I5() {
  return Wb || (Wb = 1, function(e, t) {
    if (e.setImmediate)
      return;
    var n = 1, s = {}, r = !1, i = e.document, a;
    function o(y) {
      typeof y != "function" && (y = new Function("" + y));
      for (var E = new Array(arguments.length - 1), C = 0; C < E.length; C++)
        E[C] = arguments[C + 1];
      var x = { callback: y, args: E };
      return s[n] = x, a(n), n++;
    }
    function l(y) {
      delete s[y];
    }
    function f(y) {
      var E = y.callback, C = y.args;
      switch (C.length) {
        case 0:
          E();
          break;
        case 1:
          E(C[0]);
          break;
        case 2:
          E(C[0], C[1]);
          break;
        case 3:
          E(C[0], C[1], C[2]);
          break;
        default:
          E.apply(t, C);
          break;
      }
    }
    function d(y) {
      if (r)
        setTimeout(d, 0, y);
      else {
        var E = s[y];
        if (E) {
          r = !0;
          try {
            f(E);
          } finally {
            l(y), r = !1;
          }
        }
      }
    }
    function u() {
      a = function(y) {
        process.nextTick(function() {
          d(y);
        });
      };
    }
    function c() {
      if (e.postMessage && !e.importScripts) {
        var y = !0, E = e.onmessage;
        return e.onmessage = function() {
          y = !1;
        }, e.postMessage("", "*"), e.onmessage = E, y;
      }
    }
    function h() {
      var y = "setImmediate$" + Math.random() + "$", E = function(C) {
        C.source === e && typeof C.data == "string" && C.data.indexOf(y) === 0 && d(+C.data.slice(y.length));
      };
      e.addEventListener ? e.addEventListener("message", E, !1) : e.attachEvent("onmessage", E), a = function(C) {
        e.postMessage(y + C, "*");
      };
    }
    function p() {
      var y = new MessageChannel();
      y.port1.onmessage = function(E) {
        var C = E.data;
        d(C);
      }, a = function(E) {
        y.port2.postMessage(E);
      };
    }
    function g() {
      var y = i.documentElement;
      a = function(E) {
        var C = i.createElement("script");
        C.onreadystatechange = function() {
          d(E), C.onreadystatechange = null, y.removeChild(C), C = null;
        }, y.appendChild(C);
      };
    }
    function m() {
      a = function(y) {
        setTimeout(d, 0, y);
      };
    }
    var v = Object.getPrototypeOf && Object.getPrototypeOf(e);
    v = v && v.setTimeout ? v : e, {}.toString.call(e.process) === "[object process]" ? u() : c() ? h() : e.MessageChannel ? p() : i && "onreadystatechange" in i.createElement("script") ? g() : m(), v.setImmediate = o, v.clearImmediate = l;
  }(typeof self > "u" ? It : self)), Ub;
}
var zb;
function D5() {
  if (zb)
    return fr;
  zb = 1;
  var e = typeof It < "u" && It || typeof self < "u" && self || window, t = Function.prototype.apply;
  fr.setTimeout = function() {
    return new n(t.call(setTimeout, e, arguments), clearTimeout);
  }, fr.setInterval = function() {
    return new n(t.call(setInterval, e, arguments), clearInterval);
  }, fr.clearTimeout = fr.clearInterval = function(s) {
    s && s.close();
  };
  function n(s, r) {
    this._id = s, this._clearFn = r;
  }
  return n.prototype.unref = n.prototype.ref = function() {
  }, n.prototype.close = function() {
    this._clearFn.call(e, this._id);
  }, fr.enroll = function(s, r) {
    clearTimeout(s._idleTimeoutId), s._idleTimeout = r;
  }, fr.unenroll = function(s) {
    clearTimeout(s._idleTimeoutId), s._idleTimeout = -1;
  }, fr._unrefActive = fr.active = function(s) {
    clearTimeout(s._idleTimeoutId);
    var r = s._idleTimeout;
    r >= 0 && (s._idleTimeoutId = setTimeout(function() {
      s._onTimeout && s._onTimeout();
    }, r));
  }, I5(), fr.setImmediate = typeof self < "u" && self.setImmediate || typeof It < "u" && It.setImmediate || It && It.setImmediate, fr.clearImmediate = typeof self < "u" && self.clearImmediate || typeof It < "u" && It.clearImmediate || It && It.clearImmediate, fr;
}
var Kb;
function A5() {
  return Kb || (Kb = 1, function(e) {
    (function() {
      var t, n, s, r, i, a, o, l, f = function(c, h) {
        return function() {
          return c.apply(h, arguments);
        };
      }, d = function(c, h) {
        for (var p in h)
          u.call(h, p) && (c[p] = h[p]);
        function g() {
          this.constructor = c;
        }
        return g.prototype = h.prototype, c.prototype = new g(), c.__super__ = h.prototype, c;
      }, u = {}.hasOwnProperty;
      o = M5(), s = np(), t = _5(), a = MM(), l = D5().setImmediate, n = F0().defaults, r = function(c) {
        return typeof c == "object" && c != null && Object.keys(c).length === 0;
      }, i = function(c, h, p) {
        var g, m, v;
        for (g = 0, m = c.length; g < m; g++)
          v = c[g], h = v(h, p);
        return h;
      }, e.Parser = function(c) {
        d(h, c);
        function h(p) {
          this.parseStringPromise = f(this.parseStringPromise, this), this.parseString = f(this.parseString, this), this.reset = f(this.reset, this), this.assignOrPush = f(this.assignOrPush, this), this.processAsync = f(this.processAsync, this);
          var g, m, v;
          if (!(this instanceof e.Parser))
            return new e.Parser(p);
          this.options = {}, m = n["0.2"];
          for (g in m)
            u.call(m, g) && (v = m[g], this.options[g] = v);
          for (g in p)
            u.call(p, g) && (v = p[g], this.options[g] = v);
          this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), this.options.tagNameProcessors.unshift(a.normalize)), this.reset();
        }
        return h.prototype.processAsync = function() {
          var p, g;
          try {
            return this.remaining.length <= this.options.chunkSize ? (p = this.remaining, this.remaining = "", this.saxParser = this.saxParser.write(p), this.saxParser.close()) : (p = this.remaining.substr(0, this.options.chunkSize), this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), this.saxParser = this.saxParser.write(p), l(this.processAsync));
          } catch (m) {
            if (g = m, !this.saxParser.errThrown)
              return this.saxParser.errThrown = !0, this.emit(g);
          }
        }, h.prototype.assignOrPush = function(p, g, m) {
          return g in p ? (p[g] instanceof Array || (p[g] = [p[g]]), p[g].push(m)) : this.options.explicitArray ? p[g] = [m] : p[g] = m;
        }, h.prototype.reset = function() {
          var p, g, m, v;
          return this.removeAllListeners(), this.saxParser = o.parser(this.options.strict, {
            trim: !1,
            normalize: !1,
            xmlns: this.options.xmlns
          }), this.saxParser.errThrown = !1, this.saxParser.onerror = function(y) {
            return function(E) {
              if (y.saxParser.resume(), !y.saxParser.errThrown)
                return y.saxParser.errThrown = !0, y.emit("error", E);
            };
          }(this), this.saxParser.onend = function(y) {
            return function() {
              if (!y.saxParser.ended)
                return y.saxParser.ended = !0, y.emit("end", y.resultObject);
            };
          }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, this.resultObject = null, v = [], p = this.options.attrkey, g = this.options.charkey, this.saxParser.onopentag = function(y) {
            return function(E) {
              var C, x, b, P, O;
              if (b = {}, b[g] = "", !y.options.ignoreAttrs) {
                O = E.attributes;
                for (C in O)
                  u.call(O, C) && (!(p in b) && !y.options.mergeAttrs && (b[p] = {}), x = y.options.attrValueProcessors ? i(y.options.attrValueProcessors, E.attributes[C], C) : E.attributes[C], P = y.options.attrNameProcessors ? i(y.options.attrNameProcessors, C) : C, y.options.mergeAttrs ? y.assignOrPush(b, P, x) : b[p][P] = x);
              }
              return b["#name"] = y.options.tagNameProcessors ? i(y.options.tagNameProcessors, E.name) : E.name, y.options.xmlns && (b[y.options.xmlnskey] = {
                uri: E.uri,
                local: E.local
              }), v.push(b);
            };
          }(this), this.saxParser.onclosetag = function(y) {
            return function() {
              var E, C, x, b, P, O, T, M, L, A;
              if (O = v.pop(), P = O["#name"], (!y.options.explicitChildren || !y.options.preserveChildrenOrder) && delete O["#name"], O.cdata === !0 && (E = O.cdata, delete O.cdata), L = v[v.length - 1], O[g].match(/^\s*$/) && !E ? (C = O[g], delete O[g]) : (y.options.trim && (O[g] = O[g].trim()), y.options.normalize && (O[g] = O[g].replace(/\s{2,}/g, " ").trim()), O[g] = y.options.valueProcessors ? i(y.options.valueProcessors, O[g], P) : O[g], Object.keys(O).length === 1 && g in O && !y.EXPLICIT_CHARKEY && (O = O[g])), r(O) && (O = y.options.emptyTag !== "" ? y.options.emptyTag : C), y.options.validator != null && (A = "/" + function() {
                var D, I, w;
                for (w = [], D = 0, I = v.length; D < I; D++)
                  b = v[D], w.push(b["#name"]);
                return w;
              }().concat(P).join("/"), function() {
                var D;
                try {
                  return O = y.options.validator(A, L && L[P], O);
                } catch (I) {
                  return D = I, y.emit("error", D);
                }
              }()), y.options.explicitChildren && !y.options.mergeAttrs && typeof O == "object") {
                if (!y.options.preserveChildrenOrder)
                  b = {}, y.options.attrkey in O && (b[y.options.attrkey] = O[y.options.attrkey], delete O[y.options.attrkey]), !y.options.charsAsChildren && y.options.charkey in O && (b[y.options.charkey] = O[y.options.charkey], delete O[y.options.charkey]), Object.getOwnPropertyNames(O).length > 0 && (b[y.options.childkey] = O), O = b;
                else if (L) {
                  L[y.options.childkey] = L[y.options.childkey] || [], T = {};
                  for (x in O)
                    u.call(O, x) && (T[x] = O[x]);
                  L[y.options.childkey].push(T), delete O["#name"], Object.keys(O).length === 1 && g in O && !y.EXPLICIT_CHARKEY && (O = O[g]);
                }
              }
              return v.length > 0 ? y.assignOrPush(L, P, O) : (y.options.explicitRoot && (M = O, O = {}, O[P] = M), y.resultObject = O, y.saxParser.ended = !0, y.emit("end", y.resultObject));
            };
          }(this), m = function(y) {
            return function(E) {
              var C, x;
              if (x = v[v.length - 1], x)
                return x[g] += E, y.options.explicitChildren && y.options.preserveChildrenOrder && y.options.charsAsChildren && (y.options.includeWhiteChars || E.replace(/\\n/g, "").trim() !== "") && (x[y.options.childkey] = x[y.options.childkey] || [], C = {
                  "#name": "__text__"
                }, C[g] = E, y.options.normalize && (C[g] = C[g].replace(/\s{2,}/g, " ").trim()), x[y.options.childkey].push(C)), x;
            };
          }(this), this.saxParser.ontext = m, this.saxParser.oncdata = function(y) {
            return function(E) {
              var C;
              if (C = m(E), C)
                return C.cdata = !0;
            };
          }();
        }, h.prototype.parseString = function(p, g) {
          var m;
          g != null && typeof g == "function" && (this.on("end", function(v) {
            return this.reset(), g(null, v);
          }), this.on("error", function(v) {
            return this.reset(), g(v);
          }));
          try {
            return p = p.toString(), p.trim() === "" ? (this.emit("end", null), !0) : (p = t.stripBOM(p), this.options.async ? (this.remaining = p, l(this.processAsync), this.saxParser) : this.saxParser.write(p).close());
          } catch (v) {
            if (m = v, this.saxParser.errThrown || this.saxParser.ended) {
              if (this.saxParser.ended)
                throw m;
            } else
              return this.emit("error", m), this.saxParser.errThrown = !0;
          }
        }, h.prototype.parseStringPromise = function(p) {
          return new Promise(function(g) {
            return function(m, v) {
              return g.parseString(p, function(y, E) {
                return y ? v(y) : m(E);
              });
            };
          }(this));
        }, h;
      }(s), e.parseString = function(c, h, p) {
        var g, m, v;
        return p != null ? (typeof p == "function" && (g = p), typeof h == "object" && (m = h)) : (typeof h == "function" && (g = h), m = {}), v = new e.Parser(m), v.parseString(c, g);
      }, e.parseStringPromise = function(c, h) {
        var p, g;
        return typeof h == "object" && (p = h), g = new e.Parser(p), g.parseStringPromise(c);
      };
    }).call(It);
  }(Im)), Im;
}
(function() {
  var e, t, n, s, r = function(a, o) {
    for (var l in o)
      i.call(o, l) && (a[l] = o[l]);
    function f() {
      this.constructor = a;
    }
    return f.prototype = o.prototype, a.prototype = new f(), a.__super__ = o.prototype, a;
  }, i = {}.hasOwnProperty;
  t = F0(), e = m5(), n = A5(), s = MM(), os.defaults = t.defaults, os.processors = s, os.ValidationError = function(a) {
    r(o, a);
    function o(l) {
      this.message = l;
    }
    return o;
  }(Error), os.Builder = e.Builder, os.Parser = n.Parser, os.parseString = n.parseString, os.parseStringPromise = n.parseStringPromise;
}).call(It);
const Fe = {
  STREET: "street",
  DISTRICT: "district",
  PARCEL: "parcel",
  STREET_KEY: "streetKey",
  ADDRESS_AFFIXED: "addressAffixed",
  ADDRESS_UNAFFIXED: "addressUnaffixed",
  HOUSE_NUMBERS_FOR_STREET: "houseNumbersForStreet"
};
let L5 = fi.showGeographicIdentifier;
function Nh() {
  return L5;
}
function _M(e) {
  return Array.isArray(e) && e.length === 1 ? _M(e[0]) : e;
}
function tf(e, t) {
  return Array.isArray(e) ? e.map((n) => tf(n, t)).filter((n) => n)[0] : typeof e != "object" ? null : typeof e[t] < "u" ? e[t] : Object.keys(e).map((n) => tf(e[n], t)).filter((n) => n)[0];
}
function R5(e) {
  const t = {
    objectType: Object.keys(e)[0]
  };
  return Object.keys(e[t.objectType][0]).forEach((n) => {
    t[n] = _M(e[t.objectType][0][n]);
  }), t;
}
function w5(e) {
  var n;
  let t = [];
  return e.startsWith("POINT") && (t = (n = e.split(")")[0]) == null ? void 0 : n.split("(")[1]), t;
}
function V5(e, t) {
  var o, l, f, d, u, c, h, p, g, m, v, y, E;
  const n = {
    type: t,
    properties: R5(e)
  };
  let s = (o = n.properties) != null && o.pos ? w5(n.properties.pos) : tf(n.properties, "pos")[0], r = "", i = "", a = "";
  switch (t) {
    case Fe.DISTRICT:
      n.name = (l = n.properties.geographicIdentifier) != null && l._ ? n.properties.geographicIdentifier._ : n.properties.geographicIdentifier;
      break;
    case Fe.STREET_KEY:
    case Fe.STREET:
      (f = n.properties) != null && f.position_strassenachse && (s = tf((d = n.properties) == null ? void 0 : d.position_strassenachse, "pos")[0]), n.name = Nh() ? n.properties.geographicIdentifier._ : n.properties.strassenname;
      break;
    case Fe.PARCEL:
      n.name = `${n.properties.gemarkung}/${n.properties.flurstuecksnummer}`;
      break;
    case Fe.HOUSE_NUMBERS_FOR_STREET:
      r = (u = n.properties.hausnummer) != null && u._ ? n.properties.hausnummer._ : n.properties.hausnummer, n.properties.hausnummernzusatz && (i = (c = n.properties.hausnummernzusatz) != null && c._ ? n.properties.hausnummernzusatz._ : n.properties.hausnummernzusatz), n.properties.hausnummerkomplett = `${r}${i}`, n.name = Nh() ? n.properties.geographicIdentifier._ : ((h = n.properties) != null && h.geographicIdentifier ? n.properties.geographicIdentifier._.split(n.properties.hausnummerkomplett)[0] : n.properties.strassenname + " ") + n.properties.hausnummerkomplett;
      break;
    case Fe.ADDRESS_AFFIXED:
      a = (p = n.properties.strassenname) != null && p._ ? n.properties.strassenname._ : n.properties.strassenname, r = (g = n.properties.hausnummer) != null && g._ ? n.properties.hausnummer._ : n.properties.hausnummer, i = (m = n.properties.hausnummernzusatz) != null && m._ ? n.properties.hausnummernzusatz._ : n.properties.hausnummernzusatz, n.name = Nh() ? n.properties.geographicIdentifier._ : `${a} ${r}${i}`;
      break;
    case Fe.ADDRESS_UNAFFIXED:
      a = (v = n.properties.strassenname) != null && v._ ? n.properties.strassenname._ : n.properties.strassenname, r = (y = n.properties.hausnummer) != null && y._ ? n.properties.hausnummer._ : n.properties.hausnummer, n.name = Nh() ? n.properties.geographicIdentifier._ : ((E = n.properties) != null && E.geographicIdentifier ? n.properties.geographicIdentifier._.split(r)[0] : a + " ") + r;
      break;
    default:
      n.name = null, console.error(`Unknown type in searchAddress.parse: '${t}'. Could not set name.`);
      break;
  }
  switch (t) {
    case Fe.DISTRICT:
    case Fe.STREET_KEY:
    case Fe.STREET:
    case Fe.PARCEL:
    case Fe.HOUSE_NUMBERS_FOR_STREET:
    case Fe.ADDRESS_AFFIXED:
    case Fe.ADDRESS_UNAFFIXED:
      n.geometry = {
        type: "Point",
        coordinates: s.split(" ")
      };
      break;
    default:
      n.geometry = null, console.error(`Unknown type in searchAddress.parse: '${t}'. Could not set geometry.`);
      break;
  }
  return n;
}
function IM(e, t) {
  return new Promise((n, s) => {
    os.parseString(
      t,
      { tagNameProcessors: [os.processors.stripPrefix] },
      (r, i) => {
        var a;
        if (r) {
          s(r);
          return;
        }
        try {
          const o = (a = i.FeatureCollection) != null && a.member ? i.FeatureCollection.member.map((l) => V5(l, e)).sort((l, f) => l.name.localeCompare(f.name)) : [];
          n(o);
        } catch (o) {
          s(o);
        }
      }
    );
  });
}
let DM = fi.gazetteerUrl;
function q0(e) {
  e && (DM = e);
}
function B5() {
  return DM;
}
function F5(e) {
  return Array.isArray(e) ? e.map(encodeURIComponent) : encodeURIComponent(e);
}
function N5(e, t) {
  return {
    [Fe.STREET]: (n) => `&StoredQuery_ID=findeStrasse&strassenname=*${n}`,
    [Fe.DISTRICT]: (n) => `&StoredQuery_ID=findeStadtteil&stadtteilname=${n}`,
    [Fe.PARCEL]: (n) => `&StoredQuery_ID=Flurstueck&gemarkung=${n[0]}&flurstuecksnummer=${n[1]}`,
    [Fe.STREET_KEY]: (n) => `&StoredQuery_ID=findeStrassenSchluessel&strassenschluessel=${n}`,
    [Fe.ADDRESS_AFFIXED]: (n) => `&StoredQuery_ID=AdresseMitZusatz&strassenname=${n[0]}&hausnummer=${n[1]}&zusatz=${n[2]}`,
    [Fe.ADDRESS_UNAFFIXED]: (n) => `&StoredQuery_ID=AdresseOhneZusatz&strassenname=${n[0]}&hausnummer=${n[1]}`,
    [Fe.HOUSE_NUMBERS_FOR_STREET]: (n) => `&StoredQuery_ID=HausnummernZuStrasse&strassenname=${n}`
  }[e](F5(t));
}
function AM(e, t, n) {
  return new Promise((s, r) => {
    const i = B5() + N5(e, t);
    fetch(i, {
      signal: n == null ? void 0 : n.signal,
      timeout: 6e3
    }).then((a) => s(a.text())).catch((a) => r(a));
  });
}
let oc = null;
function qu(e, t) {
  return new Promise((n, s) => {
    AM(e, t, oc).then((r) => {
      const i = IM(e, r);
      n(i);
    }).catch((r) => s(r));
  });
}
function j5(e, t) {
  return new Promise((n, s) => {
    AM(Fe.STREET, e, oc).then((r) => IM(Fe.STREET, r)).then((r) => {
      const i = [];
      for (let a = 0; a < r.length; a++)
        i.push([r[a]]), t && i.push(qu(Fe.HOUSE_NUMBERS_FOR_STREET, r[a].name));
      return Promise.all(i);
    }).then((r) => n([].concat(...r))).catch((r) => s(r));
  });
}
function LM(e, t, n = !1) {
  return n && oc !== null && oc.abort(), oc = new AbortController(), new Promise((s, r) => {
    const {
      map: i,
      zoom: a = !1,
      zoomToParams: o,
      searchAddress: l = !1,
      searchStreets: f = !1,
      searchDistricts: d = !1,
      searchParcels: u = !1,
      searchStreetKey: c = !1,
      minCharacters: h = 3
    } = t, p = [];
    let {
      searchHouseNumbers: g = !1
    } = t;
    if (e.length < h) {
      r({ error: "Search string too short." });
      return;
    }
    if (a && !i && console.warn("Instructed to zoom, but required map object was not given. Zooming will be skipped."), !f && g && (console.warn(`Search for '${e}' supposed to retrieve house numbers, but not streets. Invalid search configuration. House numbers will not be searched for as a result.`), g = !1), !(l || f || g || d || u || c)) {
      r({ error: `Search for '${e}' received no indication what to search for. Search is canceled.` });
      return;
    }
    if (f && p.push(j5(e, g)), l) {
      const m = e.split(/(\d+)/).map((y) => y.trim()).filter((y) => y), v = [!1, !1, Fe.ADDRESS_UNAFFIXED, Fe.ADDRESS_AFFIXED][m.length];
      v && p.push(qu(v, m));
    }
    if (d && /^[a-z-]+$/i.test(e) && p.push(qu(Fe.DISTRICT, e)), c && /^[a-z]{1}[0-9]{1,5}$/i.test(e) && p.push(qu(Fe.STREET_KEY, e)), u) {
      let m;
      /^[0-9]{4}[\s|/][0-9]*$/.test(e) ? m = e.split(/[\s|/]/) : /^[0-9]{5,}$/.test(e) && (m = [e.slice(0, 4), e.slice(4)]), m && p.push(qu(Fe.PARCEL, m));
    }
    Promise.all(p).then((m) => {
      const v = [].concat(...m);
      if (a && i && v.length === 1)
        try {
          a5(i, v[0], o);
        } catch (y) {
          console.error("Zooming to element from gazetteer failed."), console.error(y);
        }
      s(v);
    }).catch((m) => r(m));
  });
}
function RM({ backgroundImage: e, target: t } = {}) {
  const n = document.getElementById(t || fi.target);
  if (n) {
    const s = `url(${// keep "" as explicit none
    typeof e == "string" ? e : fi.backgroundImage})`;
    n.style.backgroundImage = s;
  }
}
function wM({ url: e, typ: t, capabilitiesUrl: n, ...s }) {
  const r = [];
  if (n)
    r.push(n);
  else if (t === "OAF")
    r.push(e);
  else if (t === "Entities3D")
    s.entities.forEach((i) => i.url ? r.push(i.url) : null);
  else if (t === "TileSet3D" || t === "Terrain3D")
    r.push(e);
  else if (t === "GeoJSON") {
    if (!e && s.features)
      return Promise.resolve(200);
    e && r.push(e);
  } else if (t === "VectorTile")
    r.push(e.replaceAll(/\{[xyz]\}/ig, "0"));
  else if (t === "WMTS") {
    const i = (e ? [e] : s.urls).map((a) => a.replace(/\{Style\}/ig, s.style).replace(/\{TileMatrixSet\}/ig, s.tileMatrixSet).replaceAll(/\{(TileMatrix|TileRow|TileCol)\}/ig, "0"));
    r.push(...i);
  } else
    e && r.push(`${e}?service=${t}&request=GetCapabilities`);
  return r.length ? Promise.allSettled(r.map((i) => new Promise((a) => fetch(i, { method: "HEAD" }).then(({ status: o }) => a(o)).catch(() => a(900))))).then((i) => Math.max(...i.map(({ value: a }) => a))) : Promise.resolve(null);
}
const $5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Tileset: B0,
  createMapView: fP,
  crs: WF,
  entities: q3,
  geojson: BS,
  layerLib: i5,
  oaf: dM,
  ping: wM,
  rawLayerList: GF,
  search: LM,
  setBackgroundImage: RM,
  setGazetteerUrl: q0,
  terrain: Y3,
  vectorBase: FS,
  vectorTile: uM,
  wfs: AS,
  wms: tS,
  wmts: hS
}, Symbol.toStringTag, { value: "Module" }));
function U5(e) {
  const t = this.createMap;
  this.createMap = async (n) => {
    try {
      const s = await t(n);
      return e.forEach((r) => r(s)), s;
    } catch (s) {
      console.error("Map creation failed."), console.error(s);
    }
  };
}
/*!
 * Vue.js v2.7.15
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var ci = Object.freeze({}), ce = Array.isArray;
function te(e) {
  return e == null;
}
function ht(e) {
  return e != null;
}
function un(e) {
  return e === !0;
}
function W5(e) {
  return e === !1;
}
function eh(e) {
  return typeof e == "string" || typeof e == "number" || // $flow-disable-line
  typeof e == "symbol" || typeof e == "boolean";
}
function Le(e) {
  return typeof e == "function";
}
function pi(e) {
  return e !== null && typeof e == "object";
}
var tE = Object.prototype.toString;
function Ai(e) {
  return tE.call(e) === "[object Object]";
}
function z5(e) {
  return tE.call(e) === "[object RegExp]";
}
function VM(e) {
  var t = parseFloat(String(e));
  return t >= 0 && Math.floor(t) === t && isFinite(e);
}
function Ev(e) {
  return ht(e) && typeof e.then == "function" && typeof e.catch == "function";
}
function K5(e) {
  return e == null ? "" : Array.isArray(e) || Ai(e) && e.toString === tE ? JSON.stringify(e, null, 2) : String(e);
}
function Ic(e) {
  var t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function zr(e, t) {
  for (var n = /* @__PURE__ */ Object.create(null), s = e.split(","), r = 0; r < s.length; r++)
    n[s[r]] = !0;
  return t ? function(i) {
    return n[i.toLowerCase()];
  } : function(i) {
    return n[i];
  };
}
zr("slot,component", !0);
var G5 = zr("key,ref,slot,slot-scope,is");
function so(e, t) {
  var n = e.length;
  if (n) {
    if (t === e[n - 1]) {
      e.length = n - 1;
      return;
    }
    var s = e.indexOf(t);
    if (s > -1)
      return e.splice(s, 1);
  }
}
var k5 = Object.prototype.hasOwnProperty;
function Ii(e, t) {
  return k5.call(e, t);
}
function il(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(s) {
    var r = t[s];
    return r || (t[s] = e(s));
  };
}
var H5 = /-(\w)/g, Ho = il(function(e) {
  return e.replace(H5, function(t, n) {
    return n ? n.toUpperCase() : "";
  });
}), Y5 = il(function(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}), X5 = /\B([A-Z])/g, nh = il(function(e) {
  return e.replace(X5, "-$1").toLowerCase();
});
function Z5(e, t) {
  function n(s) {
    var r = arguments.length;
    return r ? r > 1 ? e.apply(t, arguments) : e.call(t, s) : e.call(t);
  }
  return n._length = e.length, n;
}
function J5(e, t) {
  return e.bind(t);
}
var BM = Function.prototype.bind ? J5 : Z5;
function Cv(e, t) {
  t = t || 0;
  for (var n = e.length - t, s = new Array(n); n--; )
    s[n] = e[n + t];
  return s;
}
function He(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function FM(e) {
  for (var t = {}, n = 0; n < e.length; n++)
    e[n] && He(t, e[n]);
  return t;
}
function sn(e, t, n) {
}
var jh = function(e, t, n) {
  return !1;
}, NM = function(e) {
  return e;
};
function Yo(e, t) {
  if (e === t)
    return !0;
  var n = pi(e), s = pi(t);
  if (n && s)
    try {
      var r = Array.isArray(e), i = Array.isArray(t);
      if (r && i)
        return e.length === t.length && e.every(function(l, f) {
          return Yo(l, t[f]);
        });
      if (e instanceof Date && t instanceof Date)
        return e.getTime() === t.getTime();
      if (!r && !i) {
        var a = Object.keys(e), o = Object.keys(t);
        return a.length === o.length && a.every(function(l) {
          return Yo(e[l], t[l]);
        });
      } else
        return !1;
    } catch {
      return !1;
    }
  else
    return !n && !s ? String(e) === String(t) : !1;
}
function jM(e, t) {
  for (var n = 0; n < e.length; n++)
    if (Yo(e[n], t))
      return n;
  return -1;
}
function ef(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(this, arguments));
  };
}
function xv(e, t) {
  return e === t ? e === 0 && 1 / e !== 1 / t : e === e || t === t;
}
var Gb = "data-server-rendered", rp = ["component", "directive", "filter"], $M = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch",
  "renderTracked",
  "renderTriggered"
], Er = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: /* @__PURE__ */ Object.create(null),
  /**
   * Whether to suppress warnings.
   */
  silent: !1,
  /**
   * Show production mode tip message on boot?
   */
  productionTip: !1,
  /**
   * Whether to enable devtools
   */
  devtools: !1,
  /**
   * Whether to record perf
   */
  performance: !1,
  /**
   * Error handler for watcher errors
   */
  errorHandler: null,
  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,
  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],
  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: /* @__PURE__ */ Object.create(null),
  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: jh,
  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: jh,
  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: jh,
  /**
   * Get the namespace of an element
   */
  getTagNamespace: sn,
  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: NM,
  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: jh,
  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: !0,
  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: $M
}, Q5 = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function UM(e) {
  var t = (e + "").charCodeAt(0);
  return t === 36 || t === 95;
}
function _n(e, t, n, s) {
  Object.defineProperty(e, t, {
    value: n,
    enumerable: !!s,
    writable: !0,
    configurable: !0
  });
}
var q5 = new RegExp("[^".concat(Q5.source, ".$_\\d]"));
function tz(e) {
  if (!q5.test(e)) {
    var t = e.split(".");
    return function(n) {
      for (var s = 0; s < t.length; s++) {
        if (!n)
          return;
        n = n[t[s]];
      }
      return n;
    };
  }
}
var ez = "__proto__" in {}, Gi = typeof window < "u", Cr = Gi && window.navigator.userAgent.toLowerCase(), Pu = Cr && /msie|trident/.test(Cr), Su = Cr && Cr.indexOf("msie 9.0") > 0, WM = Cr && Cr.indexOf("edge/") > 0;
Cr && Cr.indexOf("android") > 0;
var nz = Cr && /iphone|ipad|ipod|ios/.test(Cr), kb = Cr && Cr.match(/firefox\/(\d+)/), bv = {}.watch, zM = !1;
if (Gi)
  try {
    var Hb = {};
    Object.defineProperty(Hb, "passive", {
      get: function() {
        zM = !0;
      }
    }), window.addEventListener("test-passive", null, Hb);
  } catch {
  }
var $h, ao = function() {
  return $h === void 0 && (!Gi && typeof global < "u" ? $h = global.process && global.process.env.VUE_ENV === "server" : $h = !1), $h;
}, nf = Gi && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function Xl(e) {
  return typeof e == "function" && /native code/.test(e.toString());
}
var ih = typeof Symbol < "u" && Xl(Symbol) && typeof Reflect < "u" && Xl(Reflect.ownKeys), Dc;
typeof Set < "u" && Xl(Set) ? Dc = Set : Dc = /** @class */
function() {
  function e() {
    this.set = /* @__PURE__ */ Object.create(null);
  }
  return e.prototype.has = function(t) {
    return this.set[t] === !0;
  }, e.prototype.add = function(t) {
    this.set[t] = !0;
  }, e.prototype.clear = function() {
    this.set = /* @__PURE__ */ Object.create(null);
  }, e;
}();
var Dn = null;
function iz() {
  return Dn && { proxy: Dn };
}
function eo(e) {
  e === void 0 && (e = null), e || Dn && Dn._scope.off(), Dn = e, e && e._scope.on();
}
var ar = (
  /** @class */
  function() {
    function e(t, n, s, r, i, a, o, l) {
      this.tag = t, this.data = n, this.children = s, this.text = r, this.elm = i, this.ns = void 0, this.context = a, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = n && n.key, this.componentOptions = o, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = l, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
    }
    return Object.defineProperty(e.prototype, "child", {
      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      get: function() {
        return this.componentInstance;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
), Do = function(e) {
  e === void 0 && (e = "");
  var t = new ar();
  return t.text = e, t.isComment = !0, t;
};
function Ll(e) {
  return new ar(void 0, void 0, void 0, String(e));
}
function Tv(e) {
  var t = new ar(
    e.tag,
    e.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    e.children && e.children.slice(),
    e.text,
    e.elm,
    e.context,
    e.componentOptions,
    e.asyncFactory
  );
  return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned = !0, t;
}
var rz = 0, pd = [], sz = function() {
  for (var e = 0; e < pd.length; e++) {
    var t = pd[e];
    t.subs = t.subs.filter(function(n) {
      return n;
    }), t._pending = !1;
  }
  pd.length = 0;
}, xs = (
  /** @class */
  function() {
    function e() {
      this._pending = !1, this.id = rz++, this.subs = [];
    }
    return e.prototype.addSub = function(t) {
      this.subs.push(t);
    }, e.prototype.removeSub = function(t) {
      this.subs[this.subs.indexOf(t)] = null, this._pending || (this._pending = !0, pd.push(this));
    }, e.prototype.depend = function(t) {
      e.target && e.target.addDep(this);
    }, e.prototype.notify = function(t) {
      for (var n = this.subs.filter(function(a) {
        return a;
      }), s = 0, r = n.length; s < r; s++) {
        var i = n[s];
        i.update();
      }
    }, e;
  }()
);
xs.target = null;
var md = [];
function Mu(e) {
  md.push(e), xs.target = e;
}
function _u() {
  md.pop(), xs.target = md[md.length - 1];
}
var KM = Array.prototype, rf = Object.create(KM), az = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
az.forEach(function(e) {
  var t = KM[e];
  _n(rf, e, function() {
    for (var s = [], r = 0; r < arguments.length; r++)
      s[r] = arguments[r];
    var i = t.apply(this, s), a = this.__ob__, o;
    switch (e) {
      case "push":
      case "unshift":
        o = s;
        break;
      case "splice":
        o = s.slice(2);
        break;
    }
    return o && a.observeArray(o), a.dep.notify(), i;
  });
});
var Yb = Object.getOwnPropertyNames(rf), GM = {}, eE = !0;
function no(e) {
  eE = e;
}
var oz = {
  notify: sn,
  depend: sn,
  addSub: sn,
  removeSub: sn
}, Xb = (
  /** @class */
  function() {
    function e(t, n, s) {
      if (n === void 0 && (n = !1), s === void 0 && (s = !1), this.value = t, this.shallow = n, this.mock = s, this.dep = s ? oz : new xs(), this.vmCount = 0, _n(t, "__ob__", this), ce(t)) {
        if (!s)
          if (ez)
            t.__proto__ = rf;
          else
            for (var r = 0, i = Yb.length; r < i; r++) {
              var a = Yb[r];
              _n(t, a, rf[a]);
            }
        n || this.observeArray(t);
      } else
        for (var o = Object.keys(t), r = 0; r < o.length; r++) {
          var a = o[r];
          io(t, a, GM, void 0, n, s);
        }
    }
    return e.prototype.observeArray = function(t) {
      for (var n = 0, s = t.length; n < s; n++)
        sa(t[n], !1, this.mock);
    }, e;
  }()
);
function sa(e, t, n) {
  if (e && Ii(e, "__ob__") && e.__ob__ instanceof Xb)
    return e.__ob__;
  if (eE && (n || !ao()) && (ce(e) || Ai(e)) && Object.isExtensible(e) && !e.__v_skip && !ei(e) && !(e instanceof ar))
    return new Xb(e, t, n);
}
function io(e, t, n, s, r, i) {
  var a = new xs(), o = Object.getOwnPropertyDescriptor(e, t);
  if (!(o && o.configurable === !1)) {
    var l = o && o.get, f = o && o.set;
    (!l || f) && (n === GM || arguments.length === 2) && (n = e[t]);
    var d = !r && sa(n, !1, i);
    return Object.defineProperty(e, t, {
      enumerable: !0,
      configurable: !0,
      get: function() {
        var c = l ? l.call(e) : n;
        return xs.target && (a.depend(), d && (d.dep.depend(), ce(c) && kM(c))), ei(c) && !r ? c.value : c;
      },
      set: function(c) {
        var h = l ? l.call(e) : n;
        if (xv(h, c)) {
          if (f)
            f.call(e, c);
          else {
            if (l)
              return;
            if (!r && ei(h) && !ei(c)) {
              h.value = c;
              return;
            } else
              n = c;
          }
          d = !r && sa(c, !1, i), a.notify();
        }
      }
    }), a;
  }
}
function sp(e, t, n) {
  if (!rl(e)) {
    var s = e.__ob__;
    return ce(e) && VM(t) ? (e.length = Math.max(e.length, t), e.splice(t, 1, n), s && !s.shallow && s.mock && sa(n, !1, !0), n) : t in e && !(t in Object.prototype) ? (e[t] = n, n) : e._isVue || s && s.vmCount ? n : s ? (io(s.value, t, n, void 0, s.shallow, s.mock), s.dep.notify(), n) : (e[t] = n, n);
  }
}
function nE(e, t) {
  if (ce(e) && VM(t)) {
    e.splice(t, 1);
    return;
  }
  var n = e.__ob__;
  e._isVue || n && n.vmCount || rl(e) || Ii(e, t) && (delete e[t], n && n.dep.notify());
}
function kM(e) {
  for (var t = void 0, n = 0, s = e.length; n < s; n++)
    t = e[n], t && t.__ob__ && t.__ob__.dep.depend(), ce(t) && kM(t);
}
function lz(e) {
  return HM(e, !1), e;
}
function iE(e) {
  return HM(e, !0), _n(e, "__v_isShallow", !0), e;
}
function HM(e, t) {
  rl(e) || sa(
    e,
    t,
    ao()
    /* ssr mock reactivity */
  );
}
function Ao(e) {
  return rl(e) ? Ao(e.__v_raw) : !!(e && e.__ob__);
}
function sf(e) {
  return !!(e && e.__v_isShallow);
}
function rl(e) {
  return !!(e && e.__v_isReadonly);
}
function uz(e) {
  return Ao(e) || rl(e);
}
function YM(e) {
  var t = e && e.__v_raw;
  return t ? YM(t) : e;
}
function cz(e) {
  return Object.isExtensible(e) && _n(e, "__v_skip", !0), e;
}
var rh = "__v_isRef";
function ei(e) {
  return !!(e && e.__v_isRef === !0);
}
function hz(e) {
  return XM(e, !1);
}
function dz(e) {
  return XM(e, !0);
}
function XM(e, t) {
  if (ei(e))
    return e;
  var n = {};
  return _n(n, rh, !0), _n(n, "__v_isShallow", t), _n(n, "dep", io(n, "value", e, null, t, ao())), n;
}
function fz(e) {
  e.dep && e.dep.notify();
}
function pz(e) {
  return ei(e) ? e.value : e;
}
function mz(e) {
  if (Ao(e))
    return e;
  for (var t = {}, n = Object.keys(e), s = 0; s < n.length; s++)
    af(t, e, n[s]);
  return t;
}
function af(e, t, n) {
  Object.defineProperty(e, n, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      var s = t[n];
      if (ei(s))
        return s.value;
      var r = s && s.__ob__;
      return r && r.dep.depend(), s;
    },
    set: function(s) {
      var r = t[n];
      ei(r) && !ei(s) ? r.value = s : t[n] = s;
    }
  });
}
function gz(e) {
  var t = new xs(), n = e(function() {
    t.depend();
  }, function() {
    t.notify();
  }), s = n.get, r = n.set, i = {
    get value() {
      return s();
    },
    set value(a) {
      r(a);
    }
  };
  return _n(i, rh, !0), i;
}
function vz(e) {
  var t = ce(e) ? new Array(e.length) : {};
  for (var n in e)
    t[n] = ZM(e, n);
  return t;
}
function ZM(e, t, n) {
  var s = e[t];
  if (ei(s))
    return s;
  var r = {
    get value() {
      var i = e[t];
      return i === void 0 ? n : i;
    },
    set value(i) {
      e[t] = i;
    }
  };
  return _n(r, rh, !0), r;
}
var yz = "__v_rawToReadonly", Ez = "__v_rawToShallowReadonly";
function JM(e) {
  return QM(e, !1);
}
function QM(e, t) {
  if (!Ai(e) || rl(e))
    return e;
  var n = t ? Ez : yz, s = e[n];
  if (s)
    return s;
  var r = Object.create(Object.getPrototypeOf(e));
  _n(e, n, r), _n(r, "__v_isReadonly", !0), _n(r, "__v_raw", e), ei(e) && _n(r, rh, !0), (t || sf(e)) && _n(r, "__v_isShallow", !0);
  for (var i = Object.keys(e), a = 0; a < i.length; a++)
    Cz(r, e, i[a], t);
  return r;
}
function Cz(e, t, n, s) {
  Object.defineProperty(e, n, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      var r = t[n];
      return s || !Ai(r) ? r : JM(r);
    },
    set: function() {
    }
  });
}
function xz(e) {
  return QM(e, !0);
}
function bz(e, t) {
  var n, s, r = Le(e);
  r ? (n = e, s = sn) : (n = e.get, s = e.set);
  var i = ao() ? null : new sh(Dn, n, sn, { lazy: !0 }), a = {
    // some libs rely on the presence effect for checking computed refs
    // from normal refs, but the implementation doesn't matter
    effect: i,
    get value() {
      return i ? (i.dirty && i.evaluate(), xs.target && i.depend(), i.value) : n();
    },
    set value(o) {
      s(o);
    }
  };
  return _n(a, rh, !0), _n(a, "__v_isReadonly", r), a;
}
var ap = "watcher", Zb = "".concat(ap, " callback"), Jb = "".concat(ap, " getter"), Tz = "".concat(ap, " cleanup");
function Oz(e, t) {
  return op(e, null, t);
}
function qM(e, t) {
  return op(e, null, { flush: "post" });
}
function Pz(e, t) {
  return op(e, null, { flush: "sync" });
}
var Qb = {};
function Sz(e, t, n) {
  return op(e, t, n);
}
function op(e, t, n) {
  var s = n === void 0 ? ci : n, r = s.immediate, i = s.deep, a = s.flush, o = a === void 0 ? "pre" : a;
  s.onTrack, s.onTrigger;
  var l = Dn, f = function(y, E, C) {
    return C === void 0 && (C = null), aa(y, null, C, l, E);
  }, d, u = !1, c = !1;
  if (ei(e) ? (d = function() {
    return e.value;
  }, u = sf(e)) : Ao(e) ? (d = function() {
    return e.__ob__.dep.depend(), e;
  }, i = !0) : ce(e) ? (c = !0, u = e.some(function(y) {
    return Ao(y) || sf(y);
  }), d = function() {
    return e.map(function(y) {
      if (ei(y))
        return y.value;
      if (Ao(y))
        return ou(y);
      if (Le(y))
        return f(y, Jb);
    });
  }) : Le(e) ? t ? d = function() {
    return f(e, Jb);
  } : d = function() {
    if (!(l && l._isDestroyed))
      return p && p(), f(e, ap, [g]);
  } : d = sn, t && i) {
    var h = d;
    d = function() {
      return ou(h());
    };
  }
  var p, g = function(y) {
    p = m.onStop = function() {
      f(y, Tz);
    };
  };
  if (ao())
    return g = sn, t ? r && f(t, Zb, [
      d(),
      c ? [] : void 0,
      g
    ]) : d(), sn;
  var m = new sh(Dn, d, sn, {
    lazy: !0
  });
  m.noRecurse = !t;
  var v = c ? [] : Qb;
  return m.run = function() {
    if (m.active)
      if (t) {
        var y = m.get();
        (i || u || (c ? y.some(function(E, C) {
          return xv(E, v[C]);
        }) : xv(y, v))) && (p && p(), f(t, Zb, [
          y,
          // pass undefined as the old value when it's changed for the first time
          v === Qb ? void 0 : v,
          g
        ]), v = y);
      } else
        m.get();
  }, o === "sync" ? m.update = m.run : o === "post" ? (m.post = !0, m.update = function() {
    return Av(m);
  }) : m.update = function() {
    if (l && l === Dn && !l._isMounted) {
      var y = l._preWatchers || (l._preWatchers = []);
      y.indexOf(m) < 0 && y.push(m);
    } else
      Av(m);
  }, t ? r ? m.run() : v = m.get() : o === "post" && l ? l.$once("hook:mounted", function() {
    return m.get();
  }) : m.get(), function() {
    m.teardown();
  };
}
var li, rE = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = !1), this.detached = t, this.active = !0, this.effects = [], this.cleanups = [], this.parent = li, !t && li && (this.index = (li.scopes || (li.scopes = [])).push(this) - 1);
    }
    return e.prototype.run = function(t) {
      if (this.active) {
        var n = li;
        try {
          return li = this, t();
        } finally {
          li = n;
        }
      }
    }, e.prototype.on = function() {
      li = this;
    }, e.prototype.off = function() {
      li = this.parent;
    }, e.prototype.stop = function(t) {
      if (this.active) {
        var n = void 0, s = void 0;
        for (n = 0, s = this.effects.length; n < s; n++)
          this.effects[n].teardown();
        for (n = 0, s = this.cleanups.length; n < s; n++)
          this.cleanups[n]();
        if (this.scopes)
          for (n = 0, s = this.scopes.length; n < s; n++)
            this.scopes[n].stop(!0);
        if (!this.detached && this.parent && !t) {
          var r = this.parent.scopes.pop();
          r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
        }
        this.parent = void 0, this.active = !1;
      }
    }, e;
  }()
);
function Mz(e) {
  return new rE(e);
}
function _z(e, t) {
  t === void 0 && (t = li), t && t.active && t.effects.push(e);
}
function t_() {
  return li;
}
function Iz(e) {
  li && li.cleanups.push(e);
}
function Dz(e, t) {
  Dn && (e_(Dn)[e] = t);
}
function e_(e) {
  var t = e._provided, n = e.$parent && e.$parent._provided;
  return n === t ? e._provided = Object.create(n) : t;
}
function Az(e, t, n) {
  n === void 0 && (n = !1);
  var s = Dn;
  if (s) {
    var r = s.$parent && s.$parent._provided;
    if (r && e in r)
      return r[e];
    if (arguments.length > 1)
      return n && Le(t) ? t.call(s) : t;
  }
}
var qb = il(function(e) {
  var t = e.charAt(0) === "&";
  e = t ? e.slice(1) : e;
  var n = e.charAt(0) === "~";
  e = n ? e.slice(1) : e;
  var s = e.charAt(0) === "!";
  return e = s ? e.slice(1) : e, {
    name: e,
    once: n,
    capture: s,
    passive: t
  };
});
function Ov(e, t) {
  function n() {
    var s = n.fns;
    if (ce(s))
      for (var r = s.slice(), i = 0; i < r.length; i++)
        aa(r[i], null, arguments, t, "v-on handler");
    else
      return aa(s, null, arguments, t, "v-on handler");
  }
  return n.fns = e, n;
}
function n_(e, t, n, s, r, i) {
  var a, o, l, f;
  for (a in e)
    o = e[a], l = t[a], f = qb(a), te(o) || (te(l) ? (te(o.fns) && (o = e[a] = Ov(o, i)), un(f.once) && (o = e[a] = r(f.name, o, f.capture)), n(f.name, o, f.capture, f.passive, f.params)) : o !== l && (l.fns = o, e[a] = l));
  for (a in t)
    te(e[a]) && (f = qb(a), s(f.name, t[a], f.capture));
}
function Ra(e, t, n) {
  e instanceof ar && (e = e.data.hook || (e.data.hook = {}));
  var s, r = e[t];
  function i() {
    n.apply(this, arguments), so(s.fns, i);
  }
  te(r) ? s = Ov([i]) : ht(r.fns) && un(r.merged) ? (s = r, s.fns.push(i)) : s = Ov([r, i]), s.merged = !0, e[t] = s;
}
function Lz(e, t, n) {
  var s = t.options.props;
  if (!te(s)) {
    var r = {}, i = e.attrs, a = e.props;
    if (ht(i) || ht(a))
      for (var o in s) {
        var l = nh(o);
        tT(r, a, o, l, !0) || tT(r, i, o, l, !1);
      }
    return r;
  }
}
function tT(e, t, n, s, r) {
  if (ht(t)) {
    if (Ii(t, n))
      return e[n] = t[n], r || delete t[n], !0;
    if (Ii(t, s))
      return e[n] = t[s], r || delete t[s], !0;
  }
  return !1;
}
function Rz(e) {
  for (var t = 0; t < e.length; t++)
    if (ce(e[t]))
      return Array.prototype.concat.apply([], e);
  return e;
}
function sE(e) {
  return eh(e) ? [Ll(e)] : ce(e) ? i_(e) : void 0;
}
function Uu(e) {
  return ht(e) && ht(e.text) && W5(e.isComment);
}
function i_(e, t) {
  var n = [], s, r, i, a;
  for (s = 0; s < e.length; s++)
    r = e[s], !(te(r) || typeof r == "boolean") && (i = n.length - 1, a = n[i], ce(r) ? r.length > 0 && (r = i_(r, "".concat(t || "", "_").concat(s)), Uu(r[0]) && Uu(a) && (n[i] = Ll(a.text + r[0].text), r.shift()), n.push.apply(n, r)) : eh(r) ? Uu(a) ? n[i] = Ll(a.text + r) : r !== "" && n.push(Ll(r)) : Uu(r) && Uu(a) ? n[i] = Ll(a.text + r.text) : (un(e._isVList) && ht(r.tag) && te(r.key) && ht(t) && (r.key = "__vlist".concat(t, "_").concat(s, "__")), n.push(r)));
  return n;
}
function wz(e, t) {
  var n = null, s, r, i, a;
  if (ce(e) || typeof e == "string")
    for (n = new Array(e.length), s = 0, r = e.length; s < r; s++)
      n[s] = t(e[s], s);
  else if (typeof e == "number")
    for (n = new Array(e), s = 0; s < e; s++)
      n[s] = t(s + 1, s);
  else if (pi(e))
    if (ih && e[Symbol.iterator]) {
      n = [];
      for (var o = e[Symbol.iterator](), l = o.next(); !l.done; )
        n.push(t(l.value, n.length)), l = o.next();
    } else
      for (i = Object.keys(e), n = new Array(i.length), s = 0, r = i.length; s < r; s++)
        a = i[s], n[s] = t(e[a], a, s);
  return ht(n) || (n = []), n._isVList = !0, n;
}
function Vz(e, t, n, s) {
  var r = this.$scopedSlots[e], i;
  r ? (n = n || {}, s && (n = He(He({}, s), n)), i = r(n) || (Le(t) ? t() : t)) : i = this.$slots[e] || (Le(t) ? t() : t);
  var a = n && n.slot;
  return a ? this.$createElement("template", { slot: a }, i) : i;
}
function Bz(e) {
  return cf(this.$options, "filters", e) || NM;
}
function eT(e, t) {
  return ce(e) ? e.indexOf(t) === -1 : e !== t;
}
function Fz(e, t, n, s, r) {
  var i = Er.keyCodes[t] || n;
  return r && s && !Er.keyCodes[t] ? eT(r, s) : i ? eT(i, e) : s ? nh(s) !== t : e === void 0;
}
function Nz(e, t, n, s, r) {
  if (n && pi(n)) {
    ce(n) && (n = FM(n));
    var i = void 0, a = function(l) {
      if (l === "class" || l === "style" || G5(l))
        i = e;
      else {
        var f = e.attrs && e.attrs.type;
        i = s || Er.mustUseProp(t, f, l) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {});
      }
      var d = Ho(l), u = nh(l);
      if (!(d in i) && !(u in i) && (i[l] = n[l], r)) {
        var c = e.on || (e.on = {});
        c["update:".concat(l)] = function(h) {
          n[l] = h;
        };
      }
    };
    for (var o in n)
      a(o);
  }
  return e;
}
function jz(e, t) {
  var n = this._staticTrees || (this._staticTrees = []), s = n[e];
  return s && !t || (s = n[e] = this.$options.staticRenderFns[e].call(
    this._renderProxy,
    this._c,
    this
    // for render fns generated for functional component templates
  ), r_(s, "__static__".concat(e), !1)), s;
}
function $z(e, t, n) {
  return r_(e, "__once__".concat(t).concat(n ? "_".concat(n) : ""), !0), e;
}
function r_(e, t, n) {
  if (ce(e))
    for (var s = 0; s < e.length; s++)
      e[s] && typeof e[s] != "string" && nT(e[s], "".concat(t, "_").concat(s), n);
  else
    nT(e, t, n);
}
function nT(e, t, n) {
  e.isStatic = !0, e.key = t, e.isOnce = n;
}
function Uz(e, t) {
  if (t && Ai(t)) {
    var n = e.on = e.on ? He({}, e.on) : {};
    for (var s in t) {
      var r = n[s], i = t[s];
      n[s] = r ? [].concat(r, i) : i;
    }
  }
  return e;
}
function s_(e, t, n, s) {
  t = t || { $stable: !n };
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    ce(i) ? s_(i, t, n) : i && (i.proxy && (i.fn.proxy = !0), t[i.key] = i.fn);
  }
  return s && (t.$key = s), t;
}
function Wz(e, t) {
  for (var n = 0; n < t.length; n += 2) {
    var s = t[n];
    typeof s == "string" && s && (e[t[n]] = t[n + 1]);
  }
  return e;
}
function zz(e, t) {
  return typeof e == "string" ? t + e : e;
}
function a_(e) {
  e._o = $z, e._n = Ic, e._s = K5, e._l = wz, e._t = Vz, e._q = Yo, e._i = jM, e._m = jz, e._f = Bz, e._k = Fz, e._b = Nz, e._v = Ll, e._e = Do, e._u = s_, e._g = Uz, e._d = Wz, e._p = zz;
}
function aE(e, t) {
  if (!e || !e.length)
    return {};
  for (var n = {}, s = 0, r = e.length; s < r; s++) {
    var i = e[s], a = i.data;
    if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, (i.context === t || i.fnContext === t) && a && a.slot != null) {
      var o = a.slot, l = n[o] || (n[o] = []);
      i.tag === "template" ? l.push.apply(l, i.children || []) : l.push(i);
    } else
      (n.default || (n.default = [])).push(i);
  }
  for (var f in n)
    n[f].every(Kz) && delete n[f];
  return n;
}
function Kz(e) {
  return e.isComment && !e.asyncFactory || e.text === " ";
}
function Ac(e) {
  return e.isComment && e.asyncFactory;
}
function lc(e, t, n, s) {
  var r, i = Object.keys(n).length > 0, a = t ? !!t.$stable : !i, o = t && t.$key;
  if (!t)
    r = {};
  else {
    if (t._normalized)
      return t._normalized;
    if (a && s && s !== ci && o === s.$key && !i && !s.$hasNormal)
      return s;
    r = {};
    for (var l in t)
      t[l] && l[0] !== "$" && (r[l] = Gz(e, n, l, t[l]));
  }
  for (var f in n)
    f in r || (r[f] = kz(n, f));
  return t && Object.isExtensible(t) && (t._normalized = r), _n(r, "$stable", a), _n(r, "$key", o), _n(r, "$hasNormal", i), r;
}
function Gz(e, t, n, s) {
  var r = function() {
    var i = Dn;
    eo(e);
    var a = arguments.length ? s.apply(null, arguments) : s({});
    a = a && typeof a == "object" && !ce(a) ? [a] : sE(a);
    var o = a && a[0];
    return eo(i), a && (!o || a.length === 1 && o.isComment && !Ac(o)) ? void 0 : a;
  };
  return s.proxy && Object.defineProperty(t, n, {
    get: r,
    enumerable: !0,
    configurable: !0
  }), r;
}
function kz(e, t) {
  return function() {
    return e[t];
  };
}
function Hz(e) {
  var t = e.$options, n = t.setup;
  if (n) {
    var s = e._setupContext = o_(e);
    eo(e), Mu();
    var r = aa(n, null, [e._props || iE({}), s], e, "setup");
    if (_u(), eo(), Le(r))
      t.render = r;
    else if (pi(r))
      if (e._setupState = r, r.__sfc) {
        var a = e._setupProxy = {};
        for (var i in r)
          i !== "__sfc" && af(a, r, i);
      } else
        for (var i in r)
          UM(i) || af(e, r, i);
  }
}
function o_(e) {
  return {
    get attrs() {
      if (!e._attrsProxy) {
        var t = e._attrsProxy = {};
        _n(t, "_v_attr_proxy", !0), of(t, e.$attrs, ci, e, "$attrs");
      }
      return e._attrsProxy;
    },
    get listeners() {
      if (!e._listenersProxy) {
        var t = e._listenersProxy = {};
        of(t, e.$listeners, ci, e, "$listeners");
      }
      return e._listenersProxy;
    },
    get slots() {
      return Xz(e);
    },
    emit: BM(e.$emit, e),
    expose: function(t) {
      t && Object.keys(t).forEach(function(n) {
        return af(e, t, n);
      });
    }
  };
}
function of(e, t, n, s, r) {
  var i = !1;
  for (var a in t)
    a in e ? t[a] !== n[a] && (i = !0) : (i = !0, Yz(e, a, s, r));
  for (var a in e)
    a in t || (i = !0, delete e[a]);
  return i;
}
function Yz(e, t, n, s) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    configurable: !0,
    get: function() {
      return n[s][t];
    }
  });
}
function Xz(e) {
  return e._slotsProxy || l_(e._slotsProxy = {}, e.$scopedSlots), e._slotsProxy;
}
function l_(e, t) {
  for (var n in t)
    e[n] = t[n];
  for (var n in e)
    n in t || delete e[n];
}
function Zz() {
  return oE().slots;
}
function Jz() {
  return oE().attrs;
}
function Qz() {
  return oE().listeners;
}
function oE() {
  var e = Dn;
  return e._setupContext || (e._setupContext = o_(e));
}
function qz(e, t) {
  var n = ce(e) ? e.reduce(function(i, a) {
    return i[a] = {}, i;
  }, {}) : e;
  for (var s in t) {
    var r = n[s];
    r ? ce(r) || Le(r) ? n[s] = { type: r, default: t[s] } : r.default = t[s] : r === null && (n[s] = { default: t[s] });
  }
  return n;
}
function tK(e) {
  e._vnode = null, e._staticTrees = null;
  var t = e.$options, n = e.$vnode = t._parentVnode, s = n && n.context;
  e.$slots = aE(t._renderChildren, s), e.$scopedSlots = n ? lc(e.$parent, n.data.scopedSlots, e.$slots) : ci, e._c = function(i, a, o, l) {
    return Lc(e, i, a, o, l, !1);
  }, e.$createElement = function(i, a, o, l) {
    return Lc(e, i, a, o, l, !0);
  };
  var r = n && n.data;
  io(e, "$attrs", r && r.attrs || ci, null, !0), io(e, "$listeners", t._parentListeners || ci, null, !0);
}
var Pv = null;
function eK(e) {
  a_(e.prototype), e.prototype.$nextTick = function(t) {
    return lp(t, this);
  }, e.prototype._render = function() {
    var t = this, n = t.$options, s = n.render, r = n._parentVnode;
    r && t._isMounted && (t.$scopedSlots = lc(t.$parent, r.data.scopedSlots, t.$slots, t.$scopedSlots), t._slotsProxy && l_(t._slotsProxy, t.$scopedSlots)), t.$vnode = r;
    var i;
    try {
      eo(t), Pv = t, i = s.call(t._renderProxy, t.$createElement);
    } catch (a) {
      Xo(a, t, "render"), i = t._vnode;
    } finally {
      Pv = null, eo();
    }
    return ce(i) && i.length === 1 && (i = i[0]), i instanceof ar || (i = Do()), i.parent = r, i;
  };
}
function Zm(e, t) {
  return (e.__esModule || ih && e[Symbol.toStringTag] === "Module") && (e = e.default), pi(e) ? t.extend(e) : e;
}
function nK(e, t, n, s, r) {
  var i = Do();
  return i.asyncFactory = e, i.asyncMeta = { data: t, context: n, children: s, tag: r }, i;
}
function iK(e, t) {
  if (un(e.error) && ht(e.errorComp))
    return e.errorComp;
  if (ht(e.resolved))
    return e.resolved;
  var n = Pv;
  if (n && ht(e.owners) && e.owners.indexOf(n) === -1 && e.owners.push(n), un(e.loading) && ht(e.loadingComp))
    return e.loadingComp;
  if (n && !ht(e.owners)) {
    var s = e.owners = [n], r = !0, i = null, a = null;
    n.$on("hook:destroyed", function() {
      return so(s, n);
    });
    var o = function(u) {
      for (var c = 0, h = s.length; c < h; c++)
        s[c].$forceUpdate();
      u && (s.length = 0, i !== null && (clearTimeout(i), i = null), a !== null && (clearTimeout(a), a = null));
    }, l = ef(function(u) {
      e.resolved = Zm(u, t), r ? s.length = 0 : o(!0);
    }), f = ef(function(u) {
      ht(e.errorComp) && (e.error = !0, o(!0));
    }), d = e(l, f);
    return pi(d) && (Ev(d) ? te(e.resolved) && d.then(l, f) : Ev(d.component) && (d.component.then(l, f), ht(d.error) && (e.errorComp = Zm(d.error, t)), ht(d.loading) && (e.loadingComp = Zm(d.loading, t), d.delay === 0 ? e.loading = !0 : i = setTimeout(function() {
      i = null, te(e.resolved) && te(e.error) && (e.loading = !0, o(!1));
    }, d.delay || 200)), ht(d.timeout) && (a = setTimeout(function() {
      a = null, te(e.resolved) && f(null);
    }, d.timeout)))), r = !1, e.loading ? e.loadingComp : e.resolved;
  }
}
function u_(e) {
  if (ce(e))
    for (var t = 0; t < e.length; t++) {
      var n = e[t];
      if (ht(n) && (ht(n.componentOptions) || Ac(n)))
        return n;
    }
}
var rK = 1, c_ = 2;
function Lc(e, t, n, s, r, i) {
  return (ce(n) || eh(n)) && (r = s, s = n, n = void 0), un(i) && (r = c_), sK(e, t, n, s, r);
}
function sK(e, t, n, s, r) {
  if (ht(n) && ht(n.__ob__) || (ht(n) && ht(n.is) && (t = n.is), !t))
    return Do();
  ce(s) && Le(s[0]) && (n = n || {}, n.scopedSlots = { default: s[0] }, s.length = 0), r === c_ ? s = sE(s) : r === rK && (s = Rz(s));
  var i, a;
  if (typeof t == "string") {
    var o = void 0;
    a = e.$vnode && e.$vnode.ns || Er.getTagNamespace(t), Er.isReservedTag(t) ? i = new ar(Er.parsePlatformTagName(t), n, s, void 0, void 0, e) : (!n || !n.pre) && ht(o = cf(e.$options, "components", t)) ? i = cT(o, n, e, s, t) : i = new ar(t, n, s, void 0, void 0, e);
  } else
    i = cT(t, n, e, s);
  return ce(i) ? i : ht(i) ? (ht(a) && h_(i, a), ht(n) && aK(n), i) : Do();
}
function h_(e, t, n) {
  if (e.ns = t, e.tag === "foreignObject" && (t = void 0, n = !0), ht(e.children))
    for (var s = 0, r = e.children.length; s < r; s++) {
      var i = e.children[s];
      ht(i.tag) && (te(i.ns) || un(n) && i.tag !== "svg") && h_(i, t, n);
    }
}
function aK(e) {
  pi(e.style) && ou(e.style), pi(e.class) && ou(e.class);
}
function oK(e, t, n) {
  return Lc(Dn, e, t, n, 2, !0);
}
function Xo(e, t, n) {
  Mu();
  try {
    if (t)
      for (var s = t; s = s.$parent; ) {
        var r = s.$options.errorCaptured;
        if (r)
          for (var i = 0; i < r.length; i++)
            try {
              var a = r[i].call(s, e, t, n) === !1;
              if (a)
                return;
            } catch (o) {
              iT(o, s, "errorCaptured hook");
            }
      }
    iT(e, t, n);
  } finally {
    _u();
  }
}
function aa(e, t, n, s, r) {
  var i;
  try {
    i = n ? e.apply(t, n) : e.call(t), i && !i._isVue && Ev(i) && !i._handled && (i.catch(function(a) {
      return Xo(a, s, r + " (Promise/async)");
    }), i._handled = !0);
  } catch (a) {
    Xo(a, s, r);
  }
  return i;
}
function iT(e, t, n) {
  if (Er.errorHandler)
    try {
      return Er.errorHandler.call(null, e, t, n);
    } catch (s) {
      s !== e && rT(s);
    }
  rT(e);
}
function rT(e, t, n) {
  if (Gi && typeof console < "u")
    console.error(e);
  else
    throw e;
}
var Sv = !1, Mv = [], _v = !1;
function Uh() {
  _v = !1;
  var e = Mv.slice(0);
  Mv.length = 0;
  for (var t = 0; t < e.length; t++)
    e[t]();
}
var tc;
if (typeof Promise < "u" && Xl(Promise)) {
  var lK = Promise.resolve();
  tc = function() {
    lK.then(Uh), nz && setTimeout(sn);
  }, Sv = !0;
} else if (!Pu && typeof MutationObserver < "u" && (Xl(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  var Wh = 1, uK = new MutationObserver(Uh), sT = document.createTextNode(String(Wh));
  uK.observe(sT, {
    characterData: !0
  }), tc = function() {
    Wh = (Wh + 1) % 2, sT.data = String(Wh);
  }, Sv = !0;
} else
  typeof setImmediate < "u" && Xl(setImmediate) ? tc = function() {
    setImmediate(Uh);
  } : tc = function() {
    setTimeout(Uh, 0);
  };
function lp(e, t) {
  var n;
  if (Mv.push(function() {
    if (e)
      try {
        e.call(t);
      } catch (s) {
        Xo(s, t, "nextTick");
      }
    else
      n && n(t);
  }), _v || (_v = !0, tc()), !e && typeof Promise < "u")
    return new Promise(function(s) {
      n = s;
    });
}
function cK(e) {
  e === void 0 && (e = "$style");
  {
    if (!Dn)
      return ci;
    var t = Dn[e];
    return t || ci;
  }
}
function hK(e) {
  if (Gi) {
    var t = Dn;
    t && qM(function() {
      var n = t.$el, s = e(t, t._setupProxy);
      if (n && n.nodeType === 1) {
        var r = n.style;
        for (var i in s)
          r.setProperty("--".concat(i), s[i]);
      }
    });
  }
}
function dK(e) {
  Le(e) && (e = { loader: e });
  var t = e.loader, n = e.loadingComponent, s = e.errorComponent, r = e.delay, i = r === void 0 ? 200 : r, a = e.timeout;
  e.suspensible;
  var o = e.onError, l = null, f = 0, d = function() {
    return f++, l = null, u();
  }, u = function() {
    var c;
    return l || (c = l = t().catch(function(h) {
      if (h = h instanceof Error ? h : new Error(String(h)), o)
        return new Promise(function(p, g) {
          var m = function() {
            return p(d());
          }, v = function() {
            return g(h);
          };
          o(h, m, v, f + 1);
        });
      throw h;
    }).then(function(h) {
      return c !== l && l ? l : (h && (h.__esModule || h[Symbol.toStringTag] === "Module") && (h = h.default), h);
    }));
  };
  return function() {
    var c = u();
    return {
      component: c,
      delay: i,
      timeout: a,
      error: s,
      loading: n
    };
  };
}
function Tr(e) {
  return function(t, n) {
    if (n === void 0 && (n = Dn), !!n)
      return fK(n, e, t);
  };
}
function fK(e, t, n) {
  var s = e.$options;
  s[t] = E_(s[t], n);
}
var pK = Tr("beforeMount"), mK = Tr("mounted"), gK = Tr("beforeUpdate"), vK = Tr("updated"), yK = Tr("beforeDestroy"), EK = Tr("destroyed"), CK = Tr("activated"), xK = Tr("deactivated"), bK = Tr("serverPrefetch"), TK = Tr("renderTracked"), OK = Tr("renderTriggered"), PK = Tr("errorCaptured");
function SK(e, t) {
  t === void 0 && (t = Dn), PK(e, t);
}
var d_ = "2.7.15";
function MK(e) {
  return e;
}
var aT = new Dc();
function ou(e) {
  return gd(e, aT), aT.clear(), e;
}
function gd(e, t) {
  var n, s, r = ce(e);
  if (!(!r && !pi(e) || e.__v_skip || Object.isFrozen(e) || e instanceof ar)) {
    if (e.__ob__) {
      var i = e.__ob__.dep.id;
      if (t.has(i))
        return;
      t.add(i);
    }
    if (r)
      for (n = e.length; n--; )
        gd(e[n], t);
    else if (ei(e))
      gd(e.value, t);
    else
      for (s = Object.keys(e), n = s.length; n--; )
        gd(e[s[n]], t);
  }
}
var _K = 0, sh = (
  /** @class */
  function() {
    function e(t, n, s, r, i) {
      _z(
        this,
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        li && !li._vm ? li : t ? t._scope : void 0
      ), (this.vm = t) && i && (t._watcher = this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = s, this.id = ++_K, this.active = !0, this.post = !1, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new Dc(), this.newDepIds = new Dc(), this.expression = "", Le(n) ? this.getter = n : (this.getter = tz(n), this.getter || (this.getter = sn)), this.value = this.lazy ? void 0 : this.get();
    }
    return e.prototype.get = function() {
      Mu(this);
      var t, n = this.vm;
      try {
        t = this.getter.call(n, n);
      } catch (s) {
        if (this.user)
          Xo(s, n, 'getter for watcher "'.concat(this.expression, '"'));
        else
          throw s;
      } finally {
        this.deep && ou(t), _u(), this.cleanupDeps();
      }
      return t;
    }, e.prototype.addDep = function(t) {
      var n = t.id;
      this.newDepIds.has(n) || (this.newDepIds.add(n), this.newDeps.push(t), this.depIds.has(n) || t.addSub(this));
    }, e.prototype.cleanupDeps = function() {
      for (var t = this.deps.length; t--; ) {
        var n = this.deps[t];
        this.newDepIds.has(n.id) || n.removeSub(this);
      }
      var s = this.depIds;
      this.depIds = this.newDepIds, this.newDepIds = s, this.newDepIds.clear(), s = this.deps, this.deps = this.newDeps, this.newDeps = s, this.newDeps.length = 0;
    }, e.prototype.update = function() {
      this.lazy ? this.dirty = !0 : this.sync ? this.run() : Av(this);
    }, e.prototype.run = function() {
      if (this.active) {
        var t = this.get();
        if (t !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        pi(t) || this.deep) {
          var n = this.value;
          if (this.value = t, this.user) {
            var s = 'callback for watcher "'.concat(this.expression, '"');
            aa(this.cb, this.vm, [t, n], this.vm, s);
          } else
            this.cb.call(this.vm, t, n);
        }
      }
    }, e.prototype.evaluate = function() {
      this.value = this.get(), this.dirty = !1;
    }, e.prototype.depend = function() {
      for (var t = this.deps.length; t--; )
        this.deps[t].depend();
    }, e.prototype.teardown = function() {
      if (this.vm && !this.vm._isBeingDestroyed && so(this.vm._scope.effects, this), this.active) {
        for (var t = this.deps.length; t--; )
          this.deps[t].removeSub(this);
        this.active = !1, this.onStop && this.onStop();
      }
    }, e;
  }()
);
function IK(e) {
  e._events = /* @__PURE__ */ Object.create(null), e._hasHookEvent = !1;
  var t = e.$options._parentListeners;
  t && f_(e, t);
}
var Rc;
function DK(e, t) {
  Rc.$on(e, t);
}
function AK(e, t) {
  Rc.$off(e, t);
}
function LK(e, t) {
  var n = Rc;
  return function s() {
    var r = t.apply(null, arguments);
    r !== null && n.$off(e, s);
  };
}
function f_(e, t, n) {
  Rc = e, n_(t, n || {}, DK, AK, LK, e), Rc = void 0;
}
function RK(e) {
  var t = /^hook:/;
  e.prototype.$on = function(n, s) {
    var r = this;
    if (ce(n))
      for (var i = 0, a = n.length; i < a; i++)
        r.$on(n[i], s);
    else
      (r._events[n] || (r._events[n] = [])).push(s), t.test(n) && (r._hasHookEvent = !0);
    return r;
  }, e.prototype.$once = function(n, s) {
    var r = this;
    function i() {
      r.$off(n, i), s.apply(r, arguments);
    }
    return i.fn = s, r.$on(n, i), r;
  }, e.prototype.$off = function(n, s) {
    var r = this;
    if (!arguments.length)
      return r._events = /* @__PURE__ */ Object.create(null), r;
    if (ce(n)) {
      for (var i = 0, a = n.length; i < a; i++)
        r.$off(n[i], s);
      return r;
    }
    var o = r._events[n];
    if (!o)
      return r;
    if (!s)
      return r._events[n] = null, r;
    for (var l, f = o.length; f--; )
      if (l = o[f], l === s || l.fn === s) {
        o.splice(f, 1);
        break;
      }
    return r;
  }, e.prototype.$emit = function(n) {
    var s = this, r = s._events[n];
    if (r) {
      r = r.length > 1 ? Cv(r) : r;
      for (var i = Cv(arguments, 1), a = 'event handler for "'.concat(n, '"'), o = 0, l = r.length; o < l; o++)
        aa(r[o], s, i, s, a);
    }
    return s;
  };
}
var Lo = null;
function p_(e) {
  var t = Lo;
  return Lo = e, function() {
    Lo = t;
  };
}
function wK(e) {
  var t = e.$options, n = t.parent;
  if (n && !t.abstract) {
    for (; n.$options.abstract && n.$parent; )
      n = n.$parent;
    n.$children.push(e);
  }
  e.$parent = n, e.$root = n ? n.$root : e, e.$children = [], e.$refs = {}, e._provided = n ? n._provided : /* @__PURE__ */ Object.create(null), e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1;
}
function VK(e) {
  e.prototype._update = function(t, n) {
    var s = this, r = s.$el, i = s._vnode, a = p_(s);
    s._vnode = t, i ? s.$el = s.__patch__(i, t) : s.$el = s.__patch__(
      s.$el,
      t,
      n,
      !1
      /* removeOnly */
    ), a(), r && (r.__vue__ = null), s.$el && (s.$el.__vue__ = s);
    for (var o = s; o && o.$vnode && o.$parent && o.$vnode === o.$parent._vnode; )
      o.$parent.$el = o.$el, o = o.$parent;
  }, e.prototype.$forceUpdate = function() {
    var t = this;
    t._watcher && t._watcher.update();
  }, e.prototype.$destroy = function() {
    var t = this;
    if (!t._isBeingDestroyed) {
      Nr(t, "beforeDestroy"), t._isBeingDestroyed = !0;
      var n = t.$parent;
      n && !n._isBeingDestroyed && !t.$options.abstract && so(n.$children, t), t._scope.stop(), t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), Nr(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null);
    }
  };
}
function BK(e, t, n) {
  e.$el = t, e.$options.render || (e.$options.render = Do), Nr(e, "beforeMount");
  var s;
  s = function() {
    e._update(e._render(), n);
  };
  var r = {
    before: function() {
      e._isMounted && !e._isDestroyed && Nr(e, "beforeUpdate");
    }
  };
  new sh(
    e,
    s,
    sn,
    r,
    !0
    /* isRenderWatcher */
  ), n = !1;
  var i = e._preWatchers;
  if (i)
    for (var a = 0; a < i.length; a++)
      i[a].run();
  return e.$vnode == null && (e._isMounted = !0, Nr(e, "mounted")), e;
}
function FK(e, t, n, s, r) {
  var i = s.data.scopedSlots, a = e.$scopedSlots, o = !!(i && !i.$stable || a !== ci && !a.$stable || i && e.$scopedSlots.$key !== i.$key || !i && e.$scopedSlots.$key), l = !!(r || // has new static slots
  e.$options._renderChildren || // has old static slots
  o), f = e.$vnode;
  e.$options._parentVnode = s, e.$vnode = s, e._vnode && (e._vnode.parent = s), e.$options._renderChildren = r;
  var d = s.data.attrs || ci;
  e._attrsProxy && of(e._attrsProxy, d, f.data && f.data.attrs || ci, e, "$attrs") && (l = !0), e.$attrs = d, n = n || ci;
  var u = e.$options._parentListeners;
  if (e._listenersProxy && of(e._listenersProxy, n, u || ci, e, "$listeners"), e.$listeners = e.$options._parentListeners = n, f_(e, n, u), t && e.$options.props) {
    no(!1);
    for (var c = e._props, h = e.$options._propKeys || [], p = 0; p < h.length; p++) {
      var g = h[p], m = e.$options.props;
      c[g] = fE(g, m, t, e);
    }
    no(!0), e.$options.propsData = t;
  }
  l && (e.$slots = aE(r, s.context), e.$forceUpdate());
}
function m_(e) {
  for (; e && (e = e.$parent); )
    if (e._inactive)
      return !0;
  return !1;
}
function lE(e, t) {
  if (t) {
    if (e._directInactive = !1, m_(e))
      return;
  } else if (e._directInactive)
    return;
  if (e._inactive || e._inactive === null) {
    e._inactive = !1;
    for (var n = 0; n < e.$children.length; n++)
      lE(e.$children[n]);
    Nr(e, "activated");
  }
}
function g_(e, t) {
  if (!(t && (e._directInactive = !0, m_(e))) && !e._inactive) {
    e._inactive = !0;
    for (var n = 0; n < e.$children.length; n++)
      g_(e.$children[n]);
    Nr(e, "deactivated");
  }
}
function Nr(e, t, n, s) {
  s === void 0 && (s = !0), Mu();
  var r = Dn, i = t_();
  s && eo(e);
  var a = e.$options[t], o = "".concat(t, " hook");
  if (a)
    for (var l = 0, f = a.length; l < f; l++)
      aa(a[l], e, n || null, e, o);
  e._hasHookEvent && e.$emit("hook:" + t), s && (eo(r), i && i.on()), _u();
}
var ks = [], uE = [], lf = {}, Iv = !1, cE = !1, Rl = 0;
function NK() {
  Rl = ks.length = uE.length = 0, lf = {}, Iv = cE = !1;
}
var v_ = 0, Dv = Date.now;
if (Gi && !Pu) {
  var Jm = window.performance;
  Jm && typeof Jm.now == "function" && Dv() > document.createEvent("Event").timeStamp && (Dv = function() {
    return Jm.now();
  });
}
var jK = function(e, t) {
  if (e.post) {
    if (!t.post)
      return 1;
  } else if (t.post)
    return -1;
  return e.id - t.id;
};
function $K() {
  v_ = Dv(), cE = !0;
  var e, t;
  for (ks.sort(jK), Rl = 0; Rl < ks.length; Rl++)
    e = ks[Rl], e.before && e.before(), t = e.id, lf[t] = null, e.run();
  var n = uE.slice(), s = ks.slice();
  NK(), zK(n), UK(s), sz(), nf && Er.devtools && nf.emit("flush");
}
function UK(e) {
  for (var t = e.length; t--; ) {
    var n = e[t], s = n.vm;
    s && s._watcher === n && s._isMounted && !s._isDestroyed && Nr(s, "updated");
  }
}
function WK(e) {
  e._inactive = !1, uE.push(e);
}
function zK(e) {
  for (var t = 0; t < e.length; t++)
    e[t]._inactive = !0, lE(
      e[t],
      !0
      /* true */
    );
}
function Av(e) {
  var t = e.id;
  if (lf[t] == null && !(e === xs.target && e.noRecurse)) {
    if (lf[t] = !0, !cE)
      ks.push(e);
    else {
      for (var n = ks.length - 1; n > Rl && ks[n].id > e.id; )
        n--;
      ks.splice(n + 1, 0, e);
    }
    Iv || (Iv = !0, lp($K));
  }
}
function KK(e) {
  var t = e.$options.provide;
  if (t) {
    var n = Le(t) ? t.call(e) : t;
    if (!pi(n))
      return;
    for (var s = e_(e), r = ih ? Reflect.ownKeys(n) : Object.keys(n), i = 0; i < r.length; i++) {
      var a = r[i];
      Object.defineProperty(s, a, Object.getOwnPropertyDescriptor(n, a));
    }
  }
}
function GK(e) {
  var t = y_(e.$options.inject, e);
  t && (no(!1), Object.keys(t).forEach(function(n) {
    io(e, n, t[n]);
  }), no(!0));
}
function y_(e, t) {
  if (e) {
    for (var n = /* @__PURE__ */ Object.create(null), s = ih ? Reflect.ownKeys(e) : Object.keys(e), r = 0; r < s.length; r++) {
      var i = s[r];
      if (i !== "__ob__") {
        var a = e[i].from;
        if (a in t._provided)
          n[i] = t._provided[a];
        else if ("default" in e[i]) {
          var o = e[i].default;
          n[i] = Le(o) ? o.call(t) : o;
        }
      }
    }
    return n;
  }
}
function hE(e, t, n, s, r) {
  var i = this, a = r.options, o;
  Ii(s, "_uid") ? (o = Object.create(s), o._original = s) : (o = s, s = s._original);
  var l = un(a._compiled), f = !l;
  this.data = e, this.props = t, this.children = n, this.parent = s, this.listeners = e.on || ci, this.injections = y_(a.inject, s), this.slots = function() {
    return i.$slots || lc(s, e.scopedSlots, i.$slots = aE(n, s)), i.$slots;
  }, Object.defineProperty(this, "scopedSlots", {
    enumerable: !0,
    get: function() {
      return lc(s, e.scopedSlots, this.slots());
    }
  }), l && (this.$options = a, this.$slots = this.slots(), this.$scopedSlots = lc(s, e.scopedSlots, this.$slots)), a._scopeId ? this._c = function(d, u, c, h) {
    var p = Lc(o, d, u, c, h, f);
    return p && !ce(p) && (p.fnScopeId = a._scopeId, p.fnContext = s), p;
  } : this._c = function(d, u, c, h) {
    return Lc(o, d, u, c, h, f);
  };
}
a_(hE.prototype);
function kK(e, t, n, s, r) {
  var i = e.options, a = {}, o = i.props;
  if (ht(o))
    for (var l in o)
      a[l] = fE(l, o, t || ci);
  else
    ht(n.attrs) && lT(a, n.attrs), ht(n.props) && lT(a, n.props);
  var f = new hE(n, a, r, s, e), d = i.render.call(null, f._c, f);
  if (d instanceof ar)
    return oT(d, n, f.parent, i);
  if (ce(d)) {
    for (var u = sE(d) || [], c = new Array(u.length), h = 0; h < u.length; h++)
      c[h] = oT(u[h], n, f.parent, i);
    return c;
  }
}
function oT(e, t, n, s, r) {
  var i = Tv(e);
  return i.fnContext = n, i.fnOptions = s, t.slot && ((i.data || (i.data = {})).slot = t.slot), i;
}
function lT(e, t) {
  for (var n in t)
    e[Ho(n)] = t[n];
}
function uf(e) {
  return e.name || e.__name || e._componentTag;
}
var dE = {
  init: function(e, t) {
    if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) {
      var n = e;
      dE.prepatch(n, n);
    } else {
      var s = e.componentInstance = HK(e, Lo);
      s.$mount(t ? e.elm : void 0, t);
    }
  },
  prepatch: function(e, t) {
    var n = t.componentOptions, s = t.componentInstance = e.componentInstance;
    FK(
      s,
      n.propsData,
      // updated props
      n.listeners,
      // updated listeners
      t,
      // new parent vnode
      n.children
      // new children
    );
  },
  insert: function(e) {
    var t = e.context, n = e.componentInstance;
    n._isMounted || (n._isMounted = !0, Nr(n, "mounted")), e.data.keepAlive && (t._isMounted ? WK(n) : lE(
      n,
      !0
      /* direct */
    ));
  },
  destroy: function(e) {
    var t = e.componentInstance;
    t._isDestroyed || (e.data.keepAlive ? g_(
      t,
      !0
      /* direct */
    ) : t.$destroy());
  }
}, uT = Object.keys(dE);
function cT(e, t, n, s, r) {
  if (!te(e)) {
    var i = n.$options._base;
    if (pi(e) && (e = i.extend(e)), typeof e == "function") {
      var a;
      if (te(e.cid) && (a = e, e = iK(a, i), e === void 0))
        return nK(a, t, n, s, r);
      t = t || {}, mE(e), ht(t.model) && ZK(e.options, t);
      var o = Lz(t, e);
      if (un(e.options.functional))
        return kK(e, o, t, n, s);
      var l = t.on;
      if (t.on = t.nativeOn, un(e.options.abstract)) {
        var f = t.slot;
        t = {}, f && (t.slot = f);
      }
      YK(t);
      var d = uf(e.options) || r, u = new ar(
        // @ts-expect-error
        "vue-component-".concat(e.cid).concat(d ? "-".concat(d) : ""),
        t,
        void 0,
        void 0,
        void 0,
        n,
        // @ts-expect-error
        { Ctor: e, propsData: o, listeners: l, tag: r, children: s },
        a
      );
      return u;
    }
  }
}
function HK(e, t) {
  var n = {
    _isComponent: !0,
    _parentVnode: e,
    parent: t
  }, s = e.data.inlineTemplate;
  return ht(s) && (n.render = s.render, n.staticRenderFns = s.staticRenderFns), new e.componentOptions.Ctor(n);
}
function YK(e) {
  for (var t = e.hook || (e.hook = {}), n = 0; n < uT.length; n++) {
    var s = uT[n], r = t[s], i = dE[s];
    r !== i && !(r && r._merged) && (t[s] = r ? XK(i, r) : i);
  }
}
function XK(e, t) {
  var n = function(s, r) {
    e(s, r), t(s, r);
  };
  return n._merged = !0, n;
}
function ZK(e, t) {
  var n = e.model && e.model.prop || "value", s = e.model && e.model.event || "input";
  (t.attrs || (t.attrs = {}))[n] = t.model.value;
  var r = t.on || (t.on = {}), i = r[s], a = t.model.callback;
  ht(i) ? (ce(i) ? i.indexOf(a) === -1 : i !== a) && (r[s] = [a].concat(i)) : r[s] = a;
}
var JK = sn, hs = Er.optionMergeStrategies;
function wc(e, t, n) {
  if (n === void 0 && (n = !0), !t)
    return e;
  for (var s, r, i, a = ih ? Reflect.ownKeys(t) : Object.keys(t), o = 0; o < a.length; o++)
    s = a[o], s !== "__ob__" && (r = e[s], i = t[s], !n || !Ii(e, s) ? sp(e, s, i) : r !== i && Ai(r) && Ai(i) && wc(r, i));
  return e;
}
function hT(e, t, n) {
  return n ? function() {
    var r = Le(t) ? t.call(n, n) : t, i = Le(e) ? e.call(n, n) : e;
    return r ? wc(r, i) : i;
  } : t ? e ? function() {
    return wc(Le(t) ? t.call(this, this) : t, Le(e) ? e.call(this, this) : e);
  } : t : e;
}
hs.data = function(e, t, n) {
  return n ? hT(e, t, n) : t && typeof t != "function" ? e : hT(e, t);
};
function E_(e, t) {
  var n = t ? e ? e.concat(t) : ce(t) ? t : [t] : e;
  return n && QK(n);
}
function QK(e) {
  for (var t = [], n = 0; n < e.length; n++)
    t.indexOf(e[n]) === -1 && t.push(e[n]);
  return t;
}
$M.forEach(function(e) {
  hs[e] = E_;
});
function qK(e, t, n, s) {
  var r = Object.create(e || null);
  return t ? He(r, t) : r;
}
rp.forEach(function(e) {
  hs[e + "s"] = qK;
});
hs.watch = function(e, t, n, s) {
  if (e === bv && (e = void 0), t === bv && (t = void 0), !t)
    return Object.create(e || null);
  if (!e)
    return t;
  var r = {};
  He(r, e);
  for (var i in t) {
    var a = r[i], o = t[i];
    a && !ce(a) && (a = [a]), r[i] = a ? a.concat(o) : ce(o) ? o : [o];
  }
  return r;
};
hs.props = hs.methods = hs.inject = hs.computed = function(e, t, n, s) {
  if (!e)
    return t;
  var r = /* @__PURE__ */ Object.create(null);
  return He(r, e), t && He(r, t), r;
};
hs.provide = function(e, t) {
  return e ? function() {
    var n = /* @__PURE__ */ Object.create(null);
    return wc(n, Le(e) ? e.call(this) : e), t && wc(
      n,
      Le(t) ? t.call(this) : t,
      !1
      // non-recursive
    ), n;
  } : t;
};
var t4 = function(e, t) {
  return t === void 0 ? e : t;
};
function e4(e, t) {
  var n = e.props;
  if (n) {
    var s = {}, r, i, a;
    if (ce(n))
      for (r = n.length; r--; )
        i = n[r], typeof i == "string" && (a = Ho(i), s[a] = { type: null });
    else if (Ai(n))
      for (var o in n)
        i = n[o], a = Ho(o), s[a] = Ai(i) ? i : { type: i };
    e.props = s;
  }
}
function n4(e, t) {
  var n = e.inject;
  if (n) {
    var s = e.inject = {};
    if (ce(n))
      for (var r = 0; r < n.length; r++)
        s[n[r]] = { from: n[r] };
    else if (Ai(n))
      for (var i in n) {
        var a = n[i];
        s[i] = Ai(a) ? He({ from: i }, a) : { from: a };
      }
  }
}
function i4(e) {
  var t = e.directives;
  if (t)
    for (var n in t) {
      var s = t[n];
      Le(s) && (t[n] = { bind: s, update: s });
    }
}
function Zo(e, t, n) {
  if (Le(t) && (t = t.options), e4(t), n4(t), i4(t), !t._base && (t.extends && (e = Zo(e, t.extends, n)), t.mixins))
    for (var s = 0, r = t.mixins.length; s < r; s++)
      e = Zo(e, t.mixins[s], n);
  var i = {}, a;
  for (a in e)
    o(a);
  for (a in t)
    Ii(e, a) || o(a);
  function o(l) {
    var f = hs[l] || t4;
    i[l] = f(e[l], t[l], n, l);
  }
  return i;
}
function cf(e, t, n, s) {
  if (typeof n == "string") {
    var r = e[t];
    if (Ii(r, n))
      return r[n];
    var i = Ho(n);
    if (Ii(r, i))
      return r[i];
    var a = Y5(i);
    if (Ii(r, a))
      return r[a];
    var o = r[n] || r[i] || r[a];
    return o;
  }
}
function fE(e, t, n, s) {
  var r = t[e], i = !Ii(n, e), a = n[e], o = fT(Boolean, r.type);
  if (o > -1) {
    if (i && !Ii(r, "default"))
      a = !1;
    else if (a === "" || a === nh(e)) {
      var l = fT(String, r.type);
      (l < 0 || o < l) && (a = !0);
    }
  }
  if (a === void 0) {
    a = r4(s, r, e);
    var f = eE;
    no(!0), sa(a), no(f);
  }
  return a;
}
function r4(e, t, n) {
  if (Ii(t, "default")) {
    var s = t.default;
    return e && e.$options.propsData && e.$options.propsData[n] === void 0 && e._props[n] !== void 0 ? e._props[n] : Le(s) && Lv(t.type) !== "Function" ? s.call(e) : s;
  }
}
var s4 = /^\s*function (\w+)/;
function Lv(e) {
  var t = e && e.toString().match(s4);
  return t ? t[1] : "";
}
function dT(e, t) {
  return Lv(e) === Lv(t);
}
function fT(e, t) {
  if (!ce(t))
    return dT(t, e) ? 0 : -1;
  for (var n = 0, s = t.length; n < s; n++)
    if (dT(t[n], e))
      return n;
  return -1;
}
var Oa = {
  enumerable: !0,
  configurable: !0,
  get: sn,
  set: sn
};
function pE(e, t, n) {
  Oa.get = function() {
    return this[t][n];
  }, Oa.set = function(r) {
    this[t][n] = r;
  }, Object.defineProperty(e, n, Oa);
}
function a4(e) {
  var t = e.$options;
  if (t.props && o4(e, t.props), Hz(e), t.methods && d4(e, t.methods), t.data)
    l4(e);
  else {
    var n = sa(e._data = {});
    n && n.vmCount++;
  }
  t.computed && h4(e, t.computed), t.watch && t.watch !== bv && f4(e, t.watch);
}
function o4(e, t) {
  var n = e.$options.propsData || {}, s = e._props = iE({}), r = e.$options._propKeys = [], i = !e.$parent;
  i || no(!1);
  var a = function(l) {
    r.push(l);
    var f = fE(l, t, n, e);
    io(s, l, f), l in e || pE(e, "_props", l);
  };
  for (var o in t)
    a(o);
  no(!0);
}
function l4(e) {
  var t = e.$options.data;
  t = e._data = Le(t) ? u4(t, e) : t || {}, Ai(t) || (t = {});
  var n = Object.keys(t), s = e.$options.props;
  e.$options.methods;
  for (var r = n.length; r--; ) {
    var i = n[r];
    s && Ii(s, i) || UM(i) || pE(e, "_data", i);
  }
  var a = sa(t);
  a && a.vmCount++;
}
function u4(e, t) {
  Mu();
  try {
    return e.call(t, t);
  } catch (n) {
    return Xo(n, t, "data()"), {};
  } finally {
    _u();
  }
}
var c4 = { lazy: !0 };
function h4(e, t) {
  var n = e._computedWatchers = /* @__PURE__ */ Object.create(null), s = ao();
  for (var r in t) {
    var i = t[r], a = Le(i) ? i : i.get;
    s || (n[r] = new sh(e, a || sn, sn, c4)), r in e || C_(e, r, i);
  }
}
function C_(e, t, n) {
  var s = !ao();
  Le(n) ? (Oa.get = s ? pT(t) : mT(n), Oa.set = sn) : (Oa.get = n.get ? s && n.cache !== !1 ? pT(t) : mT(n.get) : sn, Oa.set = n.set || sn), Object.defineProperty(e, t, Oa);
}
function pT(e) {
  return function() {
    var n = this._computedWatchers && this._computedWatchers[e];
    if (n)
      return n.dirty && n.evaluate(), xs.target && n.depend(), n.value;
  };
}
function mT(e) {
  return function() {
    return e.call(this, this);
  };
}
function d4(e, t) {
  e.$options.props;
  for (var n in t)
    e[n] = typeof t[n] != "function" ? sn : BM(t[n], e);
}
function f4(e, t) {
  for (var n in t) {
    var s = t[n];
    if (ce(s))
      for (var r = 0; r < s.length; r++)
        Rv(e, n, s[r]);
    else
      Rv(e, n, s);
  }
}
function Rv(e, t, n, s) {
  return Ai(n) && (s = n, n = n.handler), typeof n == "string" && (n = e[n]), e.$watch(t, n, s);
}
function p4(e) {
  var t = {};
  t.get = function() {
    return this._data;
  };
  var n = {};
  n.get = function() {
    return this._props;
  }, Object.defineProperty(e.prototype, "$data", t), Object.defineProperty(e.prototype, "$props", n), e.prototype.$set = sp, e.prototype.$delete = nE, e.prototype.$watch = function(s, r, i) {
    var a = this;
    if (Ai(r))
      return Rv(a, s, r, i);
    i = i || {}, i.user = !0;
    var o = new sh(a, s, r, i);
    if (i.immediate) {
      var l = 'callback for immediate watcher "'.concat(o.expression, '"');
      Mu(), aa(r, a, [o.value], a, l), _u();
    }
    return function() {
      o.teardown();
    };
  };
}
var m4 = 0;
function g4(e) {
  e.prototype._init = function(t) {
    var n = this;
    n._uid = m4++, n._isVue = !0, n.__v_skip = !0, n._scope = new rE(
      !0
      /* detached */
    ), n._scope._vm = !0, t && t._isComponent ? v4(n, t) : n.$options = Zo(mE(n.constructor), t || {}, n), n._renderProxy = n, n._self = n, wK(n), IK(n), tK(n), Nr(
      n,
      "beforeCreate",
      void 0,
      !1
      /* setContext */
    ), GK(n), a4(n), KK(n), Nr(n, "created"), n.$options.el && n.$mount(n.$options.el);
  };
}
function v4(e, t) {
  var n = e.$options = Object.create(e.constructor.options), s = t._parentVnode;
  n.parent = t.parent, n._parentVnode = s;
  var r = s.componentOptions;
  n.propsData = r.propsData, n._parentListeners = r.listeners, n._renderChildren = r.children, n._componentTag = r.tag, t.render && (n.render = t.render, n.staticRenderFns = t.staticRenderFns);
}
function mE(e) {
  var t = e.options;
  if (e.super) {
    var n = mE(e.super), s = e.superOptions;
    if (n !== s) {
      e.superOptions = n;
      var r = y4(e);
      r && He(e.extendOptions, r), t = e.options = Zo(n, e.extendOptions), t.name && (t.components[t.name] = e);
    }
  }
  return t;
}
function y4(e) {
  var t, n = e.options, s = e.sealedOptions;
  for (var r in n)
    n[r] !== s[r] && (t || (t = {}), t[r] = n[r]);
  return t;
}
function $t(e) {
  this._init(e);
}
g4($t);
p4($t);
RK($t);
VK($t);
eK($t);
function E4(e) {
  e.use = function(t) {
    var n = this._installedPlugins || (this._installedPlugins = []);
    if (n.indexOf(t) > -1)
      return this;
    var s = Cv(arguments, 1);
    return s.unshift(this), Le(t.install) ? t.install.apply(t, s) : Le(t) && t.apply(null, s), n.push(t), this;
  };
}
function C4(e) {
  e.mixin = function(t) {
    return this.options = Zo(this.options, t), this;
  };
}
function x4(e) {
  e.cid = 0;
  var t = 1;
  e.extend = function(n) {
    n = n || {};
    var s = this, r = s.cid, i = n._Ctor || (n._Ctor = {});
    if (i[r])
      return i[r];
    var a = uf(n) || uf(s.options), o = function(f) {
      this._init(f);
    };
    return o.prototype = Object.create(s.prototype), o.prototype.constructor = o, o.cid = t++, o.options = Zo(s.options, n), o.super = s, o.options.props && b4(o), o.options.computed && T4(o), o.extend = s.extend, o.mixin = s.mixin, o.use = s.use, rp.forEach(function(l) {
      o[l] = s[l];
    }), a && (o.options.components[a] = o), o.superOptions = s.options, o.extendOptions = n, o.sealedOptions = He({}, o.options), i[r] = o, o;
  };
}
function b4(e) {
  var t = e.options.props;
  for (var n in t)
    pE(e.prototype, "_props", n);
}
function T4(e) {
  var t = e.options.computed;
  for (var n in t)
    C_(e.prototype, n, t[n]);
}
function O4(e) {
  rp.forEach(function(t) {
    e[t] = function(n, s) {
      return s ? (t === "component" && Ai(s) && (s.name = s.name || n, s = this.options._base.extend(s)), t === "directive" && Le(s) && (s = { bind: s, update: s }), this.options[t + "s"][n] = s, s) : this.options[t + "s"][n];
    };
  });
}
function gT(e) {
  return e && (uf(e.Ctor.options) || e.tag);
}
function zh(e, t) {
  return ce(e) ? e.indexOf(t) > -1 : typeof e == "string" ? e.split(",").indexOf(t) > -1 : z5(e) ? e.test(t) : !1;
}
function vT(e, t) {
  var n = e.cache, s = e.keys, r = e._vnode;
  for (var i in n) {
    var a = n[i];
    if (a) {
      var o = a.name;
      o && !t(o) && wv(n, i, s, r);
    }
  }
}
function wv(e, t, n, s) {
  var r = e[t];
  r && (!s || r.tag !== s.tag) && r.componentInstance.$destroy(), e[t] = null, so(n, t);
}
var yT = [String, RegExp, Array], P4 = {
  name: "keep-alive",
  abstract: !0,
  props: {
    include: yT,
    exclude: yT,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function() {
      var e = this, t = e.cache, n = e.keys, s = e.vnodeToCache, r = e.keyToCache;
      if (s) {
        var i = s.tag, a = s.componentInstance, o = s.componentOptions;
        t[r] = {
          name: gT(o),
          tag: i,
          componentInstance: a
        }, n.push(r), this.max && n.length > parseInt(this.max) && wv(t, n[0], n, this._vnode), this.vnodeToCache = null;
      }
    }
  },
  created: function() {
    this.cache = /* @__PURE__ */ Object.create(null), this.keys = [];
  },
  destroyed: function() {
    for (var e in this.cache)
      wv(this.cache, e, this.keys);
  },
  mounted: function() {
    var e = this;
    this.cacheVNode(), this.$watch("include", function(t) {
      vT(e, function(n) {
        return zh(t, n);
      });
    }), this.$watch("exclude", function(t) {
      vT(e, function(n) {
        return !zh(t, n);
      });
    });
  },
  updated: function() {
    this.cacheVNode();
  },
  render: function() {
    var e = this.$slots.default, t = u_(e), n = t && t.componentOptions;
    if (n) {
      var s = gT(n), r = this, i = r.include, a = r.exclude;
      if (
        // not included
        i && (!s || !zh(i, s)) || // excluded
        a && s && zh(a, s)
      )
        return t;
      var o = this, l = o.cache, f = o.keys, d = t.key == null ? (
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        n.Ctor.cid + (n.tag ? "::".concat(n.tag) : "")
      ) : t.key;
      l[d] ? (t.componentInstance = l[d].componentInstance, so(f, d), f.push(d)) : (this.vnodeToCache = t, this.keyToCache = d), t.data.keepAlive = !0;
    }
    return t || e && e[0];
  }
}, S4 = {
  KeepAlive: P4
};
function M4(e) {
  var t = {};
  t.get = function() {
    return Er;
  }, Object.defineProperty(e, "config", t), e.util = {
    warn: JK,
    extend: He,
    mergeOptions: Zo,
    defineReactive: io
  }, e.set = sp, e.delete = nE, e.nextTick = lp, e.observable = function(n) {
    return sa(n), n;
  }, e.options = /* @__PURE__ */ Object.create(null), rp.forEach(function(n) {
    e.options[n + "s"] = /* @__PURE__ */ Object.create(null);
  }), e.options._base = e, He(e.options.components, S4), E4(e), C4(e), x4(e), O4(e);
}
M4($t);
Object.defineProperty($t.prototype, "$isServer", {
  get: ao
});
Object.defineProperty($t.prototype, "$ssrContext", {
  get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty($t, "FunctionalRenderContext", {
  value: hE
});
$t.version = d_;
var _4 = zr("style,class"), I4 = zr("input,textarea,option,select,progress"), D4 = function(e, t, n) {
  return n === "value" && I4(e) && t !== "button" || n === "selected" && e === "option" || n === "checked" && e === "input" || n === "muted" && e === "video";
}, x_ = zr("contenteditable,draggable,spellcheck"), A4 = zr("events,caret,typing,plaintext-only"), L4 = function(e, t) {
  return hf(t) || t === "false" ? "false" : (
    // allow arbitrary string value for contenteditable
    e === "contenteditable" && A4(t) ? t : "true"
  );
}, R4 = zr("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), Vv = "http://www.w3.org/1999/xlink", gE = function(e) {
  return e.charAt(5) === ":" && e.slice(0, 5) === "xlink";
}, b_ = function(e) {
  return gE(e) ? e.slice(6, e.length) : "";
}, hf = function(e) {
  return e == null || e === !1;
};
function w4(e) {
  for (var t = e.data, n = e, s = e; ht(s.componentInstance); )
    s = s.componentInstance._vnode, s && s.data && (t = ET(s.data, t));
  for (; ht(n = n.parent); )
    n && n.data && (t = ET(t, n.data));
  return V4(t.staticClass, t.class);
}
function ET(e, t) {
  return {
    staticClass: vE(e.staticClass, t.staticClass),
    class: ht(e.class) ? [e.class, t.class] : t.class
  };
}
function V4(e, t) {
  return ht(e) || ht(t) ? vE(e, yE(t)) : "";
}
function vE(e, t) {
  return e ? t ? e + " " + t : e : t || "";
}
function yE(e) {
  return Array.isArray(e) ? B4(e) : pi(e) ? F4(e) : typeof e == "string" ? e : "";
}
function B4(e) {
  for (var t = "", n, s = 0, r = e.length; s < r; s++)
    ht(n = yE(e[s])) && n !== "" && (t && (t += " "), t += n);
  return t;
}
function F4(e) {
  var t = "";
  for (var n in e)
    e[n] && (t && (t += " "), t += n);
  return t;
}
var N4 = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
}, j4 = zr("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), EE = zr("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0), T_ = function(e) {
  return j4(e) || EE(e);
};
function $4(e) {
  if (EE(e))
    return "svg";
  if (e === "math")
    return "math";
}
var Kh = /* @__PURE__ */ Object.create(null);
function U4(e) {
  if (!Gi)
    return !0;
  if (T_(e))
    return !1;
  if (e = e.toLowerCase(), Kh[e] != null)
    return Kh[e];
  var t = document.createElement(e);
  return e.indexOf("-") > -1 ? Kh[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : Kh[e] = /HTMLUnknownElement/.test(t.toString());
}
var Bv = zr("text,number,password,search,email,tel,url");
function W4(e) {
  if (typeof e == "string") {
    var t = document.querySelector(e);
    return t || document.createElement("div");
  } else
    return e;
}
function z4(e, t) {
  var n = document.createElement(e);
  return e !== "select" || t.data && t.data.attrs && t.data.attrs.multiple !== void 0 && n.setAttribute("multiple", "multiple"), n;
}
function K4(e, t) {
  return document.createElementNS(N4[e], t);
}
function G4(e) {
  return document.createTextNode(e);
}
function k4(e) {
  return document.createComment(e);
}
function H4(e, t, n) {
  e.insertBefore(t, n);
}
function Y4(e, t) {
  e.removeChild(t);
}
function X4(e, t) {
  e.appendChild(t);
}
function Z4(e) {
  return e.parentNode;
}
function J4(e) {
  return e.nextSibling;
}
function Q4(e) {
  return e.tagName;
}
function q4(e, t) {
  e.textContent = t;
}
function tG(e, t) {
  e.setAttribute(t, "");
}
var eG = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createElement: z4,
  createElementNS: K4,
  createTextNode: G4,
  createComment: k4,
  insertBefore: H4,
  removeChild: Y4,
  appendChild: X4,
  parentNode: Z4,
  nextSibling: J4,
  tagName: Q4,
  setTextContent: q4,
  setStyleScope: tG
}), nG = {
  create: function(e, t) {
    wl(t);
  },
  update: function(e, t) {
    e.data.ref !== t.data.ref && (wl(e, !0), wl(t));
  },
  destroy: function(e) {
    wl(e, !0);
  }
};
function wl(e, t) {
  var n = e.data.ref;
  if (ht(n)) {
    var s = e.context, r = e.componentInstance || e.elm, i = t ? null : r, a = t ? void 0 : r;
    if (Le(n)) {
      aa(n, s, [i], s, "template ref function");
      return;
    }
    var o = e.data.refInFor, l = typeof n == "string" || typeof n == "number", f = ei(n), d = s.$refs;
    if (l || f) {
      if (o) {
        var u = l ? d[n] : n.value;
        t ? ce(u) && so(u, r) : ce(u) ? u.includes(r) || u.push(r) : l ? (d[n] = [r], CT(s, n, d[n])) : n.value = [r];
      } else if (l) {
        if (t && d[n] !== r)
          return;
        d[n] = a, CT(s, n, i);
      } else if (f) {
        if (t && n.value !== r)
          return;
        n.value = i;
      }
    }
  }
}
function CT(e, t, n) {
  var s = e._setupState;
  s && Ii(s, t) && (ei(s[t]) ? s[t].value = n : s[t] = n);
}
var wa = new ar("", {}, []), Wu = ["create", "activate", "update", "remove", "destroy"];
function vo(e, t) {
  return e.key === t.key && e.asyncFactory === t.asyncFactory && (e.tag === t.tag && e.isComment === t.isComment && ht(e.data) === ht(t.data) && iG(e, t) || un(e.isAsyncPlaceholder) && te(t.asyncFactory.error));
}
function iG(e, t) {
  if (e.tag !== "input")
    return !0;
  var n, s = ht(n = e.data) && ht(n = n.attrs) && n.type, r = ht(n = t.data) && ht(n = n.attrs) && n.type;
  return s === r || Bv(s) && Bv(r);
}
function rG(e, t, n) {
  var s, r, i = {};
  for (s = t; s <= n; ++s)
    r = e[s].key, ht(r) && (i[r] = s);
  return i;
}
function sG(e) {
  var t, n, s = {}, r = e.modules, i = e.nodeOps;
  for (t = 0; t < Wu.length; ++t)
    for (s[Wu[t]] = [], n = 0; n < r.length; ++n)
      ht(r[n][Wu[t]]) && s[Wu[t]].push(r[n][Wu[t]]);
  function a(A) {
    return new ar(i.tagName(A).toLowerCase(), {}, [], void 0, A);
  }
  function o(A, D) {
    function I() {
      --I.listeners === 0 && l(A);
    }
    return I.listeners = D, I;
  }
  function l(A) {
    var D = i.parentNode(A);
    ht(D) && i.removeChild(D, A);
  }
  function f(A, D, I, w, B, j, k) {
    if (ht(A.elm) && ht(j) && (A = j[k] = Tv(A)), A.isRootInsert = !B, !d(A, D, I, w)) {
      var X = A.data, rt = A.children, et = A.tag;
      ht(et) ? (A.elm = A.ns ? i.createElementNS(A.ns, et) : i.createElement(et, A), v(A), p(A, rt, D), ht(X) && m(A, D), h(I, A.elm, w)) : un(A.isComment) ? (A.elm = i.createComment(A.text), h(I, A.elm, w)) : (A.elm = i.createTextNode(A.text), h(I, A.elm, w));
    }
  }
  function d(A, D, I, w) {
    var B = A.data;
    if (ht(B)) {
      var j = ht(A.componentInstance) && B.keepAlive;
      if (ht(B = B.hook) && ht(B = B.init) && B(
        A,
        !1
        /* hydrating */
      ), ht(A.componentInstance))
        return u(A, D), h(I, A.elm, w), un(j) && c(A, D, I, w), !0;
    }
  }
  function u(A, D) {
    ht(A.data.pendingInsert) && (D.push.apply(D, A.data.pendingInsert), A.data.pendingInsert = null), A.elm = A.componentInstance.$el, g(A) ? (m(A, D), v(A)) : (wl(A), D.push(A));
  }
  function c(A, D, I, w) {
    for (var B, j = A; j.componentInstance; )
      if (j = j.componentInstance._vnode, ht(B = j.data) && ht(B = B.transition)) {
        for (B = 0; B < s.activate.length; ++B)
          s.activate[B](wa, j);
        D.push(j);
        break;
      }
    h(I, A.elm, w);
  }
  function h(A, D, I) {
    ht(A) && (ht(I) ? i.parentNode(I) === A && i.insertBefore(A, D, I) : i.appendChild(A, D));
  }
  function p(A, D, I) {
    if (ce(D))
      for (var w = 0; w < D.length; ++w)
        f(D[w], I, A.elm, null, !0, D, w);
    else
      eh(A.text) && i.appendChild(A.elm, i.createTextNode(String(A.text)));
  }
  function g(A) {
    for (; A.componentInstance; )
      A = A.componentInstance._vnode;
    return ht(A.tag);
  }
  function m(A, D) {
    for (var I = 0; I < s.create.length; ++I)
      s.create[I](wa, A);
    t = A.data.hook, ht(t) && (ht(t.create) && t.create(wa, A), ht(t.insert) && D.push(A));
  }
  function v(A) {
    var D;
    if (ht(D = A.fnScopeId))
      i.setStyleScope(A.elm, D);
    else
      for (var I = A; I; )
        ht(D = I.context) && ht(D = D.$options._scopeId) && i.setStyleScope(A.elm, D), I = I.parent;
    ht(D = Lo) && D !== A.context && D !== A.fnContext && ht(D = D.$options._scopeId) && i.setStyleScope(A.elm, D);
  }
  function y(A, D, I, w, B, j) {
    for (; w <= B; ++w)
      f(I[w], j, A, D, !1, I, w);
  }
  function E(A) {
    var D, I, w = A.data;
    if (ht(w))
      for (ht(D = w.hook) && ht(D = D.destroy) && D(A), D = 0; D < s.destroy.length; ++D)
        s.destroy[D](A);
    if (ht(D = A.children))
      for (I = 0; I < A.children.length; ++I)
        E(A.children[I]);
  }
  function C(A, D, I) {
    for (; D <= I; ++D) {
      var w = A[D];
      ht(w) && (ht(w.tag) ? (x(w), E(w)) : l(w.elm));
    }
  }
  function x(A, D) {
    if (ht(D) || ht(A.data)) {
      var I, w = s.remove.length + 1;
      for (ht(D) ? D.listeners += w : D = o(A.elm, w), ht(I = A.componentInstance) && ht(I = I._vnode) && ht(I.data) && x(I, D), I = 0; I < s.remove.length; ++I)
        s.remove[I](A, D);
      ht(I = A.data.hook) && ht(I = I.remove) ? I(A, D) : D();
    } else
      l(A.elm);
  }
  function b(A, D, I, w, B) {
    for (var j = 0, k = 0, X = D.length - 1, rt = D[0], et = D[X], Z = I.length - 1, dt = I[0], vt = I[Z], bt, it, R, V, tt = !B; j <= X && k <= Z; )
      te(rt) ? rt = D[++j] : te(et) ? et = D[--X] : vo(rt, dt) ? (O(rt, dt, w, I, k), rt = D[++j], dt = I[++k]) : vo(et, vt) ? (O(et, vt, w, I, Z), et = D[--X], vt = I[--Z]) : vo(rt, vt) ? (O(rt, vt, w, I, Z), tt && i.insertBefore(A, rt.elm, i.nextSibling(et.elm)), rt = D[++j], vt = I[--Z]) : vo(et, dt) ? (O(et, dt, w, I, k), tt && i.insertBefore(A, et.elm, rt.elm), et = D[--X], dt = I[++k]) : (te(bt) && (bt = rG(D, j, X)), it = ht(dt.key) ? bt[dt.key] : P(dt, D, j, X), te(it) ? f(dt, w, A, rt.elm, !1, I, k) : (R = D[it], vo(R, dt) ? (O(R, dt, w, I, k), D[it] = void 0, tt && i.insertBefore(A, R.elm, rt.elm)) : f(dt, w, A, rt.elm, !1, I, k)), dt = I[++k]);
    j > X ? (V = te(I[Z + 1]) ? null : I[Z + 1].elm, y(A, V, I, k, Z, w)) : k > Z && C(D, j, X);
  }
  function P(A, D, I, w) {
    for (var B = I; B < w; B++) {
      var j = D[B];
      if (ht(j) && vo(A, j))
        return B;
    }
  }
  function O(A, D, I, w, B, j) {
    if (A !== D) {
      ht(D.elm) && ht(w) && (D = w[B] = Tv(D));
      var k = D.elm = A.elm;
      if (un(A.isAsyncPlaceholder)) {
        ht(D.asyncFactory.resolved) ? L(A.elm, D, I) : D.isAsyncPlaceholder = !0;
        return;
      }
      if (un(D.isStatic) && un(A.isStatic) && D.key === A.key && (un(D.isCloned) || un(D.isOnce))) {
        D.componentInstance = A.componentInstance;
        return;
      }
      var X, rt = D.data;
      ht(rt) && ht(X = rt.hook) && ht(X = X.prepatch) && X(A, D);
      var et = A.children, Z = D.children;
      if (ht(rt) && g(D)) {
        for (X = 0; X < s.update.length; ++X)
          s.update[X](A, D);
        ht(X = rt.hook) && ht(X = X.update) && X(A, D);
      }
      te(D.text) ? ht(et) && ht(Z) ? et !== Z && b(k, et, Z, I, j) : ht(Z) ? (ht(A.text) && i.setTextContent(k, ""), y(k, null, Z, 0, Z.length - 1, I)) : ht(et) ? C(et, 0, et.length - 1) : ht(A.text) && i.setTextContent(k, "") : A.text !== D.text && i.setTextContent(k, D.text), ht(rt) && ht(X = rt.hook) && ht(X = X.postpatch) && X(A, D);
    }
  }
  function T(A, D, I) {
    if (un(I) && ht(A.parent))
      A.parent.data.pendingInsert = D;
    else
      for (var w = 0; w < D.length; ++w)
        D[w].data.hook.insert(D[w]);
  }
  var M = zr("attrs,class,staticClass,staticStyle,key");
  function L(A, D, I, w) {
    var B, j = D.tag, k = D.data, X = D.children;
    if (w = w || k && k.pre, D.elm = A, un(D.isComment) && ht(D.asyncFactory))
      return D.isAsyncPlaceholder = !0, !0;
    if (ht(k) && (ht(B = k.hook) && ht(B = B.init) && B(
      D,
      !0
      /* hydrating */
    ), ht(B = D.componentInstance)))
      return u(D, I), !0;
    if (ht(j)) {
      if (ht(X))
        if (!A.hasChildNodes())
          p(D, X, I);
        else if (ht(B = k) && ht(B = B.domProps) && ht(B = B.innerHTML)) {
          if (B !== A.innerHTML)
            return !1;
        } else {
          for (var rt = !0, et = A.firstChild, Z = 0; Z < X.length; Z++) {
            if (!et || !L(et, X[Z], I, w)) {
              rt = !1;
              break;
            }
            et = et.nextSibling;
          }
          if (!rt || et)
            return !1;
        }
      if (ht(k)) {
        var dt = !1;
        for (var vt in k)
          if (!M(vt)) {
            dt = !0, m(D, I);
            break;
          }
        !dt && k.class && ou(k.class);
      }
    } else
      A.data !== D.text && (A.data = D.text);
    return !0;
  }
  return function(D, I, w, B) {
    if (te(I)) {
      ht(D) && E(D);
      return;
    }
    var j = !1, k = [];
    if (te(D))
      j = !0, f(I, k);
    else {
      var X = ht(D.nodeType);
      if (!X && vo(D, I))
        O(D, I, k, null, null, B);
      else {
        if (X) {
          if (D.nodeType === 1 && D.hasAttribute(Gb) && (D.removeAttribute(Gb), w = !0), un(w) && L(D, I, k))
            return T(I, k, !0), D;
          D = a(D);
        }
        var rt = D.elm, et = i.parentNode(rt);
        if (f(
          I,
          k,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          rt._leaveCb ? null : et,
          i.nextSibling(rt)
        ), ht(I.parent))
          for (var Z = I.parent, dt = g(I); Z; ) {
            for (var vt = 0; vt < s.destroy.length; ++vt)
              s.destroy[vt](Z);
            if (Z.elm = I.elm, dt) {
              for (var bt = 0; bt < s.create.length; ++bt)
                s.create[bt](wa, Z);
              var it = Z.data.hook.insert;
              if (it.merged)
                for (var R = it.fns.slice(1), V = 0; V < R.length; V++)
                  R[V]();
            } else
              wl(Z);
            Z = Z.parent;
          }
        ht(et) ? C([D], 0, 0) : ht(D.tag) && E(D);
      }
    }
    return T(I, k, j), I.elm;
  };
}
var aG = {
  create: Qm,
  update: Qm,
  destroy: function(t) {
    Qm(t, wa);
  }
};
function Qm(e, t) {
  (e.data.directives || t.data.directives) && oG(e, t);
}
function oG(e, t) {
  var n = e === wa, s = t === wa, r = xT(e.data.directives, e.context), i = xT(t.data.directives, t.context), a = [], o = [], l, f, d;
  for (l in i)
    f = r[l], d = i[l], f ? (d.oldValue = f.value, d.oldArg = f.arg, zu(d, "update", t, e), d.def && d.def.componentUpdated && o.push(d)) : (zu(d, "bind", t, e), d.def && d.def.inserted && a.push(d));
  if (a.length) {
    var u = function() {
      for (var c = 0; c < a.length; c++)
        zu(a[c], "inserted", t, e);
    };
    n ? Ra(t, "insert", u) : u();
  }
  if (o.length && Ra(t, "postpatch", function() {
    for (var c = 0; c < o.length; c++)
      zu(o[c], "componentUpdated", t, e);
  }), !n)
    for (l in r)
      i[l] || zu(r[l], "unbind", e, e, s);
}
var lG = /* @__PURE__ */ Object.create(null);
function xT(e, t) {
  var n = /* @__PURE__ */ Object.create(null);
  if (!e)
    return n;
  var s, r;
  for (s = 0; s < e.length; s++) {
    if (r = e[s], r.modifiers || (r.modifiers = lG), n[uG(r)] = r, t._setupState && t._setupState.__sfc) {
      var i = r.def || cf(t, "_setupState", "v-" + r.name);
      typeof i == "function" ? r.def = {
        bind: i,
        update: i
      } : r.def = i;
    }
    r.def = r.def || cf(t.$options, "directives", r.name);
  }
  return n;
}
function uG(e) {
  return e.rawName || "".concat(e.name, ".").concat(Object.keys(e.modifiers || {}).join("."));
}
function zu(e, t, n, s, r) {
  var i = e.def && e.def[t];
  if (i)
    try {
      i(n.elm, e, n, s, r);
    } catch (a) {
      Xo(a, n.context, "directive ".concat(e.name, " ").concat(t, " hook"));
    }
}
var cG = [nG, aG];
function bT(e, t) {
  var n = t.componentOptions;
  if (!(ht(n) && n.Ctor.options.inheritAttrs === !1) && !(te(e.data.attrs) && te(t.data.attrs))) {
    var s, r, i, a = t.elm, o = e.data.attrs || {}, l = t.data.attrs || {};
    (ht(l.__ob__) || un(l._v_attr_proxy)) && (l = t.data.attrs = He({}, l));
    for (s in l)
      r = l[s], i = o[s], i !== r && TT(a, s, r, t.data.pre);
    (Pu || WM) && l.value !== o.value && TT(a, "value", l.value);
    for (s in o)
      te(l[s]) && (gE(s) ? a.removeAttributeNS(Vv, b_(s)) : x_(s) || a.removeAttribute(s));
  }
}
function TT(e, t, n, s) {
  s || e.tagName.indexOf("-") > -1 ? OT(e, t, n) : R4(t) ? hf(n) ? e.removeAttribute(t) : (n = t === "allowfullscreen" && e.tagName === "EMBED" ? "true" : t, e.setAttribute(t, n)) : x_(t) ? e.setAttribute(t, L4(t, n)) : gE(t) ? hf(n) ? e.removeAttributeNS(Vv, b_(t)) : e.setAttributeNS(Vv, t, n) : OT(e, t, n);
}
function OT(e, t, n) {
  if (hf(n))
    e.removeAttribute(t);
  else {
    if (Pu && !Su && e.tagName === "TEXTAREA" && t === "placeholder" && n !== "" && !e.__ieph) {
      var s = function(r) {
        r.stopImmediatePropagation(), e.removeEventListener("input", s);
      };
      e.addEventListener("input", s), e.__ieph = !0;
    }
    e.setAttribute(t, n);
  }
}
var hG = {
  create: bT,
  update: bT
};
function PT(e, t) {
  var n = t.elm, s = t.data, r = e.data;
  if (!(te(s.staticClass) && te(s.class) && (te(r) || te(r.staticClass) && te(r.class)))) {
    var i = w4(t), a = n._transitionClasses;
    ht(a) && (i = vE(i, yE(a))), i !== n._prevClass && (n.setAttribute("class", i), n._prevClass = i);
  }
}
var dG = {
  create: PT,
  update: PT
}, qm = "__r", tg = "__c";
function fG(e) {
  if (ht(e[qm])) {
    var t = Pu ? "change" : "input";
    e[t] = [].concat(e[qm], e[t] || []), delete e[qm];
  }
  ht(e[tg]) && (e.change = [].concat(e[tg], e.change || []), delete e[tg]);
}
var Vc;
function pG(e, t, n) {
  var s = Vc;
  return function r() {
    var i = t.apply(null, arguments);
    i !== null && O_(e, r, n, s);
  };
}
var mG = Sv && !(kb && Number(kb[1]) <= 53);
function gG(e, t, n, s) {
  if (mG) {
    var r = v_, i = t;
    t = i._wrapper = function(a) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        a.target === a.currentTarget || // event is fired after handler attachment
        a.timeStamp >= r || // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        a.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        a.target.ownerDocument !== document
      )
        return i.apply(this, arguments);
    };
  }
  Vc.addEventListener(e, t, zM ? { capture: n, passive: s } : n);
}
function O_(e, t, n, s) {
  (s || Vc).removeEventListener(
    e,
    //@ts-expect-error
    t._wrapper || t,
    n
  );
}
function eg(e, t) {
  if (!(te(e.data.on) && te(t.data.on))) {
    var n = t.data.on || {}, s = e.data.on || {};
    Vc = t.elm || e.elm, fG(n), n_(n, s, gG, O_, pG, t.context), Vc = void 0;
  }
}
var vG = {
  create: eg,
  update: eg,
  // @ts-expect-error emptyNode has actually data
  destroy: function(e) {
    return eg(e, wa);
  }
}, Gh;
function ST(e, t) {
  if (!(te(e.data.domProps) && te(t.data.domProps))) {
    var n, s, r = t.elm, i = e.data.domProps || {}, a = t.data.domProps || {};
    (ht(a.__ob__) || un(a._v_attr_proxy)) && (a = t.data.domProps = He({}, a));
    for (n in i)
      n in a || (r[n] = "");
    for (n in a) {
      if (s = a[n], n === "textContent" || n === "innerHTML") {
        if (t.children && (t.children.length = 0), s === i[n])
          continue;
        r.childNodes.length === 1 && r.removeChild(r.childNodes[0]);
      }
      if (n === "value" && r.tagName !== "PROGRESS") {
        r._value = s;
        var o = te(s) ? "" : String(s);
        yG(r, o) && (r.value = o);
      } else if (n === "innerHTML" && EE(r.tagName) && te(r.innerHTML)) {
        Gh = Gh || document.createElement("div"), Gh.innerHTML = "<svg>".concat(s, "</svg>");
        for (var l = Gh.firstChild; r.firstChild; )
          r.removeChild(r.firstChild);
        for (; l.firstChild; )
          r.appendChild(l.firstChild);
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        s !== i[n]
      )
        try {
          r[n] = s;
        } catch {
        }
    }
  }
}
function yG(e, t) {
  return (
    //@ts-expect-error
    !e.composing && (e.tagName === "OPTION" || EG(e, t) || CG(e, t))
  );
}
function EG(e, t) {
  var n = !0;
  try {
    n = document.activeElement !== e;
  } catch {
  }
  return n && e.value !== t;
}
function CG(e, t) {
  var n = e.value, s = e._vModifiers;
  if (ht(s)) {
    if (s.number)
      return Ic(n) !== Ic(t);
    if (s.trim)
      return n.trim() !== t.trim();
  }
  return n !== t;
}
var xG = {
  create: ST,
  update: ST
}, bG = il(function(e) {
  var t = {}, n = /;(?![^(]*\))/g, s = /:(.+)/;
  return e.split(n).forEach(function(r) {
    if (r) {
      var i = r.split(s);
      i.length > 1 && (t[i[0].trim()] = i[1].trim());
    }
  }), t;
});
function ng(e) {
  var t = P_(e.style);
  return e.staticStyle ? He(e.staticStyle, t) : t;
}
function P_(e) {
  return Array.isArray(e) ? FM(e) : typeof e == "string" ? bG(e) : e;
}
function TG(e, t) {
  var n = {}, s;
  if (t)
    for (var r = e; r.componentInstance; )
      r = r.componentInstance._vnode, r && r.data && (s = ng(r.data)) && He(n, s);
  (s = ng(e.data)) && He(n, s);
  for (var i = e; i = i.parent; )
    i.data && (s = ng(i.data)) && He(n, s);
  return n;
}
var OG = /^--/, MT = /\s*!important$/, _T = function(e, t, n) {
  if (OG.test(t))
    e.style.setProperty(t, n);
  else if (MT.test(n))
    e.style.setProperty(nh(t), n.replace(MT, ""), "important");
  else {
    var s = PG(t);
    if (Array.isArray(n))
      for (var r = 0, i = n.length; r < i; r++)
        e.style[s] = n[r];
    else
      e.style[s] = n;
  }
}, IT = ["Webkit", "Moz", "ms"], kh, PG = il(function(e) {
  if (kh = kh || document.createElement("div").style, e = Ho(e), e !== "filter" && e in kh)
    return e;
  for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < IT.length; n++) {
    var s = IT[n] + t;
    if (s in kh)
      return s;
  }
});
function DT(e, t) {
  var n = t.data, s = e.data;
  if (!(te(n.staticStyle) && te(n.style) && te(s.staticStyle) && te(s.style))) {
    var r, i, a = t.elm, o = s.staticStyle, l = s.normalizedStyle || s.style || {}, f = o || l, d = P_(t.data.style) || {};
    t.data.normalizedStyle = ht(d.__ob__) ? He({}, d) : d;
    var u = TG(t, !0);
    for (i in f)
      te(u[i]) && _T(a, i, "");
    for (i in u)
      r = u[i], r !== f[i] && _T(a, i, r ?? "");
  }
}
var SG = {
  create: DT,
  update: DT
}, S_ = /\s+/;
function M_(e, t) {
  if (!(!t || !(t = t.trim())))
    if (e.classList)
      t.indexOf(" ") > -1 ? t.split(S_).forEach(function(s) {
        return e.classList.add(s);
      }) : e.classList.add(t);
    else {
      var n = " ".concat(e.getAttribute("class") || "", " ");
      n.indexOf(" " + t + " ") < 0 && e.setAttribute("class", (n + t).trim());
    }
}
function __(e, t) {
  if (!(!t || !(t = t.trim())))
    if (e.classList)
      t.indexOf(" ") > -1 ? t.split(S_).forEach(function(r) {
        return e.classList.remove(r);
      }) : e.classList.remove(t), e.classList.length || e.removeAttribute("class");
    else {
      for (var n = " ".concat(e.getAttribute("class") || "", " "), s = " " + t + " "; n.indexOf(s) >= 0; )
        n = n.replace(s, " ");
      n = n.trim(), n ? e.setAttribute("class", n) : e.removeAttribute("class");
    }
}
function I_(e) {
  if (e) {
    if (typeof e == "object") {
      var t = {};
      return e.css !== !1 && He(t, AT(e.name || "v")), He(t, e), t;
    } else if (typeof e == "string")
      return AT(e);
  }
}
var AT = il(function(e) {
  return {
    enterClass: "".concat(e, "-enter"),
    enterToClass: "".concat(e, "-enter-to"),
    enterActiveClass: "".concat(e, "-enter-active"),
    leaveClass: "".concat(e, "-leave"),
    leaveToClass: "".concat(e, "-leave-to"),
    leaveActiveClass: "".concat(e, "-leave-active")
  };
}), D_ = Gi && !Su, bl = "transition", ig = "animation", vd = "transition", df = "transitionend", Fv = "animation", A_ = "animationend";
D_ && (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0 && (vd = "WebkitTransition", df = "webkitTransitionEnd"), window.onanimationend === void 0 && window.onwebkitanimationend !== void 0 && (Fv = "WebkitAnimation", A_ = "webkitAnimationEnd"));
var LT = Gi ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (
  /* istanbul ignore next */
  function(e) {
    return e();
  }
);
function L_(e) {
  LT(function() {
    LT(e);
  });
}
function Ro(e, t) {
  var n = e._transitionClasses || (e._transitionClasses = []);
  n.indexOf(t) < 0 && (n.push(t), M_(e, t));
}
function Hs(e, t) {
  e._transitionClasses && so(e._transitionClasses, t), __(e, t);
}
function R_(e, t, n) {
  var s = w_(e, t), r = s.type, i = s.timeout, a = s.propCount;
  if (!r)
    return n();
  var o = r === bl ? df : A_, l = 0, f = function() {
    e.removeEventListener(o, d), n();
  }, d = function(u) {
    u.target === e && ++l >= a && f();
  };
  setTimeout(function() {
    l < a && f();
  }, i + 1), e.addEventListener(o, d);
}
var MG = /\b(transform|all)(,|$)/;
function w_(e, t) {
  var n = window.getComputedStyle(e), s = (n[vd + "Delay"] || "").split(", "), r = (n[vd + "Duration"] || "").split(", "), i = RT(s, r), a = (n[Fv + "Delay"] || "").split(", "), o = (n[Fv + "Duration"] || "").split(", "), l = RT(a, o), f, d = 0, u = 0;
  t === bl ? i > 0 && (f = bl, d = i, u = r.length) : t === ig ? l > 0 && (f = ig, d = l, u = o.length) : (d = Math.max(i, l), f = d > 0 ? i > l ? bl : ig : null, u = f ? f === bl ? r.length : o.length : 0);
  var c = f === bl && MG.test(n[vd + "Property"]);
  return {
    type: f,
    timeout: d,
    propCount: u,
    hasTransform: c
  };
}
function RT(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max.apply(null, t.map(function(n, s) {
    return wT(n) + wT(e[s]);
  }));
}
function wT(e) {
  return Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function Nv(e, t) {
  var n = e.elm;
  ht(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb());
  var s = I_(e.data.transition);
  if (!te(s) && !(ht(n._enterCb) || n.nodeType !== 1)) {
    for (var r = s.css, i = s.type, a = s.enterClass, o = s.enterToClass, l = s.enterActiveClass, f = s.appearClass, d = s.appearToClass, u = s.appearActiveClass, c = s.beforeEnter, h = s.enter, p = s.afterEnter, g = s.enterCancelled, m = s.beforeAppear, v = s.appear, y = s.afterAppear, E = s.appearCancelled, C = s.duration, x = Lo, b = Lo.$vnode; b && b.parent; )
      x = b.context, b = b.parent;
    var P = !x._isMounted || !e.isRootInsert;
    if (!(P && !v && v !== "")) {
      var O = P && f ? f : a, T = P && u ? u : l, M = P && d ? d : o, L = P && m || c, A = P && Le(v) ? v : h, D = P && y || p, I = P && E || g, w = Ic(pi(C) ? C.enter : C), B = r !== !1 && !Su, j = CE(A), k = n._enterCb = ef(function() {
        B && (Hs(n, M), Hs(n, T)), k.cancelled ? (B && Hs(n, O), I && I(n)) : D && D(n), n._enterCb = null;
      });
      e.data.show || Ra(e, "insert", function() {
        var X = n.parentNode, rt = X && X._pending && X._pending[e.key];
        rt && rt.tag === e.tag && rt.elm._leaveCb && rt.elm._leaveCb(), A && A(n, k);
      }), L && L(n), B && (Ro(n, O), Ro(n, T), L_(function() {
        Hs(n, O), k.cancelled || (Ro(n, M), j || (B_(w) ? setTimeout(k, w) : R_(n, i, k)));
      })), e.data.show && (t && t(), A && A(n, k)), !B && !j && k();
    }
  }
}
function V_(e, t) {
  var n = e.elm;
  ht(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb());
  var s = I_(e.data.transition);
  if (te(s) || n.nodeType !== 1)
    return t();
  if (ht(n._leaveCb))
    return;
  var r = s.css, i = s.type, a = s.leaveClass, o = s.leaveToClass, l = s.leaveActiveClass, f = s.beforeLeave, d = s.leave, u = s.afterLeave, c = s.leaveCancelled, h = s.delayLeave, p = s.duration, g = r !== !1 && !Su, m = CE(d), v = Ic(pi(p) ? p.leave : p), y = n._leaveCb = ef(function() {
    n.parentNode && n.parentNode._pending && (n.parentNode._pending[e.key] = null), g && (Hs(n, o), Hs(n, l)), y.cancelled ? (g && Hs(n, a), c && c(n)) : (t(), u && u(n)), n._leaveCb = null;
  });
  h ? h(E) : E();
  function E() {
    y.cancelled || (!e.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[e.key] = e), f && f(n), g && (Ro(n, a), Ro(n, l), L_(function() {
      Hs(n, a), y.cancelled || (Ro(n, o), m || (B_(v) ? setTimeout(y, v) : R_(n, i, y)));
    })), d && d(n, y), !g && !m && y());
  }
}
function B_(e) {
  return typeof e == "number" && !isNaN(e);
}
function CE(e) {
  if (te(e))
    return !1;
  var t = e.fns;
  return ht(t) ? CE(Array.isArray(t) ? t[0] : t) : (e._length || e.length) > 1;
}
function VT(e, t) {
  t.data.show !== !0 && Nv(t);
}
var _G = Gi ? {
  create: VT,
  activate: VT,
  remove: function(e, t) {
    e.data.show !== !0 ? V_(e, t) : t();
  }
} : {}, IG = [hG, dG, vG, xG, SG, _G], DG = IG.concat(cG), AG = sG({ nodeOps: eG, modules: DG });
Su && document.addEventListener("selectionchange", function() {
  var e = document.activeElement;
  e && e.vmodel && xE(e, "input");
});
var F_ = {
  inserted: function(e, t, n, s) {
    n.tag === "select" ? (s.elm && !s.elm._vOptions ? Ra(n, "postpatch", function() {
      F_.componentUpdated(e, t, n);
    }) : BT(e, t, n.context), e._vOptions = [].map.call(e.options, ff)) : (n.tag === "textarea" || Bv(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener("compositionstart", LG), e.addEventListener("compositionend", jT), e.addEventListener("change", jT), Su && (e.vmodel = !0)));
  },
  componentUpdated: function(e, t, n) {
    if (n.tag === "select") {
      BT(e, t, n.context);
      var s = e._vOptions, r = e._vOptions = [].map.call(e.options, ff);
      if (r.some(function(a, o) {
        return !Yo(a, s[o]);
      })) {
        var i = e.multiple ? t.value.some(function(a) {
          return NT(a, r);
        }) : t.value !== t.oldValue && NT(t.value, r);
        i && xE(e, "change");
      }
    }
  }
};
function BT(e, t, n) {
  FT(e, t), (Pu || WM) && setTimeout(function() {
    FT(e, t);
  }, 0);
}
function FT(e, t, n) {
  var s = t.value, r = e.multiple;
  if (!(r && !Array.isArray(s))) {
    for (var i, a, o = 0, l = e.options.length; o < l; o++)
      if (a = e.options[o], r)
        i = jM(s, ff(a)) > -1, a.selected !== i && (a.selected = i);
      else if (Yo(ff(a), s)) {
        e.selectedIndex !== o && (e.selectedIndex = o);
        return;
      }
    r || (e.selectedIndex = -1);
  }
}
function NT(e, t) {
  return t.every(function(n) {
    return !Yo(n, e);
  });
}
function ff(e) {
  return "_value" in e ? e._value : e.value;
}
function LG(e) {
  e.target.composing = !0;
}
function jT(e) {
  e.target.composing && (e.target.composing = !1, xE(e.target, "input"));
}
function xE(e, t) {
  var n = document.createEvent("HTMLEvents");
  n.initEvent(t, !0, !0), e.dispatchEvent(n);
}
function jv(e) {
  return e.componentInstance && (!e.data || !e.data.transition) ? jv(e.componentInstance._vnode) : e;
}
var RG = {
  bind: function(e, t, n) {
    var s = t.value;
    n = jv(n);
    var r = n.data && n.data.transition, i = e.__vOriginalDisplay = e.style.display === "none" ? "" : e.style.display;
    s && r ? (n.data.show = !0, Nv(n, function() {
      e.style.display = i;
    })) : e.style.display = s ? i : "none";
  },
  update: function(e, t, n) {
    var s = t.value, r = t.oldValue;
    if (!s != !r) {
      n = jv(n);
      var i = n.data && n.data.transition;
      i ? (n.data.show = !0, s ? Nv(n, function() {
        e.style.display = e.__vOriginalDisplay;
      }) : V_(n, function() {
        e.style.display = "none";
      })) : e.style.display = s ? e.__vOriginalDisplay : "none";
    }
  },
  unbind: function(e, t, n, s, r) {
    r || (e.style.display = e.__vOriginalDisplay);
  }
}, wG = {
  model: F_,
  show: RG
}, N_ = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function $v(e) {
  var t = e && e.componentOptions;
  return t && t.Ctor.options.abstract ? $v(u_(t.children)) : e;
}
function j_(e) {
  var t = {}, n = e.$options;
  for (var s in n.propsData)
    t[s] = e[s];
  var r = n._parentListeners;
  for (var s in r)
    t[Ho(s)] = r[s];
  return t;
}
function $T(e, t) {
  if (/\d-keep-alive$/.test(t.tag))
    return e("keep-alive", {
      props: t.componentOptions.propsData
    });
}
function VG(e) {
  for (; e = e.parent; )
    if (e.data.transition)
      return !0;
}
function BG(e, t) {
  return t.key === e.key && t.tag === e.tag;
}
var FG = function(e) {
  return e.tag || Ac(e);
}, NG = function(e) {
  return e.name === "show";
}, jG = {
  name: "transition",
  props: N_,
  abstract: !0,
  render: function(e) {
    var t = this, n = this.$slots.default;
    if (n && (n = n.filter(FG), !!n.length)) {
      var s = this.mode, r = n[0];
      if (VG(this.$vnode))
        return r;
      var i = $v(r);
      if (!i)
        return r;
      if (this._leaving)
        return $T(e, r);
      var a = "__transition-".concat(this._uid, "-");
      i.key = i.key == null ? i.isComment ? a + "comment" : a + i.tag : eh(i.key) ? String(i.key).indexOf(a) === 0 ? i.key : a + i.key : i.key;
      var o = (i.data || (i.data = {})).transition = j_(this), l = this._vnode, f = $v(l);
      if (i.data.directives && i.data.directives.some(NG) && (i.data.show = !0), f && f.data && !BG(i, f) && !Ac(f) && // #6687 component root is a comment node
      !(f.componentInstance && f.componentInstance._vnode.isComment)) {
        var d = f.data.transition = He({}, o);
        if (s === "out-in")
          return this._leaving = !0, Ra(d, "afterLeave", function() {
            t._leaving = !1, t.$forceUpdate();
          }), $T(e, r);
        if (s === "in-out") {
          if (Ac(i))
            return l;
          var u, c = function() {
            u();
          };
          Ra(o, "afterEnter", c), Ra(o, "enterCancelled", c), Ra(d, "delayLeave", function(h) {
            u = h;
          });
        }
      }
      return r;
    }
  }
}, $_ = He({
  tag: String,
  moveClass: String
}, N_);
delete $_.mode;
var $G = {
  props: $_,
  beforeMount: function() {
    var e = this, t = this._update;
    this._update = function(n, s) {
      var r = p_(e);
      e.__patch__(
        e._vnode,
        e.kept,
        !1,
        // hydrating
        !0
        // removeOnly (!important, avoids unnecessary moves)
      ), e._vnode = e.kept, r(), t.call(e, n, s);
    };
  },
  render: function(e) {
    for (var t = this.tag || this.$vnode.data.tag || "span", n = /* @__PURE__ */ Object.create(null), s = this.prevChildren = this.children, r = this.$slots.default || [], i = this.children = [], a = j_(this), o = 0; o < r.length; o++) {
      var l = r[o];
      l.tag && l.key != null && String(l.key).indexOf("__vlist") !== 0 && (i.push(l), n[l.key] = l, (l.data || (l.data = {})).transition = a);
    }
    if (s) {
      for (var f = [], d = [], o = 0; o < s.length; o++) {
        var l = s[o];
        l.data.transition = a, l.data.pos = l.elm.getBoundingClientRect(), n[l.key] ? f.push(l) : d.push(l);
      }
      this.kept = e(t, null, f), this.removed = d;
    }
    return e(t, null, i);
  },
  updated: function() {
    var e = this.prevChildren, t = this.moveClass || (this.name || "v") + "-move";
    !e.length || !this.hasMove(e[0].elm, t) || (e.forEach(UG), e.forEach(WG), e.forEach(zG), this._reflow = document.body.offsetHeight, e.forEach(function(n) {
      if (n.data.moved) {
        var s = n.elm, r = s.style;
        Ro(s, t), r.transform = r.WebkitTransform = r.transitionDuration = "", s.addEventListener(df, s._moveCb = function i(a) {
          a && a.target !== s || (!a || /transform$/.test(a.propertyName)) && (s.removeEventListener(df, i), s._moveCb = null, Hs(s, t));
        });
      }
    }));
  },
  methods: {
    hasMove: function(e, t) {
      if (!D_)
        return !1;
      if (this._hasMove)
        return this._hasMove;
      var n = e.cloneNode();
      e._transitionClasses && e._transitionClasses.forEach(function(r) {
        __(n, r);
      }), M_(n, t), n.style.display = "none", this.$el.appendChild(n);
      var s = w_(n);
      return this.$el.removeChild(n), this._hasMove = s.hasTransform;
    }
  }
};
function UG(e) {
  e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb();
}
function WG(e) {
  e.data.newPos = e.elm.getBoundingClientRect();
}
function zG(e) {
  var t = e.data.pos, n = e.data.newPos, s = t.left - n.left, r = t.top - n.top;
  if (s || r) {
    e.data.moved = !0;
    var i = e.elm.style;
    i.transform = i.WebkitTransform = "translate(".concat(s, "px,").concat(r, "px)"), i.transitionDuration = "0s";
  }
}
var KG = {
  Transition: jG,
  TransitionGroup: $G
};
$t.config.mustUseProp = D4;
$t.config.isReservedTag = T_;
$t.config.isReservedAttr = _4;
$t.config.getTagNamespace = $4;
$t.config.isUnknownElement = U4;
He($t.options.directives, wG);
He($t.options.components, KG);
$t.prototype.__patch__ = Gi ? AG : sn;
$t.prototype.$mount = function(e, t) {
  return e = e && Gi ? W4(e) : void 0, BK(this, e, t);
};
Gi && setTimeout(function() {
  Er.devtools && nf && nf.emit("init", $t);
}, 0);
const GG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EffectScope: rE,
  computed: bz,
  customRef: gz,
  default: $t,
  defineAsyncComponent: dK,
  defineComponent: MK,
  del: nE,
  effectScope: Mz,
  getCurrentInstance: iz,
  getCurrentScope: t_,
  h: oK,
  inject: Az,
  isProxy: uz,
  isReactive: Ao,
  isReadonly: rl,
  isRef: ei,
  isShallow: sf,
  markRaw: cz,
  mergeDefaults: qz,
  nextTick: lp,
  onActivated: CK,
  onBeforeMount: pK,
  onBeforeUnmount: yK,
  onBeforeUpdate: gK,
  onDeactivated: xK,
  onErrorCaptured: SK,
  onMounted: mK,
  onRenderTracked: TK,
  onRenderTriggered: OK,
  onScopeDispose: Iz,
  onServerPrefetch: bK,
  onUnmounted: EK,
  onUpdated: vK,
  provide: Dz,
  proxyRefs: mz,
  reactive: lz,
  readonly: JM,
  ref: hz,
  set: sp,
  shallowReactive: iE,
  shallowReadonly: xz,
  shallowRef: dz,
  toRaw: YM,
  toRef: ZM,
  toRefs: vz,
  triggerRef: fz,
  unref: pz,
  useAttrs: Jz,
  useCssModule: cK,
  useCssVars: hK,
  useListeners: Qz,
  useSlots: Zz,
  version: d_,
  watch: Sz,
  watchEffect: Oz,
  watchPostEffect: qM,
  watchSyncEffect: Pz
}, Symbol.toStringTag, { value: "Module" }));
var U_ = { exports: {} };
const kG = /* @__PURE__ */ gS(GG);
(function(e, t) {
  (function(s, r) {
    e.exports = r(kG);
  })(typeof self < "u" ? self : It, function(n) {
    return (
      /******/
      function(s) {
        var r = {};
        function i(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return s[a].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = s, i.c = r, i.d = function(a, o, l) {
          i.o(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: l });
        }, i.r = function(a) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
        }, i.t = function(a, o) {
          if (o & 1 && (a = i(a)), o & 8 || o & 4 && typeof a == "object" && a && a.__esModule)
            return a;
          var l = /* @__PURE__ */ Object.create(null);
          if (i.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: a }), o & 2 && typeof a != "string")
            for (var f in a)
              i.d(l, f, (function(d) {
                return a[d];
              }).bind(null, f));
          return l;
        }, i.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, i.p = "/dist/", i(i.s = "./src/index.ts");
      }({
        /***/
        "./src/components/VAlert/VAlert.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VAlert/VAlert.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAlert/VAlert.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAlert/VAlert.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAlert.sass */
              "./src/components/VAlert/VAlert.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, f.default, u.default).extend({
              name: "v-alert",
              props: {
                border: {
                  type: String,
                  validator: function(m) {
                    return ["top", "right", "bottom", "left"].includes(m);
                  }
                },
                closeLabel: {
                  type: String,
                  default: "$vuetify.close"
                },
                coloredBorder: Boolean,
                dense: Boolean,
                dismissible: Boolean,
                closeIcon: {
                  type: String,
                  default: "$cancel"
                },
                icon: {
                  default: "",
                  type: [Boolean, String],
                  validator: function(m) {
                    return typeof m == "string" || m === !1;
                  }
                },
                outlined: Boolean,
                prominent: Boolean,
                text: Boolean,
                type: {
                  type: String,
                  validator: function(m) {
                    return ["info", "error", "success", "warning"].includes(m);
                  }
                },
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              computed: {
                __cachedBorder: function() {
                  var m;
                  if (!this.border)
                    return null;
                  var v = {
                    staticClass: "v-alert__border",
                    class: (m = {}, m["v-alert__border--" + this.border] = !0, m)
                  };
                  return this.coloredBorder && (v = this.setBackgroundColor(this.computedColor, v), v.class["v-alert__border--has-color"] = !0), this.$createElement("div", v);
                },
                __cachedDismissible: function() {
                  var m = this;
                  if (!this.dismissible)
                    return null;
                  var v = this.iconColor;
                  return this.$createElement(o.default, {
                    staticClass: "v-alert__dismissible",
                    props: {
                      color: v,
                      icon: !0,
                      small: !0
                    },
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.closeLabel)
                    },
                    on: {
                      click: function() {
                        return m.isActive = !1;
                      }
                    }
                  }, [this.$createElement(l.default, {
                    props: {
                      color: v
                    }
                  }, this.closeIcon)]);
                },
                __cachedIcon: function() {
                  return this.computedIcon ? this.$createElement(l.default, {
                    staticClass: "v-alert__icon",
                    props: {
                      color: this.iconColor
                    }
                  }, this.computedIcon) : null;
                },
                classes: function() {
                  var m = p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-alert--border": !!this.border,
                    "v-alert--dense": this.dense,
                    "v-alert--outlined": this.outlined,
                    "v-alert--prominent": this.prominent,
                    "v-alert--text": this.text
                  });
                  return this.border && (m["v-alert--border-" + this.border] = !0), m;
                },
                computedColor: function() {
                  return this.color || this.type;
                },
                computedIcon: function() {
                  return this.icon === !1 ? !1 : typeof this.icon == "string" && this.icon ? this.icon : ["error", "info", "success", "warning"].includes(this.type) ? "$" + this.type : !1;
                },
                hasColoredIcon: function() {
                  return this.hasText || !!this.border && this.coloredBorder;
                },
                hasText: function() {
                  return this.text || this.outlined;
                },
                iconColor: function() {
                  return this.hasColoredIcon ? this.computedColor : void 0;
                },
                isDark: function() {
                  return this.type && !this.coloredBorder && !this.outlined ? !0 : d.default.options.computed.isDark.call(this);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("outline") && Object(h.breaking)("outline", "outlined", this);
              },
              methods: {
                genWrapper: function() {
                  var m = [this.$slots.prepend || this.__cachedIcon, this.genContent(), this.__cachedBorder, this.$slots.append, this.$scopedSlots.close ? this.$scopedSlots.close({
                    toggle: this.toggle
                  }) : this.__cachedDismissible], v = {
                    staticClass: "v-alert__wrapper"
                  };
                  return this.$createElement("div", v, m);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-alert__content"
                  }, this.$slots.default);
                },
                genAlert: function() {
                  var m = {
                    staticClass: "v-alert",
                    attrs: {
                      role: "alert"
                    },
                    on: this.listeners$,
                    class: this.classes,
                    style: this.styles,
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }]
                  };
                  if (!this.coloredBorder) {
                    var v = this.hasText ? this.setTextColor : this.setBackgroundColor;
                    m = v(this.computedColor, m);
                  }
                  return this.$createElement("div", m, [this.genWrapper()]);
                },
                /** @public */
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              },
              render: function(m) {
                var v = this.genAlert();
                return this.transition ? m("transition", {
                  props: {
                    name: this.transition,
                    origin: this.origin,
                    mode: this.mode
                  }
                }, [v]) : v;
              }
            });
          }
        ),
        /***/
        "./src/components/VAlert/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VAlert/index.ts ***!
            \****************************************/
          /*! exports provided: VAlert, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAlert */
              "./src/components/VAlert/VAlert.ts"
            );
            i.d(r, "VAlert", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VApp/VApp.sass": (
          /*!***************************************!*\
            !*** ./src/components/VApp/VApp.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VApp/VApp.ts": (
          /*!*************************************!*\
            !*** ./src/components/VApp/VApp.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VApp.sass */
              "./src/components/VApp/VApp.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-app",
              props: {
                dark: {
                  type: Boolean,
                  default: void 0
                },
                id: {
                  type: String,
                  default: "app"
                },
                light: {
                  type: Boolean,
                  default: void 0
                }
              },
              computed: {
                isDark: function() {
                  return this.$vuetify.theme.dark;
                }
              },
              beforeCreate: function() {
                if (!this.$vuetify || this.$vuetify === this.$root)
                  throw new Error("Vuetify is not properly initialized, see https://v2.vuetifyjs.com/getting-started/quick-start#bootstrapping-the-vuetify-object");
              },
              render: function(d) {
                var u = d("div", {
                  staticClass: "v-application--wrap"
                }, this.$slots.default);
                return d("div", {
                  staticClass: "v-application",
                  class: l({
                    "v-application--is-rtl": this.$vuetify.rtl,
                    "v-application--is-ltr": !this.$vuetify.rtl
                  }, this.themeClasses),
                  attrs: {
                    "data-app": !0
                  },
                  domProps: {
                    id: this.id
                  }
                }, [u]);
              }
            });
          }
        ),
        /***/
        "./src/components/VApp/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VApp/index.ts ***!
            \**************************************/
          /*! exports provided: VApp, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VApp */
              "./src/components/VApp/VApp.ts"
            );
            i.d(r, "VApp", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBar.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VAppBar/VAppBar.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBar.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VAppBar/VAppBar.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAppBar.sass */
              "./src/components/VAppBar/VAppBar.sass"
            );
            var a = i(
              /*! ../VToolbar/VToolbar */
              "./src/components/VToolbar/VToolbar.ts"
            ), o = i(
              /*! ../../directives/scroll */
              "./src/directives/scroll/index.ts"
            ), l = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), f = i(
              /*! ../../mixins/scrollable */
              "./src/mixins/scrollable/index.ts"
            ), d = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), u = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(a.default, f.default, d.default, u.default, Object(l.default)("top", ["clippedLeft", "clippedRight", "computedHeight", "invertedScroll", "isExtended", "isProminent", "value"]));
            r.default = g.extend({
              name: "v-app-bar",
              directives: {
                Scroll: o.default
              },
              provide: function() {
                return {
                  VAppBar: this
                };
              },
              props: {
                clippedLeft: Boolean,
                clippedRight: Boolean,
                collapseOnScroll: Boolean,
                elevateOnScroll: Boolean,
                fadeImgOnScroll: Boolean,
                hideOnScroll: Boolean,
                invertedScroll: Boolean,
                scrollOffScreen: Boolean,
                shrinkOnScroll: Boolean,
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              data: function() {
                return {
                  isActive: this.value
                };
              },
              computed: {
                applicationProperty: function() {
                  return this.bottom ? "bottom" : "top";
                },
                canScroll: function() {
                  return f.default.options.computed.canScroll.call(this) && (this.invertedScroll || this.elevateOnScroll || this.hideOnScroll || this.collapseOnScroll || this.isBooted || // If falsy, user has provided an
                  // explicit value which should
                  // overwrite anything we do
                  !this.value);
                },
                classes: function() {
                  return p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-toolbar--collapse": this.collapse || this.collapseOnScroll,
                    "v-app-bar": !0,
                    "v-app-bar--clipped": this.clippedLeft || this.clippedRight,
                    "v-app-bar--fade-img-on-scroll": this.fadeImgOnScroll,
                    "v-app-bar--elevate-on-scroll": this.elevateOnScroll,
                    "v-app-bar--fixed": !this.absolute && (this.app || this.fixed),
                    "v-app-bar--hide-shadow": this.hideShadow,
                    "v-app-bar--is-scrolled": this.currentScroll > 0,
                    "v-app-bar--shrink-on-scroll": this.shrinkOnScroll
                  });
                },
                scrollRatio: function() {
                  var v = this.computedScrollThreshold;
                  return Math.max((v - this.currentScroll) / v, 0);
                },
                computedContentHeight: function() {
                  if (!this.shrinkOnScroll)
                    return a.default.options.computed.computedContentHeight.call(this);
                  var v = this.dense ? 48 : 56, y = this.computedOriginalHeight;
                  return v + (y - v) * this.scrollRatio;
                },
                computedFontSize: function() {
                  if (this.isProminent) {
                    var v = 1.25, y = 1.5;
                    return v + (y - v) * this.scrollRatio;
                  }
                },
                computedLeft: function() {
                  return !this.app || this.clippedLeft ? 0 : this.$vuetify.application.left;
                },
                computedMarginTop: function() {
                  return this.app ? this.$vuetify.application.bar : 0;
                },
                computedOpacity: function() {
                  if (this.fadeImgOnScroll)
                    return this.scrollRatio;
                },
                computedOriginalHeight: function() {
                  var v = a.default.options.computed.computedContentHeight.call(this);
                  return this.isExtended && (v += parseInt(this.extensionHeight)), v;
                },
                computedRight: function() {
                  return !this.app || this.clippedRight ? 0 : this.$vuetify.application.right;
                },
                computedScrollThreshold: function() {
                  return this.scrollThreshold ? Number(this.scrollThreshold) : this.computedOriginalHeight - (this.dense ? 48 : 56);
                },
                computedTransform: function() {
                  if (!this.canScroll || this.elevateOnScroll && this.currentScroll === 0 && this.isActive || this.isActive)
                    return 0;
                  var v = this.scrollOffScreen ? this.computedHeight : this.computedContentHeight;
                  return this.bottom ? v : -v;
                },
                hideShadow: function() {
                  return this.elevateOnScroll && this.isExtended ? this.currentScroll < this.computedScrollThreshold : this.elevateOnScroll ? this.currentScroll === 0 || this.computedTransform < 0 : (!this.isExtended || this.scrollOffScreen) && this.computedTransform !== 0;
                },
                isCollapsed: function() {
                  return this.collapseOnScroll ? this.currentScroll > 0 : a.default.options.computed.isCollapsed.call(this);
                },
                isProminent: function() {
                  return a.default.options.computed.isProminent.call(this) || this.shrinkOnScroll;
                },
                styles: function() {
                  return p(p({}, a.default.options.computed.styles.call(this)), {
                    fontSize: Object(c.convertToUnit)(this.computedFontSize, "rem"),
                    marginTop: Object(c.convertToUnit)(this.computedMarginTop),
                    transform: "translateY(" + Object(c.convertToUnit)(this.computedTransform) + ")",
                    left: Object(c.convertToUnit)(this.computedLeft),
                    right: Object(c.convertToUnit)(this.computedRight)
                  });
                }
              },
              watch: {
                canScroll: "onScroll",
                computedTransform: function() {
                  !this.canScroll || !this.clippedLeft && !this.clippedRight || this.callUpdate();
                },
                invertedScroll: function(v) {
                  this.isActive = !v || this.currentScroll !== 0;
                },
                hideOnScroll: function(v) {
                  this.isActive = !v || this.currentScroll < this.computedScrollThreshold;
                }
              },
              created: function() {
                this.invertedScroll && (this.isActive = !1);
              },
              methods: {
                genBackground: function() {
                  var v = a.default.options.methods.genBackground.call(this);
                  return v.data = this._b(v.data || {}, v.tag, {
                    style: {
                      opacity: this.computedOpacity
                    }
                  }), v;
                },
                updateApplication: function() {
                  return this.invertedScroll ? 0 : this.computedHeight + this.computedTransform;
                },
                thresholdMet: function() {
                  if (this.invertedScroll) {
                    this.isActive = this.currentScroll > this.computedScrollThreshold;
                    return;
                  }
                  this.hideOnScroll && (this.isActive = this.isScrollingUp || this.currentScroll < this.computedScrollThreshold), !(this.currentThreshold < this.computedScrollThreshold) && (this.savedScroll = this.currentScroll);
                }
              },
              render: function(v) {
                var y = a.default.options.render.call(this, v);
                return y.data = y.data || {}, this.canScroll && (y.data.directives = y.data.directives || [], y.data.directives.push({
                  arg: this.scrollTarget,
                  name: "scroll",
                  value: this.onScroll
                })), y;
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBarNavIcon.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VAppBar/VAppBarNavIcon.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VBtn/VBtn */
              "./src/components/VBtn/VBtn.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = f.a.extend({
              name: "v-app-bar-nav-icon",
              functional: !0,
              render: function(c, h) {
                var p = h.slots, g = h.listeners, m = h.props, v = h.data, y = Object.assign(v, {
                  staticClass: ("v-app-bar__nav-icon " + (v.staticClass || "")).trim(),
                  props: d(d({}, m), {
                    icon: !0
                  }),
                  on: g
                }), E = p().default;
                return c(o.default, y, E || [c(a.default, "$menu")]);
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/VAppBarTitle.ts": (
          /*!************************************************!*\
            !*** ./src/components/VAppBar/VAppBarTitle.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../services/goto/easing-patterns */
              "./src/services/goto/easing-patterns.ts"
            ), f = Object(a.inject)("VAppBar", "v-app-bar-title", "v-app-bar");
            r.default = f.extend().extend({
              name: "v-app-bar-title",
              data: function() {
                return {
                  contentWidth: 0,
                  left: 0,
                  width: 0
                };
              },
              watch: {
                "$vuetify.breakpoint.width": "updateDimensions"
              },
              computed: {
                styles: function() {
                  if (!this.contentWidth)
                    return {};
                  var u = this.width, c = this.contentWidth, h = Object(l.easeInOutCubic)(Math.min(1, this.VAppBar.scrollRatio * 1.5));
                  return {
                    width: Object(o.convertToUnit)(u + (c - u) * h),
                    visibility: this.VAppBar.scrollRatio ? "visible" : "hidden"
                  };
                }
              },
              mounted: function() {
                this.updateDimensions();
              },
              methods: {
                updateDimensions: function() {
                  var u = this.$refs.placeholder.getBoundingClientRect();
                  this.width = u.width, this.left = u.left, this.contentWidth = this.$refs.content.scrollWidth;
                }
              },
              render: function(u) {
                return u("div", {
                  class: "v-toolbar__title v-app-bar-title"
                }, [u("div", {
                  class: "v-app-bar-title__content",
                  style: this.styles,
                  ref: "content"
                }, [this.$slots.default]), u("div", {
                  class: "v-app-bar-title__placeholder",
                  style: {
                    visibility: this.VAppBar.scrollRatio ? "hidden" : "visible"
                  },
                  ref: "placeholder"
                }, [this.$slots.default])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VAppBar/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAppBar/index.ts ***!
            \*****************************************/
          /*! exports provided: VAppBar, VAppBarNavIcon, VAppBarTitle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAppBar */
              "./src/components/VAppBar/VAppBar.ts"
            );
            i.d(r, "VAppBar", function() {
              return a.default;
            });
            var o = i(
              /*! ./VAppBarNavIcon */
              "./src/components/VAppBar/VAppBarNavIcon.ts"
            );
            i.d(r, "VAppBarNavIcon", function() {
              return o.default;
            });
            var l = i(
              /*! ./VAppBarTitle */
              "./src/components/VAppBar/VAppBarTitle.ts"
            );
            i.d(r, "VAppBarTitle", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VAppBar: a.default,
                VAppBarNavIcon: o.default,
                VAppBarTitle: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VAutocomplete/VAutocomplete.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VAutocomplete/VAutocomplete.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAutocomplete/VAutocomplete.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VAutocomplete/VAutocomplete.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAutocomplete.sass */
              "./src/components/VAutocomplete/VAutocomplete.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = d(d({}, a.defaultMenuProps), {
              offsetY: !0,
              offsetOverflow: !0,
              transition: !1
            });
            r.default = a.default.extend({
              name: "v-autocomplete",
              props: {
                autoSelectFirst: {
                  type: Boolean,
                  default: !1
                },
                filter: {
                  type: Function,
                  default: function(h, p, g) {
                    return g.toLocaleLowerCase().indexOf(p.toLocaleLowerCase()) > -1;
                  }
                },
                hideNoData: Boolean,
                menuProps: {
                  type: a.default.options.props.menuProps.type,
                  default: function() {
                    return u;
                  }
                },
                noFilter: Boolean,
                searchInput: {
                  type: String
                }
              },
              data: function() {
                return {
                  lazySearch: this.searchInput
                };
              },
              computed: {
                classes: function() {
                  return d(d({}, a.default.options.computed.classes.call(this)), {
                    "v-autocomplete": !0,
                    "v-autocomplete--is-selecting-index": this.selectedIndex > -1
                  });
                },
                computedItems: function() {
                  return this.filteredItems;
                },
                selectedValues: function() {
                  var h = this;
                  return this.selectedItems.map(function(p) {
                    return h.getValue(p);
                  });
                },
                hasDisplayedItems: function() {
                  var h = this;
                  return this.hideSelected ? this.filteredItems.some(function(p) {
                    return !h.hasItem(p);
                  }) : this.filteredItems.length > 0;
                },
                currentRange: function() {
                  return this.selectedItem == null ? 0 : String(this.getText(this.selectedItem)).length;
                },
                filteredItems: function() {
                  var h = this;
                  return !this.isSearching || this.noFilter || this.internalSearch == null ? this.allItems : this.allItems.filter(function(p) {
                    var g = Object(f.getPropertyFromItem)(p, h.itemText), m = g != null ? String(g) : "";
                    return h.filter(p, String(h.internalSearch), m);
                  });
                },
                internalSearch: {
                  get: function() {
                    return this.lazySearch;
                  },
                  set: function(h) {
                    this.lazySearch !== h && (this.lazySearch = h, this.$emit("update:search-input", h));
                  }
                },
                isAnyValueAllowed: function() {
                  return !1;
                },
                isDirty: function() {
                  return this.searchIsDirty || this.selectedItems.length > 0;
                },
                isSearching: function() {
                  return this.multiple && this.searchIsDirty || this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);
                },
                menuCanShow: function() {
                  return this.isFocused ? this.hasDisplayedItems || !this.hideNoData : !1;
                },
                $_menuProps: function() {
                  var h = a.default.options.computed.$_menuProps.call(this);
                  return h.contentClass = ("v-autocomplete__content " + (h.contentClass || "")).trim(), d(d({}, u), h);
                },
                searchIsDirty: function() {
                  return this.internalSearch != null && this.internalSearch !== "";
                },
                selectedItem: function() {
                  var h = this;
                  return this.multiple ? null : this.selectedItems.find(function(p) {
                    return h.valueComparator(h.getValue(p), h.getValue(h.internalValue));
                  });
                },
                listData: function() {
                  var h = a.default.options.computed.listData.call(this);
                  return h.props = d(d({}, h.props), {
                    items: this.virtualizedItems,
                    noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,
                    searchInput: this.internalSearch
                  }), h;
                }
              },
              watch: {
                filteredItems: "onFilteredItemsChanged",
                internalValue: "setSearch",
                isFocused: function(h) {
                  h ? (document.addEventListener("copy", this.onCopy), this.$refs.input && this.$refs.input.select()) : (document.removeEventListener("copy", this.onCopy), this.blur(), this.updateSelf());
                },
                isMenuActive: function(h) {
                  h || !this.hasSlot || (this.lazySearch = null);
                },
                items: function(h, p) {
                  !(p && p.length) && this.hideNoData && this.isFocused && !this.isMenuActive && h.length && this.activateMenu();
                },
                searchInput: function(h) {
                  this.lazySearch = h;
                },
                internalSearch: "onInternalSearchChanged",
                itemText: "updateSelf"
              },
              created: function() {
                this.setSearch();
              },
              destroyed: function() {
                document.removeEventListener("copy", this.onCopy);
              },
              methods: {
                onFilteredItemsChanged: function(h, p) {
                  var g = this;
                  if (h !== p) {
                    if (!this.autoSelectFirst) {
                      var m = p[this.$refs.menu.listIndex];
                      m ? this.setMenuIndex(h.findIndex(function(v) {
                        return v === m;
                      })) : this.setMenuIndex(-1), this.$emit("update:list-index", this.$refs.menu.listIndex);
                    }
                    this.$nextTick(function() {
                      !g.internalSearch || h.length !== 1 && !g.autoSelectFirst || (g.$refs.menu.getTiles(), g.autoSelectFirst && h.length && (g.setMenuIndex(0), g.$emit("update:list-index", g.$refs.menu.listIndex)));
                    });
                  }
                },
                onInternalSearchChanged: function() {
                  this.updateMenuDimensions();
                },
                updateMenuDimensions: function() {
                  this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions();
                },
                changeSelectedIndex: function(h) {
                  this.searchIsDirty || (this.multiple && h === f.keyCodes.left ? this.selectedIndex === -1 ? this.selectedIndex = this.selectedItems.length - 1 : this.selectedIndex-- : this.multiple && h === f.keyCodes.right ? this.selectedIndex >= this.selectedItems.length - 1 ? this.selectedIndex = -1 : this.selectedIndex++ : (h === f.keyCodes.backspace || h === f.keyCodes.delete) && this.deleteCurrentItem());
                },
                deleteCurrentItem: function() {
                  var h = this.selectedIndex, p = this.selectedItems[h];
                  if (!(!this.isInteractive || this.getDisabled(p))) {
                    var g = this.selectedItems.length - 1;
                    if (this.selectedIndex === -1 && g !== 0) {
                      this.selectedIndex = g;
                      return;
                    }
                    var m = this.selectedItems.length, v = h !== m - 1 ? h : h - 1, y = this.selectedItems[v];
                    y ? this.selectItem(p) : this.setValue(this.multiple ? [] : null), this.selectedIndex = v;
                  }
                },
                clearableCallback: function() {
                  this.internalSearch = null, a.default.options.methods.clearableCallback.call(this);
                },
                genInput: function() {
                  var h = o.default.options.methods.genInput.call(this);
                  return h.data = Object(l.default)(h.data, {
                    attrs: {
                      "aria-activedescendant": Object(f.getObjectValueByPath)(this.$refs.menu, "activeTile.id"),
                      autocomplete: Object(f.getObjectValueByPath)(h.data, "attrs.autocomplete", "off")
                    },
                    domProps: {
                      value: this.internalSearch
                    }
                  }), h;
                },
                genInputSlot: function() {
                  var h = a.default.options.methods.genInputSlot.call(this);
                  return h.data.attrs.role = "combobox", h;
                },
                genSelections: function() {
                  return this.hasSlot || this.multiple ? a.default.options.methods.genSelections.call(this) : [];
                },
                onClick: function(h) {
                  this.isInteractive && (this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus(), this.isAppendInner(h.target) || this.activateMenu());
                },
                onInput: function(h) {
                  if (!(this.selectedIndex > -1 || !h.target)) {
                    var p = h.target, g = p.value;
                    p.value && this.activateMenu(), !this.multiple && g === "" && this.deleteCurrentItem(), this.internalSearch = g, this.badInput = p.validity && p.validity.badInput;
                  }
                },
                onKeyDown: function(h) {
                  var p = h.keyCode;
                  (h.ctrlKey || ![f.keyCodes.home, f.keyCodes.end].includes(p)) && a.default.options.methods.onKeyDown.call(this, h), this.changeSelectedIndex(p);
                },
                onSpaceDown: function(h) {
                },
                onTabDown: function(h) {
                  a.default.options.methods.onTabDown.call(this, h), this.updateSelf();
                },
                onUpDown: function(h) {
                  h.preventDefault(), this.activateMenu();
                },
                selectItem: function(h) {
                  a.default.options.methods.selectItem.call(this, h), this.setSearch();
                },
                setSelectedItems: function() {
                  a.default.options.methods.setSelectedItems.call(this), this.isFocused || this.setSearch();
                },
                setSearch: function() {
                  var h = this;
                  this.$nextTick(function() {
                    (!h.multiple || !h.internalSearch || !h.isMenuActive) && (h.internalSearch = !h.selectedItems.length || h.multiple || h.hasSlot ? null : h.getText(h.selectedItem));
                  });
                },
                updateSelf: function() {
                  !this.searchIsDirty && !this.internalValue || !this.multiple && !this.valueComparator(this.internalSearch, this.getValue(this.internalValue)) && this.setSearch();
                },
                hasItem: function(h) {
                  return this.selectedValues.indexOf(this.getValue(h)) > -1;
                },
                onCopy: function(h) {
                  var p, g;
                  if (this.selectedIndex !== -1) {
                    var m = this.selectedItems[this.selectedIndex], v = this.getText(m);
                    (p = h.clipboardData) === null || p === void 0 || p.setData("text/plain", v), (g = h.clipboardData) === null || g === void 0 || g.setData("text/vnd.vuetify.autocomplete.item+plain", v), h.preventDefault();
                  }
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VAutocomplete/index.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VAutocomplete/index.ts ***!
            \***********************************************/
          /*! exports provided: VAutocomplete, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAutocomplete */
              "./src/components/VAutocomplete/VAutocomplete.ts"
            );
            i.d(r, "VAutocomplete", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VAvatar/VAvatar.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VAvatar/VAvatar.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VAvatar/VAvatar.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VAvatar/VAvatar.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VAvatar.sass */
              "./src/components/VAvatar/VAvatar.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), l = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(d.default)(a.default, o.default, l.default).extend({
              name: "v-avatar",
              props: {
                left: Boolean,
                right: Boolean,
                size: {
                  type: [Number, String],
                  default: 48
                }
              },
              computed: {
                classes: function() {
                  return u({
                    "v-avatar--left": this.left,
                    "v-avatar--right": this.right
                  }, this.roundedClasses);
                },
                styles: function() {
                  return u({
                    height: Object(f.convertToUnit)(this.size),
                    minWidth: Object(f.convertToUnit)(this.size),
                    width: Object(f.convertToUnit)(this.size)
                  }, this.measurableStyles);
                }
              },
              render: function(h) {
                var p = {
                  staticClass: "v-avatar",
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                };
                return h("div", this.setBackgroundColor(this.color, p), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VAvatar/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VAvatar/index.ts ***!
            \*****************************************/
          /*! exports provided: VAvatar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VAvatar */
              "./src/components/VAvatar/VAvatar.ts"
            );
            i.d(r, "VAvatar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBadge/VBadge.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VBadge/VBadge.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBadge/VBadge.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VBadge/VBadge.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBadge.sass */
              "./src/components/VBadge/VBadge.sass"
            );
            var a = i(
              /*! ../VIcon/VIcon */
              "./src/components/VIcon/VIcon.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), u = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = function(m, v) {
              var y = {};
              for (var E in m)
                Object.prototype.hasOwnProperty.call(m, E) && v.indexOf(E) < 0 && (y[E] = m[E]);
              if (m != null && typeof Object.getOwnPropertySymbols == "function")
                for (var C = 0, E = Object.getOwnPropertySymbols(m); C < E.length; C++)
                  v.indexOf(E[C]) < 0 && Object.prototype.propertyIsEnumerable.call(m, E[C]) && (y[E[C]] = m[E[C]]);
              return y;
            };
            r.default = Object(c.default)(o.default, Object(u.factory)(["left", "bottom"]), l.default, f.default, d.default).extend({
              name: "v-badge",
              props: {
                avatar: Boolean,
                bordered: Boolean,
                color: {
                  type: String,
                  default: "primary"
                },
                content: {
                  required: !1
                },
                dot: Boolean,
                label: {
                  type: String,
                  default: "$vuetify.badge"
                },
                icon: String,
                inline: Boolean,
                offsetX: [Number, String],
                offsetY: [Number, String],
                overlap: Boolean,
                tile: Boolean,
                transition: {
                  type: String,
                  default: "scale-rotate-transition"
                },
                value: {
                  default: !0
                }
              },
              computed: {
                classes: function() {
                  return p({
                    "v-badge--avatar": this.avatar,
                    "v-badge--bordered": this.bordered,
                    "v-badge--bottom": this.bottom,
                    "v-badge--dot": this.dot,
                    "v-badge--icon": this.icon != null,
                    "v-badge--inline": this.inline,
                    "v-badge--left": this.left,
                    "v-badge--overlap": this.overlap,
                    "v-badge--tile": this.tile
                  }, this.themeClasses);
                },
                computedBottom: function() {
                  return this.bottom ? "auto" : this.computedYOffset;
                },
                computedLeft: function() {
                  return this.isRtl ? this.left ? this.computedXOffset : "auto" : this.left ? "auto" : this.computedXOffset;
                },
                computedRight: function() {
                  return this.isRtl ? this.left ? "auto" : this.computedXOffset : this.left ? this.computedXOffset : "auto";
                },
                computedTop: function() {
                  return this.bottom ? this.computedYOffset : "auto";
                },
                computedXOffset: function() {
                  return this.calcPosition(this.offsetX);
                },
                computedYOffset: function() {
                  return this.calcPosition(this.offsetY);
                },
                isRtl: function() {
                  return this.$vuetify.rtl;
                },
                // Default fallback if offsetX
                // or offsetY are undefined.
                offset: function() {
                  return this.overlap ? this.dot ? 8 : 12 : this.dot ? 2 : 4;
                },
                styles: function() {
                  return this.inline ? {} : {
                    bottom: this.computedBottom,
                    left: this.computedLeft,
                    right: this.computedRight,
                    top: this.computedTop
                  };
                }
              },
              methods: {
                calcPosition: function(v) {
                  return "calc(100% - " + Object(h.convertToUnit)(v || this.offset) + ")";
                },
                genBadge: function() {
                  var v = this.$vuetify.lang, y = this.$attrs["aria-label"] || v.t(this.label), E = this.setBackgroundColor(this.color, {
                    staticClass: "v-badge__badge",
                    style: this.styles,
                    attrs: {
                      "aria-atomic": this.$attrs["aria-atomic"] || "true",
                      "aria-label": y,
                      "aria-live": this.$attrs["aria-live"] || "polite",
                      title: this.$attrs.title,
                      role: this.$attrs.role || "status"
                    },
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }]
                  }), C = this.$createElement("span", E, [this.genBadgeContent()]);
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition,
                      origin: this.origin,
                      mode: this.mode
                    }
                  }, [C]) : C;
                },
                genBadgeContent: function() {
                  if (!this.dot) {
                    var v = Object(h.getSlot)(this, "badge");
                    if (v)
                      return v;
                    if (this.content)
                      return String(this.content);
                    if (this.icon)
                      return this.$createElement(a.default, this.icon);
                  }
                },
                genBadgeWrapper: function() {
                  return this.$createElement("span", {
                    staticClass: "v-badge__wrapper"
                  }, [this.genBadge()]);
                }
              },
              render: function(v) {
                var y = [this.genBadgeWrapper()], E = [Object(h.getSlot)(this)], C = this.$attrs;
                C["aria-atomic"], C["aria-label"], C["aria-live"], C.role, C.title;
                var x = g(C, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
                return this.inline && this.left ? E.unshift(y) : E.push(y), v("span", {
                  staticClass: "v-badge",
                  attrs: x,
                  class: this.classes
                }, E);
              }
            });
          }
        ),
        /***/
        "./src/components/VBadge/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VBadge/index.ts ***!
            \****************************************/
          /*! exports provided: VBadge, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBadge */
              "./src/components/VBadge/VBadge.ts"
            );
            i.d(r, "VBadge", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBanner/VBanner.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VBanner/VBanner.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBanner/VBanner.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VBanner/VBanner.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBanner.sass */
              "./src/components/VBanner/VBanner.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VAvatar */
              "./src/components/VAvatar/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), d = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), u = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, d.default, u.default).extend({
              name: "v-banner",
              inheritAttrs: !1,
              props: {
                app: Boolean,
                icon: String,
                iconColor: String,
                singleLine: Boolean,
                sticky: Boolean,
                value: {
                  type: Boolean,
                  default: !0
                }
              },
              computed: {
                classes: function() {
                  return p(p({}, a.default.options.computed.classes.call(this)), {
                    "v-banner--has-icon": this.hasIcon,
                    "v-banner--is-mobile": this.isMobile,
                    "v-banner--single-line": this.singleLine,
                    "v-banner--sticky": this.isSticky
                  });
                },
                hasIcon: function() {
                  return !!(this.icon || this.$slots.icon);
                },
                isSticky: function() {
                  return this.sticky || this.app;
                },
                styles: function() {
                  var m = p({}, a.default.options.computed.styles.call(this));
                  if (this.isSticky) {
                    var v = this.app ? this.$vuetify.application.bar + this.$vuetify.application.top : 0;
                    m.top = Object(h.convertToUnit)(v), m.position = "sticky", m.zIndex = 1;
                  }
                  return m;
                }
              },
              methods: {
                /** @public */
                toggle: function() {
                  this.isActive = !this.isActive;
                },
                iconClick: function(m) {
                  this.$emit("click:icon", m);
                },
                genIcon: function() {
                  if (this.hasIcon) {
                    var m;
                    return this.icon ? m = this.$createElement(l.default, {
                      props: {
                        color: this.iconColor,
                        size: 28
                      }
                    }, [this.icon]) : m = this.$slots.icon, this.$createElement(o.default, {
                      staticClass: "v-banner__icon",
                      props: {
                        color: this.color,
                        size: 40
                      },
                      on: {
                        click: this.iconClick
                      }
                    }, [m]);
                  }
                },
                genText: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__text"
                  }, this.$slots.default);
                },
                genActions: function() {
                  var m = this, v = Object(h.getSlot)(this, "actions", {
                    dismiss: function() {
                      return m.isActive = !1;
                    }
                  });
                  if (v)
                    return this.$createElement("div", {
                      staticClass: "v-banner__actions"
                    }, v);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__content"
                  }, [this.genIcon(), this.genText()]);
                },
                genWrapper: function() {
                  return this.$createElement("div", {
                    staticClass: "v-banner__wrapper"
                  }, [this.genContent(), this.genActions()]);
                }
              },
              render: function(m) {
                var v = {
                  staticClass: "v-banner",
                  attrs: this.attrs$,
                  class: this.classes,
                  style: this.styles,
                  directives: [{
                    name: "show",
                    value: this.isActive
                  }]
                };
                return m(f.VExpandTransition, [m("div", this.outlined ? v : this.setBackgroundColor(this.color, v), [this.genWrapper()])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VBanner/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VBanner/index.ts ***!
            \*****************************************/
          /*! exports provided: VBanner, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBanner */
              "./src/components/VBanner/VBanner.ts"
            );
            i.d(r, "VBanner", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBottomNavigation/VBottomNavigation.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VBottomNavigation/VBottomNavigation.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBottomNavigation/VBottomNavigation.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VBottomNavigation/VBottomNavigation.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBottomNavigation.sass */
              "./src/components/VBottomNavigation/VBottomNavigation.sass"
            );
            var a = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), o = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/scrollable */
              "./src/mixins/scrollable/index.ts"
            ), c = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), h = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = function() {
              return m = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, m.apply(this, arguments);
            };
            r.default = Object(p.default)(
              Object(a.default)("bottom", ["height", "inputValue"]),
              l.default,
              f.default,
              Object(h.factory)("inputValue"),
              d.default,
              u.default,
              c.default
              /* @vue/component */
            ).extend({
              name: "v-bottom-navigation",
              props: {
                activeClass: {
                  type: String,
                  default: "v-btn--active"
                },
                backgroundColor: String,
                grow: Boolean,
                height: {
                  type: [Number, String],
                  default: 56
                },
                hideOnScroll: Boolean,
                horizontal: Boolean,
                inputValue: {
                  type: Boolean,
                  default: !0
                },
                mandatory: Boolean,
                shift: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              data: function() {
                return {
                  isActive: this.inputValue
                };
              },
              computed: {
                canScroll: function() {
                  return u.default.options.computed.canScroll.call(this) && (this.hideOnScroll || !this.inputValue);
                },
                classes: function() {
                  return {
                    "v-bottom-navigation--absolute": this.absolute,
                    "v-bottom-navigation--grow": this.grow,
                    "v-bottom-navigation--fixed": !this.absolute && (this.app || this.fixed),
                    "v-bottom-navigation--horizontal": this.horizontal,
                    "v-bottom-navigation--shift": this.shift
                  };
                },
                styles: function() {
                  return m(m({}, this.measurableStyles), {
                    transform: this.isActive ? "none" : "translateY(100%)"
                  });
                }
              },
              watch: {
                canScroll: "onScroll"
              },
              created: function() {
                this.$attrs.hasOwnProperty("active") && Object(g.breaking)("active.sync", "value or v-model", this);
              },
              methods: {
                thresholdMet: function() {
                  this.hideOnScroll && (this.isActive = !this.isScrollingUp || this.currentScroll > this.computedScrollThreshold, this.$emit("update:input-value", this.isActive)), !(this.currentThreshold < this.computedScrollThreshold) && (this.savedScroll = this.currentScroll);
                },
                updateApplication: function() {
                  return this.$el ? this.$el.clientHeight : 0;
                },
                updateValue: function(y) {
                  this.$emit("change", y);
                }
              },
              render: function(y) {
                var E = this.setBackgroundColor(this.backgroundColor, {
                  staticClass: "v-bottom-navigation",
                  class: this.classes,
                  style: this.styles,
                  props: {
                    activeClass: this.activeClass,
                    mandatory: !!(this.mandatory || this.value !== void 0),
                    tag: this.tag,
                    value: this.internalValue
                  },
                  on: {
                    change: this.updateValue
                  }
                });
                return this.canScroll && (E.directives = E.directives || [], E.directives.push({
                  arg: this.scrollTarget,
                  name: "scroll",
                  value: this.onScroll
                })), y(o.default, this.setTextColor(this.color, E), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VBottomNavigation/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VBottomNavigation/index.ts ***!
            \***************************************************/
          /*! exports provided: VBottomNavigation, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBottomNavigation */
              "./src/components/VBottomNavigation/VBottomNavigation.ts"
            );
            i.d(r, "VBottomNavigation", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBottomSheet/VBottomSheet.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VBottomSheet/VBottomSheet.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBottomSheet/VBottomSheet.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VBottomSheet/VBottomSheet.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBottomSheet.sass */
              "./src/components/VBottomSheet/VBottomSheet.sass"
            );
            var a = i(
              /*! ../VDialog/VDialog */
              "./src/components/VDialog/VDialog.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-bottom-sheet",
              props: {
                inset: Boolean,
                maxWidth: [String, Number],
                transition: {
                  type: String,
                  default: "bottom-sheet-transition"
                }
              },
              computed: {
                classes: function() {
                  return o(o({}, a.default.options.computed.classes.call(this)), {
                    "v-bottom-sheet": !0,
                    "v-bottom-sheet--inset": this.inset
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VBottomSheet/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VBottomSheet/index.ts ***!
            \**********************************************/
          /*! exports provided: VBottomSheet, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBottomSheet */
              "./src/components/VBottomSheet/VBottomSheet.ts"
            );
            i.d(r, "VBottomSheet", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbs.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbs.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbs.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbs.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBreadcrumbs.sass */
              "./src/components/VBreadcrumbs/VBreadcrumbs.sass"
            );
            var a = i(
              /*! ./VBreadcrumbsItem */
              "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts"
            ), o = i(
              /*! ./VBreadcrumbsDivider */
              "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(
              l.default
              /* @vue/component */
            ).extend({
              name: "v-breadcrumbs",
              props: {
                divider: {
                  type: String,
                  default: "/"
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                large: Boolean
              },
              computed: {
                classes: function() {
                  return d({
                    "v-breadcrumbs--large": this.large
                  }, this.themeClasses);
                }
              },
              methods: {
                genDivider: function() {
                  return this.$createElement(o.default, this.$slots.divider ? this.$slots.divider : this.divider);
                },
                genItems: function() {
                  for (var c = [], h = !!this.$scopedSlots.item, p = [], g = 0; g < this.items.length; g++) {
                    var m = this.items[g];
                    p.push(m.text), h ? c.push(this.$scopedSlots.item({
                      item: m
                    })) : c.push(this.$createElement(a.default, {
                      key: p.join("."),
                      props: m
                    }, [m.text])), g < this.items.length - 1 && c.push(this.genDivider());
                  }
                  return c;
                }
              },
              render: function(c) {
                var h = this.$slots.default || this.genItems();
                return c("ul", {
                  staticClass: "v-breadcrumbs",
                  class: this.classes
                }, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(a.createSimpleFunctional)("v-breadcrumbs__divider", "li");
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VBreadcrumbs/VBreadcrumbsItem.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-breadcrumbs-item",
              props: {
                // In a breadcrumb, the currently
                // active item should be dimmed
                activeClass: {
                  type: String,
                  default: "v-breadcrumbs__item--disabled"
                },
                ripple: {
                  type: [Boolean, Object],
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  var d;
                  return d = {
                    "v-breadcrumbs__item": !0
                  }, d[this.activeClass] = this.disabled, d;
                }
              },
              render: function(d) {
                var u = this.generateRouteLink(), c = u.tag, h = u.data;
                return d("li", [d(c, l(l({}, h), {
                  attrs: l(l({}, h.attrs), {
                    "aria-current": this.isActive && this.isLink ? "page" : void 0
                  })
                }), this.$slots.default)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VBreadcrumbs/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VBreadcrumbs/index.ts ***!
            \**********************************************/
          /*! exports provided: VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBreadcrumbs */
              "./src/components/VBreadcrumbs/VBreadcrumbs.ts"
            );
            i.d(r, "VBreadcrumbs", function() {
              return a.default;
            });
            var o = i(
              /*! ./VBreadcrumbsItem */
              "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts"
            );
            i.d(r, "VBreadcrumbsItem", function() {
              return o.default;
            });
            var l = i(
              /*! ./VBreadcrumbsDivider */
              "./src/components/VBreadcrumbs/VBreadcrumbsDivider.ts"
            );
            i.d(r, "VBreadcrumbsDivider", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VBreadcrumbs: a.default,
                VBreadcrumbsItem: o.default,
                VBreadcrumbsDivider: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VBtn/VBtn.sass": (
          /*!***************************************!*\
            !*** ./src/components/VBtn/VBtn.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBtn/VBtn.ts": (
          /*!*************************************!*\
            !*** ./src/components/VBtn/VBtn.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBtn.sass */
              "./src/components/VBtn/VBtn.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../VProgressCircular */
              "./src/components/VProgressCircular/index.ts"
            ), l = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), u = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), c = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), h = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function m(C) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? m = function(b) {
                return typeof b;
              } : m = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
              }, m(C);
            }
            var v = function() {
              return v = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var O in x)
                    Object.prototype.hasOwnProperty.call(x, O) && (C[O] = x[O]);
                }
                return C;
              }, v.apply(this, arguments);
            }, y = function(C, x) {
              var b = typeof Symbol == "function" && C[Symbol.iterator];
              if (!b)
                return C;
              var P = b.call(C), O, T = [], M;
              try {
                for (; (x === void 0 || x-- > 0) && !(O = P.next()).done; )
                  T.push(O.value);
              } catch (L) {
                M = {
                  error: L
                };
              } finally {
                try {
                  O && !O.done && (b = P.return) && b.call(P);
                } finally {
                  if (M)
                    throw M.error;
                }
              }
              return T;
            }, E = Object(p.default)(
              a.default,
              c.default,
              u.default,
              h.default,
              Object(l.factory)("btnToggle"),
              Object(f.factory)("inputValue")
              /* @vue/component */
            );
            r.default = E.extend().extend({
              name: "v-btn",
              props: {
                activeClass: {
                  type: String,
                  default: function() {
                    return this.btnToggle ? this.btnToggle.activeClass : "";
                  }
                },
                block: Boolean,
                depressed: Boolean,
                fab: Boolean,
                icon: Boolean,
                loading: Boolean,
                outlined: Boolean,
                plain: Boolean,
                retainFocusOnClick: Boolean,
                rounded: Boolean,
                tag: {
                  type: String,
                  default: "button"
                },
                text: Boolean,
                tile: Boolean,
                type: {
                  type: String,
                  default: "button"
                },
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-btn--active"
                };
              },
              computed: {
                classes: function() {
                  return v(v(v(v(v(v({
                    "v-btn": !0
                  }, c.default.options.computed.classes.call(this)), {
                    "v-btn--absolute": this.absolute,
                    "v-btn--block": this.block,
                    "v-btn--bottom": this.bottom,
                    "v-btn--disabled": this.disabled,
                    "v-btn--is-elevated": this.isElevated,
                    "v-btn--fab": this.fab,
                    "v-btn--fixed": this.fixed,
                    "v-btn--has-bg": this.hasBg,
                    "v-btn--icon": this.icon,
                    "v-btn--left": this.left,
                    "v-btn--loading": this.loading,
                    "v-btn--outlined": this.outlined,
                    "v-btn--plain": this.plain,
                    "v-btn--right": this.right,
                    "v-btn--round": this.isRound,
                    "v-btn--rounded": this.rounded,
                    "v-btn--router": this.to,
                    "v-btn--text": this.text,
                    "v-btn--tile": this.tile,
                    "v-btn--top": this.top
                  }), this.themeClasses), this.groupClasses), this.elevationClasses), this.sizeableClasses);
                },
                computedElevation: function() {
                  if (!this.disabled)
                    return d.default.options.computed.computedElevation.call(this);
                },
                computedRipple: function() {
                  var x, b = this.icon || this.fab ? {
                    circle: !0
                  } : !0;
                  return this.disabled ? !1 : (x = this.ripple) !== null && x !== void 0 ? x : b;
                },
                hasBg: function() {
                  return !this.text && !this.plain && !this.outlined && !this.icon;
                },
                isElevated: function() {
                  return !this.icon && !this.text && !this.outlined && !this.depressed && !this.disabled && !this.plain && (this.elevation == null || Number(this.elevation) > 0);
                },
                isRound: function() {
                  return !!(this.icon || this.fab);
                },
                styles: function() {
                  return v({}, this.measurableStyles);
                }
              },
              created: function() {
                var x = this, b = [["flat", "text"], ["outline", "outlined"], ["round", "rounded"]];
                b.forEach(function(P) {
                  var O = y(P, 2), T = O[0], M = O[1];
                  x.$attrs.hasOwnProperty(T) && Object(g.breaking)(T, M, x);
                });
              },
              methods: {
                click: function(x) {
                  !this.retainFocusOnClick && !this.fab && x.detail && this.$el.blur(), this.$emit("click", x), this.btnToggle && this.toggle();
                },
                genContent: function() {
                  return this.$createElement("span", {
                    staticClass: "v-btn__content"
                  }, this.$slots.default);
                },
                genLoader: function() {
                  return this.$createElement("span", {
                    class: "v-btn__loader"
                  }, this.$slots.loader || [this.$createElement(o.default, {
                    props: {
                      indeterminate: !0,
                      size: 23,
                      width: 2
                    }
                  })]);
                }
              },
              render: function(x) {
                var b = [this.genContent(), this.loading && this.genLoader()], P = this.generateRouteLink(), O = P.tag, T = P.data, M = this.hasBg ? this.setBackgroundColor : this.setTextColor;
                return O === "button" && (T.attrs.type = this.type, T.attrs.disabled = this.disabled), T.attrs.value = ["string", "number"].includes(m(this.value)) ? this.value : JSON.stringify(this.value), x(O, this.disabled ? T : M(this.color, T), b);
              }
            });
          }
        ),
        /***/
        "./src/components/VBtn/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VBtn/index.ts ***!
            \**************************************/
          /*! exports provided: VBtn, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBtn */
              "./src/components/VBtn/VBtn.ts"
            );
            i.d(r, "VBtn", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VBtnToggle/VBtnToggle.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VBtnToggle/VBtnToggle.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VBtnToggle/VBtnToggle.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VBtnToggle/VBtnToggle.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VBtnToggle.sass */
              "./src/components/VBtnToggle/VBtnToggle.sass"
            );
            var a = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.default, o.default).extend({
              name: "v-btn-toggle",
              props: {
                backgroundColor: String,
                borderless: Boolean,
                dense: Boolean,
                group: Boolean,
                rounded: Boolean,
                shaped: Boolean,
                tile: Boolean
              },
              computed: {
                classes: function() {
                  return f(f(f({}, a.default.options.computed.classes.call(this)), {
                    "v-btn-toggle": !0,
                    "v-btn-toggle--borderless": this.borderless,
                    "v-btn-toggle--dense": this.dense,
                    "v-btn-toggle--group": this.group,
                    "v-btn-toggle--rounded": this.rounded,
                    "v-btn-toggle--shaped": this.shaped,
                    "v-btn-toggle--tile": this.tile
                  }), this.themeClasses);
                }
              },
              methods: {
                genData: function() {
                  var u = this.setTextColor(this.color, f({}, a.default.options.methods.genData.call(this)));
                  return this.group ? u : this.setBackgroundColor(this.backgroundColor, u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VBtnToggle/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VBtnToggle/index.ts ***!
            \********************************************/
          /*! exports provided: VBtnToggle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VBtnToggle */
              "./src/components/VBtnToggle/VBtnToggle.ts"
            );
            i.d(r, "VBtnToggle", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendar.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCalendar/VCalendar.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/calendar-with-events */
              "./src/components/VCalendar/mixins/calendar-with-events.ts"
            ), o = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), l = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), f = i(
              /*! ./VCalendarMonthly */
              "./src/components/VCalendar/VCalendarMonthly.ts"
            ), d = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            ), u = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            ), c = i(
              /*! ./VCalendarCategory */
              "./src/components/VCalendar/VCalendarCategory.ts"
            ), h = i(
              /*! ./util/parser */
              "./src/components/VCalendar/util/parser.ts"
            );
            function p(m) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? p = function(y) {
                return typeof y;
              } : p = function(y) {
                return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
              }, p(m);
            }
            var g = function() {
              return g = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, g.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-calendar",
              props: g(g(g(g({}, o.default.calendar), o.default.weeks), o.default.intervals), o.default.category),
              data: function() {
                return {
                  lastStart: null,
                  lastEnd: null
                };
              },
              computed: {
                parsedValue: function() {
                  return Object(l.validateTimestamp)(this.value) ? Object(l.parseTimestamp)(this.value, !0) : this.parsedStart || this.times.today;
                },
                parsedCategoryDays: function() {
                  return parseInt(this.categoryDays) || 1;
                },
                renderProps: function() {
                  var v = this.parsedValue, y = null, E = this.maxDays, C = this.parsedWeekdays, x = this.parsedCategories, b = v, P = v;
                  switch (this.type) {
                    case "month":
                      y = f.default, b = Object(l.getStartOfMonth)(v), P = Object(l.getEndOfMonth)(v);
                      break;
                    case "week":
                      y = d.default, b = this.getStartOfWeek(v), P = this.getEndOfWeek(v), E = 7;
                      break;
                    case "day":
                      y = d.default, E = 1, C = [b.weekday];
                      break;
                    case "4day":
                      y = d.default, P = Object(l.relativeDays)(Object(l.copyTimestamp)(P), l.nextDay, 3), Object(l.updateFormatted)(P), E = 4, C = [b.weekday, (b.weekday + 1) % 7, (b.weekday + 2) % 7, (b.weekday + 3) % 7];
                      break;
                    case "custom-weekly":
                      y = u.default, b = this.parsedStart || v, P = this.parsedEnd;
                      break;
                    case "custom-daily":
                      y = d.default, b = this.parsedStart || v, P = this.parsedEnd;
                      break;
                    case "category":
                      var O = this.parsedCategoryDays;
                      y = c.default, P = Object(l.relativeDays)(Object(l.copyTimestamp)(P), l.nextDay, O), Object(l.updateFormatted)(P), E = O, C = [];
                      for (var T = 0; T < O; T++)
                        C.push((b.weekday + T) % 7);
                      x = this.getCategoryList(x);
                      break;
                    default:
                      throw new Error(this.type + " is not a valid Calendar type");
                  }
                  return {
                    component: y,
                    start: b,
                    end: P,
                    maxDays: E,
                    weekdays: C,
                    categories: x
                  };
                },
                eventWeekdays: function() {
                  return this.renderProps.weekdays;
                },
                categoryMode: function() {
                  return this.type === "category";
                },
                title: function() {
                  var v = this.renderProps, y = v.start, E = v.end, C = y.year !== E.year, x = C || y.month !== E.month;
                  return C ? this.monthShortFormatter(y, !0) + " " + y.year + " - " + this.monthShortFormatter(E, !0) + " " + E.year : x ? this.monthShortFormatter(y, !0) + " - " + this.monthShortFormatter(E, !0) + " " + E.year : this.monthLongFormatter(y, !1) + " " + y.year;
                },
                monthLongFormatter: function() {
                  return this.getFormatter({
                    timeZone: "UTC",
                    month: "long"
                  });
                },
                monthShortFormatter: function() {
                  return this.getFormatter({
                    timeZone: "UTC",
                    month: "short"
                  });
                },
                parsedCategories: function() {
                  return Object(h.getParsedCategories)(this.categories, this.categoryText);
                }
              },
              watch: {
                renderProps: "checkChange"
              },
              mounted: function() {
                this.updateEventVisibility(), this.checkChange();
              },
              updated: function() {
                window.requestAnimationFrame(this.updateEventVisibility);
              },
              methods: {
                checkChange: function() {
                  var v = this, y = v.lastStart, E = v.lastEnd, C = this.renderProps, x = C.start, b = C.end;
                  (!y || !E || x.date !== y.date || b.date !== E.date) && (this.lastStart = x, this.lastEnd = b, this.$emit("change", {
                    start: x,
                    end: b
                  }));
                },
                move: function(v) {
                  v === void 0 && (v = 1);
                  for (var y = Object(l.copyTimestamp)(this.parsedValue), E = v > 0, C = E ? l.nextDay : l.prevDay, x = E ? l.DAYS_IN_MONTH_MAX : l.DAY_MIN, b = E ? v : -v; --b >= 0; )
                    switch (this.type) {
                      case "month":
                        y.day = x, C(y);
                        break;
                      case "week":
                        Object(l.relativeDays)(y, C, l.DAYS_IN_WEEK);
                        break;
                      case "day":
                        Object(l.relativeDays)(y, C, 1);
                        break;
                      case "4day":
                        Object(l.relativeDays)(y, C, 4);
                        break;
                      case "category":
                        Object(l.relativeDays)(y, C, this.parsedCategoryDays);
                        break;
                    }
                  Object(l.updateWeekday)(y), Object(l.updateFormatted)(y), Object(l.updateRelative)(y, this.times.now), this.value instanceof Date ? this.$emit("input", Object(l.timestampToDate)(y)) : typeof this.value == "number" ? this.$emit("input", Object(l.timestampToDate)(y).getTime()) : this.$emit("input", y.date), this.$emit("moved", y);
                },
                next: function(v) {
                  v === void 0 && (v = 1), this.move(v);
                },
                prev: function(v) {
                  v === void 0 && (v = 1), this.move(-v);
                },
                timeToY: function(v, y) {
                  y === void 0 && (y = !0);
                  var E = this.$children[0];
                  return E && E.timeToY ? E.timeToY(v, y) : !1;
                },
                timeDelta: function(v) {
                  var y = this.$children[0];
                  return y && y.timeDelta ? y.timeDelta(v) : !1;
                },
                minutesToPixels: function(v) {
                  var y = this.$children[0];
                  return y && y.minutesToPixels ? y.minutesToPixels(v) : -1;
                },
                scrollToTime: function(v) {
                  var y = this.$children[0];
                  return y && y.scrollToTime ? y.scrollToTime(v) : !1;
                },
                parseTimestamp: function(v, y) {
                  return Object(l.parseTimestamp)(v, y, this.times.now);
                },
                timestampToDate: function(v) {
                  return Object(l.timestampToDate)(v);
                },
                getCategoryList: function(v) {
                  var y = this;
                  if (!this.noEvents) {
                    var E = v.reduce(function(b, P, O) {
                      return p(P) === "object" && P.categoryName ? b[P.categoryName] = {
                        index: O,
                        count: 0
                      } : typeof P == "string" && (b[P] = {
                        index: O,
                        count: 0
                      }), b;
                    }, {});
                    if (!this.categoryHideDynamic || !this.categoryShowAll) {
                      var C = v.length;
                      this.parsedEvents.forEach(function(b) {
                        var P = b.category;
                        typeof P != "string" && (P = y.categoryForInvalid), P && (P in E ? E[P].count++ : y.categoryHideDynamic || (E[P] = {
                          index: C++,
                          count: 1
                        }));
                      });
                    }
                    if (!this.categoryShowAll)
                      for (var x in E)
                        E[x].count === 0 && delete E[x];
                    v = v.filter(function(b) {
                      return p(b) === "object" && b.categoryName ? E.hasOwnProperty(b.categoryName) : typeof b == "string" ? E.hasOwnProperty(b) : !1;
                    });
                  }
                  return v;
                }
              },
              render: function(v) {
                var y = this, E = this.renderProps, C = E.start, x = E.end, b = E.maxDays, P = E.component, O = E.weekdays, T = E.categories;
                return v(P, {
                  staticClass: "v-calendar",
                  class: {
                    "v-calendar-events": !this.noEvents
                  },
                  props: g(g({}, this.$props), {
                    start: C.date,
                    end: x.date,
                    maxDays: b,
                    weekdays: O,
                    categories: T
                  }),
                  attrs: {
                    role: "grid"
                  },
                  directives: [{
                    modifiers: {
                      quiet: !0
                    },
                    name: "resize",
                    value: this.updateEventVisibility
                  }],
                  on: g(g({}, this.$listeners), {
                    "click:date": function(L, A) {
                      y.$listeners.input && y.$emit("input", L.date), y.$listeners["click:date"] && y.$emit("click:date", L, A);
                    }
                  }),
                  scopedSlots: this.getScopedSlots()
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarCategory.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VCalendar/VCalendarCategory.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarCategory.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarCategory.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarCategory.sass */
              "./src/components/VCalendar/VCalendarCategory.sass"
            );
            var a = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), f = i(
              /*! ./util/parser */
              "./src/components/VCalendar/util/parser.ts"
            );
            function d(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(m) {
                return typeof m;
              } : d = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, d(p);
            }
            var u = function() {
              return u = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, u.apply(this, arguments);
            }, c = function(p, g) {
              var m = typeof Symbol == "function" && p[Symbol.iterator];
              if (!m)
                return p;
              var v = m.call(p), y, E = [], C;
              try {
                for (; (g === void 0 || g-- > 0) && !(y = v.next()).done; )
                  E.push(y.value);
              } catch (x) {
                C = {
                  error: x
                };
              } finally {
                try {
                  y && !y.done && (m = v.return) && m.call(v);
                } finally {
                  if (C)
                    throw C.error;
                }
              }
              return E;
            }, h = function(p, g, m) {
              if (m || arguments.length === 2)
                for (var v = 0, y = g.length, E; v < y; v++)
                  (E || !(v in g)) && (E || (E = Array.prototype.slice.call(g, 0, v)), E[v] = g[v]);
              return p.concat(E || Array.prototype.slice.call(g));
            };
            r.default = a.default.extend({
              name: "v-calendar-category",
              props: l.default.category,
              computed: {
                classes: function() {
                  return u({
                    "v-calendar-daily": !0,
                    "v-calendar-category": !0
                  }, this.themeClasses);
                },
                parsedCategories: function() {
                  return Object(f.getParsedCategories)(this.categories, this.categoryText);
                }
              },
              methods: {
                genDayHeader: function(g, m) {
                  var v = this, y = {
                    staticClass: "v-calendar-category__columns"
                  }, E = u(u({
                    week: this.days
                  }, g), {
                    index: m
                  }), C = this.parsedCategories.map(function(x) {
                    return v.genDayHeaderCategory(g, v.getCategoryScope(E, x));
                  });
                  return [this.$createElement("div", y, C)];
                },
                getCategoryScope: function(g, m) {
                  var v = d(m) === "object" && m && m.categoryName === this.categoryForInvalid ? null : m;
                  return u(u({}, g), {
                    category: v
                  });
                },
                genDayHeaderCategory: function(g, m) {
                  var v = this, y = d(m.category) === "object" ? m.category.categoryName : m.category;
                  return this.$createElement("div", {
                    staticClass: "v-calendar-category__column-header",
                    on: this.getDefaultMouseEventHandlers(":day-category", function(E) {
                      return v.getCategoryScope(v.getSlotScope(g), m.category);
                    })
                  }, [Object(o.getSlot)(this, "category", m) || this.genDayHeaderCategoryTitle(y), Object(o.getSlot)(this, "day-header", m)]);
                },
                genDayHeaderCategoryTitle: function(g) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-category__category"
                  }, g === null ? this.categoryForInvalid : g);
                },
                genDays: function() {
                  var g = this, m = [];
                  return this.days.forEach(function(v, y) {
                    var E = new Array(g.parsedCategories.length || 1);
                    E.fill(v), m.push.apply(m, h([], c(E.map(function(C, x) {
                      return g.genDay(C, y, x);
                    })), !1));
                  }), m;
                },
                genDay: function(g, m, v) {
                  var y = this, E = this.parsedCategories[v];
                  return this.$createElement("div", {
                    key: g.date + "-" + v,
                    staticClass: "v-calendar-daily__day",
                    class: this.getRelativeClasses(g),
                    on: this.getDefaultMouseEventHandlers(":time", function(C) {
                      return y.getSlotScope(y.getTimestampAtEvent(C, g));
                    })
                  }, h(h([], c(this.genDayIntervals(m, E)), !1), c(this.genDayBody(g, E)), !1));
                },
                genDayIntervals: function(g, m) {
                  var v = this;
                  return this.intervals[g].map(function(y) {
                    return v.genDayInterval(y, m);
                  });
                },
                genDayInterval: function(g, m) {
                  var v = this, y = Object(o.convertToUnit)(this.intervalHeight), E = this.intervalStyle || this.intervalStyleDefault, C = {
                    key: g.time,
                    staticClass: "v-calendar-daily__day-interval",
                    style: u({
                      height: y
                    }, E(u(u({}, g), {
                      category: m
                    })))
                  }, x = Object(o.getSlot)(this, "interval", function() {
                    return v.getCategoryScope(v.getSlotScope(g), m);
                  });
                  return this.$createElement("div", C, x);
                },
                genDayBody: function(g, m) {
                  var v = {
                    staticClass: "v-calendar-category__columns"
                  }, y = [this.genDayBodyCategory(g, m)];
                  return [this.$createElement("div", v, y)];
                },
                genDayBodyCategory: function(g, m) {
                  var v = this, y = {
                    staticClass: "v-calendar-category__column",
                    on: this.getDefaultMouseEventHandlers(":time-category", function(C) {
                      return v.getCategoryScope(v.getSlotScope(v.getTimestampAtEvent(C, g)), m);
                    })
                  }, E = Object(o.getSlot)(this, "day-body", function() {
                    return v.getCategoryScope(v.getSlotScope(g), m);
                  });
                  return this.$createElement("div", y, E);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarDaily.sass": (
          /*!******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarDaily.sass ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarDaily.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VCalendar/VCalendarDaily.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarDaily.sass */
              "./src/components/VCalendar/VCalendarDaily.sass"
            );
            var a = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ./mixins/calendar-with-intervals */
              "./src/components/VCalendar/mixins/calendar-with-intervals.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, d.apply(this, arguments);
            }, u = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            }, c = function(h, p, g) {
              if (g || arguments.length === 2)
                for (var m = 0, v = p.length, y; m < v; m++)
                  (y || !(m in p)) && (y || (y = Array.prototype.slice.call(p, 0, m)), y[m] = p[m]);
              return h.concat(y || Array.prototype.slice.call(p));
            };
            r.default = l.default.extend({
              name: "v-calendar-daily",
              directives: {
                Resize: a.default
              },
              data: function() {
                return {
                  scrollPush: 0
                };
              },
              computed: {
                classes: function() {
                  return d({
                    "v-calendar-daily": !0
                  }, this.themeClasses);
                }
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function() {
                  this.$nextTick(this.onResize);
                },
                onResize: function() {
                  this.scrollPush = this.getScrollPush();
                },
                getScrollPush: function() {
                  var p = this.$refs.scrollArea, g = this.$refs.pane;
                  return p && g ? p.offsetWidth - g.offsetWidth : 0;
                },
                genHead: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__head",
                    style: {
                      marginRight: this.scrollPush + "px"
                    }
                  }, c([this.genHeadIntervals()], u(this.genHeadDays()), !1));
                },
                genHeadIntervals: function() {
                  var p = Object(f.convertToUnit)(this.intervalWidth);
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__intervals-head",
                    style: {
                      width: p
                    }
                  }, Object(f.getSlot)(this, "interval-header"));
                },
                genHeadDays: function() {
                  return this.days.map(this.genHeadDay);
                },
                genHeadDay: function(p, g) {
                  var m = this;
                  return this.$createElement("div", {
                    key: p.date,
                    staticClass: "v-calendar-daily_head-day",
                    class: this.getRelativeClasses(p),
                    on: this.getDefaultMouseEventHandlers(":day", function(v) {
                      return d({
                        nativeEvent: v
                      }, m.getSlotScope(p));
                    })
                  }, c([this.genHeadWeekday(p), this.genHeadDayLabel(p)], u(this.genDayHeader(p, g)), !1));
                },
                genDayHeader: function(p, g) {
                  var m = this;
                  return Object(f.getSlot)(this, "day-header", function() {
                    return d(d({
                      week: m.days
                    }, p), {
                      index: g
                    });
                  }) || [];
                },
                genHeadWeekday: function(p) {
                  var g = p.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(g, {
                    staticClass: "v-calendar-daily_head-weekday"
                  }), this.weekdayFormatter(p, this.shortWeekdays));
                },
                genHeadDayLabel: function(p) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily_head-day-label"
                  }, Object(f.getSlot)(this, "day-label-header", p) || [this.genHeadDayButton(p)]);
                },
                genHeadDayButton: function(p) {
                  var g = p.present ? this.color : "transparent";
                  return this.$createElement(o.default, {
                    props: {
                      color: g,
                      fab: !0,
                      depressed: !0
                    },
                    on: this.getMouseEventHandlers({
                      "click:date": {
                        event: "click",
                        stop: !0
                      },
                      "contextmenu:date": {
                        event: "contextmenu",
                        stop: !0,
                        prevent: !0,
                        result: !1
                      }
                    }, function(m) {
                      return d({
                        nativeEvent: m
                      }, p);
                    })
                  }, this.dayFormatter(p, !1));
                },
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__body"
                  }, [this.genScrollArea()]);
                },
                genScrollArea: function() {
                  return this.$createElement("div", {
                    ref: "scrollArea",
                    staticClass: "v-calendar-daily__scroll-area"
                  }, [this.genPane()]);
                },
                genPane: function() {
                  return this.$createElement("div", {
                    ref: "pane",
                    staticClass: "v-calendar-daily__pane",
                    style: {
                      height: Object(f.convertToUnit)(this.bodyHeight)
                    }
                  }, [this.genDayContainer()]);
                },
                genDayContainer: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-daily__day-container"
                  }, c([this.genBodyIntervals()], u(this.genDays()), !1));
                },
                genDays: function() {
                  return this.days.map(this.genDay);
                },
                genDay: function(p, g) {
                  var m = this;
                  return this.$createElement("div", {
                    key: p.date,
                    staticClass: "v-calendar-daily__day",
                    class: this.getRelativeClasses(p),
                    on: this.getDefaultMouseEventHandlers(":time", function(v) {
                      return d({
                        nativeEvent: v
                      }, m.getSlotScope(m.getTimestampAtEvent(v, p)));
                    })
                  }, c(c([], u(this.genDayIntervals(g)), !1), u(this.genDayBody(p)), !1));
                },
                genDayBody: function(p) {
                  var g = this;
                  return Object(f.getSlot)(this, "day-body", function() {
                    return g.getSlotScope(p);
                  }) || [];
                },
                genDayIntervals: function(p) {
                  return this.intervals[p].map(this.genDayInterval);
                },
                genDayInterval: function(p) {
                  var g = this, m = Object(f.convertToUnit)(this.intervalHeight), v = this.intervalStyle || this.intervalStyleDefault, y = {
                    key: p.time,
                    staticClass: "v-calendar-daily__day-interval",
                    style: d({
                      height: m
                    }, v(p))
                  }, E = Object(f.getSlot)(this, "interval", function() {
                    return g.getSlotScope(p);
                  });
                  return this.$createElement("div", y, E);
                },
                genBodyIntervals: function() {
                  var p = this, g = Object(f.convertToUnit)(this.intervalWidth), m = {
                    staticClass: "v-calendar-daily__intervals-body",
                    style: {
                      width: g
                    },
                    on: this.getDefaultMouseEventHandlers(":interval", function(v) {
                      return d({
                        nativeEvent: v
                      }, p.getTimestampAtEvent(v, p.parsedStart));
                    })
                  };
                  return this.$createElement("div", m, this.genIntervalLabels());
                },
                genIntervalLabels: function() {
                  return this.intervals.length ? this.intervals[0].map(this.genIntervalLabel) : null;
                },
                genIntervalLabel: function(p) {
                  var g = Object(f.convertToUnit)(this.intervalHeight), m = this.shortIntervals, v = this.showIntervalLabel || this.showIntervalLabelDefault, y = v(p), E = y ? this.intervalFormatter(p, m) : void 0;
                  return this.$createElement("div", {
                    key: p.time,
                    staticClass: "v-calendar-daily__interval",
                    style: {
                      height: g
                    }
                  }, [this.$createElement("div", {
                    staticClass: "v-calendar-daily__interval-text"
                  }, E)]);
                }
              },
              render: function(p) {
                return p("div", {
                  class: this.classes,
                  on: {
                    dragstart: function(m) {
                      m.preventDefault();
                    }
                  },
                  directives: [{
                    modifiers: {
                      quiet: !0
                    },
                    name: "resize",
                    value: this.onResize
                  }]
                }, [this.hideHeader ? "" : this.genHead(), this.genBody()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarMonthly.ts": (
          /*!******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarMonthly.ts ***!
            \******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarWeekly.sass */
              "./src/components/VCalendar/VCalendarWeekly.sass"
            );
            var a = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            ), o = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = a.default.extend({
              name: "v-calendar-monthly",
              computed: {
                staticClass: function() {
                  return "v-calendar-monthly v-calendar-weekly";
                },
                parsedStart: function() {
                  return Object(o.getStartOfMonth)(Object(o.parseTimestamp)(this.start, !0));
                },
                parsedEnd: function() {
                  return Object(o.getEndOfMonth)(Object(o.parseTimestamp)(this.end, !0));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarWeekly.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VCalendar/VCalendarWeekly.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/VCalendarWeekly.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VCalendar/VCalendarWeekly.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCalendarWeekly.sass */
              "./src/components/VCalendar/VCalendarWeekly.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ./mixins/calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            ), d = i(
              /*! ./util/props */
              "./src/components/VCalendar/util/props.ts"
            ), u = i(
              /*! ./util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = o.default.extend({
              name: "v-calendar-weekly",
              props: d.default.weeks,
              computed: {
                staticClass: function() {
                  return "v-calendar-weekly";
                },
                classes: function() {
                  return this.themeClasses;
                },
                parsedMinWeeks: function() {
                  return parseInt(this.minWeeks);
                },
                days: function() {
                  var m = this.parsedMinWeeks * this.parsedWeekdays.length, v = this.getStartOfWeek(this.parsedStart), y = this.getEndOfWeek(this.parsedEnd);
                  return Object(u.createDayList)(v, y, this.times.today, this.weekdaySkips, Number.MAX_SAFE_INTEGER, m);
                },
                todayWeek: function() {
                  var m = this.times.today, v = this.getStartOfWeek(m), y = this.getEndOfWeek(m);
                  return Object(u.createDayList)(v, y, m, this.weekdaySkips, this.parsedWeekdays.length, this.parsedWeekdays.length);
                },
                monthFormatter: function() {
                  if (this.monthFormat)
                    return this.monthFormat;
                  var m = {
                    timeZone: "UTC",
                    month: "long"
                  }, v = {
                    timeZone: "UTC",
                    month: "short"
                  };
                  return Object(u.createNativeLocaleFormatter)(this.currentLocale, function(y, E) {
                    return E ? v : m;
                  });
                }
              },
              methods: {
                isOutside: function(m) {
                  var v = Object(u.getDayIdentifier)(m);
                  return v < Object(u.getDayIdentifier)(this.parsedStart) || v > Object(u.getDayIdentifier)(this.parsedEnd);
                },
                genHead: function() {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__head",
                    attrs: {
                      role: "row"
                    }
                  }, this.genHeadDays());
                },
                genHeadDays: function() {
                  var m = this.todayWeek.map(this.genHeadDay);
                  return this.showWeek && m.unshift(this.$createElement("div", {
                    staticClass: "v-calendar-weekly__head-weeknumber"
                  })), m;
                },
                genHeadDay: function(m, v) {
                  var y = this.isOutside(this.days[v]), E = m.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(E, {
                    key: m.date,
                    staticClass: "v-calendar-weekly__head-weekday",
                    class: this.getRelativeClasses(m, y),
                    attrs: {
                      role: "columnheader"
                    }
                  }), this.weekdayFormatter(m, this.shortWeekdays));
                },
                genWeeks: function() {
                  for (var m = this.days, v = this.parsedWeekdays.length, y = [], E = 0; E < m.length; E += v)
                    y.push(this.genWeek(m.slice(E, E + v), this.getWeekNumber(m[E])));
                  return y;
                },
                genWeek: function(m, v) {
                  var y = this, E = m.map(function(C, x) {
                    return y.genDay(C, x, m);
                  });
                  return this.showWeek && E.unshift(this.genWeekNumber(v)), this.$createElement("div", {
                    key: m[0].date,
                    staticClass: "v-calendar-weekly__week",
                    attrs: {
                      role: "row"
                    }
                  }, E);
                },
                getWeekNumber: function(m) {
                  return Object(f.weekNumber)(m.year, m.month - 1, m.day, this.parsedWeekdays[0], parseInt(this.localeFirstDayOfYear));
                },
                genWeekNumber: function(m) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__weeknumber"
                  }, [this.$createElement("small", String(m))]);
                },
                genDay: function(m, v, y) {
                  var E = this.isOutside(m);
                  return this.$createElement("div", {
                    key: m.date,
                    staticClass: "v-calendar-weekly__day",
                    class: this.getRelativeClasses(m, E),
                    attrs: {
                      role: "cell"
                    },
                    on: this.getDefaultMouseEventHandlers(":day", function(C) {
                      return c({
                        nativeEvent: C
                      }, m);
                    })
                  }, p([this.genDayLabel(m)], h(Object(l.getSlot)(this, "day", function() {
                    return c({
                      outside: E,
                      index: v,
                      week: y
                    }, m);
                  }) || []), !1));
                },
                genDayLabel: function(m) {
                  return this.$createElement("div", {
                    staticClass: "v-calendar-weekly__day-label"
                  }, Object(l.getSlot)(this, "day-label", m) || [this.genDayLabelButton(m)]);
                },
                genDayLabelButton: function(m) {
                  var v = m.present ? this.color : "transparent", y = m.day === 1 && this.showMonthOnFirst;
                  return this.$createElement(a.default, {
                    props: {
                      color: v,
                      fab: !0,
                      depressed: !0,
                      small: !0
                    },
                    on: this.getMouseEventHandlers({
                      "click:date": {
                        event: "click",
                        stop: !0
                      },
                      "contextmenu:date": {
                        event: "contextmenu",
                        stop: !0,
                        prevent: !0,
                        result: !1
                      }
                    }, function(E) {
                      return c({
                        nativeEvent: E
                      }, m);
                    })
                  }, y ? this.monthFormatter(m, this.shortMonths) + " " + this.dayFormatter(m, !1) : this.dayFormatter(m, !1));
                },
                genDayMonth: function(m) {
                  var v = m.present ? this.color : void 0;
                  return this.$createElement("div", this.setTextColor(v, {
                    staticClass: "v-calendar-weekly__day-month"
                  }), Object(l.getSlot)(this, "day-month", m) || this.monthFormatter(m, this.shortMonths));
                }
              },
              render: function(m) {
                return m("div", {
                  staticClass: this.staticClass,
                  class: this.classes,
                  on: {
                    dragstart: function(y) {
                      y.preventDefault();
                    }
                  }
                }, p([this.hideHeader ? "" : this.genHead()], h(this.genWeeks()), !1));
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCalendar/index.ts ***!
            \*******************************************/
          /*! exports provided: VCalendar, VCalendarCategory, VCalendarDaily, VCalendarWeekly, VCalendarMonthly, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCalendar */
              "./src/components/VCalendar/VCalendar.ts"
            );
            i.d(r, "VCalendar", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCalendarDaily */
              "./src/components/VCalendar/VCalendarDaily.ts"
            );
            i.d(r, "VCalendarDaily", function() {
              return o.default;
            });
            var l = i(
              /*! ./VCalendarWeekly */
              "./src/components/VCalendar/VCalendarWeekly.ts"
            );
            i.d(r, "VCalendarWeekly", function() {
              return l.default;
            });
            var f = i(
              /*! ./VCalendarMonthly */
              "./src/components/VCalendar/VCalendarMonthly.ts"
            );
            i.d(r, "VCalendarMonthly", function() {
              return f.default;
            });
            var d = i(
              /*! ./VCalendarCategory */
              "./src/components/VCalendar/VCalendarCategory.ts"
            );
            i.d(r, "VCalendarCategory", function() {
              return d.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCalendar: a.default,
                VCalendarCategory: d.default,
                VCalendarDaily: o.default,
                VCalendarWeekly: l.default,
                VCalendarMonthly: f.default
              }
            };
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-base.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-base.ts ***!
            \**********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), f = i(
              /*! ../../../mixins/mouse */
              "./src/mixins/mouse/index.ts"
            ), d = i(
              /*! ../../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ./times */
              "./src/components/VCalendar/mixins/times.ts"
            ), c = i(
              /*! ../../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), p = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = Object(a.default)(
              o.default,
              l.default,
              f.default,
              d.default,
              u.default
              /* @vue/component */
            ).extend({
              name: "calendar-base",
              directives: {
                Resize: c.default
              },
              props: h.default.base,
              computed: {
                parsedWeekdays: function() {
                  return Array.isArray(this.weekdays) ? this.weekdays : (this.weekdays || "").split(",").map(function(m) {
                    return parseInt(m, 10);
                  });
                },
                weekdaySkips: function() {
                  return Object(p.getWeekdaySkips)(this.parsedWeekdays);
                },
                weekdaySkipsReverse: function() {
                  var m = this.weekdaySkips.slice();
                  return m.reverse(), m;
                },
                parsedStart: function() {
                  return Object(p.parseTimestamp)(this.start, !0);
                },
                parsedEnd: function() {
                  var m = this.parsedStart, v = this.end && Object(p.parseTimestamp)(this.end) || m;
                  return Object(p.getTimestampIdentifier)(v) < Object(p.getTimestampIdentifier)(m) ? m : v;
                },
                days: function() {
                  return Object(p.createDayList)(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips);
                },
                dayFormatter: function() {
                  if (this.dayFormat)
                    return this.dayFormat;
                  var m = {
                    timeZone: "UTC",
                    day: "numeric"
                  };
                  return Object(p.createNativeLocaleFormatter)(this.currentLocale, function(v, y) {
                    return m;
                  });
                },
                weekdayFormatter: function() {
                  if (this.weekdayFormat)
                    return this.weekdayFormat;
                  var m = {
                    timeZone: "UTC",
                    weekday: "long"
                  }, v = {
                    timeZone: "UTC",
                    weekday: "short"
                  };
                  return Object(p.createNativeLocaleFormatter)(this.currentLocale, function(y, E) {
                    return E ? v : m;
                  });
                }
              },
              methods: {
                getRelativeClasses: function(m, v) {
                  return v === void 0 && (v = !1), {
                    "v-present": m.present,
                    "v-past": m.past,
                    "v-future": m.future,
                    "v-outside": v
                  };
                },
                getStartOfWeek: function(m) {
                  return Object(p.getStartOfWeek)(m, this.parsedWeekdays, this.times.today);
                },
                getEndOfWeek: function(m) {
                  return Object(p.getEndOfWeek)(m, this.parsedWeekdays, this.times.today);
                },
                getFormatter: function(m) {
                  return Object(p.createNativeLocaleFormatter)(this.locale, function(v, y) {
                    return m;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-events.sass": (
          /*!*******************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-events.sass ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-events.ts": (
          /*!*****************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-events.ts ***!
            \*****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./calendar-with-events.sass */
              "./src/components/VCalendar/mixins/calendar-with-events.sass"
            );
            var a = i(
              /*! ../../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! ./calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), l = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), f = i(
              /*! ../modes */
              "./src/components/VCalendar/modes/index.ts"
            ), d = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), u = i(
              /*! ../util/events */
              "./src/components/VCalendar/util/events.ts"
            );
            function c(v) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(E) {
                return typeof E;
              } : c = function(E) {
                return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
              }, c(v);
            }
            var h = function() {
              return h = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, h.apply(this, arguments);
            }, p = 100, g = 95, m = 1440;
            r.default = o.default.extend({
              name: "calendar-with-events",
              directives: {
                ripple: a.default
              },
              props: h(h(h({}, l.default.events), l.default.calendar), l.default.category),
              computed: {
                noEvents: function() {
                  return this.events.length === 0;
                },
                parsedEvents: function() {
                  return this.events.map(this.parseEvent);
                },
                parsedEventOverlapThreshold: function() {
                  return parseInt(this.eventOverlapThreshold);
                },
                eventTimedFunction: function() {
                  var y = this;
                  return typeof this.eventTimed == "function" ? this.eventTimed : function(E) {
                    return !!E[y.eventTimed];
                  };
                },
                eventCategoryFunction: function() {
                  var y = this;
                  return typeof this.eventCategory == "function" ? this.eventCategory : function(E) {
                    return E[y.eventCategory];
                  };
                },
                eventTextColorFunction: function() {
                  var y = this;
                  return typeof this.eventTextColor == "function" ? this.eventTextColor : function() {
                    return y.eventTextColor;
                  };
                },
                eventNameFunction: function() {
                  var y = this;
                  return typeof this.eventName == "function" ? this.eventName : function(E, C) {
                    return E.input[y.eventName] || "";
                  };
                },
                eventModeFunction: function() {
                  return typeof this.eventOverlapMode == "function" ? this.eventOverlapMode : f.CalendarEventOverlapModes[this.eventOverlapMode];
                },
                eventWeekdays: function() {
                  return this.parsedWeekdays;
                },
                categoryMode: function() {
                  return this.type === "category";
                }
              },
              methods: {
                eventColorFunction: function(y) {
                  return typeof this.eventColor == "function" ? this.eventColor(y) : y.color || this.eventColor;
                },
                parseEvent: function(y, E) {
                  return E === void 0 && (E = 0), Object(u.parseEvent)(y, E, this.eventStart, this.eventEnd, this.eventTimedFunction(y), this.categoryMode ? this.eventCategoryFunction(y) : !1);
                },
                formatTime: function(y, E) {
                  var C = this.getFormatter({
                    timeZone: "UTC",
                    hour: "numeric",
                    minute: y.minute > 0 ? "numeric" : void 0
                  });
                  return C(y, !0);
                },
                updateEventVisibility: function() {
                  if (!(this.noEvents || !this.eventMore)) {
                    var y = this.eventHeight, E = this.getEventsMap();
                    for (var C in E) {
                      var x = E[C], b = x.parent, P = x.events, O = x.more;
                      if (!O)
                        break;
                      for (var T = b.getBoundingClientRect(), M = P.length - 1, L = P.map(function(B) {
                        return {
                          event: B,
                          bottom: B.getBoundingClientRect().bottom
                        };
                      }).sort(function(B, j) {
                        return B.bottom - j.bottom;
                      }), A = 0, D = 0; D <= M; D++) {
                        var I = L[D].bottom, w = D === M ? I > T.bottom : I + y > T.bottom;
                        w && (L[D].event.style.display = "none", A++);
                      }
                      A ? (O.style.display = "", O.innerHTML = this.$vuetify.lang.t(this.eventMoreText, A)) : O.style.display = "none";
                    }
                  }
                },
                getEventsMap: function() {
                  var y = {}, E = this.$refs.events;
                  return !E || !E.forEach || E.forEach(function(C) {
                    var x = C.getAttribute("data-date");
                    C.parentElement && x && (x in y || (y[x] = {
                      parent: C.parentElement,
                      more: null,
                      events: []
                    }), C.getAttribute("data-more") ? y[x].more = C : (y[x].events.push(C), C.style.display = ""));
                  }), y;
                },
                genDayEvent: function(y, E) {
                  var C = y.event, x = this.eventHeight, b = this.eventMarginBottom, P = Object(d.getDayIdentifier)(E), O = E.week, T = P === C.startIdentifier, M = P === C.endIdentifier, L = g;
                  if (!this.categoryMode)
                    for (var A = E.index + 1; A < O.length; A++) {
                      var D = Object(d.getDayIdentifier)(O[A]);
                      if (C.endIdentifier >= D)
                        L += p, M = M || D === C.endIdentifier;
                      else {
                        M = !0;
                        break;
                      }
                    }
                  var I = {
                    eventParsed: C,
                    day: E,
                    start: T,
                    end: M,
                    timed: !1
                  };
                  return this.genEvent(C, I, !1, {
                    staticClass: "v-event",
                    class: {
                      "v-event-start": T,
                      "v-event-end": M
                    },
                    style: {
                      height: x + "px",
                      width: L + "%",
                      "margin-bottom": b + "px"
                    },
                    attrs: {
                      "data-date": E.date
                    },
                    key: C.index,
                    ref: "events",
                    refInFor: !0
                  });
                },
                genTimedEvent: function(y, E) {
                  var C = y.event, x = y.left, b = y.width;
                  if (E.timeDelta(C.end) < 0 || E.timeDelta(C.start) >= 1 || Object(u.isEventHiddenOn)(C, E))
                    return !1;
                  var P = Object(d.getDayIdentifier)(E), O = C.startIdentifier >= P, T = C.endIdentifier > P, M = O ? E.timeToY(C.start) : 0, L = T ? E.timeToY(m) : E.timeToY(C.end), A = Math.max(this.eventHeight, L - M), D = {
                    eventParsed: C,
                    day: E,
                    start: O,
                    end: T,
                    timed: !0
                  };
                  return this.genEvent(C, D, !0, {
                    staticClass: "v-event-timed",
                    style: {
                      top: M + "px",
                      height: A + "px",
                      left: x + "%",
                      width: b + "%"
                    }
                  });
                },
                genEvent: function(y, E, C, x) {
                  var b = this, P, O = this.$scopedSlots.event, T = this.eventTextColorFunction(y.input), M = this.eventColorFunction(y.input), L = y.start.hour < 12 && y.end.hour >= 12, A = Object(d.diffMinutes)(y.start, y.end) <= this.parsedEventOverlapThreshold, D = this.formatTime, I = function() {
                    return D(y.start, L) + " - " + D(y.end, !0);
                  }, w = function() {
                    var k = b.eventNameFunction(y, C);
                    if (y.start.hasTime)
                      if (C) {
                        var X = I(), rt = A ? ", " : b.$createElement("br");
                        return b.$createElement("span", {
                          staticClass: "v-event-summary"
                        }, [b.$createElement("strong", [k]), rt, X]);
                      } else {
                        var X = D(y.start, !0);
                        return b.$createElement("span", {
                          staticClass: "v-event-summary"
                        }, [b.$createElement("strong", [X]), " ", k]);
                      }
                    return b.$createElement("span", {
                      staticClass: "v-event-summary"
                    }, [k]);
                  }, B = h(h({}, E), {
                    event: y.input,
                    outside: E.day.outside,
                    singline: A,
                    overlapsNoon: L,
                    formatTime: D,
                    timeSummary: I,
                    eventSummary: w
                  });
                  return this.$createElement("div", this.setTextColor(T, this.setBackgroundColor(M, h({
                    on: this.getDefaultMouseEventHandlers(":event", function(j) {
                      return h(h({}, B), {
                        nativeEvent: j
                      });
                    }),
                    directives: [{
                      name: "ripple",
                      value: (P = this.eventRipple) !== null && P !== void 0 ? P : !0
                    }]
                  }, x))), O ? O(B) : [this.genName(w)]);
                },
                genName: function(y) {
                  return this.$createElement("div", {
                    staticClass: "pl-1"
                  }, [y()]);
                },
                genPlaceholder: function(y) {
                  var E = this.eventHeight + this.eventMarginBottom;
                  return this.$createElement("div", {
                    style: {
                      height: E + "px"
                    },
                    attrs: {
                      "data-date": y.date
                    },
                    ref: "events",
                    refInFor: !0
                  });
                },
                genMore: function(y) {
                  var E, C = this.eventHeight, x = this.eventMarginBottom;
                  return this.$createElement("div", {
                    staticClass: "v-event-more pl-1",
                    class: {
                      "v-outside": y.outside
                    },
                    attrs: {
                      "data-date": y.date,
                      "data-more": 1
                    },
                    directives: [{
                      name: "ripple",
                      value: (E = this.eventRipple) !== null && E !== void 0 ? E : !0
                    }],
                    on: this.getDefaultMouseEventHandlers(":more", function(b) {
                      return h({
                        nativeEvent: b
                      }, y);
                    }),
                    style: {
                      display: "none",
                      height: C + "px",
                      "margin-bottom": x + "px"
                    },
                    ref: "events",
                    refInFor: !0
                  });
                },
                getVisibleEvents: function() {
                  var y = Object(d.getDayIdentifier)(this.days[0]), E = Object(d.getDayIdentifier)(this.days[this.days.length - 1]);
                  return this.parsedEvents.filter(function(C) {
                    return Object(u.isEventOverlapping)(C, y, E);
                  });
                },
                isEventForCategory: function(y, E) {
                  return !this.categoryMode || c(E) === "object" && E.categoryName && E.categoryName === y.category || typeof y.category == "string" && E === y.category || typeof y.category != "string" && E === null;
                },
                getEventsForDay: function(y) {
                  var E = Object(d.getDayIdentifier)(y), C = this.eventWeekdays[0];
                  return this.parsedEvents.filter(function(x) {
                    return Object(u.isEventStart)(x, y, E, C);
                  });
                },
                getEventsForDayAll: function(y) {
                  var E = this, C = Object(d.getDayIdentifier)(y), x = this.eventWeekdays[0];
                  return this.parsedEvents.filter(function(b) {
                    return b.allDay && (E.categoryMode ? Object(u.isEventOn)(b, C) : Object(u.isEventStart)(b, y, C, x)) && E.isEventForCategory(b, y.category);
                  });
                },
                getEventsForDayTimed: function(y) {
                  var E = this, C = Object(d.getDayIdentifier)(y);
                  return this.parsedEvents.filter(function(x) {
                    return !x.allDay && Object(u.isEventOn)(x, C) && E.isEventForCategory(x, y.category);
                  });
                },
                getScopedSlots: function() {
                  var y = this;
                  if (this.noEvents)
                    return h({}, this.$scopedSlots);
                  var E = this.eventModeFunction(this.parsedEvents, this.eventWeekdays[0], this.parsedEventOverlapThreshold), C = function(L) {
                    return !!L;
                  }, x = function(L, A, D, I) {
                    var w = A(L), B = E(L, w, I, y.categoryMode);
                    if (I)
                      return B.map(function(k) {
                        return D(k, L);
                      }).filter(C);
                    var j = [];
                    return B.forEach(function(k, X) {
                      for (; j.length < k.column; )
                        j.push(y.genPlaceholder(L));
                      var rt = D(k, L);
                      rt && j.push(rt);
                    }), j;
                  }, b = this.$scopedSlots, P = b.day, O = b["day-header"], T = b["day-body"];
                  return h(h({}, b), {
                    day: function(L) {
                      var A = x(L, y.getEventsForDay, y.genDayEvent, !1);
                      if (A && A.length > 0 && y.eventMore && A.push(y.genMore(L)), P) {
                        var D = P(L);
                        D && (A = A ? A.concat(D) : D);
                      }
                      return A;
                    },
                    "day-header": function(L) {
                      var A = x(L, y.getEventsForDayAll, y.genDayEvent, !1);
                      if (O) {
                        var D = O(L);
                        D && (A = A ? A.concat(D) : D);
                      }
                      return A;
                    },
                    "day-body": function(L) {
                      var A = x(L, y.getEventsForDayTimed, y.genTimedEvent, !0), D = [y.$createElement("div", {
                        staticClass: "v-event-timed-container"
                      }, A)];
                      if (T) {
                        var I = T(L);
                        I && (D = D.concat(I));
                      }
                      return D;
                    }
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/calendar-with-intervals.ts": (
          /*!********************************************************************!*\
            !*** ./src/components/VCalendar/mixins/calendar-with-intervals.ts ***!
            \********************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./calendar-base */
              "./src/components/VCalendar/mixins/calendar-base.ts"
            ), o = i(
              /*! ../util/props */
              "./src/components/VCalendar/util/props.ts"
            ), l = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = a.default.extend({
              name: "calendar-with-intervals",
              props: o.default.intervals,
              computed: {
                parsedFirstInterval: function() {
                  return parseInt(this.firstInterval);
                },
                parsedIntervalMinutes: function() {
                  return parseInt(this.intervalMinutes);
                },
                parsedIntervalCount: function() {
                  return parseInt(this.intervalCount);
                },
                parsedIntervalHeight: function() {
                  return parseFloat(this.intervalHeight);
                },
                parsedFirstTime: function() {
                  return Object(l.parseTime)(this.firstTime);
                },
                firstMinute: function() {
                  var d = this.parsedFirstTime;
                  return d !== !1 && d >= 0 && d <= l.MINUTES_IN_DAY ? d : this.parsedFirstInterval * this.parsedIntervalMinutes;
                },
                bodyHeight: function() {
                  return this.parsedIntervalCount * this.parsedIntervalHeight;
                },
                days: function() {
                  return Object(l.createDayList)(this.parsedStart, this.parsedEnd, this.times.today, this.weekdaySkips, this.maxDays);
                },
                intervals: function() {
                  var d = this.days, u = this.firstMinute, c = this.parsedIntervalMinutes, h = this.parsedIntervalCount, p = this.times.now;
                  return d.map(function(g) {
                    return Object(l.createIntervalList)(g, u, c, h, p);
                  });
                },
                intervalFormatter: function() {
                  if (this.intervalFormat)
                    return this.intervalFormat;
                  var d = {
                    timeZone: "UTC",
                    hour: "2-digit",
                    minute: "2-digit"
                  }, u = {
                    timeZone: "UTC",
                    hour: "numeric",
                    minute: "2-digit"
                  }, c = {
                    timeZone: "UTC",
                    hour: "numeric"
                  };
                  return Object(l.createNativeLocaleFormatter)(this.currentLocale, function(h, p) {
                    return p ? h.minute === 0 ? c : u : d;
                  });
                }
              },
              methods: {
                showIntervalLabelDefault: function(d) {
                  var u = this.intervals[0][0], c = u.hour === d.hour && u.minute === d.minute;
                  return !c;
                },
                intervalStyleDefault: function(d) {
                },
                getTimestampAtEvent: function(d, u) {
                  var c = Object(l.copyTimestamp)(u), h = d.currentTarget.getBoundingClientRect(), p = this.firstMinute, g = d, m = d, v = g.changedTouches || g.touches, y = v && v[0] ? v[0].clientY : m.clientY, E = (y - h.top) / this.parsedIntervalHeight, C = Math.floor(E * this.parsedIntervalMinutes), x = p + C;
                  return Object(l.updateMinutes)(c, x, this.times.now);
                },
                getSlotScope: function(d) {
                  var u = Object(l.copyTimestamp)(d);
                  return u.timeToY = this.timeToY, u.timeDelta = this.timeDelta, u.minutesToPixels = this.minutesToPixels, u.week = this.days, u;
                },
                scrollToTime: function(d) {
                  var u = this.timeToY(d), c = this.$refs.scrollArea;
                  return u === !1 || !c ? !1 : (c.scrollTop = u, !0);
                },
                minutesToPixels: function(d) {
                  return d / this.parsedIntervalMinutes * this.parsedIntervalHeight;
                },
                timeToY: function(d, u) {
                  u === void 0 && (u = !0);
                  var c = this.timeDelta(d);
                  return c !== !1 && (c *= this.bodyHeight, u && (c < 0 && (c = 0), c > this.bodyHeight && (c = this.bodyHeight))), c;
                },
                timeDelta: function(d) {
                  var u = Object(l.parseTime)(d);
                  if (u === !1)
                    return !1;
                  var c = this.firstMinute, h = this.parsedIntervalCount * this.parsedIntervalMinutes;
                  return (u - c) / h;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/mixins/times.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/mixins/times.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            r.default = o.a.extend({
              name: "times",
              props: {
                now: {
                  type: String,
                  validator: l.validateTimestamp
                }
              },
              data: function() {
                return {
                  times: {
                    now: Object(l.parseTimestamp)("0000-00-00 00:00", !0),
                    today: Object(l.parseTimestamp)("0000-00-00", !0)
                  }
                };
              },
              computed: {
                parsedNow: function() {
                  return this.now ? Object(l.parseTimestamp)(this.now, !0) : null;
                }
              },
              watch: {
                parsedNow: "updateTimes"
              },
              created: function() {
                this.updateTimes(), this.setPresent();
              },
              methods: {
                setPresent: function() {
                  this.times.now.present = this.times.today.present = !0, this.times.now.past = this.times.today.past = !1, this.times.now.future = this.times.today.future = !1;
                },
                updateTimes: function() {
                  var d = this.parsedNow || this.getNow();
                  this.updateDay(d, this.times.now), this.updateTime(d, this.times.now), this.updateDay(d, this.times.today);
                },
                getNow: function() {
                  return Object(l.parseDate)(/* @__PURE__ */ new Date());
                },
                updateDay: function(d, u) {
                  d.date !== u.date && (u.year = d.year, u.month = d.month, u.day = d.day, u.weekday = d.weekday, u.date = d.date);
                },
                updateTime: function(d, u) {
                  d.time !== u.time && (u.hour = d.hour, u.minute = d.minute, u.time = d.time);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCalendar/modes/column.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/modes/column.ts ***!
            \**************************************************/
          /*! exports provided: column */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "column", function() {
              return l;
            });
            var a = i(
              /*! ./common */
              "./src/components/VCalendar/modes/common.ts"
            ), o = 100, l = function(d, u, c) {
              var h = Object(a.getOverlapGroupHandler)(u);
              return function(p, g, m, v) {
                var y = h.getVisuals(p, g, m, v);
                return m && y.forEach(function(E) {
                  E.left = E.column * o / E.columnCount, E.width = o / E.columnCount;
                }), y;
              };
            };
          }
        ),
        /***/
        "./src/components/VCalendar/modes/common.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VCalendar/modes/common.ts ***!
            \**************************************************/
          /*! exports provided: getVisuals, hasOverlap, setColumnCount, getRange, getDayRange, getNormalizedRange, getOpenGroup, getOverlapGroupHandler */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "getVisuals", function() {
              return f;
            }), i.d(r, "hasOverlap", function() {
              return d;
            }), i.d(r, "setColumnCount", function() {
              return u;
            }), i.d(r, "getRange", function() {
              return c;
            }), i.d(r, "getDayRange", function() {
              return h;
            }), i.d(r, "getNormalizedRange", function() {
              return p;
            }), i.d(r, "getOpenGroup", function() {
              return g;
            }), i.d(r, "getOverlapGroupHandler", function() {
              return m;
            });
            var a = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), o = function(v, y) {
              var E = typeof Symbol == "function" && v[Symbol.iterator];
              if (!E)
                return v;
              var C = E.call(v), x, b = [], P;
              try {
                for (; (y === void 0 || y-- > 0) && !(x = C.next()).done; )
                  b.push(x.value);
              } catch (O) {
                P = {
                  error: O
                };
              } finally {
                try {
                  x && !x.done && (E = C.return) && E.call(C);
                } finally {
                  if (P)
                    throw P.error;
                }
              }
              return b;
            }, l = 864e5;
            function f(v, y) {
              y === void 0 && (y = 0);
              var E = v.map(function(C) {
                return {
                  event: C,
                  columnCount: 0,
                  column: 0,
                  left: 0,
                  width: 100
                };
              });
              return E.sort(function(C, x) {
                return Math.max(y, C.event.startTimestampIdentifier) - Math.max(y, x.event.startTimestampIdentifier) || x.event.endTimestampIdentifier - C.event.endTimestampIdentifier;
              }), E;
            }
            function d(v, y, E, C, x) {
              return x === void 0 && (x = !0), x ? !(v >= C || y <= E) : !(v > C || y < E);
            }
            function u(v) {
              v.forEach(function(y) {
                y.visuals.forEach(function(E) {
                  E.columnCount = v.length;
                });
              });
            }
            function c(v) {
              return [v.startTimestampIdentifier, v.endTimestampIdentifier];
            }
            function h(v) {
              return [v.startIdentifier, v.endIdentifier];
            }
            function p(v, y) {
              return [Math.max(y, v.startTimestampIdentifier), Math.min(y + l, v.endTimestampIdentifier)];
            }
            function g(v, y, E, C) {
              for (var x = 0; x < v.length; x++) {
                var b = v[x], P = !1;
                if (d(y, E, b.start, b.end, C))
                  for (var O = 0; O < b.visuals.length; O++) {
                    var T = b.visuals[O], M = o(C ? c(T.event) : h(T.event), 2), L = M[0], A = M[1];
                    if (d(y, E, L, A, C)) {
                      P = !0;
                      break;
                    }
                  }
                if (!P)
                  return x;
              }
              return -1;
            }
            function m(v) {
              var y = {
                groups: [],
                min: -1,
                max: -1,
                reset: function() {
                  y.groups = [], y.min = y.max = -1;
                },
                getVisuals: function(C, x, b, P) {
                  P === void 0 && (P = !1), (C.weekday === v || P) && y.reset();
                  var O = Object(a.getTimestampIdentifier)(C), T = f(x, O);
                  return T.forEach(function(M) {
                    var L = o(b ? c(M.event) : h(M.event), 2), A = L[0], D = L[1];
                    y.groups.length > 0 && !d(A, D, y.min, y.max, b) && (u(y.groups), y.reset());
                    var I = g(y.groups, A, D, b);
                    I === -1 && (I = y.groups.length, y.groups.push({
                      start: A,
                      end: D,
                      visuals: []
                    }));
                    var w = y.groups[I];
                    w.visuals.push(M), w.start = Math.min(w.start, A), w.end = Math.max(w.end, D), M.column = I, y.min === -1 ? (y.min = A, y.max = D) : (y.min = Math.min(y.min, A), y.max = Math.max(y.max, D));
                  }), u(y.groups), b && y.reset(), T;
                }
              };
              return y;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/modes/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/modes/index.ts ***!
            \*************************************************/
          /*! exports provided: CalendarEventOverlapModes */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "CalendarEventOverlapModes", function() {
              return l;
            });
            var a = i(
              /*! ./stack */
              "./src/components/VCalendar/modes/stack.ts"
            ), o = i(
              /*! ./column */
              "./src/components/VCalendar/modes/column.ts"
            ), l = {
              stack: a.stack,
              column: o.column
            };
          }
        ),
        /***/
        "./src/components/VCalendar/modes/stack.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/modes/stack.ts ***!
            \*************************************************/
          /*! exports provided: stack */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "stack", function() {
              return h;
            });
            var a = i(
              /*! ./common */
              "./src/components/VCalendar/modes/common.ts"
            ), o = i(
              /*! ../util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), l = function(T) {
              var M = typeof Symbol == "function" && Symbol.iterator, L = M && T[M], A = 0;
              if (L)
                return L.call(T);
              if (T && typeof T.length == "number")
                return {
                  next: function() {
                    return T && A >= T.length && (T = void 0), {
                      value: T && T[A++],
                      done: !T
                    };
                  }
                };
              throw new TypeError(M ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, f = function(T, M) {
              var L = typeof Symbol == "function" && T[Symbol.iterator];
              if (!L)
                return T;
              var A = L.call(T), D, I = [], w;
              try {
                for (; (M === void 0 || M-- > 0) && !(D = A.next()).done; )
                  I.push(D.value);
              } catch (B) {
                w = {
                  error: B
                };
              } finally {
                try {
                  D && !D.done && (L = A.return) && L.call(A);
                } finally {
                  if (w)
                    throw w.error;
                }
              }
              return I;
            }, d = 100, u = 5, c = 1.7, h = function(M, L, A) {
              var D = Object(a.getOverlapGroupHandler)(L);
              return function(I, w, B, j) {
                var k, X, rt, et, Z, dt;
                if (!B)
                  return D.getVisuals(I, w, B, j);
                var vt = Object(o.getTimestampIdentifier)(I), bt = Object(a.getVisuals)(w, vt), it = x(bt, vt);
                try {
                  for (var R = l(it), V = R.next(); !V.done; V = R.next()) {
                    var tt = V.value, Y = [];
                    try {
                      for (var W = (rt = void 0, l(tt.visuals)), z = W.next(); !z.done; z = W.next()) {
                        var at = z.value, ct = b(at, vt), Mt = v(ct, Y);
                        if (Mt === !1) {
                          var N = E(ct, Y);
                          N && (ct.parent = N, ct.sibling = Object(a.hasOverlap)(ct.start, ct.end, N.start, O(N.start, A)), ct.index = N.index + 1, N.children.push(ct));
                        } else {
                          var S = f(y(ct, Y, Mt - 1, Mt - 1), 1), N = S[0], _ = y(ct, Y, Mt + 1, Mt + Y.length, !0);
                          ct.children = _, ct.index = Mt, N && (ct.parent = N, ct.sibling = Object(a.hasOverlap)(ct.start, ct.end, N.start, O(N.start, A)), N.children.push(ct));
                          try {
                            for (var F = (Z = void 0, l(_)), G = F.next(); !G.done; G = F.next()) {
                              var nt = G.value;
                              nt.parent === N && (nt.parent = ct);
                              var lt = nt.index - ct.index <= 1;
                              lt && ct.sibling && Object(a.hasOverlap)(ct.start, O(ct.start, A), nt.start, nt.end) && (nt.sibling = !0);
                            }
                          } catch (Lt) {
                            Z = {
                              error: Lt
                            };
                          } finally {
                            try {
                              G && !G.done && (dt = F.return) && dt.call(F);
                            } finally {
                              if (Z)
                                throw Z.error;
                            }
                          }
                        }
                        Y.push(ct);
                      }
                    } catch (yt) {
                      rt = {
                        error: yt
                      };
                    } finally {
                      try {
                        z && !z.done && (et = W.return) && et.call(W);
                      } finally {
                        if (rt)
                          throw rt.error;
                      }
                    }
                    p(Y, A);
                  }
                } catch (yt) {
                  k = {
                    error: yt
                  };
                } finally {
                  try {
                    V && !V.done && (X = R.return) && X.call(R);
                  } finally {
                    if (k)
                      throw k.error;
                  }
                }
                return bt.sort(function(yt, Lt) {
                  return yt.left - Lt.left || yt.event.startTimestampIdentifier - Lt.event.startTimestampIdentifier;
                }), bt;
              };
            };
            function p(T, M) {
              var L, A;
              try {
                for (var D = l(T), I = D.next(); !I.done; I = D.next()) {
                  var w = I.value, B = w.visual, j = w.parent, k = P(w) + 1, X = j ? j.visual.left : 0, rt = d - X, et = Math.min(u, d / k), Z = g(w, T), dt = rt / (k - w.index + 1), vt = rt / (k - w.index + (w.sibling ? 1 : 0)) * Z;
                  j && (B.left = w.sibling ? X + dt : X + et), B.width = C(w, T, M) ? d - B.left : Math.min(d - B.left, vt * c);
                }
              } catch (bt) {
                L = {
                  error: bt
                };
              } finally {
                try {
                  I && !I.done && (A = D.return) && A.call(D);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
            }
            function g(T, M) {
              if (!T.children.length)
                return 1;
              var L = T.index + M.length, A = T.children.reduce(function(D, I) {
                return Math.min(D, I.index);
              }, L);
              return A - T.index;
            }
            function m(T, M) {
              var L, A, D = [];
              try {
                for (var I = l(M), w = I.next(); !w.done; w = I.next()) {
                  var B = w.value;
                  Object(a.hasOverlap)(T.start, T.end, B.start, B.end) && D.push(B.index);
                }
              } catch (j) {
                L = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (A = I.return) && A.call(I);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return D;
            }
            function v(T, M) {
              var L = m(T, M);
              L.sort();
              for (var A = 0; A < L.length; A++)
                if (A < L[A])
                  return A;
              return !1;
            }
            function y(T, M, L, A, D) {
              var I, w;
              D === void 0 && (D = !1);
              var B = [];
              try {
                for (var j = l(M), k = j.next(); !k.done; k = j.next()) {
                  var X = k.value;
                  X.index >= L && X.index <= A && Object(a.hasOverlap)(T.start, T.end, X.start, X.end) && B.push(X);
                }
              } catch (et) {
                I = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (w = j.return) && w.call(j);
                } finally {
                  if (I)
                    throw I.error;
                }
              }
              if (D && B.length > 0) {
                var rt = B.reduce(function(et, Z) {
                  return Math.min(et, Z.index);
                }, B[0].index);
                return B.filter(function(et) {
                  return et.index === rt;
                });
              }
              return B;
            }
            function E(T, M) {
              var L, A, D = null;
              try {
                for (var I = l(M), w = I.next(); !w.done; w = I.next()) {
                  var B = w.value;
                  Object(a.hasOverlap)(T.start, T.end, B.start, B.end) && (D === null || B.index > D.index) && (D = B);
                }
              } catch (j) {
                L = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (A = I.return) && A.call(I);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return D;
            }
            function C(T, M, L) {
              var A, D;
              try {
                for (var I = l(M), w = I.next(); !w.done; w = I.next()) {
                  var B = w.value;
                  if (B !== T && B.index > T.index && Object(a.hasOverlap)(T.start, O(T.start, L), B.start, B.end))
                    return !1;
                }
              } catch (j) {
                A = {
                  error: j
                };
              } finally {
                try {
                  w && !w.done && (D = I.return) && D.call(I);
                } finally {
                  if (A)
                    throw A.error;
                }
              }
              return !0;
            }
            function x(T, M) {
              var L, A, D, I, w = [];
              try {
                for (var B = l(T), j = B.next(); !j.done; j = B.next()) {
                  var k = j.value, X = f(Object(a.getNormalizedRange)(k.event, M), 2), rt = X[0], et = X[1], Z = !1;
                  try {
                    for (var dt = (D = void 0, l(w)), vt = dt.next(); !vt.done; vt = dt.next()) {
                      var bt = vt.value;
                      if (Object(a.hasOverlap)(rt, et, bt.start, bt.end)) {
                        bt.visuals.push(k), bt.end = Math.max(bt.end, et), Z = !0;
                        break;
                      }
                    }
                  } catch (it) {
                    D = {
                      error: it
                    };
                  } finally {
                    try {
                      vt && !vt.done && (I = dt.return) && I.call(dt);
                    } finally {
                      if (D)
                        throw D.error;
                    }
                  }
                  Z || w.push({
                    start: rt,
                    end: et,
                    visuals: [k]
                  });
                }
              } catch (it) {
                L = {
                  error: it
                };
              } finally {
                try {
                  j && !j.done && (A = B.return) && A.call(B);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return w;
            }
            function b(T, M) {
              var L = f(Object(a.getNormalizedRange)(T.event, M), 2), A = L[0], D = L[1];
              return {
                parent: null,
                sibling: !0,
                index: 0,
                visual: T,
                start: A,
                end: D,
                children: []
              };
            }
            function P(T) {
              var M, L, A = T.index;
              try {
                for (var D = l(T.children), I = D.next(); !I.done; I = D.next()) {
                  var w = I.value, B = P(w);
                  B > A && (A = B);
                }
              } catch (j) {
                M = {
                  error: j
                };
              } finally {
                try {
                  I && !I.done && (L = D.return) && L.call(D);
                } finally {
                  if (M)
                    throw M.error;
                }
              }
              return A;
            }
            function O(T, M) {
              var L = T % 100, A = L + M, D = Math.floor(A / 60), I = A % 60;
              return T - L + D * 100 + I;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/events.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/util/events.ts ***!
            \*************************************************/
          /*! exports provided: parseEvent, isEventOn, isEventHiddenOn, isEventStart, isEventOverlapping */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parseEvent", function() {
              return o;
            }), i.d(r, "isEventOn", function() {
              return l;
            }), i.d(r, "isEventHiddenOn", function() {
              return f;
            }), i.d(r, "isEventStart", function() {
              return d;
            }), i.d(r, "isEventOverlapping", function() {
              return u;
            });
            var a = i(
              /*! ./timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            );
            function o(c, h, p, g, m, v) {
              m === void 0 && (m = !1), v === void 0 && (v = !1);
              var y = c[p], E = c[g], C = Object(a.parseTimestamp)(y, !0), x = E ? Object(a.parseTimestamp)(E, !0) : C, b = Object(a.isTimedless)(y) ? Object(a.updateHasTime)(C, m) : C, P = Object(a.isTimedless)(E) ? Object(a.updateHasTime)(x, m) : x, O = Object(a.getDayIdentifier)(b), T = Object(a.getTimestampIdentifier)(b), M = Object(a.getDayIdentifier)(P), L = b.hasTime ? 0 : 2359, A = Object(a.getTimestampIdentifier)(P) + L, D = !b.hasTime;
              return {
                input: c,
                start: b,
                startIdentifier: O,
                startTimestampIdentifier: T,
                end: P,
                endIdentifier: M,
                endTimestampIdentifier: A,
                allDay: D,
                index: h,
                category: v
              };
            }
            function l(c, h) {
              return h >= c.startIdentifier && h <= c.endIdentifier;
            }
            function f(c, h) {
              return c.end.time === "00:00" && c.end.date === h.date && c.start.date !== h.date;
            }
            function d(c, h, p, g) {
              return p === c.startIdentifier || g === h.weekday && l(c, p);
            }
            function u(c, h, p) {
              return h <= c.endIdentifier && p >= c.startIdentifier;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/parser.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VCalendar/util/parser.ts ***!
            \*************************************************/
          /*! exports provided: parsedCategoryText, getParsedCategories */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parsedCategoryText", function() {
              return l;
            }), i.d(r, "getParsedCategories", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            var o = function() {
              return o = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, o.apply(this, arguments);
            };
            function l(d, u) {
              return typeof u == "string" && a(d) === "object" && d ? d[u] : typeof u == "function" ? u(d) : d;
            }
            function f(d, u) {
              return typeof d == "string" ? d.split(/\s*,\s/) : Array.isArray(d) ? d.map(function(c) {
                if (typeof c == "string")
                  return c;
                var h = typeof c.categoryName == "string" ? c.categoryName : l(c, u);
                return o(o({}, c), {
                  categoryName: h
                });
              }) : [];
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/props.ts": (
          /*!************************************************!*\
            !*** ./src/components/VCalendar/util/props.ts ***!
            \************************************************/
          /*! exports provided: default, validateNumber, validateWeekdays */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "validateNumber", function() {
              return l;
            }), i.d(r, "validateWeekdays", function() {
              return f;
            });
            var a = i(
              /*! ./timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), o = i(
              /*! ../modes */
              "./src/components/VCalendar/modes/index.ts"
            );
            r.default = {
              base: {
                start: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp,
                  default: function() {
                    return Object(a.parseDate)(/* @__PURE__ */ new Date()).date;
                  }
                },
                end: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp
                },
                weekdays: {
                  type: [Array, String],
                  default: function() {
                    return [0, 1, 2, 3, 4, 5, 6];
                  },
                  validate: f
                },
                hideHeader: {
                  type: Boolean
                },
                shortWeekdays: {
                  type: Boolean,
                  default: !0
                },
                weekdayFormat: {
                  type: Function,
                  default: null
                },
                dayFormat: {
                  type: Function,
                  default: null
                }
              },
              intervals: {
                maxDays: {
                  type: Number,
                  default: 7
                },
                shortIntervals: {
                  type: Boolean,
                  default: !0
                },
                intervalHeight: {
                  type: [Number, String],
                  default: 48,
                  validate: l
                },
                intervalWidth: {
                  type: [Number, String],
                  default: 60,
                  validate: l
                },
                intervalMinutes: {
                  type: [Number, String],
                  default: 60,
                  validate: l
                },
                firstInterval: {
                  type: [Number, String],
                  default: 0,
                  validate: l
                },
                firstTime: {
                  type: [Number, String, Object],
                  validate: a.validateTime
                },
                intervalCount: {
                  type: [Number, String],
                  default: 24,
                  validate: l
                },
                intervalFormat: {
                  type: Function,
                  default: null
                },
                intervalStyle: {
                  type: Function,
                  default: null
                },
                showIntervalLabel: {
                  type: Function,
                  default: null
                }
              },
              weeks: {
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                minWeeks: {
                  validate: l,
                  default: 1
                },
                shortMonths: {
                  type: Boolean,
                  default: !0
                },
                showMonthOnFirst: {
                  type: Boolean,
                  default: !0
                },
                showWeek: Boolean,
                monthFormat: {
                  type: Function,
                  default: null
                }
              },
              calendar: {
                type: {
                  type: String,
                  default: "month"
                },
                value: {
                  type: [String, Number, Date],
                  validate: a.validateTimestamp
                }
              },
              category: {
                categories: {
                  type: [Array, String],
                  default: ""
                },
                categoryText: {
                  type: [String, Function]
                },
                categoryHideDynamic: {
                  type: Boolean
                },
                categoryShowAll: {
                  type: Boolean
                },
                categoryForInvalid: {
                  type: String,
                  default: ""
                },
                categoryDays: {
                  type: [Number, String],
                  default: 1,
                  validate: function(u) {
                    return isFinite(parseInt(u)) && parseInt(u) > 0;
                  }
                }
              },
              events: {
                events: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                eventStart: {
                  type: String,
                  default: "start"
                },
                eventEnd: {
                  type: String,
                  default: "end"
                },
                eventTimed: {
                  type: [String, Function],
                  default: "timed"
                },
                eventCategory: {
                  type: [String, Function],
                  default: "category"
                },
                eventHeight: {
                  type: Number,
                  default: 20
                },
                eventColor: {
                  type: [String, Function],
                  default: "primary"
                },
                eventTextColor: {
                  type: [String, Function],
                  default: "white"
                },
                eventName: {
                  type: [String, Function],
                  default: "name"
                },
                eventOverlapThreshold: {
                  type: [String, Number],
                  default: 60
                },
                eventOverlapMode: {
                  type: [String, Function],
                  default: "stack",
                  validate: function(u) {
                    return u in o.CalendarEventOverlapModes || typeof u == "function";
                  }
                },
                eventMore: {
                  type: Boolean,
                  default: !0
                },
                eventMoreText: {
                  type: String,
                  default: "$vuetify.calendar.moreEvents"
                },
                eventRipple: {
                  type: [Boolean, Object],
                  default: null
                },
                eventMarginBottom: {
                  type: Number,
                  default: 1
                }
              }
            };
            function l(d) {
              return isFinite(parseInt(d));
            }
            function f(d) {
              if (typeof d == "string" && (d = d.split(",")), Array.isArray(d)) {
                var u = d.map(function(v) {
                  return parseInt(v);
                });
                if (u.length > a.DAYS_IN_WEEK || u.length === 0)
                  return !1;
                for (var c = {}, h = !1, p = 0; p < u.length; p++) {
                  var g = u[p];
                  if (!isFinite(g) || g < 0 || g >= a.DAYS_IN_WEEK)
                    return !1;
                  if (p > 0) {
                    var m = g - u[p - 1];
                    if (m < 0) {
                      if (h)
                        return !1;
                      h = !0;
                    } else if (m === 0)
                      return !1;
                  }
                  if (c[g])
                    return !1;
                  c[g] = !0;
                }
                return !0;
              }
              return !1;
            }
          }
        ),
        /***/
        "./src/components/VCalendar/util/timestamp.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VCalendar/util/timestamp.ts ***!
            \****************************************************/
          /*! exports provided: PARSE_REGEX, PARSE_TIME, DAYS_IN_MONTH, DAYS_IN_MONTH_LEAP, DAYS_IN_MONTH_MIN, DAYS_IN_MONTH_MAX, MONTH_MAX, MONTH_MIN, DAY_MIN, DAYS_IN_WEEK, MINUTES_IN_HOUR, MINUTE_MAX, MINUTES_IN_DAY, HOURS_IN_DAY, HOUR_MAX, FIRST_HOUR, OFFSET_YEAR, OFFSET_MONTH, OFFSET_HOUR, OFFSET_TIME, getStartOfWeek, getEndOfWeek, getStartOfMonth, getEndOfMonth, validateTime, parseTime, validateTimestamp, parseTimestamp, parseDate, getDayIdentifier, getTimeIdentifier, getTimestampIdentifier, updateRelative, isTimedless, updateHasTime, updateMinutes, updateWeekday, updateFormatted, getWeekday, daysInMonth, copyTimestamp, padNumber, getDate, getTime, nextMinutes, nextDay, prevDay, relativeDays, diffMinutes, findWeekday, getWeekdaySkips, timestampToDate, createDayList, createIntervalList, createNativeLocaleFormatter */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "PARSE_REGEX", function() {
              return l;
            }), i.d(r, "PARSE_TIME", function() {
              return f;
            }), i.d(r, "DAYS_IN_MONTH", function() {
              return d;
            }), i.d(r, "DAYS_IN_MONTH_LEAP", function() {
              return u;
            }), i.d(r, "DAYS_IN_MONTH_MIN", function() {
              return c;
            }), i.d(r, "DAYS_IN_MONTH_MAX", function() {
              return h;
            }), i.d(r, "MONTH_MAX", function() {
              return p;
            }), i.d(r, "MONTH_MIN", function() {
              return g;
            }), i.d(r, "DAY_MIN", function() {
              return m;
            }), i.d(r, "DAYS_IN_WEEK", function() {
              return v;
            }), i.d(r, "MINUTES_IN_HOUR", function() {
              return y;
            }), i.d(r, "MINUTE_MAX", function() {
              return E;
            }), i.d(r, "MINUTES_IN_DAY", function() {
              return C;
            }), i.d(r, "HOURS_IN_DAY", function() {
              return x;
            }), i.d(r, "HOUR_MAX", function() {
              return b;
            }), i.d(r, "FIRST_HOUR", function() {
              return P;
            }), i.d(r, "OFFSET_YEAR", function() {
              return O;
            }), i.d(r, "OFFSET_MONTH", function() {
              return T;
            }), i.d(r, "OFFSET_HOUR", function() {
              return M;
            }), i.d(r, "OFFSET_TIME", function() {
              return L;
            }), i.d(r, "getStartOfWeek", function() {
              return A;
            }), i.d(r, "getEndOfWeek", function() {
              return D;
            }), i.d(r, "getStartOfMonth", function() {
              return I;
            }), i.d(r, "getEndOfMonth", function() {
              return w;
            }), i.d(r, "validateTime", function() {
              return B;
            }), i.d(r, "parseTime", function() {
              return j;
            }), i.d(r, "validateTimestamp", function() {
              return k;
            }), i.d(r, "parseTimestamp", function() {
              return X;
            }), i.d(r, "parseDate", function() {
              return rt;
            }), i.d(r, "getDayIdentifier", function() {
              return et;
            }), i.d(r, "getTimeIdentifier", function() {
              return Z;
            }), i.d(r, "getTimestampIdentifier", function() {
              return dt;
            }), i.d(r, "updateRelative", function() {
              return vt;
            }), i.d(r, "isTimedless", function() {
              return bt;
            }), i.d(r, "updateHasTime", function() {
              return it;
            }), i.d(r, "updateMinutes", function() {
              return R;
            }), i.d(r, "updateWeekday", function() {
              return V;
            }), i.d(r, "updateFormatted", function() {
              return tt;
            }), i.d(r, "getWeekday", function() {
              return Y;
            }), i.d(r, "daysInMonth", function() {
              return W;
            }), i.d(r, "copyTimestamp", function() {
              return z;
            }), i.d(r, "padNumber", function() {
              return at;
            }), i.d(r, "getDate", function() {
              return ct;
            }), i.d(r, "getTime", function() {
              return Mt;
            }), i.d(r, "nextMinutes", function() {
              return N;
            }), i.d(r, "nextDay", function() {
              return S;
            }), i.d(r, "prevDay", function() {
              return _;
            }), i.d(r, "relativeDays", function() {
              return F;
            }), i.d(r, "diffMinutes", function() {
              return G;
            }), i.d(r, "findWeekday", function() {
              return nt;
            }), i.d(r, "getWeekdaySkips", function() {
              return lt;
            }), i.d(r, "timestampToDate", function() {
              return yt;
            }), i.d(r, "createDayList", function() {
              return Lt;
            }), i.d(r, "createIntervalList", function() {
              return Ft;
            }), i.d(r, "createNativeLocaleFormatter", function() {
              return Jt;
            });
            var a = i(
              /*! ../../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            );
            function o(J) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(Ct) {
                return typeof Ct;
              } : o = function(Ct) {
                return Ct && typeof Symbol == "function" && Ct.constructor === Symbol && Ct !== Symbol.prototype ? "symbol" : typeof Ct;
              }, o(J);
            }
            var l = /^(\d{4})-(\d{1,2})(-(\d{1,2}))?([^\d]+(\d{1,2}))?(:(\d{1,2}))?(:(\d{1,2}))?$/, f = /(\d\d?)(:(\d\d?)|)(:(\d\d?)|)/, d = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], u = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], c = 28, h = 31, p = 12, g = 1, m = 1, v = 7, y = 60, E = 59, C = 24 * 60, x = 24, b = 23, P = 0, O = 1e4, T = 100, M = 100, L = 1e4;
            function A(J, ft, Ct) {
              var St = z(J);
              return nt(St, ft[0], _), tt(St), Ct && vt(St, Ct, St.hasTime), St;
            }
            function D(J, ft, Ct) {
              var St = z(J);
              return nt(St, ft[ft.length - 1]), tt(St), Ct && vt(St, Ct, St.hasTime), St;
            }
            function I(J) {
              var ft = z(J);
              return ft.day = m, V(ft), tt(ft), ft;
            }
            function w(J) {
              var ft = z(J);
              return ft.day = W(ft.year, ft.month), V(ft), tt(ft), ft;
            }
            function B(J) {
              return typeof J == "number" && isFinite(J) || !!f.exec(J) || o(J) === "object" && isFinite(J.hour) && isFinite(J.minute);
            }
            function j(J) {
              if (typeof J == "number")
                return J;
              if (typeof J == "string") {
                var ft = f.exec(J);
                return ft ? parseInt(ft[1]) * 60 + parseInt(ft[3] || 0) : !1;
              } else
                return o(J) === "object" ? typeof J.hour != "number" || typeof J.minute != "number" ? !1 : J.hour * 60 + J.minute : !1;
            }
            function k(J) {
              return typeof J == "number" && isFinite(J) || typeof J == "string" && !!l.exec(J) || J instanceof Date;
            }
            function X(J, ft, Ct) {
              if (ft === void 0 && (ft = !1), typeof J == "number" && isFinite(J) && (J = new Date(J)), J instanceof Date) {
                var St = rt(J);
                return Ct && vt(St, Ct, St.hasTime), St;
              }
              if (typeof J != "string") {
                if (ft)
                  throw new Error(J + " is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.");
                return null;
              }
              var Tt = l.exec(J);
              if (!Tt) {
                if (ft)
                  throw new Error(J + " is not a valid timestamp. It must be a Date, number of milliseconds since Epoch, or a string in the format of YYYY-MM-DD or YYYY-MM-DD hh:mm. Zero-padding is optional and seconds are ignored.");
                return null;
              }
              var kt = {
                date: J,
                time: "",
                year: parseInt(Tt[1]),
                month: parseInt(Tt[2]),
                day: parseInt(Tt[4]) || 1,
                hour: parseInt(Tt[6]) || 0,
                minute: parseInt(Tt[8]) || 0,
                weekday: 0,
                hasDay: !!Tt[4],
                hasTime: !!(Tt[6] && Tt[8]),
                past: !1,
                present: !1,
                future: !1
              };
              return V(kt), tt(kt), Ct && vt(kt, Ct, kt.hasTime), kt;
            }
            function rt(J) {
              return tt({
                date: "",
                time: "",
                year: J.getFullYear(),
                month: J.getMonth() + 1,
                day: J.getDate(),
                weekday: J.getDay(),
                hour: J.getHours(),
                minute: J.getMinutes(),
                hasDay: !0,
                hasTime: !0,
                past: !1,
                present: !0,
                future: !1
              });
            }
            function et(J) {
              return J.year * O + J.month * T + J.day;
            }
            function Z(J) {
              return J.hour * M + J.minute;
            }
            function dt(J) {
              return et(J) * L + Z(J);
            }
            function vt(J, ft, Ct) {
              Ct === void 0 && (Ct = !1);
              var St = et(ft), Tt = et(J), kt = St === Tt;
              return J.hasTime && Ct && kt && (St = Z(ft), Tt = Z(J), kt = St === Tt), J.past = Tt < St, J.present = kt, J.future = Tt > St, J;
            }
            function bt(J) {
              return J instanceof Date || typeof J == "number" && isFinite(J);
            }
            function it(J, ft, Ct) {
              return J.hasTime !== ft && (J.hasTime = ft, ft || (J.hour = b, J.minute = E, J.time = Mt(J)), Ct && vt(J, Ct, J.hasTime)), J;
            }
            function R(J, ft, Ct) {
              return J.hasTime = !0, J.hour = Math.floor(ft / y), J.minute = ft % y, J.time = Mt(J), Ct && vt(J, Ct, !0), J;
            }
            function V(J) {
              return J.weekday = Y(J), J;
            }
            function tt(J) {
              return J.time = Mt(J), J.date = ct(J), J;
            }
            function Y(J) {
              if (J.hasDay) {
                var ft = Math.floor, Ct = J.day, St = (J.month + 9) % p + 1, Tt = ft(J.year / 100), kt = J.year % 100 - (J.month <= 2 ? 1 : 0);
                return ((Ct + ft(2.6 * St - 0.2) - 2 * Tt + kt + ft(kt / 4) + ft(Tt / 4)) % 7 + 7) % 7;
              }
              return J.weekday;
            }
            function W(J, ft) {
              return Object(a.isLeapYear)(J) ? u[ft] : d[ft];
            }
            function z(J) {
              var ft = J.date, Ct = J.time, St = J.year, Tt = J.month, kt = J.day, fe = J.weekday, Se = J.hour, Me = J.minute, xe = J.hasDay, We = J.hasTime, bn = J.past, Ye = J.present, Hn = J.future;
              return {
                date: ft,
                time: Ct,
                year: St,
                month: Tt,
                day: kt,
                weekday: fe,
                hour: Se,
                minute: Me,
                hasDay: xe,
                hasTime: We,
                past: bn,
                present: Ye,
                future: Hn
              };
            }
            function at(J, ft) {
              for (var Ct = String(J); Ct.length < ft; )
                Ct = "0" + Ct;
              return Ct;
            }
            function ct(J) {
              var ft = at(J.year, 4) + "-" + at(J.month, 2);
              return J.hasDay && (ft += "-" + at(J.day, 2)), ft;
            }
            function Mt(J) {
              return J.hasTime ? at(J.hour, 2) + ":" + at(J.minute, 2) : "";
            }
            function N(J, ft) {
              for (J.minute += ft; J.minute > y; )
                J.minute -= y, J.hour++, J.hour >= x && (S(J), J.hour = P);
              return J;
            }
            function S(J) {
              return J.day++, J.weekday = (J.weekday + 1) % v, J.day > c && J.day > W(J.year, J.month) && (J.day = m, J.month++, J.month > p && (J.month = g, J.year++)), J;
            }
            function _(J) {
              return J.day--, J.weekday = (J.weekday + 6) % v, J.day < m && (J.month--, J.month < g && (J.year--, J.month = p), J.day = W(J.year, J.month)), J;
            }
            function F(J, ft, Ct) {
              for (ft === void 0 && (ft = S), Ct === void 0 && (Ct = 1); --Ct >= 0; )
                ft(J);
              return J;
            }
            function G(J, ft) {
              var Ct = (ft.year - J.year) * 525600, St = (ft.month - J.month) * 43800, Tt = (ft.day - J.day) * 1440, kt = (ft.hour - J.hour) * 60, fe = ft.minute - J.minute;
              return Ct + St + Tt + kt + fe;
            }
            function nt(J, ft, Ct, St) {
              for (Ct === void 0 && (Ct = S), St === void 0 && (St = 6); J.weekday !== ft && --St >= 0; )
                Ct(J);
              return J;
            }
            function lt(J) {
              for (var ft = [1, 1, 1, 1, 1, 1, 1], Ct = [0, 0, 0, 0, 0, 0, 0], St = 0; St < J.length; St++)
                Ct[J[St]] = 1;
              for (var Tt = 0; Tt < v; Tt++) {
                for (var kt = 1, fe = 1; fe < v; fe++) {
                  var Se = (Tt + fe) % v;
                  if (Ct[Se])
                    break;
                  kt++;
                }
                ft[Tt] = Ct[Tt] * kt;
              }
              return ft;
            }
            function yt(J) {
              var ft = at(J.hour, 2) + ":" + at(J.minute, 2), Ct = J.date;
              return /* @__PURE__ */ new Date(Ct + "T" + ft + ":00+00:00");
            }
            function Lt(J, ft, Ct, St, Tt, kt) {
              Tt === void 0 && (Tt = 42), kt === void 0 && (kt = 0);
              var fe = et(ft), Se = [], Me = z(J), xe = 0, We = xe === fe;
              if (fe < et(J))
                throw new Error("End date is earlier than start date.");
              for (; (!We || Se.length < kt) && Se.length < Tt; ) {
                if (xe = et(Me), We = We || xe === fe, St[Me.weekday] === 0) {
                  Me = S(Me);
                  continue;
                }
                var bn = z(Me);
                tt(bn), vt(bn, Ct), Se.push(bn), Me = F(Me, S, St[Me.weekday]);
              }
              if (!Se.length)
                throw new Error("No dates found using specified start date, end date, and weekdays.");
              return Se;
            }
            function Ft(J, ft, Ct, St, Tt) {
              for (var kt = [], fe = 0; fe < St; fe++) {
                var Se = ft + fe * Ct, Me = z(J);
                kt.push(R(Me, Se, Tt));
              }
              return kt;
            }
            function Jt(J, ft) {
              var Ct = function(Tt, kt) {
                return "";
              };
              return typeof Intl > "u" || typeof Intl.DateTimeFormat > "u" ? Ct : function(St, Tt) {
                try {
                  var kt = new Intl.DateTimeFormat(J || void 0, ft(St, Tt));
                  return kt.format(yt(St));
                } catch {
                  return "";
                }
              };
            }
          }
        ),
        /***/
        "./src/components/VCard/VCard.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VCard/VCard.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCard/VCard.ts": (
          /*!***************************************!*\
            !*** ./src/components/VCard/VCard.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCard.sass */
              "./src/components/VCard/VCard.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), l = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(o.default, l.default, a.default).extend({
              name: "v-card",
              props: {
                flat: Boolean,
                hover: Boolean,
                img: String,
                link: Boolean,
                loaderHeight: {
                  type: [Number, String],
                  default: 4
                },
                raised: Boolean
              },
              computed: {
                classes: function() {
                  return d(d(d({
                    "v-card": !0
                  }, l.default.options.computed.classes.call(this)), {
                    "v-card--flat": this.flat,
                    "v-card--hover": this.hover,
                    "v-card--link": this.isClickable,
                    "v-card--loading": this.loading,
                    "v-card--disabled": this.disabled,
                    "v-card--raised": this.raised
                  }), a.default.options.computed.classes.call(this));
                },
                styles: function() {
                  var c = d({}, a.default.options.computed.styles.call(this));
                  return this.img && (c.background = 'url("' + this.img + '") center center / cover no-repeat'), c;
                }
              },
              methods: {
                genProgress: function() {
                  var c = o.default.options.methods.genProgress.call(this);
                  return c ? this.$createElement("div", {
                    staticClass: "v-card__progress",
                    key: "progress"
                  }, [c]) : null;
                }
              },
              render: function(c) {
                var h = this.generateRouteLink(), p = h.tag, g = h.data;
                return g.style = this.styles, this.isClickable && (g.attrs = g.attrs || {}, g.attrs.tabindex = 0), c(p, this.setBackgroundColor(this.color, g), [this.genProgress(), this.$slots.default]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCard/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VCard/index.ts ***!
            \***************************************/
          /*! exports provided: VCard, VCardActions, VCardSubtitle, VCardText, VCardTitle, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VCardActions", function() {
              return l;
            }), i.d(r, "VCardSubtitle", function() {
              return f;
            }), i.d(r, "VCardText", function() {
              return d;
            }), i.d(r, "VCardTitle", function() {
              return u;
            });
            var a = i(
              /*! ./VCard */
              "./src/components/VCard/VCard.ts"
            );
            i.d(r, "VCard", function() {
              return a.default;
            });
            var o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = Object(o.createSimpleFunctional)("v-card__actions"), f = Object(o.createSimpleFunctional)("v-card__subtitle"), d = Object(o.createSimpleFunctional)("v-card__text"), u = Object(o.createSimpleFunctional)("v-card__title");
            r.default = {
              $_vuetify_subcomponents: {
                VCard: a.default,
                VCardActions: l,
                VCardSubtitle: f,
                VCardText: d,
                VCardTitle: u
              }
            };
          }
        ),
        /***/
        "./src/components/VCarousel/VCarousel.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VCarousel/VCarousel.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCarousel/VCarousel.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCarousel/VCarousel.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCarousel.sass */
              "./src/components/VCarousel/VCarousel.sass"
            );
            var a = i(
              /*! ../VWindow/VWindow */
              "./src/components/VWindow/VWindow.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            ), d = i(
              /*! ../../mixins/button-group */
              "./src/mixins/button-group/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-carousel",
              props: {
                continuous: {
                  type: Boolean,
                  default: !0
                },
                cycle: Boolean,
                delimiterIcon: {
                  type: String,
                  default: "$delimiter"
                },
                height: {
                  type: [Number, String],
                  default: 500
                },
                hideDelimiters: Boolean,
                hideDelimiterBackground: Boolean,
                interval: {
                  type: [Number, String],
                  default: 6e3,
                  validator: function(g) {
                    return g > 0;
                  }
                },
                mandatory: {
                  type: Boolean,
                  default: !0
                },
                progress: Boolean,
                progressColor: String,
                showArrows: {
                  type: Boolean,
                  default: !0
                },
                verticalDelimiters: {
                  type: String,
                  default: void 0
                }
              },
              // pass down the parent's theme
              provide: function() {
                return {
                  parentTheme: this.theme
                };
              },
              data: function() {
                return {
                  internalHeight: this.height,
                  slideTimeout: void 0
                };
              },
              computed: {
                classes: function() {
                  return h(h({}, a.default.options.computed.classes.call(this)), {
                    "v-carousel": !0,
                    "v-carousel--hide-delimiter-background": this.hideDelimiterBackground,
                    "v-carousel--vertical-delimiters": this.isVertical
                  });
                },
                isDark: function() {
                  return this.dark || !this.light;
                },
                isVertical: function() {
                  return this.verticalDelimiters != null;
                }
              },
              watch: {
                internalValue: "restartTimeout",
                interval: "restartTimeout",
                height: function(g, m) {
                  g === m || !g || (this.internalHeight = g);
                },
                cycle: function(g) {
                  g ? this.restartTimeout() : (clearTimeout(this.slideTimeout), this.slideTimeout = void 0);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("hide-controls") && Object(c.breaking)("hide-controls", ':show-arrows="false"', this);
              },
              mounted: function() {
                this.startTimeout();
              },
              methods: {
                genControlIcons: function() {
                  return this.isVertical ? null : a.default.options.methods.genControlIcons.call(this);
                },
                genDelimiters: function() {
                  return this.$createElement("div", {
                    staticClass: "v-carousel__controls",
                    style: {
                      left: this.verticalDelimiters === "left" && this.isVertical ? 0 : "auto",
                      right: this.verticalDelimiters === "right" ? 0 : "auto"
                    }
                  }, [this.genItems()]);
                },
                genItems: function() {
                  for (var g = this, m = this.items.length, v = [], y = 0; y < m; y++) {
                    var E = this.$createElement(o.default, {
                      staticClass: "v-carousel__controls__item",
                      attrs: {
                        "aria-label": this.$vuetify.lang.t("$vuetify.carousel.ariaLabel.delimiter", y + 1, m)
                      },
                      props: {
                        icon: !0,
                        small: !0,
                        value: this.getValue(this.items[y], y)
                      },
                      key: y
                    }, [this.$createElement(l.default, {
                      props: {
                        size: 18
                      }
                    }, this.delimiterIcon)]);
                    v.push(E);
                  }
                  return this.$createElement(d.default, {
                    props: {
                      value: this.internalValue,
                      mandatory: this.mandatory
                    },
                    on: {
                      change: function(x) {
                        g.internalValue = x;
                      }
                    }
                  }, v);
                },
                genProgress: function() {
                  return this.$createElement(f.default, {
                    staticClass: "v-carousel__progress",
                    props: {
                      color: this.progressColor,
                      value: (this.internalIndex + 1) / this.items.length * 100
                    }
                  });
                },
                restartTimeout: function() {
                  this.slideTimeout && clearTimeout(this.slideTimeout), this.slideTimeout = void 0, window.requestAnimationFrame(this.startTimeout);
                },
                startTimeout: function() {
                  this.cycle && (this.slideTimeout = window.setTimeout(this.next, +this.interval > 0 ? +this.interval : 6e3));
                }
              },
              render: function(g) {
                var m = a.default.options.render.call(this, g);
                return m.data.style = "height: " + Object(u.convertToUnit)(this.height) + ";", this.hideDelimiters || m.children.push(this.genDelimiters()), (this.progress || this.progressColor) && m.children.push(this.genProgress()), m;
              }
            });
          }
        ),
        /***/
        "./src/components/VCarousel/VCarouselItem.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VCarousel/VCarouselItem.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            ), o = i(
              /*! ../VImg */
              "./src/components/VImg/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(l.default)(a.default, d.default);
            r.default = c.extend().extend({
              name: "v-carousel-item",
              inject: {
                parentTheme: {
                  default: {
                    isDark: !1
                  }
                }
              },
              // pass down the parent's theme
              provide: function() {
                return {
                  theme: this.parentTheme
                };
              },
              inheritAttrs: !1,
              methods: {
                genDefaultSlot: function() {
                  return [this.$createElement(o.VImg, {
                    staticClass: "v-carousel__item",
                    props: u(u({}, this.$attrs), {
                      height: this.windowGroup.internalHeight
                    }),
                    on: this.$listeners,
                    scopedSlots: {
                      placeholder: this.$scopedSlots.placeholder
                    }
                  }, Object(f.getSlot)(this))];
                },
                genWindowItem: function() {
                  var p = this.generateRouteLink(), g = p.tag, m = p.data;
                  return m.staticClass = "v-window-item", m.directives.push({
                    name: "show",
                    value: this.isActive
                  }), this.$createElement(g, m, this.genDefaultSlot());
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCarousel/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCarousel/index.ts ***!
            \*******************************************/
          /*! exports provided: VCarousel, VCarouselItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCarousel */
              "./src/components/VCarousel/VCarousel.ts"
            );
            i.d(r, "VCarousel", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCarouselItem */
              "./src/components/VCarousel/VCarouselItem.ts"
            );
            i.d(r, "VCarouselItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCarousel: a.default,
                VCarouselItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VCheckbox/VCheckbox.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VCheckbox/VCheckbox.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCheckbox/VCheckbox.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCheckbox/VCheckbox.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCheckbox.sass */
              "./src/components/VCheckbox/VCheckbox.sass"
            ), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), l = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            }, d = function(u, c) {
              var h = {};
              for (var p in u)
                Object.prototype.hasOwnProperty.call(u, p) && c.indexOf(p) < 0 && (h[p] = u[p]);
              if (u != null && typeof Object.getOwnPropertySymbols == "function")
                for (var g = 0, p = Object.getOwnPropertySymbols(u); g < p.length; g++)
                  c.indexOf(p[g]) < 0 && Object.prototype.propertyIsEnumerable.call(u, p[g]) && (h[p[g]] = u[p[g]]);
              return h;
            };
            r.default = l.default.extend({
              name: "v-checkbox",
              props: {
                indeterminate: Boolean,
                indeterminateIcon: {
                  type: String,
                  default: "$checkboxIndeterminate"
                },
                offIcon: {
                  type: String,
                  default: "$checkboxOff"
                },
                onIcon: {
                  type: String,
                  default: "$checkboxOn"
                }
              },
              data: function() {
                return {
                  inputIndeterminate: this.indeterminate
                };
              },
              computed: {
                classes: function() {
                  return f(f({}, o.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls": !0,
                    "v-input--checkbox": !0,
                    "v-input--indeterminate": this.inputIndeterminate
                  });
                },
                computedIcon: function() {
                  return this.inputIndeterminate ? this.indeterminateIcon : this.isActive ? this.onIcon : this.offIcon;
                },
                // Do not return undefined if disabled,
                // according to spec, should still show
                // a color when disabled and active
                validationState: function() {
                  if (!(this.isDisabled && !this.inputIndeterminate)) {
                    if (this.hasError && this.shouldValidate)
                      return "error";
                    if (this.hasSuccess)
                      return "success";
                    if (this.hasColor !== null)
                      return this.computedColor;
                  }
                }
              },
              watch: {
                indeterminate: function(c) {
                  var h = this;
                  this.$nextTick(function() {
                    return h.inputIndeterminate = c;
                  });
                },
                inputIndeterminate: function(c) {
                  this.$emit("update:indeterminate", c);
                },
                isActive: function() {
                  this.indeterminate && (this.inputIndeterminate = !1);
                }
              },
              methods: {
                genCheckbox: function() {
                  var c = this.attrs$;
                  c.title;
                  var h = d(c, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.$createElement(a.default, this.setTextColor(this.validationState, {
                    props: {
                      dense: this.dense,
                      dark: this.dark,
                      light: this.light
                    }
                  }), this.computedIcon), this.genInput("checkbox", f(f({}, h), {
                    "aria-checked": this.inputIndeterminate ? "mixed" : this.isActive.toString()
                  })), this.genRipple(this.setTextColor(this.rippleState))]);
                },
                genDefaultSlot: function() {
                  return [this.genCheckbox(), this.genLabel()];
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCheckbox/VSimpleCheckbox.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VCheckbox/VSimpleCheckbox.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCheckbox/VSimpleCheckbox.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VCheckbox/VSimpleCheckbox.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSimpleCheckbox.sass */
              "./src/components/VCheckbox/VSimpleCheckbox.sass"
            );
            var a = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o), f = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), d = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = l.a.extend({
              name: "v-simple-checkbox",
              functional: !0,
              directives: {
                Ripple: a.default
              },
              props: p(p(p({}, d.default.options.props), u.default.options.props), {
                disabled: Boolean,
                ripple: {
                  type: Boolean,
                  default: !0
                },
                value: Boolean,
                indeterminate: Boolean,
                indeterminateIcon: {
                  type: String,
                  default: "$checkboxIndeterminate"
                },
                onIcon: {
                  type: String,
                  default: "$checkboxOn"
                },
                offIcon: {
                  type: String,
                  default: "$checkboxOff"
                }
              }),
              render: function(m, v) {
                var y = v.props, E = v.data;
                v.listeners;
                var C = [], x = y.offIcon;
                if (y.indeterminate ? x = y.indeterminateIcon : y.value && (x = y.onIcon), C.push(m(f.VIcon, d.default.options.methods.setTextColor(y.value && y.color, {
                  props: {
                    disabled: y.disabled,
                    dark: y.dark,
                    light: y.light
                  }
                }), x)), y.ripple && !y.disabled) {
                  var b = m("div", d.default.options.methods.setTextColor(y.color, {
                    staticClass: "v-input--selection-controls__ripple",
                    directives: [{
                      def: a.default,
                      name: "ripple",
                      value: {
                        center: !0
                      }
                    }]
                  }));
                  C.push(b);
                }
                return m("div", Object(c.default)(E, {
                  class: {
                    "v-simple-checkbox": !0,
                    "v-simple-checkbox--disabled": y.disabled
                  },
                  on: {
                    click: function(O) {
                      O.stopPropagation(), E.on && E.on.input && !y.disabled && Object(h.wrapInArray)(E.on.input).forEach(function(T) {
                        return T(!y.value);
                      });
                    }
                  }
                }), [m("div", {
                  staticClass: "v-input--selection-controls__input"
                }, C)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VCheckbox/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCheckbox/index.ts ***!
            \*******************************************/
          /*! exports provided: VCheckbox, VSimpleCheckbox, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCheckbox */
              "./src/components/VCheckbox/VCheckbox.ts"
            );
            i.d(r, "VCheckbox", function() {
              return a.default;
            });
            var o = i(
              /*! ./VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            );
            i.d(r, "VSimpleCheckbox", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VCheckbox: a.default,
                VSimpleCheckbox: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VChip/VChip.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VChip/VChip.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VChip/VChip.ts": (
          /*!***************************************!*\
            !*** ./src/components/VChip/VChip.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VChip.sass */
              "./src/components/VChip/VChip.sass"
            );
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), h = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), p = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = function() {
              return m = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, m.apply(this, arguments);
            }, v = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], O;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (T) {
                O = {
                  error: T
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (O)
                    throw O.error;
                }
              }
              return P;
            };
            r.default = Object(a.default)(f.default, p.default, h.default, u.default, Object(d.factory)("chipGroup"), Object(c.factory)("inputValue")).extend({
              name: "v-chip",
              props: {
                active: {
                  type: Boolean,
                  default: !0
                },
                activeClass: {
                  type: String,
                  default: function() {
                    return this.chipGroup ? this.chipGroup.activeClass : "";
                  }
                },
                close: Boolean,
                closeIcon: {
                  type: String,
                  default: "$delete"
                },
                closeLabel: {
                  type: String,
                  default: "$vuetify.close"
                },
                disabled: Boolean,
                draggable: Boolean,
                filter: Boolean,
                filterIcon: {
                  type: String,
                  default: "$complete"
                },
                label: Boolean,
                link: Boolean,
                outlined: Boolean,
                pill: Boolean,
                tag: {
                  type: String,
                  default: "span"
                },
                textColor: String,
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-chip--active"
                };
              },
              computed: {
                classes: function() {
                  return m(m(m(m(m({
                    "v-chip": !0
                  }, h.default.options.computed.classes.call(this)), {
                    "v-chip--clickable": this.isClickable,
                    "v-chip--disabled": this.disabled,
                    "v-chip--draggable": this.draggable,
                    "v-chip--label": this.label,
                    "v-chip--link": this.isLink,
                    "v-chip--no-color": !this.color,
                    "v-chip--outlined": this.outlined,
                    "v-chip--pill": this.pill,
                    "v-chip--removable": this.hasClose
                  }), this.themeClasses), this.sizeableClasses), this.groupClasses);
                },
                hasClose: function() {
                  return !!this.close;
                },
                isClickable: function() {
                  return !!(h.default.options.computed.isClickable.call(this) || this.chipGroup);
                }
              },
              created: function() {
                var E = this, C = [["outline", "outlined"], ["selected", "input-value"], ["value", "active"], ["@input", "@active.sync"]];
                C.forEach(function(x) {
                  var b = v(x, 2), P = b[0], O = b[1];
                  E.$attrs.hasOwnProperty(P) && Object(g.breaking)(P, O, E);
                });
              },
              methods: {
                click: function(E) {
                  this.$emit("click", E), this.chipGroup && this.toggle();
                },
                genFilter: function() {
                  var E = [];
                  return this.isActive && E.push(this.$createElement(l.default, {
                    staticClass: "v-chip__filter",
                    props: {
                      left: !0
                    }
                  }, this.filterIcon)), this.$createElement(o.VExpandXTransition, E);
                },
                genClose: function() {
                  var E = this;
                  return this.$createElement(l.default, {
                    staticClass: "v-chip__close",
                    props: {
                      right: !0,
                      size: 18
                    },
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.closeLabel)
                    },
                    on: {
                      click: function(x) {
                        x.stopPropagation(), x.preventDefault(), E.$emit("click:close"), E.$emit("update:active", !1);
                      }
                    }
                  }, this.closeIcon);
                },
                genContent: function() {
                  return this.$createElement("span", {
                    staticClass: "v-chip__content"
                  }, [this.filter && this.genFilter(), this.$slots.default, this.hasClose && this.genClose()]);
                }
              },
              render: function(E) {
                var C = [this.genContent()], x = this.generateRouteLink(), b = x.tag, P = x.data;
                P.attrs = m(m({}, P.attrs), {
                  draggable: this.draggable ? "true" : void 0,
                  tabindex: this.chipGroup && !this.disabled ? 0 : P.attrs.tabindex
                }), P.directives.push({
                  name: "show",
                  value: this.active
                }), P = this.setBackgroundColor(this.color, P);
                var O = this.textColor || this.outlined && this.color;
                return E(b, this.setTextColor(O, P), C);
              }
            });
          }
        ),
        /***/
        "./src/components/VChip/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VChip/index.ts ***!
            \***************************************/
          /*! exports provided: VChip, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VChip */
              "./src/components/VChip/VChip.ts"
            );
            i.d(r, "VChip", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VChipGroup/VChipGroup.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VChipGroup/VChipGroup.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VChipGroup/VChipGroup.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VChipGroup/VChipGroup.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VChipGroup.sass */
              "./src/components/VChipGroup/VChipGroup.sass"
            );
            var a = i(
              /*! ../VSlideGroup/VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.BaseSlideGroup, o.default).extend({
              name: "v-chip-group",
              provide: function() {
                return {
                  chipGroup: this
                };
              },
              props: {
                column: Boolean
              },
              computed: {
                classes: function() {
                  return f(f({}, a.BaseSlideGroup.options.computed.classes.call(this)), {
                    "v-chip-group": !0,
                    "v-chip-group--column": this.column
                  });
                }
              },
              watch: {
                column: function(u) {
                  u && (this.scrollOffset = 0), this.$nextTick(this.onResize);
                }
              },
              methods: {
                genData: function() {
                  return this.setTextColor(this.color, f({}, a.BaseSlideGroup.options.methods.genData.call(this)));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VChipGroup/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VChipGroup/index.ts ***!
            \********************************************/
          /*! exports provided: VChipGroup, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VChipGroup */
              "./src/components/VChipGroup/VChipGroup.ts"
            );
            i.d(r, "VChipGroup", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPicker.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VColorPicker/VColorPicker.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPicker.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VColorPicker/VColorPicker.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPicker.sass */
              "./src/components/VColorPicker/VColorPicker.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ./VColorPickerPreview */
              "./src/components/VColorPicker/VColorPickerPreview.ts"
            ), l = i(
              /*! ./VColorPickerCanvas */
              "./src/components/VColorPicker/VColorPickerCanvas.ts"
            ), f = i(
              /*! ./VColorPickerEdit */
              "./src/components/VColorPicker/VColorPickerEdit.ts"
            ), d = i(
              /*! ./VColorPickerSwatches */
              "./src/components/VColorPicker/VColorPickerSwatches.ts"
            ), u = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), g = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), m = function() {
              return m = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, m.apply(this, arguments);
            };
            r.default = Object(c.default)(p.default, g.default).extend({
              name: "v-color-picker",
              props: {
                canvasHeight: {
                  type: [String, Number],
                  default: 150
                },
                disabled: Boolean,
                dotSize: {
                  type: [Number, String],
                  default: 10
                },
                flat: Boolean,
                hideCanvas: Boolean,
                hideSliders: Boolean,
                hideInputs: Boolean,
                hideModeSwitch: Boolean,
                mode: {
                  type: String,
                  default: "rgba",
                  validator: function(y) {
                    return Object.keys(f.modes).includes(y);
                  }
                },
                showSwatches: Boolean,
                swatches: Array,
                swatchesMaxHeight: {
                  type: [Number, String],
                  default: 150
                },
                value: {
                  type: [Object, String]
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  internalValue: Object(u.fromRGBA)({
                    r: 255,
                    g: 0,
                    b: 0,
                    a: 1
                  })
                };
              },
              computed: {
                hideAlpha: function() {
                  return this.value ? !Object(u.hasAlpha)(this.value) : !1;
                }
              },
              watch: {
                value: {
                  handler: function(y) {
                    this.updateColor(Object(u.parseColor)(y, this.internalValue));
                  },
                  immediate: !0
                }
              },
              methods: {
                updateColor: function(y) {
                  this.internalValue = y;
                  var E = Object(u.extractColor)(this.internalValue, this.value);
                  Object(h.deepEqual)(E, this.value) || (this.$emit("input", E), this.$emit("update:color", this.internalValue));
                },
                genCanvas: function() {
                  return this.$createElement(l.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      dotSize: this.dotSize,
                      width: this.width,
                      height: this.canvasHeight
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                },
                genControls: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__controls"
                  }, [!this.hideSliders && this.genPreview(), !this.hideInputs && this.genEdit()]);
                },
                genEdit: function() {
                  var y = this;
                  return this.$createElement(f.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      hideAlpha: this.hideAlpha,
                      hideModeSwitch: this.hideModeSwitch,
                      mode: this.mode
                    },
                    on: {
                      "update:color": this.updateColor,
                      "update:mode": function(C) {
                        return y.$emit("update:mode", C);
                      }
                    }
                  });
                },
                genPreview: function() {
                  return this.$createElement(o.default, {
                    props: {
                      color: this.internalValue,
                      disabled: this.disabled,
                      hideAlpha: this.hideAlpha
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                },
                genSwatches: function() {
                  return this.$createElement(d.default, {
                    props: {
                      dark: this.dark,
                      light: this.light,
                      disabled: this.disabled,
                      swatches: this.swatches,
                      color: this.internalValue,
                      maxHeight: this.swatchesMaxHeight
                    },
                    on: {
                      "update:color": this.updateColor
                    }
                  });
                }
              },
              render: function(y) {
                return y(a.default, {
                  staticClass: "v-color-picker",
                  class: m(m({
                    "v-color-picker--flat": this.flat
                  }, this.themeClasses), this.elevationClasses),
                  props: {
                    maxWidth: this.width
                  }
                }, [!this.hideCanvas && this.genCanvas(), (!this.hideSliders || !this.hideInputs) && this.genControls(), this.showSwatches && this.genSwatches()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerCanvas.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerCanvas.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerCanvas.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerCanvas.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerCanvas.sass */
              "./src/components/VColorPicker/VColorPickerCanvas.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend({
              name: "v-color-picker-canvas",
              props: {
                color: {
                  type: Object,
                  default: function() {
                    return Object(o.fromRGBA)({
                      r: 255,
                      g: 0,
                      b: 0,
                      a: 1
                    });
                  }
                },
                disabled: Boolean,
                dotSize: {
                  type: [Number, String],
                  default: 10
                },
                height: {
                  type: [Number, String],
                  default: 150
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  boundingRect: {
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                  }
                };
              },
              computed: {
                dot: function() {
                  return this.color ? {
                    x: this.color.hsva.s * parseInt(this.width, 10),
                    y: (1 - this.color.hsva.v) * parseInt(this.height, 10)
                  } : {
                    x: 0,
                    y: 0
                  };
                }
              },
              watch: {
                "color.hue": "updateCanvas"
              },
              mounted: function() {
                this.updateCanvas();
              },
              methods: {
                emitColor: function(u, c) {
                  var h = this.boundingRect, p = h.left, g = h.top, m = h.width, v = h.height;
                  this.$emit("update:color", Object(o.fromHSVA)({
                    h: this.color.hue,
                    s: Object(a.clamp)(u - p, 0, m) / m,
                    v: 1 - Object(a.clamp)(c - g, 0, v) / v,
                    a: this.color.alpha
                  }));
                },
                updateCanvas: function() {
                  if (this.color) {
                    var u = this.$refs.canvas, c = u.getContext("2d");
                    if (c) {
                      var h = c.createLinearGradient(0, 0, u.width, 0);
                      h.addColorStop(0, "hsla(0, 0%, 100%, 1)"), h.addColorStop(1, "hsla(" + this.color.hue + ", 100%, 50%, 1)"), c.fillStyle = h, c.fillRect(0, 0, u.width, u.height);
                      var p = c.createLinearGradient(0, 0, 0, u.height);
                      p.addColorStop(0, "hsla(0, 0%, 100%, 0)"), p.addColorStop(1, "hsla(0, 0%, 0%, 1)"), c.fillStyle = p, c.fillRect(0, 0, u.width, u.height);
                    }
                  }
                },
                handleClick: function(u) {
                  this.disabled || (this.boundingRect = this.$el.getBoundingClientRect(), this.emitColor(u.clientX, u.clientY));
                },
                handleMouseDown: function(u) {
                  u.preventDefault(), !this.disabled && (this.boundingRect = this.$el.getBoundingClientRect(), window.addEventListener("mousemove", this.handleMouseMove), window.addEventListener("mouseup", this.handleMouseUp));
                },
                handleMouseMove: function(u) {
                  this.disabled || this.emitColor(u.clientX, u.clientY);
                },
                handleMouseUp: function() {
                  window.removeEventListener("mousemove", this.handleMouseMove), window.removeEventListener("mouseup", this.handleMouseUp);
                },
                genCanvas: function() {
                  return this.$createElement("canvas", {
                    ref: "canvas",
                    attrs: {
                      width: this.width,
                      height: this.height
                    }
                  });
                },
                genDot: function() {
                  var u = parseInt(this.dotSize, 10) / 2, c = Object(a.convertToUnit)(this.dot.x - u), h = Object(a.convertToUnit)(this.dot.y - u);
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__canvas-dot",
                    class: {
                      "v-color-picker__canvas-dot--disabled": this.disabled
                    },
                    style: {
                      width: Object(a.convertToUnit)(this.dotSize),
                      height: Object(a.convertToUnit)(this.dotSize),
                      transform: "translate(" + c + ", " + h + ")"
                    }
                  });
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-color-picker__canvas",
                  style: {
                    width: Object(a.convertToUnit)(this.width),
                    height: Object(a.convertToUnit)(this.height)
                  },
                  on: {
                    click: this.handleClick,
                    mousedown: this.handleMouseDown
                  }
                }, [this.genCanvas(), this.genDot()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerEdit.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerEdit.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerEdit.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerEdit.ts ***!
            \*********************************************************/
          /*! exports provided: modes, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "modes", function() {
              return h;
            }), i(
              /*! ./VColorPickerEdit.sass */
              "./src/components/VColorPicker/VColorPickerEdit.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), c = function(p, g) {
              var m = typeof Symbol == "function" && p[Symbol.iterator];
              if (!m)
                return p;
              var v = m.call(p), y, E = [], C;
              try {
                for (; (g === void 0 || g-- > 0) && !(y = v.next()).done; )
                  E.push(y.value);
              } catch (x) {
                C = {
                  error: x
                };
              } finally {
                try {
                  y && !y.done && (m = v.return) && m.call(v);
                } finally {
                  if (C)
                    throw C.error;
                }
              }
              return E;
            }, h = {
              rgba: {
                inputs: [["r", 255, "int"], ["g", 255, "int"], ["b", 255, "int"], ["a", 1, "float"]],
                from: u.fromRGBA
              },
              hsla: {
                inputs: [["h", 360, "int"], ["s", 1, "float"], ["l", 1, "float"], ["a", 1, "float"]],
                from: u.fromHSLA
              },
              hexa: {
                from: u.fromHexa
              }
            };
            r.default = d.a.extend({
              name: "v-color-picker-edit",
              props: {
                color: Object,
                disabled: Boolean,
                hideAlpha: Boolean,
                hideModeSwitch: Boolean,
                mode: {
                  type: String,
                  default: "rgba",
                  validator: function(g) {
                    return Object.keys(h).includes(g);
                  }
                }
              },
              data: function() {
                return {
                  modes: h,
                  internalMode: this.mode
                };
              },
              computed: {
                currentMode: function() {
                  return this.modes[this.internalMode];
                }
              },
              watch: {
                mode: function(g) {
                  this.internalMode = g;
                }
              },
              created: function() {
                this.internalMode = this.mode;
              },
              methods: {
                getValue: function(g, m) {
                  return m === "float" ? Math.round(g * 100) / 100 : m === "int" ? Math.round(g) : 0;
                },
                parseValue: function(g, m) {
                  return m === "float" ? parseFloat(g) : m === "int" && parseInt(g, 10) || 0;
                },
                changeMode: function() {
                  var g = Object.keys(this.modes), m = g.indexOf(this.internalMode), v = g[(m + 1) % g.length];
                  this.internalMode = v, this.$emit("update:mode", v);
                },
                genInput: function(g, m, v, y) {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__input"
                  }, [this.$createElement("input", {
                    key: g,
                    attrs: m,
                    domProps: {
                      value: v
                    },
                    on: y
                  }), this.$createElement("span", g.toUpperCase())]);
                },
                genInputs: function() {
                  var g = this;
                  if (this.internalMode === "hexa") {
                    var m = this.color.hexa, v = this.hideAlpha && m.endsWith("FF") ? m.substr(0, 7) : m;
                    return this.genInput("hex", {
                      maxlength: this.hideAlpha ? 7 : 9,
                      disabled: this.disabled
                    }, v, {
                      change: function(C) {
                        var x = C.target;
                        g.$emit("update:color", g.currentMode.from(Object(l.parseHex)(x.value)));
                      }
                    });
                  } else {
                    var y = this.hideAlpha ? this.currentMode.inputs.slice(0, -1) : this.currentMode.inputs;
                    return y.map(function(E) {
                      var C = c(E, 3), x = C[0], b = C[1], P = C[2], O = g.color[g.internalMode];
                      return g.genInput(x, {
                        type: "number",
                        min: 0,
                        max: b,
                        step: P === "float" ? "0.01" : P === "int" ? "1" : void 0,
                        disabled: g.disabled
                      }, g.getValue(O[x], P), {
                        input: function(M) {
                          var L, A = M.target, D = g.parseValue(A.value || "0", P);
                          g.$emit("update:color", g.currentMode.from(Object.assign({}, O, (L = {}, L[x] = D, L)), g.color.alpha));
                        }
                      });
                    });
                  }
                },
                genSwitch: function() {
                  return this.$createElement(a.default, {
                    props: {
                      small: !0,
                      icon: !0,
                      disabled: this.disabled
                    },
                    on: {
                      click: this.changeMode
                    }
                  }, [this.$createElement(o.default, "$unfold")]);
                }
              },
              render: function(g) {
                return g("div", {
                  staticClass: "v-color-picker__edit"
                }, [this.genInputs(), !this.hideModeSwitch && this.genSwitch()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerPreview.sass": (
          /*!**************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerPreview.sass ***!
            \**************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerPreview.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerPreview.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerPreview.sass */
              "./src/components/VColorPicker/VColorPickerPreview.sass"
            );
            var a = i(
              /*! ../VSlider/VSlider */
              "./src/components/VSlider/VSlider.ts"
            ), o = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l), d = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = f.a.extend({
              name: "v-color-picker-preview",
              props: {
                color: Object,
                disabled: Boolean,
                hideAlpha: Boolean
              },
              methods: {
                genAlpha: function() {
                  var h = this;
                  return this.genTrack({
                    staticClass: "v-color-picker__alpha",
                    props: {
                      thumbColor: "grey lighten-2",
                      hideDetails: !0,
                      value: this.color.alpha,
                      step: 0,
                      min: 0,
                      max: 1
                    },
                    style: {
                      backgroundImage: this.disabled ? void 0 : "linear-gradient(to " + (this.$vuetify.rtl ? "left" : "right") + ", transparent, " + Object(o.RGBtoCSS)(this.color.rgba) + ")"
                    },
                    on: {
                      input: function(g) {
                        return h.color.alpha !== g && h.$emit("update:color", Object(d.fromHSVA)(u(u({}, h.color.hsva), {
                          a: g
                        })));
                      }
                    }
                  });
                },
                genSliders: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__sliders"
                  }, [this.genHue(), !this.hideAlpha && this.genAlpha()]);
                },
                genDot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__dot"
                  }, [this.$createElement("div", {
                    style: {
                      background: Object(o.RGBAtoCSS)(this.color.rgba)
                    }
                  })]);
                },
                genHue: function() {
                  var h = this;
                  return this.genTrack({
                    staticClass: "v-color-picker__hue",
                    props: {
                      thumbColor: "grey lighten-2",
                      hideDetails: !0,
                      value: this.color.hue,
                      step: 0,
                      min: 0,
                      max: 360
                    },
                    on: {
                      input: function(g) {
                        return h.color.hue !== g && h.$emit("update:color", Object(d.fromHSVA)(u(u({}, h.color.hsva), {
                          h: g
                        })));
                      }
                    }
                  });
                },
                genTrack: function(h) {
                  return this.$createElement(a.default, u(u({
                    class: "v-color-picker__track"
                  }, h), {
                    props: u({
                      disabled: this.disabled
                    }, h.props)
                  }));
                }
              },
              render: function(h) {
                return h("div", {
                  staticClass: "v-color-picker__preview",
                  class: {
                    "v-color-picker__preview--hide-alpha": this.hideAlpha
                  }
                }, [this.genDot(), this.genSliders()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerSwatches.sass": (
          /*!***************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerSwatches.sass ***!
            \***************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VColorPicker/VColorPickerSwatches.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VColorPicker/VColorPickerSwatches.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VColorPickerSwatches.sass */
              "./src/components/VColorPicker/VColorPickerSwatches.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../util/colors */
              "./src/util/colors.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VColorPicker/util/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            );
            function h(m) {
              return Object.keys(m).map(function(v) {
                var y = m[v];
                return y.base ? [y.base, y.darken4, y.darken3, y.darken2, y.darken1, y.lighten1, y.lighten2, y.lighten3, y.lighten4, y.lighten5] : [y.black, y.white, y.transparent];
              });
            }
            var p = Object(l.fromHex)("#FFFFFF").rgba, g = Object(l.fromHex)("#000000").rgba;
            r.default = Object(d.default)(u.default).extend({
              name: "v-color-picker-swatches",
              props: {
                swatches: {
                  type: Array,
                  default: function() {
                    return h(o.default);
                  }
                },
                disabled: Boolean,
                color: Object,
                maxWidth: [Number, String],
                maxHeight: [Number, String]
              },
              methods: {
                genColor: function(v) {
                  var y = this, E = this.$createElement("div", {
                    style: {
                      background: v
                    }
                  }, [Object(f.deepEqual)(this.color, Object(l.parseColor)(v, null)) && this.$createElement(a.default, {
                    props: {
                      small: !0,
                      dark: Object(c.contrastRatio)(this.color.rgba, p) > 2 && this.color.alpha > 0.5,
                      light: Object(c.contrastRatio)(this.color.rgba, g) > 2 && this.color.alpha > 0.5
                    }
                  }, "$success")]);
                  return this.$createElement("div", {
                    staticClass: "v-color-picker__color",
                    on: {
                      // TODO: Less hacky way of catching transparent
                      click: function() {
                        return y.disabled || y.$emit("update:color", Object(l.fromHex)(v === "transparent" ? "#00000000" : v));
                      }
                    }
                  }, [E]);
                },
                genSwatches: function() {
                  var v = this;
                  return this.swatches.map(function(y) {
                    var E = y.map(v.genColor);
                    return v.$createElement("div", {
                      staticClass: "v-color-picker__swatch"
                    }, E);
                  });
                }
              },
              render: function(v) {
                return v("div", {
                  staticClass: "v-color-picker__swatches",
                  style: {
                    maxWidth: Object(f.convertToUnit)(this.maxWidth),
                    maxHeight: Object(f.convertToUnit)(this.maxHeight)
                  }
                }, [this.$createElement("div", this.genSwatches())]);
              }
            });
          }
        ),
        /***/
        "./src/components/VColorPicker/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VColorPicker/index.ts ***!
            \**********************************************/
          /*! exports provided: VColorPicker, VColorPickerSwatches, VColorPickerCanvas, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VColorPicker */
              "./src/components/VColorPicker/VColorPicker.ts"
            );
            i.d(r, "VColorPicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VColorPickerSwatches */
              "./src/components/VColorPicker/VColorPickerSwatches.ts"
            );
            i.d(r, "VColorPickerSwatches", function() {
              return o.default;
            });
            var l = i(
              /*! ./VColorPickerCanvas */
              "./src/components/VColorPicker/VColorPickerCanvas.ts"
            );
            i.d(r, "VColorPickerCanvas", function() {
              return l.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VColorPicker/util/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VColorPicker/util/index.ts ***!
            \***************************************************/
          /*! exports provided: fromHSVA, fromHSLA, fromRGBA, fromHexa, fromHex, parseColor, extractColor, hasAlpha */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromHSVA", function() {
              return d;
            }), i.d(r, "fromHSLA", function() {
              return u;
            }), i.d(r, "fromRGBA", function() {
              return c;
            }), i.d(r, "fromHexa", function() {
              return h;
            }), i.d(r, "fromHex", function() {
              return p;
            }), i.d(r, "parseColor", function() {
              return m;
            }), i.d(r, "extractColor", function() {
              return y;
            }), i.d(r, "hasAlpha", function() {
              return E;
            });
            var a = i(
              /*! ../../../util/colorUtils */
              "./src/util/colorUtils.ts"
            );
            function o(C) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(b) {
                return typeof b;
              } : o = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
              }, o(C);
            }
            var l = function() {
              return l = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var O in x)
                    Object.prototype.hasOwnProperty.call(x, O) && (C[O] = x[O]);
                }
                return C;
              }, l.apply(this, arguments);
            }, f = function(C, x) {
              var b = {};
              for (var P in C)
                Object.prototype.hasOwnProperty.call(C, P) && x.indexOf(P) < 0 && (b[P] = C[P]);
              if (C != null && typeof Object.getOwnPropertySymbols == "function")
                for (var O = 0, P = Object.getOwnPropertySymbols(C); O < P.length; O++)
                  x.indexOf(P[O]) < 0 && Object.prototype.propertyIsEnumerable.call(C, P[O]) && (b[P[O]] = C[P[O]]);
              return b;
            };
            function d(C) {
              C = l({}, C);
              var x = Object(a.HSVAtoHex)(C), b = Object(a.HSVAtoHSLA)(C), P = Object(a.HSVAtoRGBA)(C);
              return {
                alpha: C.a,
                hex: x.substr(0, 7),
                hexa: x,
                hsla: b,
                hsva: C,
                hue: C.h,
                rgba: P
              };
            }
            function u(C) {
              var x = Object(a.HSLAtoHSVA)(C), b = Object(a.HSVAtoHex)(x), P = Object(a.HSVAtoRGBA)(x);
              return {
                alpha: x.a,
                hex: b.substr(0, 7),
                hexa: b,
                hsla: C,
                hsva: x,
                hue: x.h,
                rgba: P
              };
            }
            function c(C) {
              var x = Object(a.RGBAtoHSVA)(C), b = Object(a.RGBAtoHex)(C), P = Object(a.HSVAtoHSLA)(x);
              return {
                alpha: x.a,
                hex: b.substr(0, 7),
                hexa: b,
                hsla: P,
                hsva: x,
                hue: x.h,
                rgba: C
              };
            }
            function h(C) {
              var x = Object(a.HexToHSVA)(C), b = Object(a.HSVAtoHSLA)(x), P = Object(a.HSVAtoRGBA)(x);
              return {
                alpha: x.a,
                hex: C.substr(0, 7),
                hexa: C,
                hsla: b,
                hsva: x,
                hue: x.h,
                rgba: P
              };
            }
            function p(C) {
              return h(Object(a.parseHex)(C));
            }
            function g(C, x) {
              return x.every(function(b) {
                return C.hasOwnProperty(b);
              });
            }
            function m(C, x) {
              if (!C)
                return c({
                  r: 255,
                  g: 0,
                  b: 0,
                  a: 1
                });
              if (typeof C == "string") {
                if (C === "transparent")
                  return h("#00000000");
                var b = Object(a.parseHex)(C);
                return x && b === x.hexa ? x : h(b);
              }
              if (o(C) === "object") {
                if (C.hasOwnProperty("alpha"))
                  return C;
                var P = C.hasOwnProperty("a") ? parseFloat(C.a) : 1;
                if (g(C, ["r", "g", "b"]))
                  return x && C === x.rgba ? x : c(l(l({}, C), {
                    a: P
                  }));
                if (g(C, ["h", "s", "l"]))
                  return x && C === x.hsla ? x : u(l(l({}, C), {
                    a: P
                  }));
                if (g(C, ["h", "s", "v"]))
                  return x && C === x.hsva ? x : d(l(l({}, C), {
                    a: P
                  }));
              }
              return c({
                r: 255,
                g: 0,
                b: 0,
                a: 1
              });
            }
            function v(C, x) {
              if (x) {
                C.a;
                var b = f(C, ["a"]);
                return b;
              }
              return C;
            }
            function y(C, x) {
              if (x == null)
                return C;
              if (typeof x == "string")
                return x.length === 7 ? C.hex : C.hexa;
              if (o(x) === "object") {
                var b = typeof x.a == "number" && x.a === 0 ? !!x.a : !x.a;
                if (g(x, ["r", "g", "b"]))
                  return v(C.rgba, b);
                if (g(x, ["h", "s", "l"]))
                  return v(C.hsla, b);
                if (g(x, ["h", "s", "v"]))
                  return v(C.hsva, b);
              }
              return C;
            }
            function E(C) {
              return C ? typeof C == "string" ? C.length > 7 : o(C) === "object" ? g(C, ["a"]) || g(C, ["alpha"]) : !1 : !1;
            }
          }
        ),
        /***/
        "./src/components/VCombobox/VCombobox.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VCombobox/VCombobox.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VAutocomplete/VAutocomplete.sass */
              "./src/components/VAutocomplete/VAutocomplete.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VAutocomplete/VAutocomplete */
              "./src/components/VAutocomplete/VAutocomplete.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function f(u) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? f = function(h) {
                return typeof h;
              } : f = function(h) {
                return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
              }, f(u);
            }
            var d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = o.default.extend({
              name: "v-combobox",
              props: {
                delimiters: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                returnObject: {
                  type: Boolean,
                  default: !0
                }
              },
              data: function() {
                return {
                  editingIndex: -1
                };
              },
              computed: {
                computedCounterValue: function() {
                  return this.multiple ? this.selectedItems.length : (this.internalSearch || "").toString().length;
                },
                hasSlot: function() {
                  return a.default.options.computed.hasSlot.call(this) || this.multiple;
                },
                isAnyValueAllowed: function() {
                  return !0;
                },
                menuCanShow: function() {
                  return this.isFocused ? this.hasDisplayedItems || !!this.$slots["no-data"] && !this.hideNoData : !1;
                },
                searchIsDirty: function() {
                  return this.internalSearch != null;
                }
              },
              methods: {
                onInternalSearchChanged: function(c) {
                  if (c && this.multiple && this.delimiters.length) {
                    var h = this.delimiters.find(function(p) {
                      return c.endsWith(p);
                    });
                    h != null && (this.internalSearch = c.slice(0, c.length - h.length), this.updateTags());
                  }
                  this.updateMenuDimensions();
                },
                genInput: function() {
                  var c = o.default.options.methods.genInput.call(this);
                  return delete c.data.attrs.name, c.data.on.paste = this.onPaste, c;
                },
                genChipSelection: function(c, h) {
                  var p = this, g = a.default.options.methods.genChipSelection.call(this, c, h);
                  return this.multiple && (g.componentOptions.listeners = d(d({}, g.componentOptions.listeners), {
                    dblclick: function() {
                      p.editingIndex = h, p.internalSearch = p.getText(c), p.selectedIndex = -1;
                    }
                  })), g;
                },
                onChipInput: function(c) {
                  a.default.options.methods.onChipInput.call(this, c), this.editingIndex = -1;
                },
                // Requires a manual definition
                // to overwrite removal in v-autocomplete
                onEnterDown: function(c) {
                  c.preventDefault(), !(this.getMenuIndex() > -1) && this.$nextTick(this.updateSelf);
                },
                onKeyDown: function(c) {
                  var h = c.keyCode;
                  (c.ctrlKey || ![l.keyCodes.home, l.keyCodes.end].includes(h)) && a.default.options.methods.onKeyDown.call(this, c), this.multiple && h === l.keyCodes.left && this.$refs.input.selectionStart === 0 ? this.updateSelf() : h === l.keyCodes.enter && this.onEnterDown(c), this.changeSelectedIndex(h);
                },
                onTabDown: function(c) {
                  if (this.multiple && this.internalSearch && this.getMenuIndex() === -1)
                    return c.preventDefault(), c.stopPropagation(), this.updateTags();
                  o.default.options.methods.onTabDown.call(this, c);
                },
                selectItem: function(c) {
                  this.editingIndex > -1 ? this.updateEditing() : (o.default.options.methods.selectItem.call(this, c), this.internalSearch && this.multiple && this.getText(c).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase()) && (this.internalSearch = null));
                },
                setSelectedItems: function() {
                  this.internalValue == null || this.internalValue === "" ? this.selectedItems = [] : this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];
                },
                setValue: function(c) {
                  a.default.options.methods.setValue.call(this, c === void 0 ? this.internalSearch : c);
                },
                updateEditing: function() {
                  var c = this, h = this.internalValue.slice(), p = this.selectedItems.findIndex(function(m) {
                    return c.getText(m) === c.internalSearch;
                  });
                  if (p > -1) {
                    var g = f(h[p]) === "object" ? Object.assign({}, h[p]) : h[p];
                    h.splice(p, 1), h.push(g);
                  } else
                    h[this.editingIndex] = this.internalSearch;
                  this.setValue(h), this.editingIndex = -1, this.internalSearch = null;
                },
                updateCombobox: function() {
                  if (this.searchIsDirty) {
                    this.internalSearch !== this.getText(this.internalValue) && this.setValue();
                    var c = !!this.$scopedSlots.selection || this.hasChips;
                    c && (this.internalSearch = null);
                  }
                },
                updateSelf: function() {
                  this.multiple ? this.updateTags() : this.updateCombobox();
                },
                updateTags: function() {
                  var c = this, h = this.getMenuIndex();
                  if (!(h < 0 && !this.searchIsDirty || !this.internalSearch)) {
                    if (this.editingIndex > -1)
                      return this.updateEditing();
                    var p = this.selectedItems.findIndex(function(v) {
                      return c.internalSearch === c.getText(v);
                    }), g = p > -1 && f(this.selectedItems[p]) === "object" ? Object.assign({}, this.selectedItems[p]) : this.internalSearch;
                    if (p > -1) {
                      var m = this.internalValue.slice();
                      m.splice(p, 1), this.setValue(m);
                    }
                    if (h > -1)
                      return this.internalSearch = null;
                    this.selectItem(g), this.internalSearch = null;
                  }
                },
                onPaste: function(c) {
                  var h;
                  if (this.$emit("paste", c), !(!this.multiple || this.searchIsDirty)) {
                    var p = (h = c.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/vnd.vuetify.autocomplete.item+plain");
                    p && this.findExistingIndex(p) === -1 && (c.preventDefault(), a.default.options.methods.selectItem.call(this, p));
                  }
                },
                clearableCallback: function() {
                  this.editingIndex = -1, o.default.options.methods.clearableCallback.call(this);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VCombobox/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VCombobox/index.ts ***!
            \*******************************************/
          /*! exports provided: VCombobox, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCombobox */
              "./src/components/VCombobox/VCombobox.ts"
            );
            i.d(r, "VCombobox", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VContent/VContent.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VContent/VContent.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VMain/VMain */
              "./src/components/VMain/VMain.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = a.default.extend({
              name: "v-main",
              created: function() {
                Object(o.deprecate)("v-content", "v-main", this);
              },
              render: function(f) {
                var d = a.default.options.render.call(this, f);
                return d.data.staticClass += " v-content", d.children[0].data.staticClass += " v-content__wrap", f(d.tag, d.data, d.children);
              }
            });
          }
        ),
        /***/
        "./src/components/VContent/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VContent/index.ts ***!
            \******************************************/
          /*! exports provided: VContent, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VContent */
              "./src/components/VContent/VContent.ts"
            );
            i.d(r, "VContent", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VCounter/VCounter.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VCounter/VCounter.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VCounter/VCounter.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VCounter/VCounter.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VCounter.sass */
              "./src/components/VCounter/VCounter.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "v-counter",
              functional: !0,
              props: {
                value: {
                  type: [Number, String],
                  default: ""
                },
                max: [Number, String]
              },
              render: function(d, u) {
                var c = u.props, h = parseInt(c.max, 10), p = parseInt(c.value, 10), g = h ? p + " / " + h : String(c.value), m = h && p > h;
                return d("div", {
                  staticClass: "v-counter",
                  class: l({
                    "error--text": m
                  }, Object(a.functionalThemeClasses)(u))
                }, g);
              }
            });
          }
        ),
        /***/
        "./src/components/VCounter/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VCounter/index.ts ***!
            \******************************************/
          /*! exports provided: VCounter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VCounter */
              "./src/components/VCounter/VCounter.ts"
            );
            i.d(r, "VCounter", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VData/VData.ts": (
          /*!***************************************!*\
            !*** ./src/components/VData/VData.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o), f = function() {
              return f = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, f.apply(this, arguments);
            }, d = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, u = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            r.default = l.a.extend({
              name: "v-data",
              inheritAttrs: !1,
              props: {
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                options: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                },
                sortBy: {
                  type: [String, Array]
                },
                sortDesc: {
                  type: [Boolean, Array]
                },
                customSort: {
                  type: Function,
                  default: a.sortItems
                },
                mustSort: Boolean,
                multiSort: Boolean,
                page: {
                  type: Number,
                  default: 1
                },
                itemsPerPage: {
                  type: Number,
                  default: 10
                },
                groupBy: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                groupDesc: {
                  type: [Boolean, Array],
                  default: function() {
                    return [];
                  }
                },
                customGroup: {
                  type: Function,
                  default: a.groupItems
                },
                locale: {
                  type: String,
                  default: "en-US"
                },
                disableSort: Boolean,
                disablePagination: Boolean,
                disableFiltering: Boolean,
                search: String,
                customFilter: {
                  type: Function,
                  default: a.searchItems
                },
                serverItemsLength: {
                  type: Number,
                  default: -1
                }
              },
              data: function() {
                var h, p, g = {
                  page: this.page,
                  itemsPerPage: this.itemsPerPage,
                  sortBy: Object(a.wrapInArray)(this.sortBy),
                  sortDesc: Object(a.wrapInArray)(this.sortDesc),
                  groupBy: Object(a.wrapInArray)(this.groupBy),
                  groupDesc: Object(a.wrapInArray)(this.groupDesc),
                  mustSort: this.mustSort,
                  multiSort: this.multiSort
                };
                this.options && (g = Object.assign(g, this.options));
                var m = g.sortBy, v = g.sortDesc, y = g.groupBy, E = g.groupDesc, C = m.length - v.length, x = y.length - E.length;
                return C > 0 && (h = g.sortDesc).push.apply(h, u([], d(Object(a.fillArray)(C, !1)), !1)), x > 0 && (p = g.groupDesc).push.apply(p, u([], d(Object(a.fillArray)(x, !1)), !1)), {
                  internalOptions: g
                };
              },
              computed: {
                itemsLength: function() {
                  return this.serverItemsLength >= 0 ? this.serverItemsLength : this.filteredItems.length;
                },
                pageCount: function() {
                  return this.internalOptions.itemsPerPage <= 0 ? 1 : Math.ceil(this.itemsLength / this.internalOptions.itemsPerPage);
                },
                pageStart: function() {
                  return this.internalOptions.itemsPerPage === -1 || !this.items.length ? 0 : (this.internalOptions.page - 1) * this.internalOptions.itemsPerPage;
                },
                pageStop: function() {
                  return this.internalOptions.itemsPerPage === -1 ? this.itemsLength : this.items.length ? Math.min(this.itemsLength, this.internalOptions.page * this.internalOptions.itemsPerPage) : 0;
                },
                isGrouped: function() {
                  return !!this.internalOptions.groupBy.length;
                },
                pagination: function() {
                  return {
                    page: this.internalOptions.page,
                    itemsPerPage: this.internalOptions.itemsPerPage,
                    pageStart: this.pageStart,
                    pageStop: this.pageStop,
                    pageCount: this.pageCount,
                    itemsLength: this.itemsLength
                  };
                },
                filteredItems: function() {
                  var h = this.items.slice();
                  return !this.disableFiltering && this.serverItemsLength <= 0 && (h = this.customFilter(h, this.search)), h;
                },
                computedItems: function() {
                  var h = this.filteredItems.slice();
                  return (!this.disableSort || this.internalOptions.groupBy.length) && this.serverItemsLength <= 0 && (h = this.sortItems(h)), !this.disablePagination && this.serverItemsLength <= 0 && (h = this.paginateItems(h)), h;
                },
                groupedItems: function() {
                  return this.isGrouped ? this.groupItems(this.computedItems) : null;
                },
                scopedProps: function() {
                  return {
                    sort: this.sort,
                    sortArray: this.sortArray,
                    group: this.group,
                    items: this.computedItems,
                    options: this.internalOptions,
                    updateOptions: this.updateOptions,
                    pagination: this.pagination,
                    groupedItems: this.groupedItems,
                    originalItemsLength: this.items.length
                  };
                },
                computedOptions: function() {
                  return f({}, this.options);
                }
              },
              watch: {
                computedOptions: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.updateOptions(h);
                  },
                  deep: !0,
                  immediate: !0
                },
                internalOptions: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.$emit("update:options", h);
                  },
                  deep: !0,
                  immediate: !0
                },
                page: function(h) {
                  this.updateOptions({
                    page: h
                  });
                },
                "internalOptions.page": function(h) {
                  this.$emit("update:page", h);
                },
                itemsPerPage: function(h) {
                  this.updateOptions({
                    itemsPerPage: h
                  });
                },
                "internalOptions.itemsPerPage": function(h) {
                  this.$emit("update:items-per-page", h);
                },
                sortBy: function(h) {
                  this.updateOptions({
                    sortBy: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.sortBy": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:sort-by", Array.isArray(this.sortBy) ? h : h[0]);
                },
                sortDesc: function(h) {
                  this.updateOptions({
                    sortDesc: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.sortDesc": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:sort-desc", Array.isArray(this.sortDesc) ? h : h[0]);
                },
                groupBy: function(h) {
                  this.updateOptions({
                    groupBy: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.groupBy": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:group-by", Array.isArray(this.groupBy) ? h : h[0]);
                },
                groupDesc: function(h) {
                  this.updateOptions({
                    groupDesc: Object(a.wrapInArray)(h)
                  });
                },
                "internalOptions.groupDesc": function(h, p) {
                  !Object(a.deepEqual)(h, p) && this.$emit("update:group-desc", Array.isArray(this.groupDesc) ? h : h[0]);
                },
                multiSort: function(h) {
                  this.updateOptions({
                    multiSort: h
                  });
                },
                "internalOptions.multiSort": function(h) {
                  this.$emit("update:multi-sort", h);
                },
                mustSort: function(h) {
                  this.updateOptions({
                    mustSort: h
                  });
                },
                "internalOptions.mustSort": function(h) {
                  this.$emit("update:must-sort", h);
                },
                pageCount: {
                  handler: function(h) {
                    this.$emit("page-count", h);
                  },
                  immediate: !0
                },
                computedItems: {
                  handler: function(h) {
                    this.$emit("current-items", h);
                  },
                  immediate: !0
                },
                pagination: {
                  handler: function(h, p) {
                    Object(a.deepEqual)(h, p) || this.$emit("pagination", this.pagination);
                  },
                  immediate: !0
                }
              },
              methods: {
                toggle: function(h, p, g, m, v, y) {
                  var E = p.slice(), C = g.slice(), x = E.findIndex(function(b) {
                    return b === h;
                  });
                  return x < 0 ? (y || (E = [], C = []), E.push(h), C.push(!1)) : x >= 0 && !C[x] ? C[x] = !0 : v ? C[x] = !1 : (E.splice(x, 1), C.splice(x, 1)), (!Object(a.deepEqual)(E, p) || !Object(a.deepEqual)(C, g)) && (m = 1), {
                    by: E,
                    desc: C,
                    page: m
                  };
                },
                group: function(h) {
                  var p = this.toggle(h, this.internalOptions.groupBy, this.internalOptions.groupDesc, this.internalOptions.page, !0, !1), g = p.by, m = p.desc, v = p.page;
                  this.updateOptions({
                    groupBy: g,
                    groupDesc: m,
                    page: v
                  });
                },
                sort: function(h) {
                  if (Array.isArray(h))
                    return this.sortArray(h);
                  var p = this.toggle(h, this.internalOptions.sortBy, this.internalOptions.sortDesc, this.internalOptions.page, this.internalOptions.mustSort, this.internalOptions.multiSort), g = p.by, m = p.desc, v = p.page;
                  this.updateOptions({
                    sortBy: g,
                    sortDesc: m,
                    page: v
                  });
                },
                sortArray: function(h) {
                  var p = this, g = h.map(function(m) {
                    var v = p.internalOptions.sortBy.findIndex(function(y) {
                      return y === m;
                    });
                    return v > -1 ? p.internalOptions.sortDesc[v] : !1;
                  });
                  this.updateOptions({
                    sortBy: h,
                    sortDesc: g
                  });
                },
                updateOptions: function(h) {
                  this.internalOptions = f(f(f({}, this.internalOptions), h), {
                    page: this.serverItemsLength < 0 ? Math.max(1, Math.min(h.page || this.internalOptions.page, this.pageCount)) : h.page || this.internalOptions.page
                  });
                },
                sortItems: function(h) {
                  var p = [], g = [];
                  return this.disableSort || (p = this.internalOptions.sortBy, g = this.internalOptions.sortDesc), this.internalOptions.groupBy.length && (p = u(u([], d(this.internalOptions.groupBy), !1), d(p), !1), g = u(u([], d(this.internalOptions.groupDesc), !1), d(g), !1)), this.customSort(h, p, g, this.locale);
                },
                groupItems: function(h) {
                  return this.customGroup(h, this.internalOptions.groupBy, this.internalOptions.groupDesc);
                },
                paginateItems: function(h) {
                  return this.serverItemsLength === -1 && h.length <= this.pageStart && (this.internalOptions.page = Math.max(1, Math.ceil(h.length / this.internalOptions.itemsPerPage)) || 1), h.slice(this.pageStart, this.pageStop);
                }
              },
              render: function() {
                return this.$scopedSlots.default && this.$scopedSlots.default(this.scopedProps);
              }
            });
          }
        ),
        /***/
        "./src/components/VData/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VData/index.ts ***!
            \***************************************/
          /*! exports provided: VData, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VData */
              "./src/components/VData/VData.ts"
            );
            i.d(r, "VData", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataFooter.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataIterator/VDataFooter.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataFooter.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VDataIterator/VDataFooter.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataFooter.sass */
              "./src/components/VDataIterator/VDataFooter.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function c(h) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(g) {
                return typeof g;
              } : c = function(g) {
                return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
              }, c(h);
            }
            r.default = d.a.extend({
              name: "v-data-footer",
              props: {
                options: {
                  type: Object,
                  required: !0
                },
                pagination: {
                  type: Object,
                  required: !0
                },
                itemsPerPageOptions: {
                  type: Array,
                  default: function() {
                    return [5, 10, 15, -1];
                  }
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                firstIcon: {
                  type: String,
                  default: "$first"
                },
                lastIcon: {
                  type: String,
                  default: "$last"
                },
                itemsPerPageText: {
                  type: String,
                  default: "$vuetify.dataFooter.itemsPerPageText"
                },
                itemsPerPageAllText: {
                  type: String,
                  default: "$vuetify.dataFooter.itemsPerPageAll"
                },
                showFirstLastPage: Boolean,
                showCurrentPage: Boolean,
                disablePagination: Boolean,
                disableItemsPerPage: Boolean,
                pageText: {
                  type: String,
                  default: "$vuetify.dataFooter.pageText"
                }
              },
              computed: {
                disableNextPageIcon: function() {
                  return this.options.itemsPerPage <= 0 || this.options.page * this.options.itemsPerPage >= this.pagination.itemsLength || this.pagination.pageStop < 0;
                },
                computedDataItemsPerPageOptions: function() {
                  var p = this;
                  return this.itemsPerPageOptions.map(function(g) {
                    return c(g) === "object" ? g : p.genDataItemsPerPageOption(g);
                  });
                }
              },
              methods: {
                updateOptions: function(p) {
                  this.$emit("update:options", Object.assign({}, this.options, p));
                },
                onFirstPage: function() {
                  this.updateOptions({
                    page: 1
                  });
                },
                onPreviousPage: function() {
                  this.updateOptions({
                    page: this.options.page - 1
                  });
                },
                onNextPage: function() {
                  this.updateOptions({
                    page: this.options.page + 1
                  });
                },
                onLastPage: function() {
                  this.updateOptions({
                    page: this.pagination.pageCount
                  });
                },
                onChangeItemsPerPage: function(p) {
                  this.updateOptions({
                    itemsPerPage: p,
                    page: 1
                  });
                },
                genDataItemsPerPageOption: function(p) {
                  return {
                    text: p === -1 ? this.$vuetify.lang.t(this.itemsPerPageAllText) : String(p),
                    value: p
                  };
                },
                genItemsPerPageSelect: function() {
                  var p = this.options.itemsPerPage, g = this.computedDataItemsPerPageOptions;
                  return g.length <= 1 ? null : (g.find(function(m) {
                    return m.value === p;
                  }) || (p = g[0]), this.$createElement("div", {
                    staticClass: "v-data-footer__select"
                  }, [this.$vuetify.lang.t(this.itemsPerPageText), this.$createElement(a.default, {
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.itemsPerPageText)
                    },
                    props: {
                      disabled: this.disableItemsPerPage,
                      items: g,
                      value: p,
                      hideDetails: !0,
                      auto: !0,
                      minWidth: "75px"
                    },
                    on: {
                      input: this.onChangeItemsPerPage
                    }
                  })]));
                },
                genPaginationInfo: function() {
                  var p = [""], g = this.pagination.itemsLength, m = this.pagination.pageStart, v = this.pagination.pageStop;
                  return this.pagination.itemsLength && this.pagination.itemsPerPage ? (m = this.pagination.pageStart + 1, v = g < this.pagination.pageStop || this.pagination.pageStop < 0 ? g : this.pagination.pageStop, p = this.$scopedSlots["page-text"] ? [this.$scopedSlots["page-text"]({
                    pageStart: m,
                    pageStop: v,
                    itemsLength: g
                  })] : [this.$vuetify.lang.t(this.pageText, m, v, g)]) : this.$scopedSlots["page-text"] && (p = [this.$scopedSlots["page-text"]({
                    pageStart: m,
                    pageStop: v,
                    itemsLength: g
                  })]), this.$createElement("div", {
                    class: "v-data-footer__pagination"
                  }, p);
                },
                genIcon: function(p, g, m, v) {
                  return this.$createElement(l.default, {
                    props: {
                      disabled: g || this.disablePagination,
                      icon: !0,
                      text: !0
                      // dark: this.dark, // TODO: add mixin
                      // light: this.light // TODO: add mixin
                    },
                    on: {
                      click: p
                    },
                    attrs: {
                      "aria-label": m
                      // TODO: Localization
                    }
                  }, [this.$createElement(o.default, v)]);
                },
                genIcons: function() {
                  var p = [], g = [];
                  return p.push(this.genIcon(this.onPreviousPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.prevPage"), this.$vuetify.rtl ? this.nextIcon : this.prevIcon)), g.push(this.genIcon(this.onNextPage, this.disableNextPageIcon, this.$vuetify.lang.t("$vuetify.dataFooter.nextPage"), this.$vuetify.rtl ? this.prevIcon : this.nextIcon)), this.showFirstLastPage && (p.unshift(this.genIcon(this.onFirstPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.firstPage"), this.$vuetify.rtl ? this.lastIcon : this.firstIcon)), g.push(this.genIcon(this.onLastPage, this.options.page >= this.pagination.pageCount || this.options.itemsPerPage === -1, this.$vuetify.lang.t("$vuetify.dataFooter.lastPage"), this.$vuetify.rtl ? this.firstIcon : this.lastIcon))), [this.$createElement("div", {
                    staticClass: "v-data-footer__icons-before"
                  }, p), this.showCurrentPage && this.$createElement("span", [this.options.page.toString()]), this.$createElement("div", {
                    staticClass: "v-data-footer__icons-after"
                  }, g)];
                }
              },
              render: function() {
                return this.$createElement("div", {
                  staticClass: "v-data-footer"
                }, [Object(u.getSlot)(this, "prepend"), this.genItemsPerPageSelect(), this.genPaginationInfo(), this.genIcons()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataIterator/VDataIterator.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataIterator/VDataIterator.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VData */
              "./src/components/VData/index.ts"
            ), o = i(
              /*! ./VDataFooter */
              "./src/components/VDataIterator/VDataFooter.ts"
            ), l = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            };
            r.default = Object(d.default)(l.default, f.default).extend({
              name: "v-data-iterator",
              props: h(h({}, a.VData.options.props), {
                itemKey: {
                  type: String,
                  default: "id"
                },
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                singleSelect: Boolean,
                expanded: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                mobileBreakpoint: h(h({}, l.default.options.props.mobileBreakpoint), {
                  default: 600
                }),
                singleExpand: Boolean,
                loading: [Boolean, String],
                noResultsText: {
                  type: String,
                  default: "$vuetify.dataIterator.noResultsText"
                },
                noDataText: {
                  type: String,
                  default: "$vuetify.noDataText"
                },
                loadingText: {
                  type: String,
                  default: "$vuetify.dataIterator.loadingText"
                },
                hideDefaultFooter: Boolean,
                footerProps: Object,
                selectableKey: {
                  type: String,
                  default: "isSelectable"
                }
              }),
              data: function() {
                return {
                  selection: {},
                  expansion: {},
                  internalCurrentItems: [],
                  shiftKeyDown: !1,
                  lastEntry: -1
                };
              },
              computed: {
                everyItem: function() {
                  var m = this;
                  return !!this.selectableItems.length && this.selectableItems.every(function(v) {
                    return m.isSelected(v);
                  });
                },
                someItems: function() {
                  var m = this;
                  return this.selectableItems.some(function(v) {
                    return m.isSelected(v);
                  });
                },
                sanitizedFooterProps: function() {
                  return Object(u.camelizeObjectKeys)(this.footerProps);
                },
                selectableItems: function() {
                  var m = this;
                  return this.internalCurrentItems.filter(function(v) {
                    return m.isSelectable(v);
                  });
                }
              },
              watch: {
                value: {
                  handler: function(m) {
                    var v = this;
                    this.selection = m.reduce(function(y, E) {
                      return y[Object(u.getObjectValueByPath)(E, v.itemKey)] = E, y;
                    }, {});
                  },
                  immediate: !0
                },
                selection: function(m, v) {
                  Object(u.deepEqual)(Object.keys(m), Object.keys(v)) || this.$emit("input", Object.values(m));
                },
                expanded: {
                  handler: function(m) {
                    var v = this;
                    this.expansion = m.reduce(function(y, E) {
                      return y[Object(u.getObjectValueByPath)(E, v.itemKey)] = !0, y;
                    }, {});
                  },
                  immediate: !0
                },
                expansion: function(m, v) {
                  var y = this;
                  if (!Object(u.deepEqual)(m, v)) {
                    var E = Object.keys(m).filter(function(x) {
                      return m[x];
                    }), C = E.length ? this.items.filter(function(x) {
                      return E.includes(String(Object(u.getObjectValueByPath)(x, y.itemKey)));
                    }) : [];
                    this.$emit("update:expanded", C);
                  }
                }
              },
              created: function() {
                var m = this, v = [["disable-initial-sort", "sort-by"], ["filter", "custom-filter"], ["pagination", "options"], ["total-items", "server-items-length"], ["hide-actions", "hide-default-footer"], ["rows-per-page-items", "footer-props.items-per-page-options"], ["rows-per-page-text", "footer-props.items-per-page-text"], ["prev-icon", "footer-props.prev-icon"], ["next-icon", "footer-props.next-icon"]];
                v.forEach(function(E) {
                  var C = p(E, 2), x = C[0], b = C[1];
                  m.$attrs.hasOwnProperty(x) && Object(c.breaking)(x, b, m);
                });
                var y = ["expand", "content-class", "content-props", "content-tag"];
                y.forEach(function(E) {
                  m.$attrs.hasOwnProperty(E) && Object(c.removed)(E);
                });
              },
              mounted: function() {
                window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp);
              },
              beforeDestroy: function() {
                window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
              },
              methods: {
                onKeyDown: function(m) {
                  this.shiftKeyDown = m.keyCode === u.keyCodes.shift || m.shiftKey;
                },
                onKeyUp: function(m) {
                  (m.keyCode === u.keyCodes.shift || !m.shiftKey) && (this.shiftKeyDown = !1);
                },
                toggleSelectAll: function(m) {
                  for (var v = Object.assign({}, this.selection), y = 0; y < this.selectableItems.length; y++) {
                    var E = this.selectableItems[y];
                    if (this.isSelectable(E)) {
                      var C = Object(u.getObjectValueByPath)(E, this.itemKey);
                      m ? v[C] = E : delete v[C];
                    }
                  }
                  this.selection = v, this.$emit("toggle-select-all", {
                    items: this.internalCurrentItems,
                    value: m
                  });
                },
                isSelectable: function(m) {
                  return Object(u.getObjectValueByPath)(m, this.selectableKey) !== !1;
                },
                isSelected: function(m) {
                  return !!this.selection[Object(u.getObjectValueByPath)(m, this.itemKey)] || !1;
                },
                select: function(m, v, y) {
                  var E = this;
                  if (v === void 0 && (v = !0), y === void 0 && (y = !0), !!this.isSelectable(m)) {
                    var C = this.singleSelect ? {} : Object.assign({}, this.selection), x = Object(u.getObjectValueByPath)(m, this.itemKey);
                    v ? C[x] = m : delete C[x];
                    var b = this.selectableItems.findIndex(function(L) {
                      return Object(u.getObjectValueByPath)(L, E.itemKey) === x;
                    });
                    if (this.lastEntry === -1)
                      this.lastEntry = b;
                    else if (this.shiftKeyDown && !this.singleSelect && y) {
                      var P = Object(u.getObjectValueByPath)(this.selectableItems[this.lastEntry], this.itemKey), O = Object.keys(this.selection).includes(String(P));
                      this.multipleSelect(O, y, C, b);
                    }
                    if (this.lastEntry = b, this.singleSelect && y) {
                      var T = Object.keys(this.selection), M = T.length && Object(u.getObjectValueByPath)(this.selection[T[0]], this.itemKey);
                      M && M !== x && this.$emit("item-selected", {
                        item: this.selection[M],
                        value: !1
                      });
                    }
                    this.selection = C, y && this.$emit("item-selected", {
                      item: m,
                      value: v
                    });
                  }
                },
                multipleSelect: function(m, v, y, E) {
                  m === void 0 && (m = !0), v === void 0 && (v = !0);
                  for (var C = E < this.lastEntry ? E : this.lastEntry, x = E < this.lastEntry ? this.lastEntry : E, b = C; b <= x; b++) {
                    var P = this.selectableItems[b], O = Object(u.getObjectValueByPath)(P, this.itemKey);
                    m ? y[O] = P : delete y[O], v && this.$emit("item-selected", {
                      currentItem: P,
                      value: m
                    });
                  }
                },
                isExpanded: function(m) {
                  return this.expansion[Object(u.getObjectValueByPath)(m, this.itemKey)] || !1;
                },
                expand: function(m, v) {
                  v === void 0 && (v = !0);
                  var y = this.singleExpand ? {} : Object.assign({}, this.expansion), E = Object(u.getObjectValueByPath)(m, this.itemKey);
                  v ? y[E] = !0 : delete y[E], this.expansion = y, this.$emit("item-expanded", {
                    item: m,
                    value: v
                  });
                },
                createItemProps: function(m, v) {
                  var y = this;
                  return {
                    item: m,
                    index: v,
                    select: function(C) {
                      return y.select(m, C);
                    },
                    isSelected: this.isSelected(m),
                    expand: function(C) {
                      return y.expand(m, C);
                    },
                    isExpanded: this.isExpanded(m),
                    isMobile: this.isMobile
                  };
                },
                genEmptyWrapper: function(m) {
                  return this.$createElement("div", m);
                },
                genEmpty: function(m, v) {
                  if (m === 0 && this.loading) {
                    var y = this.$slots.loading || this.$vuetify.lang.t(this.loadingText);
                    return this.genEmptyWrapper(y);
                  } else if (m === 0) {
                    var E = this.$slots["no-data"] || this.$vuetify.lang.t(this.noDataText);
                    return this.genEmptyWrapper(E);
                  } else if (v === 0) {
                    var C = this.$slots["no-results"] || this.$vuetify.lang.t(this.noResultsText);
                    return this.genEmptyWrapper(C);
                  }
                  return null;
                },
                genItems: function(m) {
                  var v = this, y = this.genEmpty(m.originalItemsLength, m.pagination.itemsLength);
                  return y ? [y] : this.$scopedSlots.default ? this.$scopedSlots.default(h(h({}, m), {
                    isSelected: this.isSelected,
                    select: this.select,
                    isExpanded: this.isExpanded,
                    isMobile: this.isMobile,
                    expand: this.expand
                  })) : this.$scopedSlots.item ? m.items.map(function(E, C) {
                    return v.$scopedSlots.item(v.createItemProps(E, C));
                  }) : [];
                },
                genFooter: function(m) {
                  if (this.hideDefaultFooter)
                    return null;
                  var v = {
                    props: h(h({}, this.sanitizedFooterProps), {
                      options: m.options,
                      pagination: m.pagination
                    }),
                    on: {
                      "update:options": function(C) {
                        return m.updateOptions(C);
                      }
                    }
                  }, y = Object(u.getPrefixedScopedSlots)("footer.", this.$scopedSlots);
                  return this.$createElement(o.default, h({
                    scopedSlots: y
                  }, v));
                },
                genDefaultScopedSlot: function(m) {
                  var v = h(h({}, m), {
                    someItems: this.someItems,
                    everyItem: this.everyItem,
                    toggleSelectAll: this.toggleSelectAll
                  });
                  return this.$createElement("div", {
                    staticClass: "v-data-iterator"
                  }, [Object(u.getSlot)(this, "header", v, !0), this.genItems(m), this.genFooter(m), Object(u.getSlot)(this, "footer", v, !0)]);
                }
              },
              render: function() {
                var m = this;
                return this.$createElement(a.VData, {
                  props: this.$props,
                  on: {
                    "update:options": function(y, E) {
                      return !Object(u.deepEqual)(y, E) && m.$emit("update:options", y);
                    },
                    "update:page": function(y) {
                      return m.$emit("update:page", y);
                    },
                    "update:items-per-page": function(y) {
                      return m.$emit("update:items-per-page", y);
                    },
                    "update:sort-by": function(y) {
                      return m.$emit("update:sort-by", y);
                    },
                    "update:sort-desc": function(y) {
                      return m.$emit("update:sort-desc", y);
                    },
                    "update:group-by": function(y) {
                      return m.$emit("update:group-by", y);
                    },
                    "update:group-desc": function(y) {
                      return m.$emit("update:group-desc", y);
                    },
                    pagination: function(y, E) {
                      return !Object(u.deepEqual)(y, E) && m.$emit("pagination", y);
                    },
                    "current-items": function(y) {
                      m.internalCurrentItems = y, m.$emit("current-items", y);
                    },
                    "page-count": function(y) {
                      return m.$emit("page-count", y);
                    }
                  },
                  scopedSlots: {
                    default: this.genDefaultScopedSlot
                  }
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDataIterator/index.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VDataIterator/index.ts ***!
            \***********************************************/
          /*! exports provided: VDataIterator, VDataFooter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDataIterator */
              "./src/components/VDataIterator/VDataIterator.ts"
            );
            i.d(r, "VDataIterator", function() {
              return a.default;
            });
            var o = i(
              /*! ./VDataFooter */
              "./src/components/VDataIterator/VDataFooter.ts"
            );
            i.d(r, "VDataFooter", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VDataIterator: a.default,
                VDataFooter: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDataTable/MobileRow.ts": (
          /*!************************************************!*\
            !*** ./src/components/VDataTable/MobileRow.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "row",
              functional: !0,
              props: {
                headers: Array,
                hideDefaultHeader: Boolean,
                index: Number,
                item: Object,
                rtl: Boolean
              },
              render: function(u, c) {
                var h = c.props, p = c.slots, g = c.data, m = p(), v = h.headers.map(function(y) {
                  var E = {
                    "v-data-table__mobile-row": !0
                  }, C = [], x = Object(l.getObjectValueByPath)(h.item, y.value), b = y.value, P = g.scopedSlots && g.scopedSlots.hasOwnProperty(b) && g.scopedSlots[b], O = m.hasOwnProperty(b) && m[b];
                  P ? C.push(P({
                    item: h.item,
                    isMobile: !0,
                    header: y,
                    index: h.index,
                    value: x
                  })) : O ? C.push(O) : C.push(x == null ? x : String(x));
                  var T = [u("div", {
                    staticClass: "v-data-table__mobile-row__cell"
                  }, C)];
                  return y.value !== "dataTableSelect" && !h.hideDefaultHeader && T.unshift(u("div", {
                    staticClass: "v-data-table__mobile-row__header"
                  }, [y.text])), u("td", {
                    class: E
                  }, T);
                });
                return u("tr", f(f({}, g), {
                  staticClass: "v-data-table__mobile-table-row"
                }), v);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/Row.ts": (
          /*!******************************************!*\
            !*** ./src/components/VDataTable/Row.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, d = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            function u(c) {
              var h;
              return c.length !== 1 || !["td", "th"].includes((h = c[0]) === null || h === void 0 ? void 0 : h.tag);
            }
            r.default = o.a.extend({
              name: "row",
              functional: !0,
              props: {
                headers: Array,
                index: Number,
                item: Object,
                rtl: Boolean
              },
              render: function(h, p) {
                var g = p.props, m = p.slots, v = p.data, y = m(), E = g.headers.map(function(C) {
                  var x = [], b = Object(l.getObjectValueByPath)(g.item, C.value), P = C.value, O = v.scopedSlots && v.scopedSlots.hasOwnProperty(P) && v.scopedSlots[P], T = y.hasOwnProperty(P) && y[P];
                  O ? x.push.apply(x, d([], f(Object(l.wrapInArray)(O({
                    item: g.item,
                    isMobile: !1,
                    header: C,
                    index: g.index,
                    value: b
                  }))), !1)) : T ? x.push.apply(x, d([], f(Object(l.wrapInArray)(T)), !1)) : x.push(b == null ? b : String(b));
                  var M = "text-" + (C.align || "start");
                  return u(x) ? h("td", {
                    class: [M, C.cellClass, {
                      "v-data-table__divider": C.divider
                    }]
                  }, x) : x;
                });
                return h("tr", v, E);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/RowGroup.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VDataTable/RowGroup.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, f = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            r.default = o.a.extend({
              name: "row-group",
              functional: !0,
              props: {
                value: {
                  type: Boolean,
                  default: !0
                },
                headerClass: {
                  type: String,
                  default: "v-row-group__header"
                },
                contentClass: String,
                summaryClass: {
                  type: String,
                  default: "v-row-group__summary"
                }
              },
              render: function(u, c) {
                var h = c.slots, p = c.props, g = h(), m = [];
                return g["column.header"] ? m.push(u("tr", {
                  staticClass: p.headerClass
                }, g["column.header"])) : g["row.header"] && m.push.apply(m, f([], l(g["row.header"]), !1)), g["row.content"] && p.value && m.push.apply(m, f([], l(g["row.content"]), !1)), g["column.summary"] ? m.push(u("tr", {
                  staticClass: p.summaryClass
                }, g["column.summary"])) : g["row.summary"] && m.push.apply(m, f([], l(g["row.summary"]), !1)), m;
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTable.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VDataTable/VDataTable.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTable.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VDataTable/VDataTable.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataTable.sass */
              "./src/components/VDataTable/VDataTable.sass"
            );
            var a = i(
              /*! ../VData */
              "./src/components/VData/index.ts"
            ), o = i(
              /*! ../VDataIterator */
              "./src/components/VDataIterator/index.ts"
            ), l = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), f = i(
              /*! ./VDataTableHeader */
              "./src/components/VDataTable/VDataTableHeader.ts"
            ), d = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), u = i(
              /*! ./Row */
              "./src/components/VDataTable/Row.ts"
            ), c = i(
              /*! ./RowGroup */
              "./src/components/VDataTable/RowGroup.ts"
            ), h = i(
              /*! ../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), p = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            ), g = i(
              /*! ./MobileRow */
              "./src/components/VDataTable/MobileRow.ts"
            ), m = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), v = i(
              /*! ../../mixins/mouse */
              "./src/mixins/mouse/index.ts"
            ), y = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), E = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), C = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), x = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), b = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            function P(A) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? P = function(I) {
                return typeof I;
              } : P = function(I) {
                return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
              }, P(A);
            }
            var O = function() {
              return O = Object.assign || function(A) {
                for (var D, I = 1, w = arguments.length; I < w; I++) {
                  D = arguments[I];
                  for (var B in D)
                    Object.prototype.hasOwnProperty.call(D, B) && (A[B] = D[B]);
                }
                return A;
              }, O.apply(this, arguments);
            }, T = function(A, D) {
              var I = typeof Symbol == "function" && A[Symbol.iterator];
              if (!I)
                return A;
              var w = I.call(A), B, j = [], k;
              try {
                for (; (D === void 0 || D-- > 0) && !(B = w.next()).done; )
                  j.push(B.value);
              } catch (X) {
                k = {
                  error: X
                };
              } finally {
                try {
                  B && !B.done && (I = w.return) && I.call(w);
                } finally {
                  if (k)
                    throw k.error;
                }
              }
              return j;
            };
            function M(A, D, I) {
              return function(w) {
                var B = Object(C.getObjectValueByPath)(A, w.value);
                return w.filter ? w.filter(B, D, A) : I(B, D, A);
              };
            }
            function L(A, D, I, w, B, j) {
              return D = typeof D == "string" ? D.trim() : null, j === "union" ? !(D && w.length) && !I.length ? A : A.filter(function(k) {
                return I.length && I.every(M(k, D, C.defaultFilter)) ? !0 : D && w.some(M(k, D, B));
              }) : j === "intersection" ? A.filter(function(k) {
                var X = I.every(M(k, D, C.defaultFilter)), rt = !D || w.some(M(k, D, B));
                return X && rt;
              }) : A;
            }
            r.default = Object(E.default)(o.VDataIterator, m.default, v.default).extend({
              name: "v-data-table",
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: y.default
              },
              props: {
                headers: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                showSelect: Boolean,
                checkboxColor: String,
                showExpand: Boolean,
                showGroupBy: Boolean,
                // TODO: Fix
                // virtualRows: Boolean,
                height: [Number, String],
                hideDefaultHeader: Boolean,
                caption: String,
                dense: Boolean,
                headerProps: Object,
                calculateWidths: Boolean,
                fixedHeader: Boolean,
                headersLength: Number,
                expandIcon: {
                  type: String,
                  default: "$expand"
                },
                customFilter: {
                  type: Function,
                  default: C.defaultFilter
                },
                filterMode: {
                  type: String,
                  default: "intersection"
                },
                itemClass: {
                  type: [String, Function],
                  default: function() {
                    return "";
                  }
                },
                itemStyle: {
                  type: [String, Function],
                  default: function() {
                    return "";
                  }
                },
                loaderHeight: {
                  type: [Number, String],
                  default: 4
                }
              },
              data: function() {
                return {
                  internalGroupBy: [],
                  openCache: {},
                  widths: []
                };
              },
              computed: {
                computedHeaders: function() {
                  var D = this;
                  if (!this.headers)
                    return [];
                  var I = this.headers.filter(function(j) {
                    return j.value === void 0 || !D.internalGroupBy.find(function(k) {
                      return k === j.value;
                    });
                  }), w = {
                    text: "",
                    sortable: !1,
                    width: "1px"
                  };
                  if (this.showSelect) {
                    var B = I.findIndex(function(j) {
                      return j.value === "data-table-select";
                    });
                    B < 0 ? I.unshift(O(O({}, w), {
                      value: "data-table-select"
                    })) : I.splice(B, 1, O(O({}, w), I[B]));
                  }
                  if (this.showExpand) {
                    var B = I.findIndex(function(k) {
                      return k.value === "data-table-expand";
                    });
                    B < 0 ? I.unshift(O(O({}, w), {
                      value: "data-table-expand"
                    })) : I.splice(B, 1, O(O({}, w), I[B]));
                  }
                  return I;
                },
                colspanAttrs: function() {
                  return this.isMobile ? void 0 : {
                    colspan: this.headersLength || this.computedHeaders.length
                  };
                },
                columnSorters: function() {
                  return this.computedHeaders.reduce(function(D, I) {
                    return I.sort && (D[I.value] = I.sort), D;
                  }, {});
                },
                headersWithCustomFilters: function() {
                  return this.headers.filter(function(D) {
                    return D.filter && (!D.hasOwnProperty("filterable") || D.filterable === !0);
                  });
                },
                headersWithoutCustomFilters: function() {
                  return this.headers.filter(function(D) {
                    return !D.filter && (!D.hasOwnProperty("filterable") || D.filterable === !0);
                  });
                },
                sanitizedHeaderProps: function() {
                  return Object(C.camelizeObjectKeys)(this.headerProps);
                },
                computedItemsPerPage: function() {
                  var D = this.options && this.options.itemsPerPage ? this.options.itemsPerPage : this.itemsPerPage, I = this.sanitizedFooterProps.itemsPerPageOptions;
                  if (I && !I.find(function(B) {
                    return typeof B == "number" ? B === D : B.value === D;
                  })) {
                    var w = I[0];
                    return P(w) === "object" ? w.value : w;
                  }
                  return D;
                },
                groupByText: function() {
                  var D = this, I, w, B;
                  return (B = (w = (I = this.headers) === null || I === void 0 ? void 0 : I.find(function(j) {
                    var k;
                    return j.value === ((k = D.internalGroupBy) === null || k === void 0 ? void 0 : k[0]);
                  })) === null || w === void 0 ? void 0 : w.text) !== null && B !== void 0 ? B : "";
                }
              },
              created: function() {
                var D = this, I = [["sort-icon", "header-props.sort-icon"], ["hide-headers", "hide-default-header"], ["select-all", "show-select"]];
                I.forEach(function(w) {
                  var B = T(w, 2), j = B[0], k = B[1];
                  D.$attrs.hasOwnProperty(j) && Object(x.breaking)(j, k, D);
                });
              },
              mounted: function() {
                this.calculateWidths && (window.addEventListener("resize", this.calcWidths), this.calcWidths());
              },
              beforeDestroy: function() {
                this.calculateWidths && window.removeEventListener("resize", this.calcWidths);
              },
              methods: {
                calcWidths: function() {
                  this.widths = Array.from(this.$el.querySelectorAll("th")).map(function(D) {
                    return D.clientWidth;
                  });
                },
                customFilterWithColumns: function(D, I) {
                  return L(D, I, this.headersWithCustomFilters, this.headersWithoutCustomFilters, this.customFilter, this.filterMode);
                },
                customSortWithHeaders: function(D, I, w, B) {
                  return this.customSort(D, I, w, B, this.columnSorters);
                },
                createItemProps: function(D, I) {
                  var w = this, B = O(O({}, o.VDataIterator.options.methods.createItemProps.call(this, D, I)), {
                    headers: this.computedHeaders
                  });
                  return O(O({}, B), {
                    attrs: {
                      class: {
                        "v-data-table__selected": B.isSelected
                      }
                    },
                    on: O(O({}, this.getDefaultMouseEventHandlers(":row", function() {
                      return B;
                    }, !0)), {
                      // TODO: the first argument should be the event, and the second argument should be data,
                      // but this is a breaking change so it's for v3
                      click: function(k) {
                        return w.$emit("click:row", D, B, k);
                      }
                    })
                  });
                },
                genCaption: function(D) {
                  return this.caption ? [this.$createElement("caption", [this.caption])] : Object(C.getSlot)(this, "caption", D, !0);
                },
                genColgroup: function(D) {
                  var I = this;
                  return this.$createElement("colgroup", this.computedHeaders.map(function(w) {
                    return I.$createElement("col", {
                      class: {
                        divider: w.divider
                      }
                    });
                  }));
                },
                genLoading: function() {
                  var D = this.$createElement("th", {
                    staticClass: "column",
                    attrs: this.colspanAttrs
                  }, [this.genProgress()]), I = this.$createElement("tr", {
                    staticClass: "v-data-table__progress"
                  }, [D]);
                  return this.$createElement("thead", [I]);
                },
                genHeaders: function(D) {
                  var I = {
                    props: O(O({}, this.sanitizedHeaderProps), {
                      headers: this.computedHeaders,
                      options: D.options,
                      mobile: this.isMobile,
                      showGroupBy: this.showGroupBy,
                      checkboxColor: this.checkboxColor,
                      someItems: this.someItems,
                      everyItem: this.everyItem,
                      singleSelect: this.singleSelect,
                      disableSort: this.disableSort
                    }),
                    on: {
                      sort: D.sort,
                      group: D.group,
                      "toggle-select-all": this.toggleSelectAll
                    }
                  }, w = [Object(C.getSlot)(this, "header", O(O({}, I), {
                    isMobile: this.isMobile
                  }))];
                  if (!this.hideDefaultHeader) {
                    var B = Object(C.getPrefixedScopedSlots)("header.", this.$scopedSlots);
                    w.push(this.$createElement(f.default, O(O({}, I), {
                      scopedSlots: B
                    })));
                  }
                  return this.loading && w.push(this.genLoading()), w;
                },
                genEmptyWrapper: function(D) {
                  return this.$createElement("tr", {
                    staticClass: "v-data-table__empty-wrapper"
                  }, [this.$createElement("td", {
                    attrs: this.colspanAttrs
                  }, D)]);
                },
                genItems: function(D, I) {
                  var w = this.genEmpty(I.originalItemsLength, I.pagination.itemsLength);
                  return w ? [w] : I.groupedItems ? this.genGroupedRows(I.groupedItems, I) : this.genRows(D, I);
                },
                genGroupedRows: function(D, I) {
                  var w = this;
                  return D.map(function(B) {
                    return w.openCache.hasOwnProperty(B.name) || w.$set(w.openCache, B.name, !0), w.$scopedSlots.group ? w.$scopedSlots.group({
                      group: B.name,
                      options: I.options,
                      isMobile: w.isMobile,
                      items: B.items,
                      headers: w.computedHeaders
                    }) : w.genDefaultGroupedRow(B.name, B.items, I);
                  });
                },
                genDefaultGroupedRow: function(D, I, w) {
                  var B = this, j = !!this.openCache[D], k = [this.$createElement("template", {
                    slot: "row.content"
                  }, this.genRows(I, w))], X = function() {
                    return B.$set(B.openCache, D, !B.openCache[D]);
                  }, rt = function() {
                    return w.updateOptions({
                      groupBy: [],
                      groupDesc: []
                    });
                  };
                  if (this.$scopedSlots["group.header"])
                    k.unshift(this.$createElement("template", {
                      slot: "column.header"
                    }, [this.$scopedSlots["group.header"]({
                      group: D,
                      groupBy: w.options.groupBy,
                      isMobile: this.isMobile,
                      items: I,
                      headers: this.computedHeaders,
                      isOpen: j,
                      toggle: X,
                      remove: rt
                    })]));
                  else {
                    var et = this.$createElement(l.default, {
                      staticClass: "ma-0",
                      props: {
                        icon: !0,
                        small: !0
                      },
                      on: {
                        click: X
                      }
                    }, [this.$createElement(d.default, [j ? "$minus" : "$plus"])]), Z = this.$createElement(l.default, {
                      staticClass: "ma-0",
                      props: {
                        icon: !0,
                        small: !0
                      },
                      on: {
                        click: rt
                      }
                    }, [this.$createElement(d.default, ["$close"])]), dt = this.$createElement("td", {
                      staticClass: "text-start",
                      attrs: this.colspanAttrs
                    }, [et, this.groupByText + ": " + D, Z]);
                    k.unshift(this.$createElement("template", {
                      slot: "column.header"
                    }, [dt]));
                  }
                  return this.$scopedSlots["group.summary"] && k.push(this.$createElement("template", {
                    slot: "column.summary"
                  }, [this.$scopedSlots["group.summary"]({
                    group: D,
                    groupBy: w.options.groupBy,
                    isMobile: this.isMobile,
                    items: I,
                    headers: this.computedHeaders,
                    isOpen: j,
                    toggle: X
                  })])), this.$createElement(c.default, {
                    key: D,
                    props: {
                      value: j
                    }
                  }, k);
                },
                genRows: function(D, I) {
                  return this.$scopedSlots.item ? this.genScopedRows(D, I) : this.genDefaultRows(D, I);
                },
                genScopedRows: function(D, I) {
                  for (var w = [], B = 0; B < D.length; B++) {
                    var j = D[B];
                    w.push(this.$scopedSlots.item(O(O({}, this.createItemProps(j, B)), {
                      isMobile: this.isMobile
                    }))), this.isExpanded(j) && w.push(this.$scopedSlots["expanded-item"]({
                      headers: this.computedHeaders,
                      isMobile: this.isMobile,
                      index: B,
                      item: j
                    }));
                  }
                  return w;
                },
                genDefaultRows: function(D, I) {
                  var w = this;
                  return this.$scopedSlots["expanded-item"] ? D.map(function(B, j) {
                    return w.genDefaultExpandedRow(B, j);
                  }) : D.map(function(B, j) {
                    return w.genDefaultSimpleRow(B, j);
                  });
                },
                genDefaultExpandedRow: function(D, I) {
                  var w = this.isExpanded(D), B = {
                    "v-data-table__expanded v-data-table__expanded__row": w
                  }, j = this.genDefaultSimpleRow(D, I, B), k = this.$createElement("tr", {
                    staticClass: "v-data-table__expanded v-data-table__expanded__content"
                  }, [this.$scopedSlots["expanded-item"]({
                    headers: this.computedHeaders,
                    isMobile: this.isMobile,
                    item: D
                  })]);
                  return this.$createElement(c.default, {
                    props: {
                      value: w
                    }
                  }, [this.$createElement("template", {
                    slot: "row.header"
                  }, [j]), this.$createElement("template", {
                    slot: "row.content"
                  }, [k])]);
                },
                genDefaultSimpleRow: function(D, I, w) {
                  var B = this;
                  w === void 0 && (w = {});
                  var j = Object(C.getPrefixedScopedSlots)("item.", this.$scopedSlots), k = this.createItemProps(D, I);
                  if (this.showSelect) {
                    var X = j["data-table-select"];
                    j["data-table-select"] = X ? function() {
                      return X(O(O({}, k), {
                        isMobile: B.isMobile
                      }));
                    } : function() {
                      var et;
                      return B.$createElement(h.default, {
                        staticClass: "v-data-table__checkbox",
                        props: {
                          value: k.isSelected,
                          disabled: !B.isSelectable(D),
                          color: (et = B.checkboxColor) !== null && et !== void 0 ? et : ""
                        },
                        on: {
                          input: function(dt) {
                            return k.select(dt);
                          }
                        }
                      });
                    };
                  }
                  if (this.showExpand) {
                    var rt = j["data-table-expand"];
                    j["data-table-expand"] = rt ? function() {
                      return rt(k);
                    } : function() {
                      return B.$createElement(d.default, {
                        staticClass: "v-data-table__expand-icon",
                        class: {
                          "v-data-table__expand-icon--active": k.isExpanded
                        },
                        on: {
                          click: function(Z) {
                            Z.stopPropagation(), k.expand(!k.isExpanded);
                          }
                        }
                      }, [B.expandIcon]);
                    };
                  }
                  return this.$createElement(this.isMobile ? g.default : u.default, {
                    key: Object(C.getObjectValueByPath)(D, this.itemKey),
                    class: Object(b.mergeClasses)(O(O({}, w), {
                      "v-data-table__selected": k.isSelected
                    }), Object(C.getPropertyFromItem)(D, this.itemClass)),
                    style: Object(b.mergeStyles)({}, Object(C.getPropertyFromItem)(D, this.itemStyle)),
                    props: {
                      headers: this.computedHeaders,
                      hideDefaultHeader: this.hideDefaultHeader,
                      index: I,
                      item: D,
                      rtl: this.$vuetify.rtl
                    },
                    scopedSlots: j,
                    on: k.on
                  });
                },
                genBody: function(D) {
                  var I = O(O({}, D), {
                    expand: this.expand,
                    headers: this.computedHeaders,
                    isExpanded: this.isExpanded,
                    isMobile: this.isMobile,
                    isSelected: this.isSelected,
                    select: this.select
                  });
                  return this.$scopedSlots.body ? this.$scopedSlots.body(I) : this.$createElement("tbody", [Object(C.getSlot)(this, "body.prepend", I, !0), this.genItems(D.items, D), Object(C.getSlot)(this, "body.append", I, !0)]);
                },
                genFoot: function(D) {
                  var I, w;
                  return (w = (I = this.$scopedSlots).foot) === null || w === void 0 ? void 0 : w.call(I, D);
                },
                genFooters: function(D) {
                  var I = {
                    props: O({
                      options: D.options,
                      pagination: D.pagination,
                      itemsPerPageText: "$vuetify.dataTable.itemsPerPageText"
                    }, this.sanitizedFooterProps),
                    on: {
                      "update:options": function(j) {
                        return D.updateOptions(j);
                      }
                    },
                    widths: this.widths,
                    headers: this.computedHeaders
                  }, w = [Object(C.getSlot)(this, "footer", I, !0)];
                  return this.hideDefaultFooter || w.push(this.$createElement(o.VDataFooter, O(O({}, I), {
                    scopedSlots: Object(C.getPrefixedScopedSlots)("footer.", this.$scopedSlots)
                  }))), w;
                },
                genDefaultScopedSlot: function(D) {
                  var I = {
                    height: this.height,
                    fixedHeader: this.fixedHeader,
                    dense: this.dense
                  };
                  return this.$createElement(p.default, {
                    props: I,
                    class: {
                      "v-data-table--mobile": this.isMobile,
                      "v-data-table--selectable": this.showSelect
                    }
                  }, [this.proxySlot("top", Object(C.getSlot)(this, "top", O(O({}, D), {
                    isMobile: this.isMobile
                  }), !0)), this.genCaption(D), this.genColgroup(D), this.genHeaders(D), this.genBody(D), this.genFoot(D), this.proxySlot("bottom", this.genFooters(D))]);
                },
                proxySlot: function(D, I) {
                  return this.$createElement("template", {
                    slot: D
                  }, I);
                }
              },
              render: function() {
                var D = this;
                return this.$createElement(a.VData, {
                  props: O(O({}, this.$props), {
                    customFilter: this.customFilterWithColumns,
                    customSort: this.customSortWithHeaders,
                    itemsPerPage: this.computedItemsPerPage
                  }),
                  on: {
                    "update:options": function(w, B) {
                      D.internalGroupBy = w.groupBy || [], !Object(C.deepEqual)(w, B) && D.$emit("update:options", w);
                    },
                    "update:page": function(w) {
                      return D.$emit("update:page", w);
                    },
                    "update:items-per-page": function(w) {
                      return D.$emit("update:items-per-page", w);
                    },
                    "update:sort-by": function(w) {
                      return D.$emit("update:sort-by", w);
                    },
                    "update:sort-desc": function(w) {
                      return D.$emit("update:sort-desc", w);
                    },
                    "update:group-by": function(w) {
                      return D.$emit("update:group-by", w);
                    },
                    "update:group-desc": function(w) {
                      return D.$emit("update:group-desc", w);
                    },
                    pagination: function(w, B) {
                      return !Object(C.deepEqual)(w, B) && D.$emit("pagination", w);
                    },
                    "current-items": function(w) {
                      D.internalCurrentItems = w, D.$emit("current-items", w);
                    },
                    "page-count": function(w) {
                      return D.$emit("page-count", w);
                    }
                  },
                  scopedSlots: {
                    default: this.genDefaultScopedSlot
                  }
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeader.sass": (
          /*!*********************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeader.sass ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeader.ts": (
          /*!*******************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeader.ts ***!
            \*******************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDataTableHeader.sass */
              "./src/components/VDataTable/VDataTableHeader.sass"
            );
            var a = i(
              /*! ./VDataTableHeaderMobile */
              "./src/components/VDataTable/VDataTableHeaderMobile.ts"
            ), o = i(
              /*! ./VDataTableHeaderDesktop */
              "./src/components/VDataTable/VDataTableHeaderDesktop.ts"
            ), l = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), f = i(
              /*! ../../util/dedupeModelListeners */
              "./src/util/dedupeModelListeners.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = i(
              /*! ../../util/rebuildFunctionalSlots */
              "./src/util/rebuildFunctionalSlots.ts"
            ), c = i(
              /*! vue */
              "vue"
            ), h = /* @__PURE__ */ i.n(c), p = function() {
              return p = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, p.apply(this, arguments);
            };
            r.default = h.a.extend({
              name: "v-data-table-header",
              functional: !0,
              props: p(p({}, l.default.options.props), {
                mobile: Boolean
              }),
              render: function(m, v) {
                var y = v.props, E = v.data, C = v.slots;
                Object(f.default)(E);
                var x = Object(u.default)(C(), m);
                return E = Object(d.default)(E, {
                  props: y
                }), y.mobile ? m(a.default, E, x) : m(o.default, E, x);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeaderDesktop.ts": (
          /*!**************************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeaderDesktop.ts ***!
            \**************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = Object(a.default)(o.default).extend({
              name: "v-data-table-header-desktop",
              methods: {
                genGroupByToggle: function(c) {
                  var h = this;
                  return this.$createElement("span", {
                    on: {
                      click: function(g) {
                        g.stopPropagation(), h.$emit("group", c.value);
                      }
                    }
                  }, ["group"]);
                },
                getAria: function(c, h) {
                  var p = this, g = function(E) {
                    return p.$vuetify.lang.t("$vuetify.dataTable.ariaLabel." + E);
                  }, m = "none", v = [g("sortNone"), g("activateAscending")];
                  return c ? (h ? (m = "descending", v = [g("sortDescending"), g(this.options.mustSort ? "activateAscending" : "activateNone")]) : (m = "ascending", v = [g("sortAscending"), g("activateDescending")]), {
                    ariaSort: m,
                    ariaLabel: v.join(" ")
                  }) : {
                    ariaSort: m,
                    ariaLabel: v.join(" ")
                  };
                },
                genHeader: function(c) {
                  var h = this, p = {
                    attrs: {
                      role: "columnheader",
                      scope: "col",
                      "aria-label": c.text || ""
                    },
                    style: {
                      width: Object(l.convertToUnit)(c.width),
                      minWidth: Object(l.convertToUnit)(c.width)
                    },
                    class: d(d(["text-" + (c.align || "start")], f(Object(l.wrapInArray)(c.class)), !1), [c.divider && "v-data-table__divider"], !1),
                    on: {}
                  }, g = [];
                  if (c.value === "data-table-select" && !this.singleSelect)
                    return this.$createElement("th", p, [this.genSelectAll()]);
                  if (g.push(this.$scopedSlots.hasOwnProperty(c.value) ? this.$scopedSlots[c.value]({
                    header: c
                  }) : this.$createElement("span", [c.text])), !this.disableSort && (c.sortable || !c.hasOwnProperty("sortable"))) {
                    p.on.click = function() {
                      return h.$emit("sort", c.value);
                    };
                    var m = this.options.sortBy.findIndex(function(b) {
                      return b === c.value;
                    }), v = m >= 0, y = this.options.sortDesc[m];
                    p.class.push("sortable");
                    var E = this.getAria(v, y), C = E.ariaLabel, x = E.ariaSort;
                    p.attrs["aria-label"] += (c.text ? ": " : "") + C, p.attrs["aria-sort"] = x, v && (p.class.push("active"), p.class.push(y ? "desc" : "asc")), c.align === "end" ? g.unshift(this.genSortIcon()) : g.push(this.genSortIcon()), this.options.multiSort && v && g.push(this.$createElement("span", {
                      class: "v-data-table-header__sort-badge"
                    }, [String(m + 1)]));
                  }
                  return this.showGroupBy && c.groupable !== !1 && g.push(this.genGroupByToggle(c)), this.$createElement("th", p, g);
                }
              },
              render: function() {
                var c = this;
                return this.$createElement("thead", {
                  staticClass: "v-data-table-header"
                }, [this.$createElement("tr", this.headers.map(function(h) {
                  return c.genHeader(h);
                }))]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VDataTableHeaderMobile.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VDataTable/VDataTableHeaderMobile.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), l = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), f = i(
              /*! ./mixins/header */
              "./src/components/VDataTable/mixins/header.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            }, c = function(h, p, g) {
              if (g || arguments.length === 2)
                for (var m = 0, v = p.length, y; m < v; m++)
                  (y || !(m in p)) && (y || (y = Array.prototype.slice.call(p, 0, m)), y[m] = p[m]);
              return h.concat(y || Array.prototype.slice.call(p));
            };
            r.default = Object(a.default)(f.default).extend({
              name: "v-data-table-header-mobile",
              props: {
                sortByText: {
                  type: String,
                  default: "$vuetify.dataTable.sortBy"
                }
              },
              methods: {
                genSortChip: function(p) {
                  var g = this, m = [p.item.text], v = this.options.sortBy.findIndex(function(C) {
                    return C === p.item.value;
                  }), y = v >= 0, E = this.options.sortDesc[v];
                  return m.push(this.$createElement("div", {
                    staticClass: "v-chip__close",
                    class: {
                      sortable: !0,
                      active: y,
                      asc: y && !E,
                      desc: y && E
                    }
                  }, [this.genSortIcon()])), this.$createElement(l.default, {
                    staticClass: "sortable",
                    on: {
                      click: function(x) {
                        x.stopPropagation(), g.$emit("sort", p.item.value);
                      }
                    }
                  }, m);
                },
                genSortSelect: function(p) {
                  var g = this;
                  return this.$createElement(o.default, {
                    props: {
                      label: this.$vuetify.lang.t(this.sortByText),
                      items: p,
                      hideDetails: !0,
                      multiple: this.options.multiSort,
                      value: this.options.multiSort ? this.options.sortBy : this.options.sortBy[0],
                      menuProps: {
                        closeOnContentClick: !0
                      }
                    },
                    on: {
                      change: function(v) {
                        return g.$emit("sort", v);
                      }
                    },
                    scopedSlots: {
                      selection: function(v) {
                        return g.genSortChip(v);
                      }
                    }
                  });
                }
              },
              render: function(p) {
                var g = [], m = this.headers.find(function(C) {
                  return C.value === "data-table-select";
                });
                m && !this.singleSelect && g.push(this.$createElement("div", {
                  class: c(["v-data-table-header-mobile__select"], u(Object(d.wrapInArray)(m.class)), !1),
                  attrs: {
                    width: m.width
                  }
                }, [this.genSelectAll()]));
                var v = this.headers.filter(function(C) {
                  return C.sortable !== !1 && C.value !== "data-table-select";
                }).map(function(C) {
                  return {
                    text: C.text,
                    value: C.value
                  };
                });
                !this.disableSort && v.length && g.push(this.genSortSelect(v));
                var y = g.length ? p("th", [p("div", {
                  staticClass: "v-data-table-header-mobile__wrapper"
                }, g)]) : void 0, E = p("tr", [y]);
                return p("thead", {
                  staticClass: "v-data-table-header v-data-table-header-mobile"
                }, [E]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VEditDialog.sass": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/VEditDialog.sass ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VEditDialog.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VDataTable/VEditDialog.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VEditDialog.sass */
              "./src/components/VDataTable/VEditDialog.sass"
            );
            var a = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), d = i(
              /*! ../VMenu */
              "./src/components/VMenu/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(u.default)(a.default, o.default).extend({
              name: "v-edit-dialog",
              props: {
                cancelText: {
                  default: "Cancel"
                },
                large: Boolean,
                eager: Boolean,
                persistent: Boolean,
                saveText: {
                  default: "Save"
                },
                transition: {
                  type: String,
                  default: "slide-x-reverse-transition"
                }
              },
              data: function() {
                return {
                  isActive: !1
                };
              },
              watch: {
                isActive: function(h) {
                  h ? (this.$emit("open"), setTimeout(this.focus, 50)) : this.$emit("close");
                }
              },
              methods: {
                cancel: function() {
                  this.isActive = !1, this.$emit("cancel");
                },
                focus: function() {
                  var h = this.$refs.content.querySelector("input");
                  h && h.focus();
                },
                genButton: function(h, p) {
                  return this.$createElement(f.default, {
                    props: {
                      text: !0,
                      color: "primary",
                      light: !0
                    },
                    on: {
                      click: h
                    }
                  }, p);
                },
                genActions: function() {
                  var h = this;
                  return this.$createElement("div", {
                    class: "v-small-dialog__actions"
                  }, [this.genButton(this.cancel, this.cancelText), this.genButton(function() {
                    h.save(h.returnValue), h.$emit("save");
                  }, this.saveText)]);
                },
                genContent: function() {
                  var h = this;
                  return this.$createElement("div", {
                    staticClass: "v-small-dialog__content",
                    on: {
                      keydown: function(g) {
                        g.keyCode === l.keyCodes.esc && h.cancel(), g.keyCode === l.keyCodes.enter && (h.save(h.returnValue), h.$emit("save"));
                      }
                    },
                    ref: "content"
                  }, [this.$slots.input]);
                }
              },
              render: function(h) {
                var p = this;
                return h(d.default, {
                  staticClass: "v-small-dialog",
                  class: this.themeClasses,
                  props: {
                    contentClass: "v-small-dialog__menu-content",
                    transition: this.transition,
                    origin: "top right",
                    right: !0,
                    value: this.isActive,
                    closeOnClick: !this.persistent,
                    closeOnContentClick: !1,
                    eager: this.eager,
                    light: this.light,
                    dark: this.dark
                  },
                  on: {
                    input: function(m) {
                      return p.isActive = m;
                    }
                  },
                  scopedSlots: {
                    activator: function(m) {
                      var v = m.on;
                      return h("div", {
                        staticClass: "v-small-dialog__activator",
                        on: v
                      }, [h("span", {
                        staticClass: "v-small-dialog__activator__content"
                      }, p.$slots.default)]);
                    }
                  }
                }, [this.genContent(), this.large ? this.genActions() : null]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VSimpleTable.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VDataTable/VSimpleTable.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VSimpleTable.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VDataTable/VSimpleTable.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSimpleTable.sass */
              "./src/components/VDataTable/VSimpleTable.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(o.default).extend({
              name: "v-simple-table",
              props: {
                dense: Boolean,
                fixedHeader: Boolean,
                height: [Number, String]
              },
              computed: {
                classes: function() {
                  return f({
                    "v-data-table--dense": this.dense,
                    "v-data-table--fixed-height": !!this.height && !this.fixedHeader,
                    "v-data-table--fixed-header": this.fixedHeader,
                    "v-data-table--has-top": !!this.$slots.top,
                    "v-data-table--has-bottom": !!this.$slots.bottom
                  }, this.themeClasses);
                }
              },
              methods: {
                genWrapper: function() {
                  return this.$slots.wrapper || this.$createElement("div", {
                    staticClass: "v-data-table__wrapper",
                    style: {
                      height: Object(a.convertToUnit)(this.height)
                    }
                  }, [this.$createElement("table", this.$slots.default)]);
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-data-table",
                  class: this.classes
                }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/VVirtualTable.sass": (
          /*!******************************************************!*\
            !*** ./src/components/VDataTable/VVirtualTable.sass ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDataTable/VVirtualTable.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/VVirtualTable.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VVirtualTable.sass */
              "./src/components/VDataTable/VVirtualTable.sass"
            );
            var a = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = Object(o.default)(a.default);
            r.default = f.extend().extend({
              name: "v-virtual-table",
              props: {
                chunkSize: {
                  type: Number,
                  default: 25
                },
                headerHeight: {
                  type: Number,
                  default: 48
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                rowHeight: {
                  type: Number,
                  default: 48
                }
              },
              data: function() {
                return {
                  scrollTop: 0,
                  oldChunk: 0,
                  scrollDebounce: null,
                  invalidateCache: !1
                };
              },
              computed: {
                itemsLength: function() {
                  return this.items.length;
                },
                totalHeight: function() {
                  return this.itemsLength * this.rowHeight + this.headerHeight;
                },
                topIndex: function() {
                  return Math.floor(this.scrollTop / this.rowHeight);
                },
                chunkIndex: function() {
                  return Math.floor(this.topIndex / this.chunkSize);
                },
                startIndex: function() {
                  return Math.max(0, this.chunkIndex * this.chunkSize - this.chunkSize);
                },
                offsetTop: function() {
                  return Math.max(0, this.startIndex * this.rowHeight);
                },
                stopIndex: function() {
                  return Math.min(this.startIndex + this.chunkSize * 3, this.itemsLength);
                },
                offsetBottom: function() {
                  return Math.max(0, (this.itemsLength - this.stopIndex - this.startIndex) * this.rowHeight);
                }
              },
              watch: {
                chunkIndex: function(u, c) {
                  this.oldChunk = c;
                },
                items: function() {
                  this.cachedItems = null, this.$refs.table.scrollTop = 0;
                }
              },
              created: function() {
                this.cachedItems = null;
              },
              mounted: function() {
                this.scrollDebounce = Object(l.debounce)(this.onScroll, 50), this.$refs.table.addEventListener("scroll", this.scrollDebounce, {
                  passive: !0
                });
              },
              beforeDestroy: function() {
                this.$refs.table.removeEventListener("scroll", this.scrollDebounce);
              },
              methods: {
                createStyleHeight: function(u) {
                  return {
                    height: u + "px"
                  };
                },
                genBody: function() {
                  return (this.cachedItems === null || this.chunkIndex !== this.oldChunk) && (this.cachedItems = this.genItems(), this.oldChunk = this.chunkIndex), this.$createElement("tbody", [this.$createElement("tr", {
                    style: this.createStyleHeight(this.offsetTop)
                  }), this.cachedItems, this.$createElement("tr", {
                    style: this.createStyleHeight(this.offsetBottom)
                  })]);
                },
                genItems: function() {
                  return this.$scopedSlots.items({
                    items: this.items.slice(this.startIndex, this.stopIndex)
                  });
                },
                onScroll: function(u) {
                  var c = u.target;
                  this.scrollTop = c.scrollTop;
                },
                genTable: function() {
                  return this.$createElement("div", {
                    ref: "table",
                    staticClass: "v-virtual-table__table"
                  }, [this.$createElement("table", [this.$slots["body.before"], this.genBody(), this.$slots["body.after"]])]);
                },
                genWrapper: function() {
                  return this.$createElement("div", {
                    staticClass: "v-virtual-table__wrapper",
                    style: {
                      height: Object(l.convertToUnit)(this.height)
                    }
                  }, [this.genTable()]);
                }
              },
              render: function(u) {
                return u("div", {
                  staticClass: "v-data-table v-virtual-table",
                  class: this.classes
                }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDataTable/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VDataTable/index.ts ***!
            \********************************************/
          /*! exports provided: VDataTable, VEditDialog, VTableOverflow, VDataTableHeader, VSimpleTable, VVirtualTable, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VTableOverflow", function() {
              return c;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VDataTable */
              "./src/components/VDataTable/VDataTable.ts"
            );
            i.d(r, "VDataTable", function() {
              return o.default;
            });
            var l = i(
              /*! ./VDataTableHeader */
              "./src/components/VDataTable/VDataTableHeader.ts"
            );
            i.d(r, "VDataTableHeader", function() {
              return l.default;
            });
            var f = i(
              /*! ./VEditDialog */
              "./src/components/VDataTable/VEditDialog.ts"
            );
            i.d(r, "VEditDialog", function() {
              return f.default;
            });
            var d = i(
              /*! ./VSimpleTable */
              "./src/components/VDataTable/VSimpleTable.ts"
            );
            i.d(r, "VSimpleTable", function() {
              return d.default;
            });
            var u = i(
              /*! ./VVirtualTable */
              "./src/components/VDataTable/VVirtualTable.ts"
            );
            i.d(r, "VVirtualTable", function() {
              return u.default;
            });
            var c = Object(a.createSimpleFunctional)("v-table__overflow");
            r.default = {
              $_vuetify_subcomponents: {
                VDataTable: o.default,
                VDataTableHeader: l.default,
                VEditDialog: f.default,
                VTableOverflow: c,
                VSimpleTable: d.default,
                VVirtualTable: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDataTable/mixins/header.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VDataTable/mixins/header.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), l = i(
              /*! ../../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)().extend({
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: l.default
              },
              props: {
                headers: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                options: {
                  type: Object,
                  default: function() {
                    return {
                      page: 1,
                      itemsPerPage: 10,
                      sortBy: [],
                      sortDesc: [],
                      groupBy: [],
                      groupDesc: [],
                      multiSort: !1,
                      mustSort: !1
                    };
                  }
                },
                checkboxColor: String,
                sortIcon: {
                  type: String,
                  default: "$sort"
                },
                everyItem: Boolean,
                someItems: Boolean,
                showGroupBy: Boolean,
                singleSelect: Boolean,
                disableSort: Boolean
              },
              methods: {
                genSelectAll: function() {
                  var c = this, h, p = {
                    props: {
                      value: this.everyItem,
                      indeterminate: !this.everyItem && this.someItems,
                      color: (h = this.checkboxColor) !== null && h !== void 0 ? h : ""
                    },
                    on: {
                      input: function(m) {
                        return c.$emit("toggle-select-all", m);
                      }
                    }
                  };
                  return this.$scopedSlots["data-table-select"] ? this.$scopedSlots["data-table-select"](p) : this.$createElement(o.default, d({
                    staticClass: "v-data-table__checkbox"
                  }, p));
                },
                genSortIcon: function() {
                  return this.$createElement(a.default, {
                    staticClass: "v-data-table-header__icon",
                    props: {
                      size: 18
                    }
                  }, [this.sortIcon]);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePicker.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VDatePicker/VDatePicker.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDatePickerTitle */
              "./src/components/VDatePicker/VDatePickerTitle.ts"
            ), o = i(
              /*! ./VDatePickerHeader */
              "./src/components/VDatePicker/VDatePickerHeader.ts"
            ), l = i(
              /*! ./VDatePickerDateTable */
              "./src/components/VDatePicker/VDatePickerDateTable.ts"
            ), f = i(
              /*! ./VDatePickerMonthTable */
              "./src/components/VDatePicker/VDatePickerMonthTable.ts"
            ), d = i(
              /*! ./VDatePickerYears */
              "./src/components/VDatePicker/VDatePickerYears.ts"
            ), u = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), c = i(
              /*! ../../mixins/picker */
              "./src/mixins/picker/index.ts"
            ), h = i(
              /*! ./util/isDateAllowed */
              "./src/components/VDatePicker/util/isDateAllowed.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../VCalendar/util/timestamp */
              "./src/components/VCalendar/util/timestamp.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), E = function() {
              return E = Object.assign || function(x) {
                for (var b, P = 1, O = arguments.length; P < O; P++) {
                  b = arguments[P];
                  for (var T in b)
                    Object.prototype.hasOwnProperty.call(b, T) && (x[T] = b[T]);
                }
                return x;
              }, E.apply(this, arguments);
            }, C = function(x, b) {
              var P = typeof Symbol == "function" && x[Symbol.iterator];
              if (!P)
                return x;
              var O = P.call(x), T, M = [], L;
              try {
                for (; (b === void 0 || b-- > 0) && !(T = O.next()).done; )
                  M.push(T.value);
              } catch (A) {
                L = {
                  error: A
                };
              } finally {
                try {
                  T && !T.done && (P = O.return) && P.call(O);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return M;
            };
            r.default = Object(p.default)(u.default, c.default).extend({
              name: "v-date-picker",
              props: {
                activePicker: String,
                allowedDates: Function,
                // Function formatting the day in date picker table
                dayFormat: Function,
                disabled: Boolean,
                events: {
                  type: [Array, Function, Object],
                  default: function() {
                    return null;
                  }
                },
                eventColor: {
                  type: [Array, Function, Object, String],
                  default: function() {
                    return "warning";
                  }
                },
                firstDayOfWeek: {
                  type: [String, Number],
                  default: 0
                },
                // Function formatting the tableDate in the day/month table header
                headerDateFormat: Function,
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                max: String,
                min: String,
                // Function formatting month in the months table
                monthFormat: Function,
                multiple: Boolean,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                nextMonthAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.nextMonthAriaLabel"
                },
                nextYearAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.nextYearAriaLabel"
                },
                pickerDate: String,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                prevMonthAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.prevMonthAriaLabel"
                },
                prevYearAriaLabel: {
                  type: String,
                  default: "$vuetify.datePicker.prevYearAriaLabel"
                },
                range: Boolean,
                reactive: Boolean,
                readonly: Boolean,
                scrollable: Boolean,
                showCurrent: {
                  type: [Boolean, String],
                  default: !0
                },
                selectedItemsText: {
                  type: String,
                  default: "$vuetify.datePicker.itemsSelected"
                },
                showAdjacentMonths: Boolean,
                showWeek: Boolean,
                // Function formatting currently selected date in the picker title
                titleDateFormat: Function,
                type: {
                  type: String,
                  default: "date",
                  validator: function(b) {
                    return ["date", "month"].includes(b);
                  }
                  // TODO: year
                },
                value: [Array, String],
                weekdayFormat: Function,
                // Function formatting the year in table header and pickup title
                yearFormat: Function,
                yearIcon: String
              },
              data: function() {
                var b = this, P = /* @__PURE__ */ new Date();
                return {
                  internalActivePicker: this.type.toUpperCase(),
                  inputDay: null,
                  inputMonth: null,
                  inputYear: null,
                  isReversing: !1,
                  now: P,
                  // tableDate is a string in 'YYYY' / 'YYYY-M' format (leading zero for month is not required)
                  tableDate: function() {
                    if (b.pickerDate)
                      return b.pickerDate;
                    var O = Object(g.wrapInArray)(b.value), T = O[O.length - 1] || (typeof b.showCurrent == "string" ? b.showCurrent : P.getFullYear() + "-" + (P.getMonth() + 1));
                    return Object(y.sanitizeDateString)(T, b.type === "date" ? "month" : "year");
                  }()
                };
              },
              computed: {
                multipleValue: function() {
                  return Object(g.wrapInArray)(this.value);
                },
                isMultiple: function() {
                  return this.multiple || this.range;
                },
                lastValue: function() {
                  return this.isMultiple ? this.multipleValue[this.multipleValue.length - 1] : this.value;
                },
                selectedMonths: function() {
                  return !this.value || this.type === "month" ? this.value : this.isMultiple ? this.multipleValue.map(function(b) {
                    return b.substr(0, 7);
                  }) : this.value.substr(0, 7);
                },
                current: function() {
                  return this.showCurrent === !0 ? Object(y.sanitizeDateString)(this.now.getFullYear() + "-" + (this.now.getMonth() + 1) + "-" + this.now.getDate(), this.type) : this.showCurrent || null;
                },
                inputDate: function() {
                  return this.type === "date" ? this.inputYear + "-" + Object(y.pad)(this.inputMonth + 1) + "-" + Object(y.pad)(this.inputDay) : this.inputYear + "-" + Object(y.pad)(this.inputMonth + 1);
                },
                tableMonth: function() {
                  return Number((this.pickerDate || this.tableDate).split("-")[1]) - 1;
                },
                tableYear: function() {
                  return Number((this.pickerDate || this.tableDate).split("-")[0]);
                },
                minMonth: function() {
                  return this.min ? Object(y.sanitizeDateString)(this.min, "month") : null;
                },
                maxMonth: function() {
                  return this.max ? Object(y.sanitizeDateString)(this.max, "month") : null;
                },
                minYear: function() {
                  return this.min ? Object(y.sanitizeDateString)(this.min, "year") : null;
                },
                maxYear: function() {
                  return this.max ? Object(y.sanitizeDateString)(this.max, "year") : null;
                },
                formatters: function() {
                  return {
                    year: this.yearFormat || Object(y.createNativeLocaleFormatter)(this.currentLocale, {
                      year: "numeric",
                      timeZone: "UTC"
                    }, {
                      length: 4
                    }),
                    titleDate: this.titleDateFormat || (this.isMultiple ? this.defaultTitleMultipleDateFormatter : this.defaultTitleDateFormatter)
                  };
                },
                defaultTitleMultipleDateFormatter: function() {
                  var b = this;
                  return function(P) {
                    return P.length ? P.length === 1 ? b.defaultTitleDateFormatter(P[0]) : b.$vuetify.lang.t(b.selectedItemsText, P.length) : "-";
                  };
                },
                defaultTitleDateFormatter: function() {
                  var b = {
                    year: {
                      year: "numeric",
                      timeZone: "UTC"
                    },
                    month: {
                      month: "long",
                      timeZone: "UTC"
                    },
                    date: {
                      weekday: "short",
                      month: "short",
                      day: "numeric",
                      timeZone: "UTC"
                    }
                  }, P = Object(y.createNativeLocaleFormatter)(this.currentLocale, b[this.type], {
                    start: 0,
                    length: {
                      date: 10,
                      month: 7,
                      year: 4
                    }[this.type]
                  }), O = function(M) {
                    return P(M).replace(/([^\d\s])([\d])/g, function(L, A, D) {
                      return A + " " + D;
                    }).replace(", ", ",<br>");
                  };
                  return this.landscape ? O : P;
                }
              },
              watch: {
                internalActivePicker: {
                  immediate: !0,
                  handler: function(b) {
                    this.$emit("update:active-picker", b);
                  }
                },
                activePicker: function(b) {
                  this.internalActivePicker = b;
                },
                tableDate: function(b, P) {
                  var O = this.type === "month" ? "year" : "month";
                  this.isReversing = Object(y.sanitizeDateString)(b, O) < Object(y.sanitizeDateString)(P, O), this.$emit("update:picker-date", b);
                },
                pickerDate: function(b) {
                  b ? this.tableDate = b : this.lastValue && this.type === "date" ? this.tableDate = Object(y.sanitizeDateString)(this.lastValue, "month") : this.lastValue && this.type === "month" && (this.tableDate = Object(y.sanitizeDateString)(this.lastValue, "year"));
                },
                value: function(b, P) {
                  this.checkMultipleProp(), this.setInputDate(), (!this.isMultiple && this.value && !this.pickerDate || this.isMultiple && this.multipleValue.length && (!P || !P.length) && !this.pickerDate) && (this.tableDate = Object(y.sanitizeDateString)(this.inputDate, this.type === "month" ? "year" : "month"));
                },
                type: function(b) {
                  if (this.internalActivePicker = b.toUpperCase(), this.value && this.value.length) {
                    var P = this.multipleValue.map(function(O) {
                      return Object(y.sanitizeDateString)(O, b);
                    }).filter(this.isDateAllowed);
                    this.$emit("input", this.isMultiple ? P : P[0]);
                  }
                }
              },
              created: function() {
                this.checkMultipleProp(), this.pickerDate !== this.tableDate && this.$emit("update:picker-date", this.tableDate), this.setInputDate();
              },
              methods: {
                emitInput: function(b) {
                  if (this.range) {
                    if (this.multipleValue.length !== 1)
                      this.$emit("input", [b]);
                    else {
                      var P = [this.multipleValue[0], b];
                      this.$emit("input", P), this.$emit("change", P);
                    }
                    return;
                  }
                  var O = this.multiple ? this.multipleValue.indexOf(b) === -1 ? this.multipleValue.concat([b]) : this.multipleValue.filter(function(T) {
                    return T !== b;
                  }) : b;
                  this.$emit("input", O), this.multiple || this.$emit("change", b);
                },
                checkMultipleProp: function() {
                  if (this.value != null) {
                    var b = this.value.constructor.name, P = this.isMultiple ? "Array" : "String";
                    b !== P && Object(v.consoleWarn)("Value must be " + (this.isMultiple ? "an" : "a") + " " + P + ", got " + b, this);
                  }
                },
                isDateAllowed: function(b) {
                  return Object(h.default)(b, this.min, this.max, this.allowedDates);
                },
                yearClick: function(b) {
                  this.inputYear = b, this.type === "month" ? this.tableDate = "" + b : this.tableDate = b + "-" + Object(y.pad)((this.tableMonth || 0) + 1), this.internalActivePicker = "MONTH", this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate) && this.$emit("input", this.inputDate);
                },
                monthClick: function(b) {
                  var P = C(b.split("-"), 2), O = P[0], T = P[1];
                  this.inputYear = parseInt(O, 10), this.inputMonth = parseInt(T, 10) - 1, this.type === "date" ? (this.inputDay && (this.inputDay = Math.min(this.inputDay, Object(m.daysInMonth)(this.inputYear, this.inputMonth + 1))), this.tableDate = b, this.internalActivePicker = "DATE", this.reactive && !this.readonly && !this.isMultiple && this.isDateAllowed(this.inputDate) && this.$emit("input", this.inputDate)) : this.emitInput(this.inputDate);
                },
                dateClick: function(b) {
                  var P = C(b.split("-"), 3), O = P[0], T = P[1], M = P[2];
                  this.inputYear = parseInt(O, 10), this.inputMonth = parseInt(T, 10) - 1, this.inputDay = parseInt(M, 10), this.emitInput(this.inputDate);
                },
                genPickerTitle: function() {
                  var b = this;
                  return this.$createElement(a.default, {
                    props: {
                      date: this.value ? this.formatters.titleDate(this.isMultiple ? this.multipleValue : this.value) : "",
                      disabled: this.disabled,
                      readonly: this.readonly,
                      selectingYear: this.internalActivePicker === "YEAR",
                      year: this.formatters.year(this.multipleValue.length ? "" + this.inputYear : this.tableDate),
                      yearIcon: this.yearIcon,
                      value: this.multipleValue[0]
                    },
                    slot: "title",
                    on: {
                      "update:selecting-year": function(O) {
                        return b.internalActivePicker = O ? "YEAR" : b.type.toUpperCase();
                      }
                    }
                  });
                },
                genTableHeader: function() {
                  var b = this;
                  return this.$createElement(o.default, {
                    props: {
                      nextIcon: this.nextIcon,
                      color: this.color,
                      dark: this.dark,
                      disabled: this.disabled,
                      format: this.headerDateFormat,
                      light: this.light,
                      locale: this.locale,
                      min: this.internalActivePicker === "DATE" ? this.minMonth : this.minYear,
                      max: this.internalActivePicker === "DATE" ? this.maxMonth : this.maxYear,
                      nextAriaLabel: this.internalActivePicker === "DATE" ? this.nextMonthAriaLabel : this.nextYearAriaLabel,
                      prevAriaLabel: this.internalActivePicker === "DATE" ? this.prevMonthAriaLabel : this.prevYearAriaLabel,
                      prevIcon: this.prevIcon,
                      readonly: this.readonly,
                      value: this.internalActivePicker === "DATE" ? Object(y.pad)(this.tableYear, 4) + "-" + Object(y.pad)(this.tableMonth + 1) : "" + Object(y.pad)(this.tableYear, 4)
                    },
                    on: {
                      toggle: function() {
                        return b.internalActivePicker = b.internalActivePicker === "DATE" ? "MONTH" : "YEAR";
                      },
                      input: function(O) {
                        return b.tableDate = O;
                      }
                    }
                  });
                },
                genDateTable: function() {
                  var b = this;
                  return this.$createElement(l.default, {
                    props: {
                      allowedDates: this.allowedDates,
                      color: this.color,
                      current: this.current,
                      dark: this.dark,
                      disabled: this.disabled,
                      events: this.events,
                      eventColor: this.eventColor,
                      firstDayOfWeek: this.firstDayOfWeek,
                      format: this.dayFormat,
                      light: this.light,
                      locale: this.locale,
                      localeFirstDayOfYear: this.localeFirstDayOfYear,
                      min: this.min,
                      max: this.max,
                      range: this.range,
                      readonly: this.readonly,
                      scrollable: this.scrollable,
                      showAdjacentMonths: this.showAdjacentMonths,
                      showWeek: this.showWeek,
                      tableDate: Object(y.pad)(this.tableYear, 4) + "-" + Object(y.pad)(this.tableMonth + 1),
                      value: this.value,
                      weekdayFormat: this.weekdayFormat
                    },
                    ref: "table",
                    on: E({
                      input: this.dateClick,
                      "update:table-date": function(O) {
                        return b.tableDate = O;
                      }
                    }, Object(y.createItemTypeListeners)(this, ":date"))
                  });
                },
                genMonthTable: function() {
                  var b = this;
                  return this.$createElement(f.default, {
                    props: {
                      allowedDates: this.type === "month" ? this.allowedDates : null,
                      color: this.color,
                      current: this.current ? Object(y.sanitizeDateString)(this.current, "month") : null,
                      dark: this.dark,
                      disabled: this.disabled,
                      events: this.type === "month" ? this.events : null,
                      eventColor: this.type === "month" ? this.eventColor : null,
                      format: this.monthFormat,
                      light: this.light,
                      locale: this.locale,
                      min: this.minMonth,
                      max: this.maxMonth,
                      range: this.range,
                      readonly: this.readonly && this.type === "month",
                      scrollable: this.scrollable,
                      value: this.selectedMonths,
                      tableDate: "" + Object(y.pad)(this.tableYear, 4)
                    },
                    ref: "table",
                    on: E({
                      input: this.monthClick,
                      "update:table-date": function(O) {
                        return b.tableDate = O;
                      }
                    }, Object(y.createItemTypeListeners)(this, ":month"))
                  });
                },
                genYears: function() {
                  return this.$createElement(d.default, {
                    props: {
                      color: this.color,
                      format: this.yearFormat,
                      locale: this.locale,
                      min: this.minYear,
                      max: this.maxYear,
                      value: this.tableYear
                    },
                    on: E({
                      input: this.yearClick
                    }, Object(y.createItemTypeListeners)(this, ":year"))
                  });
                },
                genPickerBody: function() {
                  var b = this.internalActivePicker === "YEAR" ? [this.genYears()] : [this.genTableHeader(), this.internalActivePicker === "DATE" ? this.genDateTable() : this.genMonthTable()];
                  return this.$createElement("div", {
                    key: this.internalActivePicker
                  }, b);
                },
                setInputDate: function() {
                  if (this.lastValue) {
                    var b = this.lastValue.split("-");
                    this.inputYear = parseInt(b[0], 10), this.inputMonth = parseInt(b[1], 10) - 1, this.type === "date" && (this.inputDay = parseInt(b[2], 10));
                  } else
                    this.inputYear = this.inputYear || this.now.getFullYear(), this.inputMonth = this.inputMonth == null ? this.inputMonth : this.now.getMonth(), this.inputDay = this.inputDay || this.now.getDate();
                }
              },
              render: function() {
                return this.genPicker("v-picker--date");
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerDateTable.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerDateTable.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/date-picker-table */
              "./src/components/VDatePicker/mixins/date-picker-table.ts"
            ), o = i(
              /*! ../../util/dateTimeUtils */
              "./src/util/dateTimeUtils.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-date-table",
              props: {
                firstDayOfWeek: {
                  type: [String, Number],
                  default: 0
                },
                localeFirstDayOfYear: {
                  type: [String, Number],
                  default: 0
                },
                showAdjacentMonths: Boolean,
                showWeek: Boolean,
                weekdayFormat: Function
              },
              computed: {
                formatter: function() {
                  return this.format || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    day: "numeric",
                    timeZone: "UTC"
                  }, {
                    start: 8,
                    length: 2
                  });
                },
                weekdayFormatter: function() {
                  return this.weekdayFormat || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    weekday: "narrow",
                    timeZone: "UTC"
                  });
                },
                weekDays: function() {
                  var c = this, h = parseInt(this.firstDayOfWeek, 10);
                  return this.weekdayFormatter ? Object(f.createRange)(7).map(function(p) {
                    return c.weekdayFormatter("2017-01-" + (h + p + 15));
                  }) : Object(f.createRange)(7).map(function(p) {
                    return ["S", "M", "T", "W", "T", "F", "S"][(p + h) % 7];
                  });
                }
              },
              methods: {
                calculateTableDate: function(c) {
                  return Object(l.monthChange)(this.tableDate, Math.sign(c || 1));
                },
                genTHead: function() {
                  var c = this, h = this.weekDays.map(function(p) {
                    return c.$createElement("th", p);
                  });
                  return this.showWeek && h.unshift(this.$createElement("th")), this.$createElement("thead", this.genTR(h));
                },
                // Returns number of the days from the firstDayOfWeek to the first day of the current month
                weekDaysBeforeFirstDayOfTheMonth: function() {
                  var c = /* @__PURE__ */ new Date(this.displayedYear + "-" + Object(l.pad)(this.displayedMonth + 1) + "-01T00:00:00+00:00"), h = c.getUTCDay();
                  return (h - parseInt(this.firstDayOfWeek) + 7) % 7;
                },
                getWeekNumber: function(c) {
                  return Object(o.weekNumber)(this.displayedYear, this.displayedMonth, c, parseInt(this.firstDayOfWeek), parseInt(this.localeFirstDayOfYear));
                },
                genWeekNumber: function(c) {
                  return this.$createElement("td", [this.$createElement("small", {
                    staticClass: "v-date-picker-table--date__week"
                  }, String(c).padStart(2, "0"))]);
                },
                // eslint-disable-next-line max-statements
                genTBody: function() {
                  var c = [], h = new Date(this.displayedYear, this.displayedMonth + 1, 0).getDate(), p = [], g = this.weekDaysBeforeFirstDayOfTheMonth();
                  this.showWeek && p.push(this.genWeekNumber(this.getWeekNumber(1)));
                  for (var m = this.displayedMonth ? this.displayedYear : this.displayedYear - 1, v = (this.displayedMonth + 11) % 12, y = new Date(this.displayedYear, this.displayedMonth, 0).getDate(), E = this.showWeek ? 8 : 7; g--; ) {
                    var C = m + "-" + Object(l.pad)(v + 1) + "-" + Object(l.pad)(y - g);
                    p.push(this.$createElement("td", this.showAdjacentMonths ? [this.genButton(C, !0, "date", this.formatter, !0)] : []));
                  }
                  for (g = 1; g <= h; g++) {
                    var C = this.displayedYear + "-" + Object(l.pad)(this.displayedMonth + 1) + "-" + Object(l.pad)(g);
                    p.push(this.$createElement("td", [this.genButton(C, !0, "date", this.formatter)])), p.length % E === 0 && (c.push(this.genTR(p)), p = [], this.showWeek && (g < h || this.showAdjacentMonths) && p.push(this.genWeekNumber(this.getWeekNumber(g + 7))));
                  }
                  for (var x = this.displayedMonth === 11 ? this.displayedYear + 1 : this.displayedYear, b = (this.displayedMonth + 1) % 12, P = 1; p.length < E; ) {
                    var C = x + "-" + Object(l.pad)(b + 1) + "-" + Object(l.pad)(P++);
                    p.push(this.$createElement("td", this.showAdjacentMonths ? [this.genButton(C, !0, "date", this.formatter, !0)] : []));
                  }
                  return p.length && c.push(this.genTR(p)), this.$createElement("tbody", c);
                },
                genTR: function(c) {
                  return [this.$createElement("tr", c)];
                }
              },
              render: function() {
                return this.genTable("v-date-picker-table v-date-picker-table--date", [this.genTHead(), this.genTBody()], this.calculateTableDate);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerHeader.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerHeader.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerHeader.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerHeader.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerHeader.sass */
              "./src/components/VDatePicker/VDatePickerHeader.sass"
            );
            var a = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            };
            r.default = Object(c.default)(
              l.default,
              f.default,
              d.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-header",
              props: {
                disabled: Boolean,
                format: Function,
                min: String,
                max: String,
                nextAriaLabel: String,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevAriaLabel: String,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                readonly: Boolean,
                value: {
                  type: [Number, String],
                  required: !0
                }
              },
              data: function() {
                return {
                  isReversing: !1
                };
              },
              computed: {
                formatter: function() {
                  return this.format ? this.format : String(this.value).split("-")[1] ? Object(u.createNativeLocaleFormatter)(this.currentLocale, {
                    month: "long",
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 7
                  }) : Object(u.createNativeLocaleFormatter)(this.currentLocale, {
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 4
                  });
                }
              },
              watch: {
                value: function(m, v) {
                  this.isReversing = m < v;
                }
              },
              methods: {
                genBtn: function(m) {
                  var v = this, y = m > 0 ? this.nextAriaLabel : this.prevAriaLabel, E = y ? this.$vuetify.lang.t(y) : void 0, C = this.disabled || m < 0 && this.min && this.calculateChange(m) < this.min || m > 0 && this.max && this.calculateChange(m) > this.max;
                  return this.$createElement(a.default, {
                    attrs: {
                      "aria-label": E
                    },
                    props: {
                      dark: this.dark,
                      disabled: C,
                      icon: !0,
                      light: this.light
                    },
                    on: {
                      click: function(b) {
                        b.stopPropagation(), v.$emit("input", v.calculateChange(m));
                      }
                    }
                  }, [this.$createElement(o.default, m < 0 == !this.$vuetify.rtl ? this.prevIcon : this.nextIcon)]);
                },
                calculateChange: function(m) {
                  var v = p(String(this.value).split("-").map(Number), 2), y = v[0], E = v[1];
                  return E == null ? "" + (y + m) : Object(u.monthChange)(String(this.value), m);
                },
                genHeader: function() {
                  var m = this, v = !this.disabled && (this.color || "accent"), y = this.$createElement("div", this.setTextColor(v, {
                    key: String(this.value)
                  }), [this.$createElement("button", {
                    attrs: {
                      type: "button"
                    },
                    on: {
                      click: function() {
                        return m.$emit("toggle");
                      }
                    }
                  }, [this.$slots.default || this.formatter(String(this.value))])]), E = this.$createElement("transition", {
                    props: {
                      name: this.isReversing === !this.$vuetify.rtl ? "tab-reverse-transition" : "tab-transition"
                    }
                  }, [y]);
                  return this.$createElement("div", {
                    staticClass: "v-date-picker-header__value",
                    class: {
                      "v-date-picker-header__value--disabled": this.disabled
                    }
                  }, [E]);
                }
              },
              render: function() {
                return this.$createElement("div", {
                  staticClass: "v-date-picker-header",
                  class: h({
                    "v-date-picker-header--disabled": this.disabled
                  }, this.themeClasses)
                }, [this.genBtn(-1), this.genHeader(), this.genBtn(1)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerMonthTable.ts": (
          /*!*************************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerMonthTable.ts ***!
            \*************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mixins/date-picker-table */
              "./src/components/VDatePicker/mixins/date-picker-table.ts"
            ), o = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-month-table",
              computed: {
                formatter: function() {
                  return this.format || Object(o.createNativeLocaleFormatter)(this.currentLocale, {
                    month: "short",
                    timeZone: "UTC"
                  }, {
                    start: 5,
                    length: 2
                  });
                }
              },
              methods: {
                calculateTableDate: function(d) {
                  return "" + (parseInt(this.tableDate, 10) + Math.sign(d || 1));
                },
                genTBody: function() {
                  for (var d = this, u = [], c = Array(3).fill(null), h = 12 / c.length, p = function(y) {
                    var E = c.map(function(C, x) {
                      var b = y * c.length + x, P = d.displayedYear + "-" + Object(o.pad)(b + 1);
                      return d.$createElement("td", {
                        key: b
                      }, [d.genButton(P, !1, "month", d.formatter)]);
                    });
                    u.push(g.$createElement("tr", {
                      key: y
                    }, E));
                  }, g = this, m = 0; m < h; m++)
                    p(m);
                  return this.$createElement("tbody", u);
                }
              },
              render: function() {
                return this.genTable("v-date-picker-table v-date-picker-table--month", [this.genTBody()], this.calculateTableDate);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTable.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTable.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTitle.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTitle.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerTitle.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerTitle.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerTitle.sass */
              "./src/components/VDatePicker/VDatePickerTitle.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              o.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-title",
              props: {
                date: {
                  type: String,
                  default: ""
                },
                disabled: Boolean,
                readonly: Boolean,
                selectingYear: Boolean,
                value: {
                  type: String
                },
                year: {
                  type: [Number, String],
                  default: ""
                },
                yearIcon: {
                  type: String
                }
              },
              data: function() {
                return {
                  isReversing: !1
                };
              },
              computed: {
                computedTransition: function() {
                  return this.isReversing ? "picker-reverse-transition" : "picker-transition";
                }
              },
              watch: {
                value: function(d, u) {
                  this.isReversing = d < u;
                }
              },
              methods: {
                genYearIcon: function() {
                  return this.$createElement(a.default, {
                    props: {
                      dark: !0
                    }
                  }, this.yearIcon);
                },
                getYearBtn: function() {
                  return this.genPickerButton("selectingYear", !0, [String(this.year), this.yearIcon ? this.genYearIcon() : null], !1, "v-date-picker-title__year");
                },
                genTitleText: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [this.$createElement("div", {
                    domProps: {
                      innerHTML: this.date || "&nbsp;"
                    },
                    key: this.value
                  })]);
                },
                genTitleDate: function() {
                  return this.genPickerButton("selectingYear", !1, [this.genTitleText()], !1, "v-date-picker-title__date");
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-date-picker-title",
                  class: {
                    "v-date-picker-title--disabled": this.disabled
                  }
                }, [this.getYearBtn(), this.genTitleDate()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerYears.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerYears.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDatePicker/VDatePickerYears.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/VDatePickerYears.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDatePickerYears.sass */
              "./src/components/VDatePicker/VDatePickerYears.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), l = i(
              /*! ./util */
              "./src/components/VDatePicker/util/index.ts"
            ), f = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-date-picker-years",
              props: {
                format: Function,
                min: [Number, String],
                max: [Number, String],
                readonly: Boolean,
                value: [Number, String]
              },
              data: function() {
                return {
                  defaultColor: "primary"
                };
              },
              computed: {
                formatter: function() {
                  return this.format || Object(l.createNativeLocaleFormatter)(this.currentLocale, {
                    year: "numeric",
                    timeZone: "UTC"
                  }, {
                    length: 4
                  });
                }
              },
              mounted: function() {
                var c = this;
                setTimeout(function() {
                  var h = c.$el.getElementsByClassName("active")[0];
                  h ? c.$el.scrollTop = h.offsetTop - c.$el.offsetHeight / 2 + h.offsetHeight / 2 : c.min && !c.max ? c.$el.scrollTop = c.$el.scrollHeight : !c.min && c.max ? c.$el.scrollTop = 0 : c.$el.scrollTop = c.$el.scrollHeight / 2 - c.$el.offsetHeight / 2;
                });
              },
              methods: {
                genYearItem: function(c) {
                  var h = this, p = this.formatter("" + c), g = parseInt(this.value, 10) === c, m = g && (this.color || "primary");
                  return this.$createElement("li", this.setTextColor(m, {
                    key: c,
                    class: {
                      active: g
                    },
                    on: Object(f.mergeListeners)({
                      click: function() {
                        return h.$emit("input", c);
                      }
                    }, Object(l.createItemTypeNativeListeners)(this, ":year", c))
                  }), p);
                },
                genYearItems: function() {
                  for (var c = [], h = this.value ? parseInt(this.value, 10) : (/* @__PURE__ */ new Date()).getFullYear(), p = this.max ? parseInt(this.max, 10) : h + 100, g = Math.min(p, this.min ? parseInt(this.min, 10) : h - 100), m = p; m >= g; m--)
                    c.push(this.genYearItem(m));
                  return c;
                }
              },
              render: function() {
                return this.$createElement("ul", {
                  staticClass: "v-date-picker-years",
                  ref: "years"
                }, this.genYearItems());
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VDatePicker/index.ts ***!
            \*********************************************/
          /*! exports provided: VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDatePicker */
              "./src/components/VDatePicker/VDatePicker.ts"
            );
            i.d(r, "VDatePicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VDatePickerTitle */
              "./src/components/VDatePicker/VDatePickerTitle.ts"
            );
            i.d(r, "VDatePickerTitle", function() {
              return o.default;
            });
            var l = i(
              /*! ./VDatePickerHeader */
              "./src/components/VDatePicker/VDatePickerHeader.ts"
            );
            i.d(r, "VDatePickerHeader", function() {
              return l.default;
            });
            var f = i(
              /*! ./VDatePickerDateTable */
              "./src/components/VDatePicker/VDatePickerDateTable.ts"
            );
            i.d(r, "VDatePickerDateTable", function() {
              return f.default;
            });
            var d = i(
              /*! ./VDatePickerMonthTable */
              "./src/components/VDatePicker/VDatePickerMonthTable.ts"
            );
            i.d(r, "VDatePickerMonthTable", function() {
              return d.default;
            });
            var u = i(
              /*! ./VDatePickerYears */
              "./src/components/VDatePicker/VDatePickerYears.ts"
            );
            i.d(r, "VDatePickerYears", function() {
              return u.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VDatePicker: a.default,
                VDatePickerTitle: o.default,
                VDatePickerHeader: l.default,
                VDatePickerDateTable: f.default,
                VDatePickerMonthTable: d.default,
                VDatePickerYears: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/mixins/date-picker-table.ts": (
          /*!****************************************************************!*\
            !*** ./src/components/VDatePicker/mixins/date-picker-table.ts ***!
            \****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VDatePickerTable.sass */
              "./src/components/VDatePicker/VDatePickerTable.sass"
            );
            var a = i(
              /*! ../../../directives/touch */
              "./src/directives/touch/index.ts"
            ), o = i(
              /*! ../../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../../mixins/localable */
              "./src/mixins/localable/index.ts"
            ), f = i(
              /*! ../../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../util */
              "./src/components/VDatePicker/util/index.ts"
            ), u = i(
              /*! ../util/isDateAllowed */
              "./src/components/VDatePicker/util/isDateAllowed.ts"
            ), c = i(
              /*! ../../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../../util/mixins */
              "./src/util/mixins.ts"
            ), p = i(
              /*! ../../../util/helpers */
              "./src/util/helpers.ts"
            ), g = function() {
              return g = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, g.apply(this, arguments);
            }, m = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], O;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (T) {
                O = {
                  error: T
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (O)
                    throw O.error;
                }
              }
              return P;
            }, v = function(y, E, C) {
              if (C || arguments.length === 2)
                for (var x = 0, b = E.length, P; x < b; x++)
                  (P || !(x in E)) && (P || (P = Array.prototype.slice.call(E, 0, x)), P[x] = E[x]);
              return y.concat(P || Array.prototype.slice.call(E));
            };
            r.default = Object(h.default)(
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              directives: {
                Touch: a.default
              },
              props: {
                allowedDates: Function,
                current: String,
                disabled: Boolean,
                format: Function,
                events: {
                  type: [Array, Function, Object],
                  default: function() {
                    return null;
                  }
                },
                eventColor: {
                  type: [Array, Function, Object, String],
                  default: function() {
                    return "warning";
                  }
                },
                min: String,
                max: String,
                range: Boolean,
                readonly: Boolean,
                scrollable: Boolean,
                tableDate: {
                  type: String,
                  required: !0
                },
                value: [String, Array]
              },
              data: function() {
                return {
                  isReversing: !1,
                  wheelThrottle: null
                };
              },
              computed: {
                computedTransition: function() {
                  return this.isReversing === !this.$vuetify.rtl ? "tab-reverse-transition" : "tab-transition";
                },
                displayedMonth: function() {
                  return Number(this.tableDate.split("-")[1]) - 1;
                },
                displayedYear: function() {
                  return Number(this.tableDate.split("-")[0]);
                }
              },
              watch: {
                tableDate: function(E, C) {
                  this.isReversing = E < C;
                }
              },
              mounted: function() {
                this.wheelThrottle = Object(p.throttle)(this.wheel, 250);
              },
              methods: {
                genButtonClasses: function(E, C, x, b, P, O) {
                  return g({
                    "v-size--default": !C,
                    "v-date-picker-table__current": b,
                    "v-btn--active": x,
                    "v-btn--flat": !E || this.disabled,
                    "v-btn--text": x === b,
                    "v-btn--rounded": C,
                    "v-btn--disabled": !E || this.disabled,
                    "v-btn--outlined": b && !x,
                    "v-date-picker--first-in-range": P,
                    "v-date-picker--last-in-range": O
                  }, this.themeClasses);
                },
                genButtonEvents: function(E, C, x) {
                  var b = this;
                  if (!this.disabled)
                    return Object(c.mergeListeners)({
                      click: function() {
                        C && !b.readonly && b.$emit("input", E);
                      }
                    }, Object(d.createItemTypeNativeListeners)(this, ":" + x, E));
                },
                genButton: function(E, C, x, b, P) {
                  P === void 0 && (P = !1);
                  var O = Object(u.default)(E, this.min, this.max, this.allowedDates), T = this.isSelected(E) && O, M = E === this.current, L = T ? this.setBackgroundColor : this.setTextColor, A = (T || M) && (this.color || "accent"), D = !1, I = !1;
                  return this.range && this.value && Array.isArray(this.value) && (D = E === this.value[0], I = E === this.value[this.value.length - 1]), this.$createElement("button", L(A, {
                    staticClass: "v-btn",
                    class: this.genButtonClasses(O && !P, C, T, M, D, I),
                    attrs: {
                      type: "button"
                    },
                    domProps: {
                      disabled: this.disabled || !O || P
                    },
                    on: this.genButtonEvents(E, O, x)
                  }), [this.$createElement("div", {
                    staticClass: "v-btn__content"
                  }, [b(E)]), this.genEvents(E)]);
                },
                getEventColors: function(E) {
                  var C = function(O) {
                    return Array.isArray(O) ? O : [O];
                  }, x, b = [];
                  if (Array.isArray(this.events) ? x = this.events.includes(E) : this.events instanceof Function ? x = this.events(E) || !1 : this.events ? x = this.events[E] || !1 : x = !1, x)
                    x !== !0 ? b = C(x) : typeof this.eventColor == "string" ? b = [this.eventColor] : typeof this.eventColor == "function" ? b = C(this.eventColor(E)) : Array.isArray(this.eventColor) ? b = this.eventColor : b = C(this.eventColor[E]);
                  else
                    return [];
                  return b.filter(function(P) {
                    return P;
                  });
                },
                genEvents: function(E) {
                  var C = this, x = this.getEventColors(E);
                  return x.length ? this.$createElement("div", {
                    staticClass: "v-date-picker-table__events"
                  }, x.map(function(b) {
                    return C.$createElement("div", C.setBackgroundColor(b));
                  })) : null;
                },
                isValidScroll: function(E, C) {
                  var x = C(E), b = x.split("-").length === 1 ? "year" : "month";
                  return E < 0 && (this.min ? x >= Object(d.sanitizeDateString)(this.min, b) : !0) || E > 0 && (this.max ? x <= Object(d.sanitizeDateString)(this.max, b) : !0);
                },
                wheel: function(E, C) {
                  this.$emit("update:table-date", C(E.deltaY));
                },
                touch: function(E, C) {
                  this.$emit("update:table-date", C(E));
                },
                genTable: function(E, C, x) {
                  var b = this, P = this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [this.$createElement("table", {
                    key: this.tableDate
                  }, C)]), O = {
                    name: "touch",
                    value: {
                      left: function(M) {
                        return M.offsetX < -15 && b.isValidScroll(1, x) && b.touch(1, x);
                      },
                      right: function(M) {
                        return M.offsetX > 15 && b.isValidScroll(-1, x) && b.touch(-1, x);
                      }
                    }
                  };
                  return this.$createElement("div", {
                    staticClass: E,
                    class: g({
                      "v-date-picker-table--disabled": this.disabled
                    }, this.themeClasses),
                    on: !this.disabled && this.scrollable ? {
                      wheel: function(M) {
                        M.preventDefault(), b.isValidScroll(M.deltaY, x) && b.wheelThrottle(M, x);
                      }
                    } : void 0,
                    directives: [O]
                  }, [P]);
                },
                isSelected: function(E) {
                  if (Array.isArray(this.value))
                    if (this.range && this.value.length === 2) {
                      var C = m(v([], m(this.value), !1).sort(), 2), x = C[0], b = C[1];
                      return x <= E && E <= b;
                    } else
                      return this.value.indexOf(E) !== -1;
                  return E === this.value;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/util/createNativeLocaleFormatter.ts": (
          /*!************************************************************************!*\
            !*** ./src/components/VDatePicker/util/createNativeLocaleFormatter.ts ***!
            \************************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(f, d) {
              var u = typeof Symbol == "function" && f[Symbol.iterator];
              if (!u)
                return f;
              var c = u.call(f), h, p = [], g;
              try {
                for (; (d === void 0 || d-- > 0) && !(h = c.next()).done; )
                  p.push(h.value);
              } catch (m) {
                g = {
                  error: m
                };
              } finally {
                try {
                  h && !h.done && (u = c.return) && u.call(c);
                } finally {
                  if (g)
                    throw g.error;
                }
              }
              return p;
            };
            function l(f, d, u) {
              u === void 0 && (u = {
                start: 0,
                length: 0
              });
              var c = function(g) {
                var m = o(g.trim().split(" ")[0].split("-"), 3), v = m[0], y = m[1], E = m[2];
                return [Object(a.default)(v, 4), Object(a.default)(y || 1), Object(a.default)(E || 1)].join("-");
              };
              try {
                var h = new Intl.DateTimeFormat(f || void 0, d);
                return function(p) {
                  return h.format(/* @__PURE__ */ new Date(c(p) + "T00:00:00+00:00"));
                };
              } catch {
                return u.start || u.length ? function(g) {
                  return c(g).substr(u.start || 0, u.length);
                } : void 0;
              }
            }
            r.default = l;
          }
        ),
        /***/
        "./src/components/VDatePicker/util/eventHelpers.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VDatePicker/util/eventHelpers.ts ***!
            \*********************************************************/
          /*! exports provided: createItemTypeNativeListeners, createItemTypeListeners */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createItemTypeNativeListeners", function() {
              return a;
            }), i.d(r, "createItemTypeListeners", function() {
              return o;
            });
            function a(l, f, d) {
              return Object.keys(l.$listeners).reduce(function(u, c) {
                return c.endsWith(f) && (u[c.slice(0, -f.length)] = function(h) {
                  return l.$emit(c, d, h);
                }), u;
              }, {});
            }
            function o(l, f) {
              return Object.keys(l.$listeners).reduce(function(d, u) {
                return u.endsWith(f) && (d[u] = l.$listeners[u]), d;
              }, {});
            }
          }
        ),
        /***/
        "./src/components/VDatePicker/util/index.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VDatePicker/util/index.ts ***!
            \**************************************************/
          /*! exports provided: createItemTypeListeners, createItemTypeNativeListeners, createNativeLocaleFormatter, monthChange, sanitizeDateString, pad */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./eventHelpers */
              "./src/components/VDatePicker/util/eventHelpers.ts"
            );
            i.d(r, "createItemTypeListeners", function() {
              return a.createItemTypeListeners;
            }), i.d(r, "createItemTypeNativeListeners", function() {
              return a.createItemTypeNativeListeners;
            });
            var o = i(
              /*! ./createNativeLocaleFormatter */
              "./src/components/VDatePicker/util/createNativeLocaleFormatter.ts"
            );
            i.d(r, "createNativeLocaleFormatter", function() {
              return o.default;
            });
            var l = i(
              /*! ./monthChange */
              "./src/components/VDatePicker/util/monthChange.ts"
            );
            i.d(r, "monthChange", function() {
              return l.default;
            });
            var f = i(
              /*! ./sanitizeDateString */
              "./src/components/VDatePicker/util/sanitizeDateString.ts"
            );
            i.d(r, "sanitizeDateString", function() {
              return f.default;
            });
            var d = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            );
            i.d(r, "pad", function() {
              return d.default;
            });
          }
        ),
        /***/
        "./src/components/VDatePicker/util/isDateAllowed.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VDatePicker/util/isDateAllowed.ts ***!
            \**********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o, l, f, d) {
              return (!d || d(o)) && (!l || o >= l.substr(0, 10)) && (!f || o <= f);
            }
          }
        ),
        /***/
        "./src/components/VDatePicker/util/monthChange.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VDatePicker/util/monthChange.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(l, f) {
              var d = typeof Symbol == "function" && l[Symbol.iterator];
              if (!d)
                return l;
              var u = d.call(l), c, h = [], p;
              try {
                for (; (f === void 0 || f-- > 0) && !(c = u.next()).done; )
                  h.push(c.value);
              } catch (g) {
                p = {
                  error: g
                };
              } finally {
                try {
                  c && !c.done && (d = u.return) && d.call(u);
                } finally {
                  if (p)
                    throw p.error;
                }
              }
              return h;
            };
            r.default = function(l, f) {
              var d = o(l.split("-").map(Number), 2), u = d[0], c = d[1];
              return c + f === 0 ? u - 1 + "-12" : c + f === 13 ? u + 1 + "-01" : u + "-" + Object(a.default)(c + f);
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/util/pad.ts": (
          /*!************************************************!*\
            !*** ./src/components/VDatePicker/util/pad.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = function(l, f, d) {
              return f = f >> 0, l = String(l), d = String(d), l.length > f ? String(l) : (f = f - l.length, f > d.length && (d += d.repeat(f / d.length)), d.slice(0, f) + String(l));
            };
            r.default = function(o, l) {
              return l === void 0 && (l = 2), a(o, l, "0");
            };
          }
        ),
        /***/
        "./src/components/VDatePicker/util/sanitizeDateString.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VDatePicker/util/sanitizeDateString.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), o = function(l, f) {
              var d = typeof Symbol == "function" && l[Symbol.iterator];
              if (!d)
                return l;
              var u = d.call(l), c, h = [], p;
              try {
                for (; (f === void 0 || f-- > 0) && !(c = u.next()).done; )
                  h.push(c.value);
              } catch (g) {
                p = {
                  error: g
                };
              } finally {
                try {
                  c && !c.done && (d = u.return) && d.call(u);
                } finally {
                  if (p)
                    throw p.error;
                }
              }
              return h;
            };
            r.default = function(l, f) {
              var d = o(l.split("-"), 3), u = d[0], c = d[1], h = c === void 0 ? 1 : c, p = d[2], g = p === void 0 ? 1 : p;
              return (u + "-" + Object(a.default)(h) + "-" + Object(a.default)(g)).substr(0, {
                date: 10,
                month: 7,
                year: 4
              }[f]);
            };
          }
        ),
        /***/
        "./src/components/VDialog/VDialog.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VDialog/VDialog.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDialog/VDialog.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VDialog/VDialog.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDialog.sass */
              "./src/components/VDialog/VDialog.sass"
            );
            var a = i(
              /*! ../VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            ), o = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), l = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), f = i(
              /*! ../../mixins/detachable */
              "./src/mixins/detachable/index.ts"
            ), d = i(
              /*! ../../mixins/overlayable */
              "./src/mixins/overlayable/index.ts"
            ), u = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), c = i(
              /*! ../../mixins/stackable */
              "./src/mixins/stackable/index.ts"
            ), h = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), m = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), v = function() {
              return v = Object.assign || function(x) {
                for (var b, P = 1, O = arguments.length; P < O; P++) {
                  b = arguments[P];
                  for (var T in b)
                    Object.prototype.hasOwnProperty.call(b, T) && (x[T] = b[T]);
                }
                return x;
              }, v.apply(this, arguments);
            }, y = function(x, b) {
              var P = typeof Symbol == "function" && x[Symbol.iterator];
              if (!P)
                return x;
              var O = P.call(x), T, M = [], L;
              try {
                for (; (b === void 0 || b-- > 0) && !(T = O.next()).done; )
                  M.push(T.value);
              } catch (A) {
                L = {
                  error: A
                };
              } finally {
                try {
                  T && !T.done && (P = O.return) && P.call(O);
                } finally {
                  if (L)
                    throw L.error;
                }
              }
              return M;
            }, E = function(x, b, P) {
              if (P || arguments.length === 2)
                for (var O = 0, T = b.length, M; O < T; O++)
                  (M || !(O in b)) && (M || (M = Array.prototype.slice.call(b, 0, O)), M[O] = b[O]);
              return x.concat(M || Array.prototype.slice.call(b));
            }, C = Object(p.default)(l.default, f.default, d.default, u.default, c.default, o.default);
            r.default = C.extend({
              name: "v-dialog",
              directives: {
                ClickOutside: h.default
              },
              props: {
                dark: Boolean,
                disabled: Boolean,
                fullscreen: Boolean,
                light: Boolean,
                maxWidth: [String, Number],
                noClickAnimation: Boolean,
                origin: {
                  type: String,
                  default: "center center"
                },
                persistent: Boolean,
                retainFocus: {
                  type: Boolean,
                  default: !0
                },
                scrollable: Boolean,
                transition: {
                  type: [String, Boolean],
                  default: "dialog-transition"
                },
                width: [String, Number]
              },
              data: function() {
                return {
                  activatedBy: null,
                  animate: !1,
                  animateTimeout: -1,
                  stackMinZIndex: 200,
                  previousActiveElement: null
                };
              },
              computed: {
                classes: function() {
                  var b;
                  return b = {}, b[("v-dialog " + this.contentClass).trim()] = !0, b["v-dialog--active"] = this.isActive, b["v-dialog--persistent"] = this.persistent, b["v-dialog--fullscreen"] = this.fullscreen, b["v-dialog--scrollable"] = this.scrollable, b["v-dialog--animated"] = this.animate, b;
                },
                contentClasses: function() {
                  return {
                    "v-dialog__content": !0,
                    "v-dialog__content--active": this.isActive
                  };
                },
                hasActivator: function() {
                  return !!(this.$slots.activator || this.$scopedSlots.activator);
                }
              },
              watch: {
                isActive: function(b) {
                  var P;
                  b ? (this.show(), this.hideScroll()) : (this.removeOverlay(), this.unbind(), (P = this.previousActiveElement) === null || P === void 0 || P.focus());
                },
                fullscreen: function(b) {
                  this.isActive && (b ? (this.hideScroll(), this.removeOverlay(!1)) : (this.showScroll(), this.genOverlay()));
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("full-width") && Object(g.removed)("full-width", this);
              },
              beforeMount: function() {
                var b = this;
                this.$nextTick(function() {
                  b.isBooted = b.isActive, b.isActive && b.show();
                });
              },
              beforeDestroy: function() {
                typeof window < "u" && this.unbind();
              },
              methods: {
                animateClick: function() {
                  var b = this;
                  this.animate = !1, this.$nextTick(function() {
                    b.animate = !0, window.clearTimeout(b.animateTimeout), b.animateTimeout = window.setTimeout(function() {
                      return b.animate = !1;
                    }, 150);
                  });
                },
                closeConditional: function(b) {
                  var P = b.target;
                  return !(this._isDestroyed || !this.isActive || this.$refs.content.contains(P) || this.overlay && P && !this.overlay.$el.contains(P)) && this.activeZIndex >= this.getMaxZIndex();
                },
                hideScroll: function() {
                  this.fullscreen ? document.documentElement.classList.add("overflow-y-hidden") : d.default.options.methods.hideScroll.call(this);
                },
                show: function() {
                  var b = this;
                  !this.fullscreen && !this.hideOverlay && this.genOverlay(), this.$nextTick(function() {
                    b.$nextTick(function() {
                      var P, O;
                      !((P = b.$refs.dialog) === null || P === void 0) && P.contains(document.activeElement) || (b.previousActiveElement = document.activeElement, (O = b.$refs.dialog) === null || O === void 0 || O.focus()), b.bind();
                    });
                  });
                },
                bind: function() {
                  window.addEventListener("focusin", this.onFocusin);
                },
                unbind: function() {
                  window.removeEventListener("focusin", this.onFocusin);
                },
                onClickOutside: function(b) {
                  this.$emit("click:outside", b), this.persistent ? this.noClickAnimation || this.animateClick() : this.isActive = !1;
                },
                onKeydown: function(b) {
                  if (b.keyCode === m.keyCodes.esc && !this.getOpenDependents().length)
                    if (this.persistent)
                      this.noClickAnimation || this.animateClick();
                    else {
                      this.isActive = !1;
                      var P = this.getActivator();
                      this.$nextTick(function() {
                        return P && P.focus();
                      });
                    }
                  this.$emit("keydown", b);
                },
                // On focus change, wrap focus to stay inside the dialog
                // https://github.com/vuetifyjs/vuetify/issues/6892
                onFocusin: function(b) {
                  if (!(!b || !this.retainFocus)) {
                    var P = b.target;
                    if (P && this.$refs.dialog && // It isn't the document or the dialog body
                    ![document, this.$refs.dialog].includes(P) && // It isn't inside the dialog body
                    !this.$refs.dialog.contains(P) && // We're the topmost dialog
                    this.activeZIndex >= this.getMaxZIndex() && // It isn't inside a dependent element (like a menu)
                    !this.getOpenDependentElements().some(function(M) {
                      return M.contains(P);
                    })) {
                      var O = this.$refs.dialog.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])'), T = E([], y(O), !1).find(function(M) {
                        return !M.hasAttribute("disabled") && !M.matches('[tabindex="-1"]');
                      });
                      T && T.focus();
                    }
                  }
                },
                genContent: function() {
                  var b = this;
                  return this.showLazyContent(function() {
                    return [b.$createElement(a.VThemeProvider, {
                      props: {
                        root: !0,
                        light: b.light,
                        dark: b.dark
                      }
                    }, [b.$createElement("div", {
                      class: b.contentClasses,
                      attrs: v({
                        role: "dialog",
                        "aria-modal": b.hideOverlay ? void 0 : "true"
                      }, b.getScopeIdAttrs()),
                      on: {
                        keydown: b.onKeydown
                      },
                      style: {
                        zIndex: b.activeZIndex
                      },
                      ref: "content"
                    }, [b.genTransition()])])];
                  });
                },
                genTransition: function() {
                  var b = this.genInnerContent();
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition,
                      origin: this.origin,
                      appear: !0
                    }
                  }, [b]) : b;
                },
                genInnerContent: function() {
                  var b = {
                    class: this.classes,
                    attrs: {
                      tabindex: this.isActive ? 0 : void 0
                    },
                    ref: "dialog",
                    directives: [{
                      name: "click-outside",
                      value: {
                        handler: this.onClickOutside,
                        closeConditional: this.closeConditional,
                        include: this.getOpenDependentElements
                      }
                    }, {
                      name: "show",
                      value: this.isActive
                    }],
                    style: {
                      transformOrigin: this.origin
                    }
                  };
                  return this.fullscreen || (b.style = v(v({}, b.style), {
                    maxWidth: Object(m.convertToUnit)(this.maxWidth),
                    width: Object(m.convertToUnit)(this.width)
                  })), this.$createElement("div", b, this.getContentSlot());
                }
              },
              render: function(b) {
                return b("div", {
                  staticClass: "v-dialog__container",
                  class: {
                    "v-dialog__container--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  }
                }, [this.genActivator(), this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VDialog/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VDialog/index.ts ***!
            \*****************************************/
          /*! exports provided: VDialog, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDialog */
              "./src/components/VDialog/VDialog.ts"
            );
            i.d(r, "VDialog", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VDivider/VDivider.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VDivider/VDivider.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VDivider/VDivider.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VDivider/VDivider.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VDivider.sass */
              "./src/components/VDivider/VDivider.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-divider",
              props: {
                inset: Boolean,
                vertical: Boolean
              },
              render: function(f) {
                var d;
                return (!this.$attrs.role || this.$attrs.role === "separator") && (d = this.vertical ? "vertical" : "horizontal"), f("hr", {
                  class: o({
                    "v-divider": !0,
                    "v-divider--inset": this.inset,
                    "v-divider--vertical": this.vertical
                  }, this.themeClasses),
                  attrs: o({
                    role: "separator",
                    "aria-orientation": d
                  }, this.$attrs),
                  on: this.$listeners
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VDivider/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VDivider/index.ts ***!
            \******************************************/
          /*! exports provided: VDivider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VDivider */
              "./src/components/VDivider/VDivider.ts"
            );
            i.d(r, "VDivider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanel.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanel.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanel.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanel.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(
              Object(a.factory)("expansionPanels", "v-expansion-panel", "v-expansion-panels"),
              Object(o.provide)("expansionPanel", !0)
              /* @vue/component */
            ).extend({
              name: "v-expansion-panel",
              props: {
                disabled: Boolean,
                readonly: Boolean
              },
              data: function() {
                return {
                  content: null,
                  header: null,
                  nextIsActive: !1
                };
              },
              computed: {
                classes: function() {
                  return d({
                    "v-expansion-panel--active": this.isActive,
                    "v-expansion-panel--next-active": this.nextIsActive,
                    "v-expansion-panel--disabled": this.isDisabled
                  }, this.groupClasses);
                },
                isDisabled: function() {
                  return this.expansionPanels.disabled || this.disabled;
                },
                isReadonly: function() {
                  return this.expansionPanels.readonly || this.readonly;
                }
              },
              methods: {
                registerContent: function(c) {
                  this.content = c;
                },
                unregisterContent: function() {
                  this.content = null;
                },
                registerHeader: function(c) {
                  this.header = c, c.$on("click", this.onClick);
                },
                unregisterHeader: function() {
                  this.header = null;
                },
                onClick: function(c) {
                  c.detail && this.header.$el.blur(), this.$emit("click", c), this.isReadonly || this.isDisabled || this.toggle();
                },
                toggle: function() {
                  var c = this;
                  this.$nextTick(function() {
                    return c.$emit("change");
                  });
                }
              },
              render: function(c) {
                return c("div", {
                  staticClass: "v-expansion-panel",
                  class: this.classes,
                  attrs: {
                    "aria-expanded": String(this.isActive)
                  }
                }, Object(l.getSlot)(this));
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanelContent.ts": (
          /*!******************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanelContent.ts ***!
            \******************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = Object(u.default)(o.default, l.default, Object(f.inject)("expansionPanel", "v-expansion-panel-content", "v-expansion-panel"));
            r.default = c.extend().extend({
              name: "v-expansion-panel-content",
              data: function() {
                return {
                  isActive: !1
                };
              },
              computed: {
                parentIsActive: function() {
                  return this.expansionPanel.isActive;
                }
              },
              watch: {
                parentIsActive: {
                  immediate: !0,
                  handler: function(p, g) {
                    var m = this;
                    p && (this.isBooted = !0), g == null ? this.isActive = p : this.$nextTick(function() {
                      return m.isActive = p;
                    });
                  }
                }
              },
              created: function() {
                this.expansionPanel.registerContent(this);
              },
              beforeDestroy: function() {
                this.expansionPanel.unregisterContent();
              },
              render: function(p) {
                var g = this;
                return p(a.VExpandTransition, this.showLazyContent(function() {
                  return [p("div", g.setBackgroundColor(g.color, {
                    staticClass: "v-expansion-panel-content",
                    directives: [{
                      name: "show",
                      value: g.isActive
                    }]
                  }), [p("div", {
                    class: "v-expansion-panel-content__wrap"
                  }, Object(d.getSlot)(g, "default", {
                    open: g.isActive
                  }))])];
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanelHeader.ts": (
          /*!*****************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanelHeader.ts ***!
            \*****************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), d = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, h.apply(this, arguments);
            }, p = Object(c.default)(l.default, Object(f.inject)("expansionPanel", "v-expansion-panel-header", "v-expansion-panel"));
            r.default = p.extend().extend({
              name: "v-expansion-panel-header",
              directives: {
                ripple: d.default
              },
              props: {
                disableIconRotate: Boolean,
                expandIcon: {
                  type: String,
                  default: "$expand"
                },
                hideActions: Boolean,
                ripple: {
                  type: [Boolean, Object],
                  default: !1
                }
              },
              data: function() {
                return {
                  hasMousedown: !1
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-expansion-panel-header--active": this.isActive,
                    "v-expansion-panel-header--mousedown": this.hasMousedown
                  };
                },
                isActive: function() {
                  return this.expansionPanel.isActive;
                },
                isDisabled: function() {
                  return this.expansionPanel.isDisabled;
                },
                isReadonly: function() {
                  return this.expansionPanel.isReadonly;
                }
              },
              created: function() {
                this.expansionPanel.registerHeader(this);
              },
              beforeDestroy: function() {
                this.expansionPanel.unregisterHeader();
              },
              methods: {
                onClick: function(m) {
                  this.$emit("click", m);
                },
                genIcon: function() {
                  var m = Object(u.getSlot)(this, "actions", {
                    open: this.isActive
                  }) || [this.$createElement(o.default, this.expandIcon)];
                  return this.$createElement(a.VFadeTransition, [this.$createElement("div", {
                    staticClass: "v-expansion-panel-header__icon",
                    class: {
                      "v-expansion-panel-header__icon--disable-rotate": this.disableIconRotate
                    },
                    directives: [{
                      name: "show",
                      value: !this.isDisabled
                    }]
                  }, m)]);
                }
              },
              render: function(m) {
                var v = this;
                return m("button", this.setBackgroundColor(this.color, {
                  staticClass: "v-expansion-panel-header",
                  class: this.classes,
                  attrs: {
                    tabindex: this.isDisabled ? -1 : null,
                    type: "button",
                    "aria-expanded": this.isActive
                  },
                  directives: [{
                    name: "ripple",
                    value: this.ripple
                  }],
                  on: h(h({}, this.$listeners), {
                    click: this.onClick,
                    mousedown: function() {
                      return v.hasMousedown = !0;
                    },
                    mouseup: function() {
                      return v.hasMousedown = !1;
                    }
                  })
                }), [Object(u.getSlot)(this, "default", {
                  open: this.isActive
                }, !0), this.hideActions || this.genIcon()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/VExpansionPanels.ts": (
          /*!************************************************************!*\
            !*** ./src/components/VExpansionPanel/VExpansionPanels.ts ***!
            \************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VExpansionPanel.sass */
              "./src/components/VExpansionPanel/VExpansionPanel.sass"
            );
            var a = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = a.BaseItemGroup.extend({
              name: "v-expansion-panels",
              provide: function() {
                return {
                  expansionPanels: this
                };
              },
              props: {
                accordion: Boolean,
                disabled: Boolean,
                flat: Boolean,
                hover: Boolean,
                focusable: Boolean,
                inset: Boolean,
                popout: Boolean,
                readonly: Boolean,
                tile: Boolean
              },
              computed: {
                classes: function() {
                  return l(l({}, a.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-expansion-panels": !0,
                    "v-expansion-panels--accordion": this.accordion,
                    "v-expansion-panels--flat": this.flat,
                    "v-expansion-panels--hover": this.hover,
                    "v-expansion-panels--focusable": this.focusable,
                    "v-expansion-panels--inset": this.inset,
                    "v-expansion-panels--popout": this.popout,
                    "v-expansion-panels--tile": this.tile
                  });
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("expand") && Object(o.breaking)("expand", "multiple", this), Array.isArray(this.value) && this.value.length > 0 && typeof this.value[0] == "boolean" && Object(o.breaking)(':value="[true, false, true]"', ':value="[0, 2]"', this);
              },
              methods: {
                updateItem: function(d, u) {
                  var c = this.getValue(d, u), h = this.getValue(d, u + 1);
                  d.isActive = this.toggleMethod(c), d.nextIsActive = this.toggleMethod(h);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VExpansionPanel/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VExpansionPanel/index.ts ***!
            \*************************************************/
          /*! exports provided: VExpansionPanels, VExpansionPanel, VExpansionPanelHeader, VExpansionPanelContent, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VExpansionPanels */
              "./src/components/VExpansionPanel/VExpansionPanels.ts"
            );
            i.d(r, "VExpansionPanels", function() {
              return a.default;
            });
            var o = i(
              /*! ./VExpansionPanel */
              "./src/components/VExpansionPanel/VExpansionPanel.ts"
            );
            i.d(r, "VExpansionPanel", function() {
              return o.default;
            });
            var l = i(
              /*! ./VExpansionPanelContent */
              "./src/components/VExpansionPanel/VExpansionPanelContent.ts"
            );
            i.d(r, "VExpansionPanelContent", function() {
              return l.default;
            });
            var f = i(
              /*! ./VExpansionPanelHeader */
              "./src/components/VExpansionPanel/VExpansionPanelHeader.ts"
            );
            i.d(r, "VExpansionPanelHeader", function() {
              return f.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VExpansionPanels: a.default,
                VExpansionPanel: o.default,
                VExpansionPanelHeader: f.default,
                VExpansionPanelContent: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VFileInput/VFileInput.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VFileInput/VFileInput.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VFileInput/VFileInput.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VFileInput/VFileInput.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VFileInput.sass */
              "./src/components/VFileInput/VFileInput.sass"
            );
            var a = i(
              /*! ../VTextField */
              "./src/components/VTextField/index.ts"
            ), o = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            function u(g) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function(v) {
                return typeof v;
              } : u = function(v) {
                return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
              }, u(g);
            }
            var c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = a.default.extend({
              name: "v-file-input",
              model: {
                prop: "value",
                event: "change"
              },
              props: {
                chips: Boolean,
                clearable: {
                  type: Boolean,
                  default: !0
                },
                counterSizeString: {
                  type: String,
                  default: "$vuetify.fileInput.counterSize"
                },
                counterString: {
                  type: String,
                  default: "$vuetify.fileInput.counter"
                },
                hideInput: Boolean,
                multiple: Boolean,
                placeholder: String,
                prependIcon: {
                  type: String,
                  default: "$file"
                },
                readonly: {
                  type: Boolean,
                  default: !1
                },
                showSize: {
                  type: [Boolean, Number],
                  default: !1,
                  validator: function(m) {
                    return typeof m == "boolean" || [1e3, 1024].includes(m);
                  }
                },
                smallChips: Boolean,
                truncateLength: {
                  type: [Number, String],
                  default: 22
                },
                type: {
                  type: String,
                  default: "file"
                },
                value: {
                  default: void 0,
                  validator: function(m) {
                    return Object(l.wrapInArray)(m).every(function(v) {
                      return v != null && u(v) === "object";
                    });
                  }
                }
              },
              computed: {
                classes: function() {
                  return c(c({}, a.default.options.computed.classes.call(this)), {
                    "v-file-input": !0
                  });
                },
                computedCounterValue: function() {
                  var m = this.multiple && this.lazyValue ? this.lazyValue.length : this.lazyValue instanceof File ? 1 : 0;
                  if (!this.showSize)
                    return this.$vuetify.lang.t(this.counterString, m);
                  var v = this.internalArrayValue.reduce(function(y, E) {
                    var C = E.size, x = C === void 0 ? 0 : C;
                    return y + x;
                  }, 0);
                  return this.$vuetify.lang.t(this.counterSizeString, m, Object(l.humanReadableFileSize)(v, this.base === 1024));
                },
                internalArrayValue: function() {
                  return Object(l.wrapInArray)(this.internalValue);
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(m) {
                    this.lazyValue = m, this.$emit("change", this.lazyValue);
                  }
                },
                isDirty: function() {
                  return this.internalArrayValue.length > 0;
                },
                isLabelActive: function() {
                  return this.isDirty;
                },
                text: function() {
                  var m = this;
                  return !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? [this.placeholder] : this.internalArrayValue.map(function(v) {
                    var y = v.name, E = y === void 0 ? "" : y, C = v.size, x = C === void 0 ? 0 : C, b = m.truncateText(E);
                    return m.showSize ? b + " (" + Object(l.humanReadableFileSize)(x, m.base === 1024) + ")" : b;
                  });
                },
                base: function() {
                  return typeof this.showSize != "boolean" ? this.showSize : void 0;
                },
                hasChips: function() {
                  return this.chips || this.smallChips;
                }
              },
              watch: {
                readonly: {
                  handler: function(m) {
                    m === !0 && Object(f.consoleError)("readonly is not supported on <v-file-input>", this);
                  },
                  immediate: !0
                },
                value: function(m) {
                  var v = this.multiple ? m : m ? [m] : [];
                  Object(l.deepEqual)(v, this.$refs.input.files) || (this.$refs.input.value = "");
                }
              },
              methods: {
                clearableCallback: function() {
                  this.internalValue = this.multiple ? [] : null, this.$refs.input.value = "";
                },
                genChips: function() {
                  var m = this;
                  return this.isDirty ? this.text.map(function(v, y) {
                    return m.$createElement(o.VChip, {
                      props: {
                        small: m.smallChips
                      },
                      on: {
                        "click:close": function() {
                          var C = m.internalValue;
                          C.splice(y, 1), m.internalValue = C;
                        }
                      }
                    }, [v]);
                  }) : [];
                },
                genControl: function() {
                  var m = a.default.options.methods.genControl.call(this);
                  return this.hideInput && (m.data.style = Object(d.mergeStyles)(m.data.style, {
                    display: "none"
                  })), m;
                },
                genInput: function() {
                  var m = a.default.options.methods.genInput.call(this);
                  return m.data.attrs.multiple = this.multiple, delete m.data.domProps.value, delete m.data.on.input, m.data.on.change = this.onInput, [this.genSelections(), m];
                },
                genPrependSlot: function() {
                  var m = this;
                  if (!this.prependIcon)
                    return null;
                  var v = this.genIcon("prepend", function() {
                    m.$refs.input.click();
                  });
                  return this.genSlot("prepend", "outer", [v]);
                },
                genSelectionText: function() {
                  var m = this.text.length;
                  return m < 2 ? this.text : this.showSize && !this.counter ? [this.computedCounterValue] : [this.$vuetify.lang.t(this.counterString, m)];
                },
                genSelections: function() {
                  var m = this, v = [];
                  return this.isDirty && this.$scopedSlots.selection ? this.internalArrayValue.forEach(function(y, E) {
                    m.$scopedSlots.selection && v.push(m.$scopedSlots.selection({
                      text: m.text[E],
                      file: y,
                      index: E
                    }));
                  }) : v.push(this.hasChips && this.isDirty ? this.genChips() : this.genSelectionText()), this.$createElement("div", {
                    staticClass: "v-file-input__text",
                    class: {
                      "v-file-input__text--placeholder": this.placeholder && !this.isDirty,
                      "v-file-input__text--chips": this.hasChips && !this.$scopedSlots.selection
                    }
                  }, v);
                },
                genTextFieldSlot: function() {
                  var m = this, v = a.default.options.methods.genTextFieldSlot.call(this);
                  return v.data.on = c(c({}, v.data.on || {}), {
                    click: function(E) {
                      E.target && E.target.nodeName === "LABEL" || m.$refs.input.click();
                    }
                  }), v;
                },
                onInput: function(m) {
                  var v = p([], h(m.target.files || []), !1);
                  this.internalValue = this.multiple ? v : v[0], this.initialValue = this.internalValue;
                },
                onKeyDown: function(m) {
                  this.$emit("keydown", m);
                },
                truncateText: function(m) {
                  if (m.length < Number(this.truncateLength))
                    return m;
                  var v = Math.floor((Number(this.truncateLength) - 1) / 2);
                  return m.slice(0, v) + "" + m.slice(m.length - v);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VFileInput/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VFileInput/index.ts ***!
            \********************************************/
          /*! exports provided: VFileInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VFileInput */
              "./src/components/VFileInput/VFileInput.ts"
            );
            i.d(r, "VFileInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VFooter/VFooter.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VFooter/VFooter.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VFooter/VFooter.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VFooter/VFooter.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VFooter.sass */
              "./src/components/VFooter/VFooter.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), l = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, Object(o.default)("footer", ["height", "inset"]), l.default).extend({
              name: "v-footer",
              props: {
                height: {
                  default: "auto",
                  type: [Number, String]
                },
                inset: Boolean,
                padless: Boolean,
                tag: {
                  type: String,
                  default: "footer"
                }
              },
              computed: {
                applicationProperty: function() {
                  return this.inset ? "insetFooter" : "footer";
                },
                classes: function() {
                  return u(u({}, a.default.options.computed.classes.call(this)), {
                    "v-footer--absolute": this.absolute,
                    "v-footer--fixed": !this.absolute && (this.app || this.fixed),
                    "v-footer--padless": this.padless,
                    "v-footer--inset": this.inset
                  });
                },
                computedBottom: function() {
                  if (this.isPositioned)
                    return this.app ? this.$vuetify.application.bottom : 0;
                },
                computedLeft: function() {
                  if (this.isPositioned)
                    return this.app && this.inset ? this.$vuetify.application.left : 0;
                },
                computedRight: function() {
                  if (this.isPositioned)
                    return this.app && this.inset ? this.$vuetify.application.right : 0;
                },
                isPositioned: function() {
                  return !!(this.absolute || this.fixed || this.app);
                },
                styles: function() {
                  var h = parseInt(this.height);
                  return u(u({}, a.default.options.computed.styles.call(this)), {
                    height: isNaN(h) ? h : Object(d.convertToUnit)(h),
                    left: Object(d.convertToUnit)(this.computedLeft),
                    right: Object(d.convertToUnit)(this.computedRight),
                    bottom: Object(d.convertToUnit)(this.computedBottom)
                  });
                }
              },
              methods: {
                updateApplication: function() {
                  var h = parseInt(this.height);
                  return isNaN(h) ? this.$el ? this.$el.clientHeight : 0 : h;
                }
              },
              render: function(h) {
                var p = this.setBackgroundColor(this.color, {
                  staticClass: "v-footer",
                  class: this.classes,
                  style: this.styles
                });
                return h(this.tag, p, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VFooter/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VFooter/index.ts ***!
            \*****************************************/
          /*! exports provided: VFooter, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VFooter */
              "./src/components/VFooter/VFooter.ts"
            );
            i.d(r, "VFooter", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VForm/VForm.ts": (
          /*!***************************************!*\
            !*** ./src/components/VForm/VForm.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(a.default)(
              o.default,
              Object(l.provide)("form")
              /* @vue/component */
            ).extend({
              name: "v-form",
              provide: function() {
                return {
                  form: this
                };
              },
              inheritAttrs: !1,
              props: {
                disabled: Boolean,
                lazyValidation: Boolean,
                readonly: Boolean,
                value: Boolean
              },
              data: function() {
                return {
                  inputs: [],
                  watchers: [],
                  errorBag: {}
                };
              },
              watch: {
                errorBag: {
                  handler: function(u) {
                    var c = Object.values(u).includes(!0);
                    this.$emit("input", !c);
                  },
                  deep: !0,
                  immediate: !0
                }
              },
              methods: {
                watchInput: function(u) {
                  var c = this, h = function(m) {
                    return m.$watch("hasError", function(v) {
                      c.$set(c.errorBag, m._uid, v);
                    }, {
                      immediate: !0
                    });
                  }, p = {
                    _uid: u._uid,
                    valid: function() {
                    },
                    shouldValidate: function() {
                    }
                  };
                  return this.lazyValidation ? p.shouldValidate = u.$watch("shouldValidate", function(g) {
                    g && (c.errorBag.hasOwnProperty(u._uid) || (p.valid = h(u)));
                  }) : p.valid = h(u), p;
                },
                /** @public */
                validate: function() {
                  return this.inputs.filter(function(u) {
                    return !u.validate(!0);
                  }).length === 0;
                },
                /** @public */
                reset: function() {
                  this.inputs.forEach(function(u) {
                    return u.reset();
                  }), this.resetErrorBag();
                },
                resetErrorBag: function() {
                  var u = this;
                  this.lazyValidation && setTimeout(function() {
                    u.errorBag = {};
                  }, 0);
                },
                /** @public */
                resetValidation: function() {
                  this.inputs.forEach(function(u) {
                    return u.resetValidation();
                  }), this.resetErrorBag();
                },
                register: function(u) {
                  this.inputs.push(u), this.watchers.push(this.watchInput(u));
                },
                unregister: function(u) {
                  var c = this.inputs.find(function(p) {
                    return p._uid === u._uid;
                  });
                  if (c) {
                    var h = this.watchers.find(function(p) {
                      return p._uid === c._uid;
                    });
                    h && (h.valid(), h.shouldValidate()), this.watchers = this.watchers.filter(function(p) {
                      return p._uid !== c._uid;
                    }), this.inputs = this.inputs.filter(function(p) {
                      return p._uid !== c._uid;
                    }), this.$delete(this.errorBag, c._uid);
                  }
                }
              },
              render: function(u) {
                var c = this;
                return u("form", {
                  staticClass: "v-form",
                  attrs: f({
                    novalidate: !0
                  }, this.attrs$),
                  on: {
                    submit: function(p) {
                      return c.$emit("submit", p);
                    }
                  }
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VForm/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VForm/index.ts ***!
            \***************************************/
          /*! exports provided: VForm, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VForm */
              "./src/components/VForm/VForm.ts"
            );
            i.d(r, "VForm", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VGrid/VCol.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/VCol.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, d.apply(this, arguments);
            }, u = ["sm", "md", "lg", "xl"], c = function() {
              return u.reduce(function(y, E) {
                return y[E] = {
                  type: [Boolean, String, Number],
                  default: !1
                }, y;
              }, {});
            }(), h = function() {
              return u.reduce(function(y, E) {
                return y["offset" + Object(f.upperFirst)(E)] = {
                  type: [String, Number],
                  default: null
                }, y;
              }, {});
            }(), p = function() {
              return u.reduce(function(y, E) {
                return y["order" + Object(f.upperFirst)(E)] = {
                  type: [String, Number],
                  default: null
                }, y;
              }, {});
            }(), g = {
              col: Object.keys(c),
              offset: Object.keys(h),
              order: Object.keys(p)
            };
            function m(y, E, C) {
              var x = y;
              if (!(C == null || C === !1)) {
                if (E) {
                  var b = E.replace(y, "");
                  x += "-" + b;
                }
                return y === "col" && (C === "" || C === !0) || (x += "-" + C), x.toLowerCase();
              }
            }
            var v = /* @__PURE__ */ new Map();
            r.default = o.a.extend({
              name: "v-col",
              functional: !0,
              props: d(d(d(d(d(d({
                cols: {
                  type: [Boolean, String, Number],
                  default: !1
                }
              }, c), {
                offset: {
                  type: [String, Number],
                  default: null
                }
              }), h), {
                order: {
                  type: [String, Number],
                  default: null
                }
              }), p), {
                alignSelf: {
                  type: String,
                  default: null,
                  validator: function(E) {
                    return ["auto", "start", "end", "center", "baseline", "stretch"].includes(E);
                  }
                },
                tag: {
                  type: String,
                  default: "div"
                }
              }),
              render: function(E, C) {
                var x, b = C.props, P = C.data, O = C.children;
                C.parent;
                var T = "";
                for (var M in b)
                  T += String(b[M]);
                var L = v.get(T);
                if (!L) {
                  L = [];
                  var A;
                  for (A in g)
                    g[A].forEach(function(I) {
                      var w = b[I], B = m(A, I, w);
                      B && L.push(B);
                    });
                  var D = L.some(function(I) {
                    return I.startsWith("col-");
                  });
                  L.push((x = {
                    // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
                    col: !D || !b.cols
                  }, x["col-" + b.cols] = b.cols, x["offset-" + b.offset] = b.offset, x["order-" + b.order] = b.order, x["align-self-" + b.alignSelf] = b.alignSelf, x)), v.set(T, L);
                }
                return E(b.tag, Object(l.default)(P, {
                  class: L
                }), O);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VContainer.ts": (
          /*!********************************************!*\
            !*** ./src/components/VGrid/VContainer.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            ), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            ), o = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            );
            r.default = Object(a.default)("container").extend({
              name: "v-container",
              functional: !0,
              props: {
                id: String,
                tag: {
                  type: String,
                  default: "div"
                },
                fluid: {
                  type: Boolean,
                  default: !1
                }
              },
              render: function(f, d) {
                var u = d.props, c = d.data, h = d.children, p, g = c.attrs;
                return g && (c.attrs = {}, p = Object.keys(g).filter(function(m) {
                  if (m === "slot")
                    return !1;
                  var v = g[m];
                  return m.startsWith("data-") ? (c.attrs[m] = v, !1) : v || typeof v == "string";
                })), u.id && (c.domProps = c.domProps || {}, c.domProps.id = u.id), f(u.tag, Object(o.default)(c, {
                  staticClass: "container",
                  class: Array({
                    "container--fluid": u.fluid
                  }).concat(p || [])
                }), h);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VFlex.ts": (
          /*!***************************************!*\
            !*** ./src/components/VGrid/VFlex.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            );
            r.default = Object(a.default)("flex");
          }
        ),
        /***/
        "./src/components/VGrid/VGrid.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VGrid.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VGrid/VLayout.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VLayout.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ./grid */
              "./src/components/VGrid/grid.ts"
            );
            r.default = Object(a.default)("layout");
          }
        ),
        /***/
        "./src/components/VGrid/VRow.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/VRow.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VGrid.sass */
              "./src/components/VGrid/VGrid.sass"
            );
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(M) {
                for (var L, A = 1, D = arguments.length; A < D; A++) {
                  L = arguments[A];
                  for (var I in L)
                    Object.prototype.hasOwnProperty.call(L, I) && (M[I] = L[I]);
                }
                return M;
              }, d.apply(this, arguments);
            }, u = function(M, L) {
              var A = typeof Symbol == "function" && M[Symbol.iterator];
              if (!A)
                return M;
              var D = A.call(M), I, w = [], B;
              try {
                for (; (L === void 0 || L-- > 0) && !(I = D.next()).done; )
                  w.push(I.value);
              } catch (j) {
                B = {
                  error: j
                };
              } finally {
                try {
                  I && !I.done && (A = D.return) && A.call(D);
                } finally {
                  if (B)
                    throw B.error;
                }
              }
              return w;
            }, c = function(M, L, A) {
              if (A || arguments.length === 2)
                for (var D = 0, I = L.length, w; D < I; D++)
                  (w || !(D in L)) && (w || (w = Array.prototype.slice.call(L, 0, D)), w[D] = L[D]);
              return M.concat(w || Array.prototype.slice.call(L));
            }, h = ["sm", "md", "lg", "xl"], p = ["start", "end", "center"];
            function g(M, L) {
              return h.reduce(function(A, D) {
                return A[M + Object(f.upperFirst)(D)] = L(), A;
              }, {});
            }
            var m = function(L) {
              return c(c([], u(p), !1), ["baseline", "stretch"], !1).includes(L);
            }, v = g("align", function() {
              return {
                type: String,
                default: null,
                validator: m
              };
            }), y = function(L) {
              return c(c([], u(p), !1), ["space-between", "space-around"], !1).includes(L);
            }, E = g("justify", function() {
              return {
                type: String,
                default: null,
                validator: y
              };
            }), C = function(L) {
              return c(c([], u(p), !1), ["space-between", "space-around", "stretch"], !1).includes(L);
            }, x = g("alignContent", function() {
              return {
                type: String,
                default: null,
                validator: C
              };
            }), b = {
              align: Object.keys(v),
              justify: Object.keys(E),
              alignContent: Object.keys(x)
            }, P = {
              align: "align",
              justify: "justify",
              alignContent: "align-content"
            };
            function O(M, L, A) {
              var D = P[M];
              if (A != null) {
                if (L) {
                  var I = L.replace(M, "");
                  D += "-" + I;
                }
                return D += "-" + A, D.toLowerCase();
              }
            }
            var T = /* @__PURE__ */ new Map();
            r.default = o.a.extend({
              name: "v-row",
              functional: !0,
              props: d(d(d(d(d({
                tag: {
                  type: String,
                  default: "div"
                },
                dense: Boolean,
                noGutters: Boolean,
                align: {
                  type: String,
                  default: null,
                  validator: m
                }
              }, v), {
                justify: {
                  type: String,
                  default: null,
                  validator: y
                }
              }), E), {
                alignContent: {
                  type: String,
                  default: null,
                  validator: C
                }
              }), x),
              render: function(L, A) {
                var D, I = A.props, w = A.data, B = A.children, j = "";
                for (var k in I)
                  j += String(I[k]);
                var X = T.get(j);
                if (!X) {
                  X = [];
                  var rt;
                  for (rt in b)
                    b[rt].forEach(function(et) {
                      var Z = I[et], dt = O(rt, et, Z);
                      dt && X.push(dt);
                    });
                  X.push((D = {
                    "no-gutters": I.noGutters,
                    "row--dense": I.dense
                  }, D["align-" + I.align] = I.align, D["justify-" + I.justify] = I.justify, D["align-content-" + I.alignContent] = I.alignContent, D)), T.set(j, X);
                }
                return L(I.tag, Object(l.default)(w, {
                  staticClass: "row",
                  class: X
                }), B);
              }
            });
          }
        ),
        /***/
        "./src/components/VGrid/VSpacer.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/VSpacer.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./_grid.sass */
              "./src/components/VGrid/_grid.sass"
            );
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(a.createSimpleFunctional)("spacer", "div", "v-spacer");
          }
        ),
        /***/
        "./src/components/VGrid/_grid.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VGrid/_grid.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VGrid/grid.ts": (
          /*!**************************************!*\
            !*** ./src/components/VGrid/grid.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(f) {
              return o.a.extend({
                name: "v-" + f,
                functional: !0,
                props: {
                  id: String,
                  tag: {
                    type: String,
                    default: "div"
                  }
                },
                render: function(u, c) {
                  var h = c.props, p = c.data, g = c.children;
                  p.staticClass = (f + " " + (p.staticClass || "")).trim();
                  var m = p.attrs;
                  if (m) {
                    p.attrs = {};
                    var v = Object.keys(m).filter(function(y) {
                      if (y === "slot")
                        return !1;
                      var E = m[y];
                      return y.startsWith("data-") ? (p.attrs[y] = E, !1) : E || typeof E == "string";
                    });
                    v.length && (p.staticClass += " " + v.join(" "));
                  }
                  return h.id && (p.domProps = p.domProps || {}, p.domProps.id = h.id), u(h.tag, p, g);
                }
              });
            }
          }
        ),
        /***/
        "./src/components/VGrid/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VGrid/index.ts ***!
            \***************************************/
          /*! exports provided: VContainer, VCol, VRow, VSpacer, VLayout, VFlex, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VContainer */
              "./src/components/VGrid/VContainer.ts"
            );
            i.d(r, "VContainer", function() {
              return a.default;
            });
            var o = i(
              /*! ./VCol */
              "./src/components/VGrid/VCol.ts"
            );
            i.d(r, "VCol", function() {
              return o.default;
            });
            var l = i(
              /*! ./VRow */
              "./src/components/VGrid/VRow.ts"
            );
            i.d(r, "VRow", function() {
              return l.default;
            });
            var f = i(
              /*! ./VSpacer */
              "./src/components/VGrid/VSpacer.ts"
            );
            i.d(r, "VSpacer", function() {
              return f.default;
            });
            var d = i(
              /*! ./VLayout */
              "./src/components/VGrid/VLayout.ts"
            );
            i.d(r, "VLayout", function() {
              return d.default;
            });
            var u = i(
              /*! ./VFlex */
              "./src/components/VGrid/VFlex.ts"
            );
            i.d(r, "VFlex", function() {
              return u.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VContainer: a.default,
                VCol: o.default,
                VRow: l.default,
                VSpacer: f.default,
                VLayout: d.default,
                VFlex: u.default
              }
            };
          }
        ),
        /***/
        "./src/components/VHover/VHover.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VHover/VHover.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), o = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = Object(l.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-hover",
              props: {
                disabled: {
                  type: Boolean,
                  default: !1
                },
                value: {
                  type: Boolean,
                  default: void 0
                }
              },
              methods: {
                onMouseEnter: function() {
                  this.runDelay("open");
                },
                onMouseLeave: function() {
                  this.runDelay("close");
                }
              },
              render: function() {
                if (!this.$scopedSlots.default && this.value === void 0)
                  return Object(f.consoleWarn)("v-hover is missing a default scopedSlot or bound value", this), null;
                var u;
                return this.$scopedSlots.default && (u = this.$scopedSlots.default({
                  hover: this.isActive
                })), Array.isArray(u) && u.length === 1 && (u = u[0]), !u || Array.isArray(u) || !u.tag ? (Object(f.consoleWarn)("v-hover should only contain a single element", this), u) : (this.disabled || (u.data = u.data || {}, this._g(u.data, {
                  mouseenter: this.onMouseEnter,
                  mouseleave: this.onMouseLeave
                })), u);
              }
            });
          }
        ),
        /***/
        "./src/components/VHover/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VHover/index.ts ***!
            \****************************************/
          /*! exports provided: VHover, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VHover */
              "./src/components/VHover/VHover.ts"
            );
            i.d(r, "VHover", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VIcon/VIcon.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VIcon/VIcon.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VIcon/VIcon.ts": (
          /*!***************************************!*\
            !*** ./src/components/VIcon/VIcon.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VIcon.sass */
              "./src/components/VIcon/VIcon.sass"
            );
            var a = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! vue */
              "vue"
            ), c = /* @__PURE__ */ i.n(u), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(E) {
                for (var C, x = 1, b = arguments.length; x < b; x++) {
                  C = arguments[x];
                  for (var P in C)
                    Object.prototype.hasOwnProperty.call(C, P) && (E[P] = C[P]);
                }
                return E;
              }, p.apply(this, arguments);
            }, g;
            (function(E) {
              E.xSmall = "12px", E.small = "16px", E.default = "24px", E.medium = "28px", E.large = "36px", E.xLarge = "40px";
            })(g || (g = {}));
            function m(E) {
              return ["fas", "far", "fal", "fab", "fad", "fak"].some(function(C) {
                return E.includes(C);
              });
            }
            function v(E) {
              return /^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(E) && /[\dz]$/i.test(E) && E.length > 4;
            }
            var y = Object(h.default)(
              a.default,
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-icon",
              props: {
                dense: Boolean,
                disabled: Boolean,
                left: Boolean,
                right: Boolean,
                size: [Number, String],
                tag: {
                  type: String,
                  required: !1,
                  default: "i"
                }
              },
              computed: {
                medium: function() {
                  return !1;
                },
                hasClickListener: function() {
                  return !!(this.listeners$.click || this.listeners$["!click"]);
                }
              },
              methods: {
                getIcon: function() {
                  var C = "";
                  return this.$slots.default && (C = this.$slots.default[0].text.trim()), Object(d.remapInternalIcon)(this, C);
                },
                getSize: function() {
                  var C = {
                    xSmall: this.xSmall,
                    small: this.small,
                    medium: this.medium,
                    large: this.large,
                    xLarge: this.xLarge
                  }, x = Object(d.keys)(C).find(function(b) {
                    return C[b];
                  });
                  return x && g[x] || Object(d.convertToUnit)(this.size);
                },
                // Component data for both font icon and SVG wrapper span
                getDefaultData: function() {
                  return {
                    staticClass: "v-icon notranslate",
                    class: {
                      "v-icon--disabled": this.disabled,
                      "v-icon--left": this.left,
                      "v-icon--link": this.hasClickListener,
                      "v-icon--right": this.right,
                      "v-icon--dense": this.dense
                    },
                    attrs: p({
                      "aria-hidden": !this.hasClickListener,
                      disabled: this.hasClickListener && this.disabled,
                      type: this.hasClickListener ? "button" : void 0
                    }, this.attrs$),
                    on: this.listeners$
                  };
                },
                getSvgWrapperData: function() {
                  var C = this.getSize(), x = p(p({}, this.getDefaultData()), {
                    style: C ? {
                      fontSize: C,
                      height: C,
                      width: C
                    } : void 0
                  });
                  return this.applyColors(x), x;
                },
                applyColors: function(C) {
                  C.class = p(p({}, C.class), this.themeClasses), this.setTextColor(this.color, C);
                },
                renderFontIcon: function(C, x) {
                  var b = [], P = this.getDefaultData(), O = "material-icons", T = C.indexOf("-"), M = T <= -1;
                  M ? b.push(C) : (O = C.slice(0, T), m(O) && (O = "")), P.class[O] = !0, P.class[C] = !M;
                  var L = this.getSize();
                  return L && (P.style = {
                    fontSize: L
                  }), this.applyColors(P), x(this.hasClickListener ? "button" : this.tag, P, b);
                },
                renderSvgIcon: function(C, x) {
                  var b = {
                    class: "v-icon__svg",
                    attrs: {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: "0 0 24 24",
                      role: "img",
                      "aria-hidden": !0
                    }
                  }, P = this.getSize();
                  return P && (b.style = {
                    fontSize: P,
                    height: P,
                    width: P
                  }), x(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [x("svg", b, [x("path", {
                    attrs: {
                      d: C
                    }
                  })])]);
                },
                renderSvgIconComponent: function(C, x) {
                  var b = {
                    class: {
                      "v-icon__component": !0
                    }
                  }, P = this.getSize();
                  P && (b.style = {
                    fontSize: P,
                    height: P,
                    width: P
                  }), this.applyColors(b);
                  var O = C.component;
                  return b.props = C.props, b.nativeOn = b.on, x(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [x(O, b)]);
                }
              },
              render: function(C) {
                var x = this.getIcon();
                return typeof x == "string" ? v(x) ? this.renderSvgIcon(x, C) : this.renderFontIcon(x, C) : this.renderSvgIconComponent(x, C);
              }
            });
            r.default = c.a.extend({
              name: "v-icon",
              $_wrapperFor: y,
              functional: !0,
              render: function(C, x) {
                var b = x.data, P = x.children, O = "";
                return b.domProps && (O = b.domProps.textContent || b.domProps.innerHTML || O, delete b.domProps.textContent, delete b.domProps.innerHTML), C(y, b, O ? [O] : P);
              }
            });
          }
        ),
        /***/
        "./src/components/VIcon/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VIcon/index.ts ***!
            \***************************************/
          /*! exports provided: VIcon, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VIcon */
              "./src/components/VIcon/VIcon.ts"
            );
            i.d(r, "VIcon", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VImg/VImg.sass": (
          /*!***************************************!*\
            !*** ./src/components/VImg/VImg.sass ***!
            \***************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VImg/VImg.ts": (
          /*!*************************************!*\
            !*** ./src/components/VImg/VImg.ts ***!
            \*************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VImg.sass */
              "./src/components/VImg/VImg.sass"
            );
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../VResponsive */
              "./src/components/VResponsive/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            function h(g) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? h = function(v) {
                return typeof v;
              } : h = function(v) {
                return v && typeof Symbol == "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v;
              }, h(g);
            }
            var p = typeof window < "u" && "IntersectionObserver" in window;
            r.default = Object(f.default)(o.default, l.default).extend({
              name: "v-img",
              directives: {
                intersect: a.default
              },
              props: {
                alt: String,
                contain: Boolean,
                eager: Boolean,
                gradient: String,
                lazySrc: String,
                options: {
                  type: Object,
                  // For more information on types, navigate to:
                  // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                  default: function() {
                    return {
                      root: void 0,
                      rootMargin: void 0,
                      threshold: void 0
                    };
                  }
                },
                position: {
                  type: String,
                  default: "center center"
                },
                sizes: String,
                src: {
                  type: [String, Object],
                  default: ""
                },
                srcset: String,
                transition: {
                  type: [Boolean, String],
                  default: "fade-transition"
                }
              },
              data: function() {
                return {
                  currentSrc: "",
                  image: null,
                  isLoading: !0,
                  calculatedAspectRatio: void 0,
                  naturalWidth: void 0,
                  hasError: !1
                };
              },
              computed: {
                computedAspectRatio: function() {
                  return Number(this.normalisedSrc.aspect || this.calculatedAspectRatio);
                },
                normalisedSrc: function() {
                  return this.src && h(this.src) === "object" ? {
                    src: this.src.src,
                    srcset: this.srcset || this.src.srcset,
                    lazySrc: this.lazySrc || this.src.lazySrc,
                    aspect: Number(this.aspectRatio || this.src.aspect)
                  } : {
                    src: this.src,
                    srcset: this.srcset,
                    lazySrc: this.lazySrc,
                    aspect: Number(this.aspectRatio || 0)
                  };
                },
                __cachedImage: function() {
                  if (!(this.normalisedSrc.src || this.normalisedSrc.lazySrc || this.gradient))
                    return [];
                  var m = [], v = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc;
                  this.gradient && m.push("linear-gradient(" + this.gradient + ")"), v && m.push('url("' + v + '")');
                  var y = this.$createElement("div", {
                    staticClass: "v-image__image",
                    class: {
                      "v-image__image--preload": this.isLoading,
                      "v-image__image--contain": this.contain,
                      "v-image__image--cover": !this.contain
                    },
                    style: {
                      backgroundImage: m.join(", "),
                      backgroundPosition: this.position
                    },
                    key: +this.isLoading
                  });
                  return this.transition ? this.$createElement("transition", {
                    attrs: {
                      name: this.transition,
                      mode: "in-out"
                    }
                  }, [y]) : y;
                }
              },
              watch: {
                src: function() {
                  this.isLoading ? this.loadImage() : this.init(void 0, void 0, !0);
                },
                "$vuetify.breakpoint.width": "getSrc"
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function(m, v, y) {
                  if (!(p && !y && !this.eager)) {
                    if (this.normalisedSrc.lazySrc) {
                      var E = new Image();
                      E.src = this.normalisedSrc.lazySrc, this.pollForSize(E, null);
                    }
                    this.normalisedSrc.src && this.loadImage();
                  }
                },
                onLoad: function() {
                  this.getSrc(), this.isLoading = !1, this.$emit("load", this.src), this.image && (this.normalisedSrc.src.endsWith(".svg") || this.normalisedSrc.src.startsWith("data:image/svg+xml")) && (this.image.naturalHeight && this.image.naturalWidth ? (this.naturalWidth = this.image.naturalWidth, this.calculatedAspectRatio = this.image.naturalWidth / this.image.naturalHeight) : this.calculatedAspectRatio = 1);
                },
                onError: function() {
                  this.hasError = !0, this.$emit("error", this.src);
                },
                getSrc: function() {
                  this.image && (this.currentSrc = this.image.currentSrc || this.image.src);
                },
                loadImage: function() {
                  var m = this, v = new Image();
                  this.image = v, v.onload = function() {
                    v.decode ? v.decode().catch(function(y) {
                      Object(u.consoleWarn)(`Failed to decode image, trying to render anyway

` + ("src: " + m.normalisedSrc.src) + (y.message ? `
Original error: ` + y.message : ""), m);
                    }).then(m.onLoad) : m.onLoad();
                  }, v.onerror = this.onError, this.hasError = !1, this.sizes && (v.sizes = this.sizes), this.normalisedSrc.srcset && (v.srcset = this.normalisedSrc.srcset), v.src = this.normalisedSrc.src, this.$emit("loadstart", this.normalisedSrc.src), this.aspectRatio || this.pollForSize(v), this.getSrc();
                },
                pollForSize: function(m, v) {
                  var y = this;
                  v === void 0 && (v = 100);
                  var E = function C() {
                    var x = m.naturalHeight, b = m.naturalWidth;
                    x || b ? (y.naturalWidth = b, y.calculatedAspectRatio = b / x) : !m.complete && y.isLoading && !y.hasError && v != null && setTimeout(C, v);
                  };
                  E();
                },
                genContent: function() {
                  var m = o.default.options.methods.genContent.call(this);
                  return this.naturalWidth && this._b(m.data, "div", {
                    style: {
                      width: this.naturalWidth + "px"
                    }
                  }), m;
                },
                __genPlaceholder: function() {
                  var m = Object(c.getSlot)(this, "placeholder");
                  if (m) {
                    var v = this.isLoading ? [this.$createElement("div", {
                      staticClass: "v-image__placeholder"
                    }, m)] : [];
                    return this.transition ? this.$createElement("transition", {
                      props: {
                        appear: !0,
                        name: this.transition
                      }
                    }, v) : v[0];
                  }
                }
              },
              render: function(m) {
                var v = o.default.options.render.call(this, m), y = Object(d.default)(v.data, {
                  staticClass: "v-image",
                  attrs: {
                    "aria-label": this.alt,
                    role: this.alt ? "img" : void 0
                  },
                  class: this.themeClasses,
                  // Only load intersect directive if it
                  // will work in the current browser.
                  directives: p ? [{
                    name: "intersect",
                    modifiers: {
                      once: !0
                    },
                    value: {
                      handler: this.init,
                      options: this.options
                    }
                  }] : void 0
                });
                return v.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()], m(v.tag, y, v.children);
              }
            });
          }
        ),
        /***/
        "./src/components/VImg/index.ts": (
          /*!**************************************!*\
            !*** ./src/components/VImg/index.ts ***!
            \**************************************/
          /*! exports provided: VImg, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VImg */
              "./src/components/VImg/VImg.ts"
            );
            i.d(r, "VImg", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VInput/VInput.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VInput/VInput.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VInput/VInput.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VInput/VInput.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VInput.sass */
              "./src/components/VInput/VInput.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), l = i(
              /*! ../VMessages */
              "./src/components/VMessages/index.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/validatable */
              "./src/mixins/validatable/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(f.default, d.default);
            r.default = g.extend().extend({
              name: "v-input",
              inheritAttrs: !1,
              props: {
                appendIcon: String,
                backgroundColor: {
                  type: String,
                  default: ""
                },
                dense: Boolean,
                height: [Number, String],
                hideDetails: [Boolean, String],
                hideSpinButtons: Boolean,
                hint: String,
                id: String,
                label: String,
                loading: Boolean,
                persistentHint: Boolean,
                prependIcon: String,
                value: null
              },
              data: function() {
                return {
                  lazyValue: this.value,
                  hasMouseDown: !1
                };
              },
              computed: {
                classes: function() {
                  return p({
                    "v-input--has-state": this.hasState,
                    "v-input--hide-details": !this.showDetails,
                    "v-input--is-label-active": this.isLabelActive,
                    "v-input--is-dirty": this.isDirty,
                    "v-input--is-disabled": this.isDisabled,
                    "v-input--is-focused": this.isFocused,
                    // <v-switch loading>.loading === '' so we can't just cast to boolean
                    "v-input--is-loading": this.loading !== !1 && this.loading != null,
                    "v-input--is-readonly": this.isReadonly,
                    "v-input--dense": this.dense,
                    "v-input--hide-spin-buttons": this.hideSpinButtons
                  }, this.themeClasses);
                },
                computedId: function() {
                  return this.id || "input-" + this._uid;
                },
                hasDetails: function() {
                  return this.messagesToDisplay.length > 0;
                },
                hasHint: function() {
                  return !this.hasMessages && !!this.hint && (this.persistentHint || this.isFocused);
                },
                hasLabel: function() {
                  return !!(this.$slots.label || this.label);
                },
                // Proxy for `lazyValue`
                // This allows an input
                // to function without
                // a provided model
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(v) {
                    this.lazyValue = v, this.$emit(this.$_modelEvent, v);
                  }
                },
                isDirty: function() {
                  return !!this.lazyValue;
                },
                isLabelActive: function() {
                  return this.isDirty;
                },
                messagesToDisplay: function() {
                  var v = this;
                  return this.hasHint ? [this.hint] : this.hasMessages ? this.validations.map(function(y) {
                    if (typeof y == "string")
                      return y;
                    var E = y(v.internalValue);
                    return typeof E == "string" ? E : "";
                  }).filter(function(y) {
                    return y !== "";
                  }) : [];
                },
                showDetails: function() {
                  return this.hideDetails === !1 || this.hideDetails === "auto" && this.hasDetails;
                }
              },
              watch: {
                value: function(v) {
                  this.lazyValue = v;
                }
              },
              beforeCreate: function() {
                this.$_modelEvent = this.$options.model && this.$options.model.event || "input";
              },
              methods: {
                genContent: function() {
                  return [this.genPrependSlot(), this.genControl(), this.genAppendSlot()];
                },
                genControl: function() {
                  return this.$createElement("div", {
                    staticClass: "v-input__control",
                    attrs: {
                      title: this.attrs$.title
                    }
                  }, [this.genInputSlot(), this.genMessages()]);
                },
                genDefaultSlot: function() {
                  return [this.genLabel(), this.$slots.default];
                },
                genIcon: function(v, y, E) {
                  var C = this, x;
                  E === void 0 && (E = {});
                  var b = this[v + "Icon"], P = "click:" + Object(u.kebabCase)(v), O = !!(this.listeners$[P] || y), T = {
                    prepend: "prependAction",
                    prependInner: "prependAction",
                    append: "appendAction",
                    appendOuter: "appendAction",
                    clear: "clear"
                  }[v], M = O && T ? this.$vuetify.lang.t("$vuetify.input." + T, (x = this.label) !== null && x !== void 0 ? x : "") : void 0, L = Object(c.default)({
                    attrs: {
                      "aria-label": M,
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      light: this.light,
                      tabindex: v === "clear" ? -1 : void 0
                    },
                    on: O ? {
                      click: function(D) {
                        D.preventDefault(), D.stopPropagation(), C.$emit(P, D), y && y(D);
                      },
                      // Container has g event that will
                      // trigger menu open if enclosed
                      mouseup: function(D) {
                        D.preventDefault(), D.stopPropagation();
                      }
                    } : void 0
                  }, E);
                  return this.$createElement("div", {
                    staticClass: "v-input__icon",
                    class: v ? "v-input__icon--" + Object(u.kebabCase)(v) : void 0
                  }, [this.$createElement(a.default, L, b)]);
                },
                genInputSlot: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
                    staticClass: "v-input__slot",
                    style: {
                      height: Object(u.convertToUnit)(this.height)
                    },
                    on: {
                      click: this.onClick,
                      mousedown: this.onMouseDown,
                      mouseup: this.onMouseUp
                    },
                    ref: "input-slot"
                  }), [this.genDefaultSlot()]);
                },
                genLabel: function() {
                  return this.hasLabel ? this.$createElement(o.default, {
                    props: {
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      focused: this.hasState,
                      for: this.computedId,
                      light: this.light
                    }
                  }, this.$slots.label || this.label) : null;
                },
                genMessages: function() {
                  var v = this;
                  return this.showDetails ? this.$createElement(l.default, {
                    props: {
                      color: this.hasHint ? "" : this.validationState,
                      dark: this.dark,
                      light: this.light,
                      value: this.messagesToDisplay
                    },
                    attrs: {
                      role: this.hasMessages ? "alert" : null
                    },
                    scopedSlots: {
                      default: function(E) {
                        return Object(u.getSlot)(v, "message", E);
                      }
                    }
                  }) : null;
                },
                genSlot: function(v, y, E) {
                  if (!E.length)
                    return null;
                  var C = v + "-" + y;
                  return this.$createElement("div", {
                    staticClass: "v-input__" + C,
                    ref: C
                  }, E);
                },
                genPrependSlot: function() {
                  var v = [];
                  return this.$slots.prepend ? v.push(this.$slots.prepend) : this.prependIcon && v.push(this.genIcon("prepend")), this.genSlot("prepend", "outer", v);
                },
                genAppendSlot: function() {
                  var v = [];
                  return this.$slots.append ? v.push(this.$slots.append) : this.appendIcon && v.push(this.genIcon("append")), this.genSlot("append", "outer", v);
                },
                onClick: function(v) {
                  this.$emit("click", v);
                },
                onMouseDown: function(v) {
                  this.hasMouseDown = !0, this.$emit("mousedown", v);
                },
                onMouseUp: function(v) {
                  this.hasMouseDown = !1, this.$emit("mouseup", v);
                }
              },
              render: function(v) {
                return v("div", this.setTextColor(this.validationState, {
                  staticClass: "v-input",
                  class: this.classes
                }), this.genContent());
              }
            });
          }
        ),
        /***/
        "./src/components/VInput/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VInput/index.ts ***!
            \****************************************/
          /*! exports provided: VInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VInput */
              "./src/components/VInput/VInput.ts"
            );
            i.d(r, "VInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VItemGroup/VItem.sass": (
          /*!**********************************************!*\
            !*** ./src/components/VItemGroup/VItem.sass ***!
            \**********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VItemGroup/VItem.ts": (
          /*!********************************************!*\
            !*** ./src/components/VItemGroup/VItem.ts ***!
            \********************************************/
          /*! exports provided: BaseItem, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "BaseItem", function() {
              return c;
            }), i(
              /*! ./VItem.sass */
              "./src/components/VItemGroup/VItem.sass"
            );
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = d.a.extend({
              props: {
                activeClass: String,
                value: {
                  required: !1
                },
                disabled: Boolean
              },
              data: function() {
                return {
                  isActive: !1
                };
              },
              methods: {
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              },
              render: function() {
                var p;
                if (!this.$scopedSlots.default)
                  return Object(l.consoleWarn)("v-item is missing a default scopedSlot", this), null;
                var g;
                return this.$scopedSlots.default && (g = this.$scopedSlots.default({
                  active: this.isActive,
                  toggle: this.toggle
                })), Array.isArray(g) && g.length === 1 && (g = g[0]), !g || Array.isArray(g) || !g.tag ? (Object(l.consoleWarn)("v-item should only contain a single element", this), g) : (g.data = this._b(g.data || {}, g.tag, {
                  class: (p = {}, p[this.activeClass] = this.isActive, p["v-item--disabled"] = this.disabled, p)
                }), this.disabled && (g.data.attrs = u(u({}, g.data.attrs), {
                  tabindex: -1
                })), g);
              }
            });
            r.default = Object(o.default)(c, Object(a.factory)("itemGroup", "v-item", "v-item-group")).extend({
              name: "v-item"
            });
          }
        ),
        /***/
        "./src/components/VItemGroup/VItemGroup.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VItemGroup/VItemGroup.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VItemGroup/VItemGroup.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VItemGroup/VItemGroup.ts ***!
            \*************************************************/
          /*! exports provided: BaseItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "BaseItemGroup", function() {
              return c;
            }), i(
              /*! ./VItemGroup.sass */
              "./src/components/VItemGroup/VItemGroup.sass"
            );
            var a = i(
              /*! ../../mixins/comparable */
              "./src/mixins/comparable/index.ts"
            ), o = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(f.default)(a.default, o.default, l.default).extend({
              name: "base-item-group",
              props: {
                activeClass: {
                  type: String,
                  default: "v-item--active"
                },
                mandatory: Boolean,
                max: {
                  type: [Number, String],
                  default: null
                },
                multiple: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              data: function() {
                return {
                  // As long as a value is defined, show it
                  // Otherwise, check if multiple
                  // to determine which default to provide
                  internalLazyValue: this.value !== void 0 ? this.value : this.multiple ? [] : void 0,
                  items: []
                };
              },
              computed: {
                classes: function() {
                  return u({
                    "v-item-group": !0
                  }, this.themeClasses);
                },
                selectedIndex: function() {
                  return this.selectedItem && this.items.indexOf(this.selectedItem) || -1;
                },
                selectedItem: function() {
                  if (!this.multiple)
                    return this.selectedItems[0];
                },
                selectedItems: function() {
                  var p = this;
                  return this.items.filter(function(g, m) {
                    return p.toggleMethod(p.getValue(g, m));
                  });
                },
                selectedValues: function() {
                  return this.internalValue == null ? [] : Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue];
                },
                toggleMethod: function() {
                  var p = this;
                  if (!this.multiple)
                    return function(m) {
                      return p.valueComparator(p.internalValue, m);
                    };
                  var g = this.internalValue;
                  return Array.isArray(g) ? function(m) {
                    return g.some(function(v) {
                      return p.valueComparator(v, m);
                    });
                  } : function() {
                    return !1;
                  };
                }
              },
              watch: {
                internalValue: "updateItemsState",
                items: "updateItemsState"
              },
              created: function() {
                this.multiple && !Array.isArray(this.internalValue) && Object(d.consoleWarn)("Model must be bound to an array if the multiple property is true.", this);
              },
              methods: {
                genData: function() {
                  return {
                    class: this.classes
                  };
                },
                getValue: function(p, g) {
                  return p.value === void 0 ? g : p.value;
                },
                onClick: function(p) {
                  this.updateInternalValue(this.getValue(p, this.items.indexOf(p)));
                },
                register: function(p) {
                  var g = this, m = this.items.push(p) - 1;
                  p.$on("change", function() {
                    return g.onClick(p);
                  }), this.mandatory && !this.selectedValues.length && this.updateMandatory(), this.updateItem(p, m);
                },
                unregister: function(p) {
                  if (!this._isDestroyed) {
                    var g = this.items.indexOf(p), m = this.getValue(p, g);
                    this.items.splice(g, 1);
                    var v = this.selectedValues.indexOf(m);
                    if (!(v < 0)) {
                      if (!this.mandatory)
                        return this.updateInternalValue(m);
                      this.multiple && Array.isArray(this.internalValue) ? this.internalValue = this.internalValue.filter(function(y) {
                        return y !== m;
                      }) : this.internalValue = void 0, this.selectedItems.length || this.updateMandatory(!0);
                    }
                  }
                },
                updateItem: function(p, g) {
                  var m = this.getValue(p, g);
                  p.isActive = this.toggleMethod(m);
                },
                // https://github.com/vuetifyjs/vuetify/issues/5352
                updateItemsState: function() {
                  var p = this;
                  this.$nextTick(function() {
                    if (p.mandatory && !p.selectedItems.length)
                      return p.updateMandatory();
                    p.items.forEach(p.updateItem);
                  });
                },
                updateInternalValue: function(p) {
                  this.multiple ? this.updateMultiple(p) : this.updateSingle(p);
                },
                updateMandatory: function(p) {
                  if (this.items.length) {
                    var g = this.items.slice();
                    p && g.reverse();
                    var m = g.find(function(y) {
                      return !y.disabled;
                    });
                    if (m) {
                      var v = this.items.indexOf(m);
                      this.updateInternalValue(this.getValue(m, v));
                    }
                  }
                },
                updateMultiple: function(p) {
                  var g = this, m = Array.isArray(this.internalValue) ? this.internalValue : [], v = m.slice(), y = v.findIndex(function(E) {
                    return g.valueComparator(E, p);
                  });
                  this.mandatory && // Item already exists
                  y > -1 && // value would be reduced below min
                  v.length - 1 < 1 || // Max is set
                  this.max != null && // Item doesn't exist
                  y < 0 && // value would be increased above max
                  v.length + 1 > this.max || (y > -1 ? v.splice(y, 1) : v.push(p), this.internalValue = v);
                },
                updateSingle: function(p) {
                  var g = this.valueComparator(this.internalValue, p);
                  this.mandatory && g || (this.internalValue = g ? void 0 : p);
                }
              },
              render: function(p) {
                return p(this.tag, this.genData(), this.$slots.default);
              }
            });
            r.default = c.extend({
              name: "v-item-group",
              provide: function() {
                return {
                  itemGroup: this
                };
              }
            });
          }
        ),
        /***/
        "./src/components/VItemGroup/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VItemGroup/index.ts ***!
            \********************************************/
          /*! exports provided: VItem, VItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VItem */
              "./src/components/VItemGroup/VItem.ts"
            );
            i.d(r, "VItem", function() {
              return a.default;
            });
            var o = i(
              /*! ./VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            );
            i.d(r, "VItemGroup", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VItem: a.default,
                VItemGroup: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VLabel/VLabel.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VLabel/VLabel.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VLabel/VLabel.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VLabel/VLabel.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VLabel.sass */
              "./src/components/VLabel/VLabel.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(l.default)(o.default).extend({
              name: "v-label",
              functional: !0,
              props: {
                absolute: Boolean,
                color: {
                  type: String,
                  default: "primary"
                },
                disabled: Boolean,
                focused: Boolean,
                for: String,
                left: {
                  type: [Number, String],
                  default: 0
                },
                right: {
                  type: [Number, String],
                  default: "auto"
                },
                value: Boolean
              },
              render: function(h, p) {
                var g = p.children, m = p.listeners, v = p.props, y = p.data, E = Object(d.default)({
                  staticClass: "v-label",
                  class: u({
                    "v-label--active": v.value,
                    "v-label--is-disabled": v.disabled
                  }, Object(o.functionalThemeClasses)(p)),
                  attrs: {
                    for: v.for,
                    "aria-hidden": !v.for
                  },
                  on: m,
                  style: {
                    left: Object(f.convertToUnit)(v.left),
                    right: Object(f.convertToUnit)(v.right),
                    position: v.absolute ? "absolute" : "relative"
                  },
                  ref: "label"
                }, y);
                return h("label", a.default.options.methods.setTextColor(v.focused && v.color, E), g);
              }
            });
          }
        ),
        /***/
        "./src/components/VLabel/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VLabel/index.ts ***!
            \****************************************/
          /*! exports provided: VLabel, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VLabel */
              "./src/components/VLabel/VLabel.ts"
            );
            i.d(r, "VLabel", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VLazy/VLazy.ts": (
          /*!***************************************!*\
            !*** ./src/components/VLazy/VLazy.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, o.default).extend({
              name: "VLazy",
              directives: {
                intersect: l.default
              },
              props: {
                options: {
                  type: Object,
                  // For more information on types, navigate to:
                  // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                  default: function() {
                    return {
                      root: void 0,
                      rootMargin: void 0,
                      threshold: void 0
                    };
                  }
                },
                tag: {
                  type: String,
                  default: "div"
                },
                transition: {
                  type: String,
                  default: "fade-transition"
                }
              },
              computed: {
                styles: function() {
                  return u({}, this.measurableStyles);
                }
              },
              methods: {
                genContent: function() {
                  var h = this.isActive && Object(d.getSlot)(this);
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, h) : h;
                },
                onObserve: function(h, p, g) {
                  this.isActive || (this.isActive = g);
                }
              },
              render: function(h) {
                return h(this.tag, {
                  staticClass: "v-lazy",
                  attrs: this.$attrs,
                  directives: [{
                    name: "intersect",
                    value: {
                      handler: this.onObserve,
                      options: this.options
                    }
                  }],
                  on: this.$listeners,
                  style: this.styles
                }, [this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VLazy/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VLazy/index.ts ***!
            \***************************************/
          /*! exports provided: VLazy, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VLazy */
              "./src/components/VLazy/VLazy.ts"
            );
            i.d(r, "VLazy", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VList/VList.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VList/VList.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VList.ts": (
          /*!***************************************!*\
            !*** ./src/components/VList/VList.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VList.sass */
              "./src/components/VList/VList.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = function() {
              return o = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, o.apply(this, arguments);
            }, l = function(f) {
              var d = typeof Symbol == "function" && Symbol.iterator, u = d && f[d], c = 0;
              if (u)
                return u.call(f);
              if (f && typeof f.length == "number")
                return {
                  next: function() {
                    return f && c >= f.length && (f = void 0), {
                      value: f && f[c++],
                      done: !f
                    };
                  }
                };
              throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = a.default.extend().extend({
              name: "v-list",
              provide: function() {
                return {
                  isInList: !0,
                  list: this
                };
              },
              inject: {
                isInMenu: {
                  default: !1
                },
                isInNav: {
                  default: !1
                }
              },
              props: {
                dense: Boolean,
                disabled: Boolean,
                expand: Boolean,
                flat: Boolean,
                nav: Boolean,
                rounded: Boolean,
                subheader: Boolean,
                threeLine: Boolean,
                twoLine: Boolean
              },
              data: function() {
                return {
                  groups: []
                };
              },
              computed: {
                classes: function() {
                  return o(o({}, a.default.options.computed.classes.call(this)), {
                    "v-list--dense": this.dense,
                    "v-list--disabled": this.disabled,
                    "v-list--flat": this.flat,
                    "v-list--nav": this.nav,
                    "v-list--rounded": this.rounded,
                    "v-list--subheader": this.subheader,
                    "v-list--two-line": this.twoLine,
                    "v-list--three-line": this.threeLine
                  });
                }
              },
              methods: {
                register: function(d) {
                  this.groups.push(d);
                },
                unregister: function(d) {
                  var u = this.groups.findIndex(function(c) {
                    return c._uid === d._uid;
                  });
                  u > -1 && this.groups.splice(u, 1);
                },
                listClick: function(d) {
                  var u, c;
                  if (!this.expand)
                    try {
                      for (var h = l(this.groups), p = h.next(); !p.done; p = h.next()) {
                        var g = p.value;
                        g.toggle(d);
                      }
                    } catch (m) {
                      u = {
                        error: m
                      };
                    } finally {
                      try {
                        p && !p.done && (c = h.return) && c.call(h);
                      } finally {
                        if (u)
                          throw u.error;
                      }
                    }
                }
              },
              render: function(d) {
                var u = {
                  staticClass: "v-list",
                  class: this.classes,
                  style: this.styles,
                  attrs: o({
                    role: this.isInNav || this.isInMenu ? void 0 : "list"
                  }, this.attrs$)
                };
                return d(this.tag, this.setBackgroundColor(this.color, u), [this.$slots.default]);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListGroup.sass": (
          /*!**********************************************!*\
            !*** ./src/components/VList/VListGroup.sass ***!
            \**********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListGroup.ts": (
          /*!********************************************!*\
            !*** ./src/components/VList/VListGroup.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListGroup.sass */
              "./src/components/VList/VListGroup.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ./VListItem */
              "./src/components/VList/VListItem.ts"
            ), l = i(
              /*! ./VListItemIcon */
              "./src/components/VList/VListItemIcon.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), u = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), c = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), h = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), p = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), g = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), y = function() {
              return y = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var O in x)
                    Object.prototype.hasOwnProperty.call(x, O) && (C[O] = x[O]);
                }
                return C;
              }, y.apply(this, arguments);
            }, E = Object(m.default)(f.default, d.default, u.default, Object(h.inject)("list"), c.default);
            r.default = E.extend().extend({
              name: "v-list-group",
              directives: {
                ripple: p.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: ""
                },
                appendIcon: {
                  type: String,
                  default: "$expand"
                },
                color: {
                  type: String,
                  default: "primary"
                },
                disabled: Boolean,
                group: [String, RegExp],
                noAction: Boolean,
                prependIcon: String,
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                },
                subGroup: Boolean
              },
              computed: {
                classes: function() {
                  return {
                    "v-list-group--active": this.isActive,
                    "v-list-group--disabled": this.disabled,
                    "v-list-group--no-action": this.noAction,
                    "v-list-group--sub-group": this.subGroup
                  };
                }
              },
              watch: {
                isActive: function(x) {
                  !this.subGroup && x && this.list && this.list.listClick(this._uid);
                },
                $route: "onRouteChange"
              },
              created: function() {
                this.list && this.list.register(this), this.group && this.$route && this.value == null && (this.isActive = this.matchRoute(this.$route.path));
              },
              beforeDestroy: function() {
                this.list && this.list.unregister(this);
              },
              methods: {
                click: function(x) {
                  var b = this;
                  this.disabled || (this.isBooted = !0, this.$emit("click", x), this.$nextTick(function() {
                    return b.isActive = !b.isActive;
                  }));
                },
                genIcon: function(x) {
                  return this.$createElement(a.default, x);
                },
                genAppendIcon: function() {
                  var x = this.subGroup ? !1 : this.appendIcon;
                  return !x && !this.$slots.appendIcon ? null : this.$createElement(l.default, {
                    staticClass: "v-list-group__header__append-icon"
                  }, [this.$slots.appendIcon || this.genIcon(x)]);
                },
                genHeader: function() {
                  var x;
                  return this.$createElement(o.default, {
                    staticClass: "v-list-group__header",
                    attrs: {
                      "aria-expanded": String(this.isActive),
                      role: "button"
                    },
                    class: (x = {}, x[this.activeClass] = this.isActive, x),
                    props: {
                      inputValue: this.isActive
                    },
                    directives: [{
                      name: "ripple",
                      value: this.ripple
                    }],
                    on: y(y({}, this.listeners$), {
                      click: this.click
                    })
                  }, [this.genPrependIcon(), this.$slots.activator, this.genAppendIcon()]);
                },
                genItems: function() {
                  var x = this;
                  return this.showLazyContent(function() {
                    return [x.$createElement("div", {
                      staticClass: "v-list-group__items",
                      directives: [{
                        name: "show",
                        value: x.isActive
                      }]
                    }, Object(v.getSlot)(x))];
                  });
                },
                genPrependIcon: function() {
                  var x = this.subGroup && this.prependIcon == null ? "$subgroup" : this.prependIcon;
                  return !x && !this.$slots.prependIcon ? null : this.$createElement(l.default, {
                    staticClass: "v-list-group__header__prepend-icon"
                  }, [this.$slots.prependIcon || this.genIcon(x)]);
                },
                onRouteChange: function(x) {
                  if (this.group) {
                    var b = this.matchRoute(x.path);
                    b && this.isActive !== b && this.list && this.list.listClick(this._uid), this.isActive = b;
                  }
                },
                toggle: function(x) {
                  var b = this, P = this._uid === x;
                  P && (this.isBooted = !0), this.$nextTick(function() {
                    return b.isActive = P;
                  });
                },
                matchRoute: function(x) {
                  return x.match(this.group) !== null;
                }
              },
              render: function(x) {
                return x("div", this.setTextColor(this.isActive && this.color, {
                  staticClass: "v-list-group",
                  class: this.classes
                }), [this.genHeader(), x(g.VExpandTransition, this.genItems())]);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItem.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VList/VListItem.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListItem.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VList/VListItem.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListItem.sass */
              "./src/components/VList/VListItem.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), l = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), f = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), u = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), c = i(
              /*! ./../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, g.apply(this, arguments);
            }, m = Object(p.default)(a.default, o.default, f.default, Object(l.factory)("listItemGroup"), Object(d.factory)("inputValue"));
            r.default = m.extend().extend({
              name: "v-list-item",
              directives: {
                Ripple: u.default
              },
              inject: {
                isInGroup: {
                  default: !1
                },
                isInList: {
                  default: !1
                },
                isInMenu: {
                  default: !1
                },
                isInNav: {
                  default: !1
                }
              },
              inheritAttrs: !1,
              props: {
                activeClass: {
                  type: String,
                  default: function() {
                    return this.listItemGroup ? this.listItemGroup.activeClass : "";
                  }
                },
                dense: Boolean,
                inactive: Boolean,
                link: Boolean,
                selectable: {
                  type: Boolean
                },
                tag: {
                  type: String,
                  default: "div"
                },
                threeLine: Boolean,
                twoLine: Boolean,
                value: null
              },
              data: function() {
                return {
                  proxyClass: "v-list-item--active"
                };
              },
              computed: {
                classes: function() {
                  return g(g(g({
                    "v-list-item": !0
                  }, o.default.options.computed.classes.call(this)), {
                    "v-list-item--dense": this.dense,
                    "v-list-item--disabled": this.disabled,
                    "v-list-item--link": this.isClickable && !this.inactive,
                    "v-list-item--selectable": this.selectable,
                    "v-list-item--three-line": this.threeLine,
                    "v-list-item--two-line": this.twoLine
                  }), this.themeClasses);
                },
                isClickable: function() {
                  return !!(o.default.options.computed.isClickable.call(this) || this.listItemGroup);
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("avatar") && Object(h.removed)("avatar", this);
              },
              methods: {
                click: function(y) {
                  y.detail && this.$el.blur(), this.$emit("click", y), this.to || this.toggle();
                },
                genAttrs: function() {
                  var y = g({
                    "aria-disabled": this.disabled ? !0 : void 0,
                    tabindex: this.isClickable && !this.disabled ? 0 : -1
                  }, this.$attrs);
                  return this.$attrs.hasOwnProperty("role") || this.isInNav || (this.isInGroup ? (y.role = "option", y["aria-selected"] = String(this.isActive)) : this.isInMenu ? (y.role = this.isClickable ? "menuitem" : void 0, y.id = y.id || "list-item-" + this._uid) : this.isInList && (y.role = "listitem")), y;
                },
                toggle: function() {
                  this.to && this.inputValue === void 0 && (this.isActive = !this.isActive), this.$emit("change");
                }
              },
              render: function(y) {
                var E = this, C = this.generateRouteLink(), x = C.tag, b = C.data;
                b.attrs = g(g({}, b.attrs), this.genAttrs()), b[this.to ? "nativeOn" : "on"] = g(g({}, b[this.to ? "nativeOn" : "on"]), {
                  keydown: function(T) {
                    E.disabled || (T.keyCode === c.keyCodes.enter && E.click(T), E.$emit("keydown", T));
                  }
                }), this.inactive && (x = "div"), this.inactive && this.to && (b.on = b.nativeOn, delete b.nativeOn);
                var P = this.$scopedSlots.default ? this.$scopedSlots.default({
                  active: this.isActive,
                  toggle: this.toggle
                }) : this.$slots.default;
                return y(x, this.isActive ? this.setTextColor(this.color, b) : b, P);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemAction.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VList/VListItemAction.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "v-list-item-action",
              functional: !0,
              render: function(f, d) {
                var u = d.data, c = d.children, h = c === void 0 ? [] : c;
                u.staticClass = u.staticClass ? "v-list-item__action " + u.staticClass : "v-list-item__action";
                var p = h.filter(function(g) {
                  return g.isComment === !1 && g.text !== " ";
                });
                return p.length > 1 && (u.staticClass += " v-list-item__action--stack"), f("div", u, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemAvatar.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VList/VListItemAvatar.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VAvatar */
              "./src/components/VAvatar/index.ts"
            ), o = function() {
              return o = Object.assign || function(l) {
                for (var f, d = 1, u = arguments.length; d < u; d++) {
                  f = arguments[d];
                  for (var c in f)
                    Object.prototype.hasOwnProperty.call(f, c) && (l[c] = f[c]);
                }
                return l;
              }, o.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-list-item-avatar",
              props: {
                horizontal: Boolean,
                size: {
                  type: [Number, String],
                  default: 40
                }
              },
              computed: {
                classes: function() {
                  return o(o({
                    "v-list-item__avatar--horizontal": this.horizontal
                  }, a.default.options.computed.classes.call(this)), {
                    "v-avatar--tile": this.tile || this.horizontal
                  });
                }
              },
              render: function(f) {
                var d = a.default.options.render.call(this, f);
                return d.data = d.data || {}, d.data.staticClass += " v-list-item__avatar", d;
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemGroup.sass": (
          /*!**************************************************!*\
            !*** ./src/components/VList/VListItemGroup.sass ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VList/VListItemGroup.ts": (
          /*!************************************************!*\
            !*** ./src/components/VList/VListItemGroup.ts ***!
            \************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VListItemGroup.sass */
              "./src/components/VList/VListItemGroup.sass"
            );
            var a = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(a.BaseItemGroup, o.default).extend({
              name: "v-list-item-group",
              provide: function() {
                return {
                  isInGroup: !0,
                  listItemGroup: this
                };
              },
              computed: {
                classes: function() {
                  return f(f({}, a.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-list-item-group": !0
                  });
                }
              },
              methods: {
                genData: function() {
                  return this.setTextColor(this.color, f(f({}, a.BaseItemGroup.options.methods.genData.call(this)), {
                    attrs: {
                      role: "listbox"
                    }
                  }));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VList/VListItemIcon.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VList/VListItemIcon.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "v-list-item-icon",
              functional: !0,
              render: function(f, d) {
                var u = d.data, c = d.children;
                return u.staticClass = ("v-list-item__icon " + (u.staticClass || "")).trim(), f("div", u, c);
              }
            });
          }
        ),
        /***/
        "./src/components/VList/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VList/index.ts ***!
            \***************************************/
          /*! exports provided: VListItemActionText, VListItemContent, VListItemTitle, VListItemSubtitle, VList, VListGroup, VListItem, VListItemAction, VListItemAvatar, VListItemIcon, VListItemGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VListItemActionText", function() {
              return p;
            }), i.d(r, "VListItemContent", function() {
              return g;
            }), i.d(r, "VListItemTitle", function() {
              return m;
            }), i.d(r, "VListItemSubtitle", function() {
              return v;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VList */
              "./src/components/VList/VList.ts"
            );
            i.d(r, "VList", function() {
              return o.default;
            });
            var l = i(
              /*! ./VListGroup */
              "./src/components/VList/VListGroup.ts"
            );
            i.d(r, "VListGroup", function() {
              return l.default;
            });
            var f = i(
              /*! ./VListItem */
              "./src/components/VList/VListItem.ts"
            );
            i.d(r, "VListItem", function() {
              return f.default;
            });
            var d = i(
              /*! ./VListItemGroup */
              "./src/components/VList/VListItemGroup.ts"
            );
            i.d(r, "VListItemGroup", function() {
              return d.default;
            });
            var u = i(
              /*! ./VListItemAction */
              "./src/components/VList/VListItemAction.ts"
            );
            i.d(r, "VListItemAction", function() {
              return u.default;
            });
            var c = i(
              /*! ./VListItemAvatar */
              "./src/components/VList/VListItemAvatar.ts"
            );
            i.d(r, "VListItemAvatar", function() {
              return c.default;
            });
            var h = i(
              /*! ./VListItemIcon */
              "./src/components/VList/VListItemIcon.ts"
            );
            i.d(r, "VListItemIcon", function() {
              return h.default;
            });
            var p = Object(a.createSimpleFunctional)("v-list-item__action-text", "span"), g = Object(a.createSimpleFunctional)("v-list-item__content", "div"), m = Object(a.createSimpleFunctional)("v-list-item__title", "div"), v = Object(a.createSimpleFunctional)("v-list-item__subtitle", "div");
            r.default = {
              $_vuetify_subcomponents: {
                VList: o.default,
                VListGroup: l.default,
                VListItem: f.default,
                VListItemAction: u.default,
                VListItemActionText: p,
                VListItemAvatar: c.default,
                VListItemContent: g,
                VListItemGroup: d.default,
                VListItemIcon: h.default,
                VListItemSubtitle: v,
                VListItemTitle: m
              }
            };
          }
        ),
        /***/
        "./src/components/VMain/VMain.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VMain/VMain.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMain/VMain.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMain/VMain.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMain.sass */
              "./src/components/VMain/VMain.sass"
            );
            var a = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            );
            r.default = a.default.extend({
              name: "v-main",
              props: {
                tag: {
                  type: String,
                  default: "main"
                }
              },
              computed: {
                styles: function() {
                  var l = this.$vuetify.application, f = l.bar, d = l.top, u = l.right, c = l.footer, h = l.insetFooter, p = l.bottom, g = l.left;
                  return {
                    paddingTop: d + f + "px",
                    paddingRight: u + "px",
                    paddingBottom: c + h + p + "px",
                    paddingLeft: g + "px"
                  };
                }
              },
              render: function(l) {
                var f = {
                  staticClass: "v-main",
                  style: this.styles,
                  ref: "main"
                };
                return l(this.tag, f, [l("div", {
                  staticClass: "v-main__wrap"
                }, this.$slots.default)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMain/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMain/index.ts ***!
            \***************************************/
          /*! exports provided: VMain, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMain */
              "./src/components/VMain/VMain.ts"
            );
            i.d(r, "VMain", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VMenu/VMenu.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VMenu/VMenu.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMenu/VMenu.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMenu/VMenu.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMenu.sass */
              "./src/components/VMenu/VMenu.sass"
            );
            var a = i(
              /*! ../VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            ), o = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/menuable */
              "./src/mixins/menuable/index.ts"
            ), u = i(
              /*! ../../mixins/returnable */
              "./src/mixins/returnable/index.ts"
            ), c = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), E = i(
              /*! ../../services/goto */
              "./src/services/goto/index.ts"
            ), C = function() {
              return C = Object.assign || function(O) {
                for (var T, M = 1, L = arguments.length; M < L; M++) {
                  T = arguments[M];
                  for (var A in T)
                    Object.prototype.hasOwnProperty.call(T, A) && (O[A] = T[A]);
                }
                return O;
              }, C.apply(this, arguments);
            }, x = function(O, T) {
              var M = typeof Symbol == "function" && O[Symbol.iterator];
              if (!M)
                return O;
              var L = M.call(O), A, D = [], I;
              try {
                for (; (T === void 0 || T-- > 0) && !(A = L.next()).done; )
                  D.push(A.value);
              } catch (w) {
                I = {
                  error: w
                };
              } finally {
                try {
                  A && !A.done && (M = L.return) && M.call(L);
                } finally {
                  if (I)
                    throw I.error;
                }
              }
              return D;
            }, b = function(O, T, M) {
              if (M || arguments.length === 2)
                for (var L = 0, A = T.length, D; L < A; L++)
                  (D || !(L in T)) && (D || (D = Array.prototype.slice.call(T, 0, L)), D[L] = T[L]);
              return O.concat(D || Array.prototype.slice.call(T));
            }, P = Object(m.default)(f.default, l.default, u.default, c.default, h.default, d.default);
            r.default = P.extend({
              name: "v-menu",
              directives: {
                ClickOutside: p.default,
                Resize: g.default
              },
              provide: function() {
                return {
                  isInMenu: !0,
                  // Pass theme through to default slot
                  theme: this.theme
                };
              },
              props: {
                auto: Boolean,
                closeOnClick: {
                  type: Boolean,
                  default: !0
                },
                closeOnContentClick: {
                  type: Boolean,
                  default: !0
                },
                disabled: Boolean,
                disableKeys: Boolean,
                maxHeight: {
                  type: [Number, String],
                  default: "auto"
                },
                offsetX: Boolean,
                offsetY: Boolean,
                openOnHover: Boolean,
                origin: {
                  type: String,
                  default: "top left"
                },
                transition: {
                  type: [Boolean, String],
                  default: "v-menu-transition"
                },
                contentProps: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                }
              },
              data: function() {
                return {
                  calculatedTopAuto: 0,
                  defaultOffset: 8,
                  hasJustFocused: !1,
                  listIndex: -1,
                  resizeTimeout: 0,
                  selectedIndex: null,
                  tiles: []
                };
              },
              computed: {
                activeTile: function() {
                  return this.tiles[this.listIndex];
                },
                calculatedLeft: function() {
                  var T = Math.max(this.dimensions.content.width, parseFloat(this.calculatedMinWidth));
                  return this.auto ? Object(y.convertToUnit)(this.calcXOverflow(this.calcLeftAuto(), T)) || "0" : this.calcLeft(T) || "0";
                },
                calculatedMaxHeight: function() {
                  var T = this.auto ? "200px" : Object(y.convertToUnit)(this.maxHeight);
                  return T || "0";
                },
                calculatedMaxWidth: function() {
                  return Object(y.convertToUnit)(this.maxWidth) || "0";
                },
                calculatedMinWidth: function() {
                  if (this.minWidth)
                    return Object(y.convertToUnit)(this.minWidth) || "0";
                  var T = Math.min(this.dimensions.activator.width + Number(this.nudgeWidth) + (this.auto ? 16 : 0), Math.max(this.pageWidth - 24, 0)), M = isNaN(parseInt(this.calculatedMaxWidth)) ? T : parseInt(this.calculatedMaxWidth);
                  return Object(y.convertToUnit)(Math.min(M, T)) || "0";
                },
                calculatedTop: function() {
                  var T = this.auto ? Object(y.convertToUnit)(this.calcYOverflow(this.calculatedTopAuto)) : this.calcTop();
                  return T || "0";
                },
                hasClickableTiles: function() {
                  return !!this.tiles.find(function(T) {
                    return T.tabIndex > -1;
                  });
                },
                styles: function() {
                  return {
                    maxHeight: this.calculatedMaxHeight,
                    minWidth: this.calculatedMinWidth,
                    maxWidth: this.calculatedMaxWidth,
                    top: this.calculatedTop,
                    left: this.calculatedLeft,
                    transformOrigin: this.origin,
                    zIndex: this.zIndex || this.activeZIndex
                  };
                }
              },
              watch: {
                isActive: function(T) {
                  T || (this.listIndex = -1);
                },
                isContentActive: function(T) {
                  this.hasJustFocused = T;
                },
                listIndex: function(T, M) {
                  if (T in this.tiles) {
                    var L = this.tiles[T];
                    L.classList.add("v-list-item--highlighted");
                    var A = this.$refs.content.scrollTop, D = this.$refs.content.clientHeight;
                    A > L.offsetTop - 8 ? Object(E.default)(L.offsetTop - L.clientHeight, {
                      appOffset: !1,
                      duration: 300,
                      container: this.$refs.content
                    }) : A + D < L.offsetTop + L.clientHeight + 8 && Object(E.default)(L.offsetTop - D + L.clientHeight * 2, {
                      appOffset: !1,
                      duration: 300,
                      container: this.$refs.content
                    });
                  }
                  M in this.tiles && this.tiles[M].classList.remove("v-list-item--highlighted");
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("full-width") && Object(v.removed)("full-width", this);
              },
              mounted: function() {
                this.isActive && this.callActivate();
              },
              methods: {
                activate: function() {
                  var T = this;
                  this.updateDimensions(), requestAnimationFrame(function() {
                    T.startTransition().then(function() {
                      T.$refs.content && (T.calculatedTopAuto = T.calcTopAuto(), T.auto && (T.$refs.content.scrollTop = T.calcScrollPosition()));
                    });
                  });
                },
                calcScrollPosition: function() {
                  var T = this.$refs.content, M = T.querySelector(".v-list-item--active"), L = T.scrollHeight - T.offsetHeight;
                  return M ? Math.min(L, Math.max(0, M.offsetTop - T.offsetHeight / 2 + M.offsetHeight / 2)) : T.scrollTop;
                },
                calcLeftAuto: function() {
                  return parseInt(this.dimensions.activator.left - this.defaultOffset * 2);
                },
                calcTopAuto: function() {
                  var T = this.$refs.content, M = T.querySelector(".v-list-item--active");
                  if (M || (this.selectedIndex = null), this.offsetY || !M)
                    return this.computedTop;
                  this.selectedIndex = Array.from(this.tiles).indexOf(M);
                  var L = M.offsetTop - this.calcScrollPosition(), A = T.querySelector(".v-list-item").offsetTop;
                  return this.computedTop - L - A - 1;
                },
                changeListIndex: function(T) {
                  if (this.getTiles(), !(!this.isActive || !this.hasClickableTiles)) {
                    if (T.keyCode === y.keyCodes.tab) {
                      this.isActive = !1;
                      return;
                    } else if (T.keyCode === y.keyCodes.down)
                      this.nextTile();
                    else if (T.keyCode === y.keyCodes.up)
                      this.prevTile();
                    else if (T.keyCode === y.keyCodes.end)
                      this.lastTile();
                    else if (T.keyCode === y.keyCodes.home)
                      this.firstTile();
                    else if (T.keyCode === y.keyCodes.enter && this.listIndex !== -1)
                      this.tiles[this.listIndex].click();
                    else
                      return;
                    T.preventDefault();
                  }
                },
                closeConditional: function(T) {
                  var M = T.target;
                  return this.isActive && !this._isDestroyed && this.closeOnClick && !this.$refs.content.contains(M);
                },
                genActivatorAttributes: function() {
                  var T = o.default.options.methods.genActivatorAttributes.call(this);
                  return this.activeTile && this.activeTile.id ? C(C({}, T), {
                    "aria-activedescendant": this.activeTile.id
                  }) : T;
                },
                genActivatorListeners: function() {
                  var T = d.default.options.methods.genActivatorListeners.call(this);
                  return this.disableKeys || (T.keydown = this.onKeyDown), T;
                },
                genTransition: function() {
                  var T = this.genContent();
                  return this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, [T]) : T;
                },
                genDirectives: function() {
                  var T = this, M = [{
                    name: "show",
                    value: this.isContentActive
                  }];
                  return !this.openOnHover && this.closeOnClick && M.push({
                    name: "click-outside",
                    value: {
                      handler: function() {
                        T.isActive = !1;
                      },
                      closeConditional: this.closeConditional,
                      include: function() {
                        return b([T.$el], x(T.getOpenDependentElements()), !1);
                      }
                    }
                  }), M;
                },
                genContent: function() {
                  var T, M = this, L = {
                    attrs: C(C(C({}, this.getScopeIdAttrs()), this.contentProps), {
                      role: "role" in this.$attrs ? this.$attrs.role : "menu"
                    }),
                    staticClass: "v-menu__content",
                    class: C(C(C({}, this.rootThemeClasses), this.roundedClasses), (T = {
                      "v-menu__content--auto": this.auto,
                      "v-menu__content--fixed": this.activatorFixed,
                      menuable__content__active: this.isActive
                    }, T[this.contentClass.trim()] = !0, T)),
                    style: this.styles,
                    directives: this.genDirectives(),
                    ref: "content",
                    on: {
                      click: function(D) {
                        var I = D.target;
                        I.getAttribute("disabled") || M.closeOnContentClick && (M.isActive = !1);
                      },
                      keydown: this.onKeyDown
                    }
                  };
                  return this.$listeners.scroll && (L.on = L.on || {}, L.on.scroll = this.$listeners.scroll), !this.disabled && this.openOnHover && (L.on = L.on || {}, L.on.mouseenter = this.mouseEnterHandler), this.openOnHover && (L.on = L.on || {}, L.on.mouseleave = this.mouseLeaveHandler), this.$createElement("div", L, this.getContentSlot());
                },
                getTiles: function() {
                  this.$refs.content && (this.tiles = Array.from(this.$refs.content.querySelectorAll(".v-list-item, .v-divider, .v-subheader")));
                },
                mouseEnterHandler: function() {
                  var T = this;
                  this.runDelay("open", function() {
                    T.hasJustFocused || (T.hasJustFocused = !0);
                  });
                },
                mouseLeaveHandler: function(T) {
                  var M = this;
                  this.runDelay("close", function() {
                    var L;
                    !((L = M.$refs.content) === null || L === void 0) && L.contains(T.relatedTarget) || requestAnimationFrame(function() {
                      M.isActive = !1, M.callDeactivate();
                    });
                  });
                },
                nextTile: function() {
                  var T = this.tiles[this.listIndex + 1];
                  if (!T) {
                    if (!this.tiles.length)
                      return;
                    this.listIndex = -1, this.nextTile();
                    return;
                  }
                  this.listIndex++, T.tabIndex === -1 && this.nextTile();
                },
                prevTile: function() {
                  var T = this.tiles[this.listIndex - 1];
                  if (!T) {
                    if (!this.tiles.length)
                      return;
                    this.listIndex = this.tiles.length, this.prevTile();
                    return;
                  }
                  this.listIndex--, T.tabIndex === -1 && this.prevTile();
                },
                lastTile: function() {
                  var T = this.tiles[this.tiles.length - 1];
                  T && (this.listIndex = this.tiles.length - 1, T.tabIndex === -1 && this.prevTile());
                },
                firstTile: function() {
                  var T = this.tiles[0];
                  T && (this.listIndex = 0, T.tabIndex === -1 && this.nextTile());
                },
                onKeyDown: function(T) {
                  var M = this;
                  if (!this.disableKeys) {
                    if (T.keyCode === y.keyCodes.esc) {
                      setTimeout(function() {
                        M.isActive = !1;
                      });
                      var L = this.getActivator();
                      this.$nextTick(function() {
                        return L && L.focus();
                      });
                    } else
                      !this.isActive && [y.keyCodes.up, y.keyCodes.down].includes(T.keyCode) && (this.isActive = !0);
                    this.$nextTick(function() {
                      return M.changeListIndex(T);
                    });
                  }
                },
                onResize: function() {
                  this.isActive && (this.$refs.content.offsetWidth, this.updateDimensions(), clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.updateDimensions, 100));
                }
              },
              render: function(T) {
                var M = this, L = {
                  staticClass: "v-menu",
                  class: {
                    "v-menu--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  },
                  directives: [{
                    arg: "500",
                    name: "resize",
                    value: this.onResize
                  }]
                };
                return T("div", L, [!this.activator && this.genActivator(), this.showLazyContent(function() {
                  return [M.$createElement(a.VThemeProvider, {
                    props: {
                      root: !0,
                      light: M.light,
                      dark: M.dark
                    }
                  }, [M.genTransition()])];
                })]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMenu/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VMenu/index.ts ***!
            \***************************************/
          /*! exports provided: VMenu, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMenu */
              "./src/components/VMenu/VMenu.ts"
            );
            i.d(r, "VMenu", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VMessages/VMessages.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VMessages/VMessages.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VMessages/VMessages.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VMessages/VMessages.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VMessages.sass */
              "./src/components/VMessages/VMessages.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(l.default)(a.default, o.default).extend({
              name: "v-messages",
              props: {
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              methods: {
                genChildren: function() {
                  return this.$createElement("transition-group", {
                    staticClass: "v-messages__wrapper",
                    attrs: {
                      name: "message-transition",
                      tag: "div"
                    }
                  }, this.value.map(this.genMessage));
                },
                genMessage: function(u, c) {
                  return this.$createElement("div", {
                    staticClass: "v-messages__message",
                    key: c
                  }, Object(f.getSlot)(this, "default", {
                    message: u,
                    key: c
                  }) || [u]);
                }
              },
              render: function(u) {
                return u("div", this.setTextColor(this.color, {
                  staticClass: "v-messages",
                  class: this.themeClasses
                }), [this.genChildren()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VMessages/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VMessages/index.ts ***!
            \*******************************************/
          /*! exports provided: VMessages, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VMessages */
              "./src/components/VMessages/VMessages.ts"
            );
            i.d(r, "VMessages", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/VNavigationDrawer.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VNavigationDrawer/VNavigationDrawer.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/VNavigationDrawer.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VNavigationDrawer/VNavigationDrawer.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VNavigationDrawer.sass */
              "./src/components/VNavigationDrawer/VNavigationDrawer.sass"
            );
            var a = i(
              /*! ../VImg/VImg */
              "./src/components/VImg/VImg.ts"
            ), o = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), u = i(
              /*! ../../mixins/overlayable */
              "./src/mixins/overlayable/index.ts"
            ), c = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), m = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), v = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), y = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), E = function() {
              return E = Object.assign || function(x) {
                for (var b, P = 1, O = arguments.length; P < O; P++) {
                  b = arguments[P];
                  for (var T in b)
                    Object.prototype.hasOwnProperty.call(b, T) && (x[T] = b[T]);
                }
                return x;
              }, E.apply(this, arguments);
            }, C = Object(y.default)(Object(o.default)("left", ["isActive", "isMobile", "miniVariant", "expandOnHover", "permanent", "right", "temporary", "width"]), l.default, f.default, d.default, u.default, c.default, h.default);
            r.default = C.extend({
              name: "v-navigation-drawer",
              directives: {
                ClickOutside: p.default,
                Resize: g.default,
                Touch: m.default
              },
              provide: function() {
                return {
                  isInNav: this.tag === "nav"
                };
              },
              props: {
                bottom: Boolean,
                clipped: Boolean,
                disableResizeWatcher: Boolean,
                disableRouteWatcher: Boolean,
                expandOnHover: Boolean,
                floating: Boolean,
                height: {
                  type: [Number, String],
                  default: function() {
                    return this.app ? "100vh" : "100%";
                  }
                },
                miniVariant: Boolean,
                miniVariantWidth: {
                  type: [Number, String],
                  default: 56
                },
                permanent: Boolean,
                right: Boolean,
                src: {
                  type: [String, Object],
                  default: ""
                },
                stateless: Boolean,
                tag: {
                  type: String,
                  default: function() {
                    return this.app ? "nav" : "aside";
                  }
                },
                temporary: Boolean,
                touchless: Boolean,
                width: {
                  type: [Number, String],
                  default: 256
                },
                value: null
              },
              data: function() {
                return {
                  isMouseover: !1,
                  touchArea: {
                    left: 0,
                    right: 0
                  },
                  stackMinZIndex: 6
                };
              },
              computed: {
                /**
                 * Used for setting an app value from a dynamic
                 * property. Called from applicationable.js
                 */
                applicationProperty: function() {
                  return this.right ? "right" : "left";
                },
                classes: function() {
                  return E({
                    "v-navigation-drawer": !0,
                    "v-navigation-drawer--absolute": this.absolute,
                    "v-navigation-drawer--bottom": this.bottom,
                    "v-navigation-drawer--clipped": this.clipped,
                    "v-navigation-drawer--close": !this.isActive,
                    "v-navigation-drawer--fixed": !this.absolute && (this.app || this.fixed),
                    "v-navigation-drawer--floating": this.floating,
                    "v-navigation-drawer--is-mobile": this.isMobile,
                    "v-navigation-drawer--is-mouseover": this.isMouseover,
                    "v-navigation-drawer--mini-variant": this.isMiniVariant,
                    "v-navigation-drawer--custom-mini-variant": Number(this.miniVariantWidth) !== 56,
                    "v-navigation-drawer--open": this.isActive,
                    "v-navigation-drawer--open-on-hover": this.expandOnHover,
                    "v-navigation-drawer--right": this.right,
                    "v-navigation-drawer--temporary": this.temporary
                  }, this.themeClasses);
                },
                computedMaxHeight: function() {
                  if (!this.hasApp)
                    return null;
                  var b = this.$vuetify.application.bottom + this.$vuetify.application.footer + this.$vuetify.application.bar;
                  return this.clipped ? b + this.$vuetify.application.top : b;
                },
                computedTop: function() {
                  if (!this.hasApp)
                    return 0;
                  var b = this.$vuetify.application.bar;
                  return b += this.clipped ? this.$vuetify.application.top : 0, b;
                },
                computedTransform: function() {
                  return this.isActive ? 0 : this.isBottom || this.right ? 100 : -100;
                },
                computedWidth: function() {
                  return this.isMiniVariant ? this.miniVariantWidth : this.width;
                },
                hasApp: function() {
                  return this.app && !this.isMobile && !this.temporary;
                },
                isBottom: function() {
                  return this.bottom && this.isMobile;
                },
                isMiniVariant: function() {
                  return !this.expandOnHover && this.miniVariant || this.expandOnHover && !this.isMouseover;
                },
                isMobile: function() {
                  return !this.stateless && !this.permanent && d.default.options.computed.isMobile.call(this);
                },
                reactsToClick: function() {
                  return !this.stateless && !this.permanent && (this.isMobile || this.temporary);
                },
                reactsToMobile: function() {
                  return this.app && !this.disableResizeWatcher && !this.permanent && !this.stateless && !this.temporary;
                },
                reactsToResize: function() {
                  return !this.disableResizeWatcher && !this.stateless;
                },
                reactsToRoute: function() {
                  return !this.disableRouteWatcher && !this.stateless && (this.temporary || this.isMobile);
                },
                showOverlay: function() {
                  return !this.hideOverlay && this.isActive && (this.isMobile || this.temporary);
                },
                styles: function() {
                  var b = this.isBottom ? "translateY" : "translateX";
                  return {
                    height: Object(v.convertToUnit)(this.height),
                    top: this.isBottom ? "auto" : Object(v.convertToUnit)(this.computedTop),
                    maxHeight: this.computedMaxHeight != null ? "calc(100% - " + Object(v.convertToUnit)(this.computedMaxHeight) + ")" : void 0,
                    transform: b + "(" + Object(v.convertToUnit)(this.computedTransform, "%") + ")",
                    width: Object(v.convertToUnit)(this.computedWidth)
                  };
                }
              },
              watch: {
                $route: "onRouteChange",
                isActive: function(b) {
                  this.$emit("input", b);
                },
                /**
                 * When mobile changes, adjust the active state
                 * only when there has been a previous value
                 */
                isMobile: function(b, P) {
                  !b && this.isActive && !this.temporary && this.removeOverlay(), !(P == null || !this.reactsToResize || !this.reactsToMobile) && (this.isActive = !b);
                },
                permanent: function(b) {
                  b && (this.isActive = !0);
                },
                showOverlay: function(b) {
                  b ? this.genOverlay() : this.removeOverlay();
                },
                value: function(b) {
                  if (!this.permanent) {
                    if (b == null) {
                      this.init();
                      return;
                    }
                    b !== this.isActive && (this.isActive = b);
                  }
                },
                expandOnHover: "updateMiniVariant",
                isMouseover: function(b) {
                  this.updateMiniVariant(!b);
                }
              },
              beforeMount: function() {
                this.init();
              },
              methods: {
                calculateTouchArea: function() {
                  var b = this.$el.parentNode;
                  if (b) {
                    var P = b.getBoundingClientRect();
                    this.touchArea = {
                      left: P.left + 50,
                      right: P.right - 50
                    };
                  }
                },
                closeConditional: function() {
                  return this.isActive && !this._isDestroyed && this.reactsToClick;
                },
                genAppend: function() {
                  return this.genPosition("append");
                },
                genBackground: function() {
                  var b = {
                    height: "100%",
                    width: "100%",
                    src: this.src
                  }, P = this.$scopedSlots.img ? this.$scopedSlots.img(b) : this.$createElement(a.default, {
                    props: b
                  });
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__image"
                  }, [P]);
                },
                genDirectives: function() {
                  var b = this, P = [{
                    name: "click-outside",
                    value: {
                      handler: function() {
                        b.isActive = !1;
                      },
                      closeConditional: this.closeConditional,
                      include: this.getOpenDependentElements
                    }
                  }];
                  return !this.touchless && !this.stateless && P.push({
                    name: "touch",
                    value: {
                      parent: !0,
                      left: this.swipeLeft,
                      right: this.swipeRight
                    }
                  }), P;
                },
                genListeners: function() {
                  var b = this, P = {
                    mouseenter: function() {
                      return b.isMouseover = !0;
                    },
                    mouseleave: function() {
                      return b.isMouseover = !1;
                    },
                    transitionend: function(T) {
                      if (T.target === T.currentTarget) {
                        b.$emit("transitionend", T);
                        var M = document.createEvent("UIEvents");
                        M.initUIEvent("resize", !0, !1, window, 0), window.dispatchEvent(M);
                      }
                    }
                  };
                  return this.miniVariant && (P.click = function() {
                    return b.$emit("update:mini-variant", !1);
                  }), P;
                },
                genPosition: function(b) {
                  var P = Object(v.getSlot)(this, b);
                  return P && this.$createElement("div", {
                    staticClass: "v-navigation-drawer__" + b
                  }, P);
                },
                genPrepend: function() {
                  return this.genPosition("prepend");
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__content"
                  }, this.$slots.default);
                },
                genBorder: function() {
                  return this.$createElement("div", {
                    staticClass: "v-navigation-drawer__border"
                  });
                },
                init: function() {
                  this.permanent ? this.isActive = !0 : this.stateless || this.value != null ? this.isActive = this.value : this.temporary || (this.isActive = !this.isMobile);
                },
                onRouteChange: function() {
                  this.reactsToRoute && this.closeConditional() && (this.isActive = !1);
                },
                swipeLeft: function(b) {
                  this.isActive && this.right || (this.calculateTouchArea(), !(Math.abs(b.touchendX - b.touchstartX) < 100) && (this.right && b.touchstartX >= this.touchArea.right ? this.isActive = !0 : !this.right && this.isActive && (this.isActive = !1)));
                },
                swipeRight: function(b) {
                  this.isActive && !this.right || (this.calculateTouchArea(), !(Math.abs(b.touchendX - b.touchstartX) < 100) && (!this.right && b.touchstartX <= this.touchArea.left ? this.isActive = !0 : this.right && this.isActive && (this.isActive = !1)));
                },
                /**
                 * Update the application layout
                 */
                updateApplication: function() {
                  if (!this.isActive || this.isMobile || this.temporary || !this.$el)
                    return 0;
                  var b = Number(this.miniVariant ? this.miniVariantWidth : this.width);
                  return isNaN(b) ? this.$el.clientWidth : b;
                },
                updateMiniVariant: function(b) {
                  this.expandOnHover && this.miniVariant !== b && this.$emit("update:mini-variant", b);
                }
              },
              render: function(b) {
                var P = [this.genPrepend(), this.genContent(), this.genAppend(), this.genBorder()];
                return (this.src || Object(v.getSlot)(this, "img")) && P.unshift(this.genBackground()), b(this.tag, this.setBackgroundColor(this.color, {
                  class: this.classes,
                  style: this.styles,
                  directives: this.genDirectives(),
                  on: this.genListeners()
                }), P);
              }
            });
          }
        ),
        /***/
        "./src/components/VNavigationDrawer/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VNavigationDrawer/index.ts ***!
            \***************************************************/
          /*! exports provided: VNavigationDrawer, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VNavigationDrawer */
              "./src/components/VNavigationDrawer/VNavigationDrawer.ts"
            );
            i.d(r, "VNavigationDrawer", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOtpInput/VOtpInput.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VOtpInput/VOtpInput.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOtpInput/VOtpInput.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VOtpInput/VOtpInput.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../VTextField/VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            ), i(
              /*! ./VOtpInput.sass */
              "./src/components/VOtpInput/VOtpInput.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), l = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = function() {
              return c = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, c.apply(this, arguments);
            }, h = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, p = function(m, v, y) {
              if (y || arguments.length === 2)
                for (var E = 0, C = v.length, x; E < C; E++)
                  (x || !(E in v)) && (x || (x = Array.prototype.slice.call(v, 0, E)), x[E] = v[E]);
              return m.concat(x || Array.prototype.slice.call(v));
            }, g = Object(u.default)(a.default);
            r.default = g.extend().extend({
              name: "v-otp-input",
              directives: {
                ripple: l.default
              },
              inheritAttrs: !1,
              props: {
                length: {
                  type: [Number, String],
                  default: 6
                },
                type: {
                  type: String,
                  default: "text"
                },
                plain: Boolean
              },
              data: function() {
                return {
                  initialValue: null,
                  isBooted: !1,
                  otp: []
                };
              },
              computed: {
                outlined: function() {
                  return !this.plain;
                },
                classes: function() {
                  return c(c(c({}, a.default.options.computed.classes.call(this)), o.default.options.computed.classes.call(this)), {
                    "v-otp-input--plain": this.plain
                  });
                }
              },
              watch: {
                isFocused: "updateValue",
                value: function(v) {
                  this.lazyValue = v, this.otp = (v == null ? void 0 : v.split("")) || [];
                }
              },
              created: function() {
                var v;
                this.$attrs.hasOwnProperty("browser-autocomplete") && Object(d.breaking)("browser-autocomplete", "autocomplete", this), this.otp = ((v = this.internalValue) === null || v === void 0 ? void 0 : v.split("")) || [];
              },
              mounted: function() {
                var v = this;
                requestAnimationFrame(function() {
                  return v.isBooted = !0;
                });
              },
              methods: {
                /** @public */
                focus: function(v, y) {
                  this.onFocus(v, y || 0);
                },
                genInputSlot: function(v) {
                  var y = this;
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
                    staticClass: "v-input__slot",
                    style: {
                      height: Object(f.convertToUnit)(this.height)
                    },
                    on: {
                      click: function() {
                        return y.onClick(v);
                      },
                      mousedown: function(C) {
                        return y.onMouseDown(C, v);
                      },
                      mouseup: function(C) {
                        return y.onMouseUp(C, v);
                      }
                    }
                  }), [this.genDefaultSlot(v)]);
                },
                genControl: function(v) {
                  return this.$createElement("div", {
                    staticClass: "v-input__control"
                  }, [this.genInputSlot(v)]);
                },
                genDefaultSlot: function(v) {
                  return [this.genFieldset(), this.genTextFieldSlot(v)];
                },
                genContent: function() {
                  var v = this;
                  return Array.from({
                    length: +this.length
                  }, function(y, E) {
                    return v.$createElement("div", v.setTextColor(v.validationState, {
                      staticClass: "v-input",
                      class: v.classes
                    }), [v.genControl(E)]);
                  });
                },
                genFieldset: function() {
                  return this.$createElement("fieldset", {
                    attrs: {
                      "aria-hidden": !0
                    }
                  }, [this.genLegend()]);
                },
                genLegend: function() {
                  var v = this.$createElement("span", {
                    domProps: {
                      innerHTML: "&#8203;"
                    }
                  });
                  return this.$createElement("legend", {
                    style: {
                      width: "0px"
                    }
                  }, [v]);
                },
                genInput: function(v) {
                  var y = this, E = Object.assign({}, this.listeners$);
                  return delete E.change, this.$createElement("input", {
                    style: {},
                    domProps: {
                      value: this.otp[v],
                      min: this.type === "number" ? 0 : null
                    },
                    attrs: c(c({}, this.attrs$), {
                      autocomplete: "one-time-code",
                      disabled: this.isDisabled,
                      readonly: this.isReadonly,
                      type: this.type,
                      id: this.computedId + "--" + v,
                      class: "otp-field-box--" + v
                    }),
                    on: Object.assign(E, {
                      blur: this.onBlur,
                      input: function(x) {
                        return y.onInput(x, v);
                      },
                      focus: function(x) {
                        return y.onFocus(x, v);
                      },
                      keydown: this.onKeyDown,
                      keyup: function(x) {
                        return y.onKeyUp(x, v);
                      }
                    }),
                    ref: "input",
                    refInFor: !0
                  });
                },
                genTextFieldSlot: function(v) {
                  return this.$createElement("div", {
                    staticClass: "v-text-field__slot"
                  }, [this.genInput(v)]);
                },
                onBlur: function(v) {
                  var y = this;
                  this.isFocused = !1, v && this.$nextTick(function() {
                    return y.$emit("blur", v);
                  });
                },
                onClick: function(v) {
                  this.isFocused || this.isDisabled || !this.$refs.input[v] || this.onFocus(void 0, v);
                },
                onFocus: function(v, y) {
                  v == null || v.preventDefault(), v == null || v.stopPropagation();
                  var E = this.$refs.input, C = this.$refs.input && E[y || 0];
                  if (C) {
                    if (document.activeElement !== C)
                      return C.focus(), C.select();
                    this.isFocused || (this.isFocused = !0, C.select(), v && this.$emit("focus", v));
                  }
                },
                onInput: function(v, y) {
                  for (var E = +this.length - 1, C = v.target, x = C.value, b = (x == null ? void 0 : x.split("")) || [], P = p([], h(this.otp), !1), O = 0; O < b.length; O++) {
                    var T = y + O;
                    if (T > E)
                      break;
                    P[T] = b[O].toString();
                  }
                  b.length || P.splice(y, 1), this.otp = P, this.internalValue = this.otp.join(""), y + b.length >= +this.length ? (this.onCompleted(), this.clearFocus(y)) : b.length && this.changeFocus(y + b.length);
                },
                clearFocus: function(v) {
                  var y = this.$refs.input[v];
                  y.blur();
                },
                onKeyDown: function(v) {
                  v.keyCode === f.keyCodes.enter && this.$emit("change", this.internalValue), this.$emit("keydown", v);
                },
                onMouseDown: function(v, y) {
                  v.target !== this.$refs.input[y] && (v.preventDefault(), v.stopPropagation()), a.default.options.methods.onMouseDown.call(this, v);
                },
                onMouseUp: function(v, y) {
                  this.hasMouseDown && this.focus(v, y), a.default.options.methods.onMouseUp.call(this, v);
                },
                changeFocus: function(v) {
                  this.onFocus(void 0, v || 0);
                },
                updateValue: function(v) {
                  this.hasColor = v, v ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                },
                onKeyUp: function(v, y) {
                  v.preventDefault();
                  var E = v.key;
                  if (!["Tab", "Shift", "Meta", "Control", "Alt"].includes(E) && !["Delete"].includes(E)) {
                    if (E === "ArrowLeft" || E === "Backspace" && !this.otp[y])
                      return y > 0 && this.changeFocus(y - 1);
                    if (E === "ArrowRight")
                      return y + 1 < +this.length && this.changeFocus(y + 1);
                  }
                },
                onCompleted: function() {
                  var v = this.otp.join("");
                  v.length === +this.length && this.$emit("finish", v);
                }
              },
              render: function(v) {
                return v("div", {
                  staticClass: "v-otp-input",
                  class: this.themeClasses
                }, this.genContent());
              }
            });
          }
        ),
        /***/
        "./src/components/VOtpInput/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VOtpInput/index.ts ***!
            \*******************************************/
          /*! exports provided: VOtpInput, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOtpInput */
              "./src/components/VOtpInput/VOtpInput.ts"
            );
            i.d(r, "VOtpInput", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOverflowBtn/VOverflowBtn.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VOverflowBtn/VOverflowBtn.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOverflowBtn/VOverflowBtn.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VOverflowBtn/VOverflowBtn.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VOverflowBtn.sass */
              "./src/components/VOverflowBtn/VOverflowBtn.sass"
            );
            var a = i(
              /*! ../VSelect/VSelect */
              "./src/components/VSelect/VSelect.ts"
            ), o = i(
              /*! ../VAutocomplete */
              "./src/components/VAutocomplete/index.ts"
            ), l = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), f = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = o.default.extend({
              name: "v-overflow-btn",
              props: {
                editable: Boolean,
                segmented: Boolean
              },
              computed: {
                classes: function() {
                  return u(u({}, o.default.options.computed.classes.call(this)), {
                    "v-overflow-btn": !0,
                    "v-overflow-btn--segmented": this.segmented,
                    "v-overflow-btn--editable": this.editable
                  });
                },
                isAnyValueAllowed: function() {
                  return this.editable || o.default.options.computed.isAnyValueAllowed.call(this);
                },
                isSingle: function() {
                  return !0;
                },
                computedItems: function() {
                  return this.segmented ? this.allItems : this.filteredItems;
                },
                labelValue: function() {
                  return this.isFocused && !this.persistentPlaceholder || this.isLabelActive;
                }
              },
              methods: {
                genSelections: function() {
                  return this.editable ? o.default.options.methods.genSelections.call(this) : a.default.options.methods.genSelections.call(this);
                },
                genCommaSelection: function(h, p, g) {
                  return this.segmented ? this.genSegmentedBtn(h) : a.default.options.methods.genCommaSelection.call(this, h, p, g);
                },
                genInput: function() {
                  var h = l.default.options.methods.genInput.call(this);
                  return h.data = h.data || {}, h.data.domProps.value = this.editable ? this.internalSearch : "", h.data.attrs.readonly = !this.isAnyValueAllowed, h;
                },
                genLabel: function() {
                  if (this.editable && this.isFocused)
                    return null;
                  var h = l.default.options.methods.genLabel.call(this);
                  return h && (h.data = h.data || {}, h.data.style = {}, h);
                },
                genSegmentedBtn: function(h) {
                  var p = this, g = this.getValue(h), m = this.computedItems.find(function(v) {
                    return p.getValue(v) === g;
                  }) || h;
                  return !m.text || !m.callback ? (Object(d.consoleWarn)('When using "segmented" prop without a selection slot, items must contain both a text and callback property', this), null) : this.$createElement(f.default, {
                    props: {
                      text: !0
                    },
                    on: {
                      click: function(y) {
                        y.stopPropagation(), m.callback(y);
                      }
                    }
                  }, [m.text]);
                },
                updateValue: function(h) {
                  h ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VOverflowBtn/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VOverflowBtn/index.ts ***!
            \**********************************************/
          /*! exports provided: VOverflowBtn, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOverflowBtn */
              "./src/components/VOverflowBtn/VOverflowBtn.ts"
            );
            i.d(r, "VOverflowBtn", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VOverlay/VOverlay.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VOverlay/VOverlay.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VOverlay/VOverlay.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VOverlay/VOverlay.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VOverlay.sass */
              "./src/components/VOverlay/VOverlay.sass"
            );
            var a = i(
              /*! ./../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ./../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "v-overlay",
              props: {
                absolute: Boolean,
                color: {
                  type: String,
                  default: "#212121"
                },
                dark: {
                  type: Boolean,
                  default: !0
                },
                opacity: {
                  type: [Number, String],
                  default: 0.46
                },
                value: {
                  default: !0
                },
                zIndex: {
                  type: [Number, String],
                  default: 5
                }
              },
              computed: {
                __scrim: function() {
                  var c = this.setBackgroundColor(this.color, {
                    staticClass: "v-overlay__scrim",
                    style: {
                      opacity: this.computedOpacity
                    }
                  });
                  return this.$createElement("div", c);
                },
                classes: function() {
                  return d({
                    "v-overlay--absolute": this.absolute,
                    "v-overlay--active": this.isActive
                  }, this.themeClasses);
                },
                computedOpacity: function() {
                  return Number(this.isActive ? this.opacity : 0);
                },
                styles: function() {
                  return {
                    zIndex: this.zIndex
                  };
                }
              },
              methods: {
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-overlay__content"
                  }, this.$slots.default);
                }
              },
              render: function(c) {
                var h = [this.__scrim];
                return this.isActive && h.push(this.genContent()), c("div", {
                  staticClass: "v-overlay",
                  on: this.$listeners,
                  class: this.classes,
                  style: this.styles
                }, h);
              }
            });
          }
        ),
        /***/
        "./src/components/VOverlay/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VOverlay/index.ts ***!
            \******************************************/
          /*! exports provided: VOverlay, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VOverlay */
              "./src/components/VOverlay/VOverlay.ts"
            );
            i.d(r, "VOverlay", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VPagination/VPagination.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VPagination/VPagination.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VPagination/VPagination.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VPagination/VPagination.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VPagination.sass */
              "./src/components/VPagination/VPagination.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/intersectable */
              "./src/mixins/intersectable/index.ts"
            ), d = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = function() {
              return c = Object.assign || function(g) {
                for (var m, v = 1, y = arguments.length; v < y; v++) {
                  m = arguments[v];
                  for (var E in m)
                    Object.prototype.hasOwnProperty.call(m, E) && (g[E] = m[E]);
                }
                return g;
              }, c.apply(this, arguments);
            }, h = function(g, m) {
              var v = typeof Symbol == "function" && g[Symbol.iterator];
              if (!v)
                return g;
              var y = v.call(g), E, C = [], x;
              try {
                for (; (m === void 0 || m-- > 0) && !(E = y.next()).done; )
                  C.push(E.value);
              } catch (b) {
                x = {
                  error: b
                };
              } finally {
                try {
                  E && !E.done && (v = y.return) && v.call(y);
                } finally {
                  if (x)
                    throw x.error;
                }
              }
              return C;
            }, p = function(g, m, v) {
              if (v || arguments.length === 2)
                for (var y = 0, E = m.length, C; y < E; y++)
                  (C || !(y in m)) && (C || (C = Array.prototype.slice.call(m, 0, y)), C[y] = m[y]);
              return g.concat(C || Array.prototype.slice.call(m));
            };
            r.default = Object(u.default)(l.default, Object(f.default)({
              onVisible: ["init"]
            }), d.default).extend({
              name: "v-pagination",
              directives: {
                Resize: o.default
              },
              props: {
                circle: Boolean,
                disabled: Boolean,
                navigationColor: String,
                navigationTextColor: String,
                length: {
                  type: Number,
                  default: 0,
                  validator: function(m) {
                    return m % 1 === 0;
                  }
                },
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                totalVisible: [Number, String],
                value: {
                  type: Number,
                  default: 0
                },
                pageAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.page"
                },
                currentPageAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.currentPage"
                },
                previousAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.previous"
                },
                nextAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.next"
                },
                wrapperAriaLabel: {
                  type: String,
                  default: "$vuetify.pagination.ariaLabel.wrapper"
                }
              },
              data: function() {
                return {
                  maxButtons: 0,
                  selected: null
                };
              },
              computed: {
                classes: function() {
                  return c({
                    "v-pagination": !0,
                    "v-pagination--circle": this.circle,
                    "v-pagination--disabled": this.disabled
                  }, this.themeClasses);
                },
                items: function() {
                  var m = parseInt(this.totalVisible, 10);
                  if (m === 0 || isNaN(this.length) || this.length > Number.MAX_SAFE_INTEGER)
                    return [];
                  var v = Math.min(Math.max(0, m) || this.length, Math.max(0, this.maxButtons) || this.length, this.length);
                  if (this.length <= v)
                    return this.range(1, this.length);
                  var y = v % 2 === 0 ? 1 : 0, E = Math.floor(v / 2), C = this.length - E + 1 + y;
                  if (this.value > E && this.value < C) {
                    var x = 1, b = this.length, P = this.value - E + 2, O = this.value + E - 2 - y, T = P - 1 === x + 1 ? 2 : "...", M = O + 1 === b - 1 ? O + 1 : "...";
                    return p(p([1, T], h(this.range(P, O)), !1), [M, this.length], !1);
                  } else if (this.value === E) {
                    var O = this.value + E - 1 - y;
                    return p(p([], h(this.range(1, O)), !1), ["...", this.length], !1);
                  } else if (this.value === C) {
                    var P = this.value - E + 1;
                    return p([1, "..."], h(this.range(P, this.length)), !1);
                  } else
                    return p(p(p([], h(this.range(1, E)), !1), ["..."], !1), h(this.range(C, this.length)), !1);
                }
              },
              watch: {
                value: function() {
                  this.init();
                }
              },
              beforeMount: function() {
                this.init();
              },
              methods: {
                init: function() {
                  var m = this;
                  this.selected = null, this.onResize(), this.$nextTick(this.onResize), setTimeout(function() {
                    return m.selected = m.value;
                  }, 100);
                },
                onResize: function() {
                  var m = this.$el && this.$el.parentElement ? this.$el.parentElement.clientWidth : window.innerWidth;
                  this.maxButtons = Math.floor((m - 96) / 42);
                },
                next: function(m) {
                  m.preventDefault(), this.$emit("input", this.value + 1), this.$emit("next");
                },
                previous: function(m) {
                  m.preventDefault(), this.$emit("input", this.value - 1), this.$emit("previous");
                },
                range: function(m, v) {
                  var y = [];
                  m = m > 0 ? m : 1;
                  for (var E = m; E <= v; E++)
                    y.push(E);
                  return y;
                },
                genIcon: function(m, v, y, E, C) {
                  return m("li", [m("button", this.setBackgroundColor(this.navigationColor, {
                    staticClass: "v-pagination__navigation",
                    class: {
                      "v-pagination__navigation--disabled": y
                    },
                    attrs: {
                      disabled: y,
                      type: "button",
                      "aria-label": C
                    },
                    on: y ? {} : {
                      click: E
                    }
                  }), [m(a.default, {
                    props: {
                      color: this.navigationTextColor
                    }
                  }, [v])])]);
                },
                genItem: function(m, v) {
                  var y = this, E = v === this.value && (this.color || "primary"), C = v === this.value, x = C ? this.currentPageAriaLabel : this.pageAriaLabel;
                  return m("button", this.setBackgroundColor(E, {
                    staticClass: "v-pagination__item",
                    class: {
                      "v-pagination__item--active": v === this.value
                    },
                    attrs: {
                      type: "button",
                      "aria-current": C,
                      "aria-label": this.$vuetify.lang.t(x, v)
                    },
                    on: {
                      click: function() {
                        return y.$emit("input", v);
                      }
                    }
                  }), [v.toString()]);
                },
                genItems: function(m) {
                  var v = this;
                  return this.items.map(function(y, E) {
                    return m("li", {
                      key: E
                    }, [isNaN(Number(y)) ? m("span", {
                      class: "v-pagination__more"
                    }, [y.toString()]) : v.genItem(m, y)]);
                  });
                },
                genList: function(m, v) {
                  return m("ul", {
                    directives: [{
                      modifiers: {
                        quiet: !0
                      },
                      name: "resize",
                      value: this.onResize
                    }],
                    class: this.classes
                  }, v);
                }
              },
              render: function(m) {
                var v = [this.genIcon(m, this.$vuetify.rtl ? this.nextIcon : this.prevIcon, this.value <= 1, this.previous, this.$vuetify.lang.t(this.previousAriaLabel)), this.genItems(m), this.genIcon(m, this.$vuetify.rtl ? this.prevIcon : this.nextIcon, this.value >= this.length, this.next, this.$vuetify.lang.t(this.nextAriaLabel))];
                return m("nav", {
                  attrs: {
                    role: "navigation",
                    "aria-label": this.$vuetify.lang.t(this.wrapperAriaLabel)
                  }
                }, [this.genList(m, v)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VPagination/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VPagination/index.ts ***!
            \*********************************************/
          /*! exports provided: VPagination, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VPagination */
              "./src/components/VPagination/VPagination.ts"
            );
            i.d(r, "VPagination", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VParallax/VParallax.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VParallax/VParallax.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VParallax/VParallax.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VParallax/VParallax.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VParallax.sass */
              "./src/components/VParallax/VParallax.sass"
            );
            var a = i(
              /*! ../../mixins/translatable */
              "./src/mixins/translatable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = Object(o.default)(a.default);
            r.default = l.extend().extend({
              name: "v-parallax",
              props: {
                alt: {
                  type: String,
                  default: ""
                },
                height: {
                  type: [String, Number],
                  default: 500
                },
                src: String,
                srcset: String
              },
              data: function() {
                return {
                  isBooted: !1
                };
              },
              computed: {
                styles: function() {
                  return {
                    display: "block",
                    opacity: this.isBooted ? 1 : 0,
                    transform: "translate(-50%, " + this.parallax + "px)"
                  };
                }
              },
              mounted: function() {
                this.init();
              },
              methods: {
                init: function() {
                  var d = this, u = this.$refs.img;
                  u && (u.complete ? (this.translate(), this.listeners()) : u.addEventListener("load", function() {
                    d.translate(), d.listeners();
                  }, !1), this.isBooted = !0);
                },
                objHeight: function() {
                  return this.$refs.img.naturalHeight;
                }
              },
              render: function(d) {
                var u = {
                  staticClass: "v-parallax__image",
                  style: this.styles,
                  attrs: {
                    src: this.src,
                    srcset: this.srcset,
                    alt: this.alt
                  },
                  ref: "img"
                }, c = d("div", {
                  staticClass: "v-parallax__image-container"
                }, [d("img", u)]), h = d("div", {
                  staticClass: "v-parallax__content"
                }, this.$slots.default);
                return d("div", {
                  staticClass: "v-parallax",
                  style: {
                    height: this.height + "px"
                  },
                  on: this.$listeners
                }, [c, h]);
              }
            });
          }
        ),
        /***/
        "./src/components/VParallax/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VParallax/index.ts ***!
            \*******************************************/
          /*! exports provided: VParallax, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VParallax */
              "./src/components/VParallax/VParallax.ts"
            );
            i.d(r, "VParallax", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VPicker/VPicker.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VPicker/VPicker.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VPicker/VPicker.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VPicker/VPicker.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VPicker.sass */
              "./src/components/VPicker/VPicker.sass"
            ), i(
              /*! ../VCard/VCard.sass */
              "./src/components/VCard/VCard.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(d.default)(a.default, o.default, l.default).extend({
              name: "v-picker",
              props: {
                flat: Boolean,
                fullWidth: Boolean,
                landscape: Boolean,
                noTitle: Boolean,
                transition: {
                  type: String,
                  default: "fade-transition"
                },
                width: {
                  type: [Number, String],
                  default: 290
                }
              },
              computed: {
                computedTitleColor: function() {
                  var h = this.isDark ? !1 : this.color || "primary";
                  return this.color || h;
                }
              },
              methods: {
                genTitle: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.computedTitleColor, {
                    staticClass: "v-picker__title",
                    class: {
                      "v-picker__title--landscape": this.landscape
                    }
                  }), this.$slots.title);
                },
                genBodyTransition: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, this.$slots.default);
                },
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-picker__body",
                    class: u({
                      "v-picker__body--no-title": this.noTitle
                    }, this.themeClasses),
                    style: this.fullWidth ? void 0 : {
                      width: Object(f.convertToUnit)(this.width)
                    }
                  }, [this.genBodyTransition()]);
                },
                genActions: function() {
                  return this.$createElement("div", {
                    staticClass: "v-picker__actions v-card__actions",
                    class: {
                      "v-picker__actions--no-title": this.noTitle
                    }
                  }, this.$slots.actions);
                }
              },
              render: function(h) {
                return h("div", {
                  staticClass: "v-picker v-card",
                  class: u(u({
                    "v-picker--flat": this.flat,
                    "v-picker--landscape": this.landscape,
                    "v-picker--full-width": this.fullWidth
                  }, this.themeClasses), this.elevationClasses)
                }, [this.$slots.title ? this.genTitle() : null, this.genBody(), this.$slots.actions ? this.genActions() : null]);
              }
            });
          }
        ),
        /***/
        "./src/components/VPicker/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VPicker/index.ts ***!
            \*****************************************/
          /*! exports provided: VPicker, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VPicker */
              "./src/components/VPicker/VPicker.ts"
            );
            i.d(r, "VPicker", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VProgressCircular/VProgressCircular.sass": (
          /*!*****************************************************************!*\
            !*** ./src/components/VProgressCircular/VProgressCircular.sass ***!
            \*****************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VProgressCircular/VProgressCircular.ts": (
          /*!***************************************************************!*\
            !*** ./src/components/VProgressCircular/VProgressCircular.ts ***!
            \***************************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VProgressCircular.sass */
              "./src/components/VProgressCircular/VProgressCircular.sass"
            );
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = o.default.extend({
              name: "v-progress-circular",
              directives: {
                intersect: a.default
              },
              props: {
                button: Boolean,
                indeterminate: Boolean,
                rotate: {
                  type: [Number, String],
                  default: 0
                },
                size: {
                  type: [Number, String],
                  default: 32
                },
                width: {
                  type: [Number, String],
                  default: 4
                },
                value: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  radius: 20,
                  isVisible: !0
                };
              },
              computed: {
                calculatedSize: function() {
                  return Number(this.size) + (this.button ? 8 : 0);
                },
                circumference: function() {
                  return 2 * Math.PI * this.radius;
                },
                classes: function() {
                  return {
                    "v-progress-circular--visible": this.isVisible,
                    "v-progress-circular--indeterminate": this.indeterminate,
                    "v-progress-circular--button": this.button
                  };
                },
                normalizedValue: function() {
                  return this.value < 0 ? 0 : this.value > 100 ? 100 : parseFloat(this.value);
                },
                strokeDashArray: function() {
                  return Math.round(this.circumference * 1e3) / 1e3;
                },
                strokeDashOffset: function() {
                  return (100 - this.normalizedValue) / 100 * this.circumference + "px";
                },
                strokeWidth: function() {
                  return Number(this.width) / +this.size * this.viewBoxSize * 2;
                },
                styles: function() {
                  return {
                    height: Object(l.convertToUnit)(this.calculatedSize),
                    width: Object(l.convertToUnit)(this.calculatedSize)
                  };
                },
                svgStyles: function() {
                  return {
                    transform: "rotate(" + Number(this.rotate) + "deg)"
                  };
                },
                viewBoxSize: function() {
                  return this.radius / (1 - Number(this.width) / +this.size);
                }
              },
              methods: {
                genCircle: function(d, u) {
                  return this.$createElement("circle", {
                    class: "v-progress-circular__" + d,
                    attrs: {
                      fill: "transparent",
                      cx: 2 * this.viewBoxSize,
                      cy: 2 * this.viewBoxSize,
                      r: this.radius,
                      "stroke-width": this.strokeWidth,
                      "stroke-dasharray": this.strokeDashArray,
                      "stroke-dashoffset": u
                    }
                  });
                },
                genSvg: function() {
                  var d = [this.indeterminate || this.genCircle("underlay", 0), this.genCircle("overlay", this.strokeDashOffset)];
                  return this.$createElement("svg", {
                    style: this.svgStyles,
                    attrs: {
                      xmlns: "http://www.w3.org/2000/svg",
                      viewBox: this.viewBoxSize + " " + this.viewBoxSize + " " + 2 * this.viewBoxSize + " " + 2 * this.viewBoxSize
                    }
                  }, d);
                },
                genInfo: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-circular__info"
                  }, this.$slots.default);
                },
                onObserve: function(d, u, c) {
                  this.isVisible = c;
                }
              },
              render: function(d) {
                return d("div", this.setTextColor(this.color, {
                  staticClass: "v-progress-circular",
                  attrs: {
                    role: "progressbar",
                    "aria-valuemin": 0,
                    "aria-valuemax": 100,
                    "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
                  },
                  class: this.classes,
                  directives: [{
                    name: "intersect",
                    value: this.onObserve
                  }],
                  style: this.styles,
                  on: this.$listeners
                }), [this.genSvg(), this.genInfo()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VProgressCircular/index.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VProgressCircular/index.ts ***!
            \***************************************************/
          /*! exports provided: VProgressCircular, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VProgressCircular */
              "./src/components/VProgressCircular/VProgressCircular.ts"
            );
            i.d(r, "VProgressCircular", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VProgressLinear/VProgressLinear.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VProgressLinear/VProgressLinear.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VProgressLinear/VProgressLinear.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VProgressLinear/VProgressLinear.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VProgressLinear.sass */
              "./src/components/VProgressLinear/VProgressLinear.sass"
            );
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), l = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), f = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), p = function() {
              return p = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, p.apply(this, arguments);
            }, g = Object(h.default)(l.default, Object(f.factory)(["absolute", "fixed", "top", "bottom"]), d.default, u.default);
            r.default = g.extend({
              name: "v-progress-linear",
              directives: {
                intersect: o.default
              },
              props: {
                active: {
                  type: Boolean,
                  default: !0
                },
                backgroundColor: {
                  type: String,
                  default: null
                },
                backgroundOpacity: {
                  type: [Number, String],
                  default: null
                },
                bufferValue: {
                  type: [Number, String],
                  default: 100
                },
                color: {
                  type: String,
                  default: "primary"
                },
                height: {
                  type: [Number, String],
                  default: 4
                },
                indeterminate: Boolean,
                query: Boolean,
                reverse: Boolean,
                rounded: Boolean,
                stream: Boolean,
                striped: Boolean,
                value: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  internalLazyValue: this.value || 0,
                  isVisible: !0
                };
              },
              computed: {
                __cachedBackground: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.backgroundColor || this.color, {
                    staticClass: "v-progress-linear__background",
                    style: this.backgroundStyle
                  }));
                },
                __cachedBar: function() {
                  return this.$createElement(this.computedTransition, [this.__cachedBarType]);
                },
                __cachedBarType: function() {
                  return this.indeterminate ? this.__cachedIndeterminate : this.__cachedDeterminate;
                },
                __cachedBuffer: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-linear__buffer",
                    style: this.styles
                  });
                },
                __cachedDeterminate: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-progress-linear__determinate",
                    style: {
                      width: Object(c.convertToUnit)(this.normalizedValue, "%")
                    }
                  }));
                },
                __cachedIndeterminate: function() {
                  return this.$createElement("div", {
                    staticClass: "v-progress-linear__indeterminate",
                    class: {
                      "v-progress-linear__indeterminate--active": this.active
                    }
                  }, [this.genProgressBar("long"), this.genProgressBar("short")]);
                },
                __cachedStream: function() {
                  return this.stream ? this.$createElement("div", this.setTextColor(this.color, {
                    staticClass: "v-progress-linear__stream",
                    style: {
                      width: Object(c.convertToUnit)(100 - this.normalizedBuffer, "%")
                    }
                  })) : null;
                },
                backgroundStyle: function() {
                  var v, y = this.backgroundOpacity == null ? this.backgroundColor ? 1 : 0.3 : parseFloat(this.backgroundOpacity);
                  return v = {
                    opacity: y
                  }, v[this.isReversed ? "right" : "left"] = Object(c.convertToUnit)(this.normalizedValue, "%"), v.width = Object(c.convertToUnit)(Math.max(0, this.normalizedBuffer - this.normalizedValue), "%"), v;
                },
                classes: function() {
                  return p({
                    "v-progress-linear--absolute": this.absolute,
                    "v-progress-linear--fixed": this.fixed,
                    "v-progress-linear--query": this.query,
                    "v-progress-linear--reactive": this.reactive,
                    "v-progress-linear--reverse": this.isReversed,
                    "v-progress-linear--rounded": this.rounded,
                    "v-progress-linear--striped": this.striped,
                    "v-progress-linear--visible": this.isVisible
                  }, this.themeClasses);
                },
                computedTransition: function() {
                  return this.indeterminate ? a.VFadeTransition : a.VSlideXTransition;
                },
                isReversed: function() {
                  return this.$vuetify.rtl !== this.reverse;
                },
                normalizedBuffer: function() {
                  return this.normalize(this.bufferValue);
                },
                normalizedValue: function() {
                  return this.normalize(this.internalLazyValue);
                },
                reactive: function() {
                  return !!this.$listeners.change;
                },
                styles: function() {
                  var v = {};
                  return this.active || (v.height = 0), !this.indeterminate && parseFloat(this.normalizedBuffer) !== 100 && (v.width = Object(c.convertToUnit)(this.normalizedBuffer, "%")), v;
                }
              },
              methods: {
                genContent: function() {
                  var v = Object(c.getSlot)(this, "default", {
                    value: this.internalLazyValue
                  });
                  return v ? this.$createElement("div", {
                    staticClass: "v-progress-linear__content"
                  }, v) : null;
                },
                genListeners: function() {
                  var v = this.$listeners;
                  return this.reactive && (v.click = this.onClick), v;
                },
                genProgressBar: function(v) {
                  var y;
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-progress-linear__indeterminate",
                    class: (y = {}, y[v] = !0, y)
                  }));
                },
                onClick: function(v) {
                  if (this.reactive) {
                    var y = this.$el.getBoundingClientRect().width;
                    this.internalValue = v.offsetX / y * 100;
                  }
                },
                onObserve: function(v, y, E) {
                  this.isVisible = E;
                },
                normalize: function(v) {
                  return v < 0 ? 0 : v > 100 ? 100 : parseFloat(v);
                }
              },
              render: function(v) {
                var y = {
                  staticClass: "v-progress-linear",
                  attrs: {
                    role: "progressbar",
                    "aria-valuemin": 0,
                    "aria-valuemax": this.normalizedBuffer,
                    "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
                  },
                  class: this.classes,
                  directives: [{
                    name: "intersect",
                    value: this.onObserve
                  }],
                  style: {
                    bottom: this.bottom ? 0 : void 0,
                    height: this.active ? Object(c.convertToUnit)(this.height) : 0,
                    top: this.top ? 0 : void 0
                  },
                  on: this.genListeners()
                };
                return v("div", y, [this.__cachedStream, this.__cachedBackground, this.__cachedBuffer, this.__cachedBar, this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VProgressLinear/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VProgressLinear/index.ts ***!
            \*************************************************/
          /*! exports provided: VProgressLinear, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VProgressLinear */
              "./src/components/VProgressLinear/VProgressLinear.ts"
            );
            i.d(r, "VProgressLinear", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadio.sass": (
          /*!************************************************!*\
            !*** ./src/components/VRadioGroup/VRadio.sass ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadio.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VRadioGroup/VRadio.ts ***!
            \**********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRadio.sass */
              "./src/components/VRadioGroup/VRadio.sass"
            );
            var a = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), f = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), d = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), u = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), c = i(
              /*! ../../mixins/rippleable */
              "./src/mixins/rippleable/index.ts"
            ), h = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), p = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), v = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), y = function() {
              return y = Object.assign || function(x) {
                for (var b, P = 1, O = arguments.length; P < O; P++) {
                  b = arguments[P];
                  for (var T in b)
                    Object.prototype.hasOwnProperty.call(b, T) && (x[T] = b[T]);
                }
                return x;
              }, y.apply(this, arguments);
            }, E = function(x, b) {
              var P = {};
              for (var O in x)
                Object.prototype.hasOwnProperty.call(x, O) && b.indexOf(O) < 0 && (P[O] = x[O]);
              if (x != null && typeof Object.getOwnPropertySymbols == "function")
                for (var T = 0, O = Object.getOwnPropertySymbols(x); T < O.length; T++)
                  b.indexOf(O[T]) < 0 && Object.prototype.propertyIsEnumerable.call(x, O[T]) && (P[O[T]] = x[O[T]]);
              return P;
            }, C = Object(m.default)(f.default, d.default, c.default, Object(u.factory)("radioGroup"), h.default);
            r.default = C.extend().extend({
              name: "v-radio",
              inheritAttrs: !1,
              props: {
                disabled: {
                  type: Boolean,
                  default: null
                },
                id: String,
                label: String,
                name: String,
                offIcon: {
                  type: String,
                  default: "$radioOff"
                },
                onIcon: {
                  type: String,
                  default: "$radioOn"
                },
                readonly: {
                  type: Boolean,
                  default: null
                },
                value: {
                  default: null
                }
              },
              data: function() {
                return {
                  isFocused: !1
                };
              },
              computed: {
                classes: function() {
                  return y(y({
                    "v-radio--is-disabled": this.isDisabled,
                    "v-radio--is-focused": this.isFocused
                  }, this.themeClasses), this.groupClasses);
                },
                computedColor: function() {
                  if (!this.isDisabled)
                    return p.default.options.computed.computedColor.call(this);
                },
                computedIcon: function() {
                  return this.isActive ? this.onIcon : this.offIcon;
                },
                computedId: function() {
                  return l.default.options.computed.computedId.call(this);
                },
                hasLabel: l.default.options.computed.hasLabel,
                hasState: function() {
                  return (this.radioGroup || {}).hasState;
                },
                isDisabled: function() {
                  var b;
                  return (b = this.disabled) !== null && b !== void 0 ? b : !!this.radioGroup && this.radioGroup.isDisabled;
                },
                isReadonly: function() {
                  var b;
                  return (b = this.readonly) !== null && b !== void 0 ? b : !!this.radioGroup && this.radioGroup.isReadonly;
                },
                computedName: function() {
                  return this.name || !this.radioGroup ? this.name : this.radioGroup.name || "radio-" + this.radioGroup._uid;
                },
                rippleState: function() {
                  return p.default.options.computed.rippleState.call(this);
                },
                validationState: function() {
                  return (this.radioGroup || {}).validationState || this.computedColor;
                }
              },
              methods: {
                genInput: function(b) {
                  return p.default.options.methods.genInput.call(this, "radio", b);
                },
                genLabel: function() {
                  return this.hasLabel ? this.$createElement(a.default, {
                    on: {
                      // Label shouldn't cause the input to focus
                      click: p.prevent
                    },
                    attrs: {
                      for: this.computedId
                    },
                    props: {
                      color: this.validationState,
                      focused: this.hasState
                    }
                  }, Object(g.getSlot)(this, "label") || this.label) : null;
                },
                genRadio: function() {
                  var b = this.attrs$;
                  b.title;
                  var P = E(b, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.$createElement(o.default, this.setTextColor(this.validationState, {
                    props: {
                      dense: this.radioGroup && this.radioGroup.dense
                    }
                  }), this.computedIcon), this.genInput(y({
                    name: this.computedName,
                    value: this.value
                  }, P)), this.genRipple(this.setTextColor(this.rippleState))]);
                },
                onFocus: function(b) {
                  this.isFocused = !0, this.$emit("focus", b);
                },
                onBlur: function(b) {
                  this.isFocused = !1, this.$emit("blur", b);
                },
                onChange: function() {
                  this.isDisabled || this.isReadonly || this.isActive || this.toggle();
                },
                onKeydown: function() {
                }
                // Override default with noop
              },
              render: function(b) {
                var P = {
                  staticClass: "v-radio",
                  class: this.classes,
                  on: Object(v.mergeListeners)({
                    click: this.onChange
                  }, this.listeners$),
                  attrs: {
                    title: this.attrs$.title
                  }
                };
                return b("div", P, [this.genRadio(), this.genLabel()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadioGroup.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VRadioGroup/VRadioGroup.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRadioGroup/VRadioGroup.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VRadioGroup/VRadioGroup.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            ), i(
              /*! ./VRadioGroup.sass */
              "./src/components/VRadioGroup/VRadioGroup.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            }, d = Object(l.default)(o.BaseItemGroup, a.default);
            r.default = d.extend({
              name: "v-radio-group",
              provide: function() {
                return {
                  radioGroup: this
                };
              },
              props: {
                column: {
                  type: Boolean,
                  default: !0
                },
                height: {
                  type: [Number, String],
                  default: "auto"
                },
                name: String,
                row: Boolean,
                // If no value set on VRadio
                // will match valueComparator
                // force default to null
                value: null
              },
              computed: {
                classes: function() {
                  return f(f({}, a.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls v-input--radio-group": !0,
                    "v-input--radio-group--column": this.column && !this.row,
                    "v-input--radio-group--row": this.row
                  });
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-input--radio-group__input",
                    attrs: {
                      id: this.id,
                      role: "radiogroup",
                      "aria-labelledby": this.computedId
                    }
                  }, a.default.options.methods.genDefaultSlot.call(this));
                },
                genInputSlot: function() {
                  var c = a.default.options.methods.genInputSlot.call(this);
                  return delete c.data.on.click, c;
                },
                genLabel: function() {
                  var c = a.default.options.methods.genLabel.call(this);
                  return c ? (c.data.attrs.id = this.computedId, delete c.data.attrs.for, c.tag = "legend", c) : null;
                },
                onClick: o.BaseItemGroup.options.methods.onClick
              },
              render: function(c) {
                var h = a.default.options.render.call(this, c);
                return this._b(h.data, "div", this.attrs$), h;
              }
            });
          }
        ),
        /***/
        "./src/components/VRadioGroup/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VRadioGroup/index.ts ***!
            \*********************************************/
          /*! exports provided: VRadioGroup, VRadio, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRadioGroup */
              "./src/components/VRadioGroup/VRadioGroup.ts"
            );
            i.d(r, "VRadioGroup", function() {
              return a.default;
            });
            var o = i(
              /*! ./VRadio */
              "./src/components/VRadioGroup/VRadio.ts"
            );
            i.d(r, "VRadio", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VRadioGroup: a.default,
                VRadio: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VRangeSlider/VRangeSlider.sass": (
          /*!*******************************************************!*\
            !*** ./src/components/VRangeSlider/VRangeSlider.sass ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRangeSlider/VRangeSlider.ts": (
          /*!*****************************************************!*\
            !*** ./src/components/VRangeSlider/VRangeSlider.ts ***!
            \*****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRangeSlider.sass */
              "./src/components/VRangeSlider/VRangeSlider.sass"
            );
            var a = i(
              /*! ../VSlider */
              "./src/components/VSlider/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = function() {
              return l = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, l.apply(this, arguments);
            }, f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = a.default.extend({
              name: "v-range-slider",
              props: {
                value: {
                  type: Array,
                  default: function() {
                    return [0, 0];
                  }
                }
              },
              data: function() {
                return {
                  activeThumb: null,
                  lazyValue: this.value
                };
              },
              computed: {
                classes: function() {
                  return l(l({}, a.default.options.computed.classes.call(this)), {
                    "v-input--range-slider": !0
                  });
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(c) {
                    var h = this, p = c.map(function(v) {
                      return v === void 0 && (v = 0), h.roundValue(Math.min(Math.max(v, h.minValue), h.maxValue));
                    });
                    if (p[0] > p[1] || p[1] < p[0]) {
                      if (this.activeThumb !== null) {
                        var g = this.activeThumb === 1 ? 0 : 1, m = this.$refs["thumb_" + g];
                        m.focus();
                      }
                      p = [p[1], p[0]];
                    }
                    this.lazyValue = p, Object(o.deepEqual)(p, this.value) || this.$emit("input", p), this.validate();
                  }
                },
                inputWidth: function() {
                  var c = this;
                  return this.internalValue.map(function(h) {
                    return (c.roundValue(h) - c.minValue) / (c.maxValue - c.minValue) * 100;
                  });
                }
              },
              methods: {
                getTrackStyle: function(c, h, p, g) {
                  var m;
                  p === void 0 && (p = 0), g === void 0 && (g = 0);
                  var v = this.vertical ? this.$vuetify.rtl ? "top" : "bottom" : this.$vuetify.rtl ? "right" : "left", y = this.vertical ? "height" : "width", E = "calc(" + c + "% + " + p + "px)", C = "calc(" + h + "% + " + g + "px)";
                  return m = {
                    transition: this.trackTransition
                  }, m[v] = E, m[y] = C, m;
                },
                getIndexOfClosestValue: function(c, h) {
                  return Math.abs(c[0] - h) < Math.abs(c[1] - h) ? 0 : 1;
                },
                genInput: function() {
                  var c = this;
                  return Object(o.createRange)(2).map(function(h) {
                    var p = a.default.options.methods.genInput.call(c);
                    return p.data = p.data || {}, p.data.attrs = p.data.attrs || {}, p.data.attrs.value = c.internalValue[h], p.data.attrs.id = "input-" + (h ? "max" : "min") + "-" + c._uid, p;
                  });
                },
                genTrackContainer: function() {
                  var c = this, h = [], p = this.isDisabled ? 10 : 0, g = [{
                    class: "v-slider__track-background",
                    color: this.computedTrackColor,
                    styles: [0, this.inputWidth[0], 0, -p]
                  }, {
                    class: this.isDisabled ? "v-slider__track-background" : "v-slider__track-fill",
                    color: this.isDisabled ? this.computedTrackColor : this.computedTrackFillColor,
                    styles: [this.inputWidth[0], Math.abs(this.inputWidth[1] - this.inputWidth[0]), p, p * -2]
                  }, {
                    class: "v-slider__track-background",
                    color: this.computedTrackColor,
                    styles: [this.inputWidth[1], Math.abs(100 - this.inputWidth[1]), p, -p]
                  }];
                  return this.$vuetify.rtl && g.reverse(), h.push.apply(h, d([], f(g.map(function(m) {
                    return c.$createElement("div", c.setBackgroundColor(m.color, {
                      staticClass: m.class,
                      style: c.getTrackStyle.apply(c, d([], f(m.styles), !1))
                    }));
                  })), !1)), this.$createElement("div", {
                    staticClass: "v-slider__track-container",
                    ref: "track"
                  }, h);
                },
                genChildren: function() {
                  var c = this;
                  return [this.genInput(), this.genTrackContainer(), this.genSteps(), Object(o.createRange)(2).map(function(h) {
                    var p = c.internalValue[h], g = function(x) {
                      c.isFocused = !0, c.activeThumb = h, c.$emit("focus", x);
                    }, m = function(x) {
                      c.isFocused = !1, c.activeThumb = null, c.$emit("blur", x);
                    }, v = c.inputWidth[h], y = c.isActive && c.activeThumb === h, E = c.isFocused && c.activeThumb === h;
                    return c.genThumbContainer(p, v, y, E, g, m, "thumb_" + h);
                  })];
                },
                reevaluateSelected: function(c) {
                  this.activeThumb = this.getIndexOfClosestValue(this.internalValue, c);
                  var h = "thumb_" + this.activeThumb, p = this.$refs[h];
                  p.focus();
                },
                onSliderMouseDown: function(c) {
                  var h = this, p, g = this.parseMouseMove(c);
                  if (this.reevaluateSelected(g), this.oldValue = this.internalValue, this.isActive = !0, !((p = c.target) === null || p === void 0) && p.matches(".v-slider__thumb-container, .v-slider__thumb-container *")) {
                    this.thumbPressed = !0;
                    var m = c.target.getBoundingClientRect(), v = "touches" in c ? c.touches[0] : c;
                    this.startOffset = this.vertical ? v.clientY - (m.top + m.height / 2) : v.clientX - (m.left + m.width / 2);
                  } else
                    this.startOffset = 0, window.clearTimeout(this.mouseTimeout), this.mouseTimeout = window.setTimeout(function() {
                      h.thumbPressed = !0;
                    }, 300);
                  var y = o.passiveSupported ? {
                    passive: !0,
                    capture: !0
                  } : !0, E = o.passiveSupported ? {
                    passive: !0
                  } : !1, C = "touches" in c;
                  this.onMouseMove(c), this.app.addEventListener(C ? "touchmove" : "mousemove", this.onMouseMove, E), Object(o.addOnceEventListener)(this.app, C ? "touchend" : "mouseup", this.onSliderMouseUp, y), this.$emit("start", this.internalValue);
                },
                onSliderClick: function(c) {
                  if (!this.isActive) {
                    if (this.noClick) {
                      this.noClick = !1;
                      return;
                    }
                    var h = this.parseMouseMove(c);
                    this.reevaluateSelected(h), this.setInternalValue(h), this.$emit("change", this.internalValue);
                  }
                },
                onMouseMove: function(c) {
                  var h = this.parseMouseMove(c);
                  c.type === "mousemove" && (this.thumbPressed = !0), this.activeThumb === null && (this.activeThumb = this.getIndexOfClosestValue(this.internalValue, h)), this.setInternalValue(h);
                },
                onKeyDown: function(c) {
                  if (this.activeThumb !== null) {
                    var h = this.parseKeyDown(c, this.internalValue[this.activeThumb]);
                    h != null && (this.setInternalValue(h), this.$emit("change", this.internalValue));
                  }
                },
                setInternalValue: function(c) {
                  var h = this;
                  this.internalValue = this.internalValue.map(function(p, g) {
                    return g === h.activeThumb ? c : Number(p);
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VRangeSlider/index.ts": (
          /*!**********************************************!*\
            !*** ./src/components/VRangeSlider/index.ts ***!
            \**********************************************/
          /*! exports provided: VRangeSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRangeSlider */
              "./src/components/VRangeSlider/VRangeSlider.ts"
            );
            i.d(r, "VRangeSlider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VRating/VRating.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VRating/VRating.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VRating/VRating.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VRating/VRating.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VRating.sass */
              "./src/components/VRating/VRating.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/sizeable */
              "./src/mixins/sizeable/index.ts"
            ), d = i(
              /*! ../../mixins/rippleable */
              "./src/mixins/rippleable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(h.default)(o.default, l.default, d.default, f.default, u.default).extend({
              name: "v-rating",
              props: {
                backgroundColor: {
                  type: String,
                  default: "accent"
                },
                color: {
                  type: String,
                  default: "primary"
                },
                clearable: Boolean,
                dense: Boolean,
                emptyIcon: {
                  type: String,
                  default: "$ratingEmpty"
                },
                fullIcon: {
                  type: String,
                  default: "$ratingFull"
                },
                halfIcon: {
                  type: String,
                  default: "$ratingHalf"
                },
                halfIncrements: Boolean,
                hover: Boolean,
                length: {
                  type: [Number, String],
                  default: 5
                },
                readonly: Boolean,
                size: [Number, String],
                value: {
                  type: Number,
                  default: 0
                },
                iconLabel: {
                  type: String,
                  default: "$vuetify.rating.ariaLabel.icon"
                }
              },
              data: function() {
                return {
                  hoverIndex: -1,
                  internalValue: this.value
                };
              },
              computed: {
                directives: function() {
                  return this.readonly || !this.ripple ? [] : [{
                    name: "ripple",
                    value: {
                      circle: !0
                    }
                  }];
                },
                iconProps: function() {
                  var g = this.$props, m = g.dark, v = g.large, y = g.light, E = g.medium, C = g.small, x = g.size, b = g.xLarge, P = g.xSmall;
                  return {
                    dark: m,
                    large: v,
                    light: y,
                    medium: E,
                    size: x,
                    small: C,
                    xLarge: b,
                    xSmall: P
                  };
                },
                isHovering: function() {
                  return this.hover && this.hoverIndex >= 0;
                }
              },
              watch: {
                internalValue: function(g) {
                  g !== this.value && this.$emit("input", g);
                },
                value: function(g) {
                  this.internalValue = g;
                }
              },
              methods: {
                createClickFn: function(g) {
                  var m = this;
                  return function(v) {
                    if (!m.readonly) {
                      var y = m.genHoverIndex(v, g);
                      m.clearable && m.internalValue === y ? m.internalValue = 0 : m.internalValue = y;
                    }
                  };
                },
                createProps: function(g) {
                  var m = {
                    index: g,
                    value: this.internalValue,
                    click: this.createClickFn(g),
                    isFilled: Math.floor(this.internalValue) > g,
                    isHovered: Math.floor(this.hoverIndex) > g
                  };
                  return this.halfIncrements && (m.isHalfHovered = !m.isHovered && (this.hoverIndex - g) % 1 > 0, m.isHalfFilled = !m.isFilled && (this.internalValue - g) % 1 > 0), m;
                },
                genHoverIndex: function(g, m) {
                  var v = this.isHalfEvent(g);
                  return this.halfIncrements && this.$vuetify.rtl && (v = !v), m + (v ? 0.5 : 1);
                },
                getIconName: function(g) {
                  var m = this.isHovering ? g.isHovered : g.isFilled, v = this.isHovering ? g.isHalfHovered : g.isHalfFilled;
                  return m ? this.fullIcon : v ? this.halfIcon : this.emptyIcon;
                },
                getColor: function(g) {
                  if (this.isHovering) {
                    if (g.isHovered || g.isHalfHovered)
                      return this.color;
                  } else if (g.isFilled || g.isHalfFilled)
                    return this.color;
                  return this.backgroundColor;
                },
                isHalfEvent: function(g) {
                  if (this.halfIncrements) {
                    var m = g.target && g.target.getBoundingClientRect();
                    if (m && g.pageX - m.left < m.width / 2)
                      return !0;
                  }
                  return !1;
                },
                onMouseEnter: function(g, m) {
                  var v = this;
                  this.runDelay("open", function() {
                    v.hoverIndex = v.genHoverIndex(g, m);
                  });
                },
                onMouseLeave: function() {
                  var g = this;
                  this.runDelay("close", function() {
                    return g.hoverIndex = -1;
                  });
                },
                genItem: function(g) {
                  var m = this, v = this.createProps(g);
                  if (this.$scopedSlots.item)
                    return this.$scopedSlots.item(v);
                  var y = {
                    click: v.click
                  };
                  return this.hover && (y.mouseenter = function(E) {
                    return m.onMouseEnter(E, g);
                  }, y.mouseleave = this.onMouseLeave, this.halfIncrements && (y.mousemove = function(E) {
                    return m.onMouseEnter(E, g);
                  })), this.$createElement(a.default, this.setTextColor(this.getColor(v), {
                    attrs: {
                      "aria-label": this.$vuetify.lang.t(this.iconLabel, g + 1, Number(this.length))
                    },
                    directives: this.directives,
                    props: this.iconProps,
                    on: y
                  }), [this.getIconName(v)]);
                }
              },
              render: function(g) {
                var m = this, v = Object(c.createRange)(Number(this.length)).map(function(y) {
                  return m.genItem(y);
                });
                return g("div", {
                  staticClass: "v-rating",
                  class: {
                    "v-rating--readonly": this.readonly,
                    "v-rating--dense": this.dense
                  }
                }, v);
              }
            });
          }
        ),
        /***/
        "./src/components/VRating/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VRating/index.ts ***!
            \*****************************************/
          /*! exports provided: VRating, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VRating */
              "./src/components/VRating/VRating.ts"
            );
            i.d(r, "VRating", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VResponsive/VResponsive.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VResponsive/VResponsive.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VResponsive/VResponsive.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VResponsive/VResponsive.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VResponsive.sass */
              "./src/components/VResponsive/VResponsive.sass"
            );
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              name: "v-responsive",
              props: {
                aspectRatio: [String, Number],
                contentClass: String
              },
              computed: {
                computedAspectRatio: function() {
                  return Number(this.aspectRatio);
                },
                aspectStyle: function() {
                  return this.computedAspectRatio ? {
                    paddingBottom: 1 / this.computedAspectRatio * 100 + "%"
                  } : void 0;
                },
                __cachedSizer: function() {
                  return this.aspectStyle ? this.$createElement("div", {
                    style: this.aspectStyle,
                    staticClass: "v-responsive__sizer"
                  }) : [];
                }
              },
              methods: {
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-responsive__content",
                    class: this.contentClass
                  }, Object(l.getSlot)(this));
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-responsive",
                  style: this.measurableStyles,
                  on: this.$listeners
                }, [this.__cachedSizer, this.genContent()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VResponsive/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VResponsive/index.ts ***!
            \*********************************************/
          /*! exports provided: VResponsive, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VResponsive */
              "./src/components/VResponsive/VResponsive.ts"
            );
            i.d(r, "VResponsive", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSelect/VSelect.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSelect/VSelect.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSelect/VSelect.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSelect/VSelect.ts ***!
            \*******************************************/
          /*! exports provided: defaultMenuProps, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "defaultMenuProps", function() {
              return x;
            }), i(
              /*! ../VTextField/VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            ), i(
              /*! ./VSelect.sass */
              "./src/components/VSelect/VSelect.sass"
            );
            var a = i(
              /*! ../VChip */
              "./src/components/VChip/index.ts"
            ), o = i(
              /*! ../VMenu */
              "./src/components/VMenu/index.ts"
            ), l = i(
              /*! ./VSelectList */
              "./src/components/VSelect/VSelectList.ts"
            ), f = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), d = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), u = i(
              /*! ../../mixins/comparable */
              "./src/mixins/comparable/index.ts"
            ), c = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), h = i(
              /*! ../../mixins/filterable */
              "./src/mixins/filterable/index.ts"
            ), p = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), g = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), m = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), v = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), y = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), E = function() {
              return E = Object.assign || function(P) {
                for (var O, T = 1, M = arguments.length; T < M; T++) {
                  O = arguments[T];
                  for (var L in O)
                    Object.prototype.hasOwnProperty.call(O, L) && (P[L] = O[L]);
                }
                return P;
              }, E.apply(this, arguments);
            }, C = function(P) {
              var O = typeof Symbol == "function" && Symbol.iterator, T = O && P[O], M = 0;
              if (T)
                return T.call(P);
              if (P && typeof P.length == "number")
                return {
                  next: function() {
                    return P && M >= P.length && (P = void 0), {
                      value: P && P[M++],
                      done: !P
                    };
                  }
                };
              throw new TypeError(O ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, x = {
              closeOnClick: !1,
              closeOnContentClick: !1,
              disableKeys: !0,
              openOnClick: !1,
              maxHeight: 304
            }, b = Object(y.default)(d.default, u.default, c.default, h.default);
            r.default = b.extend().extend({
              name: "v-select",
              directives: {
                ClickOutside: p.default
              },
              props: {
                appendIcon: {
                  type: String,
                  default: "$dropdown"
                },
                attach: {
                  type: null,
                  default: !1
                },
                cacheItems: Boolean,
                chips: Boolean,
                clearable: Boolean,
                deletableChips: Boolean,
                disableLookup: Boolean,
                eager: Boolean,
                hideSelected: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                itemColor: {
                  type: String,
                  default: "primary"
                },
                itemDisabled: {
                  type: [String, Array, Function],
                  default: "disabled"
                },
                itemText: {
                  type: [String, Array, Function],
                  default: "text"
                },
                itemValue: {
                  type: [String, Array, Function],
                  default: "value"
                },
                menuProps: {
                  type: [String, Array, Object],
                  default: function() {
                    return x;
                  }
                },
                multiple: Boolean,
                openOnClear: Boolean,
                returnObject: Boolean,
                smallChips: Boolean
              },
              data: function() {
                return {
                  cachedItems: this.cacheItems ? this.items : [],
                  menuIsBooted: !1,
                  isMenuActive: !1,
                  lastItem: 20,
                  // As long as a value is defined, show it
                  // Otherwise, check if multiple
                  // to determine which default to provide
                  lazyValue: this.value !== void 0 ? this.value : this.multiple ? [] : void 0,
                  selectedIndex: -1,
                  selectedItems: [],
                  keyboardLookupPrefix: "",
                  keyboardLookupLastTime: 0
                };
              },
              computed: {
                /* All items that the select has */
                allItems: function() {
                  return this.filterDuplicates(this.cachedItems.concat(this.items));
                },
                classes: function() {
                  return E(E({}, d.default.options.computed.classes.call(this)), {
                    "v-select": !0,
                    "v-select--chips": this.hasChips,
                    "v-select--chips--small": this.smallChips,
                    "v-select--is-menu-active": this.isMenuActive,
                    "v-select--is-multi": this.multiple
                  });
                },
                /* Used by other components to overwrite */
                computedItems: function() {
                  return this.allItems;
                },
                computedOwns: function() {
                  return "list-" + this._uid;
                },
                computedCounterValue: function() {
                  var O, T = this.multiple ? this.selectedItems : ((O = this.getText(this.selectedItems[0])) !== null && O !== void 0 ? O : "").toString();
                  return typeof this.counterValue == "function" ? this.counterValue(T) : T.length;
                },
                directives: function() {
                  var O = this;
                  return this.isFocused ? [{
                    name: "click-outside",
                    value: {
                      handler: this.blur,
                      closeConditional: this.closeConditional,
                      include: function() {
                        return O.getOpenDependentElements();
                      }
                    }
                  }] : void 0;
                },
                dynamicHeight: function() {
                  return "auto";
                },
                hasChips: function() {
                  return this.chips || this.smallChips;
                },
                hasSlot: function() {
                  return !!(this.hasChips || this.$scopedSlots.selection);
                },
                isDirty: function() {
                  return this.selectedItems.length > 0;
                },
                listData: function() {
                  var O, T = this.$vnode && this.$vnode.context.$options._scopeId, M = T ? (O = {}, O[T] = !0, O) : {};
                  return {
                    attrs: E(E({}, M), {
                      id: this.computedOwns
                    }),
                    props: {
                      action: this.multiple,
                      color: this.itemColor,
                      dense: this.dense,
                      hideSelected: this.hideSelected,
                      items: this.virtualizedItems,
                      itemDisabled: this.itemDisabled,
                      itemText: this.itemText,
                      itemValue: this.itemValue,
                      noDataText: this.$vuetify.lang.t(this.noDataText),
                      selectedItems: this.selectedItems
                    },
                    on: {
                      select: this.selectItem
                    },
                    scopedSlots: {
                      item: this.$scopedSlots.item
                    }
                  };
                },
                staticList: function() {
                  return (this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"]) && Object(v.consoleError)("assert: staticList should not be called if slots are used"), this.$createElement(l.default, this.listData);
                },
                virtualizedItems: function() {
                  return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem);
                },
                menuCanShow: function() {
                  return !0;
                },
                $_menuProps: function() {
                  var O = typeof this.menuProps == "string" ? this.menuProps.split(",") : this.menuProps;
                  return Array.isArray(O) && (O = O.reduce(function(T, M) {
                    return T[M.trim()] = !0, T;
                  }, {})), E(E(E({}, x), {
                    eager: this.eager,
                    value: this.menuCanShow && this.isMenuActive,
                    nudgeBottom: O.offsetY ? 1 : 0
                  }), O);
                }
              },
              watch: {
                internalValue: function(O) {
                  var T = this;
                  this.initialValue = O, this.setSelectedItems(), this.multiple && this.$nextTick(function() {
                    var M;
                    (M = T.$refs.menu) === null || M === void 0 || M.updateDimensions();
                  }), this.hideSelected && this.$nextTick(function() {
                    T.onScroll();
                  });
                },
                isMenuActive: function(O) {
                  var T = this;
                  window.setTimeout(function() {
                    return T.onMenuActiveChange(O);
                  });
                },
                items: {
                  immediate: !0,
                  handler: function(O) {
                    var T = this;
                    this.cacheItems && this.$nextTick(function() {
                      T.cachedItems = T.filterDuplicates(T.cachedItems.concat(O));
                    }), this.setSelectedItems();
                  }
                }
              },
              methods: {
                /** @public */
                blur: function(O) {
                  d.default.options.methods.blur.call(this, O), this.isMenuActive = !1, this.isFocused = !1, this.selectedIndex = -1, this.setMenuIndex(-1);
                },
                /** @public */
                activateMenu: function() {
                  !this.isInteractive || this.isMenuActive || (this.isMenuActive = !0);
                },
                clearableCallback: function() {
                  var O = this;
                  this.setValue(this.multiple ? [] : null), this.setMenuIndex(-1), this.$nextTick(function() {
                    return O.$refs.input && O.$refs.input.focus();
                  }), this.openOnClear && (this.isMenuActive = !0);
                },
                closeConditional: function(O) {
                  return this.isMenuActive ? !this._isDestroyed && // Click originates from outside the menu content
                  // Multiple selects don't close when an item is clicked
                  (!this.getContent() || !this.getContent().contains(O.target)) && // Click originates from outside the element
                  this.$el && !this.$el.contains(O.target) && O.target !== this.$el : !0;
                },
                filterDuplicates: function(O) {
                  for (var T = /* @__PURE__ */ new Map(), M = 0; M < O.length; ++M) {
                    var L = O[M];
                    if (L != null) {
                      if (L.header || L.divider) {
                        T.set(L, L);
                        continue;
                      }
                      var A = this.getValue(L);
                      !T.has(A) && T.set(A, L);
                    }
                  }
                  return Array.from(T.values());
                },
                findExistingIndex: function(O) {
                  var T = this, M = this.getValue(O);
                  return (this.internalValue || []).findIndex(function(L) {
                    return T.valueComparator(T.getValue(L), M);
                  });
                },
                getContent: function() {
                  return this.$refs.menu && this.$refs.menu.$refs.content;
                },
                genChipSelection: function(O, T) {
                  var M = this, L = this.isDisabled || this.getDisabled(O), A = !L && this.isInteractive;
                  return this.$createElement(a.default, {
                    staticClass: "v-chip--select",
                    attrs: {
                      tabindex: -1
                    },
                    props: {
                      close: this.deletableChips && A,
                      disabled: L,
                      inputValue: T === this.selectedIndex,
                      small: this.smallChips
                    },
                    on: {
                      click: function(I) {
                        A && (I.stopPropagation(), M.selectedIndex = T);
                      },
                      "click:close": function() {
                        return M.onChipInput(O);
                      }
                    },
                    key: JSON.stringify(this.getValue(O))
                  }, this.getText(O));
                },
                genCommaSelection: function(O, T, M) {
                  var L = T === this.selectedIndex && this.computedColor, A = this.isDisabled || this.getDisabled(O);
                  return this.$createElement("div", this.setTextColor(L, {
                    staticClass: "v-select__selection v-select__selection--comma",
                    class: {
                      "v-select__selection--disabled": A
                    },
                    key: JSON.stringify(this.getValue(O))
                  }), "" + this.getText(O) + (M ? "" : ", "));
                },
                genDefaultSlot: function() {
                  var O = this.genSelections(), T = this.genInput();
                  return Array.isArray(O) ? O.push(T) : (O.children = O.children || [], O.children.push(T)), [this.genFieldset(), this.$createElement("div", {
                    staticClass: "v-select__slot",
                    directives: this.directives
                  }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, O, this.suffix ? this.genAffix("suffix") : null, this.genClearIcon(), this.genIconSlot(), this.genHiddenInput()]), this.genMenu(), this.genProgress()];
                },
                genIcon: function(O, T, M) {
                  var L = f.default.options.methods.genIcon.call(this, O, T, M);
                  return O === "append" && (L.children[0].data = Object(g.default)(L.children[0].data, {
                    attrs: {
                      tabindex: L.children[0].componentOptions.listeners && "-1",
                      "aria-hidden": "true",
                      "aria-label": void 0
                    }
                  })), L;
                },
                genInput: function() {
                  var O = d.default.options.methods.genInput.call(this);
                  return delete O.data.attrs.name, O.data = Object(g.default)(O.data, {
                    domProps: {
                      value: null
                    },
                    attrs: {
                      readonly: !0,
                      type: "text",
                      "aria-readonly": String(this.isReadonly),
                      "aria-activedescendant": Object(m.getObjectValueByPath)(this.$refs.menu, "activeTile.id"),
                      autocomplete: Object(m.getObjectValueByPath)(O.data, "attrs.autocomplete", "off"),
                      placeholder: !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? this.placeholder : void 0
                    },
                    on: {
                      keypress: this.onKeyPress
                    }
                  }), O;
                },
                genHiddenInput: function() {
                  return this.$createElement("input", {
                    domProps: {
                      value: this.lazyValue
                    },
                    attrs: {
                      type: "hidden",
                      name: this.attrs$.name
                    }
                  });
                },
                genInputSlot: function() {
                  var O = d.default.options.methods.genInputSlot.call(this);
                  return O.data.attrs = E(E({}, O.data.attrs), {
                    role: "button",
                    "aria-haspopup": "listbox",
                    "aria-expanded": String(this.isMenuActive),
                    "aria-owns": this.computedOwns
                  }), O;
                },
                genList: function() {
                  return this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"] ? this.genListWithSlot() : this.staticList;
                },
                genListWithSlot: function() {
                  var O = this, T = ["prepend-item", "no-data", "append-item"].filter(function(M) {
                    return O.$slots[M];
                  }).map(function(M) {
                    return O.$createElement("template", {
                      slot: M
                    }, O.$slots[M]);
                  });
                  return this.$createElement(l.default, E({}, this.listData), T);
                },
                genMenu: function() {
                  var O = this, T = this.$_menuProps;
                  return T.activator = this.$refs["input-slot"], "attach" in T || (// TODO: make this a computed property or helper or something
                  this.attach === "" || // If used as a boolean prop (<v-menu attach>)
                  this.attach === !0 || // If bound to a boolean (<v-menu :attach="true">)
                  this.attach === "attach" ? T.attach = this.$el : T.attach = this.attach), this.$createElement(o.default, {
                    attrs: {
                      role: void 0
                    },
                    props: T,
                    on: {
                      input: function(L) {
                        O.isMenuActive = L, O.isFocused = L;
                      },
                      scroll: this.onScroll
                    },
                    ref: "menu"
                  }, [this.genList()]);
                },
                genSelections: function() {
                  var O = this.selectedItems.length, T = new Array(O), M;
                  for (this.$scopedSlots.selection ? M = this.genSlotSelection : this.hasChips ? M = this.genChipSelection : M = this.genCommaSelection; O--; )
                    T[O] = M(this.selectedItems[O], O, O === T.length - 1);
                  return this.$createElement("div", {
                    staticClass: "v-select__selections"
                  }, T);
                },
                genSlotSelection: function(O, T) {
                  var M = this;
                  return this.$scopedSlots.selection({
                    attrs: {
                      class: "v-chip--select"
                    },
                    parent: this,
                    item: O,
                    index: T,
                    select: function(A) {
                      A.stopPropagation(), M.selectedIndex = T;
                    },
                    selected: T === this.selectedIndex,
                    disabled: !this.isInteractive
                  });
                },
                getMenuIndex: function() {
                  return this.$refs.menu ? this.$refs.menu.listIndex : -1;
                },
                getDisabled: function(O) {
                  return Object(m.getPropertyFromItem)(O, this.itemDisabled, !1);
                },
                getText: function(O) {
                  return Object(m.getPropertyFromItem)(O, this.itemText, O);
                },
                getValue: function(O) {
                  return Object(m.getPropertyFromItem)(O, this.itemValue, this.getText(O));
                },
                onBlur: function(O) {
                  O && this.$emit("blur", O);
                },
                onChipInput: function(O) {
                  this.multiple ? this.selectItem(O) : this.setValue(null), this.selectedItems.length === 0 ? this.isMenuActive = !0 : this.isMenuActive = !1, this.selectedIndex = -1;
                },
                onClick: function(O) {
                  this.isInteractive && (this.isAppendInner(O.target) || (this.isMenuActive = !0), this.isFocused || (this.isFocused = !0, this.$emit("focus")), this.$emit("click", O));
                },
                onEscDown: function(O) {
                  O.preventDefault(), this.isMenuActive && (O.stopPropagation(), this.isMenuActive = !1);
                },
                onKeyPress: function(O) {
                  var T = this;
                  if (!(this.multiple || !this.isInteractive || this.disableLookup || O.key.length > 1 || O.ctrlKey || O.metaKey || O.altKey)) {
                    var M = 1e3, L = performance.now();
                    L - this.keyboardLookupLastTime > M && (this.keyboardLookupPrefix = ""), this.keyboardLookupPrefix += O.key.toLowerCase(), this.keyboardLookupLastTime = L;
                    var A = this.allItems.findIndex(function(I) {
                      var w, B = ((w = T.getText(I)) !== null && w !== void 0 ? w : "").toString();
                      return B.toLowerCase().startsWith(T.keyboardLookupPrefix);
                    }), D = this.allItems[A];
                    A !== -1 && (this.lastItem = Math.max(this.lastItem, A + 5), this.setValue(this.returnObject ? D : this.getValue(D)), this.$nextTick(function() {
                      return T.$refs.menu.getTiles();
                    }), setTimeout(function() {
                      return T.setMenuIndex(A);
                    }));
                  }
                },
                onKeyDown: function(O) {
                  var T = this;
                  if (!(this.isReadonly && O.keyCode !== m.keyCodes.tab)) {
                    var M = O.keyCode, L = this.$refs.menu;
                    if (this.$emit("keydown", O), !!L) {
                      if (this.isMenuActive && [m.keyCodes.up, m.keyCodes.down, m.keyCodes.home, m.keyCodes.end, m.keyCodes.enter].includes(M) && this.$nextTick(function() {
                        L.changeListIndex(O), T.$emit("update:list-index", L.listIndex);
                      }), [m.keyCodes.enter, m.keyCodes.space].includes(M) && this.activateMenu(), !this.isMenuActive && [m.keyCodes.up, m.keyCodes.down, m.keyCodes.home, m.keyCodes.end].includes(M))
                        return this.onUpDown(O);
                      if (M === m.keyCodes.esc)
                        return this.onEscDown(O);
                      if (M === m.keyCodes.tab)
                        return this.onTabDown(O);
                      if (M === m.keyCodes.space)
                        return this.onSpaceDown(O);
                    }
                  }
                },
                onMenuActiveChange: function(O) {
                  if (!(this.multiple && !O || this.getMenuIndex() > -1)) {
                    var T = this.$refs.menu;
                    if (!(!T || !this.isDirty)) {
                      this.$refs.menu.getTiles();
                      for (var M = 0; M < T.tiles.length; M++)
                        if (T.tiles[M].getAttribute("aria-selected") === "true") {
                          this.setMenuIndex(M);
                          break;
                        }
                    }
                  }
                },
                onMouseUp: function(O) {
                  var T = this;
                  this.hasMouseDown && O.which !== 3 && this.isInteractive && this.isAppendInner(O.target) && this.$nextTick(function() {
                    return T.isMenuActive = !T.isMenuActive;
                  }), d.default.options.methods.onMouseUp.call(this, O);
                },
                onScroll: function() {
                  var O = this;
                  if (!this.isMenuActive)
                    requestAnimationFrame(function() {
                      var M = O.getContent();
                      M && (M.scrollTop = 0);
                    });
                  else {
                    if (this.lastItem > this.computedItems.length)
                      return;
                    var T = this.getContent().scrollHeight - (this.getContent().scrollTop + this.getContent().clientHeight) < 200;
                    T && (this.lastItem += 20);
                  }
                },
                onSpaceDown: function(O) {
                  O.preventDefault();
                },
                onTabDown: function(O) {
                  var T = this.$refs.menu;
                  if (T) {
                    var M = T.activeTile;
                    !this.multiple && M && this.isMenuActive ? (O.preventDefault(), O.stopPropagation(), M.click()) : this.blur(O);
                  }
                },
                onUpDown: function(O) {
                  var T = this, M = this.$refs.menu;
                  if (M) {
                    if (O.preventDefault(), this.multiple)
                      return this.activateMenu();
                    var L = O.keyCode;
                    M.isBooted = !0, window.requestAnimationFrame(function() {
                      if (M.getTiles(), !M.hasClickableTiles)
                        return T.activateMenu();
                      switch (L) {
                        case m.keyCodes.up:
                          M.prevTile();
                          break;
                        case m.keyCodes.down:
                          M.nextTile();
                          break;
                        case m.keyCodes.home:
                          M.firstTile();
                          break;
                        case m.keyCodes.end:
                          M.lastTile();
                          break;
                      }
                      T.selectItem(T.allItems[T.getMenuIndex()]);
                    });
                  }
                },
                selectItem: function(O) {
                  var T = this;
                  if (!this.multiple)
                    this.setValue(this.returnObject ? O : this.getValue(O)), this.isMenuActive = !1;
                  else {
                    var M = (this.internalValue || []).slice(), L = this.findExistingIndex(O);
                    if (L !== -1 ? M.splice(L, 1) : M.push(O), this.setValue(M.map(function(D) {
                      return T.returnObject ? D : T.getValue(D);
                    })), this.hideSelected)
                      this.setMenuIndex(-1);
                    else {
                      var A = this.allItems.indexOf(O);
                      ~A && (this.$nextTick(function() {
                        return T.$refs.menu.getTiles();
                      }), setTimeout(function() {
                        return T.setMenuIndex(A);
                      }));
                    }
                  }
                },
                setMenuIndex: function(O) {
                  this.$refs.menu && (this.$refs.menu.listIndex = O);
                },
                setSelectedItems: function() {
                  var O, T, M = this, L = [], A = !this.multiple || !Array.isArray(this.internalValue) ? [this.internalValue] : this.internalValue, D = function(X) {
                    var rt = I.allItems.findIndex(function(et) {
                      return M.valueComparator(M.getValue(et), M.getValue(X));
                    });
                    rt > -1 && L.push(I.allItems[rt]);
                  }, I = this;
                  try {
                    for (var w = C(A), B = w.next(); !B.done; B = w.next()) {
                      var j = B.value;
                      D(j);
                    }
                  } catch (k) {
                    O = {
                      error: k
                    };
                  } finally {
                    try {
                      B && !B.done && (T = w.return) && T.call(w);
                    } finally {
                      if (O)
                        throw O.error;
                    }
                  }
                  this.selectedItems = L;
                },
                setValue: function(O) {
                  this.valueComparator(O, this.internalValue) || (this.internalValue = O, this.$emit("change", O));
                },
                isAppendInner: function(O) {
                  var T = this.$refs["append-inner"];
                  return T && (T === O || T.contains(O));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSelect/VSelectList.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VSelect/VSelectList.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VCheckbox/VSimpleCheckbox */
              "./src/components/VCheckbox/VSimpleCheckbox.ts"
            ), o = i(
              /*! ../VDivider */
              "./src/components/VDivider/index.ts"
            ), l = i(
              /*! ../VSubheader */
              "./src/components/VSubheader/index.ts"
            ), f = i(
              /*! ../VList */
              "./src/components/VList/index.ts"
            ), d = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), u = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), c = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, g.apply(this, arguments);
            };
            r.default = Object(p.default)(u.default, c.default).extend({
              name: "v-select-list",
              // https://github.com/vuejs/vue/issues/6872
              directives: {
                ripple: d.default
              },
              props: {
                action: Boolean,
                dense: Boolean,
                hideSelected: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                itemDisabled: {
                  type: [String, Array, Function],
                  default: "disabled"
                },
                itemText: {
                  type: [String, Array, Function],
                  default: "text"
                },
                itemValue: {
                  type: [String, Array, Function],
                  default: "value"
                },
                noDataText: String,
                noFilter: Boolean,
                searchInput: null,
                selectedItems: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              computed: {
                parsedItems: function() {
                  var v = this;
                  return this.selectedItems.map(function(y) {
                    return v.getValue(y);
                  });
                },
                tileActiveClass: function() {
                  return Object.keys(this.setTextColor(this.color).class || {}).join(" ");
                },
                staticNoDataTile: function() {
                  var v = {
                    attrs: {
                      role: void 0
                    },
                    on: {
                      mousedown: function(E) {
                        return E.preventDefault();
                      }
                      // Prevent onBlur from being called
                    }
                  };
                  return this.$createElement(f.VListItem, v, [this.genTileContent(this.noDataText)]);
                }
              },
              methods: {
                genAction: function(v, y) {
                  var E = this;
                  return this.$createElement(f.VListItemAction, [this.$createElement(a.default, {
                    props: {
                      color: this.color,
                      value: y,
                      ripple: !1
                    },
                    on: {
                      input: function() {
                        return E.$emit("select", v);
                      }
                    }
                  })]);
                },
                genDivider: function(v) {
                  return this.$createElement(o.default, {
                    props: v
                  });
                },
                genFilteredText: function(v) {
                  if (v = v || "", !this.searchInput || this.noFilter)
                    return v;
                  var y = this.getMaskedCharacters(v), E = y.start, C = y.middle, x = y.end;
                  return [E, this.genHighlight(C), x];
                },
                genHeader: function(v) {
                  return this.$createElement(l.default, {
                    props: v
                  }, v.header);
                },
                genHighlight: function(v) {
                  return this.$createElement("span", {
                    staticClass: "v-list-item__mask"
                  }, v);
                },
                getMaskedCharacters: function(v) {
                  var y = (this.searchInput || "").toString().toLocaleLowerCase(), E = v.toLocaleLowerCase().indexOf(y);
                  if (E < 0)
                    return {
                      start: v,
                      middle: "",
                      end: ""
                    };
                  var C = v.slice(0, E), x = v.slice(E, E + y.length), b = v.slice(E + y.length);
                  return {
                    start: C,
                    middle: x,
                    end: b
                  };
                },
                genTile: function(v) {
                  var y = this, E = v.item, C = v.index, x = v.disabled, b = x === void 0 ? null : x, P = v.value, O = P === void 0 ? !1 : P;
                  O || (O = this.hasItem(E)), E === Object(E) && (b = b !== null ? b : this.getDisabled(E));
                  var T = {
                    attrs: {
                      // Default behavior in list does not
                      // contain aria-selected by default
                      "aria-selected": String(O),
                      id: "list-item-" + this._uid + "-" + C,
                      role: "option"
                    },
                    on: {
                      mousedown: function(D) {
                        D.preventDefault();
                      },
                      click: function() {
                        return b || y.$emit("select", E);
                      }
                    },
                    props: {
                      activeClass: this.tileActiveClass,
                      disabled: b,
                      ripple: !0,
                      inputValue: O
                    }
                  };
                  if (!this.$scopedSlots.item)
                    return this.$createElement(f.VListItem, T, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(E, O) : null, this.genTileContent(E, C)]);
                  var M = this, L = this.$scopedSlots.item({
                    parent: M,
                    item: E,
                    attrs: g(g({}, T.attrs), T.props),
                    on: T.on
                  });
                  return this.needsTile(L) ? this.$createElement(f.VListItem, T, L) : L;
                },
                genTileContent: function(v, y) {
                  return this.$createElement(f.VListItemContent, [this.$createElement(f.VListItemTitle, [this.genFilteredText(this.getText(v))])]);
                },
                hasItem: function(v) {
                  return this.parsedItems.indexOf(this.getValue(v)) > -1;
                },
                needsTile: function(v) {
                  return v.length !== 1 || v[0].componentOptions == null || v[0].componentOptions.Ctor.options.name !== "v-list-item";
                },
                getDisabled: function(v) {
                  return !!Object(h.getPropertyFromItem)(v, this.itemDisabled, !1);
                },
                getText: function(v) {
                  return String(Object(h.getPropertyFromItem)(v, this.itemText, v));
                },
                getValue: function(v) {
                  return Object(h.getPropertyFromItem)(v, this.itemValue, this.getText(v));
                }
              },
              render: function() {
                for (var v = [], y = this.items.length, E = 0; E < y; E++) {
                  var C = this.items[E];
                  this.hideSelected && this.hasItem(C) || (C == null ? v.push(this.genTile({
                    item: C,
                    index: E
                  })) : C.header ? v.push(this.genHeader(C)) : C.divider ? v.push(this.genDivider(C)) : v.push(this.genTile({
                    item: C,
                    index: E
                  })));
                }
                return v.length || v.push(this.$slots["no-data"] || this.staticNoDataTile), this.$slots["prepend-item"] && v.unshift(this.$slots["prepend-item"]), this.$slots["append-item"] && v.push(this.$slots["append-item"]), this.$createElement(f.VList, {
                  staticClass: "v-select-list",
                  class: this.themeClasses,
                  attrs: {
                    role: "listbox",
                    tabindex: -1
                  },
                  props: {
                    dense: this.dense
                  }
                }, v);
              }
            });
          }
        ),
        /***/
        "./src/components/VSelect/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSelect/index.ts ***!
            \*****************************************/
          /*! exports provided: VSelect, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSelect */
              "./src/components/VSelect/VSelect.ts"
            );
            i.d(r, "VSelect", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSheet/VSheet.sass": (
          /*!*******************************************!*\
            !*** ./src/components/VSheet/VSheet.sass ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSheet/VSheet.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSheet/VSheet.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSheet.sass */
              "./src/components/VSheet/VSheet.sass"
            );
            var a = i(
              /*! ../../mixins/binds-attrs */
              "./src/mixins/binds-attrs/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), f = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), d = i(
              /*! ../../mixins/roundable */
              "./src/mixins/roundable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = Object(c.default)(a.default, o.default, l.default, f.default, d.default, u.default).extend({
              name: "v-sheet",
              props: {
                outlined: Boolean,
                shaped: Boolean,
                tag: {
                  type: String,
                  default: "div"
                }
              },
              computed: {
                classes: function() {
                  return h(h(h({
                    "v-sheet": !0,
                    "v-sheet--outlined": this.outlined,
                    "v-sheet--shaped": this.shaped
                  }, this.themeClasses), this.elevationClasses), this.roundedClasses);
                },
                styles: function() {
                  return this.measurableStyles;
                }
              },
              render: function(g) {
                var m = {
                  class: this.classes,
                  style: this.styles,
                  on: this.listeners$
                };
                return g(this.tag, this.setBackgroundColor(this.color, m), this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VSheet/index.ts": (
          /*!****************************************!*\
            !*** ./src/components/VSheet/index.ts ***!
            \****************************************/
          /*! exports provided: VSheet, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSheet */
              "./src/components/VSheet/VSheet.ts"
            );
            i.d(r, "VSheet", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/VSkeletonLoader.sass": (
          /*!*************************************************************!*\
            !*** ./src/components/VSkeletonLoader/VSkeletonLoader.sass ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/VSkeletonLoader.ts": (
          /*!***********************************************************!*\
            !*** ./src/components/VSkeletonLoader/VSkeletonLoader.ts ***!
            \***********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSkeletonLoader.sass */
              "./src/components/VSkeletonLoader/VSkeletonLoader.sass"
            );
            var a = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), o = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = function(h, p) {
              var g = typeof Symbol == "function" && h[Symbol.iterator];
              if (!g)
                return h;
              var m = g.call(h), v, y = [], E;
              try {
                for (; (p === void 0 || p-- > 0) && !(v = m.next()).done; )
                  y.push(v.value);
              } catch (C) {
                E = {
                  error: C
                };
              } finally {
                try {
                  v && !v.done && (g = m.return) && g.call(m);
                } finally {
                  if (E)
                    throw E.error;
                }
              }
              return y;
            };
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "VSkeletonLoader",
              props: {
                boilerplate: Boolean,
                loading: Boolean,
                loadingText: {
                  type: String,
                  default: "$vuetify.loading"
                },
                tile: Boolean,
                transition: String,
                type: String,
                types: {
                  type: Object,
                  default: function() {
                    return {};
                  }
                }
              },
              computed: {
                attrs: function() {
                  return this.isLoading ? u({
                    "aria-busy": this.boilerplate ? void 0 : !0,
                    "aria-live": this.boilerplate ? void 0 : "polite",
                    "aria-label": this.boilerplate ? void 0 : this.$vuetify.lang.t(this.loadingText),
                    role: this.boilerplate ? void 0 : "alert"
                  }, this.$attrs) : this.$attrs;
                },
                classes: function() {
                  return u(u({
                    "v-skeleton-loader--boilerplate": this.boilerplate,
                    "v-skeleton-loader--is-loading": this.isLoading,
                    "v-skeleton-loader--tile": this.tile
                  }, this.themeClasses), this.elevationClasses);
                },
                isLoading: function() {
                  return !("default" in this.$scopedSlots) || this.loading;
                },
                rootTypes: function() {
                  return u({
                    actions: "button@2",
                    article: "heading, paragraph",
                    avatar: "avatar",
                    button: "button",
                    card: "image, card-heading",
                    "card-avatar": "image, list-item-avatar",
                    "card-heading": "heading",
                    chip: "chip",
                    "date-picker": "list-item, card-heading, divider, date-picker-options, date-picker-days, actions",
                    "date-picker-options": "text, avatar@2",
                    "date-picker-days": "avatar@28",
                    heading: "heading",
                    image: "image",
                    "list-item": "text",
                    "list-item-avatar": "avatar, text",
                    "list-item-two-line": "sentences",
                    "list-item-avatar-two-line": "avatar, sentences",
                    "list-item-three-line": "paragraph",
                    "list-item-avatar-three-line": "avatar, paragraph",
                    paragraph: "text@3",
                    sentences: "text@2",
                    table: "table-heading, table-thead, table-tbody, table-tfoot",
                    "table-heading": "heading, text",
                    "table-thead": "heading@6",
                    "table-tbody": "table-row-divider@6",
                    "table-row-divider": "table-row, divider",
                    "table-row": "table-cell@6",
                    "table-cell": "text",
                    "table-tfoot": "text@2, avatar@2",
                    text: "text"
                  }, this.types);
                }
              },
              methods: {
                genBone: function(p, g) {
                  return this.$createElement("div", {
                    staticClass: "v-skeleton-loader__" + p + " v-skeleton-loader__bone"
                  }, g);
                },
                genBones: function(p) {
                  var g = this, m = c(p.split("@"), 2), v = m[0], y = m[1], E = function() {
                    return g.genStructure(v);
                  };
                  return Array.from({
                    length: y
                  }).map(E);
                },
                // Fix type when this is merged
                // https://github.com/microsoft/TypeScript/pull/33050
                genStructure: function(p) {
                  var g = [];
                  p = p || this.type || "";
                  var m = this.rootTypes[p] || "";
                  if (p !== m) {
                    if (p.indexOf(",") > -1)
                      return this.mapBones(p);
                    if (p.indexOf("@") > -1)
                      return this.genBones(p);
                    m.indexOf(",") > -1 ? g = this.mapBones(m) : m.indexOf("@") > -1 ? g = this.genBones(m) : m && g.push(this.genStructure(m));
                  }
                  return [this.genBone(p, g)];
                },
                genSkeleton: function() {
                  var p = [];
                  return this.isLoading ? p.push(this.genStructure()) : p.push(Object(d.getSlot)(this)), this.transition ? this.$createElement("transition", {
                    props: {
                      name: this.transition
                    },
                    // Only show transition when
                    // content has been loaded
                    on: {
                      afterEnter: this.resetStyles,
                      beforeEnter: this.onBeforeEnter,
                      beforeLeave: this.onBeforeLeave,
                      leaveCancelled: this.resetStyles
                    }
                  }, p) : p;
                },
                mapBones: function(p) {
                  return p.replace(/\s/g, "").split(",").map(this.genStructure);
                },
                onBeforeEnter: function(p) {
                  this.resetStyles(p), this.isLoading && (p._initialStyle = {
                    display: p.style.display,
                    transition: p.style.transition
                  }, p.style.setProperty("transition", "none", "important"));
                },
                onBeforeLeave: function(p) {
                  p.style.setProperty("display", "none", "important");
                },
                resetStyles: function(p) {
                  p._initialStyle && (p.style.display = p._initialStyle.display || "", p.style.transition = p._initialStyle.transition, delete p._initialStyle);
                }
              },
              render: function(p) {
                return p("div", {
                  staticClass: "v-skeleton-loader",
                  attrs: this.attrs,
                  on: this.$listeners,
                  class: this.classes,
                  style: this.isLoading ? this.measurableStyles : void 0
                }, [this.genSkeleton()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSkeletonLoader/index.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSkeletonLoader/index.ts ***!
            \*************************************************/
          /*! exports provided: VSkeletonLoader, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSkeletonLoader */
              "./src/components/VSkeletonLoader/VSkeletonLoader.ts"
            );
            i.d(r, "VSkeletonLoader", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideGroup.sass": (
          /*!*****************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideGroup.sass ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideGroup.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideGroup.ts ***!
            \***************************************************/
          /*! exports provided: calculateUpdatedOffset, calculateCenteredOffset, BaseSlideGroup, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "calculateUpdatedOffset", function() {
              return v;
            }), i.d(r, "calculateCenteredOffset", function() {
              return y;
            }), i.d(r, "BaseSlideGroup", function() {
              return E;
            }), i(
              /*! ./VSlideGroup.sass */
              "./src/components/VSlideGroup/VSlideGroup.sass"
            );
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), f = i(
              /*! ../../mixins/mobile */
              "./src/mixins/mobile/index.ts"
            ), d = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), u = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = function() {
              return p = Object.assign || function(C) {
                for (var x, b = 1, P = arguments.length; b < P; b++) {
                  x = arguments[b];
                  for (var O in x)
                    Object.prototype.hasOwnProperty.call(x, O) && (C[O] = x[O]);
                }
                return C;
              }, p.apply(this, arguments);
            }, g = function(C) {
              var x = typeof Symbol == "function" && Symbol.iterator, b = x && C[x], P = 0;
              if (b)
                return b.call(C);
              if (C && typeof C.length == "number")
                return {
                  next: function() {
                    return C && P >= C.length && (C = void 0), {
                      value: C && C[P++],
                      done: !C
                    };
                  }
                };
              throw new TypeError(x ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            function m(C) {
              var x = 0.501, b = Math.abs(C);
              return Math.sign(C) * (b / ((1 / x - 2) * (1 - b) + 1));
            }
            function v(C, x, b, P) {
              var O = C.clientWidth, T = b ? x.content - C.offsetLeft - O : C.offsetLeft;
              b && (P = -P);
              var M = x.wrapper + P, L = O + T, A = O * 0.4;
              return T <= P ? P = Math.max(T - A, 0) : M <= L && (P = Math.min(P - (M - L - A), x.content - x.wrapper)), b ? -P : P;
            }
            function y(C, x, b) {
              var P = C.offsetLeft, O = C.clientWidth;
              if (b) {
                var T = x.content - P - O / 2 - x.wrapper / 2;
                return -Math.min(x.content - x.wrapper, Math.max(0, T));
              } else {
                var T = P + O / 2 - x.wrapper / 2;
                return Math.min(x.content - x.wrapper, Math.max(0, T));
              }
            }
            var E = Object(c.default)(l.BaseItemGroup, f.default).extend({
              name: "base-slide-group",
              directives: {
                Resize: d.default,
                Touch: u.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: "v-slide-item--active"
                },
                centerActive: Boolean,
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                showArrows: {
                  type: [Boolean, String],
                  validator: function(x) {
                    return typeof x == "boolean" || ["always", "never", "desktop", "mobile"].includes(x);
                  }
                }
              },
              data: function() {
                return {
                  isOverflowing: !1,
                  resizeTimeout: 0,
                  startX: 0,
                  isSwipingHorizontal: !1,
                  isSwiping: !1,
                  scrollOffset: 0,
                  widths: {
                    content: 0,
                    wrapper: 0
                  }
                };
              },
              computed: {
                canTouch: function() {
                  return typeof window < "u";
                },
                __cachedNext: function() {
                  return this.genTransition("next");
                },
                __cachedPrev: function() {
                  return this.genTransition("prev");
                },
                classes: function() {
                  return p(p({}, l.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-slide-group": !0,
                    "v-slide-group--has-affixes": this.hasAffixes,
                    "v-slide-group--is-overflowing": this.isOverflowing
                  });
                },
                hasAffixes: function() {
                  switch (this.showArrows) {
                    case "always":
                      return !0;
                    case "desktop":
                      return !this.isMobile;
                    case !0:
                      return this.isOverflowing || Math.abs(this.scrollOffset) > 0;
                    case "mobile":
                      return this.isMobile || this.isOverflowing || Math.abs(this.scrollOffset) > 0;
                    case "never":
                      return !1;
                    default:
                      return !this.isMobile && (this.isOverflowing || Math.abs(this.scrollOffset) > 0);
                  }
                },
                hasNext: function() {
                  if (!this.hasAffixes)
                    return !1;
                  var x = this.widths, b = x.content, P = x.wrapper;
                  return b > Math.abs(this.scrollOffset) + P;
                },
                hasPrev: function() {
                  return this.hasAffixes && this.scrollOffset !== 0;
                }
              },
              watch: {
                internalValue: "setWidths",
                // When overflow changes, the arrows alter
                // the widths of the content and wrapper
                // and need to be recalculated
                isOverflowing: "setWidths",
                scrollOffset: function(x) {
                  this.$vuetify.rtl && (x = -x);
                  var b = x <= 0 ? m(-x) : x > this.widths.content - this.widths.wrapper ? -(this.widths.content - this.widths.wrapper) + m(this.widths.content - this.widths.wrapper - x) : -x;
                  this.$vuetify.rtl && (b = -b), this.$refs.content.style.transform = "translateX(" + b + "px)";
                }
              },
              mounted: function() {
                var x = this;
                if (typeof ResizeObserver < "u") {
                  var b = new ResizeObserver(function() {
                    x.onResize();
                  });
                  b.observe(this.$el), b.observe(this.$refs.content), this.$on("hook:destroyed", function() {
                    b.disconnect();
                  });
                } else {
                  var P = 0;
                  this.$on("hook:beforeUpdate", function() {
                    var O;
                    P = (((O = x.$refs.content) === null || O === void 0 ? void 0 : O.children) || []).length;
                  }), this.$on("hook:updated", function() {
                    var O;
                    P !== (((O = x.$refs.content) === null || O === void 0 ? void 0 : O.children) || []).length && x.setWidths();
                  });
                }
              },
              methods: {
                onScroll: function() {
                  this.$refs.wrapper.scrollLeft = 0;
                },
                onFocusin: function(x) {
                  var b, P, O, T;
                  if (this.isOverflowing)
                    try {
                      for (var M = g(Object(h.composedPath)(x)), L = M.next(); !L.done; L = M.next()) {
                        var A = L.value;
                        try {
                          for (var D = (O = void 0, g(this.items)), I = D.next(); !I.done; I = D.next()) {
                            var w = I.value;
                            if (w.$el === A) {
                              this.scrollOffset = v(w.$el, this.widths, this.$vuetify.rtl, this.scrollOffset);
                              return;
                            }
                          }
                        } catch (B) {
                          O = {
                            error: B
                          };
                        } finally {
                          try {
                            I && !I.done && (T = D.return) && T.call(D);
                          } finally {
                            if (O)
                              throw O.error;
                          }
                        }
                      }
                    } catch (B) {
                      b = {
                        error: B
                      };
                    } finally {
                      try {
                        L && !L.done && (P = M.return) && P.call(M);
                      } finally {
                        if (b)
                          throw b.error;
                      }
                    }
                },
                // Always generate next for scrollable hint
                genNext: function() {
                  var x = this, b = this.$scopedSlots.next ? this.$scopedSlots.next({}) : this.$slots.next || this.__cachedNext;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__next",
                    class: {
                      "v-slide-group__next--disabled": !this.hasNext
                    },
                    on: {
                      click: function() {
                        return x.onAffixClick("next");
                      }
                    },
                    key: "next"
                  }, [b]);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__content",
                    ref: "content",
                    on: {
                      focusin: this.onFocusin
                    }
                  }, this.$slots.default);
                },
                genData: function() {
                  return {
                    class: this.classes,
                    directives: [{
                      name: "resize",
                      value: this.onResize
                    }]
                  };
                },
                genIcon: function(x) {
                  var b = x;
                  this.$vuetify.rtl && x === "prev" ? b = "next" : this.$vuetify.rtl && x === "next" && (b = "prev");
                  var P = "" + x[0].toUpperCase() + x.slice(1), O = this["has" + P];
                  return !this.showArrows && !O ? null : this.$createElement(a.default, {
                    props: {
                      disabled: !O
                    }
                  }, this[b + "Icon"]);
                },
                // Always generate prev for scrollable hint
                genPrev: function() {
                  var x = this, b = this.$scopedSlots.prev ? this.$scopedSlots.prev({}) : this.$slots.prev || this.__cachedPrev;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__prev",
                    class: {
                      "v-slide-group__prev--disabled": !this.hasPrev
                    },
                    on: {
                      click: function() {
                        return x.onAffixClick("prev");
                      }
                    },
                    key: "prev"
                  }, [b]);
                },
                genTransition: function(x) {
                  return this.$createElement(o.VFadeTransition, [this.genIcon(x)]);
                },
                genWrapper: function() {
                  var x = this;
                  return this.$createElement("div", {
                    staticClass: "v-slide-group__wrapper",
                    directives: [{
                      name: "touch",
                      value: {
                        start: function(P) {
                          return x.overflowCheck(P, x.onTouchStart);
                        },
                        move: function(P) {
                          return x.overflowCheck(P, x.onTouchMove);
                        },
                        end: function(P) {
                          return x.overflowCheck(P, x.onTouchEnd);
                        }
                      }
                    }],
                    ref: "wrapper",
                    on: {
                      scroll: this.onScroll
                    }
                  }, [this.genContent()]);
                },
                calculateNewOffset: function(x, b, P, O) {
                  var T = P ? -1 : 1, M = T * O + (x === "prev" ? -1 : 1) * b.wrapper;
                  return T * Math.max(Math.min(M, b.content - b.wrapper), 0);
                },
                onAffixClick: function(x) {
                  this.$emit("click:" + x), this.scrollTo(x);
                },
                onResize: function() {
                  this._isDestroyed || this.setWidths();
                },
                onTouchStart: function(x) {
                  var b = this.$refs.content;
                  this.startX = this.scrollOffset + x.touchstartX, b.style.setProperty("transition", "none"), b.style.setProperty("willChange", "transform");
                },
                onTouchMove: function(x) {
                  if (this.canTouch) {
                    if (!this.isSwiping) {
                      var b = x.touchmoveX - x.touchstartX, P = x.touchmoveY - x.touchstartY;
                      this.isSwipingHorizontal = Math.abs(b) > Math.abs(P), this.isSwiping = !0;
                    }
                    this.isSwipingHorizontal && (this.scrollOffset = this.startX - x.touchmoveX, document.documentElement.style.overflowY = "hidden");
                  }
                },
                onTouchEnd: function() {
                  if (this.canTouch) {
                    var x = this.$refs, b = x.content, P = x.wrapper, O = b.clientWidth - P.clientWidth;
                    b.style.setProperty("transition", null), b.style.setProperty("willChange", null), this.$vuetify.rtl ? this.scrollOffset > 0 || !this.isOverflowing ? this.scrollOffset = 0 : this.scrollOffset <= -O && (this.scrollOffset = -O) : this.scrollOffset < 0 || !this.isOverflowing ? this.scrollOffset = 0 : this.scrollOffset >= O && (this.scrollOffset = O), this.isSwiping = !1, document.documentElement.style.removeProperty("overflow-y");
                  }
                },
                overflowCheck: function(x, b) {
                  x.stopPropagation(), this.isOverflowing && b(x);
                },
                scrollIntoView: function() {
                  if (!this.selectedItem && this.items.length) {
                    var x = this.items[this.items.length - 1].$el.getBoundingClientRect(), b = this.$refs.wrapper.getBoundingClientRect();
                    (this.$vuetify.rtl && b.right < x.right || !this.$vuetify.rtl && b.left > x.left) && this.scrollTo("prev");
                  }
                  this.selectedItem && (this.selectedIndex === 0 || !this.centerActive && !this.isOverflowing ? this.scrollOffset = 0 : this.centerActive ? this.scrollOffset = y(this.selectedItem.$el, this.widths, this.$vuetify.rtl) : this.isOverflowing && (this.scrollOffset = v(this.selectedItem.$el, this.widths, this.$vuetify.rtl, this.scrollOffset)));
                },
                scrollTo: function(x) {
                  this.scrollOffset = this.calculateNewOffset(x, {
                    // Force reflow
                    content: this.$refs.content ? this.$refs.content.clientWidth : 0,
                    wrapper: this.$refs.wrapper ? this.$refs.wrapper.clientWidth : 0
                  }, this.$vuetify.rtl, this.scrollOffset);
                },
                setWidths: function() {
                  var x = this;
                  window.requestAnimationFrame(function() {
                    if (!x._isDestroyed) {
                      var b = x.$refs, P = b.content, O = b.wrapper;
                      x.widths = {
                        content: P ? P.clientWidth : 0,
                        wrapper: O ? O.clientWidth : 0
                      }, x.isOverflowing = x.widths.wrapper + 1 < x.widths.content, x.scrollIntoView();
                    }
                  });
                }
              },
              render: function(x) {
                return x("div", this.genData(), [this.genPrev(), this.genWrapper(), this.genNext()]);
              }
            });
            r.default = E.extend({
              name: "v-slide-group",
              provide: function() {
                return {
                  slideGroup: this
                };
              }
            });
          }
        ),
        /***/
        "./src/components/VSlideGroup/VSlideItem.ts": (
          /*!**************************************************!*\
            !*** ./src/components/VSlideGroup/VSlideItem.ts ***!
            \**************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VItemGroup/VItem */
              "./src/components/VItemGroup/VItem.ts"
            ), o = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(l.default)(
              a.BaseItem,
              Object(o.factory)("slideGroup")
              /* @vue/component */
            ).extend({
              name: "v-slide-item"
            });
          }
        ),
        /***/
        "./src/components/VSlideGroup/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VSlideGroup/index.ts ***!
            \*********************************************/
          /*! exports provided: VSlideGroup, VSlideItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            );
            i.d(r, "VSlideGroup", function() {
              return a.default;
            });
            var o = i(
              /*! ./VSlideItem */
              "./src/components/VSlideGroup/VSlideItem.ts"
            );
            i.d(r, "VSlideItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VSlideGroup: a.default,
                VSlideItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VSlider/VSlider.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSlider/VSlider.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSlider/VSlider.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSlider/VSlider.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSlider.sass */
              "./src/components/VSlider/VSlider.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), d = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = function() {
              return h = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, h.apply(this, arguments);
            };
            r.default = Object(l.default)(
              a.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-slider",
              directives: {
                ClickOutside: d.default
              },
              mixins: [f.default],
              props: {
                disabled: Boolean,
                inverseLabel: Boolean,
                max: {
                  type: [Number, String],
                  default: 100
                },
                min: {
                  type: [Number, String],
                  default: 0
                },
                step: {
                  type: [Number, String],
                  default: 1
                },
                thumbColor: String,
                thumbLabel: {
                  type: [Boolean, String],
                  default: void 0,
                  validator: function(g) {
                    return typeof g == "boolean" || g === "always";
                  }
                },
                thumbSize: {
                  type: [Number, String],
                  default: 32
                },
                tickLabels: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                ticks: {
                  type: [Boolean, String],
                  default: !1,
                  validator: function(g) {
                    return typeof g == "boolean" || g === "always";
                  }
                },
                tickSize: {
                  type: [Number, String],
                  default: 2
                },
                trackColor: String,
                trackFillColor: String,
                value: [Number, String],
                vertical: Boolean
              },
              data: function() {
                return {
                  app: null,
                  oldValue: null,
                  thumbPressed: !1,
                  mouseTimeout: -1,
                  isFocused: !1,
                  isActive: !1,
                  noClick: !1,
                  startOffset: 0
                };
              },
              computed: {
                classes: function() {
                  return h(h({}, a.default.options.computed.classes.call(this)), {
                    "v-input__slider": !0,
                    "v-input__slider--vertical": this.vertical,
                    "v-input__slider--inverse-label": this.inverseLabel
                  });
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(g) {
                    g = isNaN(g) ? this.minValue : g;
                    var m = this.roundValue(Math.min(Math.max(g, this.minValue), this.maxValue));
                    m !== this.lazyValue && (this.lazyValue = m, this.$emit("input", m));
                  }
                },
                trackTransition: function() {
                  return this.thumbPressed ? this.showTicks || this.stepNumeric ? "0.1s cubic-bezier(0.25, 0.8, 0.5, 1)" : "none" : "";
                },
                minValue: function() {
                  return parseFloat(this.min);
                },
                maxValue: function() {
                  return parseFloat(this.max);
                },
                stepNumeric: function() {
                  return this.step > 0 ? parseFloat(this.step) : 0;
                },
                inputWidth: function() {
                  var g = (this.roundValue(this.internalValue) - this.minValue) / (this.maxValue - this.minValue) * 100;
                  return isNaN(g) ? 0 : g;
                },
                trackFillStyles: function() {
                  var g, m = this.vertical ? "bottom" : "left", v = this.vertical ? "top" : "right", y = this.vertical ? "height" : "width", E = this.$vuetify.rtl ? "auto" : "0", C = this.$vuetify.rtl ? "0" : "auto", x = this.isDisabled ? "calc(" + this.inputWidth + "% - 10px)" : this.inputWidth + "%";
                  return g = {
                    transition: this.trackTransition
                  }, g[m] = E, g[v] = C, g[y] = x, g;
                },
                trackStyles: function() {
                  var g, m = this.vertical ? this.$vuetify.rtl ? "bottom" : "top" : this.$vuetify.rtl ? "left" : "right", v = this.vertical ? "height" : "width", y = "0px", E = this.isDisabled ? "calc(" + (100 - this.inputWidth) + "% - 10px)" : "calc(" + (100 - this.inputWidth) + "%)";
                  return g = {
                    transition: this.trackTransition
                  }, g[m] = y, g[v] = E, g;
                },
                showTicks: function() {
                  return this.tickLabels.length > 0 || !!(!this.isDisabled && this.stepNumeric && this.ticks);
                },
                numTicks: function() {
                  return Math.ceil((this.maxValue - this.minValue) / this.stepNumeric);
                },
                showThumbLabel: function() {
                  return !this.isDisabled && !!(this.thumbLabel || this.$scopedSlots["thumb-label"]);
                },
                computedTrackColor: function() {
                  if (!this.isDisabled)
                    return this.trackColor ? this.trackColor : this.isDark ? this.validationState : this.validationState || "primary lighten-3";
                },
                computedTrackFillColor: function() {
                  if (!this.isDisabled)
                    return this.trackFillColor ? this.trackFillColor : this.validationState || this.computedColor;
                },
                computedThumbColor: function() {
                  return this.thumbColor ? this.thumbColor : this.validationState || this.computedColor;
                }
              },
              watch: {
                min: function(g) {
                  var m = parseFloat(g);
                  m > this.internalValue && this.$emit("input", m);
                },
                max: function(g) {
                  var m = parseFloat(g);
                  m < this.internalValue && this.$emit("input", m);
                },
                value: {
                  handler: function(g) {
                    this.internalValue = g;
                  },
                  immediate: !0
                }
              },
              mounted: function() {
                this.app = document.querySelector("[data-app]") || Object(c.consoleWarn)("Missing v-app or a non-body wrapping element with the [data-app] attribute", this);
              },
              methods: {
                genDefaultSlot: function() {
                  var g = [this.genLabel()], m = this.genSlider();
                  return this.inverseLabel ? g.unshift(m) : g.push(m), g.push(this.genProgress()), g;
                },
                genSlider: function() {
                  return this.$createElement("div", {
                    class: h({
                      "v-slider": !0,
                      "v-slider--horizontal": !this.vertical,
                      "v-slider--vertical": this.vertical,
                      "v-slider--focused": this.isFocused,
                      "v-slider--active": this.isActive,
                      "v-slider--disabled": this.isDisabled,
                      "v-slider--readonly": this.isReadonly
                    }, this.themeClasses),
                    directives: [{
                      name: "click-outside",
                      value: this.onBlur
                    }],
                    on: {
                      click: this.onSliderClick,
                      mousedown: this.onSliderMouseDown,
                      touchstart: this.onSliderMouseDown
                    }
                  }, this.genChildren());
                },
                genChildren: function() {
                  return [this.genInput(), this.genTrackContainer(), this.genSteps(), this.genThumbContainer(this.internalValue, this.inputWidth, this.isActive, this.isFocused, this.onFocus, this.onBlur)];
                },
                genInput: function() {
                  return this.$createElement("input", {
                    attrs: h({
                      value: this.internalValue,
                      id: this.computedId,
                      disabled: !0,
                      readonly: !0,
                      tabindex: -1
                    }, this.$attrs)
                    // on: this.genListeners(), // TODO: do we need to attach the listeners to input?
                  });
                },
                genTrackContainer: function() {
                  var g = [this.$createElement("div", this.setBackgroundColor(this.computedTrackColor, {
                    staticClass: "v-slider__track-background",
                    style: this.trackStyles
                  })), this.$createElement("div", this.setBackgroundColor(this.computedTrackFillColor, {
                    staticClass: "v-slider__track-fill",
                    style: this.trackFillStyles
                  }))];
                  return this.$createElement("div", {
                    staticClass: "v-slider__track-container",
                    ref: "track"
                  }, g);
                },
                genSteps: function() {
                  var g = this;
                  if (!this.step || !this.showTicks)
                    return null;
                  var m = parseFloat(this.tickSize), v = Object(u.createRange)(this.numTicks + 1), y = this.vertical ? "bottom" : this.$vuetify.rtl ? "right" : "left", E = this.vertical ? this.$vuetify.rtl ? "left" : "right" : "top";
                  this.vertical && v.reverse();
                  var C = v.map(function(x) {
                    var b, P = [];
                    g.tickLabels[x] && P.push(g.$createElement("div", {
                      staticClass: "v-slider__tick-label"
                    }, g.tickLabels[x]));
                    var O = x * (100 / g.numTicks), T = g.$vuetify.rtl ? 100 - g.inputWidth < O : O < g.inputWidth;
                    return g.$createElement("span", {
                      key: x,
                      staticClass: "v-slider__tick",
                      class: {
                        "v-slider__tick--filled": T
                      },
                      style: (b = {
                        width: m + "px",
                        height: m + "px"
                      }, b[y] = "calc(" + O + "% - " + m / 2 + "px)", b[E] = "calc(50% - " + m / 2 + "px)", b)
                    }, P);
                  });
                  return this.$createElement("div", {
                    staticClass: "v-slider__ticks-container",
                    class: {
                      "v-slider__ticks-container--always-show": this.ticks === "always" || this.tickLabels.length > 0
                    }
                  }, C);
                },
                genThumbContainer: function(g, m, v, y, E, C, x) {
                  x === void 0 && (x = "thumb");
                  var b = [this.genThumb()], P = this.genThumbLabelContent(g);
                  return this.showThumbLabel && b.push(this.genThumbLabel(P)), this.$createElement("div", this.setTextColor(this.computedThumbColor, {
                    ref: x,
                    key: x,
                    staticClass: "v-slider__thumb-container",
                    class: {
                      "v-slider__thumb-container--active": v,
                      "v-slider__thumb-container--focused": y,
                      "v-slider__thumb-container--show-label": this.showThumbLabel
                    },
                    style: this.getThumbContainerStyles(m),
                    attrs: {
                      role: "slider",
                      tabindex: this.isDisabled ? -1 : this.$attrs.tabindex ? this.$attrs.tabindex : 0,
                      "aria-label": this.$attrs["aria-label"] || this.label,
                      "aria-valuemin": this.min,
                      "aria-valuemax": this.max,
                      "aria-valuenow": this.internalValue,
                      "aria-readonly": String(this.isReadonly),
                      "aria-orientation": this.vertical ? "vertical" : "horizontal"
                    },
                    on: {
                      focus: E,
                      blur: C,
                      keydown: this.onKeyDown
                    }
                  }), b);
                },
                genThumbLabelContent: function(g) {
                  return this.$scopedSlots["thumb-label"] ? this.$scopedSlots["thumb-label"]({
                    value: g
                  }) : [this.$createElement("span", [String(g)])];
                },
                genThumbLabel: function(g) {
                  var m = Object(u.convertToUnit)(this.thumbSize), v = this.vertical ? "translateY(20%) translateY(" + (Number(this.thumbSize) / 3 - 1) + "px) translateX(55%) rotate(135deg)" : "translateY(-20%) translateY(-12px) translateX(-50%) rotate(45deg)";
                  return this.$createElement(o.VScaleTransition, {
                    props: {
                      origin: "bottom center"
                    }
                  }, [this.$createElement("div", {
                    staticClass: "v-slider__thumb-label-container",
                    directives: [{
                      name: "show",
                      value: this.isFocused || this.isActive || this.thumbLabel === "always"
                    }]
                  }, [this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
                    staticClass: "v-slider__thumb-label",
                    style: {
                      height: m,
                      width: m,
                      transform: v
                    }
                  }), [this.$createElement("div", g)])])]);
                },
                genThumb: function() {
                  return this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
                    staticClass: "v-slider__thumb"
                  }));
                },
                getThumbContainerStyles: function(g) {
                  var m, v = this.vertical ? "top" : "left", y = this.$vuetify.rtl ? 100 - g : g;
                  return y = this.vertical ? 100 - y : y, m = {
                    transition: this.trackTransition
                  }, m[v] = y + "%", m;
                },
                onSliderMouseDown: function(g) {
                  var m = this, v;
                  if (g.preventDefault(), this.oldValue = this.internalValue, this.isActive = !0, !((v = g.target) === null || v === void 0) && v.matches(".v-slider__thumb-container, .v-slider__thumb-container *")) {
                    this.thumbPressed = !0;
                    var y = g.target.getBoundingClientRect(), E = "touches" in g ? g.touches[0] : g;
                    this.startOffset = this.vertical ? E.clientY - (y.top + y.height / 2) : E.clientX - (y.left + y.width / 2);
                  } else
                    this.startOffset = 0, window.clearTimeout(this.mouseTimeout), this.mouseTimeout = window.setTimeout(function() {
                      m.thumbPressed = !0;
                    }, 300);
                  var C = u.passiveSupported ? {
                    passive: !0,
                    capture: !0
                  } : !0, x = u.passiveSupported ? {
                    passive: !0
                  } : !1, b = "touches" in g;
                  this.onMouseMove(g), this.app.addEventListener(b ? "touchmove" : "mousemove", this.onMouseMove, x), Object(u.addOnceEventListener)(this.app, b ? "touchend" : "mouseup", this.onSliderMouseUp, C), this.$emit("start", this.internalValue);
                },
                onSliderMouseUp: function(g) {
                  g.stopPropagation(), window.clearTimeout(this.mouseTimeout), this.thumbPressed = !1;
                  var m = u.passiveSupported ? {
                    passive: !0
                  } : !1;
                  this.app.removeEventListener("touchmove", this.onMouseMove, m), this.app.removeEventListener("mousemove", this.onMouseMove, m), this.$emit("mouseup", g), this.$emit("end", this.internalValue), Object(u.deepEqual)(this.oldValue, this.internalValue) || (this.$emit("change", this.internalValue), this.noClick = !0), this.isActive = !1;
                },
                onMouseMove: function(g) {
                  g.type === "mousemove" && (this.thumbPressed = !0), this.internalValue = this.parseMouseMove(g);
                },
                onKeyDown: function(g) {
                  if (this.isInteractive) {
                    var m = this.parseKeyDown(g, this.internalValue);
                    m == null || m < this.minValue || m > this.maxValue || (this.internalValue = m, this.$emit("change", m));
                  }
                },
                onSliderClick: function(g) {
                  if (this.noClick) {
                    this.noClick = !1;
                    return;
                  }
                  var m = this.$refs.thumb;
                  m.focus(), this.onMouseMove(g), this.$emit("change", this.internalValue);
                },
                onBlur: function(g) {
                  this.isFocused = !1, this.$emit("blur", g);
                },
                onFocus: function(g) {
                  this.isFocused = !0, this.$emit("focus", g);
                },
                parseMouseMove: function(g) {
                  var m = this.vertical ? "top" : "left", v = this.vertical ? "height" : "width", y = this.vertical ? "clientY" : "clientX", E = this.$refs.track.getBoundingClientRect(), C = m, x = E[C], b = v, P = E[b], O = "touches" in g ? g.touches[0][y] : g[y], T = Math.min(Math.max((O - x - this.startOffset) / P, 0), 1) || 0;
                  return this.vertical && (T = 1 - T), this.$vuetify.rtl && (T = 1 - T), parseFloat(this.min) + T * (this.maxValue - this.minValue);
                },
                parseKeyDown: function(g, m) {
                  if (this.isInteractive) {
                    var v = u.keyCodes.pageup, y = u.keyCodes.pagedown, E = u.keyCodes.end, C = u.keyCodes.home, x = u.keyCodes.left, b = u.keyCodes.right, P = u.keyCodes.down, O = u.keyCodes.up;
                    if ([v, y, E, C, x, b, P, O].includes(g.keyCode)) {
                      g.preventDefault();
                      var T = this.stepNumeric || 1, M = (this.maxValue - this.minValue) / T;
                      if ([x, b, P, O].includes(g.keyCode)) {
                        var L = this.$vuetify.rtl ? [x, O] : [b, O], A = L.includes(g.keyCode) ? 1 : -1, D = g.shiftKey ? 3 : g.ctrlKey ? 2 : 1;
                        m = m + A * T * D;
                      } else if (g.keyCode === C)
                        m = this.minValue;
                      else if (g.keyCode === E)
                        m = this.maxValue;
                      else {
                        var A = g.keyCode === y ? 1 : -1;
                        m = m - A * T * (M > 100 ? M / 10 : 10);
                      }
                      return m;
                    }
                  }
                },
                roundValue: function(g) {
                  if (!this.stepNumeric)
                    return g;
                  var m = this.step.toString().trim(), v = m.indexOf(".") > -1 ? m.length - m.indexOf(".") - 1 : 0, y = this.minValue % this.stepNumeric, E = Math.round((g - y) / this.stepNumeric) * this.stepNumeric + y;
                  return parseFloat(Math.min(E, this.maxValue).toFixed(v));
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSlider/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSlider/index.ts ***!
            \*****************************************/
          /*! exports provided: VSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSlider */
              "./src/components/VSlider/VSlider.ts"
            );
            i.d(r, "VSlider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSnackbar/VSnackbar.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VSnackbar/VSnackbar.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSnackbar/VSnackbar.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VSnackbar/VSnackbar.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSnackbar.sass */
              "./src/components/VSnackbar/VSnackbar.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), d = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), c = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), h = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            r.default = Object(u.default)(
              a.default,
              o.default,
              f.default,
              Object(d.factory)(["absolute", "bottom", "left", "right", "top"])
              /* @vue/component */
            ).extend({
              name: "v-snackbar",
              props: {
                app: Boolean,
                centered: Boolean,
                contentClass: {
                  type: String,
                  default: ""
                },
                multiLine: Boolean,
                text: Boolean,
                timeout: {
                  type: [Number, String],
                  default: 5e3
                },
                transition: {
                  type: [Boolean, String],
                  default: "v-snack-transition",
                  validator: function(g) {
                    return typeof g == "string" || g === !1;
                  }
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  activeTimeout: -1
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-snack--absolute": this.absolute,
                    "v-snack--active": this.isActive,
                    "v-snack--bottom": this.bottom || !this.top,
                    "v-snack--centered": this.centered,
                    "v-snack--has-background": this.hasBackground,
                    "v-snack--left": this.left,
                    "v-snack--multi-line": this.multiLine && !this.vertical,
                    "v-snack--right": this.right,
                    "v-snack--text": this.text,
                    "v-snack--top": this.top,
                    "v-snack--vertical": this.vertical
                  };
                },
                // Text and outlined styles both
                // use transparent backgrounds
                hasBackground: function() {
                  return !this.text && !this.outlined;
                },
                // Snackbar is dark by default
                // override themeable logic.
                isDark: function() {
                  return this.hasBackground ? !this.light : l.default.options.computed.isDark.call(this);
                },
                styles: function() {
                  if (this.absolute || !this.app)
                    return {};
                  var g = this.$vuetify.application, m = g.bar, v = g.bottom, y = g.footer, E = g.insetFooter, C = g.left, x = g.right, b = g.top;
                  return {
                    paddingBottom: Object(c.convertToUnit)(v + y + E),
                    paddingLeft: Object(c.convertToUnit)(C),
                    paddingRight: Object(c.convertToUnit)(x),
                    paddingTop: Object(c.convertToUnit)(m + b)
                  };
                }
              },
              watch: {
                isActive: "setTimeout",
                timeout: "setTimeout"
              },
              mounted: function() {
                this.isActive && this.setTimeout();
              },
              created: function() {
                this.$attrs.hasOwnProperty("auto-height") && Object(h.removed)("auto-height", this), this.timeout == 0 && Object(h.deprecate)('timeout="0"', "-1", this);
              },
              methods: {
                genActions: function() {
                  return this.$createElement("div", {
                    staticClass: "v-snack__action "
                  }, [Object(c.getSlot)(this, "action", {
                    attrs: {
                      class: "v-snack__btn"
                    }
                  })]);
                },
                genContent: function() {
                  var g;
                  return this.$createElement("div", {
                    staticClass: "v-snack__content",
                    class: (g = {}, g[this.contentClass] = !0, g),
                    attrs: {
                      role: "status",
                      "aria-live": "polite"
                    }
                  }, [Object(c.getSlot)(this)]);
                },
                genWrapper: function() {
                  var g = this, m = this.hasBackground ? this.setBackgroundColor : this.setTextColor, v = m(this.color, {
                    staticClass: "v-snack__wrapper",
                    class: a.default.options.computed.classes.call(this),
                    style: a.default.options.computed.styles.call(this),
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }],
                    on: {
                      pointerenter: function() {
                        return window.clearTimeout(g.activeTimeout);
                      },
                      pointerleave: this.setTimeout
                    }
                  });
                  return this.$createElement("div", v, [this.genContent(), this.genActions()]);
                },
                genTransition: function() {
                  return this.$createElement("transition", {
                    props: {
                      name: this.transition
                    }
                  }, [this.genWrapper()]);
                },
                setTimeout: function() {
                  var g = this;
                  window.clearTimeout(this.activeTimeout);
                  var m = Number(this.timeout);
                  !this.isActive || // TODO: remove 0 in v3
                  [0, -1].includes(m) || (this.activeTimeout = window.setTimeout(function() {
                    g.isActive = !1;
                  }, m));
                }
              },
              render: function(g) {
                return g("div", {
                  staticClass: "v-snack",
                  class: this.classes,
                  style: this.styles
                }, [this.transition !== !1 ? this.genTransition() : this.genWrapper()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSnackbar/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSnackbar/index.ts ***!
            \*******************************************/
          /*! exports provided: VSnackbar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSnackbar */
              "./src/components/VSnackbar/VSnackbar.ts"
            );
            i.d(r, "VSnackbar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSparkline/VSparkline.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSparkline/VSparkline.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ./helpers/core */
              "./src/components/VSparkline/helpers/core.ts"
            ), f = i(
              /*! ./helpers/path */
              "./src/components/VSparkline/helpers/path.ts"
            );
            function d(c) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(p) {
                return typeof p;
              } : d = function(p) {
                return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
              }, d(c);
            }
            var u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(o.default)(a.default).extend({
              name: "VSparkline",
              inheritAttrs: !1,
              props: {
                autoDraw: Boolean,
                autoDrawDuration: {
                  type: Number,
                  default: 2e3
                },
                autoDrawEasing: {
                  type: String,
                  default: "ease"
                },
                autoLineWidth: {
                  type: Boolean,
                  default: !1
                },
                color: {
                  type: String,
                  default: "primary"
                },
                fill: {
                  type: Boolean,
                  default: !1
                },
                gradient: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                gradientDirection: {
                  type: String,
                  validator: function(h) {
                    return ["top", "bottom", "left", "right"].includes(h);
                  },
                  default: "top"
                },
                height: {
                  type: [String, Number],
                  default: 75
                },
                labels: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                labelSize: {
                  type: [Number, String],
                  default: 7
                },
                lineWidth: {
                  type: [String, Number],
                  default: 4
                },
                padding: {
                  type: [String, Number],
                  default: 8
                },
                showLabels: Boolean,
                smooth: {
                  type: [Boolean, Number, String],
                  default: !1
                },
                type: {
                  type: String,
                  default: "trend",
                  validator: function(h) {
                    return ["trend", "bar"].includes(h);
                  }
                },
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                width: {
                  type: [Number, String],
                  default: 300
                }
              },
              data: function() {
                return {
                  lastLength: 0
                };
              },
              computed: {
                parsedPadding: function() {
                  return Number(this.padding);
                },
                parsedWidth: function() {
                  return Number(this.width);
                },
                parsedHeight: function() {
                  return parseInt(this.height, 10);
                },
                parsedLabelSize: function() {
                  return parseInt(this.labelSize, 10) || 7;
                },
                totalHeight: function() {
                  var h = this.parsedHeight;
                  return this.hasLabels && (h += parseInt(this.labelSize, 10) * 1.5), h;
                },
                totalWidth: function() {
                  var h = this.parsedWidth;
                  return this.type === "bar" && (h = Math.max(this.value.length * this._lineWidth, h)), h;
                },
                totalValues: function() {
                  return this.value.length;
                },
                _lineWidth: function() {
                  if (this.autoLineWidth && this.type !== "trend") {
                    var h = this.parsedPadding * (this.totalValues + 1);
                    return (this.parsedWidth - h) / this.totalValues;
                  } else
                    return parseFloat(this.lineWidth) || 4;
                },
                boundary: function() {
                  if (this.type === "bar")
                    return {
                      minX: 0,
                      maxX: this.totalWidth,
                      minY: 0,
                      maxY: this.parsedHeight
                    };
                  var h = this.parsedPadding;
                  return {
                    minX: h,
                    maxX: this.totalWidth - h,
                    minY: h,
                    maxY: this.parsedHeight - h
                  };
                },
                hasLabels: function() {
                  return !!(this.showLabels || this.labels.length > 0 || this.$scopedSlots.label);
                },
                parsedLabels: function() {
                  for (var h = [], p = this._values, g = p.length, m = 0; h.length < g; m++) {
                    var v = p[m], y = this.labels[m];
                    y || (y = d(v) === "object" ? v.value : v), h.push({
                      x: v.x,
                      value: String(y)
                    });
                  }
                  return h;
                },
                normalizedValues: function() {
                  return this.value.map(function(h) {
                    return typeof h == "number" ? h : h.value;
                  });
                },
                _values: function() {
                  return this.type === "trend" ? Object(l.genPoints)(this.normalizedValues, this.boundary) : Object(l.genBars)(this.normalizedValues, this.boundary);
                },
                textY: function() {
                  var h = this.parsedHeight;
                  return this.type === "trend" && (h -= 4), h;
                },
                _radius: function() {
                  return this.smooth === !0 ? 8 : Number(this.smooth);
                }
              },
              watch: {
                value: {
                  immediate: !0,
                  handler: function() {
                    var h = this;
                    this.$nextTick(function() {
                      if (!(!h.autoDraw || h.type === "bar" || !h.$refs.path)) {
                        var p = h.$refs.path, g = p.getTotalLength();
                        h.fill ? (p.style.transformOrigin = "bottom center", p.style.transition = "none", p.style.transform = "scaleY(0)", p.getBoundingClientRect(), p.style.transition = "transform " + h.autoDrawDuration + "ms " + h.autoDrawEasing, p.style.transform = "scaleY(1)") : (p.style.transition = "none", p.style.strokeDasharray = g + " " + g, p.style.strokeDashoffset = Math.abs(g - (h.lastLength || 0)).toString(), p.getBoundingClientRect(), p.style.transition = "stroke-dashoffset " + h.autoDrawDuration + "ms " + h.autoDrawEasing, p.style.strokeDashoffset = "0"), h.lastLength = g;
                      }
                    });
                  }
                }
              },
              methods: {
                genGradient: function() {
                  var h = this, p = this.gradientDirection, g = this.gradient.slice();
                  g.length || g.push("");
                  var m = Math.max(g.length - 1, 1), v = g.reverse().map(function(y, E) {
                    return h.$createElement("stop", {
                      attrs: {
                        offset: E / m,
                        "stop-color": y || "currentColor"
                      }
                    });
                  });
                  return this.$createElement("defs", [this.$createElement("linearGradient", {
                    attrs: {
                      id: this._uid,
                      gradientUnits: "userSpaceOnUse",
                      x1: p === "left" ? "100%" : "0",
                      y1: p === "top" ? "100%" : "0",
                      x2: p === "right" ? "100%" : "0",
                      y2: p === "bottom" ? "100%" : "0"
                    }
                  }, v)]);
                },
                genG: function(h) {
                  return this.$createElement("g", {
                    style: {
                      fontSize: "8",
                      textAnchor: "middle",
                      dominantBaseline: "mathematical",
                      fill: "currentColor"
                    }
                    // TODO: TS 3.5 is too eager with the array type here
                  }, h);
                },
                genPath: function() {
                  var h = Object(l.genPoints)(this.normalizedValues, this.boundary);
                  return this.$createElement("path", {
                    attrs: {
                      d: Object(f.genPath)(h, this._radius, this.fill, this.parsedHeight),
                      fill: this.fill ? "url(#" + this._uid + ")" : "none",
                      stroke: this.fill ? "none" : "url(#" + this._uid + ")"
                    },
                    ref: "path"
                  });
                },
                genLabels: function(h) {
                  var p = this, g = this.parsedLabels.map(function(m, v) {
                    return p.$createElement("text", {
                      attrs: {
                        x: m.x + h + p._lineWidth / 2,
                        y: p.textY + p.parsedLabelSize * 0.75,
                        "font-size": Number(p.labelSize) || 7
                      }
                    }, [p.genLabel(m, v)]);
                  });
                  return this.genG(g);
                },
                genLabel: function(h, p) {
                  return this.$scopedSlots.label ? this.$scopedSlots.label({
                    index: p,
                    value: h.value
                  }) : h.value;
                },
                genBars: function() {
                  if (!(!this.value || this.totalValues < 2)) {
                    var h = Object(l.genBars)(this.normalizedValues, this.boundary), p = (Math.abs(h[0].x - h[1].x) - this._lineWidth) / 2;
                    return this.$createElement("svg", {
                      attrs: {
                        display: "block",
                        viewBox: "0 0 " + this.totalWidth + " " + this.totalHeight
                      }
                    }, [this.genGradient(), this.genClipPath(h, p, this._lineWidth, "sparkline-bar-" + this._uid), this.hasLabels ? this.genLabels(p) : void 0, this.$createElement("g", {
                      attrs: {
                        "clip-path": "url(#sparkline-bar-" + this._uid + "-clip)",
                        fill: "url(#" + this._uid + ")"
                      }
                    }, [this.$createElement("rect", {
                      attrs: {
                        x: 0,
                        y: 0,
                        width: this.totalWidth,
                        height: this.height
                      }
                    })])]);
                  }
                },
                genClipPath: function(h, p, g, m) {
                  var v = this, y = typeof this.smooth == "number" ? this.smooth : this.smooth ? 2 : 0;
                  return this.$createElement("clipPath", {
                    attrs: {
                      id: m + "-clip"
                    }
                  }, h.map(function(E) {
                    return v.$createElement("rect", {
                      attrs: {
                        x: E.x + p,
                        y: E.y,
                        width: g,
                        height: E.height,
                        rx: y,
                        ry: y
                      }
                    }, [v.autoDraw ? v.$createElement("animate", {
                      attrs: {
                        attributeName: "height",
                        from: 0,
                        to: E.height,
                        dur: v.autoDrawDuration + "ms",
                        fill: "freeze"
                      }
                    }) : void 0]);
                  }));
                },
                genTrend: function() {
                  return this.$createElement("svg", this.setTextColor(this.color, {
                    attrs: u(u({}, this.$attrs), {
                      display: "block",
                      "stroke-width": this._lineWidth || 1,
                      viewBox: "0 0 " + this.width + " " + this.totalHeight
                    })
                  }), [this.genGradient(), this.hasLabels && this.genLabels(-(this._lineWidth / 2)), this.genPath()]);
                }
              },
              render: function(h) {
                if (!(this.totalValues < 2))
                  return this.type === "trend" ? this.genTrend() : this.genBars();
              }
            });
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/core.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/core.ts ***!
            \***************************************************/
          /*! exports provided: genPoints, genBars */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "genPoints", function() {
              return l;
            }), i.d(r, "genBars", function() {
              return f;
            });
            var a = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, o = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            function l(d, u) {
              var c = u.minX, h = u.maxX, p = u.minY, g = u.maxY, m = d.length, v = Math.max.apply(Math, o([], a(d), !1)), y = Math.min.apply(Math, o([], a(d), !1)), E = (h - c) / (m - 1), C = (g - p) / (v - y || 1);
              return d.map(function(x, b) {
                return {
                  x: c + b * E,
                  y: g - (x - y) * C,
                  value: x
                };
              });
            }
            function f(d, u) {
              var c = u.minX, h = u.maxX, p = u.minY, g = u.maxY, m = d.length, v = Math.max.apply(Math, o([], a(d), !1)), y = Math.min.apply(Math, o([], a(d), !1));
              y > 0 && (y = 0), v < 0 && (v = 0);
              var E = h / m, C = (g - p) / (v - y || 1), x = g - Math.abs(y * C);
              return d.map(function(b, P) {
                var O = Math.abs(C * b);
                return {
                  x: c + P * E,
                  y: x - O + +(b < 0) * O,
                  height: O,
                  value: b
                };
              });
            }
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/math.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/math.ts ***!
            \***************************************************/
          /*! exports provided: checkCollinear, getDistance, moveTo */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "checkCollinear", function() {
              return o;
            }), i.d(r, "getDistance", function() {
              return l;
            }), i.d(r, "moveTo", function() {
              return f;
            });
            function a(d) {
              return parseInt(d, 10);
            }
            function o(d, u, c) {
              return a(d.x + c.x) === a(2 * u.x) && a(d.y + c.y) === a(2 * u.y);
            }
            function l(d, u) {
              return Math.sqrt(Math.pow(u.x - d.x, 2) + Math.pow(u.y - d.y, 2));
            }
            function f(d, u, c) {
              var h = {
                x: d.x - u.x,
                y: d.y - u.y
              }, p = Math.sqrt(h.x * h.x + h.y * h.y), g = {
                x: h.x / p,
                y: h.y / p
              };
              return {
                x: u.x + g.x * c,
                y: u.y + g.y * c
              };
            }
          }
        ),
        /***/
        "./src/components/VSparkline/helpers/path.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VSparkline/helpers/path.ts ***!
            \***************************************************/
          /*! exports provided: genPath */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "genPath", function() {
              return o;
            });
            var a = i(
              /*! ./math */
              "./src/components/VSparkline/helpers/math.ts"
            );
            function o(l, f, d, u) {
              d === void 0 && (d = !1), u === void 0 && (u = 75);
              var c = l.shift(), h = l[l.length - 1];
              return (d ? "M" + c.x + " " + (u - c.x + 2) + " L" + c.x + " " + c.y : "M" + c.x + " " + c.y) + l.map(function(p, g) {
                var m = l[g + 1], v = l[g - 1] || c, y = m && Object(a.checkCollinear)(m, p, v);
                if (!m || y)
                  return "L" + p.x + " " + p.y;
                var E = Math.min(Object(a.getDistance)(v, p), Object(a.getDistance)(m, p)), C = E / 2 < f, x = C ? E / 2 : f, b = Object(a.moveTo)(v, p, x), P = Object(a.moveTo)(m, p, x);
                return "L" + b.x + " " + b.y + "S" + p.x + " " + p.y + " " + P.x + " " + P.y;
              }).join("") + (d ? "L" + h.x + " " + (u - c.x + 2) + " Z" : "");
            }
          }
        ),
        /***/
        "./src/components/VSparkline/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSparkline/index.ts ***!
            \********************************************/
          /*! exports provided: VSparkline, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSparkline */
              "./src/components/VSparkline/VSparkline.ts"
            );
            i.d(r, "VSparkline", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSpeedDial/VSpeedDial.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSpeedDial/VSpeedDial.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSpeedDial/VSpeedDial.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSpeedDial/VSpeedDial.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSpeedDial.sass */
              "./src/components/VSpeedDial/VSpeedDial.sass"
            );
            var a = i(
              /*! ../../mixins/toggleable */
              "./src/mixins/toggleable/index.ts"
            ), o = i(
              /*! ../../mixins/positionable */
              "./src/mixins/positionable/index.ts"
            ), l = i(
              /*! ../../mixins/transitionable */
              "./src/mixins/transitionable/index.ts"
            ), f = i(
              /*! ../../directives/click-outside */
              "./src/directives/click-outside/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(o.default, a.default, l.default).extend({
              name: "v-speed-dial",
              directives: {
                ClickOutside: f.default
              },
              props: {
                direction: {
                  type: String,
                  default: "top",
                  validator: function(c) {
                    return ["top", "right", "bottom", "left"].includes(c);
                  }
                },
                openOnHover: Boolean,
                transition: {
                  type: String,
                  default: "scale-transition"
                }
              },
              computed: {
                classes: function() {
                  var c;
                  return c = {
                    "v-speed-dial": !0,
                    "v-speed-dial--top": this.top,
                    "v-speed-dial--right": this.right,
                    "v-speed-dial--bottom": this.bottom,
                    "v-speed-dial--left": this.left,
                    "v-speed-dial--absolute": this.absolute,
                    "v-speed-dial--fixed": this.fixed
                  }, c["v-speed-dial--direction-" + this.direction] = !0, c["v-speed-dial--is-active"] = this.isActive, c;
                }
              },
              render: function(c) {
                var h = this, p = [], g = {
                  class: this.classes,
                  directives: [{
                    name: "click-outside",
                    value: function() {
                      return h.isActive = !1;
                    }
                  }],
                  on: {
                    click: function() {
                      return h.isActive = !h.isActive;
                    }
                  }
                };
                if (this.openOnHover && (g.on.mouseenter = function() {
                  return h.isActive = !0;
                }, g.on.mouseleave = function() {
                  return h.isActive = !1;
                }), this.isActive) {
                  var m = 0;
                  p = (this.$slots.default || []).map(function(y, E) {
                    return y.tag && typeof y.componentOptions < "u" && (y.componentOptions.Ctor.options.name === "v-btn" || y.componentOptions.Ctor.options.name === "v-tooltip") ? (m++, c("div", {
                      style: {
                        transitionDelay: m * 0.05 + "s"
                      },
                      key: E
                    }, [y])) : (y.key = E, y);
                  });
                }
                var v = c("transition-group", {
                  class: "v-speed-dial__list",
                  props: {
                    name: this.transition,
                    mode: this.mode,
                    origin: this.origin,
                    tag: "div"
                  }
                }, p);
                return c("div", g, [this.$slots.activator, v]);
              }
            });
          }
        ),
        /***/
        "./src/components/VSpeedDial/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSpeedDial/index.ts ***!
            \********************************************/
          /*! exports provided: VSpeedDial, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSpeedDial */
              "./src/components/VSpeedDial/VSpeedDial.ts"
            );
            i.d(r, "VSpeedDial", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VStepper/VStepper.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VStepper/VStepper.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VStepper/VStepper.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VStepper/VStepper.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VStepper.sass */
              "./src/components/VStepper/VStepper.sass"
            );
            var a = i(
              /*! ../VSheet */
              "./src/components/VSheet/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(f.default)(a.default, Object(o.provide)("stepper"), l.default);
            r.default = c.extend({
              name: "v-stepper",
              provide: function() {
                return {
                  stepClick: this.stepClick,
                  isVertical: this.vertical
                };
              },
              props: {
                altLabels: Boolean,
                nonLinear: Boolean,
                flat: Boolean,
                vertical: Boolean
              },
              data: function() {
                var p = {
                  isBooted: !1,
                  steps: [],
                  content: [],
                  isReverse: !1
                };
                return p.internalLazyValue = this.value != null ? this.value : (p[0] || {}).step || 1, p;
              },
              computed: {
                classes: function() {
                  return u({
                    "v-stepper--flat": this.flat,
                    "v-stepper--is-booted": this.isBooted,
                    "v-stepper--vertical": this.vertical,
                    "v-stepper--alt-labels": this.altLabels,
                    "v-stepper--non-linear": this.nonLinear
                  }, a.default.options.computed.classes.call(this));
                },
                styles: function() {
                  return u({}, a.default.options.computed.styles.call(this));
                }
              },
              watch: {
                internalValue: function(p, g) {
                  this.isReverse = Number(p) < Number(g), g && (this.isBooted = !0), this.updateView();
                }
              },
              created: function() {
                this.$listeners.input && Object(d.breaking)("@input", "@change", this);
              },
              mounted: function() {
                this.updateView();
              },
              methods: {
                register: function(p) {
                  p.$options.name === "v-stepper-step" ? this.steps.push(p) : p.$options.name === "v-stepper-content" && (p.isVertical = this.vertical, this.content.push(p));
                },
                unregister: function(p) {
                  p.$options.name === "v-stepper-step" ? this.steps = this.steps.filter(function(g) {
                    return g !== p;
                  }) : p.$options.name === "v-stepper-content" && (p.isVertical = this.vertical, this.content = this.content.filter(function(g) {
                    return g !== p;
                  }));
                },
                stepClick: function(p) {
                  var g = this;
                  this.$nextTick(function() {
                    return g.internalValue = p;
                  });
                },
                updateView: function() {
                  for (var p = this.steps.length; --p >= 0; )
                    this.steps[p].toggle(this.internalValue);
                  for (var p = this.content.length; --p >= 0; )
                    this.content[p].toggle(this.internalValue, this.isReverse);
                }
              },
              render: function(p) {
                return p(this.tag, {
                  staticClass: "v-stepper",
                  class: this.classes,
                  style: this.styles
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/VStepperContent.ts": (
          /*!****************************************************!*\
            !*** ./src/components/VStepper/VStepperContent.ts ***!
            \****************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = Object(f.default)(Object(o.inject)("stepper", "v-stepper-content", "v-stepper"));
            r.default = d.extend().extend({
              name: "v-stepper-content",
              inject: {
                isVerticalProvided: {
                  from: "isVertical"
                }
              },
              props: {
                step: {
                  type: [Number, String],
                  required: !0
                }
              },
              data: function() {
                return {
                  height: 0,
                  // Must be null to allow
                  // previous comparison
                  isActive: null,
                  isReverse: !1,
                  isVertical: this.isVerticalProvided
                };
              },
              computed: {
                computedTransition: function() {
                  var c = this.$vuetify.rtl ? !this.isReverse : this.isReverse;
                  return c ? a.VTabReverseTransition : a.VTabTransition;
                },
                styles: function() {
                  return this.isVertical ? {
                    height: Object(l.convertToUnit)(this.height)
                  } : {};
                }
              },
              watch: {
                isActive: function(c, h) {
                  if (c && h == null) {
                    this.height = "auto";
                    return;
                  }
                  this.isVertical && (this.isActive ? this.enter() : this.leave());
                }
              },
              mounted: function() {
                this.$refs.wrapper.addEventListener("transitionend", this.onTransition, !1), this.stepper && this.stepper.register(this);
              },
              beforeDestroy: function() {
                this.$refs.wrapper.removeEventListener("transitionend", this.onTransition, !1), this.stepper && this.stepper.unregister(this);
              },
              methods: {
                onTransition: function(c) {
                  !this.isActive || c.propertyName !== "height" || (this.height = "auto");
                },
                enter: function() {
                  var c = this, h = 0;
                  requestAnimationFrame(function() {
                    h = c.$refs.wrapper.scrollHeight;
                  }), this.height = 0, setTimeout(function() {
                    return c.isActive && (c.height = h || "auto");
                  }, 450);
                },
                leave: function() {
                  var c = this;
                  this.height = this.$refs.wrapper.clientHeight, setTimeout(function() {
                    return c.height = 0;
                  }, 10);
                },
                toggle: function(c, h) {
                  this.isActive = c.toString() === this.step.toString(), this.isReverse = h;
                }
              },
              render: function(c) {
                var h = {
                  staticClass: "v-stepper__content"
                }, p = {
                  staticClass: "v-stepper__wrapper",
                  style: this.styles,
                  ref: "wrapper"
                };
                this.isVertical || (h.directives = [{
                  name: "show",
                  value: this.isActive
                }]);
                var g = c("div", p, [this.$slots.default]), m = c("div", h, [g]);
                return c(this.computedTransition, {
                  on: this.$listeners
                }, [m]);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/VStepperStep.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VStepper/VStepperStep.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = Object(d.default)(o.default, Object(l.inject)("stepper", "v-stepper-step", "v-stepper"));
            r.default = c.extend().extend({
              name: "v-stepper-step",
              directives: {
                ripple: f.default
              },
              inject: ["stepClick"],
              props: {
                color: {
                  type: String,
                  default: "primary"
                },
                complete: Boolean,
                completeIcon: {
                  type: String,
                  default: "$complete"
                },
                editable: Boolean,
                editIcon: {
                  type: String,
                  default: "$edit"
                },
                errorIcon: {
                  type: String,
                  default: "$error"
                },
                rules: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                step: [Number, String]
              },
              data: function() {
                return {
                  isActive: !1,
                  isInactive: !0
                };
              },
              computed: {
                classes: function() {
                  return {
                    "v-stepper__step--active": this.isActive,
                    "v-stepper__step--editable": this.editable,
                    "v-stepper__step--inactive": this.isInactive,
                    "v-stepper__step--error error--text": this.hasError,
                    "v-stepper__step--complete": this.complete
                  };
                },
                hasError: function() {
                  return this.rules.some(function(p) {
                    return p() !== !0;
                  });
                }
              },
              mounted: function() {
                this.stepper && this.stepper.register(this);
              },
              beforeDestroy: function() {
                this.stepper && this.stepper.unregister(this);
              },
              methods: {
                click: function(p) {
                  p.stopPropagation(), this.$emit("click", p), this.editable && this.stepClick(this.step);
                },
                genIcon: function(p) {
                  return this.$createElement(a.default, p);
                },
                genLabel: function() {
                  return this.$createElement("div", {
                    staticClass: "v-stepper__label"
                  }, this.$slots.default);
                },
                genStep: function() {
                  var p = !this.hasError && (this.complete || this.isActive) ? this.color : !1;
                  return this.$createElement("span", this.setBackgroundColor(p, {
                    staticClass: "v-stepper__step__step"
                  }), this.genStepContent());
                },
                genStepContent: function() {
                  var p = [];
                  return this.hasError ? p.push(this.genIcon(this.errorIcon)) : this.complete ? this.editable ? p.push(this.genIcon(this.editIcon)) : p.push(this.genIcon(this.completeIcon)) : p.push(String(this.step)), p;
                },
                keyboardClick: function(p) {
                  p.keyCode === u.keyCodes.space && this.click(p);
                },
                toggle: function(p) {
                  this.isActive = p.toString() === this.step.toString(), this.isInactive = Number(p) < Number(this.step);
                }
              },
              render: function(p) {
                return p("div", {
                  attrs: {
                    tabindex: this.editable ? 0 : -1
                  },
                  staticClass: "v-stepper__step",
                  class: this.classes,
                  directives: [{
                    name: "ripple",
                    value: this.editable
                  }],
                  on: {
                    click: this.click,
                    keydown: this.keyboardClick
                  }
                }, [this.genStep(), this.genLabel()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VStepper/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VStepper/index.ts ***!
            \******************************************/
          /*! exports provided: VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VStepperHeader", function() {
              return d;
            }), i.d(r, "VStepperItems", function() {
              return u;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ./VStepper */
              "./src/components/VStepper/VStepper.ts"
            );
            i.d(r, "VStepper", function() {
              return o.default;
            });
            var l = i(
              /*! ./VStepperStep */
              "./src/components/VStepper/VStepperStep.ts"
            );
            i.d(r, "VStepperStep", function() {
              return l.default;
            });
            var f = i(
              /*! ./VStepperContent */
              "./src/components/VStepper/VStepperContent.ts"
            );
            i.d(r, "VStepperContent", function() {
              return f.default;
            });
            var d = Object(a.createSimpleFunctional)("v-stepper__header"), u = Object(a.createSimpleFunctional)("v-stepper__items");
            r.default = {
              $_vuetify_subcomponents: {
                VStepper: o.default,
                VStepperContent: f.default,
                VStepperStep: l.default,
                VStepperHeader: d,
                VStepperItems: u
              }
            };
          }
        ),
        /***/
        "./src/components/VSubheader/VSubheader.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSubheader/VSubheader.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSubheader/VSubheader.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSubheader/VSubheader.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSubheader.sass */
              "./src/components/VSubheader/VSubheader.sass"
            );
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(o.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-subheader",
              props: {
                inset: Boolean
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-subheader",
                  class: l({
                    "v-subheader--inset": this.inset
                  }, this.themeClasses),
                  attrs: this.$attrs,
                  on: this.$listeners
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VSubheader/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSubheader/index.ts ***!
            \********************************************/
          /*! exports provided: VSubheader, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSubheader */
              "./src/components/VSubheader/VSubheader.ts"
            );
            i.d(r, "VSubheader", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSwitch/VSwitch.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VSwitch/VSwitch.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSwitch/VSwitch.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VSwitch/VSwitch.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ../../styles/components/_selection-controls.sass */
              "./src/styles/components/_selection-controls.sass"
            ), i(
              /*! ./VSwitch.sass */
              "./src/components/VSwitch/VSwitch.sass"
            );
            var a = i(
              /*! ../../mixins/selectable */
              "./src/mixins/selectable/index.ts"
            ), o = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), l = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), f = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), d = i(
              /*! ../VProgressCircular/VProgressCircular */
              "./src/components/VProgressCircular/VProgressCircular.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, c.apply(this, arguments);
            }, h = function(p, g) {
              var m = {};
              for (var v in p)
                Object.prototype.hasOwnProperty.call(p, v) && g.indexOf(v) < 0 && (m[v] = p[v]);
              if (p != null && typeof Object.getOwnPropertySymbols == "function")
                for (var y = 0, v = Object.getOwnPropertySymbols(p); y < v.length; y++)
                  g.indexOf(v[y]) < 0 && Object.prototype.propertyIsEnumerable.call(p, v[y]) && (m[v[y]] = p[v[y]]);
              return m;
            };
            r.default = a.default.extend({
              name: "v-switch",
              directives: {
                Touch: l.default
              },
              props: {
                inset: Boolean,
                loading: {
                  type: [Boolean, String],
                  default: !1
                },
                flat: {
                  type: Boolean,
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  return c(c({}, o.default.options.computed.classes.call(this)), {
                    "v-input--selection-controls v-input--switch": !0,
                    "v-input--switch--flat": this.flat,
                    "v-input--switch--inset": this.inset
                  });
                },
                attrs: function() {
                  return {
                    "aria-checked": String(this.isActive),
                    "aria-disabled": String(this.isDisabled),
                    role: "switch"
                  };
                },
                // Do not return undefined if disabled,
                // according to spec, should still show
                // a color when disabled and active
                validationState: function() {
                  if (this.hasError && this.shouldValidate)
                    return "error";
                  if (this.hasSuccess)
                    return "success";
                  if (this.hasColor !== null)
                    return this.computedColor;
                },
                switchData: function() {
                  return this.setTextColor(this.loading ? void 0 : this.validationState, {
                    class: this.themeClasses
                  });
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return [this.genSwitch(), this.genLabel()];
                },
                genSwitch: function() {
                  var g = this.attrs$;
                  g.title;
                  var m = h(g, ["title"]);
                  return this.$createElement("div", {
                    staticClass: "v-input--selection-controls__input"
                  }, [this.genInput("checkbox", c(c({}, this.attrs), m)), this.genRipple(this.setTextColor(this.validationState, {
                    directives: [{
                      name: "touch",
                      value: {
                        left: this.onSwipeLeft,
                        right: this.onSwipeRight
                      }
                    }]
                  })), this.$createElement("div", c({
                    staticClass: "v-input--switch__track"
                  }, this.switchData)), this.$createElement("div", c({
                    staticClass: "v-input--switch__thumb"
                  }, this.switchData), [this.genProgress()])]);
                },
                genProgress: function() {
                  return this.$createElement(f.VFabTransition, {}, [this.loading === !1 ? null : this.$slots.progress || this.$createElement(d.default, {
                    props: {
                      color: this.loading === !0 || this.loading === "" ? this.color || "primary" : this.loading,
                      size: 16,
                      width: 2,
                      indeterminate: !0
                    }
                  })]);
                },
                onSwipeLeft: function() {
                  this.isActive && this.onChange();
                },
                onSwipeRight: function() {
                  this.isActive || this.onChange();
                },
                onKeydown: function(g) {
                  (g.keyCode === u.keyCodes.left && this.isActive || g.keyCode === u.keyCodes.right && !this.isActive) && this.onChange();
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VSwitch/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VSwitch/index.ts ***!
            \*****************************************/
          /*! exports provided: VSwitch, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSwitch */
              "./src/components/VSwitch/VSwitch.ts"
            );
            i.d(r, "VSwitch", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VSystemBar/VSystemBar.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VSystemBar/VSystemBar.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VSystemBar/VSystemBar.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VSystemBar/VSystemBar.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VSystemBar.sass */
              "./src/components/VSystemBar/VSystemBar.sass"
            );
            var a = i(
              /*! ../../mixins/applicationable */
              "./src/mixins/applicationable/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = function() {
              return u = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, u.apply(this, arguments);
            };
            r.default = Object(f.default)(
              Object(a.default)("bar", ["height", "window"]),
              o.default,
              l.default
              /* @vue/component */
            ).extend({
              name: "v-system-bar",
              props: {
                height: [Number, String],
                lightsOut: Boolean,
                window: Boolean
              },
              computed: {
                classes: function() {
                  return u({
                    "v-system-bar--lights-out": this.lightsOut,
                    "v-system-bar--absolute": this.absolute,
                    "v-system-bar--fixed": !this.absolute && (this.app || this.fixed),
                    "v-system-bar--window": this.window
                  }, this.themeClasses);
                },
                computedHeight: function() {
                  return this.height ? isNaN(parseInt(this.height)) ? this.height : parseInt(this.height) : this.window ? 32 : 24;
                },
                styles: function() {
                  return {
                    height: Object(d.convertToUnit)(this.computedHeight)
                  };
                }
              },
              methods: {
                updateApplication: function() {
                  return this.$el ? this.$el.clientHeight : this.computedHeight;
                }
              },
              render: function(h) {
                var p = {
                  staticClass: "v-system-bar",
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                };
                return h("div", this.setBackgroundColor(this.color, p), Object(d.getSlot)(this));
              }
            });
          }
        ),
        /***/
        "./src/components/VSystemBar/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VSystemBar/index.ts ***!
            \********************************************/
          /*! exports provided: VSystemBar, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VSystemBar */
              "./src/components/VSystemBar/VSystemBar.ts"
            );
            i.d(r, "VSystemBar", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTabs/VTab.ts": (
          /*!**************************************!*\
            !*** ./src/components/VTabs/VTab.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), o = i(
              /*! ../../mixins/routable */
              "./src/mixins/routable/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ./../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = function() {
              return u = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, u.apply(this, arguments);
            }, c = Object(d.default)(
              o.default,
              // Must be after routable
              // to overwrite activeClass
              Object(a.factory)("tabsBar"),
              l.default
            );
            r.default = c.extend().extend().extend({
              name: "v-tab",
              props: {
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                },
                tabValue: {
                  required: !1
                }
              },
              data: function() {
                return {
                  proxyClass: "v-tab--active"
                };
              },
              computed: {
                classes: function() {
                  return u(u(u({
                    "v-tab": !0
                  }, o.default.options.computed.classes.call(this)), {
                    "v-tab--disabled": this.disabled
                  }), this.groupClasses);
                },
                value: function() {
                  if (this.tabValue != null)
                    return this.tabValue;
                  var p = this.to || this.href;
                  if (p == null)
                    return p;
                  if (this.$router && this.to === Object(this.to)) {
                    var g = this.$router.resolve(this.to, this.$route, this.append);
                    p = g.href;
                  }
                  return p.replace("#", "");
                }
              },
              methods: {
                click: function(p) {
                  if (this.disabled) {
                    p.preventDefault();
                    return;
                  }
                  this.href && this.href.indexOf("#") > -1 && p.preventDefault(), p.detail && this.$el.blur(), this.$emit("click", p), this.to || this.toggle();
                },
                toggle: function() {
                  (!this.isActive || !this.tabsBar.mandatory && !this.to) && this.$emit("change");
                }
              },
              render: function(p) {
                var g = this, m = this.generateRouteLink(), v = m.tag, y = m.data;
                return y.attrs = u(u({}, y.attrs), {
                  "aria-selected": String(this.isActive),
                  role: "tab",
                  tabindex: this.disabled ? -1 : 0
                }), y.on = u(u({}, y.on), {
                  keydown: function(C) {
                    C.keyCode === f.keyCodes.enter && g.click(C), g.$emit("keydown", C);
                  }
                }), p(v, y, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabItem.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTabs/VTabItem.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            );
            r.default = a.default.extend({
              name: "v-tab-item",
              props: {
                id: String
              },
              methods: {
                genWindowItem: function() {
                  var l = a.default.options.methods.genWindowItem.call(this);
                  return l.data.domProps = l.data.domProps || {}, l.data.domProps.id = this.id || this.value, l;
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabs.sass": (
          /*!*****************************************!*\
            !*** ./src/components/VTabs/VTabs.sass ***!
            \*****************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTabs/VTabs.ts": (
          /*!***************************************!*\
            !*** ./src/components/VTabs/VTabs.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTabs.sass */
              "./src/components/VTabs/VTabs.sass"
            );
            var a = i(
              /*! ./VTabsBar */
              "./src/components/VTabs/VTabsBar.ts"
            ), o = i(
              /*! ./VTabsItems */
              "./src/components/VTabs/VTabsItems.ts"
            ), l = i(
              /*! ./VTabsSlider */
              "./src/components/VTabs/VTabsSlider.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../mixins/proxyable */
              "./src/mixins/proxyable/index.ts"
            ), u = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), c = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), p = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), g = function() {
              return g = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, g.apply(this, arguments);
            }, m = Object(p.default)(f.default, d.default, u.default);
            r.default = m.extend().extend({
              name: "v-tabs",
              directives: {
                Resize: c.default
              },
              props: {
                activeClass: {
                  type: String,
                  default: ""
                },
                alignWithTitle: Boolean,
                backgroundColor: String,
                centerActive: Boolean,
                centered: Boolean,
                fixedTabs: Boolean,
                grow: Boolean,
                height: {
                  type: [Number, String],
                  default: void 0
                },
                hideSlider: Boolean,
                iconsAndText: Boolean,
                mobileBreakpoint: [String, Number],
                nextIcon: {
                  type: String,
                  default: "$next"
                },
                optional: Boolean,
                prevIcon: {
                  type: String,
                  default: "$prev"
                },
                right: Boolean,
                showArrows: [Boolean, String],
                sliderColor: String,
                sliderSize: {
                  type: [Number, String],
                  default: 2
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  resizeTimeout: 0,
                  slider: {
                    height: null,
                    left: null,
                    right: null,
                    top: null,
                    width: null
                  },
                  transitionTime: 300
                };
              },
              computed: {
                classes: function() {
                  return g({
                    "v-tabs--align-with-title": this.alignWithTitle,
                    "v-tabs--centered": this.centered,
                    "v-tabs--fixed-tabs": this.fixedTabs,
                    "v-tabs--grow": this.grow,
                    "v-tabs--icons-and-text": this.iconsAndText,
                    "v-tabs--right": this.right,
                    "v-tabs--vertical": this.vertical
                  }, this.themeClasses);
                },
                isReversed: function() {
                  return this.$vuetify.rtl && this.vertical;
                },
                sliderStyles: function() {
                  return {
                    height: Object(h.convertToUnit)(this.slider.height),
                    left: this.isReversed ? void 0 : Object(h.convertToUnit)(this.slider.left),
                    right: this.isReversed ? Object(h.convertToUnit)(this.slider.right) : void 0,
                    top: this.vertical ? Object(h.convertToUnit)(this.slider.top) : void 0,
                    transition: this.slider.left != null ? null : "none",
                    width: Object(h.convertToUnit)(this.slider.width)
                  };
                },
                computedColor: function() {
                  return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                }
              },
              watch: {
                alignWithTitle: "callSlider",
                centered: "callSlider",
                centerActive: "callSlider",
                fixedTabs: "callSlider",
                grow: "callSlider",
                iconsAndText: "callSlider",
                right: "callSlider",
                showArrows: "callSlider",
                vertical: "callSlider",
                "$vuetify.application.left": "onResize",
                "$vuetify.application.right": "onResize",
                "$vuetify.rtl": "onResize"
              },
              mounted: function() {
                var y = this;
                if (typeof ResizeObserver < "u") {
                  var E = new ResizeObserver(function() {
                    y.onResize();
                  });
                  E.observe(this.$el), this.$on("hook:destroyed", function() {
                    E.disconnect();
                  });
                }
                this.$nextTick(function() {
                  window.setTimeout(y.callSlider, 30);
                });
              },
              methods: {
                callSlider: function() {
                  var y = this;
                  return this.hideSlider || !this.$refs.items || !this.$refs.items.selectedItems.length ? (this.slider.width = 0, !1) : (this.$nextTick(function() {
                    var E = y.$refs.items.selectedItems[0];
                    if (!E || !E.$el) {
                      y.slider.width = 0, y.slider.left = 0;
                      return;
                    }
                    var C = E.$el;
                    y.slider = {
                      height: y.vertical ? C.scrollHeight : Number(y.sliderSize),
                      left: y.vertical ? 0 : C.offsetLeft,
                      right: y.vertical ? 0 : C.offsetLeft + C.offsetWidth,
                      top: C.offsetTop,
                      width: y.vertical ? Number(y.sliderSize) : C.scrollWidth
                    };
                  }), !0);
                },
                genBar: function(y, E) {
                  var C = this, x = {
                    style: {
                      height: Object(h.convertToUnit)(this.height)
                    },
                    props: {
                      activeClass: this.activeClass,
                      centerActive: this.centerActive,
                      dark: this.dark,
                      light: this.light,
                      mandatory: !this.optional,
                      mobileBreakpoint: this.mobileBreakpoint,
                      nextIcon: this.nextIcon,
                      prevIcon: this.prevIcon,
                      showArrows: this.showArrows,
                      value: this.internalValue
                    },
                    on: {
                      "call:slider": this.callSlider,
                      change: function(P) {
                        C.internalValue = P;
                      }
                    },
                    ref: "items"
                  };
                  return this.setTextColor(this.computedColor, x), this.setBackgroundColor(this.backgroundColor, x), this.$createElement(a.default, x, [this.genSlider(E), y]);
                },
                genItems: function(y, E) {
                  var C = this;
                  return y || (E.length ? this.$createElement(o.default, {
                    props: {
                      value: this.internalValue
                    },
                    on: {
                      change: function(b) {
                        C.internalValue = b;
                      }
                    }
                  }, E) : null);
                },
                genSlider: function(y) {
                  return this.hideSlider ? null : (y || (y = this.$createElement(l.default, {
                    props: {
                      color: this.sliderColor
                    }
                  })), this.$createElement("div", {
                    staticClass: "v-tabs-slider-wrapper",
                    style: this.sliderStyles
                  }, [y]));
                },
                onResize: function() {
                  this._isDestroyed || (clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.callSlider, 0));
                },
                parseNodes: function() {
                  for (var y = null, E = null, C = [], x = [], b = this.$slots.default || [], P = b.length, O = 0; O < P; O++) {
                    var T = b[O];
                    if (T.componentOptions)
                      switch (T.componentOptions.Ctor.options.name) {
                        case "v-tabs-slider":
                          E = T;
                          break;
                        case "v-tabs-items":
                          y = T;
                          break;
                        case "v-tab-item":
                          C.push(T);
                          break;
                        default:
                          x.push(T);
                      }
                    else
                      x.push(T);
                  }
                  return {
                    tab: x,
                    slider: E,
                    items: y,
                    item: C
                  };
                }
              },
              render: function(y) {
                var E = this.parseNodes(), C = E.tab, x = E.slider, b = E.items, P = E.item;
                return y("div", {
                  staticClass: "v-tabs",
                  class: this.classes,
                  directives: [{
                    name: "resize",
                    modifiers: {
                      quiet: !0
                    },
                    value: this.onResize
                  }]
                }, [this.genBar(C, x), this.genItems(b, P)]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsBar.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTabs/VTabsBar.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VSlideGroup/VSlideGroup */
              "./src/components/VSlideGroup/VSlideGroup.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../mixins/ssr-bootable */
              "./src/mixins/ssr-bootable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c) {
              var h = typeof Symbol == "function" && Symbol.iterator, p = h && c[h], g = 0;
              if (p)
                return p.call(c);
              if (c && typeof c.length == "number")
                return {
                  next: function() {
                    return c && g >= c.length && (c = void 0), {
                      value: c && c[g++],
                      done: !c
                    };
                  }
                };
              throw new TypeError(h ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = Object(f.default)(
              a.BaseSlideGroup,
              l.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-tabs-bar",
              provide: function() {
                return {
                  tabsBar: this
                };
              },
              computed: {
                classes: function() {
                  return d(d(d({}, a.BaseSlideGroup.options.computed.classes.call(this)), {
                    "v-tabs-bar": !0,
                    "v-tabs-bar--is-mobile": this.isMobile,
                    // TODO: Remove this and move to v-slide-group
                    "v-tabs-bar--show-arrows": this.showArrows
                  }), this.themeClasses);
                }
              },
              watch: {
                items: "callSlider",
                internalValue: "callSlider",
                $route: "onRouteChange"
              },
              methods: {
                callSlider: function() {
                  this.isBooted && this.$emit("call:slider");
                },
                genContent: function() {
                  var h = a.BaseSlideGroup.options.methods.genContent.call(this);
                  return h.data = h.data || {}, h.data.staticClass += " v-tabs-bar__content", h;
                },
                onRouteChange: function(h, p) {
                  var g, m;
                  if (!this.mandatory) {
                    var v = this.items, y = h.path, E = p.path, C = !1, x = !1;
                    try {
                      for (var b = u(v), P = b.next(); !P.done; P = b.next()) {
                        var O = P.value;
                        if (O.to === E ? x = !0 : O.to === y && (C = !0), C && x)
                          break;
                      }
                    } catch (T) {
                      g = {
                        error: T
                      };
                    } finally {
                      try {
                        P && !P.done && (m = b.return) && m.call(b);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                    !C && x && (this.internalValue = void 0);
                  }
                }
              },
              render: function(h) {
                var p = a.BaseSlideGroup.options.render.call(this, h);
                return p.data.attrs = {
                  role: "tablist"
                }, p;
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsItems.ts": (
          /*!********************************************!*\
            !*** ./src/components/VTabs/VTabsItems.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../VWindow/VWindow */
              "./src/components/VWindow/VWindow.ts"
            ), o = i(
              /*! ./../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = a.default.extend({
              name: "v-tabs-items",
              props: {
                mandatory: {
                  type: Boolean,
                  default: !1
                }
              },
              computed: {
                classes: function() {
                  return l(l({}, a.default.options.computed.classes.call(this)), {
                    "v-tabs-items": !0
                  });
                },
                isDark: function() {
                  return this.rootIsDark;
                }
              },
              methods: {
                getValue: function(d, u) {
                  return d.id || o.BaseItemGroup.options.methods.getValue.call(this, d, u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/VTabsSlider.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTabs/VTabsSlider.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              name: "v-tabs-slider",
              render: function(f) {
                return f("div", this.setBackgroundColor(this.color, {
                  staticClass: "v-tabs-slider"
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VTabs/index.ts": (
          /*!***************************************!*\
            !*** ./src/components/VTabs/index.ts ***!
            \***************************************/
          /*! exports provided: VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTabs */
              "./src/components/VTabs/VTabs.ts"
            );
            i.d(r, "VTabs", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTab */
              "./src/components/VTabs/VTab.ts"
            );
            i.d(r, "VTab", function() {
              return o.default;
            });
            var l = i(
              /*! ./VTabsItems */
              "./src/components/VTabs/VTabsItems.ts"
            );
            i.d(r, "VTabsItems", function() {
              return l.default;
            });
            var f = i(
              /*! ./VTabItem */
              "./src/components/VTabs/VTabItem.ts"
            );
            i.d(r, "VTabItem", function() {
              return f.default;
            });
            var d = i(
              /*! ./VTabsSlider */
              "./src/components/VTabs/VTabsSlider.ts"
            );
            i.d(r, "VTabsSlider", function() {
              return d.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTabs: a.default,
                VTab: o.default,
                VTabsItems: l.default,
                VTabItem: f.default,
                VTabsSlider: d.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTextField/VTextField.sass": (
          /*!***************************************************!*\
            !*** ./src/components/VTextField/VTextField.sass ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTextField/VTextField.ts": (
          /*!*************************************************!*\
            !*** ./src/components/VTextField/VTextField.ts ***!
            \*************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTextField.sass */
              "./src/components/VTextField/VTextField.sass"
            );
            var a = i(
              /*! ../VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../VCounter */
              "./src/components/VCounter/index.ts"
            ), l = i(
              /*! ../VLabel */
              "./src/components/VLabel/index.ts"
            ), f = i(
              /*! ../../mixins/intersectable */
              "./src/mixins/intersectable/index.ts"
            ), d = i(
              /*! ../../mixins/loadable */
              "./src/mixins/loadable/index.ts"
            ), u = i(
              /*! ../../mixins/validatable */
              "./src/mixins/validatable/index.ts"
            ), c = i(
              /*! ../../directives/resize */
              "./src/directives/resize/index.ts"
            ), h = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), p = i(
              /*! ../../util/dom */
              "./src/util/dom.ts"
            ), g = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), m = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), v = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), y = function() {
              return y = Object.assign || function(O) {
                for (var T, M = 1, L = arguments.length; M < L; M++) {
                  T = arguments[M];
                  for (var A in T)
                    Object.prototype.hasOwnProperty.call(T, A) && (O[A] = T[A]);
                }
                return O;
              }, y.apply(this, arguments);
            }, E = function(O, T) {
              var M = {};
              for (var L in O)
                Object.prototype.hasOwnProperty.call(O, L) && T.indexOf(L) < 0 && (M[L] = O[L]);
              if (O != null && typeof Object.getOwnPropertySymbols == "function")
                for (var A = 0, L = Object.getOwnPropertySymbols(O); A < L.length; A++)
                  T.indexOf(L[A]) < 0 && Object.prototype.propertyIsEnumerable.call(O, L[A]) && (M[L[A]] = O[L[A]]);
              return M;
            }, C = function(O, T) {
              var M = typeof Symbol == "function" && O[Symbol.iterator];
              if (!M)
                return O;
              var L = M.call(O), A, D = [], I;
              try {
                for (; (T === void 0 || T-- > 0) && !(A = L.next()).done; )
                  D.push(A.value);
              } catch (w) {
                I = {
                  error: w
                };
              } finally {
                try {
                  A && !A.done && (M = L.return) && M.call(L);
                } finally {
                  if (I)
                    throw I.error;
                }
              }
              return D;
            }, x = function(O, T, M) {
              if (M || arguments.length === 2)
                for (var L = 0, A = T.length, D; L < A; L++)
                  (D || !(L in T)) && (D || (D = Array.prototype.slice.call(T, 0, L)), D[L] = T[L]);
              return O.concat(D || Array.prototype.slice.call(T));
            }, b = Object(v.default)(a.default, Object(f.default)({
              onVisible: ["onResize", "tryAutofocus"]
            }), d.default), P = ["color", "file", "time", "date", "datetime-local", "week", "month"];
            r.default = b.extend().extend({
              name: "v-text-field",
              directives: {
                resize: c.default,
                ripple: h.default
              },
              inheritAttrs: !1,
              props: {
                appendOuterIcon: String,
                autofocus: Boolean,
                clearable: Boolean,
                clearIcon: {
                  type: String,
                  default: "$clear"
                },
                counter: [Boolean, Number, String],
                counterValue: Function,
                filled: Boolean,
                flat: Boolean,
                fullWidth: Boolean,
                label: String,
                outlined: Boolean,
                placeholder: String,
                prefix: String,
                prependInnerIcon: String,
                persistentPlaceholder: Boolean,
                reverse: Boolean,
                rounded: Boolean,
                shaped: Boolean,
                singleLine: Boolean,
                solo: Boolean,
                soloInverted: Boolean,
                suffix: String,
                type: {
                  type: String,
                  default: "text"
                }
              },
              data: function() {
                return {
                  badInput: !1,
                  labelWidth: 0,
                  prefixWidth: 0,
                  prependWidth: 0,
                  initialValue: null,
                  isBooted: !1,
                  isClearing: !1
                };
              },
              computed: {
                classes: function() {
                  return y(y({}, a.default.options.computed.classes.call(this)), {
                    "v-text-field": !0,
                    "v-text-field--full-width": this.fullWidth,
                    "v-text-field--prefix": this.prefix,
                    "v-text-field--single-line": this.isSingle,
                    "v-text-field--solo": this.isSolo,
                    "v-text-field--solo-inverted": this.soloInverted,
                    "v-text-field--solo-flat": this.flat,
                    "v-text-field--filled": this.filled,
                    "v-text-field--is-booted": this.isBooted,
                    "v-text-field--enclosed": this.isEnclosed,
                    "v-text-field--reverse": this.reverse,
                    "v-text-field--outlined": this.outlined,
                    "v-text-field--placeholder": this.placeholder,
                    "v-text-field--rounded": this.rounded,
                    "v-text-field--shaped": this.shaped
                  });
                },
                computedColor: function() {
                  var T = u.default.options.computed.computedColor.call(this);
                  return !this.soloInverted || !this.isFocused ? T : this.color || "primary";
                },
                computedCounterValue: function() {
                  return typeof this.counterValue == "function" ? this.counterValue(this.internalValue) : x([], C((this.internalValue || "").toString()), !1).length;
                },
                hasCounter: function() {
                  return this.counter !== !1 && this.counter != null;
                },
                hasDetails: function() {
                  return a.default.options.computed.hasDetails.call(this) || this.hasCounter;
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(T) {
                    this.lazyValue = T, this.$emit("input", this.lazyValue);
                  }
                },
                isDirty: function() {
                  var T;
                  return ((T = this.lazyValue) === null || T === void 0 ? void 0 : T.toString().length) > 0 || this.badInput;
                },
                isEnclosed: function() {
                  return this.filled || this.isSolo || this.outlined;
                },
                isLabelActive: function() {
                  return this.isDirty || P.includes(this.type);
                },
                isSingle: function() {
                  return this.isSolo || this.singleLine || this.fullWidth || // https://material.io/components/text-fields/#filled-text-field
                  this.filled && !this.hasLabel;
                },
                isSolo: function() {
                  return this.solo || this.soloInverted;
                },
                labelPosition: function() {
                  var T = this.prefix && !this.labelValue ? this.prefixWidth : 0;
                  return this.labelValue && this.prependWidth && (T -= this.prependWidth), this.$vuetify.rtl === this.reverse ? {
                    left: T,
                    right: "auto"
                  } : {
                    left: "auto",
                    right: T
                  };
                },
                showLabel: function() {
                  return this.hasLabel && !(this.isSingle && this.labelValue);
                },
                labelValue: function() {
                  return this.isFocused || this.isLabelActive || this.persistentPlaceholder;
                }
              },
              watch: {
                // labelValue: 'setLabelWidth', // moved to mounted, see #11533
                outlined: "setLabelWidth",
                label: function() {
                  this.$nextTick(this.setLabelWidth);
                },
                prefix: function() {
                  this.$nextTick(this.setPrefixWidth);
                },
                isFocused: "updateValue",
                value: function(T) {
                  this.lazyValue = T;
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("box") && Object(m.breaking)("box", "filled", this), this.$attrs.hasOwnProperty("browser-autocomplete") && Object(m.breaking)("browser-autocomplete", "autocomplete", this), this.shaped && !(this.filled || this.outlined || this.isSolo) && Object(m.consoleWarn)("shaped should be used with either filled or outlined", this);
              },
              mounted: function() {
                var T = this;
                this.$watch(function() {
                  return T.labelValue;
                }, this.setLabelWidth), this.autofocus && this.tryAutofocus(), requestAnimationFrame(function() {
                  T.isBooted = !0, requestAnimationFrame(function() {
                    T.isIntersecting || T.onResize();
                  });
                });
              },
              methods: {
                /** @public */
                focus: function() {
                  this.onFocus();
                },
                /** @public */
                blur: function(T) {
                  var M = this;
                  window.requestAnimationFrame(function() {
                    M.$refs.input && M.$refs.input.blur();
                  });
                },
                clearableCallback: function() {
                  var T = this;
                  this.$refs.input && this.$refs.input.focus(), this.$nextTick(function() {
                    return T.internalValue = null;
                  });
                },
                genAppendSlot: function() {
                  var T = [];
                  return this.$slots["append-outer"] ? T.push(this.$slots["append-outer"]) : this.appendOuterIcon && T.push(this.genIcon("appendOuter")), this.genSlot("append", "outer", T);
                },
                genPrependInnerSlot: function() {
                  var T = [];
                  return this.$slots["prepend-inner"] ? T.push(this.$slots["prepend-inner"]) : this.prependInnerIcon && T.push(this.genIcon("prependInner")), this.genSlot("prepend", "inner", T);
                },
                genIconSlot: function() {
                  var T = [];
                  return this.$slots.append ? T.push(this.$slots.append) : this.appendIcon && T.push(this.genIcon("append")), this.genSlot("append", "inner", T);
                },
                genInputSlot: function() {
                  var T = a.default.options.methods.genInputSlot.call(this), M = this.genPrependInnerSlot();
                  return M && (T.children = T.children || [], T.children.unshift(M)), T;
                },
                genClearIcon: function() {
                  return this.clearable ? this.isDirty ? this.genSlot("append", "inner", [this.genIcon("clear", this.clearableCallback)]) : this.genSlot("append", "inner", [this.$createElement("div")]) : null;
                },
                genCounter: function() {
                  var T, M, L;
                  if (!this.hasCounter)
                    return null;
                  var A = this.counter === !0 ? this.attrs$.maxlength : this.counter, D = {
                    dark: this.dark,
                    light: this.light,
                    max: A,
                    value: this.computedCounterValue
                  };
                  return (L = (M = (T = this.$scopedSlots).counter) === null || M === void 0 ? void 0 : M.call(T, {
                    props: D
                  })) !== null && L !== void 0 ? L : this.$createElement(o.default, {
                    props: D
                  });
                },
                genControl: function() {
                  return a.default.options.methods.genControl.call(this);
                },
                genDefaultSlot: function() {
                  return [this.genFieldset(), this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot(), this.genProgress()];
                },
                genFieldset: function() {
                  return this.outlined ? this.$createElement("fieldset", {
                    attrs: {
                      "aria-hidden": !0
                    }
                  }, [this.genLegend()]) : null;
                },
                genLabel: function() {
                  if (!this.showLabel)
                    return null;
                  var T = {
                    props: {
                      absolute: !0,
                      color: this.validationState,
                      dark: this.dark,
                      disabled: this.isDisabled,
                      focused: !this.isSingle && (this.isFocused || !!this.validationState),
                      for: this.computedId,
                      left: this.labelPosition.left,
                      light: this.light,
                      right: this.labelPosition.right,
                      value: this.labelValue
                    }
                  };
                  return this.$createElement(l.default, T, this.$slots.label || this.label);
                },
                genLegend: function() {
                  var T = !this.singleLine && (this.labelValue || this.isDirty) ? this.labelWidth : 0, M = this.$createElement("span", {
                    domProps: {
                      innerHTML: "&#8203;"
                    },
                    staticClass: "notranslate"
                  });
                  return this.$createElement("legend", {
                    style: {
                      width: this.isSingle ? void 0 : Object(g.convertToUnit)(T)
                    }
                  }, [M]);
                },
                genInput: function() {
                  var T = Object.assign({}, this.listeners$);
                  delete T.change;
                  var M = this.attrs$;
                  M.title;
                  var L = E(M, ["title"]);
                  return this.$createElement("input", {
                    style: {},
                    domProps: {
                      value: this.type === "number" && Object.is(this.lazyValue, -0) ? "-0" : this.lazyValue
                    },
                    attrs: y(y({}, L), {
                      autofocus: this.autofocus,
                      disabled: this.isDisabled,
                      id: this.computedId,
                      placeholder: this.persistentPlaceholder || this.isFocused || !this.hasLabel ? this.placeholder : void 0,
                      readonly: this.isReadonly,
                      type: this.type
                    }),
                    on: Object.assign(T, {
                      blur: this.onBlur,
                      input: this.onInput,
                      focus: this.onFocus,
                      keydown: this.onKeyDown
                    }),
                    ref: "input",
                    directives: [{
                      name: "resize",
                      modifiers: {
                        quiet: !0
                      },
                      value: this.onResize
                    }]
                  });
                },
                genMessages: function() {
                  if (!this.showDetails)
                    return null;
                  var T = a.default.options.methods.genMessages.call(this), M = this.genCounter();
                  return this.$createElement("div", {
                    staticClass: "v-text-field__details"
                  }, [T, M]);
                },
                genTextFieldSlot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-text-field__slot"
                  }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, this.genInput(), this.suffix ? this.genAffix("suffix") : null]);
                },
                genAffix: function(T) {
                  return this.$createElement("div", {
                    class: "v-text-field__" + T,
                    ref: T
                  }, this[T]);
                },
                onBlur: function(T) {
                  var M = this;
                  this.isFocused = !1, T && this.$nextTick(function() {
                    return M.$emit("blur", T);
                  });
                },
                onClick: function() {
                  this.isFocused || this.isDisabled || !this.$refs.input || this.$refs.input.focus();
                },
                onFocus: function(T) {
                  if (this.$refs.input) {
                    var M = Object(p.attachedRoot)(this.$el);
                    if (M) {
                      if (M.activeElement !== this.$refs.input)
                        return this.$refs.input.focus();
                      this.isFocused || (this.isFocused = !0, T && this.$emit("focus", T));
                    }
                  }
                },
                onInput: function(T) {
                  var M = T.target;
                  this.internalValue = M.value, this.badInput = M.validity && M.validity.badInput;
                },
                onKeyDown: function(T) {
                  T.keyCode === g.keyCodes.enter && this.lazyValue !== this.initialValue && (this.initialValue = this.lazyValue, this.$emit("change", this.initialValue)), this.$emit("keydown", T);
                },
                onMouseDown: function(T) {
                  T.target !== this.$refs.input && (T.preventDefault(), T.stopPropagation()), a.default.options.methods.onMouseDown.call(this, T);
                },
                onMouseUp: function(T) {
                  this.hasMouseDown && this.focus(), a.default.options.methods.onMouseUp.call(this, T);
                },
                setLabelWidth: function() {
                  this.outlined && (this.labelWidth = this.$refs.label ? Math.min(this.$refs.label.scrollWidth * 0.75 + 6, this.$el.offsetWidth - 24) : 0);
                },
                setPrefixWidth: function() {
                  this.$refs.prefix && (this.prefixWidth = this.$refs.prefix.offsetWidth);
                },
                setPrependWidth: function() {
                  !this.outlined || !this.$refs["prepend-inner"] || (this.prependWidth = this.$refs["prepend-inner"].offsetWidth);
                },
                tryAutofocus: function() {
                  if (!this.autofocus || typeof document > "u" || !this.$refs.input)
                    return !1;
                  var T = Object(p.attachedRoot)(this.$el);
                  return !T || T.activeElement === this.$refs.input ? !1 : (this.$refs.input.focus(), !0);
                },
                updateValue: function(T) {
                  this.hasColor = T, T ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue);
                },
                onResize: function() {
                  this.setLabelWidth(), this.setPrefixWidth(), this.setPrependWidth();
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTextField/index.ts": (
          /*!********************************************!*\
            !*** ./src/components/VTextField/index.ts ***!
            \********************************************/
          /*! exports provided: VTextField, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTextField */
              "./src/components/VTextField/VTextField.ts"
            );
            i.d(r, "VTextField", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTextarea/VTextarea.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTextarea/VTextarea.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTextarea/VTextarea.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTextarea/VTextarea.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTextarea.sass */
              "./src/components/VTextarea/VTextarea.sass"
            );
            var a = i(
              /*! ../VTextField/VTextField */
              "./src/components/VTextField/VTextField.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = function() {
              return l = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, l.apply(this, arguments);
            }, f = Object(o.default)(a.default);
            r.default = f.extend({
              name: "v-textarea",
              props: {
                autoGrow: Boolean,
                noResize: Boolean,
                rowHeight: {
                  type: [Number, String],
                  default: 24,
                  validator: function(u) {
                    return !isNaN(parseFloat(u));
                  }
                },
                rows: {
                  type: [Number, String],
                  default: 5,
                  validator: function(u) {
                    return !isNaN(parseInt(u, 10));
                  }
                }
              },
              computed: {
                classes: function() {
                  return l({
                    "v-textarea": !0,
                    "v-textarea--auto-grow": this.autoGrow,
                    "v-textarea--no-resize": this.noResizeHandle
                  }, a.default.options.computed.classes.call(this));
                },
                noResizeHandle: function() {
                  return this.noResize || this.autoGrow;
                }
              },
              watch: {
                autoGrow: function(u) {
                  var c = this;
                  this.$nextTick(function() {
                    var h;
                    u ? c.calculateInputHeight() : (h = c.$refs.input) === null || h === void 0 || h.style.removeProperty("height");
                  });
                },
                lazyValue: function() {
                  this.autoGrow && this.$nextTick(this.calculateInputHeight);
                },
                rowHeight: function() {
                  this.autoGrow && this.$nextTick(this.calculateInputHeight);
                }
              },
              mounted: function() {
                var u = this;
                setTimeout(function() {
                  u.autoGrow && u.calculateInputHeight();
                }, 0);
              },
              methods: {
                calculateInputHeight: function() {
                  var u = this.$refs.input;
                  if (u) {
                    u.style.height = "0";
                    var c = u.scrollHeight, h = parseInt(this.rows, 10) * parseFloat(this.rowHeight);
                    u.style.height = Math.max(h, c) + "px";
                  }
                },
                genInput: function() {
                  var u = a.default.options.methods.genInput.call(this);
                  return u.tag = "textarea", delete u.data.attrs.type, u.data.attrs.rows = this.rows, u;
                },
                onInput: function(u) {
                  a.default.options.methods.onInput.call(this, u), this.autoGrow && this.calculateInputHeight();
                },
                onKeyDown: function(u) {
                  this.isFocused && u.keyCode === 13 && u.stopPropagation(), this.$emit("keydown", u);
                }
              }
            });
          }
        ),
        /***/
        "./src/components/VTextarea/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTextarea/index.ts ***!
            \*******************************************/
          /*! exports provided: VTextarea, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTextarea */
              "./src/components/VTextarea/VTextarea.ts"
            );
            i.d(r, "VTextarea", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VThemeProvider/VThemeProvider.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VThemeProvider/VThemeProvider.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            );
            r.default = a.default.extend({
              name: "v-theme-provider",
              props: {
                root: Boolean
              },
              computed: {
                isDark: function() {
                  return this.root ? this.rootIsDark : a.default.options.computed.isDark.call(this);
                }
              },
              render: function() {
                return this.$slots.default && this.$slots.default.find(function(l) {
                  return !l.isComment && l.text !== " ";
                });
              }
            });
          }
        ),
        /***/
        "./src/components/VThemeProvider/index.ts": (
          /*!************************************************!*\
            !*** ./src/components/VThemeProvider/index.ts ***!
            \************************************************/
          /*! exports provided: VThemeProvider, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VThemeProvider */
              "./src/components/VThemeProvider/VThemeProvider.ts"
            );
            i.d(r, "VThemeProvider", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTimePicker/SelectingTimes.ts": (
          /*!******************************************************!*\
            !*** ./src/components/VTimePicker/SelectingTimes.ts ***!
            \******************************************************/
          /*! exports provided: SelectingTimes */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "SelectingTimes", function() {
              return a;
            });
            var a;
            (function(o) {
              o[o.Hour = 1] = "Hour", o[o.Minute = 2] = "Minute", o[o.Second = 3] = "Second";
            })(a || (a = {}));
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePicker.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTimePicker/VTimePicker.ts ***!
            \***************************************************/
          /*! exports provided: SelectingTimes, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimePickerTitle */
              "./src/components/VTimePicker/VTimePickerTitle.ts"
            ), o = i(
              /*! ./VTimePickerClock */
              "./src/components/VTimePicker/VTimePickerClock.ts"
            ), l = i(
              /*! ../../mixins/picker */
              "./src/mixins/picker/index.ts"
            ), f = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), d = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), u = i(
              /*! ../VDatePicker/util/pad */
              "./src/components/VDatePicker/util/pad.ts"
            ), c = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), h = i(
              /*! ./SelectingTimes */
              "./src/components/VTimePicker/SelectingTimes.ts"
            );
            i.d(r, "SelectingTimes", function() {
              return h.SelectingTimes;
            });
            var p = function(C, x) {
              var b = typeof Symbol == "function" && C[Symbol.iterator];
              if (!b)
                return C;
              var P = b.call(C), O, T = [], M;
              try {
                for (; (x === void 0 || x-- > 0) && !(O = P.next()).done; )
                  T.push(O.value);
              } catch (L) {
                M = {
                  error: L
                };
              } finally {
                try {
                  O && !O.done && (b = P.return) && b.call(P);
                } finally {
                  if (M)
                    throw M.error;
                }
              }
              return T;
            }, g = Object(d.createRange)(24), m = Object(d.createRange)(12), v = m.map(function(C) {
              return C + 12;
            }), y = Object(d.createRange)(60), E = {
              1: "hour",
              2: "minute",
              3: "second"
            };
            r.default = Object(c.default)(
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker",
              props: {
                activePicker: String,
                allowedHours: [Function, Array],
                allowedMinutes: [Function, Array],
                allowedSeconds: [Function, Array],
                disabled: Boolean,
                format: {
                  type: String,
                  default: "ampm",
                  validator: function(x) {
                    return ["ampm", "24hr"].includes(x);
                  }
                },
                min: String,
                max: String,
                readonly: Boolean,
                scrollable: Boolean,
                useSeconds: Boolean,
                value: null,
                ampmInTitle: Boolean
              },
              data: function() {
                return {
                  inputHour: null,
                  inputMinute: null,
                  inputSecond: null,
                  lazyInputHour: null,
                  lazyInputMinute: null,
                  lazyInputSecond: null,
                  period: "am",
                  selecting: h.SelectingTimes.Hour
                };
              },
              computed: {
                selectingHour: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Hour;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Hour;
                  }
                },
                selectingMinute: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Minute;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Minute;
                  }
                },
                selectingSecond: {
                  get: function() {
                    return this.selecting === h.SelectingTimes.Second;
                  },
                  set: function(x) {
                    this.selecting = h.SelectingTimes.Second;
                  }
                },
                isAllowedHourCb: function() {
                  var x = this, b;
                  if (this.allowedHours instanceof Array ? b = function(M) {
                    return x.allowedHours.includes(M);
                  } : b = this.allowedHours, !this.min && !this.max)
                    return b;
                  var P = this.min ? Number(this.min.split(":")[0]) : 0, O = this.max ? Number(this.max.split(":")[0]) : 23;
                  return function(T) {
                    return T >= P * 1 && T <= O * 1 && (!b || b(T));
                  };
                },
                isAllowedMinuteCb: function() {
                  var x = this, b, P = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour);
                  if (this.allowedMinutes instanceof Array ? b = function(j) {
                    return x.allowedMinutes.includes(j);
                  } : b = this.allowedMinutes, !this.min && !this.max)
                    return P ? b : function() {
                      return !1;
                    };
                  var O = p(this.min ? this.min.split(":").map(Number) : [0, 0], 2), T = O[0], M = O[1], L = p(this.max ? this.max.split(":").map(Number) : [23, 59], 2), A = L[0], D = L[1], I = T * 60 + M * 1, w = A * 60 + D * 1;
                  return function(B) {
                    var j = 60 * x.inputHour + B;
                    return j >= I && j <= w && P && (!b || b(B));
                  };
                },
                isAllowedSecondCb: function() {
                  var x = this, b, P = !this.isAllowedHourCb || this.inputHour === null || this.isAllowedHourCb(this.inputHour), O = P && (!this.isAllowedMinuteCb || this.inputMinute === null || this.isAllowedMinuteCb(this.inputMinute));
                  if (this.allowedSeconds instanceof Array ? b = function(rt) {
                    return x.allowedSeconds.includes(rt);
                  } : b = this.allowedSeconds, !this.min && !this.max)
                    return O ? b : function() {
                      return !1;
                    };
                  var T = p(this.min ? this.min.split(":").map(Number) : [0, 0, 0], 3), M = T[0], L = T[1], A = T[2], D = p(this.max ? this.max.split(":").map(Number) : [23, 59, 59], 3), I = D[0], w = D[1], B = D[2], j = M * 3600 + L * 60 + (A || 0) * 1, k = I * 3600 + w * 60 + (B || 0) * 1;
                  return function(X) {
                    var rt = 3600 * x.inputHour + 60 * x.inputMinute + X;
                    return rt >= j && rt <= k && O && (!b || b(X));
                  };
                },
                isAmPm: function() {
                  return this.format === "ampm";
                }
              },
              watch: {
                activePicker: "setPicker",
                selecting: "emitPicker",
                value: "setInputData"
              },
              mounted: function() {
                this.setInputData(this.value), this.$on("update:period", this.setPeriod);
              },
              methods: {
                genValue: function() {
                  return this.inputHour != null && this.inputMinute != null && (!this.useSeconds || this.inputSecond != null) ? Object(u.default)(this.inputHour) + ":" + Object(u.default)(this.inputMinute) + (this.useSeconds ? ":" + Object(u.default)(this.inputSecond) : "") : null;
                },
                emitValue: function() {
                  var x = this.genValue();
                  x !== null && this.$emit("input", x);
                },
                emitPicker: function(x) {
                  var b = "HOUR";
                  x === h.SelectingTimes.Minute ? b = "MINUTE" : x === h.SelectingTimes.Second && (b = "SECOND"), this.$emit("update:active-picker", b);
                },
                setPicker: function(x) {
                  x === "HOUR" ? this.selecting = h.SelectingTimes.Hour : x === "MINUTE" ? this.selecting = h.SelectingTimes.Minute : x === "SECOND" && this.useSeconds && (this.selecting = h.SelectingTimes.Second);
                },
                setPeriod: function(x) {
                  if (this.period = x, this.inputHour != null) {
                    var b = this.inputHour + (x === "am" ? -12 : 12);
                    this.inputHour = this.firstAllowed("hour", b), this.emitValue();
                  }
                },
                setInputData: function(x) {
                  if (x == null || x === "")
                    this.inputHour = null, this.inputMinute = null, this.inputSecond = null;
                  else if (x instanceof Date)
                    this.inputHour = x.getHours(), this.inputMinute = x.getMinutes(), this.inputSecond = x.getSeconds();
                  else {
                    var b = p(x.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6), 6), P = b[1], O = b[2], T = b[4], M = b[5];
                    this.inputHour = M ? this.convert12to24(parseInt(P, 10), M) : parseInt(P, 10), this.inputMinute = parseInt(O, 10), this.inputSecond = parseInt(T || 0, 10);
                  }
                  this.period = this.inputHour == null || this.inputHour < 12 ? "am" : "pm";
                },
                convert24to12: function(x) {
                  return x ? (x - 1) % 12 + 1 : 12;
                },
                convert12to24: function(x, b) {
                  return x % 12 + (b === "pm" ? 12 : 0);
                },
                onInput: function(x) {
                  this.selecting === h.SelectingTimes.Hour ? this.inputHour = this.isAmPm ? this.convert12to24(x, this.period) : x : this.selecting === h.SelectingTimes.Minute ? this.inputMinute = x : this.inputSecond = x, this.emitValue();
                },
                onChange: function(x) {
                  this.$emit("click:" + E[this.selecting], x);
                  var b = this.selecting === (this.useSeconds ? h.SelectingTimes.Second : h.SelectingTimes.Minute);
                  if (this.selecting === h.SelectingTimes.Hour ? this.selecting = h.SelectingTimes.Minute : this.useSeconds && this.selecting === h.SelectingTimes.Minute && (this.selecting = h.SelectingTimes.Second), !(this.inputHour === this.lazyInputHour && this.inputMinute === this.lazyInputMinute && (!this.useSeconds || this.inputSecond === this.lazyInputSecond))) {
                    var P = this.genValue();
                    P !== null && (this.lazyInputHour = this.inputHour, this.lazyInputMinute = this.inputMinute, this.useSeconds && (this.lazyInputSecond = this.inputSecond), b && this.$emit("change", P));
                  }
                },
                firstAllowed: function(x, b) {
                  var P = x === "hour" ? this.isAllowedHourCb : x === "minute" ? this.isAllowedMinuteCb : this.isAllowedSecondCb;
                  if (!P)
                    return b;
                  var O = x === "minute" || x === "second" ? y : this.isAmPm ? b < 12 ? m : v : g, T = O.find(function(M) {
                    return P((M + b) % O.length + O[0]);
                  });
                  return ((T || 0) + b) % O.length + O[0];
                },
                genClock: function() {
                  return this.$createElement(o.default, {
                    props: {
                      allowedValues: this.selecting === h.SelectingTimes.Hour ? this.isAllowedHourCb : this.selecting === h.SelectingTimes.Minute ? this.isAllowedMinuteCb : this.isAllowedSecondCb,
                      color: this.color,
                      dark: this.dark,
                      disabled: this.disabled,
                      double: this.selecting === h.SelectingTimes.Hour && !this.isAmPm,
                      format: this.selecting === h.SelectingTimes.Hour ? this.isAmPm ? this.convert24to12 : function(x) {
                        return x;
                      } : function(x) {
                        return Object(u.default)(x, 2);
                      },
                      light: this.light,
                      max: this.selecting === h.SelectingTimes.Hour ? this.isAmPm && this.period === "am" ? 11 : 23 : 59,
                      min: this.selecting === h.SelectingTimes.Hour && this.isAmPm && this.period === "pm" ? 12 : 0,
                      readonly: this.readonly,
                      scrollable: this.scrollable,
                      size: Number(this.width) - (!this.fullWidth && this.landscape ? 80 : 20),
                      step: this.selecting === h.SelectingTimes.Hour ? 1 : 5,
                      value: this.selecting === h.SelectingTimes.Hour ? this.inputHour : this.selecting === h.SelectingTimes.Minute ? this.inputMinute : this.inputSecond
                    },
                    on: {
                      input: this.onInput,
                      change: this.onChange
                    },
                    ref: "clock"
                  });
                },
                genClockAmPm: function() {
                  return this.$createElement("div", this.setTextColor(this.color || "primary", {
                    staticClass: "v-time-picker-clock__ampm"
                  }), [this.genPickerButton("period", "am", this.$vuetify.lang.t("$vuetify.timePicker.am"), this.disabled || this.readonly), this.genPickerButton("period", "pm", this.$vuetify.lang.t("$vuetify.timePicker.pm"), this.disabled || this.readonly)]);
                },
                genPickerBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-time-picker-clock__container",
                    key: this.selecting
                  }, [!this.ampmInTitle && this.isAmPm && this.genClockAmPm(), this.genClock()]);
                },
                genPickerTitle: function() {
                  var x = this;
                  return this.$createElement(a.default, {
                    props: {
                      ampm: this.isAmPm,
                      ampmReadonly: this.isAmPm && !this.ampmInTitle,
                      disabled: this.disabled,
                      hour: this.inputHour,
                      minute: this.inputMinute,
                      second: this.inputSecond,
                      period: this.period,
                      readonly: this.readonly,
                      useSeconds: this.useSeconds,
                      selecting: this.selecting
                    },
                    on: {
                      "update:selecting": function(P) {
                        return x.selecting = P;
                      },
                      "update:period": function(P) {
                        return x.$emit("update:period", P);
                      }
                    },
                    ref: "title",
                    slot: "title"
                  });
                }
              },
              render: function() {
                return this.genPicker("v-picker--time");
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerClock.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerClock.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerClock.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerClock.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimePickerClock.sass */
              "./src/components/VTimePicker/VTimePickerClock.sass"
            );
            var a = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = function() {
              return f = Object.assign || function(d) {
                for (var u, c = 1, h = arguments.length; c < h; c++) {
                  u = arguments[c];
                  for (var p in u)
                    Object.prototype.hasOwnProperty.call(u, p) && (d[p] = u[p]);
                }
                return d;
              }, f.apply(this, arguments);
            };
            r.default = Object(l.default)(
              a.default,
              o.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker-clock",
              props: {
                allowedValues: Function,
                ampm: Boolean,
                disabled: Boolean,
                double: Boolean,
                format: {
                  type: Function,
                  default: function(u) {
                    return u;
                  }
                },
                max: {
                  type: Number,
                  required: !0
                },
                min: {
                  type: Number,
                  required: !0
                },
                scrollable: Boolean,
                readonly: Boolean,
                rotate: {
                  type: Number,
                  default: 0
                },
                step: {
                  type: Number,
                  default: 1
                },
                value: Number
              },
              data: function() {
                return {
                  inputValue: this.value,
                  isDragging: !1,
                  valueOnMouseDown: null,
                  valueOnMouseUp: null
                };
              },
              computed: {
                count: function() {
                  return this.max - this.min + 1;
                },
                degreesPerUnit: function() {
                  return 360 / this.roundCount;
                },
                degrees: function() {
                  return this.degreesPerUnit * Math.PI / 180;
                },
                displayedValue: function() {
                  return this.value == null ? this.min : this.value;
                },
                innerRadiusScale: function() {
                  return 0.62;
                },
                roundCount: function() {
                  return this.double ? this.count / 2 : this.count;
                }
              },
              watch: {
                value: function(u) {
                  this.inputValue = u;
                }
              },
              methods: {
                wheel: function(u) {
                  u.preventDefault();
                  var c = Math.sign(-u.deltaY || 1), h = this.displayedValue;
                  do
                    h = h + c, h = (h - this.min + this.count) % this.count + this.min;
                  while (!this.isAllowed(h) && h !== this.displayedValue);
                  h !== this.displayedValue && this.update(h);
                },
                isInner: function(u) {
                  return this.double && u - this.min >= this.roundCount;
                },
                handScale: function(u) {
                  return this.isInner(u) ? this.innerRadiusScale : 1;
                },
                isAllowed: function(u) {
                  return !this.allowedValues || this.allowedValues(u);
                },
                genValues: function() {
                  for (var u = [], c = this.min; c <= this.max; c = c + this.step) {
                    var h = c === this.value && (this.color || "accent");
                    u.push(this.$createElement("span", this.setBackgroundColor(h, {
                      staticClass: "v-time-picker-clock__item",
                      class: {
                        "v-time-picker-clock__item--active": c === this.displayedValue,
                        "v-time-picker-clock__item--disabled": this.disabled || !this.isAllowed(c)
                      },
                      style: this.getTransform(c),
                      domProps: {
                        innerHTML: "<span>" + this.format(c) + "</span>"
                      }
                    })));
                  }
                  return u;
                },
                genHand: function() {
                  var u = "scaleY(" + this.handScale(this.displayedValue) + ")", c = this.rotate + this.degreesPerUnit * (this.displayedValue - this.min), h = this.value != null && (this.color || "accent");
                  return this.$createElement("div", this.setBackgroundColor(h, {
                    staticClass: "v-time-picker-clock__hand",
                    class: {
                      "v-time-picker-clock__hand--inner": this.isInner(this.value)
                    },
                    style: {
                      transform: "rotate(" + c + "deg) " + u
                    }
                  }));
                },
                getTransform: function(u) {
                  var c = this.getPosition(u), h = c.x, p = c.y;
                  return {
                    left: 50 + h * 50 + "%",
                    top: 50 + p * 50 + "%"
                  };
                },
                getPosition: function(u) {
                  var c = this.rotate * Math.PI / 180;
                  return {
                    x: Math.sin((u - this.min) * this.degrees + c) * this.handScale(u),
                    y: -Math.cos((u - this.min) * this.degrees + c) * this.handScale(u)
                  };
                },
                onMouseDown: function(u) {
                  u.preventDefault(), this.valueOnMouseDown = null, this.valueOnMouseUp = null, this.isDragging = !0, this.onDragMove(u);
                },
                onMouseUp: function(u) {
                  u.stopPropagation(), this.isDragging = !1, this.valueOnMouseUp !== null && this.isAllowed(this.valueOnMouseUp) && this.$emit("change", this.valueOnMouseUp);
                },
                onDragMove: function(u) {
                  if (u.preventDefault(), !(!this.isDragging && u.type !== "click" || !this.$refs.clock))
                    for (var c = this.$refs.clock.getBoundingClientRect(), h = c.width, p = c.top, g = c.left, m = this.$refs.innerClock.getBoundingClientRect().width, v = ("touches" in u) ? u.touches[0] : u, y = v.clientX, E = v.clientY, C = {
                      x: h / 2,
                      y: -h / 2
                    }, x = {
                      x: y - g,
                      y: p - E
                    }, b = Math.round(this.angle(C, x) - this.rotate + 360) % 360, P = this.double && this.euclidean(C, x) < (m + m * this.innerRadiusScale) / 4, O = Math.ceil(15 / this.degreesPerUnit), T, M = 0; M < O; M++) {
                      if (T = this.angleToValue(b + M * this.degreesPerUnit, P), this.isAllowed(T))
                        return this.setMouseDownValue(T);
                      if (T = this.angleToValue(b - M * this.degreesPerUnit, P), this.isAllowed(T))
                        return this.setMouseDownValue(T);
                    }
                },
                angleToValue: function(u, c) {
                  var h = (Math.round(u / this.degreesPerUnit) + (c ? this.roundCount : 0)) % this.count + this.min;
                  return u < 360 - this.degreesPerUnit / 2 ? h : c ? this.max - this.roundCount + 1 : this.min;
                },
                setMouseDownValue: function(u) {
                  this.valueOnMouseDown === null && (this.valueOnMouseDown = u), this.valueOnMouseUp = u, this.update(u);
                },
                update: function(u) {
                  this.inputValue !== u && (this.inputValue = u, this.$emit("input", u));
                },
                euclidean: function(u, c) {
                  var h = c.x - u.x, p = c.y - u.y;
                  return Math.sqrt(h * h + p * p);
                },
                angle: function(u, c) {
                  var h = 2 * Math.atan2(c.y - u.y - this.euclidean(u, c), c.x - u.x);
                  return Math.abs(h * 180 / Math.PI);
                }
              },
              render: function(u) {
                var c = this, h = {
                  staticClass: "v-time-picker-clock",
                  class: f({
                    "v-time-picker-clock--indeterminate": this.value == null
                  }, this.themeClasses),
                  on: this.readonly || this.disabled ? void 0 : {
                    mousedown: this.onMouseDown,
                    mouseup: this.onMouseUp,
                    mouseleave: function(g) {
                      return c.isDragging && c.onMouseUp(g);
                    },
                    touchstart: this.onMouseDown,
                    touchend: this.onMouseUp,
                    mousemove: this.onDragMove,
                    touchmove: this.onDragMove
                  },
                  ref: "clock"
                };
                return this.scrollable && h.on && (h.on.wheel = this.wheel), u("div", h, [u("div", {
                  staticClass: "v-time-picker-clock__inner",
                  ref: "innerClock"
                }, [this.genHand(), this.genValues()])]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerTitle.sass": (
          /*!**********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerTitle.sass ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimePicker/VTimePickerTitle.ts": (
          /*!********************************************************!*\
            !*** ./src/components/VTimePicker/VTimePickerTitle.ts ***!
            \********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimePickerTitle.sass */
              "./src/components/VTimePicker/VTimePickerTitle.sass"
            );
            var a = i(
              /*! ../../mixins/picker-button */
              "./src/mixins/picker-button/index.ts"
            ), o = i(
              /*! ../VDatePicker/util */
              "./src/components/VDatePicker/util/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ./SelectingTimes */
              "./src/components/VTimePicker/SelectingTimes.ts"
            );
            r.default = Object(l.default)(
              a.default
              /* @vue/component */
            ).extend({
              name: "v-time-picker-title",
              props: {
                ampm: Boolean,
                ampmReadonly: Boolean,
                disabled: Boolean,
                hour: Number,
                minute: Number,
                second: Number,
                period: {
                  type: String,
                  validator: function(u) {
                    return u === "am" || u === "pm";
                  }
                },
                readonly: Boolean,
                useSeconds: Boolean,
                selecting: Number
              },
              methods: {
                genTime: function() {
                  var u = this.hour;
                  this.ampm && (u = u ? (u - 1) % 12 + 1 : 12);
                  var c = this.hour == null ? "--" : this.ampm ? String(u) : Object(o.pad)(u), h = this.minute == null ? "--" : Object(o.pad)(this.minute), p = [this.genPickerButton("selecting", f.SelectingTimes.Hour, c, this.disabled), this.$createElement("span", ":"), this.genPickerButton("selecting", f.SelectingTimes.Minute, h, this.disabled)];
                  if (this.useSeconds) {
                    var g = this.second == null ? "--" : Object(o.pad)(this.second);
                    p.push(this.$createElement("span", ":")), p.push(this.genPickerButton("selecting", f.SelectingTimes.Second, g, this.disabled));
                  }
                  return this.$createElement("div", {
                    class: "v-time-picker-title__time"
                  }, p);
                },
                genAmPm: function() {
                  return this.$createElement("div", {
                    staticClass: "v-time-picker-title__ampm",
                    class: {
                      "v-time-picker-title__ampm--readonly": this.ampmReadonly
                    }
                  }, [!this.ampmReadonly || this.period === "am" ? this.genPickerButton("period", "am", this.$vuetify.lang.t("$vuetify.timePicker.am"), this.disabled || this.readonly) : null, !this.ampmReadonly || this.period === "pm" ? this.genPickerButton("period", "pm", this.$vuetify.lang.t("$vuetify.timePicker.pm"), this.disabled || this.readonly) : null]);
                }
              },
              render: function(u) {
                var c = [this.genTime()];
                return this.ampm && c.push(this.genAmPm()), u("div", {
                  staticClass: "v-time-picker-title"
                }, c);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimePicker/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTimePicker/index.ts ***!
            \*********************************************/
          /*! exports provided: VTimePicker, VTimePickerClock, VTimePickerTitle, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimePicker */
              "./src/components/VTimePicker/VTimePicker.ts"
            );
            i.d(r, "VTimePicker", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTimePickerClock */
              "./src/components/VTimePicker/VTimePickerClock.ts"
            );
            i.d(r, "VTimePickerClock", function() {
              return o.default;
            });
            var l = i(
              /*! ./VTimePickerTitle */
              "./src/components/VTimePicker/VTimePickerTitle.ts"
            );
            i.d(r, "VTimePickerTitle", function() {
              return l.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTimePicker: a.default,
                VTimePickerClock: o.default,
                VTimePickerTitle: l.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTimeline/VTimeline.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTimeline/VTimeline.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTimeline/VTimeline.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTimeline/VTimeline.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTimeline.sass */
              "./src/components/VTimeline/VTimeline.sass"
            );
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = Object(a.default)(
              o.default
              /* @vue/component */
            ).extend({
              name: "v-timeline",
              provide: function() {
                return {
                  timeline: this
                };
              },
              props: {
                alignTop: Boolean,
                dense: Boolean,
                reverse: Boolean
              },
              computed: {
                classes: function() {
                  return l({
                    "v-timeline--align-top": this.alignTop,
                    "v-timeline--dense": this.dense,
                    "v-timeline--reverse": this.reverse
                  }, this.themeClasses);
                }
              },
              render: function(d) {
                return d("div", {
                  staticClass: "v-timeline",
                  class: this.classes
                }, this.$slots.default);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimeline/VTimelineItem.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTimeline/VTimelineItem.ts ***!
            \***************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = Object(a.default)(
              f.default,
              l.default
              /* @vue/component */
            );
            r.default = u.extend().extend({
              name: "v-timeline-item",
              inject: ["timeline"],
              props: {
                color: {
                  type: String,
                  default: "primary"
                },
                fillDot: Boolean,
                hideDot: Boolean,
                icon: String,
                iconColor: String,
                large: Boolean,
                left: Boolean,
                right: Boolean,
                small: Boolean
              },
              computed: {
                hasIcon: function() {
                  return !!this.icon || !!this.$slots.icon;
                }
              },
              methods: {
                genBody: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__body"
                  }, this.$slots.default);
                },
                genIcon: function() {
                  return this.$slots.icon ? this.$slots.icon : this.$createElement(o.default, {
                    props: {
                      color: this.iconColor,
                      dark: !this.theme.isDark,
                      small: this.small
                    }
                  }, this.icon);
                },
                genInnerDot: function() {
                  var h = this.setBackgroundColor(this.color);
                  return this.$createElement("div", d({
                    staticClass: "v-timeline-item__inner-dot"
                  }, h), [this.hasIcon && this.genIcon()]);
                },
                genDot: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__dot",
                    class: {
                      "v-timeline-item__dot--small": this.small,
                      "v-timeline-item__dot--large": this.large
                    }
                  }, [this.genInnerDot()]);
                },
                genDivider: function() {
                  var h = [];
                  return this.hideDot || h.push(this.genDot()), this.$createElement("div", {
                    staticClass: "v-timeline-item__divider"
                  }, h);
                },
                genOpposite: function() {
                  return this.$createElement("div", {
                    staticClass: "v-timeline-item__opposite"
                  }, this.$slots.opposite);
                }
              },
              render: function(h) {
                var p = [this.genBody(), this.genDivider()];
                return this.$slots.opposite && p.push(this.genOpposite()), h("div", {
                  staticClass: "v-timeline-item",
                  class: d({
                    "v-timeline-item--fill-dot": this.fillDot,
                    "v-timeline-item--before": this.timeline.reverse ? this.right : this.left,
                    "v-timeline-item--after": this.timeline.reverse ? this.left : this.right
                  }, this.themeClasses)
                }, p);
              }
            });
          }
        ),
        /***/
        "./src/components/VTimeline/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTimeline/index.ts ***!
            \*******************************************/
          /*! exports provided: VTimeline, VTimelineItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTimeline */
              "./src/components/VTimeline/VTimeline.ts"
            );
            i.d(r, "VTimeline", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTimelineItem */
              "./src/components/VTimeline/VTimelineItem.ts"
            );
            i.d(r, "VTimelineItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTimeline: a.default,
                VTimelineItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VToolbar/VToolbar.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VToolbar/VToolbar.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VToolbar/VToolbar.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VToolbar/VToolbar.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VToolbar.sass */
              "./src/components/VToolbar/VToolbar.sass"
            );
            var a = i(
              /*! ../VSheet/VSheet */
              "./src/components/VSheet/VSheet.ts"
            ), o = i(
              /*! ../VImg/VImg */
              "./src/components/VImg/VImg.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            };
            r.default = a.default.extend({
              name: "v-toolbar",
              props: {
                absolute: Boolean,
                bottom: Boolean,
                collapse: Boolean,
                dense: Boolean,
                extended: Boolean,
                extensionHeight: {
                  default: 48,
                  type: [Number, String]
                },
                flat: Boolean,
                floating: Boolean,
                prominent: Boolean,
                short: Boolean,
                src: {
                  type: [String, Object],
                  default: ""
                },
                tag: {
                  type: String,
                  default: "header"
                }
              },
              data: function() {
                return {
                  isExtended: !1
                };
              },
              computed: {
                computedHeight: function() {
                  var h = this.computedContentHeight;
                  if (!this.isExtended)
                    return h;
                  var p = parseInt(this.extensionHeight);
                  return this.isCollapsed ? h : h + (isNaN(p) ? 0 : p);
                },
                computedContentHeight: function() {
                  return this.height ? parseInt(this.height) : this.isProminent && this.dense ? 96 : this.isProminent && this.short ? 112 : this.isProminent ? 128 : this.dense ? 48 : this.short || this.$vuetify.breakpoint.smAndDown ? 56 : 64;
                },
                classes: function() {
                  return d(d({}, a.default.options.computed.classes.call(this)), {
                    "v-toolbar": !0,
                    "v-toolbar--absolute": this.absolute,
                    "v-toolbar--bottom": this.bottom,
                    "v-toolbar--collapse": this.collapse,
                    "v-toolbar--collapsed": this.isCollapsed,
                    "v-toolbar--dense": this.dense,
                    "v-toolbar--extended": this.isExtended,
                    "v-toolbar--flat": this.flat,
                    "v-toolbar--floating": this.floating,
                    "v-toolbar--prominent": this.isProminent
                  });
                },
                isCollapsed: function() {
                  return this.collapse;
                },
                isProminent: function() {
                  return this.prominent;
                },
                styles: function() {
                  return d(d({}, this.measurableStyles), {
                    height: Object(l.convertToUnit)(this.computedHeight)
                  });
                }
              },
              created: function() {
                var h = this, p = [["app", "<v-app-bar app>"], ["manual-scroll", '<v-app-bar :value="false">'], ["clipped-left", "<v-app-bar clipped-left>"], ["clipped-right", "<v-app-bar clipped-right>"], ["inverted-scroll", "<v-app-bar inverted-scroll>"], ["scroll-off-screen", "<v-app-bar scroll-off-screen>"], ["scroll-target", "<v-app-bar scroll-target>"], ["scroll-threshold", "<v-app-bar scroll-threshold>"], ["card", "<v-app-bar flat>"]];
                p.forEach(function(g) {
                  var m = u(g, 2), v = m[0], y = m[1];
                  h.$attrs.hasOwnProperty(v) && Object(f.breaking)(v, y, h);
                });
              },
              methods: {
                genBackground: function() {
                  var h = {
                    height: Object(l.convertToUnit)(this.computedHeight),
                    src: this.src
                  }, p = this.$scopedSlots.img ? this.$scopedSlots.img({
                    props: h
                  }) : this.$createElement(o.default, {
                    props: h
                  });
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__image"
                  }, [p]);
                },
                genContent: function() {
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__content",
                    style: {
                      height: Object(l.convertToUnit)(this.computedContentHeight)
                    }
                  }, Object(l.getSlot)(this));
                },
                genExtension: function() {
                  return this.$createElement("div", {
                    staticClass: "v-toolbar__extension",
                    style: {
                      height: Object(l.convertToUnit)(this.extensionHeight)
                    }
                  }, Object(l.getSlot)(this, "extension"));
                }
              },
              render: function(h) {
                this.isExtended = this.extended || !!this.$scopedSlots.extension;
                var p = [this.genContent()], g = this.setBackgroundColor(this.color, {
                  class: this.classes,
                  style: this.styles,
                  on: this.$listeners
                });
                return this.isExtended && p.push(this.genExtension()), (this.src || this.$scopedSlots.img) && p.unshift(this.genBackground()), h(this.tag, g, p);
              }
            });
          }
        ),
        /***/
        "./src/components/VToolbar/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VToolbar/index.ts ***!
            \******************************************/
          /*! exports provided: VToolbar, VToolbarItems, VToolbarTitle, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VToolbarItems", function() {
              return f;
            }), i.d(r, "VToolbarTitle", function() {
              return l;
            });
            var a = i(
              /*! ./VToolbar */
              "./src/components/VToolbar/VToolbar.ts"
            );
            i.d(r, "VToolbar", function() {
              return a.default;
            });
            var o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = Object(o.createSimpleFunctional)("v-toolbar__title"), f = Object(o.createSimpleFunctional)("v-toolbar__items");
            r.default = {
              $_vuetify_subcomponents: {
                VToolbar: a.default,
                VToolbarItems: f,
                VToolbarTitle: l
              }
            };
          }
        ),
        /***/
        "./src/components/VTooltip/VTooltip.sass": (
          /*!***********************************************!*\
            !*** ./src/components/VTooltip/VTooltip.sass ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTooltip/VTooltip.ts": (
          /*!*********************************************!*\
            !*** ./src/components/VTooltip/VTooltip.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTooltip.sass */
              "./src/components/VTooltip/VTooltip.sass"
            );
            var a = i(
              /*! ../../mixins/activatable */
              "./src/mixins/activatable/index.ts"
            ), o = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/delayable */
              "./src/mixins/delayable/index.ts"
            ), f = i(
              /*! ../../mixins/dependent */
              "./src/mixins/dependent/index.ts"
            ), d = i(
              /*! ../../mixins/menuable */
              "./src/mixins/menuable/index.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), h = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(h.default)(o.default, l.default, f.default, d.default).extend({
              name: "v-tooltip",
              props: {
                closeDelay: {
                  type: [Number, String],
                  default: 0
                },
                disabled: Boolean,
                openDelay: {
                  type: [Number, String],
                  default: 0
                },
                openOnHover: {
                  type: Boolean,
                  default: !0
                },
                openOnFocus: {
                  type: Boolean,
                  default: !0
                },
                tag: {
                  type: String,
                  default: "span"
                },
                transition: String
              },
              data: function() {
                return {
                  calculatedMinWidth: 0,
                  closeDependents: !1
                };
              },
              computed: {
                calculatedLeft: function() {
                  var g = this.dimensions, m = g.activator, v = g.content, y = !this.bottom && !this.left && !this.top && !this.right, E = this.attach !== !1 ? m.offsetLeft : m.left, C = 0;
                  return this.top || this.bottom || y ? C = E + m.width / 2 - v.width / 2 : (this.left || this.right) && (C = E + (this.right ? m.width : -v.width) + (this.right ? 10 : -10)), this.nudgeLeft && (C -= parseInt(this.nudgeLeft)), this.nudgeRight && (C += parseInt(this.nudgeRight)), this.calcXOverflow(C, this.dimensions.content.width) + "px";
                },
                calculatedTop: function() {
                  var g = this.dimensions, m = g.activator, v = g.content, y = this.attach !== !1 ? m.offsetTop : m.top, E = 0;
                  return this.top || this.bottom ? E = y + (this.bottom ? m.height : -v.height) + (this.bottom ? 10 : -10) : (this.left || this.right) && (E = y + m.height / 2 - v.height / 2), this.nudgeTop && (E -= parseInt(this.nudgeTop)), this.nudgeBottom && (E += parseInt(this.nudgeBottom)), this.attach === !1 && (E += this.pageYOffset), this.calcYOverflow(E) + "px";
                },
                classes: function() {
                  return {
                    "v-tooltip--top": this.top,
                    "v-tooltip--right": this.right,
                    "v-tooltip--bottom": this.bottom,
                    "v-tooltip--left": this.left,
                    "v-tooltip--attached": this.attach === "" || this.attach === !0 || this.attach === "attach"
                  };
                },
                computedTransition: function() {
                  return this.transition ? this.transition : this.isActive ? "scale-transition" : "fade-transition";
                },
                offsetY: function() {
                  return this.top || this.bottom;
                },
                offsetX: function() {
                  return this.left || this.right;
                },
                styles: function() {
                  return {
                    left: this.calculatedLeft,
                    maxWidth: Object(u.convertToUnit)(this.maxWidth),
                    minWidth: Object(u.convertToUnit)(this.minWidth),
                    top: this.calculatedTop,
                    zIndex: this.zIndex || this.activeZIndex
                  };
                }
              },
              beforeMount: function() {
                var g = this;
                this.$nextTick(function() {
                  g.value && g.callActivate();
                });
              },
              mounted: function() {
                Object(u.getSlotType)(this, "activator", !0) === "v-slot" && Object(c.consoleError)(`v-tooltip's activator slot must be bound, try '<template #activator="data"><v-btn v-on="data.on>'`, this);
              },
              methods: {
                activate: function() {
                  this.updateDimensions(), requestAnimationFrame(this.startTransition);
                },
                deactivate: function() {
                  this.runDelay("close");
                },
                genActivatorListeners: function() {
                  var g = this, m = a.default.options.methods.genActivatorListeners.call(this);
                  return this.openOnFocus && (m.focus = function(v) {
                    g.getActivator(v), g.runDelay("open");
                  }, m.blur = function(v) {
                    g.getActivator(v), g.runDelay("close");
                  }), m.keydown = function(v) {
                    v.keyCode === u.keyCodes.esc && (g.getActivator(v), g.runDelay("close"));
                  }, m;
                },
                genActivatorAttributes: function() {
                  return {
                    "aria-haspopup": !0,
                    "aria-expanded": String(this.isActive)
                  };
                },
                genTransition: function() {
                  var g = this.genContent();
                  return this.computedTransition ? this.$createElement("transition", {
                    props: {
                      name: this.computedTransition
                    }
                  }, [g]) : g;
                },
                genContent: function() {
                  var g;
                  return this.$createElement("div", this.setBackgroundColor(this.color, {
                    staticClass: "v-tooltip__content",
                    class: (g = {}, g[this.contentClass] = !0, g.menuable__content__active = this.isActive, g["v-tooltip__content--fixed"] = this.activatorFixed, g),
                    style: this.styles,
                    attrs: this.getScopeIdAttrs(),
                    directives: [{
                      name: "show",
                      value: this.isContentActive
                    }],
                    ref: "content"
                  }), this.getContentSlot());
                }
              },
              render: function(g) {
                var m = this;
                return g(this.tag, {
                  staticClass: "v-tooltip",
                  class: this.classes
                }, [this.showLazyContent(function() {
                  return [m.genTransition()];
                }), this.genActivator()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VTooltip/index.ts": (
          /*!******************************************!*\
            !*** ./src/components/VTooltip/index.ts ***!
            \******************************************/
          /*! exports provided: VTooltip, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTooltip */
              "./src/components/VTooltip/VTooltip.ts"
            );
            i.d(r, "VTooltip", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeview.sass": (
          /*!*************************************************!*\
            !*** ./src/components/VTreeview/VTreeview.sass ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeview.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VTreeview/VTreeview.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VTreeview.sass */
              "./src/components/VTreeview/VTreeview.sass"
            );
            var a = i(
              /*! ./VTreeviewNode */
              "./src/components/VTreeview/VTreeviewNode.ts"
            ), o = i(
              /*! ../../mixins/themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), c = i(
              /*! ./util/filterTreeItems */
              "./src/components/VTreeview/util/filterTreeItems.ts"
            ), h = function() {
              return h = Object.assign || function(v) {
                for (var y, E = 1, C = arguments.length; E < C; E++) {
                  y = arguments[E];
                  for (var x in y)
                    Object.prototype.hasOwnProperty.call(y, x) && (v[x] = y[x]);
                }
                return v;
              }, h.apply(this, arguments);
            }, p = function(v, y) {
              var E = typeof Symbol == "function" && v[Symbol.iterator];
              if (!E)
                return v;
              var C = E.call(v), x, b = [], P;
              try {
                for (; (y === void 0 || y-- > 0) && !(x = C.next()).done; )
                  b.push(x.value);
              } catch (O) {
                P = {
                  error: O
                };
              } finally {
                try {
                  x && !x.done && (E = C.return) && E.call(C);
                } finally {
                  if (P)
                    throw P.error;
                }
              }
              return b;
            }, g = function(v, y, E) {
              if (E || arguments.length === 2)
                for (var C = 0, x = y.length, b; C < x; C++)
                  (b || !(C in y)) && (b || (b = Array.prototype.slice.call(y, 0, C)), b[C] = y[C]);
              return v.concat(b || Array.prototype.slice.call(y));
            }, m = function(v) {
              var y = typeof Symbol == "function" && Symbol.iterator, E = y && v[y], C = 0;
              if (E)
                return E.call(v);
              if (v && typeof v.length == "number")
                return {
                  next: function() {
                    return v && C >= v.length && (v = void 0), {
                      value: v && v[C++],
                      done: !v
                    };
                  }
                };
              throw new TypeError(y ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = Object(d.default)(
              Object(l.provide)("treeview"),
              o.default
              /* @vue/component */
            ).extend({
              name: "v-treeview",
              provide: function() {
                return {
                  treeview: this
                };
              },
              props: h({
                active: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                dense: Boolean,
                disabled: Boolean,
                filter: Function,
                hoverable: Boolean,
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                multipleActive: Boolean,
                open: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                openAll: Boolean,
                returnObject: {
                  type: Boolean,
                  default: !1
                  // TODO: Should be true in next major
                },
                search: String,
                value: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              }, a.VTreeviewNodeProps),
              data: function() {
                return {
                  level: -1,
                  activeCache: /* @__PURE__ */ new Set(),
                  nodes: {},
                  openCache: /* @__PURE__ */ new Set(),
                  selectedCache: /* @__PURE__ */ new Set()
                };
              },
              computed: {
                excludedItems: function() {
                  var y = /* @__PURE__ */ new Set();
                  if (!this.search)
                    return y;
                  for (var E = 0; E < this.items.length; E++)
                    Object(c.filterTreeItems)(this.filter || c.filterTreeItem, this.items[E], this.search, this.itemKey, this.itemText, this.itemChildren, y);
                  return y;
                }
              },
              watch: {
                items: {
                  handler: function() {
                    var y = this, E = Object.keys(this.nodes).map(function(P) {
                      return Object(f.getObjectValueByPath)(y.nodes[P].item, y.itemKey);
                    }), C = this.getKeys(this.items), x = Object(f.arrayDiff)(C, E);
                    if (!(!x.length && C.length < E.length)) {
                      x.forEach(function(P) {
                        return delete y.nodes[P];
                      });
                      var b = g([], p(this.selectedCache), !1);
                      this.selectedCache = /* @__PURE__ */ new Set(), this.activeCache = /* @__PURE__ */ new Set(), this.openCache = /* @__PURE__ */ new Set(), this.buildTree(this.items), Object(f.deepEqual)(b, g([], p(this.selectedCache), !1)) || this.emitSelected();
                    }
                  },
                  deep: !0
                },
                active: function(y) {
                  this.handleNodeCacheWatcher(y, this.activeCache, this.updateActive, this.emitActive);
                },
                value: function(y) {
                  this.handleNodeCacheWatcher(y, this.selectedCache, this.updateSelected, this.emitSelected);
                },
                open: function(y) {
                  this.handleNodeCacheWatcher(y, this.openCache, this.updateOpen, this.emitOpen);
                }
              },
              created: function() {
                var y, E, C, x, b = this, P = function(w) {
                  return b.returnObject ? Object(f.getObjectValueByPath)(w, b.itemKey) : w;
                };
                this.buildTree(this.items);
                try {
                  for (var O = m(this.value.map(P)), T = O.next(); !T.done; T = O.next()) {
                    var M = T.value;
                    this.updateSelected(M, !0, !0);
                  }
                } catch (I) {
                  y = {
                    error: I
                  };
                } finally {
                  try {
                    T && !T.done && (E = O.return) && E.call(O);
                  } finally {
                    if (y)
                      throw y.error;
                  }
                }
                try {
                  for (var L = m(this.active.map(P)), A = L.next(); !A.done; A = L.next()) {
                    var D = A.value;
                    this.updateActive(D, !0);
                  }
                } catch (I) {
                  C = {
                    error: I
                  };
                } finally {
                  try {
                    A && !A.done && (x = L.return) && x.call(L);
                  } finally {
                    if (C)
                      throw C.error;
                  }
                }
              },
              mounted: function() {
                var y = this;
                (this.$slots.prepend || this.$slots.append) && Object(u.consoleWarn)("The prepend and append slots require a slot-scope attribute", this), this.openAll ? this.updateAll(!0) : (this.open.forEach(function(E) {
                  return y.updateOpen(y.returnObject ? Object(f.getObjectValueByPath)(E, y.itemKey) : E, !0);
                }), this.emitOpen());
              },
              methods: {
                /** @public */
                updateAll: function(y) {
                  var E = this;
                  Object.keys(this.nodes).forEach(function(C) {
                    return E.updateOpen(Object(f.getObjectValueByPath)(E.nodes[C].item, E.itemKey), y);
                  }), this.emitOpen();
                },
                getKeys: function(y, E) {
                  E === void 0 && (E = []);
                  for (var C = 0; C < y.length; C++) {
                    var x = Object(f.getObjectValueByPath)(y[C], this.itemKey);
                    E.push(x);
                    var b = Object(f.getObjectValueByPath)(y[C], this.itemChildren);
                    b && E.push.apply(E, g([], p(this.getKeys(b)), !1));
                  }
                  return E;
                },
                buildTree: function(y, E) {
                  var C = this, x;
                  E === void 0 && (E = null);
                  for (var b = 0; b < y.length; b++) {
                    var P = y[b], O = Object(f.getObjectValueByPath)(P, this.itemKey), T = (x = Object(f.getObjectValueByPath)(P, this.itemChildren)) !== null && x !== void 0 ? x : [], M = this.nodes.hasOwnProperty(O) ? this.nodes[O] : {
                      isSelected: !1,
                      isIndeterminate: !1,
                      isActive: !1,
                      isOpen: !1,
                      vnode: null
                    }, L = {
                      vnode: M.vnode,
                      parent: E,
                      children: T.map(function(w) {
                        return Object(f.getObjectValueByPath)(w, C.itemKey);
                      }),
                      item: P
                    };
                    if (this.buildTree(T, O), this.selectionType !== "independent" && E !== null && !this.nodes.hasOwnProperty(O) && this.nodes.hasOwnProperty(E) ? L.isSelected = this.nodes[E].isSelected : (L.isSelected = M.isSelected, L.isIndeterminate = M.isIndeterminate), L.isActive = M.isActive, L.isOpen = M.isOpen, this.nodes[O] = L, T.length && this.selectionType !== "independent") {
                      var A = this.calculateState(O, this.nodes), D = A.isSelected, I = A.isIndeterminate;
                      L.isSelected = D, L.isIndeterminate = I;
                    }
                    this.nodes[O].isSelected && (this.selectionType === "independent" || L.children.length === 0) && this.selectedCache.add(O), this.nodes[O].isActive && this.activeCache.add(O), this.nodes[O].isOpen && this.openCache.add(O), this.updateVnodeState(O);
                  }
                },
                calculateState: function(y, E) {
                  var C = E[y].children, x = C.reduce(function(O, T) {
                    return O[0] += +!!E[T].isSelected, O[1] += +!!E[T].isIndeterminate, O;
                  }, [0, 0]), b = !!C.length && x[0] === C.length, P = !b && (x[0] > 0 || x[1] > 0);
                  return {
                    isSelected: b,
                    isIndeterminate: P
                  };
                },
                emitOpen: function() {
                  this.emitNodeCache("update:open", this.openCache);
                },
                emitSelected: function() {
                  this.emitNodeCache("input", this.selectedCache);
                },
                emitActive: function() {
                  this.emitNodeCache("update:active", this.activeCache);
                },
                emitNodeCache: function(y, E) {
                  var C = this;
                  this.$emit(y, this.returnObject ? g([], p(E), !1).map(function(x) {
                    return C.nodes[x].item;
                  }) : g([], p(E), !1));
                },
                handleNodeCacheWatcher: function(y, E, C, x) {
                  var b = this;
                  y = this.returnObject ? y.map(function(O) {
                    return Object(f.getObjectValueByPath)(O, b.itemKey);
                  }) : y;
                  var P = g([], p(E), !1);
                  Object(f.deepEqual)(P, y) || (P.forEach(function(O) {
                    return C(O, !1);
                  }), y.forEach(function(O) {
                    return C(O, !0);
                  }), x());
                },
                getDescendants: function(y, E) {
                  E === void 0 && (E = []);
                  var C = this.nodes[y].children;
                  E.push.apply(E, g([], p(C), !1));
                  for (var x = 0; x < C.length; x++)
                    E = this.getDescendants(C[x], E);
                  return E;
                },
                getParents: function(y) {
                  for (var E = this.nodes[y].parent, C = []; E !== null; )
                    C.push(E), E = this.nodes[E].parent;
                  return C;
                },
                register: function(y) {
                  var E = Object(f.getObjectValueByPath)(y.item, this.itemKey);
                  this.nodes[E].vnode = y, this.updateVnodeState(E);
                },
                unregister: function(y) {
                  var E = Object(f.getObjectValueByPath)(y.item, this.itemKey);
                  this.nodes[E] && (this.nodes[E].vnode = null);
                },
                isParent: function(y) {
                  return this.nodes[y].children && this.nodes[y].children.length;
                },
                updateActive: function(y, E) {
                  var C = this;
                  if (this.nodes.hasOwnProperty(y)) {
                    this.multipleActive || this.activeCache.forEach(function(b) {
                      C.nodes[b].isActive = !1, C.updateVnodeState(b), C.activeCache.delete(b);
                    });
                    var x = this.nodes[y];
                    x && (E ? this.activeCache.add(y) : this.activeCache.delete(y), x.isActive = E, this.updateVnodeState(y));
                  }
                },
                updateSelected: function(y, E, C) {
                  var x, b, P, O, T, M;
                  if (C === void 0 && (C = !1), !!this.nodes.hasOwnProperty(y)) {
                    var L = /* @__PURE__ */ new Map();
                    if (this.selectionType !== "independent") {
                      try {
                        for (var A = m(this.getDescendants(y)), D = A.next(); !D.done; D = A.next()) {
                          var I = D.value;
                          (!Object(f.getObjectValueByPath)(this.nodes[I].item, this.itemDisabled) || C) && (this.nodes[I].isSelected = E, this.nodes[I].isIndeterminate = !1, L.set(I, E));
                        }
                      } catch (bt) {
                        x = {
                          error: bt
                        };
                      } finally {
                        try {
                          D && !D.done && (b = A.return) && b.call(A);
                        } finally {
                          if (x)
                            throw x.error;
                        }
                      }
                      var w = this.calculateState(y, this.nodes);
                      this.nodes[y].isSelected = E, this.nodes[y].isIndeterminate = w.isIndeterminate, L.set(y, E);
                      try {
                        for (var B = m(this.getParents(y)), j = B.next(); !j.done; j = B.next()) {
                          var k = j.value, X = this.calculateState(k, this.nodes);
                          this.nodes[k].isSelected = X.isSelected, this.nodes[k].isIndeterminate = X.isIndeterminate, L.set(k, X.isSelected);
                        }
                      } catch (bt) {
                        P = {
                          error: bt
                        };
                      } finally {
                        try {
                          j && !j.done && (O = B.return) && O.call(B);
                        } finally {
                          if (P)
                            throw P.error;
                        }
                      }
                    } else
                      this.nodes[y].isSelected = E, this.nodes[y].isIndeterminate = !1, L.set(y, E);
                    try {
                      for (var rt = m(L.entries()), et = rt.next(); !et.done; et = rt.next()) {
                        var Z = p(et.value, 2), dt = Z[0], vt = Z[1];
                        this.updateVnodeState(dt), !(this.selectionType === "leaf" && this.isParent(dt)) && (vt === !0 ? this.selectedCache.add(dt) : this.selectedCache.delete(dt));
                      }
                    } catch (bt) {
                      T = {
                        error: bt
                      };
                    } finally {
                      try {
                        et && !et.done && (M = rt.return) && M.call(rt);
                      } finally {
                        if (T)
                          throw T.error;
                      }
                    }
                  }
                },
                updateOpen: function(y, E) {
                  var C = this;
                  if (this.nodes.hasOwnProperty(y)) {
                    var x = this.nodes[y], b = Object(f.getObjectValueByPath)(x.item, this.itemChildren);
                    b && !b.length && x.vnode && !x.vnode.hasLoaded ? x.vnode.checkChildren().then(function() {
                      return C.updateOpen(y, E);
                    }) : b && b.length && (x.isOpen = E, x.isOpen ? this.openCache.add(y) : this.openCache.delete(y), this.updateVnodeState(y));
                  }
                },
                updateVnodeState: function(y) {
                  var E = this.nodes[y];
                  E && E.vnode && (E.vnode.isSelected = E.isSelected, E.vnode.isIndeterminate = E.isIndeterminate, E.vnode.isActive = E.isActive, E.vnode.isOpen = E.isOpen);
                },
                isExcluded: function(y) {
                  return !!this.search && this.excludedItems.has(y);
                }
              },
              render: function(y) {
                var E = this, C = this.items.length ? this.items.filter(function(x) {
                  return !E.isExcluded(Object(f.getObjectValueByPath)(x, E.itemKey));
                }).map(function(x) {
                  var b = a.default.options.methods.genChild.bind(E);
                  return b(x, E.disabled || Object(f.getObjectValueByPath)(x, E.itemDisabled));
                }) : this.$slots.default;
                return y("div", {
                  staticClass: "v-treeview",
                  class: h({
                    "v-treeview--hoverable": this.hoverable,
                    "v-treeview--dense": this.dense
                  }, this.themeClasses)
                }, C);
              }
            });
          }
        ),
        /***/
        "./src/components/VTreeview/VTreeviewNode.ts": (
          /*!***************************************************!*\
            !*** ./src/components/VTreeview/VTreeviewNode.ts ***!
            \***************************************************/
          /*! exports provided: VTreeviewNodeProps, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VTreeviewNodeProps", function() {
              return m;
            });
            var a = i(
              /*! ../transitions */
              "./src/components/transitions/index.ts"
            ), o = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), l = i(
              /*! ../../mixins/registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../mixins/colorable */
              "./src/mixins/colorable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(y) {
                for (var E, C = 1, x = arguments.length; C < x; C++) {
                  E = arguments[C];
                  for (var b in E)
                    Object.prototype.hasOwnProperty.call(E, b) && (y[b] = E[b]);
                }
                return y;
              }, c.apply(this, arguments);
            }, h = function(y, E) {
              var C = typeof Symbol == "function" && y[Symbol.iterator];
              if (!C)
                return y;
              var x = C.call(y), b, P = [], O;
              try {
                for (; (E === void 0 || E-- > 0) && !(b = x.next()).done; )
                  P.push(b.value);
              } catch (T) {
                O = {
                  error: T
                };
              } finally {
                try {
                  b && !b.done && (C = x.return) && C.call(x);
                } finally {
                  if (O)
                    throw O.error;
                }
              }
              return P;
            }, p = function(y, E, C) {
              if (C || arguments.length === 2)
                for (var x = 0, b = E.length, P; x < b; x++)
                  (P || !(x in E)) && (P || (P = Array.prototype.slice.call(E, 0, x)), P[x] = E[x]);
              return y.concat(P || Array.prototype.slice.call(E));
            }, g = Object(d.default)(f.default, Object(l.inject)("treeview")), m = {
              activatable: Boolean,
              activeClass: {
                type: String,
                default: "v-treeview-node--active"
              },
              color: {
                type: String,
                default: "primary"
              },
              disablePerNode: Boolean,
              expandIcon: {
                type: String,
                default: "$subgroup"
              },
              indeterminateIcon: {
                type: String,
                default: "$checkboxIndeterminate"
              },
              itemChildren: {
                type: String,
                default: "children"
              },
              itemDisabled: {
                type: String,
                default: "disabled"
              },
              itemKey: {
                type: String,
                default: "id"
              },
              itemText: {
                type: String,
                default: "name"
              },
              loadChildren: Function,
              loadingIcon: {
                type: String,
                default: "$loading"
              },
              offIcon: {
                type: String,
                default: "$checkboxOff"
              },
              onIcon: {
                type: String,
                default: "$checkboxOn"
              },
              openOnClick: Boolean,
              rounded: Boolean,
              selectable: Boolean,
              selectedColor: {
                type: String,
                default: "accent"
              },
              shaped: Boolean,
              transition: Boolean,
              selectionType: {
                type: String,
                default: "leaf",
                validator: function(E) {
                  return ["leaf", "independent"].includes(E);
                }
              }
            }, v = g.extend().extend({
              name: "v-treeview-node",
              inject: {
                treeview: {
                  default: null
                }
              },
              props: c({
                level: Number,
                item: {
                  type: Object,
                  default: function() {
                    return null;
                  }
                },
                parentIsDisabled: Boolean
              }, m),
              data: function() {
                return {
                  hasLoaded: !1,
                  isActive: !1,
                  isIndeterminate: !1,
                  isLoading: !1,
                  isOpen: !1,
                  isSelected: !1
                  // Node is selected (checkbox)
                };
              },
              computed: {
                disabled: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemDisabled) || !this.disablePerNode && this.parentIsDisabled && this.selectionType === "leaf";
                },
                key: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemKey);
                },
                children: function() {
                  var E = this, C = Object(u.getObjectValueByPath)(this.item, this.itemChildren);
                  return C && C.filter(function(x) {
                    return !E.treeview.isExcluded(Object(u.getObjectValueByPath)(x, E.itemKey));
                  });
                },
                text: function() {
                  return Object(u.getObjectValueByPath)(this.item, this.itemText);
                },
                scopedProps: function() {
                  return {
                    item: this.item,
                    leaf: !this.children,
                    selected: this.isSelected,
                    indeterminate: this.isIndeterminate,
                    active: this.isActive,
                    open: this.isOpen
                  };
                },
                computedIcon: function() {
                  return this.isIndeterminate ? this.indeterminateIcon : this.isSelected ? this.onIcon : this.offIcon;
                },
                hasChildren: function() {
                  return !!this.children && (!!this.children.length || !!this.loadChildren);
                }
              },
              created: function() {
                this.treeview.register(this);
              },
              beforeDestroy: function() {
                this.treeview.unregister(this);
              },
              methods: {
                checkChildren: function() {
                  var E = this;
                  return new Promise(function(C) {
                    if (!E.children || E.children.length || !E.loadChildren || E.hasLoaded)
                      return C();
                    E.isLoading = !0, C(E.loadChildren(E.item));
                  }).then(function() {
                    E.isLoading = !1, E.hasLoaded = !0;
                  });
                },
                open: function() {
                  this.isOpen = !this.isOpen, this.treeview.updateOpen(this.key, this.isOpen), this.treeview.emitOpen();
                },
                genLabel: function() {
                  var E = [];
                  return this.$scopedSlots.label ? E.push(this.$scopedSlots.label(this.scopedProps)) : E.push(this.text), this.$createElement("div", {
                    slot: "label",
                    staticClass: "v-treeview-node__label"
                  }, E);
                },
                genPrependSlot: function() {
                  return this.$scopedSlots.prepend ? this.$createElement("div", {
                    staticClass: "v-treeview-node__prepend"
                  }, this.$scopedSlots.prepend(this.scopedProps)) : null;
                },
                genAppendSlot: function() {
                  return this.$scopedSlots.append ? this.$createElement("div", {
                    staticClass: "v-treeview-node__append"
                  }, this.$scopedSlots.append(this.scopedProps)) : null;
                },
                genContent: function() {
                  var E = [this.genPrependSlot(), this.genLabel(), this.genAppendSlot()];
                  return this.$createElement("div", {
                    staticClass: "v-treeview-node__content"
                  }, E);
                },
                genToggle: function() {
                  var E = this;
                  return this.$createElement(o.VIcon, {
                    staticClass: "v-treeview-node__toggle",
                    class: {
                      "v-treeview-node__toggle--open": this.isOpen,
                      "v-treeview-node__toggle--loading": this.isLoading
                    },
                    slot: "prepend",
                    on: {
                      click: function(x) {
                        x.stopPropagation(), !E.isLoading && E.checkChildren().then(function() {
                          return E.open();
                        });
                      }
                    }
                  }, [this.isLoading ? this.loadingIcon : this.expandIcon]);
                },
                genCheckbox: function() {
                  var E = this;
                  return this.$createElement(o.VIcon, {
                    staticClass: "v-treeview-node__checkbox",
                    props: {
                      color: this.isSelected || this.isIndeterminate ? this.selectedColor : void 0,
                      disabled: this.disabled
                    },
                    on: {
                      click: function(x) {
                        x.stopPropagation(), !E.isLoading && E.checkChildren().then(function() {
                          E.$nextTick(function() {
                            E.isSelected = !E.isSelected, E.isIndeterminate = !1, E.treeview.updateSelected(E.key, E.isSelected), E.treeview.emitSelected();
                          });
                        });
                      }
                    }
                  }, [this.computedIcon]);
                },
                genLevel: function(E) {
                  var C = this;
                  return Object(u.createRange)(E).map(function() {
                    return C.$createElement("div", {
                      staticClass: "v-treeview-node__level"
                    });
                  });
                },
                genNode: function() {
                  var E, C = this, x = [this.genContent()];
                  return this.selectable && x.unshift(this.genCheckbox()), this.hasChildren ? x.unshift(this.genToggle()) : x.unshift.apply(x, p([], h(this.genLevel(1)), !1)), x.unshift.apply(x, p([], h(this.genLevel(this.level)), !1)), this.$createElement("div", this.setTextColor(this.isActive && this.color, {
                    staticClass: "v-treeview-node__root",
                    class: (E = {}, E[this.activeClass] = this.isActive, E),
                    on: {
                      click: function() {
                        C.openOnClick && C.hasChildren ? C.checkChildren().then(C.open) : C.activatable && !C.disabled && (C.isActive = !C.isActive, C.treeview.updateActive(C.key, C.isActive), C.treeview.emitActive());
                      }
                    }
                  }), x);
                },
                genChild: function(E, C) {
                  return this.$createElement(v, {
                    key: Object(u.getObjectValueByPath)(E, this.itemKey),
                    props: {
                      activatable: this.activatable,
                      activeClass: this.activeClass,
                      item: E,
                      selectable: this.selectable,
                      selectedColor: this.selectedColor,
                      color: this.color,
                      disablePerNode: this.disablePerNode,
                      expandIcon: this.expandIcon,
                      indeterminateIcon: this.indeterminateIcon,
                      offIcon: this.offIcon,
                      onIcon: this.onIcon,
                      loadingIcon: this.loadingIcon,
                      itemKey: this.itemKey,
                      itemText: this.itemText,
                      itemDisabled: this.itemDisabled,
                      itemChildren: this.itemChildren,
                      loadChildren: this.loadChildren,
                      transition: this.transition,
                      openOnClick: this.openOnClick,
                      rounded: this.rounded,
                      shaped: this.shaped,
                      level: this.level + 1,
                      selectionType: this.selectionType,
                      parentIsDisabled: C
                    },
                    scopedSlots: this.$scopedSlots
                  });
                },
                genChildrenWrapper: function() {
                  var E = this;
                  if (!this.isOpen || !this.children)
                    return null;
                  var C = [this.children.map(function(x) {
                    return E.genChild(x, E.disabled);
                  })];
                  return this.$createElement("div", {
                    staticClass: "v-treeview-node__children"
                  }, C);
                },
                genTransition: function() {
                  return this.$createElement(a.VExpandTransition, [this.genChildrenWrapper()]);
                }
              },
              render: function(E) {
                var C = [this.genNode()];
                return this.transition ? C.push(this.genTransition()) : C.push(this.genChildrenWrapper()), E("div", {
                  staticClass: "v-treeview-node",
                  class: {
                    "v-treeview-node--leaf": !this.hasChildren,
                    "v-treeview-node--click": this.openOnClick,
                    "v-treeview-node--disabled": this.disabled,
                    "v-treeview-node--rounded": this.rounded,
                    "v-treeview-node--shaped": this.shaped,
                    "v-treeview-node--selected": this.isSelected
                  },
                  attrs: {
                    "aria-expanded": String(this.isOpen)
                  }
                }, C);
              }
            });
            r.default = v;
          }
        ),
        /***/
        "./src/components/VTreeview/index.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VTreeview/index.ts ***!
            \*******************************************/
          /*! exports provided: VTreeview, VTreeviewNode, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VTreeview */
              "./src/components/VTreeview/VTreeview.ts"
            );
            i.d(r, "VTreeview", function() {
              return a.default;
            });
            var o = i(
              /*! ./VTreeviewNode */
              "./src/components/VTreeview/VTreeviewNode.ts"
            );
            i.d(r, "VTreeviewNode", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VTreeview: a.default,
                VTreeviewNode: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/VTreeview/util/filterTreeItems.ts": (
          /*!**********************************************************!*\
            !*** ./src/components/VTreeview/util/filterTreeItems.ts ***!
            \**********************************************************/
          /*! exports provided: filterTreeItem, filterTreeItems */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "filterTreeItem", function() {
              return o;
            }), i.d(r, "filterTreeItems", function() {
              return l;
            });
            var a = i(
              /*! ../../../util/helpers */
              "./src/util/helpers.ts"
            );
            function o(f, d, u) {
              var c = Object(a.getObjectValueByPath)(f, u);
              return c.toLocaleLowerCase().indexOf(d.toLocaleLowerCase()) > -1;
            }
            function l(f, d, u, c, h, p, g) {
              if (f(d, u, h))
                return !0;
              var m = Object(a.getObjectValueByPath)(d, p);
              if (m) {
                for (var v = !1, y = 0; y < m.length; y++)
                  l(f, m[y], u, c, h, p, g) && (v = !0);
                if (v)
                  return !0;
              }
              return g.add(Object(a.getObjectValueByPath)(d, c)), !1;
            }
          }
        ),
        /***/
        "./src/components/VVirtualScroll/VVirtualScroll.sass": (
          /*!***********************************************************!*\
            !*** ./src/components/VVirtualScroll/VVirtualScroll.sass ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VVirtualScroll/VVirtualScroll.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/VVirtualScroll/VVirtualScroll.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VVirtualScroll.sass */
              "./src/components/VVirtualScroll/VVirtualScroll.sass"
            );
            var a = i(
              /*! ../../mixins/measurable */
              "./src/mixins/measurable/index.ts"
            ), o = i(
              /*! ../../directives/scroll */
              "./src/directives/scroll/index.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = a.default.extend({
              name: "v-virtual-scroll",
              directives: {
                Scroll: o.default
              },
              props: {
                bench: {
                  type: [Number, String],
                  default: 0
                },
                itemHeight: {
                  type: [Number, String],
                  required: !0
                },
                items: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                }
              },
              data: function() {
                return {
                  first: 0,
                  last: 0,
                  scrollTop: 0
                };
              },
              computed: {
                __bench: function() {
                  return parseInt(this.bench, 10);
                },
                __itemHeight: function() {
                  return parseInt(this.itemHeight, 10);
                },
                firstToRender: function() {
                  return Math.max(0, this.first - this.__bench);
                },
                lastToRender: function() {
                  return Math.min(this.items.length, this.last + this.__bench);
                }
              },
              watch: {
                height: "onScroll",
                itemHeight: "onScroll"
              },
              mounted: function() {
                this.last = this.getLast(0);
              },
              methods: {
                getChildren: function() {
                  return this.items.slice(this.firstToRender, this.lastToRender).map(this.genChild);
                },
                genChild: function(d, u) {
                  u += this.firstToRender;
                  var c = Object(l.convertToUnit)(u * this.__itemHeight);
                  return this.$createElement("div", {
                    staticClass: "v-virtual-scroll__item",
                    style: {
                      top: c
                    },
                    key: u
                  }, Object(l.getSlot)(this, "default", {
                    index: u,
                    item: d
                  }));
                },
                getFirst: function() {
                  return Math.floor(this.scrollTop / this.__itemHeight);
                },
                getLast: function(d) {
                  var u = parseInt(this.height || 0, 10) || this.$el.clientHeight;
                  return d + Math.ceil(u / this.__itemHeight);
                },
                onScroll: function() {
                  this.scrollTop = this.$el.scrollTop, this.first = this.getFirst(), this.last = this.getLast(this.first);
                }
              },
              render: function(d) {
                var u = d("div", {
                  staticClass: "v-virtual-scroll__container",
                  style: {
                    height: Object(l.convertToUnit)(this.items.length * this.__itemHeight)
                  }
                }, this.getChildren());
                return d("div", {
                  staticClass: "v-virtual-scroll",
                  style: this.measurableStyles,
                  directives: [{
                    name: "scroll",
                    modifiers: {
                      self: !0
                    },
                    value: this.onScroll
                  }],
                  on: this.$listeners
                }, [u]);
              }
            });
          }
        ),
        /***/
        "./src/components/VVirtualScroll/index.ts": (
          /*!************************************************!*\
            !*** ./src/components/VVirtualScroll/index.ts ***!
            \************************************************/
          /*! exports provided: VVirtualScroll, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VVirtualScroll */
              "./src/components/VVirtualScroll/VVirtualScroll.ts"
            );
            i.d(r, "VVirtualScroll", function() {
              return a.default;
            }), r.default = a.default;
          }
        ),
        /***/
        "./src/components/VWindow/VWindow.sass": (
          /*!*********************************************!*\
            !*** ./src/components/VWindow/VWindow.sass ***!
            \*********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/components/VWindow/VWindow.ts": (
          /*!*******************************************!*\
            !*** ./src/components/VWindow/VWindow.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i(
              /*! ./VWindow.sass */
              "./src/components/VWindow/VWindow.sass"
            );
            var a = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), o = i(
              /*! ../VBtn */
              "./src/components/VBtn/index.ts"
            ), l = i(
              /*! ../VIcon */
              "./src/components/VIcon/index.ts"
            ), f = i(
              /*! ../VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = f.BaseItemGroup.extend({
              name: "v-window",
              directives: {
                Touch: a.default
              },
              provide: function() {
                return {
                  windowGroup: this
                };
              },
              props: {
                activeClass: {
                  type: String,
                  default: "v-window-item--active"
                },
                continuous: Boolean,
                mandatory: {
                  type: Boolean,
                  default: !0
                },
                nextIcon: {
                  type: [Boolean, String],
                  default: "$next"
                },
                prevIcon: {
                  type: [Boolean, String],
                  default: "$prev"
                },
                reverse: Boolean,
                showArrows: Boolean,
                showArrowsOnHover: Boolean,
                touch: Object,
                touchless: Boolean,
                value: {
                  required: !1
                },
                vertical: Boolean
              },
              data: function() {
                return {
                  changedByDelimiters: !1,
                  internalHeight: void 0,
                  transitionHeight: void 0,
                  transitionCount: 0,
                  isBooted: !1,
                  isReverse: !1
                };
              },
              computed: {
                isActive: function() {
                  return this.transitionCount > 0;
                },
                classes: function() {
                  return d(d({}, f.BaseItemGroup.options.computed.classes.call(this)), {
                    "v-window--show-arrows-on-hover": this.showArrowsOnHover
                  });
                },
                computedTransition: function() {
                  if (!this.isBooted)
                    return "";
                  var c = this.vertical ? "y" : "x", h = this.internalReverse ? !this.isReverse : this.isReverse, p = h ? "-reverse" : "";
                  return "v-window-" + c + p + "-transition";
                },
                hasActiveItems: function() {
                  return !!this.items.find(function(c) {
                    return !c.disabled;
                  });
                },
                hasNext: function() {
                  return this.continuous || this.internalIndex < this.items.length - 1;
                },
                hasPrev: function() {
                  return this.continuous || this.internalIndex > 0;
                },
                internalIndex: function() {
                  var c = this;
                  return this.items.findIndex(function(h, p) {
                    return c.internalValue === c.getValue(h, p);
                  });
                },
                internalReverse: function() {
                  return this.$vuetify.rtl ? !this.reverse : this.reverse;
                }
              },
              watch: {
                internalIndex: function(c, h) {
                  this.isReverse = this.updateReverse(c, h);
                }
              },
              mounted: function() {
                var c = this;
                window.requestAnimationFrame(function() {
                  return c.isBooted = !0;
                });
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$slots.default;
                },
                genContainer: function() {
                  var c = [this.genDefaultSlot()];
                  return this.showArrows && c.push(this.genControlIcons()), this.$createElement("div", {
                    staticClass: "v-window__container",
                    class: {
                      "v-window__container--is-active": this.isActive
                    },
                    style: {
                      height: this.internalHeight || this.transitionHeight
                    }
                  }, c);
                },
                genIcon: function(c, h, p) {
                  var g = this, m, v, y, E = {
                    click: function(P) {
                      P.stopPropagation(), g.changedByDelimiters = !0, p();
                    }
                  }, C = {
                    "aria-label": this.$vuetify.lang.t("$vuetify.carousel." + c)
                  }, x = (y = (v = (m = this.$scopedSlots)[c]) === null || v === void 0 ? void 0 : v.call(m, {
                    on: E,
                    attrs: C
                  })) !== null && y !== void 0 ? y : [this.$createElement(o.default, {
                    props: {
                      icon: !0
                    },
                    attrs: C,
                    on: E
                  }, [this.$createElement(l.default, {
                    props: {
                      large: !0
                    }
                  }, h)])];
                  return this.$createElement("div", {
                    staticClass: "v-window__" + c
                  }, x);
                },
                genControlIcons: function() {
                  var c = [], h = this.$vuetify.rtl ? this.nextIcon : this.prevIcon;
                  if (this.hasPrev && h && typeof h == "string") {
                    var p = this.genIcon("prev", h, this.prev);
                    p && c.push(p);
                  }
                  var g = this.$vuetify.rtl ? this.prevIcon : this.nextIcon;
                  if (this.hasNext && g && typeof g == "string") {
                    var p = this.genIcon("next", g, this.next);
                    p && c.push(p);
                  }
                  return c;
                },
                getNextIndex: function(c) {
                  var h = (c + 1) % this.items.length, p = this.items[h];
                  return p.disabled ? this.getNextIndex(h) : h;
                },
                getPrevIndex: function(c) {
                  var h = (c + this.items.length - 1) % this.items.length, p = this.items[h];
                  return p.disabled ? this.getPrevIndex(h) : h;
                },
                next: function() {
                  if (!(!this.hasActiveItems || !this.hasNext)) {
                    var c = this.getNextIndex(this.internalIndex), h = this.items[c];
                    this.internalValue = this.getValue(h, c);
                  }
                },
                prev: function() {
                  if (!(!this.hasActiveItems || !this.hasPrev)) {
                    var c = this.getPrevIndex(this.internalIndex), h = this.items[c];
                    this.internalValue = this.getValue(h, c);
                  }
                },
                updateReverse: function(c, h) {
                  var p = this.items.length, g = p - 1;
                  return p <= 2 ? c < h : c === g && h === 0 ? !0 : c === 0 && h === g ? !1 : c < h;
                }
              },
              render: function(c) {
                var h = this, p = {
                  staticClass: "v-window",
                  class: this.classes,
                  directives: []
                };
                if (!this.touchless) {
                  var g = this.touch || {
                    left: function() {
                      h.$vuetify.rtl ? h.prev() : h.next();
                    },
                    right: function() {
                      h.$vuetify.rtl ? h.next() : h.prev();
                    },
                    end: function(v) {
                      v.stopPropagation();
                    },
                    start: function(v) {
                      v.stopPropagation();
                    }
                  };
                  p.directives.push({
                    name: "touch",
                    value: g
                  });
                }
                return c("div", p, [this.genContainer()]);
              }
            });
          }
        ),
        /***/
        "./src/components/VWindow/VWindowItem.ts": (
          /*!***********************************************!*\
            !*** ./src/components/VWindow/VWindowItem.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../mixins/bootable */
              "./src/mixins/bootable/index.ts"
            ), o = i(
              /*! ../../mixins/groupable */
              "./src/mixins/groupable/index.ts"
            ), l = i(
              /*! ../../directives/touch */
              "./src/directives/touch/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = Object(d.default)(a.default, Object(o.factory)("windowGroup", "v-window-item", "v-window"));
            r.default = u.extend().extend().extend({
              name: "v-window-item",
              directives: {
                Touch: l.default
              },
              props: {
                disabled: Boolean,
                reverseTransition: {
                  type: [Boolean, String],
                  default: void 0
                },
                transition: {
                  type: [Boolean, String],
                  default: void 0
                },
                value: {
                  required: !1
                }
              },
              data: function() {
                return {
                  isActive: !1,
                  inTransition: !1
                };
              },
              computed: {
                classes: function() {
                  return this.groupClasses;
                },
                computedTransition: function() {
                  return this.windowGroup.internalReverse ? typeof this.reverseTransition < "u" ? this.reverseTransition || "" : this.windowGroup.computedTransition : typeof this.transition < "u" ? this.transition || "" : this.windowGroup.computedTransition;
                }
              },
              methods: {
                genDefaultSlot: function() {
                  return this.$slots.default;
                },
                genWindowItem: function() {
                  return this.$createElement("div", {
                    staticClass: "v-window-item",
                    class: this.classes,
                    directives: [{
                      name: "show",
                      value: this.isActive
                    }],
                    on: this.$listeners
                  }, this.genDefaultSlot());
                },
                onAfterTransition: function() {
                  this.inTransition && (this.inTransition = !1, this.windowGroup.transitionCount > 0 && (this.windowGroup.transitionCount--, this.windowGroup.transitionCount === 0 && (this.windowGroup.transitionHeight = void 0)));
                },
                onBeforeTransition: function() {
                  this.inTransition || (this.inTransition = !0, this.windowGroup.transitionCount === 0 && (this.windowGroup.transitionHeight = Object(f.convertToUnit)(this.windowGroup.$el.clientHeight)), this.windowGroup.transitionCount++);
                },
                onTransitionCancelled: function() {
                  this.onAfterTransition();
                },
                onEnter: function(h) {
                  var p = this;
                  this.inTransition && this.$nextTick(function() {
                    !p.computedTransition || !p.inTransition || (p.windowGroup.transitionHeight = Object(f.convertToUnit)(h.clientHeight));
                  });
                }
              },
              render: function(h) {
                var p = this;
                return h("transition", {
                  props: {
                    name: this.computedTransition
                  },
                  on: {
                    // Handlers for enter windows.
                    beforeEnter: this.onBeforeTransition,
                    afterEnter: this.onAfterTransition,
                    enterCancelled: this.onTransitionCancelled,
                    // Handlers for leave windows.
                    beforeLeave: this.onBeforeTransition,
                    afterLeave: this.onAfterTransition,
                    leaveCancelled: this.onTransitionCancelled,
                    // Enter handler for height transition.
                    enter: this.onEnter
                  }
                }, this.showLazyContent(function() {
                  return [p.genWindowItem()];
                }));
              }
            });
          }
        ),
        /***/
        "./src/components/VWindow/index.ts": (
          /*!*****************************************!*\
            !*** ./src/components/VWindow/index.ts ***!
            \*****************************************/
          /*! exports provided: VWindow, VWindowItem, default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VWindow */
              "./src/components/VWindow/VWindow.ts"
            );
            i.d(r, "VWindow", function() {
              return a.default;
            });
            var o = i(
              /*! ./VWindowItem */
              "./src/components/VWindow/VWindowItem.ts"
            );
            i.d(r, "VWindowItem", function() {
              return o.default;
            }), r.default = {
              $_vuetify_subcomponents: {
                VWindow: a.default,
                VWindowItem: o.default
              }
            };
          }
        ),
        /***/
        "./src/components/index.ts": (
          /*!*********************************!*\
            !*** ./src/components/index.ts ***!
            \*********************************/
          /*! exports provided: VApp, VAppBar, VAppBarNavIcon, VAppBarTitle, VAlert, VAutocomplete, VAvatar, VBadge, VBanner, VBottomNavigation, VBottomSheet, VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, VBtn, VBtnToggle, VCalendar, VCalendarCategory, VCalendarDaily, VCalendarWeekly, VCalendarMonthly, VCard, VCardActions, VCardSubtitle, VCardText, VCardTitle, VCarousel, VCarouselItem, VCheckbox, VSimpleCheckbox, VChip, VChipGroup, VColorPicker, VColorPickerSwatches, VColorPickerCanvas, VContent, VCombobox, VCounter, VData, VDataIterator, VDataFooter, VDataTable, VEditDialog, VTableOverflow, VDataTableHeader, VSimpleTable, VVirtualTable, VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, VDialog, VDivider, VExpansionPanels, VExpansionPanel, VExpansionPanelHeader, VExpansionPanelContent, VFileInput, VFooter, VForm, VContainer, VCol, VRow, VSpacer, VLayout, VFlex, VHover, VIcon, VImg, VInput, VItem, VItemGroup, VLabel, VLazy, VListItemActionText, VListItemContent, VListItemTitle, VListItemSubtitle, VList, VListGroup, VListItem, VListItemAction, VListItemAvatar, VListItemIcon, VListItemGroup, VMain, VMenu, VMessages, VNavigationDrawer, VOtpInput, VOverflowBtn, VOverlay, VPagination, VSheet, VParallax, VPicker, VProgressCircular, VProgressLinear, VRadioGroup, VRadio, VRangeSlider, VRating, VResponsive, VSelect, VSkeletonLoader, VSlider, VSlideGroup, VSlideItem, VSnackbar, VSparkline, VSpeedDial, VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, VSubheader, VSwitch, VSystemBar, VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, VTextarea, VTextField, VThemeProvider, VTimeline, VTimelineItem, VTimePicker, VTimePickerClock, VTimePickerTitle, VToolbar, VToolbarItems, VToolbarTitle, VTooltip, VTreeview, VTreeviewNode, VVirtualScroll, VWindow, VWindowItem, VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VDialogTopTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VExpandXTransition */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./VApp */
              "./src/components/VApp/index.ts"
            );
            i.d(r, "VApp", function() {
              return a.VApp;
            });
            var o = i(
              /*! ./VAppBar */
              "./src/components/VAppBar/index.ts"
            );
            i.d(r, "VAppBar", function() {
              return o.VAppBar;
            }), i.d(r, "VAppBarNavIcon", function() {
              return o.VAppBarNavIcon;
            }), i.d(r, "VAppBarTitle", function() {
              return o.VAppBarTitle;
            });
            var l = i(
              /*! ./VAlert */
              "./src/components/VAlert/index.ts"
            );
            i.d(r, "VAlert", function() {
              return l.VAlert;
            });
            var f = i(
              /*! ./VAutocomplete */
              "./src/components/VAutocomplete/index.ts"
            );
            i.d(r, "VAutocomplete", function() {
              return f.VAutocomplete;
            });
            var d = i(
              /*! ./VAvatar */
              "./src/components/VAvatar/index.ts"
            );
            i.d(r, "VAvatar", function() {
              return d.VAvatar;
            });
            var u = i(
              /*! ./VBadge */
              "./src/components/VBadge/index.ts"
            );
            i.d(r, "VBadge", function() {
              return u.VBadge;
            });
            var c = i(
              /*! ./VBanner */
              "./src/components/VBanner/index.ts"
            );
            i.d(r, "VBanner", function() {
              return c.VBanner;
            });
            var h = i(
              /*! ./VBottomNavigation */
              "./src/components/VBottomNavigation/index.ts"
            );
            i.d(r, "VBottomNavigation", function() {
              return h.VBottomNavigation;
            });
            var p = i(
              /*! ./VBottomSheet */
              "./src/components/VBottomSheet/index.ts"
            );
            i.d(r, "VBottomSheet", function() {
              return p.VBottomSheet;
            });
            var g = i(
              /*! ./VBreadcrumbs */
              "./src/components/VBreadcrumbs/index.ts"
            );
            i.d(r, "VBreadcrumbs", function() {
              return g.VBreadcrumbs;
            }), i.d(r, "VBreadcrumbsItem", function() {
              return g.VBreadcrumbsItem;
            }), i.d(r, "VBreadcrumbsDivider", function() {
              return g.VBreadcrumbsDivider;
            });
            var m = i(
              /*! ./VBtn */
              "./src/components/VBtn/index.ts"
            );
            i.d(r, "VBtn", function() {
              return m.VBtn;
            });
            var v = i(
              /*! ./VBtnToggle */
              "./src/components/VBtnToggle/index.ts"
            );
            i.d(r, "VBtnToggle", function() {
              return v.VBtnToggle;
            });
            var y = i(
              /*! ./VCalendar */
              "./src/components/VCalendar/index.ts"
            );
            i.d(r, "VCalendar", function() {
              return y.VCalendar;
            }), i.d(r, "VCalendarCategory", function() {
              return y.VCalendarCategory;
            }), i.d(r, "VCalendarDaily", function() {
              return y.VCalendarDaily;
            }), i.d(r, "VCalendarWeekly", function() {
              return y.VCalendarWeekly;
            }), i.d(r, "VCalendarMonthly", function() {
              return y.VCalendarMonthly;
            });
            var E = i(
              /*! ./VCard */
              "./src/components/VCard/index.ts"
            );
            i.d(r, "VCard", function() {
              return E.VCard;
            }), i.d(r, "VCardActions", function() {
              return E.VCardActions;
            }), i.d(r, "VCardSubtitle", function() {
              return E.VCardSubtitle;
            }), i.d(r, "VCardText", function() {
              return E.VCardText;
            }), i.d(r, "VCardTitle", function() {
              return E.VCardTitle;
            });
            var C = i(
              /*! ./VCarousel */
              "./src/components/VCarousel/index.ts"
            );
            i.d(r, "VCarousel", function() {
              return C.VCarousel;
            }), i.d(r, "VCarouselItem", function() {
              return C.VCarouselItem;
            });
            var x = i(
              /*! ./VCheckbox */
              "./src/components/VCheckbox/index.ts"
            );
            i.d(r, "VCheckbox", function() {
              return x.VCheckbox;
            }), i.d(r, "VSimpleCheckbox", function() {
              return x.VSimpleCheckbox;
            });
            var b = i(
              /*! ./VChip */
              "./src/components/VChip/index.ts"
            );
            i.d(r, "VChip", function() {
              return b.VChip;
            });
            var P = i(
              /*! ./VChipGroup */
              "./src/components/VChipGroup/index.ts"
            );
            i.d(r, "VChipGroup", function() {
              return P.VChipGroup;
            });
            var O = i(
              /*! ./VColorPicker */
              "./src/components/VColorPicker/index.ts"
            );
            i.d(r, "VColorPicker", function() {
              return O.VColorPicker;
            }), i.d(r, "VColorPickerSwatches", function() {
              return O.VColorPickerSwatches;
            }), i.d(r, "VColorPickerCanvas", function() {
              return O.VColorPickerCanvas;
            });
            var T = i(
              /*! ./VContent */
              "./src/components/VContent/index.ts"
            );
            i.d(r, "VContent", function() {
              return T.VContent;
            });
            var M = i(
              /*! ./VCombobox */
              "./src/components/VCombobox/index.ts"
            );
            i.d(r, "VCombobox", function() {
              return M.VCombobox;
            });
            var L = i(
              /*! ./VCounter */
              "./src/components/VCounter/index.ts"
            );
            i.d(r, "VCounter", function() {
              return L.VCounter;
            });
            var A = i(
              /*! ./VData */
              "./src/components/VData/index.ts"
            );
            i.d(r, "VData", function() {
              return A.VData;
            });
            var D = i(
              /*! ./VDataIterator */
              "./src/components/VDataIterator/index.ts"
            );
            i.d(r, "VDataIterator", function() {
              return D.VDataIterator;
            }), i.d(r, "VDataFooter", function() {
              return D.VDataFooter;
            });
            var I = i(
              /*! ./VDataTable */
              "./src/components/VDataTable/index.ts"
            );
            i.d(r, "VDataTable", function() {
              return I.VDataTable;
            }), i.d(r, "VEditDialog", function() {
              return I.VEditDialog;
            }), i.d(r, "VTableOverflow", function() {
              return I.VTableOverflow;
            }), i.d(r, "VDataTableHeader", function() {
              return I.VDataTableHeader;
            }), i.d(r, "VSimpleTable", function() {
              return I.VSimpleTable;
            }), i.d(r, "VVirtualTable", function() {
              return I.VVirtualTable;
            });
            var w = i(
              /*! ./VDatePicker */
              "./src/components/VDatePicker/index.ts"
            );
            i.d(r, "VDatePicker", function() {
              return w.VDatePicker;
            }), i.d(r, "VDatePickerTitle", function() {
              return w.VDatePickerTitle;
            }), i.d(r, "VDatePickerHeader", function() {
              return w.VDatePickerHeader;
            }), i.d(r, "VDatePickerDateTable", function() {
              return w.VDatePickerDateTable;
            }), i.d(r, "VDatePickerMonthTable", function() {
              return w.VDatePickerMonthTable;
            }), i.d(r, "VDatePickerYears", function() {
              return w.VDatePickerYears;
            });
            var B = i(
              /*! ./VDialog */
              "./src/components/VDialog/index.ts"
            );
            i.d(r, "VDialog", function() {
              return B.VDialog;
            });
            var j = i(
              /*! ./VDivider */
              "./src/components/VDivider/index.ts"
            );
            i.d(r, "VDivider", function() {
              return j.VDivider;
            });
            var k = i(
              /*! ./VExpansionPanel */
              "./src/components/VExpansionPanel/index.ts"
            );
            i.d(r, "VExpansionPanels", function() {
              return k.VExpansionPanels;
            }), i.d(r, "VExpansionPanel", function() {
              return k.VExpansionPanel;
            }), i.d(r, "VExpansionPanelHeader", function() {
              return k.VExpansionPanelHeader;
            }), i.d(r, "VExpansionPanelContent", function() {
              return k.VExpansionPanelContent;
            });
            var X = i(
              /*! ./VFileInput */
              "./src/components/VFileInput/index.ts"
            );
            i.d(r, "VFileInput", function() {
              return X.VFileInput;
            });
            var rt = i(
              /*! ./VFooter */
              "./src/components/VFooter/index.ts"
            );
            i.d(r, "VFooter", function() {
              return rt.VFooter;
            });
            var et = i(
              /*! ./VForm */
              "./src/components/VForm/index.ts"
            );
            i.d(r, "VForm", function() {
              return et.VForm;
            });
            var Z = i(
              /*! ./VGrid */
              "./src/components/VGrid/index.ts"
            );
            i.d(r, "VContainer", function() {
              return Z.VContainer;
            }), i.d(r, "VCol", function() {
              return Z.VCol;
            }), i.d(r, "VRow", function() {
              return Z.VRow;
            }), i.d(r, "VSpacer", function() {
              return Z.VSpacer;
            }), i.d(r, "VLayout", function() {
              return Z.VLayout;
            }), i.d(r, "VFlex", function() {
              return Z.VFlex;
            });
            var dt = i(
              /*! ./VHover */
              "./src/components/VHover/index.ts"
            );
            i.d(r, "VHover", function() {
              return dt.VHover;
            });
            var vt = i(
              /*! ./VIcon */
              "./src/components/VIcon/index.ts"
            );
            i.d(r, "VIcon", function() {
              return vt.VIcon;
            });
            var bt = i(
              /*! ./VImg */
              "./src/components/VImg/index.ts"
            );
            i.d(r, "VImg", function() {
              return bt.VImg;
            });
            var it = i(
              /*! ./VInput */
              "./src/components/VInput/index.ts"
            );
            i.d(r, "VInput", function() {
              return it.VInput;
            });
            var R = i(
              /*! ./VItemGroup */
              "./src/components/VItemGroup/index.ts"
            );
            i.d(r, "VItem", function() {
              return R.VItem;
            }), i.d(r, "VItemGroup", function() {
              return R.VItemGroup;
            });
            var V = i(
              /*! ./VLabel */
              "./src/components/VLabel/index.ts"
            );
            i.d(r, "VLabel", function() {
              return V.VLabel;
            });
            var tt = i(
              /*! ./VLazy */
              "./src/components/VLazy/index.ts"
            );
            i.d(r, "VLazy", function() {
              return tt.VLazy;
            });
            var Y = i(
              /*! ./VList */
              "./src/components/VList/index.ts"
            );
            i.d(r, "VListItemActionText", function() {
              return Y.VListItemActionText;
            }), i.d(r, "VListItemContent", function() {
              return Y.VListItemContent;
            }), i.d(r, "VListItemTitle", function() {
              return Y.VListItemTitle;
            }), i.d(r, "VListItemSubtitle", function() {
              return Y.VListItemSubtitle;
            }), i.d(r, "VList", function() {
              return Y.VList;
            }), i.d(r, "VListGroup", function() {
              return Y.VListGroup;
            }), i.d(r, "VListItem", function() {
              return Y.VListItem;
            }), i.d(r, "VListItemAction", function() {
              return Y.VListItemAction;
            }), i.d(r, "VListItemAvatar", function() {
              return Y.VListItemAvatar;
            }), i.d(r, "VListItemIcon", function() {
              return Y.VListItemIcon;
            }), i.d(r, "VListItemGroup", function() {
              return Y.VListItemGroup;
            });
            var W = i(
              /*! ./VMain */
              "./src/components/VMain/index.ts"
            );
            i.d(r, "VMain", function() {
              return W.VMain;
            });
            var z = i(
              /*! ./VMenu */
              "./src/components/VMenu/index.ts"
            );
            i.d(r, "VMenu", function() {
              return z.VMenu;
            });
            var at = i(
              /*! ./VMessages */
              "./src/components/VMessages/index.ts"
            );
            i.d(r, "VMessages", function() {
              return at.VMessages;
            });
            var ct = i(
              /*! ./VNavigationDrawer */
              "./src/components/VNavigationDrawer/index.ts"
            );
            i.d(r, "VNavigationDrawer", function() {
              return ct.VNavigationDrawer;
            });
            var Mt = i(
              /*! ./VOtpInput */
              "./src/components/VOtpInput/index.ts"
            );
            i.d(r, "VOtpInput", function() {
              return Mt.VOtpInput;
            });
            var N = i(
              /*! ./VOverflowBtn */
              "./src/components/VOverflowBtn/index.ts"
            );
            i.d(r, "VOverflowBtn", function() {
              return N.VOverflowBtn;
            });
            var S = i(
              /*! ./VOverlay */
              "./src/components/VOverlay/index.ts"
            );
            i.d(r, "VOverlay", function() {
              return S.VOverlay;
            });
            var _ = i(
              /*! ./VPagination */
              "./src/components/VPagination/index.ts"
            );
            i.d(r, "VPagination", function() {
              return _.VPagination;
            });
            var F = i(
              /*! ./VSheet */
              "./src/components/VSheet/index.ts"
            );
            i.d(r, "VSheet", function() {
              return F.VSheet;
            });
            var G = i(
              /*! ./VParallax */
              "./src/components/VParallax/index.ts"
            );
            i.d(r, "VParallax", function() {
              return G.VParallax;
            });
            var nt = i(
              /*! ./VPicker */
              "./src/components/VPicker/index.ts"
            );
            i.d(r, "VPicker", function() {
              return nt.VPicker;
            });
            var lt = i(
              /*! ./VProgressCircular */
              "./src/components/VProgressCircular/index.ts"
            );
            i.d(r, "VProgressCircular", function() {
              return lt.VProgressCircular;
            });
            var yt = i(
              /*! ./VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            );
            i.d(r, "VProgressLinear", function() {
              return yt.VProgressLinear;
            });
            var Lt = i(
              /*! ./VRadioGroup */
              "./src/components/VRadioGroup/index.ts"
            );
            i.d(r, "VRadioGroup", function() {
              return Lt.VRadioGroup;
            }), i.d(r, "VRadio", function() {
              return Lt.VRadio;
            });
            var Ft = i(
              /*! ./VRangeSlider */
              "./src/components/VRangeSlider/index.ts"
            );
            i.d(r, "VRangeSlider", function() {
              return Ft.VRangeSlider;
            });
            var Jt = i(
              /*! ./VRating */
              "./src/components/VRating/index.ts"
            );
            i.d(r, "VRating", function() {
              return Jt.VRating;
            });
            var J = i(
              /*! ./VResponsive */
              "./src/components/VResponsive/index.ts"
            );
            i.d(r, "VResponsive", function() {
              return J.VResponsive;
            });
            var ft = i(
              /*! ./VSelect */
              "./src/components/VSelect/index.ts"
            );
            i.d(r, "VSelect", function() {
              return ft.VSelect;
            });
            var Ct = i(
              /*! ./VSkeletonLoader */
              "./src/components/VSkeletonLoader/index.ts"
            );
            i.d(r, "VSkeletonLoader", function() {
              return Ct.VSkeletonLoader;
            });
            var St = i(
              /*! ./VSlider */
              "./src/components/VSlider/index.ts"
            );
            i.d(r, "VSlider", function() {
              return St.VSlider;
            });
            var Tt = i(
              /*! ./VSlideGroup */
              "./src/components/VSlideGroup/index.ts"
            );
            i.d(r, "VSlideGroup", function() {
              return Tt.VSlideGroup;
            }), i.d(r, "VSlideItem", function() {
              return Tt.VSlideItem;
            });
            var kt = i(
              /*! ./VSnackbar */
              "./src/components/VSnackbar/index.ts"
            );
            i.d(r, "VSnackbar", function() {
              return kt.VSnackbar;
            });
            var fe = i(
              /*! ./VSparkline */
              "./src/components/VSparkline/index.ts"
            );
            i.d(r, "VSparkline", function() {
              return fe.VSparkline;
            });
            var Se = i(
              /*! ./VSpeedDial */
              "./src/components/VSpeedDial/index.ts"
            );
            i.d(r, "VSpeedDial", function() {
              return Se.VSpeedDial;
            });
            var Me = i(
              /*! ./VStepper */
              "./src/components/VStepper/index.ts"
            );
            i.d(r, "VStepper", function() {
              return Me.VStepper;
            }), i.d(r, "VStepperContent", function() {
              return Me.VStepperContent;
            }), i.d(r, "VStepperStep", function() {
              return Me.VStepperStep;
            }), i.d(r, "VStepperHeader", function() {
              return Me.VStepperHeader;
            }), i.d(r, "VStepperItems", function() {
              return Me.VStepperItems;
            });
            var xe = i(
              /*! ./VSubheader */
              "./src/components/VSubheader/index.ts"
            );
            i.d(r, "VSubheader", function() {
              return xe.VSubheader;
            });
            var We = i(
              /*! ./VSwitch */
              "./src/components/VSwitch/index.ts"
            );
            i.d(r, "VSwitch", function() {
              return We.VSwitch;
            });
            var bn = i(
              /*! ./VSystemBar */
              "./src/components/VSystemBar/index.ts"
            );
            i.d(r, "VSystemBar", function() {
              return bn.VSystemBar;
            });
            var Ye = i(
              /*! ./VTabs */
              "./src/components/VTabs/index.ts"
            );
            i.d(r, "VTabs", function() {
              return Ye.VTabs;
            }), i.d(r, "VTab", function() {
              return Ye.VTab;
            }), i.d(r, "VTabItem", function() {
              return Ye.VTabItem;
            }), i.d(r, "VTabsItems", function() {
              return Ye.VTabsItems;
            }), i.d(r, "VTabsSlider", function() {
              return Ye.VTabsSlider;
            });
            var Hn = i(
              /*! ./VTextarea */
              "./src/components/VTextarea/index.ts"
            );
            i.d(r, "VTextarea", function() {
              return Hn.VTextarea;
            });
            var pn = i(
              /*! ./VTextField */
              "./src/components/VTextField/index.ts"
            );
            i.d(r, "VTextField", function() {
              return pn.VTextField;
            });
            var Ne = i(
              /*! ./VThemeProvider */
              "./src/components/VThemeProvider/index.ts"
            );
            i.d(r, "VThemeProvider", function() {
              return Ne.VThemeProvider;
            });
            var mn = i(
              /*! ./VTimeline */
              "./src/components/VTimeline/index.ts"
            );
            i.d(r, "VTimeline", function() {
              return mn.VTimeline;
            }), i.d(r, "VTimelineItem", function() {
              return mn.VTimelineItem;
            });
            var gn = i(
              /*! ./VTimePicker */
              "./src/components/VTimePicker/index.ts"
            );
            i.d(r, "VTimePicker", function() {
              return gn.VTimePicker;
            }), i.d(r, "VTimePickerClock", function() {
              return gn.VTimePickerClock;
            }), i.d(r, "VTimePickerTitle", function() {
              return gn.VTimePickerTitle;
            });
            var we = i(
              /*! ./VToolbar */
              "./src/components/VToolbar/index.ts"
            );
            i.d(r, "VToolbar", function() {
              return we.VToolbar;
            }), i.d(r, "VToolbarItems", function() {
              return we.VToolbarItems;
            }), i.d(r, "VToolbarTitle", function() {
              return we.VToolbarTitle;
            });
            var vn = i(
              /*! ./VTooltip */
              "./src/components/VTooltip/index.ts"
            );
            i.d(r, "VTooltip", function() {
              return vn.VTooltip;
            });
            var ze = i(
              /*! ./VTreeview */
              "./src/components/VTreeview/index.ts"
            );
            i.d(r, "VTreeview", function() {
              return ze.VTreeview;
            }), i.d(r, "VTreeviewNode", function() {
              return ze.VTreeviewNode;
            });
            var Tn = i(
              /*! ./VVirtualScroll */
              "./src/components/VVirtualScroll/index.ts"
            );
            i.d(r, "VVirtualScroll", function() {
              return Tn.VVirtualScroll;
            });
            var tn = i(
              /*! ./VWindow */
              "./src/components/VWindow/index.ts"
            );
            i.d(r, "VWindow", function() {
              return tn.VWindow;
            }), i.d(r, "VWindowItem", function() {
              return tn.VWindowItem;
            });
            var ae = i(
              /*! ./transitions */
              "./src/components/transitions/index.ts"
            );
            i.d(r, "VCarouselTransition", function() {
              return ae.VCarouselTransition;
            }), i.d(r, "VCarouselReverseTransition", function() {
              return ae.VCarouselReverseTransition;
            }), i.d(r, "VTabTransition", function() {
              return ae.VTabTransition;
            }), i.d(r, "VTabReverseTransition", function() {
              return ae.VTabReverseTransition;
            }), i.d(r, "VMenuTransition", function() {
              return ae.VMenuTransition;
            }), i.d(r, "VFabTransition", function() {
              return ae.VFabTransition;
            }), i.d(r, "VDialogTransition", function() {
              return ae.VDialogTransition;
            }), i.d(r, "VDialogBottomTransition", function() {
              return ae.VDialogBottomTransition;
            }), i.d(r, "VDialogTopTransition", function() {
              return ae.VDialogTopTransition;
            }), i.d(r, "VFadeTransition", function() {
              return ae.VFadeTransition;
            }), i.d(r, "VScaleTransition", function() {
              return ae.VScaleTransition;
            }), i.d(r, "VScrollXTransition", function() {
              return ae.VScrollXTransition;
            }), i.d(r, "VScrollXReverseTransition", function() {
              return ae.VScrollXReverseTransition;
            }), i.d(r, "VScrollYTransition", function() {
              return ae.VScrollYTransition;
            }), i.d(r, "VScrollYReverseTransition", function() {
              return ae.VScrollYReverseTransition;
            }), i.d(r, "VSlideXTransition", function() {
              return ae.VSlideXTransition;
            }), i.d(r, "VSlideXReverseTransition", function() {
              return ae.VSlideXReverseTransition;
            }), i.d(r, "VSlideYTransition", function() {
              return ae.VSlideYTransition;
            }), i.d(r, "VSlideYReverseTransition", function() {
              return ae.VSlideYReverseTransition;
            }), i.d(r, "VExpandTransition", function() {
              return ae.VExpandTransition;
            }), i.d(r, "VExpandXTransition", function() {
              return ae.VExpandXTransition;
            });
          }
        ),
        /***/
        "./src/components/transitions/createTransition.ts": (
          /*!********************************************************!*\
            !*** ./src/components/transitions/createTransition.ts ***!
            \********************************************************/
          /*! exports provided: createSimpleTransition, createJavascriptTransition */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createSimpleTransition", function() {
              return d;
            }), i.d(r, "createJavascriptTransition", function() {
              return u;
            });
            var a = i(
              /*! ../../util/mergeData */
              "./src/util/mergeData.ts"
            ), o = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            }, l = function(c, h, p) {
              if (p || arguments.length === 2)
                for (var g = 0, m = h.length, v; g < m; g++)
                  (v || !(g in h)) && (v || (v = Array.prototype.slice.call(h, 0, g)), v[g] = h[g]);
              return c.concat(v || Array.prototype.slice.call(h));
            };
            function f(c) {
              var h;
              c === void 0 && (c = []);
              for (var p = [], g = 1; g < arguments.length; g++)
                p[g - 1] = arguments[g];
              return (h = Array()).concat.apply(h, l([c], o(p), !1));
            }
            function d(c, h, p) {
              return h === void 0 && (h = "top center 0"), {
                name: c,
                functional: !0,
                props: {
                  group: {
                    type: Boolean,
                    default: !1
                  },
                  hideOnLeave: {
                    type: Boolean,
                    default: !1
                  },
                  leaveAbsolute: {
                    type: Boolean,
                    default: !1
                  },
                  mode: {
                    type: String,
                    default: p
                  },
                  origin: {
                    type: String,
                    default: h
                  }
                },
                render: function(m, v) {
                  var y = "transition" + (v.props.group ? "-group" : ""), E = {
                    props: {
                      name: c,
                      mode: v.props.mode
                    },
                    on: {
                      beforeEnter: function(x) {
                        x.style.transformOrigin = v.props.origin, x.style.webkitTransformOrigin = v.props.origin;
                      }
                    }
                  };
                  return v.props.leaveAbsolute && (E.on.leave = f(E.on.leave, function(C) {
                    var x = C.offsetTop, b = C.offsetLeft, P = C.offsetWidth, O = C.offsetHeight;
                    C._transitionInitialStyles = {
                      position: C.style.position,
                      top: C.style.top,
                      left: C.style.left,
                      width: C.style.width,
                      height: C.style.height
                    }, C.style.position = "absolute", C.style.top = x + "px", C.style.left = b + "px", C.style.width = P + "px", C.style.height = O + "px";
                  }), E.on.afterLeave = f(E.on.afterLeave, function(C) {
                    if (C && C._transitionInitialStyles) {
                      var x = C._transitionInitialStyles, b = x.position, P = x.top, O = x.left, T = x.width, M = x.height;
                      delete C._transitionInitialStyles, C.style.position = b || "", C.style.top = P || "", C.style.left = O || "", C.style.width = T || "", C.style.height = M || "";
                    }
                  })), v.props.hideOnLeave && (E.on.leave = f(E.on.leave, function(C) {
                    C.style.setProperty("display", "none", "important");
                  })), m(y, Object(a.default)(v.data, E), v.children);
                }
              };
            }
            function u(c, h, p) {
              return p === void 0 && (p = "in-out"), {
                name: c,
                functional: !0,
                props: {
                  mode: {
                    type: String,
                    default: p
                  }
                },
                render: function(m, v) {
                  return m("transition", Object(a.default)(v.data, {
                    props: {
                      name: c
                    },
                    on: h
                  }), v.children);
                }
              };
            }
          }
        ),
        /***/
        "./src/components/transitions/expand-transition.ts": (
          /*!*********************************************************!*\
            !*** ./src/components/transitions/expand-transition.ts ***!
            \*********************************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = function(o, l) {
              o === void 0 && (o = ""), l === void 0 && (l = !1);
              var f = l ? "width" : "height", d = "offset" + Object(a.upperFirst)(f);
              return {
                beforeEnter: function(p) {
                  var g;
                  p._parent = p.parentNode, p._initialStyle = (g = {
                    transition: p.style.transition,
                    overflow: p.style.overflow
                  }, g[f] = p.style[f], g);
                },
                enter: function(p) {
                  var g = p._initialStyle;
                  p.style.setProperty("transition", "none", "important"), p.style.overflow = "hidden";
                  var m = p[d] + "px";
                  p.style[f] = "0", p.offsetHeight, p.style.transition = g.transition, o && p._parent && p._parent.classList.add(o), requestAnimationFrame(function() {
                    p.style[f] = m;
                  });
                },
                afterEnter: c,
                enterCancelled: c,
                leave: function(p) {
                  var g;
                  p._initialStyle = (g = {
                    transition: "",
                    overflow: p.style.overflow
                  }, g[f] = p.style[f], g), p.style.overflow = "hidden", p.style[f] = p[d] + "px", p.offsetHeight, requestAnimationFrame(function() {
                    return p.style[f] = "0";
                  });
                },
                afterLeave: u,
                leaveCancelled: u
              };
              function u(h) {
                o && h._parent && h._parent.classList.remove(o), c(h);
              }
              function c(h) {
                var p = h._initialStyle[f];
                h.style.overflow = h._initialStyle.overflow, p != null && (h.style[f] = p), delete h._initialStyle;
              }
            };
          }
        ),
        /***/
        "./src/components/transitions/index.ts": (
          /*!*********************************************!*\
            !*** ./src/components/transitions/index.ts ***!
            \*********************************************/
          /*! exports provided: VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VDialogTopTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VExpandXTransition, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "VCarouselTransition", function() {
              return l;
            }), i.d(r, "VCarouselReverseTransition", function() {
              return f;
            }), i.d(r, "VTabTransition", function() {
              return d;
            }), i.d(r, "VTabReverseTransition", function() {
              return u;
            }), i.d(r, "VMenuTransition", function() {
              return c;
            }), i.d(r, "VFabTransition", function() {
              return h;
            }), i.d(r, "VDialogTransition", function() {
              return p;
            }), i.d(r, "VDialogBottomTransition", function() {
              return g;
            }), i.d(r, "VDialogTopTransition", function() {
              return m;
            }), i.d(r, "VFadeTransition", function() {
              return v;
            }), i.d(r, "VScaleTransition", function() {
              return y;
            }), i.d(r, "VScrollXTransition", function() {
              return E;
            }), i.d(r, "VScrollXReverseTransition", function() {
              return C;
            }), i.d(r, "VScrollYTransition", function() {
              return x;
            }), i.d(r, "VScrollYReverseTransition", function() {
              return b;
            }), i.d(r, "VSlideXTransition", function() {
              return P;
            }), i.d(r, "VSlideXReverseTransition", function() {
              return O;
            }), i.d(r, "VSlideYTransition", function() {
              return T;
            }), i.d(r, "VSlideYReverseTransition", function() {
              return M;
            }), i.d(r, "VExpandTransition", function() {
              return L;
            }), i.d(r, "VExpandXTransition", function() {
              return A;
            });
            var a = i(
              /*! ./createTransition */
              "./src/components/transitions/createTransition.ts"
            ), o = i(
              /*! ./expand-transition */
              "./src/components/transitions/expand-transition.ts"
            ), l = Object(a.createSimpleTransition)("carousel-transition"), f = Object(a.createSimpleTransition)("carousel-reverse-transition"), d = Object(a.createSimpleTransition)("tab-transition"), u = Object(a.createSimpleTransition)("tab-reverse-transition"), c = Object(a.createSimpleTransition)("menu-transition"), h = Object(a.createSimpleTransition)("fab-transition", "center center", "out-in"), p = Object(a.createSimpleTransition)("dialog-transition"), g = Object(a.createSimpleTransition)("dialog-bottom-transition"), m = Object(a.createSimpleTransition)("dialog-top-transition"), v = Object(a.createSimpleTransition)("fade-transition"), y = Object(a.createSimpleTransition)("scale-transition"), E = Object(a.createSimpleTransition)("scroll-x-transition"), C = Object(a.createSimpleTransition)("scroll-x-reverse-transition"), x = Object(a.createSimpleTransition)("scroll-y-transition"), b = Object(a.createSimpleTransition)("scroll-y-reverse-transition"), P = Object(a.createSimpleTransition)("slide-x-transition"), O = Object(a.createSimpleTransition)("slide-x-reverse-transition"), T = Object(a.createSimpleTransition)("slide-y-transition"), M = Object(a.createSimpleTransition)("slide-y-reverse-transition"), L = Object(a.createJavascriptTransition)("expand-transition", Object(o.default)()), A = Object(a.createJavascriptTransition)("expand-x-transition", Object(o.default)("", !0));
            r.default = {
              $_vuetify_subcomponents: {
                VCarouselTransition: l,
                VCarouselReverseTransition: f,
                VDialogTransition: p,
                VDialogBottomTransition: g,
                VDialogTopTransition: m,
                VFabTransition: h,
                VFadeTransition: v,
                VMenuTransition: c,
                VScaleTransition: y,
                VScrollXTransition: E,
                VScrollXReverseTransition: C,
                VScrollYTransition: x,
                VScrollYReverseTransition: b,
                VSlideXTransition: P,
                VSlideXReverseTransition: O,
                VSlideYTransition: T,
                VSlideYReverseTransition: M,
                VTabReverseTransition: u,
                VTabTransition: d,
                VExpandTransition: L,
                VExpandXTransition: A
              }
            };
          }
        ),
        /***/
        "./src/directives/click-outside/index.ts": (
          /*!***********************************************!*\
            !*** ./src/directives/click-outside/index.ts ***!
            \***********************************************/
          /*! exports provided: ClickOutside, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "ClickOutside", function() {
              return h;
            });
            var a = i(
              /*! ../../util/dom */
              "./src/util/dom.ts"
            );
            function o(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(m) {
                return typeof m;
              } : o = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, o(p);
            }
            function l() {
              return !0;
            }
            function f(p, g, m) {
              if (!p || d(p, m) === !1)
                return !1;
              var v = Object(a.attachedRoot)(g);
              if (typeof ShadowRoot < "u" && v instanceof ShadowRoot && v.host === p.target)
                return !1;
              var y = (o(m.value) === "object" && m.value.include || function() {
                return [];
              })();
              return y.push(g), !y.some(function(E) {
                return E.contains(p.target);
              });
            }
            function d(p, g) {
              var m = o(g.value) === "object" && g.value.closeConditional || l;
              return m(p);
            }
            function u(p, g, m) {
              var v = typeof m.value == "function" ? m.value : m.value.handler;
              g._clickOutside.lastMousedownWasOutside && f(p, g, m) && setTimeout(function() {
                d(p, m) && v && v(p);
              }, 0);
            }
            function c(p, g) {
              var m = Object(a.attachedRoot)(p);
              g(document), typeof ShadowRoot < "u" && m instanceof ShadowRoot && g(m);
            }
            var h = {
              // [data-app] may not be found
              // if using bind, inserted makes
              // sure that the root element is
              // available, iOS does not support
              // clicks on body
              inserted: function(g, m, v) {
                var y = function(x) {
                  return u(x, g, m);
                }, E = function(x) {
                  g._clickOutside.lastMousedownWasOutside = f(x, g, m);
                };
                c(g, function(C) {
                  C.addEventListener("click", y, !0), C.addEventListener("mousedown", E, !0);
                }), g._clickOutside || (g._clickOutside = {
                  lastMousedownWasOutside: !0
                }), g._clickOutside[v.context._uid] = {
                  onClick: y,
                  onMousedown: E
                };
              },
              unbind: function(g, m, v) {
                g._clickOutside && (c(g, function(y) {
                  var E;
                  if (!(!y || !(!((E = g._clickOutside) === null || E === void 0) && E[v.context._uid]))) {
                    var C = g._clickOutside[v.context._uid], x = C.onClick, b = C.onMousedown;
                    y.removeEventListener("click", x, !0), y.removeEventListener("mousedown", b, !0);
                  }
                }), delete g._clickOutside[v.context._uid]);
              }
            };
            r.default = h;
          }
        ),
        /***/
        "./src/directives/index.ts": (
          /*!*********************************!*\
            !*** ./src/directives/index.ts ***!
            \*********************************/
          /*! exports provided: ClickOutside, Intersect, Mutate, Resize, Ripple, Scroll, Touch */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./click-outside */
              "./src/directives/click-outside/index.ts"
            );
            i.d(r, "ClickOutside", function() {
              return a.ClickOutside;
            });
            var o = i(
              /*! ./intersect */
              "./src/directives/intersect/index.ts"
            );
            i.d(r, "Intersect", function() {
              return o.Intersect;
            });
            var l = i(
              /*! ./mutate */
              "./src/directives/mutate/index.ts"
            );
            i.d(r, "Mutate", function() {
              return l.Mutate;
            });
            var f = i(
              /*! ./resize */
              "./src/directives/resize/index.ts"
            );
            i.d(r, "Resize", function() {
              return f.Resize;
            });
            var d = i(
              /*! ./ripple */
              "./src/directives/ripple/index.ts"
            );
            i.d(r, "Ripple", function() {
              return d.Ripple;
            });
            var u = i(
              /*! ./scroll */
              "./src/directives/scroll/index.ts"
            );
            i.d(r, "Scroll", function() {
              return u.Scroll;
            });
            var c = i(
              /*! ./touch */
              "./src/directives/touch/index.ts"
            );
            i.d(r, "Touch", function() {
              return c.Touch;
            });
          }
        ),
        /***/
        "./src/directives/intersect/index.ts": (
          /*!*******************************************!*\
            !*** ./src/directives/intersect/index.ts ***!
            \*******************************************/
          /*! exports provided: Intersect, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Intersect", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            function o(d, u, c) {
              if (!(typeof window > "u" || !("IntersectionObserver" in window))) {
                var h = u.modifiers || {}, p = u.value, g = a(p) === "object" ? p : {
                  handler: p,
                  options: {}
                }, m = g.handler, v = g.options, y = new IntersectionObserver(function(E, C) {
                  var x;
                  E === void 0 && (E = []);
                  var b = (x = d._observe) === null || x === void 0 ? void 0 : x[c.context._uid];
                  if (b) {
                    var P = E.some(function(O) {
                      return O.isIntersecting;
                    });
                    m && (!h.quiet || b.init) && (!h.once || P || b.init) && m(E, C, P), P && h.once ? l(d, u, c) : b.init = !0;
                  }
                }, v);
                d._observe = Object(d._observe), d._observe[c.context._uid] = {
                  init: !1,
                  observer: y
                }, y.observe(d);
              }
            }
            function l(d, u, c) {
              var h, p = (h = d._observe) === null || h === void 0 ? void 0 : h[c.context._uid];
              p && (p.observer.unobserve(d), delete d._observe[c.context._uid]);
            }
            var f = {
              inserted: o,
              unbind: l
            };
            r.default = f;
          }
        ),
        /***/
        "./src/directives/mutate/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/mutate/index.ts ***!
            \****************************************/
          /*! exports provided: Mutate, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Mutate", function() {
              return d;
            });
            function a(u) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(h) {
                return typeof h;
              } : a = function(h) {
                return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
              }, a(u);
            }
            var o = function(u, c) {
              var h = {};
              for (var p in u)
                Object.prototype.hasOwnProperty.call(u, p) && c.indexOf(p) < 0 && (h[p] = u[p]);
              if (u != null && typeof Object.getOwnPropertySymbols == "function")
                for (var g = 0, p = Object.getOwnPropertySymbols(u); g < p.length; g++)
                  c.indexOf(p[g]) < 0 && Object.prototype.propertyIsEnumerable.call(u, p[g]) && (h[p[g]] = u[p[g]]);
              return h;
            };
            function l(u, c, h) {
              var p = c.modifiers || {}, g = c.value, m = a(g) === "object" ? g.handler : g, v = p.once, y = o(p, ["once"]), E = Object.keys(y).length > 0, C = a(g) === "object" && g.options ? g.options : E ? {
                attributes: y.attr,
                childList: y.child,
                subtree: y.sub,
                characterData: y.char
              } : {
                attributes: !0,
                childList: !0,
                subtree: !0,
                characterData: !0
              }, x = new MutationObserver(function(b, P) {
                u._mutate && (m(b, P), v && f(u, c, h));
              });
              x.observe(u, C), u._mutate = Object(u._mutate), u._mutate[h.context._uid] = {
                observer: x
              };
            }
            function f(u, c, h) {
              var p;
              !((p = u._mutate) === null || p === void 0) && p[h.context._uid] && (u._mutate[h.context._uid].observer.disconnect(), delete u._mutate[h.context._uid]);
            }
            var d = {
              inserted: l,
              unbind: f
            };
            r.default = d;
          }
        ),
        /***/
        "./src/directives/resize/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/resize/index.ts ***!
            \****************************************/
          /*! exports provided: Resize, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Resize", function() {
              return l;
            });
            function a(f, d, u) {
              var c = d.value, h = d.options || {
                passive: !0
              };
              window.addEventListener("resize", c, h), f._onResize = Object(f._onResize), f._onResize[u.context._uid] = {
                callback: c,
                options: h
              }, (!d.modifiers || !d.modifiers.quiet) && c();
            }
            function o(f, d, u) {
              var c;
              if (!((c = f._onResize) === null || c === void 0) && c[u.context._uid]) {
                var h = f._onResize[u.context._uid], p = h.callback, g = h.options;
                window.removeEventListener("resize", p, g), delete f._onResize[u.context._uid];
              }
            }
            var l = {
              inserted: a,
              unbind: o
            };
            r.default = l;
          }
        ),
        /***/
        "./src/directives/ripple/VRipple.sass": (
          /*!********************************************!*\
            !*** ./src/directives/ripple/VRipple.sass ***!
            \********************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/directives/ripple/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/ripple/index.ts ***!
            \****************************************/
          /*! exports provided: Ripple, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Ripple", function() {
              return D;
            }), i(
              /*! ./VRipple.sass */
              "./src/directives/ripple/VRipple.sass"
            );
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = function(I, w) {
              var B = typeof Symbol == "function" && I[Symbol.iterator];
              if (!B)
                return I;
              var j = B.call(I), k, X = [], rt;
              try {
                for (; (w === void 0 || w-- > 0) && !(k = j.next()).done; )
                  X.push(k.value);
              } catch (et) {
                rt = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (B = j.return) && B.call(j);
                } finally {
                  if (rt)
                    throw rt.error;
                }
              }
              return X;
            }, f = function(I, w, B) {
              if (B || arguments.length === 2)
                for (var j = 0, k = w.length, X; j < k; j++)
                  (X || !(j in w)) && (X || (X = Array.prototype.slice.call(w, 0, j)), X[j] = w[j]);
              return I.concat(X || Array.prototype.slice.call(w));
            }, d = 80;
            function u(I, w) {
              I.style.transform = w, I.style.webkitTransform = w;
            }
            function c(I) {
              return I.constructor.name === "TouchEvent";
            }
            function h(I) {
              return I.constructor.name === "KeyboardEvent";
            }
            var p = function(w, B, j) {
              j === void 0 && (j = {});
              var k = 0, X = 0;
              if (!h(w)) {
                var rt = B.getBoundingClientRect(), et = c(w) ? w.touches[w.touches.length - 1] : w;
                k = et.clientX - rt.left, X = et.clientY - rt.top;
              }
              var Z = 0, dt = 0.3;
              B._ripple && B._ripple.circle ? (dt = 0.15, Z = B.clientWidth / 2, Z = j.center ? Z : Z + Math.sqrt(Math.pow(k - Z, 2) + Math.pow(X - Z, 2)) / 4) : Z = Math.sqrt(Math.pow(B.clientWidth, 2) + Math.pow(B.clientHeight, 2)) / 2;
              var vt = (B.clientWidth - Z * 2) / 2 + "px", bt = (B.clientHeight - Z * 2) / 2 + "px", it = j.center ? vt : k - Z + "px", R = j.center ? bt : X - Z + "px";
              return {
                radius: Z,
                scale: dt,
                x: it,
                y: R,
                centerX: vt,
                centerY: bt
              };
            }, g = {
              /* eslint-disable max-statements */
              show: function(w, B, j) {
                if (j === void 0 && (j = {}), !(!B._ripple || !B._ripple.enabled)) {
                  var k = document.createElement("span"), X = document.createElement("span");
                  k.appendChild(X), k.className = "v-ripple__container", j.class && (k.className += " " + j.class);
                  var rt = p(w, B, j), et = rt.radius, Z = rt.scale, dt = rt.x, vt = rt.y, bt = rt.centerX, it = rt.centerY, R = et * 2 + "px";
                  X.className = "v-ripple__animation", X.style.width = R, X.style.height = R, B.appendChild(k);
                  var V = window.getComputedStyle(B);
                  V && V.position === "static" && (B.style.position = "relative", B.dataset.previousPosition = "static"), X.classList.add("v-ripple__animation--enter"), X.classList.add("v-ripple__animation--visible"), u(X, "translate(" + dt + ", " + vt + ") scale3d(" + Z + "," + Z + "," + Z + ")"), X.dataset.activated = String(performance.now()), setTimeout(function() {
                    X.classList.remove("v-ripple__animation--enter"), X.classList.add("v-ripple__animation--in"), u(X, "translate(" + bt + ", " + it + ") scale3d(1,1,1)");
                  }, 0);
                }
              },
              hide: function(w) {
                if (!(!w || !w._ripple || !w._ripple.enabled)) {
                  var B = w.getElementsByClassName("v-ripple__animation");
                  if (B.length !== 0) {
                    var j = B[B.length - 1];
                    if (!j.dataset.isHiding) {
                      j.dataset.isHiding = "true";
                      var k = performance.now() - Number(j.dataset.activated), X = Math.max(250 - k, 0);
                      setTimeout(function() {
                        j.classList.remove("v-ripple__animation--in"), j.classList.add("v-ripple__animation--out"), setTimeout(function() {
                          var rt, et = w.getElementsByClassName("v-ripple__animation");
                          et.length === 1 && w.dataset.previousPosition && (w.style.position = w.dataset.previousPosition, delete w.dataset.previousPosition), ((rt = j.parentNode) === null || rt === void 0 ? void 0 : rt.parentNode) === w && w.removeChild(j.parentNode);
                        }, 300);
                      }, X);
                    }
                  }
                }
              }
            };
            function m(I) {
              return typeof I > "u" || !!I;
            }
            function v(I) {
              var w = {}, B = I.currentTarget;
              if (!(!B || !B._ripple || B._ripple.touched || I.rippleStop)) {
                if (I.rippleStop = !0, c(I))
                  B._ripple.touched = !0, B._ripple.isTouch = !0;
                else if (B._ripple.isTouch)
                  return;
                if (w.center = B._ripple.centered || h(I), B._ripple.class && (w.class = B._ripple.class), c(I)) {
                  if (B._ripple.showTimerCommit)
                    return;
                  B._ripple.showTimerCommit = function() {
                    g.show(I, B, w);
                  }, B._ripple.showTimer = window.setTimeout(function() {
                    B && B._ripple && B._ripple.showTimerCommit && (B._ripple.showTimerCommit(), B._ripple.showTimerCommit = null);
                  }, d);
                } else
                  g.show(I, B, w);
              }
            }
            function y(I) {
              var w = I.currentTarget;
              if (!(!w || !w._ripple)) {
                if (window.clearTimeout(w._ripple.showTimer), I.type === "touchend" && w._ripple.showTimerCommit) {
                  w._ripple.showTimerCommit(), w._ripple.showTimerCommit = null, w._ripple.showTimer = setTimeout(function() {
                    y(I);
                  });
                  return;
                }
                window.setTimeout(function() {
                  w._ripple && (w._ripple.touched = !1);
                }), g.hide(w);
              }
            }
            function E(I) {
              var w = I.currentTarget;
              !w || !w._ripple || (w._ripple.showTimerCommit && (w._ripple.showTimerCommit = null), window.clearTimeout(w._ripple.showTimer));
            }
            var C = !1;
            function x(I) {
              !C && (I.keyCode === o.keyCodes.enter || I.keyCode === o.keyCodes.space) && (C = !0, v(I));
            }
            function b(I) {
              C = !1, y(I);
            }
            function P(I) {
              C === !0 && (C = !1, y(I));
            }
            function O(I, w, B) {
              var j = m(w.value);
              j || g.hide(I), I._ripple = I._ripple || {}, I._ripple.enabled = j;
              var k = w.value || {};
              k.center && (I._ripple.centered = !0), k.class && (I._ripple.class = w.value.class), k.circle && (I._ripple.circle = k.circle), j && !B ? (I.addEventListener("touchstart", v, {
                passive: !0
              }), I.addEventListener("touchend", y, {
                passive: !0
              }), I.addEventListener("touchmove", E, {
                passive: !0
              }), I.addEventListener("touchcancel", y), I.addEventListener("mousedown", v), I.addEventListener("mouseup", y), I.addEventListener("mouseleave", y), I.addEventListener("keydown", x), I.addEventListener("keyup", b), I.addEventListener("blur", P), I.addEventListener("dragstart", y, {
                passive: !0
              })) : !j && B && T(I);
            }
            function T(I) {
              I.removeEventListener("mousedown", v), I.removeEventListener("touchstart", v), I.removeEventListener("touchend", y), I.removeEventListener("touchmove", E), I.removeEventListener("touchcancel", y), I.removeEventListener("mouseup", y), I.removeEventListener("mouseleave", y), I.removeEventListener("keydown", x), I.removeEventListener("keyup", b), I.removeEventListener("dragstart", y), I.removeEventListener("blur", P);
            }
            function M(I, w, B) {
              O(I, w, !1), B.context && B.context.$nextTick(function() {
                var j = window.getComputedStyle(I);
                if (j && j.display === "inline") {
                  var k = B.fnOptions ? [B.fnOptions, B.context] : [B.componentInstance];
                  a.consoleWarn.apply(void 0, f(["v-ripple can only be used on block-level elements"], l(k), !1));
                }
              });
            }
            function L(I) {
              delete I._ripple, T(I);
            }
            function A(I, w) {
              if (w.value !== w.oldValue) {
                var B = m(w.oldValue);
                O(I, w, B);
              }
            }
            var D = {
              bind: M,
              unbind: L,
              update: A
            };
            r.default = D;
          }
        ),
        /***/
        "./src/directives/scroll/index.ts": (
          /*!****************************************!*\
            !*** ./src/directives/scroll/index.ts ***!
            \****************************************/
          /*! exports provided: Scroll, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Scroll", function() {
              return f;
            });
            function a(d) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? a = function(c) {
                return typeof c;
              } : a = function(c) {
                return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
              }, a(d);
            }
            function o(d, u, c) {
              var h = (u.modifiers || {}).self, p = h === void 0 ? !1 : h, g = u.value, m = a(g) === "object" && g.options || {
                passive: !0
              }, v = typeof g == "function" || "handleEvent" in g ? g : g.handler, y = p ? d : u.arg ? document.querySelector(u.arg) : window;
              y && (y.addEventListener("scroll", v, m), d._onScroll = Object(d._onScroll), d._onScroll[c.context._uid] = {
                handler: v,
                options: m,
                // Don't reference self
                target: p ? void 0 : y
              });
            }
            function l(d, u, c) {
              var h;
              if (!((h = d._onScroll) === null || h === void 0) && h[c.context._uid]) {
                var p = d._onScroll[c.context._uid], g = p.handler, m = p.options, v = p.target, y = v === void 0 ? d : v;
                y.removeEventListener("scroll", g, m), delete d._onScroll[c.context._uid];
              }
            }
            var f = {
              inserted: o,
              unbind: l
            };
            r.default = f;
          }
        ),
        /***/
        "./src/directives/touch/index.ts": (
          /*!***************************************!*\
            !*** ./src/directives/touch/index.ts ***!
            \***************************************/
          /*! exports provided: Touch, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Touch", function() {
              return p;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = function(m) {
              var v = m.touchstartX, y = m.touchendX, E = m.touchstartY, C = m.touchendY, x = 0.5, b = 16;
              m.offsetX = y - v, m.offsetY = C - E, Math.abs(m.offsetY) < x * Math.abs(m.offsetX) && (m.left && y < v - b && m.left(m), m.right && y > v + b && m.right(m)), Math.abs(m.offsetX) < x * Math.abs(m.offsetY) && (m.up && C < E - b && m.up(m), m.down && C > E + b && m.down(m));
            };
            function l(g, m) {
              var v = g.changedTouches[0];
              m.touchstartX = v.clientX, m.touchstartY = v.clientY, m.start && m.start(Object.assign(g, m));
            }
            function f(g, m) {
              var v = g.changedTouches[0];
              m.touchendX = v.clientX, m.touchendY = v.clientY, m.end && m.end(Object.assign(g, m)), o(m);
            }
            function d(g, m) {
              var v = g.changedTouches[0];
              m.touchmoveX = v.clientX, m.touchmoveY = v.clientY, m.move && m.move(Object.assign(g, m));
            }
            function u(g) {
              var m = {
                touchstartX: 0,
                touchstartY: 0,
                touchendX: 0,
                touchendY: 0,
                touchmoveX: 0,
                touchmoveY: 0,
                offsetX: 0,
                offsetY: 0,
                left: g.left,
                right: g.right,
                up: g.up,
                down: g.down,
                start: g.start,
                move: g.move,
                end: g.end
              };
              return {
                touchstart: function(y) {
                  return l(y, m);
                },
                touchend: function(y) {
                  return f(y, m);
                },
                touchmove: function(y) {
                  return d(y, m);
                }
              };
            }
            function c(g, m, v) {
              var y = m.value, E = y.parent ? g.parentElement : g, C = y.options || {
                passive: !0
              };
              if (E) {
                var x = u(m.value);
                E._touchHandlers = Object(E._touchHandlers), E._touchHandlers[v.context._uid] = x, Object(a.keys)(x).forEach(function(b) {
                  E.addEventListener(b, x[b], C);
                });
              }
            }
            function h(g, m, v) {
              var y = m.value.parent ? g.parentElement : g;
              if (!(!y || !y._touchHandlers)) {
                var E = y._touchHandlers[v.context._uid];
                Object(a.keys)(E).forEach(function(C) {
                  y.removeEventListener(C, E[C]);
                }), delete y._touchHandlers[v.context._uid];
              }
            }
            var p = {
              inserted: c,
              unbind: h
            };
            r.default = p;
          }
        ),
        /***/
        "./src/framework.ts": (
          /*!**************************!*\
            !*** ./src/framework.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./install */
              "./src/install.ts"
            ), o = i(
              /*! ./services */
              "./src/services/index.ts"
            ), l = (
              /** @class */
              function() {
                function f(d) {
                  d === void 0 && (d = {}), this.framework = {
                    isHydrating: !1
                  }, this.installed = [], this.preset = {}, this.userPreset = {}, this.userPreset = d, this.use(o.Presets), this.use(o.Application), this.use(o.Breakpoint), this.use(o.Goto), this.use(o.Icons), this.use(o.Lang), this.use(o.Theme);
                }
                return f.prototype.init = function(d, u) {
                  var c = this;
                  this.installed.forEach(function(h) {
                    var p = c.framework[h];
                    p.framework = c.framework, p.init(d, u);
                  }), this.framework.rtl = !!this.preset.rtl;
                }, f.prototype.use = function(d) {
                  var u = d.property;
                  this.installed.includes(u) || (this.framework[u] = new d(this.preset, this), this.installed.push(u));
                }, f.install = a.install, f.installed = !1, f.version = "2.7.1", f.config = {
                  silent: !1
                }, f;
              }()
            );
            r.default = l;
          }
        ),
        /***/
        "./src/index.ts": (
          /*!**********************!*\
            !*** ./src/index.ts ***!
            \**********************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./components */
              "./src/components/index.ts"
            ), o = i(
              /*! ./directives */
              "./src/directives/index.ts"
            ), l = i(
              /*! ./framework */
              "./src/framework.ts"
            ), f = function() {
              return f = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, f.apply(this, arguments);
            };
            r.default = l.default;
            var d = l.default.install;
            l.default.install = function(u, c) {
              d.call(l.default, u, f({
                components: a,
                directives: o
              }, c));
            }, typeof window < "u" && window.Vue && window.Vue.use(l.default);
          }
        ),
        /***/
        "./src/install.ts": (
          /*!************************!*\
            !*** ./src/install.ts ***!
            \************************/
          /*! exports provided: install */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "install", function() {
              return f;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ./util/console */
              "./src/util/console.ts"
            );
            function f(d, u) {
              if (u === void 0 && (u = {}), !f.installed) {
                f.installed = !0, o.a !== d && Object(l.consoleError)(`Multiple instances of Vue detected
See https://github.com/vuetifyjs/vuetify/issues/4068

If you're seeing "$attrs is readonly", it's caused by this`);
                var c = u.components || {}, h = u.directives || {};
                for (var p in h) {
                  var g = h[p];
                  d.directive(p, g);
                }
                (function m(v) {
                  if (v) {
                    for (var y in v) {
                      var E = v[y];
                      E && !m(E.$_vuetify_subcomponents) && d.component(y, E);
                    }
                    return !0;
                  }
                  return !1;
                })(c), !d.$_vuetify_installed && (d.$_vuetify_installed = !0, d.mixin({
                  beforeCreate: function() {
                    var v = this.$options;
                    v.vuetify ? (v.vuetify.init(this, this.$ssrContext), this.$vuetify = d.observable(v.vuetify.framework)) : this.$vuetify = v.parent && v.parent.$vuetify || this;
                  },
                  beforeMount: function() {
                    this.$options.vuetify && this.$el && this.$el.hasAttribute("data-server-rendered") && (this.$vuetify.isHydrating = !0, this.$vuetify.breakpoint.update(!0));
                  },
                  mounted: function() {
                    this.$options.vuetify && this.$vuetify.isHydrating && (this.$vuetify.isHydrating = !1, this.$vuetify.breakpoint.update());
                  }
                }));
              }
            }
          }
        ),
        /***/
        "./src/locale/af.ts": (
          /*!**************************!*\
            !*** ./src/locale/af.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "badge",
              close: "Close",
              dataIterator: {
                noResultsText: "Geen ooreenstemmende resultate is gevind nie",
                loadingText: "Loading item..."
              },
              dataTable: {
                itemsPerPageText: "Rye per bladsy:",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending..",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Aantal per bladsy:",
                itemsPerPageAll: "Alles",
                nextPage: "Volgende bladsy",
                prevPage: "Vorige bladsy",
                firstPage: "Eerste bladsy",
                lastPage: "Laaste bladsy",
                pageText: "{0}-{1} van {2}"
              },
              datePicker: {
                itemsSelected: "{0} gekies",
                nextMonthAriaLabel: "Volgende maand",
                nextYearAriaLabel: "Volgende jaar",
                prevMonthAriaLabel: "Vorige maand",
                prevYearAriaLabel: "Vorige jaar"
              },
              noDataText: "Geen data is beskikbaar nie",
              carousel: {
                prev: "Vorige visuele",
                next: "Volgende visuele",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} meer"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginasie-navigasie",
                  next: "Volgende bladsy",
                  previous: "Vorige bladsy",
                  page: "Gaan na bladsy {0}",
                  currentPage: "Huidige bladsy, Bladsy {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ar.ts": (
          /*!**************************!*\
            !*** ./src/locale/ar.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "   ",
                loadingText: "  ..."
              },
              dataTable: {
                itemsPerPageText: "   :",
                ariaLabel: {
                  sortDescending: " .",
                  sortAscending: " .",
                  sortNone: " .",
                  activateNone: "  .",
                  activateDescending: "  .",
                  activateAscending: "  ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "   :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "  {0}",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "  ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: "  {0}  {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1}  )"
              },
              timePicker: {
                am: "",
                pm: ""
              },
              pagination: {
                ariaLabel: {
                  wrapper: "  ",
                  next: " ",
                  previous: " ",
                  page: "{0}   ",
                  currentPage: "{0}   "
                }
              },
              rating: {
                ariaLabel: {
                  icon: " {0}  {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/az.ts": (
          /*!**************************!*\
            !*** ./src/locale/az.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "nian",
              close: "Bala",
              dataIterator: {
                noResultsText: "Uyun mlumat taplmad",
                loadingText: "Yklnir... Zhmt olmasa, gzlyin."
              },
              dataTable: {
                itemsPerPageText: "Shif ba stir say:",
                ariaLabel: {
                  sortDescending: "Azalan sra il dzlm.",
                  sortAscending: "Artan sra il dzlm.",
                  sortNone: "Sralanmamdr. ",
                  activateNone: "Sralaman ydr.",
                  activateDescending: "Azalan sra il dz.",
                  activateAscending: "Artan sra il dz."
                },
                sortBy: "Srala"
              },
              dataFooter: {
                itemsPerPageText: "Shif ba stir say:",
                itemsPerPageAll: "Hams",
                nextPage: "Nvbti shif",
                prevPage: "vvlki shif",
                firstPage: "lk shif",
                lastPage: "Son shif",
                pageText: "{0} - {1} aras, Cmi: {2} qeydiyyat"
              },
              datePicker: {
                itemsSelected: "{0} element seildi",
                nextMonthAriaLabel: "Nvbti ay",
                nextYearAriaLabel: "Nvbti yl",
                prevMonthAriaLabel: "Ken ay",
                prevYearAriaLabel: "Ken yl"
              },
              noDataText: "Bu grntd mlumat yoxdur.",
              carousel: {
                prev: "vvlki grnt",
                next: "Nvbti grnt",
                ariaLabel: {
                  delimiter: "Galereya shif {0} / {1}"
                }
              },
              calendar: {
                moreEvents: "{0} dad daha"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fayl",
                counterSize: "{0} fayl (cmi {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Shiflm Naviqasiyas",
                  next: "Nvbti shif",
                  previous: "vvlki shif",
                  page: "Shify get {0}",
                  currentPage: "Cari shif, Shif {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/bg.ts": (
          /*!**************************!*\
            !*** ./src/locale/bg.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "   ",
                loadingText: "  ..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: "   .",
                  sortAscending: "   .",
                  sortNone: " .",
                  activateNone: "    .",
                  activateDescending: "     .",
                  activateAscending: "     ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "  ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: " {0}  {1}  "
                }
              },
              calendar: {
                moreEvents: " {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1} )"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ca.ts": (
          /*!**************************!*\
            !*** ./src/locale/ca.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Insgnia",
              close: "Tancar",
              dataIterator: {
                noResultsText: "Sense dades per mostrar",
                loadingText: "Carregant..."
              },
              dataTable: {
                itemsPerPageText: "Files per pgina:",
                ariaLabel: {
                  sortDescending: "Ordre descendent.",
                  sortAscending: "Ordre ascendent.",
                  sortNone: "Sense ordenar.",
                  activateNone: "Premi per treure la ordenaci.",
                  activateDescending: "Premi per ordenar descendent.",
                  activateAscending: "Premi per ordenar ascendent."
                },
                sortBy: "Ordenat per"
              },
              dataFooter: {
                itemsPerPageText: "Elements per pgina:",
                itemsPerPageAll: "Tot",
                nextPage: "Pgina segent",
                prevPage: "Pgina anterior",
                firstPage: "Primera pgina",
                lastPage: "ltima pgina",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} seleccionats",
                nextMonthAriaLabel: "El mes que ve",
                nextYearAriaLabel: "L'any que ve",
                prevMonthAriaLabel: "Mes anterior",
                prevYearAriaLabel: "Any anterior"
              },
              noDataText: "Sense dades",
              carousel: {
                prev: "Visualitzaci prvia",
                next: "Visualitzaci segent",
                ariaLabel: {
                  delimiter: "Diapositiva {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} ms"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fitxers",
                counterSize: "{0} fitxers ({1} en total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegaci de la pgina",
                  next: "Pgina segent",
                  previous: "Pgina anterior",
                  page: "Ves a la pgina {0}",
                  currentPage: "Pgina actual, pgina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Puntuaci {0} de {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ckb.ts": (
          /*!***************************!*\
            !*** ./src/locale/ckb.ts ***!
            \***************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "   ",
                loadingText: " ..."
              },
              dataTable: {
                itemsPerPageText: "   :",
                ariaLabel: {
                  sortDescending: ".   ",
                  sortAscending: ".   ",
                  sortNone: ".",
                  activateNone: "   .",
                  activateDescending: "   .",
                  activateAscending: "     ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "   :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "   ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: "  {0}  {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1}   )"
              },
              timePicker: {
                am: " ",
                pm: " "
              },
              pagination: {
                ariaLabel: {
                  wrapper: " ",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: "  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/cs.ts": (
          /*!**************************!*\
            !*** ./src/locale/cs.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznak",
              close: "Zavt",
              dataIterator: {
                noResultsText: "Nenalezeny dn zznamy",
                loadingText: "Natm poloky..."
              },
              dataTable: {
                itemsPerPageText: "dk na strnku:",
                ariaLabel: {
                  sortDescending: "azeno sestupn.",
                  sortAscending: "azeno vzestupn.",
                  sortNone: "Neseazeno.",
                  activateNone: "Aktivovnm vypnete azen.",
                  activateDescending: "Aktivovnm se bude adit sestupn.",
                  activateAscending: "Aktivovnm se bude adit vzestupn."
                },
                sortBy: "adit dle"
              },
              dataFooter: {
                itemsPerPageText: "Poloek na strnku:",
                itemsPerPageAll: "Ve",
                nextPage: "Dal strana",
                prevPage: "Pedchoz strana",
                firstPage: "Prvn strana",
                lastPage: "Posledn strana",
                pageText: "{0}-{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} vybrno",
                nextMonthAriaLabel: "Pt msc",
                nextYearAriaLabel: "Pt rok",
                prevMonthAriaLabel: "Pedchoz msc",
                prevYearAriaLabel: "Pedchoz rok"
              },
              noDataText: "Nejsou dostupn dn data",
              carousel: {
                prev: "Pedchoz obrzek",
                next: "Dal obrzek",
                ariaLabel: {
                  delimiter: "Slide {0} z {1}"
                }
              },
              calendar: {
                moreEvents: "{0} dalch"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} soubor",
                counterSize: "{0} soubor ({1} celkem)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigace po strnkch",
                  next: "Dal strana",
                  previous: "Pedchoz strana",
                  page: "Pejt na strnku {0}",
                  currentPage: "Aktuln strnka, strnka {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Hodnocen {0} z {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/da.ts": (
          /*!**************************!*\
            !*** ./src/locale/da.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Emblem",
              close: "Luk",
              dataIterator: {
                noResultsText: "Ingen matchende data fundet",
                loadingText: "Indhenter data..."
              },
              dataTable: {
                itemsPerPageText: "Rkker pr. side:",
                ariaLabel: {
                  sortDescending: "Sorteret faldende.",
                  sortAscending: "Sorteret stigende.",
                  sortNone: "Ikke sorteret.",
                  activateNone: "Aktiver for at fjerne sortering.",
                  activateDescending: "Aktiver for at sortere faldende.",
                  activateAscending: "Aktiver for at sortere stigende."
                },
                sortBy: "Sorter efter"
              },
              dataFooter: {
                itemsPerPageText: "Rkker pr. side:",
                itemsPerPageAll: "Alle",
                nextPage: "Nste side",
                prevPage: "Forrige side",
                firstPage: "Frste side",
                lastPage: "Sidste side",
                pageText: "{0}-{1} af {2}"
              },
              datePicker: {
                itemsSelected: "{0} valgt",
                nextMonthAriaLabel: "Nste mned",
                nextYearAriaLabel: "Nste r",
                prevMonthAriaLabel: "Forrige mned",
                prevYearAriaLabel: "Forrige r"
              },
              noDataText: "Ingen data tilgngelig",
              carousel: {
                prev: "Forrige visuelle",
                next: "Nste visuelle",
                ariaLabel: {
                  delimiter: "Karrusel dias {0} af {1}"
                }
              },
              calendar: {
                moreEvents: "{0} mere"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer ({1} total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagineringsnavigation",
                  next: "Nste side",
                  previous: "Forrige side",
                  page: "G til side {0}",
                  currentPage: "Nuvrende side, Side {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Bedmmelse {0} af {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/de.ts": (
          /*!**************************!*\
            !*** ./src/locale/de.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Abzeichen",
              close: "Schlieen",
              dataIterator: {
                noResultsText: "Keine Elemente gefunden",
                loadingText: "Lade Elemente..."
              },
              dataTable: {
                itemsPerPageText: "Zeilen pro Seite:",
                ariaLabel: {
                  sortDescending: "Absteigend sortiert.",
                  sortAscending: "Aufsteigend sortiert.",
                  sortNone: "Nicht sortiert.",
                  activateNone: "Aktivieren um Sortierung zu entfernen.",
                  activateDescending: "Aktivieren um absteigend zu sortieren.",
                  activateAscending: "Aktivieren um aufsteigend zu sortieren."
                },
                sortBy: "Sortiere nach"
              },
              dataFooter: {
                itemsPerPageText: "Elemente pro Seite:",
                itemsPerPageAll: "Alle",
                nextPage: "Nchste Seite",
                prevPage: "Vorherige Seite",
                firstPage: "Erste Seite",
                lastPage: "Letzte Seite",
                pageText: "{0}-{1} von {2}"
              },
              datePicker: {
                itemsSelected: "{0} ausgewhlt",
                nextMonthAriaLabel: "Nchsten Monat",
                nextYearAriaLabel: "Nchstes Jahr",
                prevMonthAriaLabel: "Vorheriger Monat",
                prevYearAriaLabel: "Vorheriges Jahr"
              },
              noDataText: "Keine Daten vorhanden",
              carousel: {
                prev: "Vorheriges Bild",
                next: "Nchstes Bild",
                ariaLabel: {
                  delimiter: "Element {0} von {1}"
                }
              },
              calendar: {
                moreEvents: "{0} mehr"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} Dateien",
                counterSize: "{0} Dateien ({1} gesamt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Seitennavigation",
                  next: "Nchste Seite",
                  previous: "Vorherige Seite",
                  page: "Gehe zu Seite {0}",
                  currentPage: "Aktuelle Seite, Seite {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/el.ts": (
          /*!**************************!*\
            !*** ./src/locale/el.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "Close",
              dataIterator: {
                noResultsText: "  ",
                loadingText: "Loading item..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending.",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: "  ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: " ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "  ",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/en.ts": (
          /*!**************************!*\
            !*** ./src/locale/en.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Badge",
              close: "Close",
              dataIterator: {
                noResultsText: "No matching records found",
                loadingText: "Loading items..."
              },
              dataTable: {
                itemsPerPageText: "Rows per page:",
                ariaLabel: {
                  sortDescending: "Sorted descending.",
                  sortAscending: "Sorted ascending.",
                  sortNone: "Not sorted.",
                  activateNone: "Activate to remove sorting.",
                  activateDescending: "Activate to sort descending.",
                  activateAscending: "Activate to sort ascending."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Items per page:",
                itemsPerPageAll: "All",
                nextPage: "Next page",
                prevPage: "Previous page",
                firstPage: "First page",
                lastPage: "Last page",
                pageText: "{0}-{1} of {2}"
              },
              datePicker: {
                itemsSelected: "{0} selected",
                nextMonthAriaLabel: "Next month",
                nextYearAriaLabel: "Next year",
                prevMonthAriaLabel: "Previous month",
                prevYearAriaLabel: "Previous year"
              },
              noDataText: "No data available",
              carousel: {
                prev: "Previous visual",
                next: "Next visual",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} more"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Next page",
                  previous: "Previous page",
                  page: "Goto Page {0}",
                  currentPage: "Current Page, Page {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/es.ts": (
          /*!**************************!*\
            !*** ./src/locale/es.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Placa",
              close: "Cerrar",
              dataIterator: {
                noResultsText: "Ningn elemento coincide con la bsqueda",
                loadingText: "Cargando..."
              },
              dataTable: {
                itemsPerPageText: "Filas por pgina:",
                ariaLabel: {
                  sortDescending: "Orden descendente.",
                  sortAscending: "Orden ascendente.",
                  sortNone: "Sin ordenar.",
                  activateNone: "Pulse para quitar orden.",
                  activateDescending: "Pulse para ordenar de forma descendente.",
                  activateAscending: "Pulse para ordenar de forma ascendente."
                },
                sortBy: "Ordenado por"
              },
              dataFooter: {
                itemsPerPageText: "Elementos por pgina:",
                itemsPerPageAll: "Todos",
                nextPage: "Pgina siguiente",
                prevPage: "Pgina anterior",
                firstPage: "Primera pgina",
                lastPage: "ltima pgina",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} seleccionados",
                nextMonthAriaLabel: "Prximo mes",
                nextYearAriaLabel: "Prximo ao",
                prevMonthAriaLabel: "Mes anterior",
                prevYearAriaLabel: "Ao anterior"
              },
              noDataText: "No hay datos disponibles",
              carousel: {
                prev: "Visual anterior",
                next: "Visual siguiente",
                ariaLabel: {
                  delimiter: "Visual {0} de {1}"
                }
              },
              calendar: {
                moreEvents: "{0} ms"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} archivos",
                counterSize: "{0} archivos ({1} en total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegacin de paginacin",
                  next: "Pgina siguiente",
                  previous: "Pgina anterior",
                  page: "Ir a la pgina {0}",
                  currentPage: "Pgina actual, pgina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Puntuacin {0} de {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/et.ts": (
          /*!**************************!*\
            !*** ./src/locale/et.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Mrk",
              close: "Sulge",
              dataIterator: {
                noResultsText: "Vastavaid kirjeid ei leitud",
                loadingText: "Andmeid laaditakse..."
              },
              dataTable: {
                itemsPerPageText: "Ridu lehekljel:",
                ariaLabel: {
                  sortDescending: "Kahanevalt sorteeritud.",
                  sortAscending: "Kasvavalt sorteeritud.",
                  sortNone: "Ei ole sorteeritud.",
                  activateNone: "Vajuta uuesti sorteerimise eemaldamiseks.",
                  activateDescending: "Vajuta uuesti, et sorteerida kahanevalt.",
                  activateAscending: "Vajuta kasvavalt sorteerimiseks."
                },
                sortBy: "Sorteerimise alus"
              },
              dataFooter: {
                itemsPerPageText: "Kirjeid lehekljel:",
                itemsPerPageAll: "Kik",
                nextPage: "Jrgmine leheklg",
                prevPage: "Eelmine leheklg",
                firstPage: "Esimene leheklg",
                lastPage: "Viimane leheklg",
                pageText: "{0}-{1} {2}st"
              },
              datePicker: {
                itemsSelected: "{0} valitud",
                nextMonthAriaLabel: "Jrgmine kuu",
                nextYearAriaLabel: "Jrgmine aasta",
                prevMonthAriaLabel: "Eelmine kuu",
                prevYearAriaLabel: "Eelmine aasta"
              },
              noDataText: "Andmed puuduvad",
              carousel: {
                prev: "Eelmine visuaalne",
                next: "Jrgmine visuaalne",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} veel"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} faili",
                counterSize: "{0} faili (kokku {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Jrgmine leheklg",
                  previous: "Eelmine leheklg",
                  page: "Mine lehele {0}",
                  currentPage: "Praegune leht, leht {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fa.ts": (
          /*!**************************!*\
            !*** ./src/locale/fa.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "  ",
                loadingText: "  ..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: " ",
                  sortAscending: " ",
                  sortNone: " ",
                  activateNone: " ",
                  activateDescending: "  ",
                  activateAscending: "  "
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}  {1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0}  ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "  ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: " {0}  {1}"
                }
              },
              calendar: {
                moreEvents: "{ {0"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1}  )"
              },
              timePicker: {
                am: "  ",
                pm: "  "
              },
              pagination: {
                ariaLabel: {
                  wrapper: "  ",
                  next: " ",
                  previous: " ",
                  page: "  {0}",
                  currentPage: "{0}    "
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fi.ts": (
          /*!**************************!*\
            !*** ./src/locale/fi.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Infopiste",
              close: "Sulje",
              dataIterator: {
                noResultsText: "Ei osumia",
                loadingText: "Ladataan kohteita..."
              },
              dataTable: {
                itemsPerPageText: "Rivej sivulla:",
                ariaLabel: {
                  sortDescending: ": Jrjestetty laskevasti. Poista jrjestminen aktivoimalla.",
                  sortAscending: ": Jrjestetty nousevasti. Jrjest laskevasti aktivoimalla.",
                  sortNone: ": Ei jrjestetty. Jrjest nousevasti aktivoimalla.",
                  activateNone: "Aktivoi lajittelun poistamiseksi.",
                  activateDescending: "Aktivoi laskevien laskevien lajittelemiseksi.",
                  activateAscending: "Aktivoi lajitella nouseva."
                },
                sortBy: "Jrjest"
              },
              dataFooter: {
                itemsPerPageText: "Kohteita sivulla:",
                itemsPerPageAll: "Kaikki",
                nextPage: "Seuraava sivu",
                prevPage: "Edellinen sivu",
                firstPage: "Ensimminen sivu",
                lastPage: "Viimeinen sivu",
                pageText: "{0}-{1} ({2})"
              },
              datePicker: {
                itemsSelected: "{0} valittu",
                nextMonthAriaLabel: "Seuraava kuukausi",
                nextYearAriaLabel: "Ensi vuosi",
                prevMonthAriaLabel: "Edellinen kuukausi",
                prevYearAriaLabel: "Edellinen vuosi"
              },
              noDataText: "Ei dataa",
              carousel: {
                prev: "Edellinen kuva",
                next: "Seuraava kuva",
                ariaLabel: {
                  delimiter: "Karusellin kuva {0}/{1}"
                }
              },
              calendar: {
                moreEvents: "{0} lis"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} tiedostoa",
                counterSize: "{0} tiedostoa ({1} yhteens)"
              },
              timePicker: {
                am: "ap.",
                pm: "ip."
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Seuraava sivu",
                  previous: "Edellinen sivu",
                  page: "Mene sivulle {0}",
                  currentPage: "Nykyinen sivu, Sivu {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Luokitus {0}/{1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/fr.ts": (
          /*!**************************!*\
            !*** ./src/locale/fr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Badge",
              close: "Fermer",
              dataIterator: {
                noResultsText: "Aucun enregistrement correspondant trouv",
                loadingText: "Chargement de l'lment..."
              },
              dataTable: {
                itemsPerPageText: "Lignes par page :",
                ariaLabel: {
                  sortDescending: "Tri dcroissant.",
                  sortAscending: "Tri croissant.",
                  sortNone: "Non tri.",
                  activateNone: "Activer pour supprimer le tri.",
                  activateDescending: "Activer pour trier par ordre dcroissant.",
                  activateAscending: "Activer pour trier par ordre croissant."
                },
                sortBy: "Trier par"
              },
              dataFooter: {
                itemsPerPageText: "lements par page :",
                itemsPerPageAll: "Tous",
                nextPage: "Page suivante",
                prevPage: "Page prcdente",
                firstPage: "Premire page",
                lastPage: "Dernire page",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} slectionn(s)",
                nextMonthAriaLabel: "Le mois prochain",
                nextYearAriaLabel: "L'anne prochaine",
                prevMonthAriaLabel: "Le mois prcdent",
                prevYearAriaLabel: "Anne prcdente"
              },
              noDataText: "Aucune donne disponible",
              carousel: {
                prev: "Visuel prcdent",
                next: "Visuel suivant",
                ariaLabel: {
                  delimiter: "Diapositive {0} de {1}"
                }
              },
              calendar: {
                moreEvents: "{0} de plus"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fichier(s)",
                counterSize: "{0} fichier(s) ({1} au total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigation de pagination",
                  next: "Page suivante",
                  previous: "Page prcdente",
                  page: "Aller  la page {0}",
                  currentPage: "Page actuelle, Page {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Note de {0} sur {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/he.ts": (
          /*!**************************!*\
            !*** ./src/locale/he.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "   ",
                loadingText: " ..."
              },
              dataTable: {
                itemsPerPageText: " :",
                ariaLabel: {
                  sortDescending: "   .   .",
                  sortAscending: "   .     .",
                  sortNone: " .     .",
                  activateNone: "  .",
                  activateDescending: "  .",
                  activateAscending: "  ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: " :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "  ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1}  )"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: " ",
                  next: " ",
                  previous: " ",
                  page: "{0}  ",
                  currentPage: "{0}  , "
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/hr.ts": (
          /*!**************************!*\
            !*** ./src/locale/hr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Bed",
              close: "Zatvori",
              dataIterator: {
                noResultsText: "Nisu pronaene odgovarajue stavke",
                loadingText: "Uitavanje..."
              },
              dataTable: {
                itemsPerPageText: "Redaka po stranici:",
                ariaLabel: {
                  sortDescending: "Sortirano silazno.",
                  sortAscending: "Sortirano uzlazno.",
                  sortNone: "Nije sortirano.",
                  activateNone: "Odaberite za uklanjanje sortiranja.",
                  activateDescending: "Odaberite za silazno sortiranje.",
                  activateAscending: "Odaberite za uzlazno sortiranje."
                },
                sortBy: "Sortirajte po"
              },
              dataFooter: {
                itemsPerPageText: "Stavki po stranici:",
                itemsPerPageAll: "Sve",
                nextPage: "Sljedea stranica",
                prevPage: "Prethodna stranica",
                firstPage: "Prva stranica",
                lastPage: "Posljednja stranica",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} odabrano",
                nextMonthAriaLabel: "Sljedei mjesec",
                nextYearAriaLabel: "Slijedee godine",
                prevMonthAriaLabel: "Prethodni mjesec",
                prevYearAriaLabel: "Prola godina"
              },
              noDataText: "Nema dostupnih podataka",
              carousel: {
                prev: "Prethodno",
                next: "Sljedee",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Jo {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "Odabranih datoteka: {0}",
                counterSize: "Odabranih datoteka: {0} ({1} ukupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija stranicama",
                  next: "Sljedea stranica",
                  previous: "Prethodna stranica",
                  page: "Idi na stranicu {0}",
                  currentPage: "Trenutna stranica, stranica {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/hu.ts": (
          /*!**************************!*\
            !*** ./src/locale/hu.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Jelvny",
              close: "Bezrs",
              dataIterator: {
                noResultsText: "Nincs egyez tallat",
                loadingText: "Betlts..."
              },
              dataTable: {
                itemsPerPageText: "Elem oldalanknt:",
                ariaLabel: {
                  sortDescending: "Cskken sorrendbe rendezve.",
                  sortAscending: "Nvekv sorrendbe rendezve.",
                  sortNone: "Rendezetlen.",
                  activateNone: "Rendezs trlse.",
                  activateDescending: "Aktivld a cskken rendezsrt.",
                  activateAscending: "Aktivld a nvekv rendezsrt."
                },
                sortBy: "Rendezs"
              },
              dataFooter: {
                itemsPerPageText: "Elem oldalanknt:",
                itemsPerPageAll: "Mind",
                nextPage: "Kvetkez oldal",
                prevPage: "Elz oldal",
                firstPage: "Els oldal",
                lastPage: "Utols oldal",
                pageText: "{0}-{1} / {2}"
              },
              datePicker: {
                itemsSelected: "{0} kivlasztva",
                nextMonthAriaLabel: "Kvetkez hnap",
                nextYearAriaLabel: "Kvetkez v",
                prevMonthAriaLabel: "Elz hnap",
                prevYearAriaLabel: "Elz v"
              },
              noDataText: "Nincs elrhet adat",
              carousel: {
                prev: "Elz",
                next: "Kvetkez",
                ariaLabel: {
                  delimiter: "Dia {0}/{1}"
                }
              },
              calendar: {
                moreEvents: "{0} tovbbi"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fjl",
                counterSize: "{0} fjl ({1} sszesen)"
              },
              timePicker: {
                am: "de",
                pm: "du"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Oldal navigci",
                  next: "Kvetkez oldal",
                  previous: "Elz oldal",
                  page: "Menj a(z) {0}. oldalra",
                  currentPage: "Aktulis oldal: {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/id.ts": (
          /*!**************************!*\
            !*** ./src/locale/id.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Lencana",
              close: "Tutup",
              dataIterator: {
                noResultsText: "Tidak ditemukan catatan yang cocok",
                loadingText: "Memuat data..."
              },
              dataTable: {
                itemsPerPageText: "Baris per halaman:",
                ariaLabel: {
                  sortDescending: "Diurutkan kebawah.",
                  sortAscending: "Diurutkan keatas.",
                  sortNone: "Tidak diurutkan.",
                  activateNone: "Aktifkan untuk menghapus penyortiran.",
                  activateDescending: "Aktifkan untuk mengurutkan kebawah.",
                  activateAscending: "Aktifkan untuk mengurutkan keatas."
                },
                sortBy: "Urutkan berdasar"
              },
              dataFooter: {
                itemsPerPageText: "Item per halaman:",
                itemsPerPageAll: "Semua",
                nextPage: "Halaman selanjutnya",
                prevPage: "Halaman sebelumnya",
                firstPage: "Halaman pertama",
                lastPage: "Halaman terakhir",
                pageText: "{0}-{1} dari {2}"
              },
              datePicker: {
                itemsSelected: "{0} dipilih",
                nextMonthAriaLabel: "Bulan depan",
                nextYearAriaLabel: "Tahun depan",
                prevMonthAriaLabel: "Bulan sebelumnya",
                prevYearAriaLabel: "Tahun sebelumnya"
              },
              noDataText: "Tidak ada data tersedia",
              carousel: {
                prev: "Visual sebelumnya",
                next: "Visual selanjutnya",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} lagi"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} berkas",
                counterSize: "{0} berkas (dari total {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigasi Pagination",
                  next: "Halaman selanjutnya",
                  previous: "Halaman sebelumnya",
                  page: "Buka halaman {0}",
                  currentPage: "Halaman Saat Ini, Halaman {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/index.ts": (
          /*!*****************************!*\
            !*** ./src/locale/index.ts ***!
            \*****************************/
          /*! exports provided: af, ar, bg, ca, ckb, cs, da, de, el, en, es, et, fa, fi, fr, hr, hu, he, id, it, ja, ko, lv, lt, nl, no, pl, pt, ro, ru, sk, sl, srCyrl, srLatn, sv, th, tr, az, uk, vi, zhHans, zhHant */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./af */
              "./src/locale/af.ts"
            );
            i.d(r, "af", function() {
              return a.default;
            });
            var o = i(
              /*! ./ar */
              "./src/locale/ar.ts"
            );
            i.d(r, "ar", function() {
              return o.default;
            });
            var l = i(
              /*! ./bg */
              "./src/locale/bg.ts"
            );
            i.d(r, "bg", function() {
              return l.default;
            });
            var f = i(
              /*! ./ca */
              "./src/locale/ca.ts"
            );
            i.d(r, "ca", function() {
              return f.default;
            });
            var d = i(
              /*! ./ckb */
              "./src/locale/ckb.ts"
            );
            i.d(r, "ckb", function() {
              return d.default;
            });
            var u = i(
              /*! ./cs */
              "./src/locale/cs.ts"
            );
            i.d(r, "cs", function() {
              return u.default;
            });
            var c = i(
              /*! ./da */
              "./src/locale/da.ts"
            );
            i.d(r, "da", function() {
              return c.default;
            });
            var h = i(
              /*! ./de */
              "./src/locale/de.ts"
            );
            i.d(r, "de", function() {
              return h.default;
            });
            var p = i(
              /*! ./el */
              "./src/locale/el.ts"
            );
            i.d(r, "el", function() {
              return p.default;
            });
            var g = i(
              /*! ./en */
              "./src/locale/en.ts"
            );
            i.d(r, "en", function() {
              return g.default;
            });
            var m = i(
              /*! ./es */
              "./src/locale/es.ts"
            );
            i.d(r, "es", function() {
              return m.default;
            });
            var v = i(
              /*! ./et */
              "./src/locale/et.ts"
            );
            i.d(r, "et", function() {
              return v.default;
            });
            var y = i(
              /*! ./fa */
              "./src/locale/fa.ts"
            );
            i.d(r, "fa", function() {
              return y.default;
            });
            var E = i(
              /*! ./fi */
              "./src/locale/fi.ts"
            );
            i.d(r, "fi", function() {
              return E.default;
            });
            var C = i(
              /*! ./fr */
              "./src/locale/fr.ts"
            );
            i.d(r, "fr", function() {
              return C.default;
            });
            var x = i(
              /*! ./hr */
              "./src/locale/hr.ts"
            );
            i.d(r, "hr", function() {
              return x.default;
            });
            var b = i(
              /*! ./hu */
              "./src/locale/hu.ts"
            );
            i.d(r, "hu", function() {
              return b.default;
            });
            var P = i(
              /*! ./he */
              "./src/locale/he.ts"
            );
            i.d(r, "he", function() {
              return P.default;
            });
            var O = i(
              /*! ./id */
              "./src/locale/id.ts"
            );
            i.d(r, "id", function() {
              return O.default;
            });
            var T = i(
              /*! ./it */
              "./src/locale/it.ts"
            );
            i.d(r, "it", function() {
              return T.default;
            });
            var M = i(
              /*! ./ja */
              "./src/locale/ja.ts"
            );
            i.d(r, "ja", function() {
              return M.default;
            });
            var L = i(
              /*! ./ko */
              "./src/locale/ko.ts"
            );
            i.d(r, "ko", function() {
              return L.default;
            });
            var A = i(
              /*! ./lv */
              "./src/locale/lv.ts"
            );
            i.d(r, "lv", function() {
              return A.default;
            });
            var D = i(
              /*! ./lt */
              "./src/locale/lt.ts"
            );
            i.d(r, "lt", function() {
              return D.default;
            });
            var I = i(
              /*! ./nl */
              "./src/locale/nl.ts"
            );
            i.d(r, "nl", function() {
              return I.default;
            });
            var w = i(
              /*! ./no */
              "./src/locale/no.ts"
            );
            i.d(r, "no", function() {
              return w.default;
            });
            var B = i(
              /*! ./pl */
              "./src/locale/pl.ts"
            );
            i.d(r, "pl", function() {
              return B.default;
            });
            var j = i(
              /*! ./pt */
              "./src/locale/pt.ts"
            );
            i.d(r, "pt", function() {
              return j.default;
            });
            var k = i(
              /*! ./ro */
              "./src/locale/ro.ts"
            );
            i.d(r, "ro", function() {
              return k.default;
            });
            var X = i(
              /*! ./ru */
              "./src/locale/ru.ts"
            );
            i.d(r, "ru", function() {
              return X.default;
            });
            var rt = i(
              /*! ./sk */
              "./src/locale/sk.ts"
            );
            i.d(r, "sk", function() {
              return rt.default;
            });
            var et = i(
              /*! ./sl */
              "./src/locale/sl.ts"
            );
            i.d(r, "sl", function() {
              return et.default;
            });
            var Z = i(
              /*! ./sr-Cyrl */
              "./src/locale/sr-Cyrl.ts"
            );
            i.d(r, "srCyrl", function() {
              return Z.default;
            });
            var dt = i(
              /*! ./sr-Latn */
              "./src/locale/sr-Latn.ts"
            );
            i.d(r, "srLatn", function() {
              return dt.default;
            });
            var vt = i(
              /*! ./sv */
              "./src/locale/sv.ts"
            );
            i.d(r, "sv", function() {
              return vt.default;
            });
            var bt = i(
              /*! ./th */
              "./src/locale/th.ts"
            );
            i.d(r, "th", function() {
              return bt.default;
            });
            var it = i(
              /*! ./tr */
              "./src/locale/tr.ts"
            );
            i.d(r, "tr", function() {
              return it.default;
            });
            var R = i(
              /*! ./az */
              "./src/locale/az.ts"
            );
            i.d(r, "az", function() {
              return R.default;
            });
            var V = i(
              /*! ./uk */
              "./src/locale/uk.ts"
            );
            i.d(r, "uk", function() {
              return V.default;
            });
            var tt = i(
              /*! ./vi */
              "./src/locale/vi.ts"
            );
            i.d(r, "vi", function() {
              return tt.default;
            });
            var Y = i(
              /*! ./zh-Hans */
              "./src/locale/zh-Hans.ts"
            );
            i.d(r, "zhHans", function() {
              return Y.default;
            });
            var W = i(
              /*! ./zh-Hant */
              "./src/locale/zh-Hant.ts"
            );
            i.d(r, "zhHant", function() {
              return W.default;
            });
          }
        ),
        /***/
        "./src/locale/it.ts": (
          /*!**************************!*\
            !*** ./src/locale/it.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Distintivo",
              close: "Chiudi",
              dataIterator: {
                noResultsText: "Nessun risultato trovato",
                loadingText: "Caricamento in corso..."
              },
              dataTable: {
                itemsPerPageText: "Righe per pagina:",
                ariaLabel: {
                  sortDescending: "Ordinati in ordine decrescente.",
                  sortAscending: "Ordinati in ordine crescente.",
                  sortNone: "Non ordinato.",
                  activateNone: "Attiva per rimuovere l'ordinamento.",
                  activateDescending: "Attiva per ordinare in ordine decrescente.",
                  activateAscending: "Attiva per ordinare in ordine crescente."
                },
                sortBy: "Ordina per"
              },
              dataFooter: {
                itemsPerPageText: "Elementi per pagina:",
                itemsPerPageAll: "Tutti",
                nextPage: "Pagina seguente",
                prevPage: "Pagina precedente",
                firstPage: "Prima pagina",
                lastPage: "Ultima pagina",
                pageText: "{0}-{1} di {2}"
              },
              datePicker: {
                itemsSelected: "{0} selezionati",
                nextMonthAriaLabel: "Il prossimo mese",
                nextYearAriaLabel: "L'anno prossimo",
                prevMonthAriaLabel: "Il mese scorso",
                prevYearAriaLabel: "L'anno scorso"
              },
              noDataText: "Nessun elemento disponibile",
              carousel: {
                prev: "Vista precedente",
                next: "Prossima vista",
                ariaLabel: {
                  delimiter: "Carousel slide {0} di {1}"
                }
              },
              calendar: {
                moreEvents: "{0} di pi"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} file",
                counterSize: "{0} file ({1} in totale)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigazione impaginazione",
                  next: "Pagina seguente",
                  previous: "Pagina precedente",
                  page: "Vai alla pagina {0}",
                  currentPage: "Pagina corrente, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Valutazione {0} di {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ja.ts": (
          /*!**************************!*\
            !*** ./src/locale/ja.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "",
                loadingText: "..."
              },
              dataTable: {
                itemsPerPageText: "1",
                ariaLabel: {
                  sortDescending: "",
                  sortAscending: "",
                  sortNone: "",
                  activateNone: "",
                  activateDescending: "",
                  activateAscending: ""
                },
                sortBy: ""
              },
              dataFooter: {
                itemsPerPageText: "1",
                itemsPerPageAll: "",
                nextPage: "",
                prevPage: "",
                firstPage: "",
                lastPage: "",
                pageText: "{0}-{1}  / {2}"
              },
              datePicker: {
                itemsSelected: "{0}",
                nextMonthAriaLabel: "",
                nextYearAriaLabel: "",
                prevMonthAriaLabel: "",
                prevYearAriaLabel: ""
              },
              noDataText: "",
              carousel: {
                prev: "",
                next: "",
                ariaLabel: {
                  delimiter: " {0} / {1}"
                }
              },
              calendar: {
                moreEvents: "{0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ( {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "",
                  next: "",
                  previous: "",
                  page: "{0}",
                  currentPage: " {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: " {1}  {0}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ko.ts": (
          /*!**************************!*\
            !*** ./src/locale/ko.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "  .",
                loadingText: " ..."
              },
              dataTable: {
                itemsPerPageText: "   :",
                ariaLabel: {
                  sortDescending: " .",
                  sortAscending: " .",
                  sortNone: " .",
                  activateNone: "  .",
                  activateDescending: "   .",
                  activateAscending: "   ."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "   :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{2}  {0}-{1}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: "",
                prevMonthAriaLabel: "",
                prevYearAriaLabel: ""
              },
              noDataText: " .",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "",
                pm: ""
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: " ",
                  previous: " ",
                  page: "  {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/lt.ts": (
          /*!**************************!*\
            !*** ./src/locale/lt.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "enklelis",
              close: "Udaryti",
              dataIterator: {
                noResultsText: "Nerasta atitinkani ra",
                loadingText: "Kraunama..."
              },
              dataTable: {
                itemsPerPageText: "Eiluts per puslap:",
                ariaLabel: {
                  sortDescending: "Irikiuota majimo tvarka.",
                  sortAscending: "Irikiuota didjimo tvarka.",
                  sortNone: "Nerikiuota.",
                  activateNone: "Suaktyvinkite, jei norite rikiavim paalinti.",
                  activateDescending: "Suaktyvinkite, jei norite rikiuoti majimo tvarka.",
                  activateAscending: "Suaktyvinkite, jei norite rikiuoti didjimo tvarka."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "raai per puslap:",
                itemsPerPageAll: "Visi",
                nextPage: "Kitas puslapis",
                prevPage: "Ankstesnis puslapis",
                firstPage: "Pirmas puslapis",
                lastPage: "Paskutinis puslapis",
                pageText: "{0}-{1} i {2}"
              },
              datePicker: {
                itemsSelected: "{0} pasirinkta",
                nextMonthAriaLabel: "Kit mnes",
                nextYearAriaLabel: "Kitais metais",
                prevMonthAriaLabel: "Praeita mnes",
                prevYearAriaLabel: "Praeiti metai"
              },
              noDataText: "Nra duomen",
              carousel: {
                prev: "Ankstesnioji skaidr",
                next: "Kita skaidr",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Daugiau {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fail",
                counterSize: "{0} fail ({1} i viso)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Puslapio narymas",
                  next: "Kitas puslapis",
                  previous: "Ankstesnis puslapis",
                  page: "Eiti  puslap {0}",
                  currentPage: "Dabartinis puslapis, puslapis {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/lv.ts": (
          /*!**************************!*\
            !*** ./src/locale/lv.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "etons",
              close: "Aizvrt",
              dataIterator: {
                noResultsText: "Nekas netika atrasts",
                loadingText: "Ield..."
              },
              dataTable: {
                itemsPerPageText: "Rdt lap:",
                ariaLabel: {
                  sortDescending: "Sakrtots dilsto secb.",
                  sortAscending: "Sakrtots augo secb.",
                  sortNone: "Nav sakrtots.",
                  activateNone: "Aktivizt, lai noemtu krtoanu.",
                  activateDescending: "Aktivizt, lai sakrtotu dilsto secb.",
                  activateAscending: "Aktivizt, lai sakrtotu augo secb."
                },
                sortBy: "Sort by"
              },
              dataFooter: {
                itemsPerPageText: "Rdt lap:",
                itemsPerPageAll: "Visu",
                nextPage: "Nkam lapa",
                prevPage: "Iepriekj lapa",
                firstPage: "Pirm lapa",
                lastPage: "Pdj lapa",
                pageText: "{0}-{1} no {2}"
              },
              datePicker: {
                itemsSelected: "{0} izvlts",
                nextMonthAriaLabel: "Nkammnes",
                nextYearAriaLabel: "Nkamgad",
                prevMonthAriaLabel: "Iepriekjais mnesis",
                prevYearAriaLabel: "Iepriekjais gads"
              },
              noDataText: "Nav pieejamu datu",
              carousel: {
                prev: "Iepriekjais slaids",
                next: "Nkamais slaids",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "Vl {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} files",
                counterSize: "{0} files ({1} in total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigcija pagination",
                  next: "Nkam lapa",
                  previous: "Iepriekj lapa",
                  page: "Iet uz lapu {0}",
                  currentPage: "Pareizj lapa, lapa {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/nl.ts": (
          /*!**************************!*\
            !*** ./src/locale/nl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "insigne",
              close: "Sluiten",
              dataIterator: {
                noResultsText: "Geen overeenkomende resultaten gevonden",
                loadingText: "Items aan het laden..."
              },
              dataTable: {
                itemsPerPageText: "Rijen per pagina:",
                ariaLabel: {
                  sortDescending: "Aflopend gesorteerd.",
                  sortAscending: "Oplopend gesorteerd.",
                  sortNone: "Niet gesorteerd.",
                  activateNone: "Activeer om de sortering te verwijderen.",
                  activateDescending: "Activeer om aflopend te sorteren.",
                  activateAscending: "Activeer om oplopend te sorteren."
                },
                sortBy: "Sorteer volgens"
              },
              dataFooter: {
                itemsPerPageText: "Aantal per pagina:",
                itemsPerPageAll: "Alles",
                nextPage: "Volgende pagina",
                prevPage: "Vorige pagina",
                firstPage: "Eerste pagina",
                lastPage: "Laatste pagina",
                pageText: "{0}-{1} van {2}"
              },
              datePicker: {
                itemsSelected: "{0} geselecteerd",
                nextMonthAriaLabel: "Volgende maand",
                nextYearAriaLabel: "Volgend jaar",
                prevMonthAriaLabel: "Vorige maand",
                prevYearAriaLabel: "Vorig jaar"
              },
              noDataText: "Geen gegevens beschikbaar",
              carousel: {
                prev: "Vorig beeld",
                next: "Volgend beeld",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} meer"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} bestanden",
                counterSize: "{0} bestanden ({1} in totaal)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginanavigatie",
                  next: "Volgende pagina",
                  previous: "Vorige pagina",
                  page: "Ga naar pagina {0}",
                  currentPage: "Huidige pagina, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/no.ts": (
          /*!**************************!*\
            !*** ./src/locale/no.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Skilt",
              close: "Lukk",
              dataIterator: {
                noResultsText: "Fant ingen matchende elementer.",
                loadingText: "Laster elementer..."
              },
              dataTable: {
                itemsPerPageText: "Rader per side:",
                ariaLabel: {
                  sortDescending: "Sortert synkende.",
                  sortAscending: "Sortert stigende.",
                  sortNone: "Ikke sortert.",
                  activateNone: "Aktiver for  fjerne sortering.",
                  activateDescending: "Aktiver for  sortere synkende.",
                  activateAscending: "Aktiver for  sortere stigende."
                },
                sortBy: "Sorter etter"
              },
              dataFooter: {
                itemsPerPageText: "Elementer per side:",
                itemsPerPageAll: "Alle",
                nextPage: "Neste side",
                prevPage: "Forrige side",
                firstPage: "Frste side",
                lastPage: "Siste side",
                pageText: "{0}-{1} av {2}"
              },
              datePicker: {
                itemsSelected: "{0} valgt",
                nextMonthAriaLabel: "Neste mned",
                nextYearAriaLabel: "Neste r",
                prevMonthAriaLabel: "Forrige mned",
                prevYearAriaLabel: "Forrige r"
              },
              noDataText: "Ingen data er tilgjengelig",
              carousel: {
                prev: "Forrige bilde",
                next: "Neste bilde",
                ariaLabel: {
                  delimiter: "Karusellbilde {0} av {1}"
                }
              },
              calendar: {
                moreEvents: "{0} flere"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer ({1} totalt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Paginasjonsnavigasjon",
                  next: "Neste side",
                  previous: "Forrige side",
                  page: "G til side {0}",
                  currentPage: "Gjeldende side, side {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/pl.ts": (
          /*!**************************!*\
            !*** ./src/locale/pl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznaka",
              close: "Zamknij",
              dataIterator: {
                noResultsText: "Nie znaleziono danych odpowiadajcych wyszukiwaniu",
                loadingText: "Wczytywanie danych..."
              },
              dataTable: {
                itemsPerPageText: "Wierszy na stronie:",
                ariaLabel: {
                  sortDescending: "Sortowanie malejco. Kliknij aby zmieni.",
                  sortAscending: "Sortowanie rosnco. Kliknij aby zmieni.",
                  sortNone: "Bez sortowania. Kliknij aby posortowa rosnco.",
                  activateNone: "Kliknij aby usun sortowanie.",
                  activateDescending: "Kliknij aby posortowa malejco.",
                  activateAscending: "Kliknij aby posortowa rosnco."
                },
                sortBy: "Sortuj wedug"
              },
              dataFooter: {
                itemsPerPageText: "Pozycji na stronie:",
                itemsPerPageAll: "Wszystkie",
                nextPage: "Nastpna strona",
                prevPage: "Poprzednia strona",
                firstPage: "Pierwsza strona",
                lastPage: "Ostatnia strona",
                pageText: "{0}-{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} dat(y)",
                nextMonthAriaLabel: "Nastpny miesic",
                nextYearAriaLabel: "Nastpny rok",
                prevMonthAriaLabel: "Poprzedni miesic",
                prevYearAriaLabel: "Poprzedni rok"
              },
              noDataText: "Brak danych",
              carousel: {
                prev: "Poprzedni obraz",
                next: "Nastpny obraz",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} wicej"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "Liczba plikw: {0}",
                counterSize: "Liczba plikw: {0} (cznie {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Nawigacja paginacyjna",
                  next: "Nastpna strona",
                  previous: "Poprzednia strona",
                  page: "Id do strony {0}",
                  currentPage: "Bieca strona, strona {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/pt.ts": (
          /*!**************************!*\
            !*** ./src/locale/pt.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Distintivo",
              close: "Fechar",
              dataIterator: {
                noResultsText: "Nenhum dado encontrado",
                loadingText: "Carregando itens..."
              },
              dataTable: {
                itemsPerPageText: "Linhas por pgina:",
                ariaLabel: {
                  sortDescending: "Ordenado decrescente.",
                  sortAscending: "Ordenado crescente.",
                  sortNone: "No ordenado.",
                  activateNone: "Ative para remover a ordenao.",
                  activateDescending: "Ative para ordenar decrescente.",
                  activateAscending: "Ative para ordenar crescente."
                },
                sortBy: "Ordenar por"
              },
              dataFooter: {
                itemsPerPageText: "Itens por pgina:",
                itemsPerPageAll: "Todos",
                nextPage: "Prxima pgina",
                prevPage: "Pgina anterior",
                firstPage: "Primeira pgina",
                lastPage: "ltima pgina",
                pageText: "{0}-{1} de {2}"
              },
              datePicker: {
                itemsSelected: "{0} selecionado(s)",
                nextMonthAriaLabel: "Prximo ms",
                nextYearAriaLabel: "Prximo ano",
                prevMonthAriaLabel: "Ms anterior",
                prevYearAriaLabel: "Ano anterior"
              },
              noDataText: "No h dados disponveis",
              carousel: {
                prev: "Viso anterior",
                next: "Prxima viso",
                ariaLabel: {
                  delimiter: "Slide {0} de {1} do carrossel"
                }
              },
              calendar: {
                moreEvents: "Mais {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} arquivo(s)",
                counterSize: "{0} arquivo(s) ({1} no total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navegao de paginao",
                  next: "Prxima pgina",
                  previous: "Pgina anterior",
                  page: "Ir  pgina {0}",
                  currentPage: "Pgina atual, pgina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ro.ts": (
          /*!**************************!*\
            !*** ./src/locale/ro.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Insign",
              close: "nchidei",
              dataIterator: {
                noResultsText: "Nu s-au gsit nregistrri corespunztoare",
                loadingText: "Se ncarc articolele..."
              },
              dataTable: {
                itemsPerPageText: "Rnduri pe pagin:",
                ariaLabel: {
                  sortDescending: "Sortate descendent.",
                  sortAscending: "Sortate ascendent.",
                  sortNone: "Nesortate.",
                  activateNone: "Activai pentru a elimina sortarea.",
                  activateDescending: "Activai pentru a sorta descendent.",
                  activateAscending: "Activai pentru a sorta ascendent."
                },
                sortBy: "Sortai dup"
              },
              dataFooter: {
                itemsPerPageText: "Articole pe pagin:",
                itemsPerPageAll: "Toate",
                nextPage: "Pagina urmtoare",
                prevPage: "Pagina anterioar",
                firstPage: "Prima pagin",
                lastPage: "Ultima pagin",
                pageText: "{0}-{1} din {2}"
              },
              datePicker: {
                itemsSelected: "{0} selectate",
                nextMonthAriaLabel: "Luna urmtoare",
                nextYearAriaLabel: "Anul urmtor",
                prevMonthAriaLabel: "Luna anterioar",
                prevYearAriaLabel: "Anul anterior"
              },
              noDataText: "Nu exist date disponibile",
              carousel: {
                prev: "Grafica anterioar",
                next: "Grafica urmtoare",
                ariaLabel: {
                  delimiter: "Slide carusel {0} din {1}"
                }
              },
              calendar: {
                moreEvents: "nc {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fiiere",
                counterSize: "{0} fiiere ({1} n total)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigare prin paginare",
                  next: "Pagina urmtoare",
                  previous: "Pagina anterioar",
                  page: "Mergei la pagina {0}",
                  currentPage: "Pagina curent, pagina {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating de {0} din {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/ru.ts": (
          /*!**************************!*\
            !*** ./src/locale/ru.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "   ",
                loadingText: " ..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: "  .",
                  sortAscending: "  .",
                  sortNone: " .",
                  activateNone: ",   .",
                  activateDescending: "   .",
                  activateAscending: "    ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: " ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: " {0}  {1}"
                }
              },
              calendar: {
                moreEvents: " {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: ": {0}",
                counterSize: ": {0} ( {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "  ",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sk.ts": (
          /*!**************************!*\
            !*** ./src/locale/sk.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Odznak",
              close: "Zavrie",
              dataIterator: {
                noResultsText: "Neboli njden iadne zznamy",
                loadingText: "Natavam poloky..."
              },
              dataTable: {
                itemsPerPageText: "Poet riadkov na strnku:",
                ariaLabel: {
                  sortDescending: "Zoraden zostupne.",
                  sortAscending: "Zoraden vzostupne.",
                  sortNone: "Nezoraden.",
                  activateNone: "Aktivujte na zruenie triedenia.",
                  activateDescending: "Aktivujte na zoradenie zostupne.",
                  activateAscending: "Aktivujte na zoradenie vzostupne."
                },
                sortBy: "Zoradi poda"
              },
              dataFooter: {
                itemsPerPageText: "Poet poloiek na strnku:",
                itemsPerPageAll: "Vetko",
                nextPage: "alia strnka",
                prevPage: "Predchdzajca strnka",
                firstPage: "Prv strnka",
                lastPage: "Posledn strnka",
                pageText: "{0}{1} z {2}"
              },
              datePicker: {
                itemsSelected: "{0} vybran",
                nextMonthAriaLabel: "al mesiac",
                nextYearAriaLabel: "al rok",
                prevMonthAriaLabel: "Predchdzajci mesiac",
                prevYearAriaLabel: "Predchdzajci rok"
              },
              noDataText: "Nie s dostupn iadne dta",
              carousel: {
                prev: "Predchdzajci obrzok",
                next: "Dal obrzok",
                ariaLabel: {
                  delimiter: "Snmka {0} z {1}"
                }
              },
              calendar: {
                moreEvents: "{0} alch"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} sborov",
                counterSize: "{0} sborov ({1} celkom)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigcia strnkovania",
                  next: "alia strnka",
                  previous: "Predchdzajca strnka",
                  page: "s na strnku {0}",
                  currentPage: "Aktulna strnka, strnka {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Hodnotenie {0} z {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sl.ts": (
          /*!**************************!*\
            !*** ./src/locale/sl.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Znaka",
              close: "Zapri",
              dataIterator: {
                noResultsText: "Ni iskanega zapisa",
                loadingText: "Nalaganje..."
              },
              dataTable: {
                itemsPerPageText: "Vrstic na stran:",
                ariaLabel: {
                  sortDescending: "Razvreno padajoe.",
                  sortAscending: "Razvreno naraajoe.",
                  sortNone: "Ni razvreno.",
                  activateNone: "Aktivirajte za odstranitev razvranja.",
                  activateDescending: "Aktivirajte za padajoe razvranje.",
                  activateAscending: "Aktivirajte za naraajoe razvranje."
                },
                sortBy: "Razvrsti po"
              },
              dataFooter: {
                itemsPerPageText: "Predmetov na stran:",
                itemsPerPageAll: "Vse",
                nextPage: "Naslednja stran",
                prevPage: "Prejnja stran",
                firstPage: "Prva stran",
                lastPage: "Zadnja stran",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} izbrano/-ih",
                nextMonthAriaLabel: "Naslednji mesec",
                nextYearAriaLabel: "Naslednje leto",
                prevMonthAriaLabel: "Prejnji mesec",
                prevYearAriaLabel: "Prejnje leto"
              },
              noDataText: "Ni podatkov",
              carousel: {
                prev: "Prejnji prikaz",
                next: "Naslednji prikaz",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "e {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} datotek",
                counterSize: "{0} datotek ({1} skupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija po strani po strani",
                  next: "Naslednja stran",
                  previous: "Prejnja stran",
                  page: "Pojdi na stran {0}",
                  currentPage: "Trenutna stran, stran {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sr-Cyrl.ts": (
          /*!*******************************!*\
            !*** ./src/locale/sr-Cyrl.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "    ",
                loadingText: " ..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: " .",
                  sortAscending: " .",
                  sortNone: " .",
                  activateNone: "   .",
                  activateDescending: "   .",
                  activateAscending: "   ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "  ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: " {0}  {1}"
                }
              },
              calendar: {
                moreEvents: "{0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1} )"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: " ",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: " {0}  {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sr-Latn.ts": (
          /*!*******************************!*\
            !*** ./src/locale/sr-Latn.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Znaka",
              close: "Zatvori",
              dataIterator: {
                noResultsText: "Nijedan zapis nije pronaen",
                loadingText: "Uitavanje stavke..."
              },
              dataTable: {
                itemsPerPageText: "Redova po stranici:",
                ariaLabel: {
                  sortDescending: "Sortirano opadajue.",
                  sortAscending: "Sortirano rastue.",
                  sortNone: "Nije sortirano.",
                  activateNone: "Klikni da ukloni sortiranje.",
                  activateDescending: "Klikni da sortira opadajue.",
                  activateAscending: "Klikni da sortira rastue."
                },
                sortBy: "Sortiraj po"
              },
              dataFooter: {
                itemsPerPageText: "Stavki po stranici:",
                itemsPerPageAll: "Sve",
                nextPage: "Sledea stranica",
                prevPage: "Prethodna stranica",
                firstPage: "Prva stranica",
                lastPage: "Poslednja stranica",
                pageText: "{0}-{1} od {2}"
              },
              datePicker: {
                itemsSelected: "{0} odabrano",
                nextMonthAriaLabel: "Sledeeg meseca",
                nextYearAriaLabel: "Sledee godine",
                prevMonthAriaLabel: "Prethodni mesec",
                prevYearAriaLabel: "Prethodna godina"
              },
              noDataText: "Nema dostupnih podataka",
              carousel: {
                prev: "Prethodna slika",
                next: "Sledea slika",
                ariaLabel: {
                  delimiter: "Slika {0} od {1}"
                }
              },
              calendar: {
                moreEvents: "{0} vie"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} fajlova",
                counterSize: "{0} fajlova ({1} ukupno)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Navigacija stranicama",
                  next: "Sledea stranica",
                  previous: "Prethodna stranica",
                  page: "Idi na stranu {0}",
                  currentPage: "Trenutna stranica, stranica {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Ocena {0} od {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/sv.ts": (
          /*!**************************!*\
            !*** ./src/locale/sv.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Bricka",
              close: "Stng",
              dataIterator: {
                noResultsText: "Inga poster funna",
                loadingText: "Laddar data..."
              },
              dataTable: {
                itemsPerPageText: "Rader per sida:",
                ariaLabel: {
                  sortDescending: "Sorterat fallande.",
                  sortAscending: "Sorterat stigande.",
                  sortNone: "Osorterat.",
                  activateNone: "Aktivera fr att ta bort sortering.",
                  activateDescending: "Aktivera fr sortering fallande.",
                  activateAscending: "Aktivera fr sortering stigande."
                },
                sortBy: "Sortera efter"
              },
              dataFooter: {
                itemsPerPageText: "Objekt per sida:",
                itemsPerPageAll: "Alla",
                nextPage: "Nsta sida",
                prevPage: "Fregende sida",
                firstPage: "Frsta sidan",
                lastPage: "Sista sidan",
                pageText: "{0}-{1} av {2}"
              },
              datePicker: {
                itemsSelected: "{0} markerade",
                nextMonthAriaLabel: "Nsta mnad",
                nextYearAriaLabel: "Nsta r",
                prevMonthAriaLabel: "Frra mnaden",
                prevYearAriaLabel: "Frra ret"
              },
              noDataText: "Ingen data tillgnglig",
              carousel: {
                prev: "Fregende vy",
                next: "Nsta vy",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: "{0} fler"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} filer",
                counterSize: "{0} filer (av {1} totalt)"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Pagination Navigation",
                  next: "Nsta sida",
                  previous: "Fregende sida",
                  page: "G till sidan {0}",
                  currentPage: "Aktuell sida, sida {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/th.ts": (
          /*!**************************!*\
            !*** ./src/locale/th.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "",
                loadingText: "..."
              },
              dataTable: {
                itemsPerPageText: ":",
                ariaLabel: {
                  sortDescending: "",
                  sortAscending: "",
                  sortNone: "",
                  activateNone: "",
                  activateDescending: "",
                  activateAscending: ""
                },
                sortBy: ""
              },
              dataFooter: {
                itemsPerPageText: ":",
                itemsPerPageAll: "",
                nextPage: "",
                prevPage: "",
                firstPage: "",
                lastPage: "",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: " {0} ",
                nextMonthAriaLabel: "",
                nextYearAriaLabel: "",
                prevMonthAriaLabel: "",
                prevYearAriaLabel: ""
              },
              noDataText: "",
              carousel: {
                prev: "",
                next: "",
                ariaLabel: {
                  delimiter: " {0}  {1}"
                }
              },
              calendar: {
                moreEvents: " {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ( {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "",
                  next: "",
                  previous: "",
                  page: " {0}",
                  currentPage: " ( {0})"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/tr.ts": (
          /*!**************************!*\
            !*** ./src/locale/tr.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "rozet",
              close: "Kapat",
              dataIterator: {
                noResultsText: "Eleen veri bulunamad",
                loadingText: "Ykleniyor... Ltfen bekleyin."
              },
              dataTable: {
                itemsPerPageText: "Sayfa bana satr:",
                ariaLabel: {
                  sortDescending: "Z den A ya sral.",
                  sortAscending: "A dan Z ye sral.",
                  sortNone: "Sral deil. ",
                  activateNone: "Sralamay kaldrmak iin etkinletir.",
                  activateDescending: "Z den A ya sralamak iin etkinletir.",
                  activateAscending: "A dan Z ye sralamak iin etkinletir."
                },
                sortBy: "Srala"
              },
              dataFooter: {
                itemsPerPageText: "Sayfa bana satr:",
                itemsPerPageAll: "Hepsi",
                nextPage: "Sonraki sayfa",
                prevPage: "nceki sayfa",
                firstPage: "lk sayfa",
                lastPage: "Son sayfa",
                pageText: "{0} - {1} aras, Toplam: {2} kayt"
              },
              datePicker: {
                itemsSelected: "{0} ge seildi",
                nextMonthAriaLabel: "Gelecek ay",
                nextYearAriaLabel: "Gelecek yl",
                prevMonthAriaLabel: "Getiimiz ay",
                prevYearAriaLabel: "Geen yl"
              },
              noDataText: "Bu grnmde veri yok.",
              carousel: {
                prev: "nceki grsel",
                next: "Sonraki grsel",
                ariaLabel: {
                  delimiter: "Galeri sayfa {0} / {1}"
                }
              },
              calendar: {
                moreEvents: "{0} tane daha"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} dosya",
                counterSize: "{0} dosya (toplamda {1})"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "Sayfalandrma Navigasyonu",
                  next: "Sonraki sayfa",
                  previous: "nceki sayfa",
                  page: "Sayfaya git {0}",
                  currentPage: "Geerli Sayfa, Sayfa {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/uk.ts": (
          /*!**************************!*\
            !*** ./src/locale/uk.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "     ",
                loadingText: "..."
              },
              dataTable: {
                itemsPerPageText: "  :",
                ariaLabel: {
                  sortDescending: "  .",
                  sortAscending: "  .",
                  sortNone: " .",
                  activateNone: ",   .",
                  activateDescending: ",    .",
                  activateAscending: ",    ."
                },
                sortBy: " "
              },
              dataFooter: {
                itemsPerPageText: "  :",
                itemsPerPageAll: "",
                nextPage: " ",
                prevPage: " ",
                firstPage: " ",
                lastPage: " ",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: "{0} ",
                nextMonthAriaLabel: " ",
                nextYearAriaLabel: " ",
                prevMonthAriaLabel: " ",
                prevYearAriaLabel: " "
              },
              noDataText: "   ",
              carousel: {
                prev: " ",
                next: " ",
                ariaLabel: {
                  delimiter: " {0}  {1}"
                }
              },
              calendar: {
                moreEvents: " {0}"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  ({1} )"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "  ",
                  next: " ",
                  previous: " ",
                  page: "   {0}",
                  currentPage: " ,  {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/vi.ts": (
          /*!**************************!*\
            !*** ./src/locale/vi.ts ***!
            \**************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "Huy hiu",
              close: "ng",
              dataIterator: {
                noResultsText: "Khng tm thy kt qu no",
                loadingText: "ang ti..."
              },
              dataTable: {
                itemsPerPageText: "S hng mi trang:",
                ariaLabel: {
                  sortDescending: "Sp xp gim dn.",
                  sortAscending: "Sp xp tng dn.",
                  sortNone: "Khng sp xp.",
                  activateNone: "Kch hot  b sp xp.",
                  activateDescending: "Kch hot  sp xp gim dn.",
                  activateAscending: "Kch hot  sp xp tng dn."
                },
                sortBy: "Sp xp"
              },
              dataFooter: {
                itemsPerPageText: "S mc mi trang:",
                itemsPerPageAll: "Ton b",
                nextPage: "Trang tip theo",
                prevPage: "Trang trc",
                firstPage: "Trang u",
                lastPage: "Trang cui",
                pageText: "{0}-{1} trn {2}"
              },
              datePicker: {
                itemsSelected: "{0} c chn",
                nextMonthAriaLabel: "Thng sau",
                nextYearAriaLabel: "Nm sau",
                prevMonthAriaLabel: "Thng trc",
                prevYearAriaLabel: "Nm trc"
              },
              noDataText: "Khng c d liu",
              carousel: {
                prev: "nh tip theo",
                next: "nh trc",
                ariaLabel: {
                  delimiter: "Carousel slide {0} trn {1}"
                }
              },
              calendar: {
                moreEvents: "{0} na"
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} tp",
                counterSize: "{0} tp (tng cng {1})"
              },
              timePicker: {
                am: "SA",
                pm: "CH"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "iu hng phn trang",
                  next: "Trang tip theo",
                  previous: "Trang trc",
                  page: "n trang {0}",
                  currentPage: "Trang hin ti, Trang {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "nh gi {0} trn {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/zh-Hans.ts": (
          /*!*******************************!*\
            !*** ./src/locale/zh-Hans.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "",
                loadingText: ""
              },
              dataTable: {
                itemsPerPageText: "",
                ariaLabel: {
                  sortDescending: "",
                  sortAscending: "",
                  sortNone: "",
                  activateNone: "",
                  activateDescending: "",
                  activateAscending: ""
                },
                sortBy: ""
              },
              dataFooter: {
                itemsPerPageText: "",
                itemsPerPageAll: "",
                nextPage: "",
                prevPage: "",
                firstPage: "",
                lastPage: "",
                pageText: "{0}-{1}  {2}"
              },
              datePicker: {
                itemsSelected: " {0}",
                nextMonthAriaLabel: "",
                nextYearAriaLabel: "",
                prevMonthAriaLabel: "",
                prevYearAriaLabel: ""
              },
              noDataText: "",
              carousel: {
                prev: "",
                next: "",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: " {0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  {1}"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "",
                  next: "",
                  previous: "",
                  page: " {0}",
                  currentPage: " {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/locale/zh-Hant.ts": (
          /*!*******************************!*\
            !*** ./src/locale/zh-Hant.ts ***!
            \*******************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), r.default = {
              badge: "",
              close: "",
              dataIterator: {
                noResultsText: "",
                loadingText: "..."
              },
              dataTable: {
                itemsPerPageText: "",
                ariaLabel: {
                  sortDescending: "",
                  sortAscending: "",
                  sortNone: "",
                  activateNone: "",
                  activateDescending: "",
                  activateAscending: ""
                },
                sortBy: ""
              },
              dataFooter: {
                itemsPerPageText: "",
                itemsPerPageAll: "",
                nextPage: "",
                prevPage: "",
                firstPage: "",
                lastPage: "",
                pageText: "{2}  {0}~{1} "
              },
              datePicker: {
                itemsSelected: " {0}",
                nextMonthAriaLabel: "",
                nextYearAriaLabel: "",
                prevMonthAriaLabel: "",
                prevYearAriaLabel: ""
              },
              noDataText: "",
              carousel: {
                prev: "",
                next: "",
                ariaLabel: {
                  delimiter: "Carousel slide {0} of {1}"
                }
              },
              calendar: {
                moreEvents: " {0} "
              },
              input: {
                clear: "Clear {0}",
                prependAction: "{0} prepended action",
                appendAction: "{0} appended action"
              },
              fileInput: {
                counter: "{0} ",
                counterSize: "{0}  {1}"
              },
              timePicker: {
                am: "AM",
                pm: "PM"
              },
              pagination: {
                ariaLabel: {
                  wrapper: "",
                  next: "",
                  previous: "",
                  page: " {0}",
                  currentPage: " {0}"
                }
              },
              rating: {
                ariaLabel: {
                  icon: "Rating {0} of {1}"
                }
              },
              loading: "Loading..."
            };
          }
        ),
        /***/
        "./src/mixins/activatable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/activatable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../delayable */
              "./src/mixins/delayable/index.ts"
            ), o = i(
              /*! ../toggleable */
              "./src/mixins/toggleable/index.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function u(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? u = function(m) {
                return typeof m;
              } : u = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, u(p);
            }
            var c = function(p) {
              var g = typeof Symbol == "function" && Symbol.iterator, m = g && p[g], v = 0;
              if (m)
                return m.call(p);
              if (p && typeof p.length == "number")
                return {
                  next: function() {
                    return p && v >= p.length && (p = void 0), {
                      value: p && p[v++],
                      done: !p
                    };
                  }
                };
              throw new TypeError(g ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, h = Object(l.default)(a.default, o.default);
            r.default = h.extend({
              name: "activatable",
              props: {
                activator: {
                  default: null,
                  validator: function(g) {
                    return ["string", "object"].includes(u(g));
                  }
                },
                disabled: Boolean,
                internalActivator: Boolean,
                openOnClick: {
                  type: Boolean,
                  default: !0
                },
                openOnHover: Boolean,
                openOnFocus: Boolean
              },
              data: function() {
                return {
                  // Do not use this directly, call getActivator() instead
                  activatorElement: null,
                  activatorNode: [],
                  events: ["click", "mouseenter", "mouseleave", "focus"],
                  listeners: {}
                };
              },
              watch: {
                activator: "resetActivator",
                openOnFocus: "resetActivator",
                openOnHover: "resetActivator"
              },
              mounted: function() {
                var g = Object(f.getSlotType)(this, "activator", !0);
                g && ["v-slot", "normal"].includes(g) && Object(d.consoleError)(`The activator slot must be bound, try '<template v-slot:activator="{ on }"><v-btn v-on="on">'`, this), this.addActivatorEvents();
              },
              beforeDestroy: function() {
                this.removeActivatorEvents();
              },
              methods: {
                addActivatorEvents: function() {
                  var g, m;
                  if (!(!this.activator || this.disabled || !this.getActivator())) {
                    this.listeners = this.genActivatorListeners();
                    var v = Object.keys(this.listeners);
                    try {
                      for (var y = c(v), E = y.next(); !E.done; E = y.next()) {
                        var C = E.value;
                        this.getActivator().addEventListener(C, this.listeners[C]);
                      }
                    } catch (x) {
                      g = {
                        error: x
                      };
                    } finally {
                      try {
                        E && !E.done && (m = y.return) && m.call(y);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                  }
                },
                genActivator: function() {
                  var g = Object(f.getSlot)(this, "activator", Object.assign(this.getValueProxy(), {
                    on: this.genActivatorListeners(),
                    attrs: this.genActivatorAttributes()
                  })) || [];
                  return this.activatorNode = g, g;
                },
                genActivatorAttributes: function() {
                  return {
                    role: this.openOnClick && !this.openOnHover ? "button" : void 0,
                    "aria-haspopup": !0,
                    "aria-expanded": String(this.isActive)
                  };
                },
                genActivatorListeners: function() {
                  var g = this;
                  if (this.disabled)
                    return {};
                  var m = {};
                  return this.openOnHover ? (m.mouseenter = function(v) {
                    g.getActivator(v), g.runDelay("open");
                  }, m.mouseleave = function(v) {
                    g.getActivator(v), g.runDelay("close");
                  }) : this.openOnClick && (m.click = function(v) {
                    var y = g.getActivator(v);
                    y && y.focus(), v.stopPropagation(), g.isActive = !g.isActive;
                  }), this.openOnFocus && (m.focus = function(v) {
                    g.getActivator(v), v.stopPropagation(), g.isActive = !g.isActive;
                  }), m;
                },
                getActivator: function(g) {
                  if (this.activatorElement)
                    return this.activatorElement;
                  var m = null;
                  if (this.activator) {
                    var v = this.internalActivator ? this.$el : document;
                    typeof this.activator == "string" ? m = v.querySelector(this.activator) : this.activator.$el ? m = this.activator.$el : m = this.activator;
                  } else if (this.activatorNode.length === 1 || this.activatorNode.length && !g) {
                    var y = this.activatorNode[0].componentInstance;
                    y && y.$options.mixins && //                         Activatable is indirectly used via Menuable
                    y.$options.mixins.some(function(E) {
                      return E.options && ["activatable", "menuable"].includes(E.options.name);
                    }) ? m = y.getActivator() : m = this.activatorNode[0].elm;
                  } else
                    g && (m = g.currentTarget || g.target);
                  return this.activatorElement = (m == null ? void 0 : m.nodeType) === Node.ELEMENT_NODE ? m : null, this.activatorElement;
                },
                getContentSlot: function() {
                  return Object(f.getSlot)(this, "default", this.getValueProxy(), !0);
                },
                getValueProxy: function() {
                  var g = this;
                  return {
                    get value() {
                      return g.isActive;
                    },
                    set value(m) {
                      g.isActive = m;
                    }
                  };
                },
                removeActivatorEvents: function() {
                  var g, m;
                  if (!(!this.activator || !this.activatorElement)) {
                    var v = Object.keys(this.listeners);
                    try {
                      for (var y = c(v), E = y.next(); !E.done; E = y.next()) {
                        var C = E.value;
                        this.activatorElement.removeEventListener(C, this.listeners[C]);
                      }
                    } catch (x) {
                      g = {
                        error: x
                      };
                    } finally {
                      try {
                        E && !E.done && (m = y.return) && m.call(y);
                      } finally {
                        if (g)
                          throw g.error;
                      }
                    }
                    this.listeners = {};
                  }
                },
                resetActivator: function() {
                  this.removeActivatorEvents(), this.activatorElement = null, this.getActivator(), this.addActivatorEvents();
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/applicationable/index.ts": (
          /*!*********************************************!*\
            !*** ./src/mixins/applicationable/index.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! ../positionable */
              "./src/mixins/positionable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function l(f, d) {
              return d === void 0 && (d = []), Object(o.default)(Object(a.factory)(["absolute", "fixed"])).extend({
                name: "applicationable",
                props: {
                  app: Boolean
                },
                computed: {
                  applicationProperty: function() {
                    return f;
                  }
                },
                watch: {
                  // If previous value was app
                  // reset the provided prop
                  app: function(c, h) {
                    h ? this.removeApplication(!0) : this.callUpdate();
                  },
                  applicationProperty: function(c, h) {
                    this.$vuetify.application.unregister(this._uid, h);
                  }
                },
                activated: function() {
                  this.callUpdate();
                },
                created: function() {
                  for (var c = 0, h = d.length; c < h; c++)
                    this.$watch(d[c], this.callUpdate);
                  this.callUpdate();
                },
                mounted: function() {
                  this.callUpdate();
                },
                deactivated: function() {
                  this.removeApplication();
                },
                destroyed: function() {
                  this.removeApplication();
                },
                methods: {
                  callUpdate: function() {
                    this.app && this.$vuetify.application.register(this._uid, this.applicationProperty, this.updateApplication());
                  },
                  removeApplication: function(c) {
                    c === void 0 && (c = !1), !(!c && !this.app) && this.$vuetify.application.unregister(this._uid, this.applicationProperty);
                  },
                  updateApplication: function() {
                    return 0;
                  }
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/binds-attrs/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/binds-attrs/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(f) {
              return function(d, u) {
                for (var c in u)
                  Object.prototype.hasOwnProperty.call(d, c) || this.$delete(this.$data[f], c);
                for (var c in d)
                  this.$set(this.$data[f], c, d[c]);
              };
            }
            r.default = o.a.extend({
              data: function() {
                return {
                  attrs$: {},
                  listeners$: {}
                };
              },
              created: function() {
                this.$watch("$attrs", l("attrs$"), {
                  immediate: !0
                }), this.$watch("$listeners", l("listeners$"), {
                  immediate: !0
                });
              }
            });
          }
        ),
        /***/
        "./src/mixins/bootable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/bootable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend().extend({
              name: "bootable",
              props: {
                eager: Boolean
              },
              data: function() {
                return {
                  isBooted: !1
                };
              },
              computed: {
                hasContent: function() {
                  return this.isBooted || this.eager || this.isActive;
                }
              },
              watch: {
                isActive: function() {
                  this.isBooted = !0;
                }
              },
              created: function() {
                "lazy" in this.$attrs && Object(a.removed)("lazy", this);
              },
              methods: {
                showLazyContent: function(d) {
                  return this.hasContent && d ? d() : [this.$createElement()];
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/button-group/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/button-group/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VItemGroup/VItemGroup */
              "./src/components/VItemGroup/VItemGroup.ts"
            );
            r.default = a.BaseItemGroup.extend({
              name: "button-group",
              provide: function() {
                return {
                  btnToggle: this
                };
              },
              computed: {
                classes: function() {
                  return a.BaseItemGroup.options.computed.classes.call(this);
                }
              },
              methods: {
                // Isn't being passed down through types
                genData: a.BaseItemGroup.options.methods.genData
              }
            });
          }
        ),
        /***/
        "./src/mixins/colorable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/colorable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), d = function() {
              return d = Object.assign || function(c) {
                for (var h, p = 1, g = arguments.length; p < g; p++) {
                  h = arguments[p];
                  for (var m in h)
                    Object.prototype.hasOwnProperty.call(h, m) && (c[m] = h[m]);
                }
                return c;
              }, d.apply(this, arguments);
            }, u = function(c, h) {
              var p = typeof Symbol == "function" && c[Symbol.iterator];
              if (!p)
                return c;
              var g = p.call(c), m, v = [], y;
              try {
                for (; (h === void 0 || h-- > 0) && !(m = g.next()).done; )
                  v.push(m.value);
              } catch (E) {
                y = {
                  error: E
                };
              } finally {
                try {
                  m && !m.done && (p = g.return) && p.call(g);
                } finally {
                  if (y)
                    throw y.error;
                }
              }
              return v;
            };
            r.default = o.a.extend({
              name: "colorable",
              props: {
                color: String
              },
              methods: {
                setBackgroundColor: function(h, p) {
                  var g;
                  return p === void 0 && (p = {}), typeof p.style == "string" ? (Object(l.consoleError)("style must be an object", this), p) : typeof p.class == "string" ? (Object(l.consoleError)("class must be an object", this), p) : (Object(f.isCssColor)(h) ? p.style = d(d({}, p.style), {
                    "background-color": "" + h,
                    "border-color": "" + h
                  }) : h && (p.class = d(d({}, p.class), (g = {}, g[h] = !0, g))), p);
                },
                setTextColor: function(h, p) {
                  var g;
                  if (p === void 0 && (p = {}), typeof p.style == "string")
                    return Object(l.consoleError)("style must be an object", this), p;
                  if (typeof p.class == "string")
                    return Object(l.consoleError)("class must be an object", this), p;
                  if (Object(f.isCssColor)(h))
                    p.style = d(d({}, p.style), {
                      color: "" + h,
                      "caret-color": "" + h
                    });
                  else if (h) {
                    var m = u(h.toString().trim().split(" ", 2), 2), v = m[0], y = m[1];
                    p.class = d(d({}, p.class), (g = {}, g[v + "--text"] = !0, g)), y && (p.class["text--" + y] = !0);
                  }
                  return p;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/comparable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/comparable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = o.a.extend({
              name: "comparable",
              props: {
                valueComparator: {
                  type: Function,
                  default: l.deepEqual
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/delayable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/delayable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend().extend({
              name: "delayable",
              props: {
                openDelay: {
                  type: [Number, String],
                  default: 0
                },
                closeDelay: {
                  type: [Number, String],
                  default: 0
                }
              },
              data: function() {
                return {
                  openTimeout: void 0,
                  closeTimeout: void 0
                };
              },
              methods: {
                /**
                 * Clear any pending delay timers from executing
                 */
                clearDelay: function() {
                  clearTimeout(this.openTimeout), clearTimeout(this.closeTimeout);
                },
                /**
                 * Runs callback after a specified delay
                 */
                runDelay: function(f, d) {
                  var u = this;
                  this.clearDelay();
                  var c = parseInt(this[f + "Delay"], 10);
                  this[f + "Timeout"] = setTimeout(d || function() {
                    u.isActive = {
                      open: !0,
                      close: !1
                    }[f];
                  }, c);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/dependent/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/dependent/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), o = function(d, u) {
              var c = typeof Symbol == "function" && d[Symbol.iterator];
              if (!c)
                return d;
              var h = c.call(d), p, g = [], m;
              try {
                for (; (u === void 0 || u-- > 0) && !(p = h.next()).done; )
                  g.push(p.value);
              } catch (v) {
                m = {
                  error: v
                };
              } finally {
                try {
                  p && !p.done && (c = h.return) && c.call(h);
                } finally {
                  if (m)
                    throw m.error;
                }
              }
              return g;
            }, l = function(d, u, c) {
              if (c || arguments.length === 2)
                for (var h = 0, p = u.length, g; h < p; h++)
                  (g || !(h in u)) && (g || (g = Array.prototype.slice.call(u, 0, h)), g[h] = u[h]);
              return d.concat(g || Array.prototype.slice.call(u));
            };
            function f(d) {
              for (var u = [], c = 0; c < d.length; c++) {
                var h = d[c];
                h.isActive && h.isDependent ? u.push(h) : u.push.apply(u, l([], o(f(h.$children)), !1));
              }
              return u;
            }
            r.default = Object(a.default)().extend({
              name: "dependent",
              data: function() {
                return {
                  closeDependents: !0,
                  isActive: !1,
                  isDependent: !0
                };
              },
              watch: {
                isActive: function(u) {
                  if (!u)
                    for (var c = this.getOpenDependents(), h = 0; h < c.length; h++)
                      c[h].isActive = !1;
                }
              },
              methods: {
                getOpenDependents: function() {
                  return this.closeDependents ? f(this.$children) : [];
                },
                getOpenDependentElements: function() {
                  for (var u = [], c = this.getOpenDependents(), h = 0; h < c.length; h++)
                    u.push.apply(u, l([], o(c[h].getClickableDependentElements()), !1));
                  return u;
                },
                getClickableDependentElements: function() {
                  var u = [this.$el];
                  return this.$refs.content && u.push(this.$refs.content), this.overlay && u.push(this.overlay.$el), u.push.apply(u, l([], o(this.getOpenDependentElements()), !1)), u;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/detachable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/detachable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../bootable */
              "./src/mixins/bootable/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), f = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function d(h) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(g) {
                return typeof g;
              } : d = function(g) {
                return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
              }, d(h);
            }
            function u(h) {
              var p = d(h);
              return p === "boolean" || p === "string" ? !0 : h.nodeType === Node.ELEMENT_NODE;
            }
            function c(h) {
              h.forEach(function(p) {
                p.elm && p.elm.parentNode && p.elm.parentNode.removeChild(p.elm);
              });
            }
            r.default = Object(l.default)(a.default).extend({
              name: "detachable",
              props: {
                attach: {
                  default: !1,
                  validator: u
                },
                contentClass: {
                  type: String,
                  default: ""
                }
              },
              data: function() {
                return {
                  activatorNode: null,
                  hasDetached: !1
                };
              },
              watch: {
                attach: function() {
                  this.hasDetached = !1, this.initDetach();
                },
                hasContent: function() {
                  this.$nextTick(this.initDetach);
                }
              },
              beforeMount: function() {
                var p = this;
                this.$nextTick(function() {
                  if (p.activatorNode) {
                    var g = Array.isArray(p.activatorNode) ? p.activatorNode : [p.activatorNode];
                    g.forEach(function(m) {
                      if (m.elm && p.$el.parentNode) {
                        var v = p.$el === p.$el.parentNode.firstChild ? p.$el : p.$el.nextSibling;
                        p.$el.parentNode.insertBefore(m.elm, v);
                      }
                    });
                  }
                });
              },
              mounted: function() {
                this.hasContent && this.initDetach();
              },
              deactivated: function() {
                this.isActive = !1;
              },
              beforeDestroy: function() {
                this.$refs.content && this.$refs.content.parentNode && this.$refs.content.parentNode.removeChild(this.$refs.content);
              },
              destroyed: function() {
                var p = this;
                if (this.activatorNode) {
                  var g = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];
                  if (this.$el.isConnected) {
                    var m = new MutationObserver(function(v) {
                      v.some(function(y) {
                        return Array.from(y.removedNodes).includes(p.$el);
                      }) && (m.disconnect(), c(g));
                    });
                    m.observe(this.$el.parentNode, {
                      subtree: !1,
                      childList: !0
                    });
                  } else
                    c(g);
                }
              },
              methods: {
                getScopeIdAttrs: function() {
                  var p, g = Object(o.getObjectValueByPath)(this.$vnode, "context.$options._scopeId");
                  return g && (p = {}, p[g] = "", p);
                },
                initDetach: function() {
                  if (!(this._isDestroyed || !this.$refs.content || this.hasDetached || // Leave menu in place if attached
                  // and dev has not changed target
                  this.attach === "" || // If used as a boolean prop (<v-menu attach>)
                  this.attach === !0 || // If bound to a boolean (<v-menu :attach="true">)
                  this.attach === "attach")) {
                    var p;
                    if (this.attach === !1 ? p = document.querySelector("[data-app]") : typeof this.attach == "string" ? p = document.querySelector(this.attach) : p = this.attach, !p) {
                      Object(f.consoleWarn)("Unable to locate target " + (this.attach || "[data-app]"), this);
                      return;
                    }
                    p.appendChild(this.$refs.content), this.hasDetached = !0;
                  }
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/elevatable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/elevatable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "elevatable",
              props: {
                elevation: [Number, String]
              },
              computed: {
                computedElevation: function() {
                  return this.elevation;
                },
                elevationClasses: function() {
                  var f, d = this.computedElevation;
                  return d == null ? {} : isNaN(parseInt(d)) ? {} : (f = {}, f["elevation-" + this.elevation] = !0, f);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/filterable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/filterable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "filterable",
              props: {
                noDataText: {
                  type: String,
                  default: "$vuetify.noDataText"
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/groupable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/groupable/index.ts ***!
            \***************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return o;
            });
            var a = i(
              /*! ../registrable */
              "./src/mixins/registrable/index.ts"
            );
            function o(f, d, u) {
              return Object(a.inject)(f, d, u).extend({
                name: "groupable",
                props: {
                  activeClass: {
                    type: String,
                    default: function() {
                      if (this[f])
                        return this[f].activeClass;
                    }
                  },
                  disabled: Boolean
                },
                data: function() {
                  return {
                    isActive: !1
                  };
                },
                computed: {
                  groupClasses: function() {
                    var h;
                    return this.activeClass ? (h = {}, h[this.activeClass] = this.isActive, h) : {};
                  }
                },
                created: function() {
                  this[f] && this[f].register(this);
                },
                beforeDestroy: function() {
                  this[f] && this[f].unregister(this);
                },
                methods: {
                  toggle: function(h) {
                    if (this.disabled && h) {
                      h.preventDefault();
                      return;
                    }
                    this.$emit("change");
                  }
                }
              });
            }
            var l = o("itemGroup");
            r.default = l;
          }
        ),
        /***/
        "./src/mixins/intersectable/index.ts": (
          /*!*******************************************!*\
            !*** ./src/mixins/intersectable/index.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return d;
            });
            var a = i(
              /*! ../../directives/intersect */
              "./src/directives/intersect/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            function d(u) {
              return f.a.extend({
                name: "intersectable",
                data: function() {
                  return {
                    isIntersecting: !1
                  };
                },
                mounted: function() {
                  a.default.inserted(this.$el, {
                    name: "intersect",
                    value: this.onObserve
                  }, this.$vnode);
                },
                destroyed: function() {
                  a.default.unbind(this.$el, {
                    name: "intersect",
                    value: this.onObserve
                  }, this.$vnode);
                },
                methods: {
                  onObserve: function(h, p, g) {
                    if (this.isIntersecting = g, !!g)
                      for (var m = 0, v = u.onVisible.length; m < v; m++) {
                        var y = this[u.onVisible[m]];
                        if (typeof y == "function") {
                          y();
                          continue;
                        }
                        Object(o.consoleWarn)(u.onVisible[m] + " method is not available on the instance but referenced in intersectable mixin options");
                      }
                  }
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/loadable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/loadable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../components/VProgressLinear */
              "./src/components/VProgressLinear/index.ts"
            );
            r.default = o.a.extend().extend({
              name: "loadable",
              props: {
                loading: {
                  type: [Boolean, String],
                  default: !1
                },
                loaderHeight: {
                  type: [Number, String],
                  default: 2
                }
              },
              methods: {
                genProgress: function() {
                  return this.loading === !1 ? null : this.$slots.progress || this.$createElement(l.default, {
                    props: {
                      absolute: !0,
                      color: this.loading === !0 || this.loading === "" ? this.color || "primary" : this.loading,
                      height: this.loaderHeight,
                      indeterminate: !0
                    }
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/localable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/localable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "localable",
              props: {
                locale: String
              },
              computed: {
                currentLocale: function() {
                  return this.locale || this.$vuetify.lang.current;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/measurable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/measurable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "measurable",
              props: {
                height: [Number, String],
                maxHeight: [Number, String],
                maxWidth: [Number, String],
                minHeight: [Number, String],
                minWidth: [Number, String],
                width: [Number, String]
              },
              computed: {
                measurableStyles: function() {
                  var d = {}, u = Object(a.convertToUnit)(this.height), c = Object(a.convertToUnit)(this.minHeight), h = Object(a.convertToUnit)(this.minWidth), p = Object(a.convertToUnit)(this.maxHeight), g = Object(a.convertToUnit)(this.maxWidth), m = Object(a.convertToUnit)(this.width);
                  return u && (d.height = u), c && (d.minHeight = c), h && (d.minWidth = h), p && (d.maxHeight = p), g && (d.maxWidth = g), m && (d.width = m), d;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/menuable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/menuable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../stackable */
              "./src/mixins/stackable/index.ts"
            ), o = i(
              /*! ../positionable */
              "./src/mixins/positionable/index.ts"
            ), l = i(
              /*! ../activatable */
              "./src/mixins/activatable/index.ts"
            ), f = i(
              /*! ../detachable */
              "./src/mixins/detachable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), u = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), c = function() {
              return c = Object.assign || function(p) {
                for (var g, m = 1, v = arguments.length; m < v; m++) {
                  g = arguments[m];
                  for (var y in g)
                    Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]);
                }
                return p;
              }, c.apply(this, arguments);
            }, h = Object(d.default)(a.default, Object(o.factory)(["top", "right", "bottom", "left", "absolute"]), l.default, f.default);
            r.default = h.extend().extend({
              name: "menuable",
              props: {
                allowOverflow: Boolean,
                light: Boolean,
                dark: Boolean,
                maxWidth: {
                  type: [Number, String],
                  default: "auto"
                },
                minWidth: [Number, String],
                nudgeBottom: {
                  type: [Number, String],
                  default: 0
                },
                nudgeLeft: {
                  type: [Number, String],
                  default: 0
                },
                nudgeRight: {
                  type: [Number, String],
                  default: 0
                },
                nudgeTop: {
                  type: [Number, String],
                  default: 0
                },
                nudgeWidth: {
                  type: [Number, String],
                  default: 0
                },
                offsetOverflow: Boolean,
                positionX: {
                  type: Number,
                  default: null
                },
                positionY: {
                  type: Number,
                  default: null
                },
                zIndex: {
                  type: [Number, String],
                  default: null
                }
              },
              data: function() {
                return {
                  activatorNode: [],
                  absoluteX: 0,
                  absoluteY: 0,
                  activatedBy: null,
                  activatorFixed: !1,
                  dimensions: {
                    activator: {
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0,
                      width: 0,
                      height: 0,
                      offsetTop: 0,
                      scrollHeight: 0,
                      offsetLeft: 0
                    },
                    content: {
                      top: 0,
                      left: 0,
                      bottom: 0,
                      right: 0,
                      width: 0,
                      height: 0,
                      offsetTop: 0,
                      scrollHeight: 0
                    }
                  },
                  relativeYOffset: 0,
                  hasJustFocused: !1,
                  hasWindow: !1,
                  inputActivator: !1,
                  isContentActive: !1,
                  pageWidth: 0,
                  pageYOffset: 0,
                  stackClass: "v-menu__content--active",
                  stackMinZIndex: 6
                };
              },
              computed: {
                computedLeft: function() {
                  var g = this.dimensions.activator, m = this.dimensions.content, v = (this.attach !== !1 ? g.offsetLeft : g.left) || 0, y = Math.max(g.width, m.width), E = 0;
                  if (E += v, (this.left || this.$vuetify.rtl && !this.right) && (E -= y - g.width), this.offsetX) {
                    var C = isNaN(Number(this.maxWidth)) ? g.width : Math.min(g.width, Number(this.maxWidth));
                    E += this.left ? -C : g.width;
                  }
                  return this.nudgeLeft && (E -= parseInt(this.nudgeLeft)), this.nudgeRight && (E += parseInt(this.nudgeRight)), E;
                },
                computedTop: function() {
                  var g = this.dimensions.activator, m = this.dimensions.content, v = 0;
                  return this.top && (v += g.height - m.height), this.attach !== !1 ? v += g.offsetTop : v += g.top + this.pageYOffset, this.offsetY && (v += this.top ? -g.height : g.height), this.nudgeTop && (v -= parseInt(this.nudgeTop)), this.nudgeBottom && (v += parseInt(this.nudgeBottom)), v;
                },
                hasActivator: function() {
                  return !!this.$slots.activator || !!this.$scopedSlots.activator || !!this.activator || !!this.inputActivator;
                },
                absoluteYOffset: function() {
                  return this.pageYOffset - this.relativeYOffset;
                }
              },
              watch: {
                disabled: function(g) {
                  g && this.callDeactivate();
                },
                isActive: function(g) {
                  this.disabled || (g ? this.callActivate() : this.callDeactivate());
                },
                positionX: "updateDimensions",
                positionY: "updateDimensions"
              },
              beforeMount: function() {
                this.hasWindow = typeof window < "u", this.hasWindow && window.addEventListener("resize", this.updateDimensions, !1);
              },
              beforeDestroy: function() {
                this.hasWindow && window.removeEventListener("resize", this.updateDimensions, !1);
              },
              methods: {
                absolutePosition: function() {
                  return {
                    offsetTop: this.positionY || this.absoluteY,
                    offsetLeft: this.positionX || this.absoluteX,
                    scrollHeight: 0,
                    top: this.positionY || this.absoluteY,
                    bottom: this.positionY || this.absoluteY,
                    left: this.positionX || this.absoluteX,
                    right: this.positionX || this.absoluteX,
                    height: 0,
                    width: 0
                  };
                },
                activate: function() {
                },
                calcLeft: function(g) {
                  return Object(u.convertToUnit)(this.attach !== !1 ? this.computedLeft : this.calcXOverflow(this.computedLeft, g));
                },
                calcTop: function() {
                  return Object(u.convertToUnit)(this.attach !== !1 ? this.computedTop : this.calcYOverflow(this.computedTop));
                },
                calcXOverflow: function(g, m) {
                  var v = g + m - this.pageWidth + 12;
                  return (!this.left || this.right) && v > 0 ? g = Math.max(g - v, 0) : g = Math.max(g, 12), g + this.getOffsetLeft();
                },
                calcYOverflow: function(g) {
                  var m = this.getInnerHeight(), v = this.absoluteYOffset + m, y = this.dimensions.activator, E = this.dimensions.content.height, C = g + E, x = v < C;
                  return x && this.offsetOverflow && // If we don't have enough room to offset
                  // the overflow, don't offset
                  y.top > E ? g = this.pageYOffset + (y.top - E) : x && !this.allowOverflow ? g = v - E - 12 : g < this.absoluteYOffset && !this.allowOverflow && (g = this.absoluteYOffset + 12), g < 12 ? 12 : g;
                },
                callActivate: function() {
                  this.hasWindow && this.activate();
                },
                callDeactivate: function() {
                  this.isContentActive = !1, this.deactivate();
                },
                checkForPageYOffset: function() {
                  this.hasWindow && (this.pageYOffset = this.activatorFixed ? 0 : this.getOffsetTop());
                },
                checkActivatorFixed: function() {
                  if (this.attach !== !1) {
                    this.activatorFixed = !1;
                    return;
                  }
                  for (var g = this.getActivator(); g; ) {
                    if (window.getComputedStyle(g).position === "fixed") {
                      this.activatorFixed = !0;
                      return;
                    }
                    g = g.offsetParent;
                  }
                  this.activatorFixed = !1;
                },
                deactivate: function() {
                },
                genActivatorListeners: function() {
                  var g = this, m = l.default.options.methods.genActivatorListeners.call(this), v = m.click;
                  return v && (m.click = function(y) {
                    g.openOnClick && v && v(y), g.absoluteX = y.clientX, g.absoluteY = y.clientY;
                  }), m;
                },
                getInnerHeight: function() {
                  return this.hasWindow ? window.innerHeight || document.documentElement.clientHeight : 0;
                },
                getOffsetLeft: function() {
                  return this.hasWindow ? window.pageXOffset || document.documentElement.scrollLeft : 0;
                },
                getOffsetTop: function() {
                  return this.hasWindow ? window.pageYOffset || document.documentElement.scrollTop : 0;
                },
                getRoundedBoundedClientRect: function(g) {
                  var m = g.getBoundingClientRect();
                  return {
                    top: Math.round(m.top),
                    left: Math.round(m.left),
                    bottom: Math.round(m.bottom),
                    right: Math.round(m.right),
                    width: Math.round(m.width),
                    height: Math.round(m.height)
                  };
                },
                measure: function(g) {
                  if (!g || !this.hasWindow)
                    return null;
                  var m = this.getRoundedBoundedClientRect(g);
                  if (this.attach !== !1) {
                    var v = window.getComputedStyle(g);
                    m.left = parseInt(v.marginLeft), m.top = parseInt(v.marginTop);
                  }
                  return m;
                },
                sneakPeek: function(g) {
                  var m = this;
                  requestAnimationFrame(function() {
                    var v = m.$refs.content;
                    if (!v || v.style.display !== "none") {
                      g();
                      return;
                    }
                    v.style.display = "inline-block", g(), v.style.display = "none";
                  });
                },
                startTransition: function() {
                  var g = this;
                  return new Promise(function(m) {
                    return requestAnimationFrame(function() {
                      g.isContentActive = g.hasJustFocused = g.isActive, m();
                    });
                  });
                },
                updateDimensions: function() {
                  var g = this;
                  this.hasWindow = typeof window < "u", this.checkActivatorFixed(), this.checkForPageYOffset(), this.pageWidth = document.documentElement.clientWidth;
                  var m = {
                    activator: c({}, this.dimensions.activator),
                    content: c({}, this.dimensions.content)
                  };
                  if (!this.hasActivator || this.absolute)
                    m.activator = this.absolutePosition();
                  else {
                    var v = this.getActivator();
                    if (!v)
                      return;
                    m.activator = this.measure(v), m.activator.offsetLeft = v.offsetLeft, this.attach !== !1 ? m.activator.offsetTop = v.offsetTop : m.activator.offsetTop = 0;
                  }
                  this.sneakPeek(function() {
                    if (g.$refs.content) {
                      if (g.$refs.content.offsetParent) {
                        var y = g.getRoundedBoundedClientRect(g.$refs.content.offsetParent);
                        g.relativeYOffset = window.pageYOffset + y.top, m.activator.top -= g.relativeYOffset, m.activator.left -= window.pageXOffset + y.left;
                      }
                      m.content = g.measure(g.$refs.content);
                    }
                    g.dimensions = m;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/mobile/index.ts": (
          /*!************************************!*\
            !*** ./src/mixins/mobile/index.ts ***!
            \************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "mobile",
              props: {
                mobileBreakpoint: {
                  type: [Number, String],
                  default: function() {
                    return this.$vuetify ? this.$vuetify.breakpoint.mobileBreakpoint : void 0;
                  },
                  validator: function(d) {
                    return !isNaN(Number(d)) || ["xs", "sm", "md", "lg", "xl"].includes(String(d));
                  }
                }
              },
              computed: {
                isMobile: function() {
                  var d = this.$vuetify.breakpoint, u = d.mobile, c = d.width, h = d.name, p = d.mobileBreakpoint;
                  if (p === this.mobileBreakpoint)
                    return u;
                  var g = parseInt(this.mobileBreakpoint, 10), m = !isNaN(g);
                  return m ? c < g : h === this.mobileBreakpoint;
                }
              },
              created: function() {
                this.$attrs.hasOwnProperty("mobile-break-point") && Object(a.deprecate)("mobile-break-point", "mobile-breakpoint", this);
              }
            });
          }
        ),
        /***/
        "./src/mixins/mouse/index.ts": (
          /*!***********************************!*\
            !*** ./src/mixins/mouse/index.ts ***!
            \***********************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function() {
              return l = Object.assign || function(f) {
                for (var d, u = 1, c = arguments.length; u < c; u++) {
                  d = arguments[u];
                  for (var h in d)
                    Object.prototype.hasOwnProperty.call(d, h) && (f[h] = d[h]);
                }
                return f;
              }, l.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "mouse",
              methods: {
                getDefaultMouseEventHandlers: function(d, u, c) {
                  var h;
                  c === void 0 && (c = !1);
                  var p = Object.keys(this.$listeners).filter(function(g) {
                    return g.endsWith(d);
                  }).reduce(function(g, m) {
                    return g[m] = {
                      event: m.slice(0, -d.length)
                    }, g;
                  }, {});
                  return this.getMouseEventHandlers(l(l({}, p), (h = {}, h["contextmenu" + d] = {
                    event: "contextmenu",
                    prevent: !0,
                    result: !1
                  }, h)), u, c);
                },
                getMouseEventHandlers: function(d, u, c) {
                  var h = this;
                  c === void 0 && (c = !1);
                  var p = {}, g = function(E) {
                    var C = d[E];
                    if (!m.$listeners[E])
                      return "continue";
                    var x = C.passive ? "&" : (C.once ? "~" : "") + (C.capture ? "!" : ""), b = x + C.event, P = function(T) {
                      var M, L, A = T;
                      if (C.button === void 0 || A.buttons > 0 && A.button === C.button) {
                        if (C.prevent && T.preventDefault(), C.stop && T.stopPropagation(), T && "touches" in T) {
                          var D = " ", I = (M = T.currentTarget) === null || M === void 0 ? void 0 : M.className.split(D), w = document.elementsFromPoint(T.changedTouches[0].clientX, T.changedTouches[0].clientY), B = w.find(function(j) {
                            return j.className.split(D).some(function(k) {
                              return I.includes(k);
                            });
                          });
                          if (B && !(!((L = T.target) === null || L === void 0) && L.isSameNode(B))) {
                            B.dispatchEvent(new TouchEvent(T.type, {
                              changedTouches: T.changedTouches,
                              targetTouches: T.targetTouches,
                              touches: T.touches
                            }));
                            return;
                          }
                        }
                        c ? h.$emit(E, T, u(T)) : h.$emit(E, u(T), T);
                      }
                      return C.result;
                    };
                    b in p ? Array.isArray(p[b]) ? p[b].push(P) : p[b] = [p[b], P] : p[b] = P;
                  }, m = this;
                  for (var v in d)
                    g(v);
                  return p;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/overlayable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/overlayable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VOverlay */
              "./src/components/VOverlay/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend().extend({
              name: "overlayable",
              props: {
                hideOverlay: Boolean,
                overlayColor: String,
                overlayOpacity: [Number, String]
              },
              data: function() {
                return {
                  animationFrame: 0,
                  overlay: null
                };
              },
              watch: {
                hideOverlay: function(u) {
                  this.isActive && (u ? this.removeOverlay() : this.genOverlay());
                }
              },
              beforeDestroy: function() {
                this.removeOverlay();
              },
              methods: {
                createOverlay: function() {
                  var u = new a.default({
                    propsData: {
                      absolute: this.absolute,
                      value: !1,
                      color: this.overlayColor,
                      opacity: this.overlayOpacity
                    }
                  });
                  u.$mount();
                  var c = this.absolute ? this.$el.parentNode : document.querySelector("[data-app]");
                  c && c.insertBefore(u.$el, c.firstChild), this.overlay = u;
                },
                genOverlay: function() {
                  var u = this;
                  if (this.hideScroll(), !this.hideOverlay)
                    return this.overlay || this.createOverlay(), this.animationFrame = requestAnimationFrame(function() {
                      u.overlay && (u.activeZIndex !== void 0 ? u.overlay.zIndex = String(u.activeZIndex - 1) : u.$el && (u.overlay.zIndex = Object(o.getZIndex)(u.$el)), u.overlay.value = !0);
                    }), !0;
                },
                /** removeOverlay(false) will not restore the scollbar afterwards */
                removeOverlay: function(u) {
                  var c = this;
                  u === void 0 && (u = !0), this.overlay && (Object(o.addOnceEventListener)(this.overlay.$el, "transitionend", function() {
                    !c.overlay || !c.overlay.$el || !c.overlay.$el.parentNode || c.overlay.value || c.isActive || (c.overlay.$el.parentNode.removeChild(c.overlay.$el), c.overlay.$destroy(), c.overlay = null);
                  }), cancelAnimationFrame(this.animationFrame), this.overlay.value = !1), u && this.showScroll();
                },
                scrollListener: function(u) {
                  if ("key" in u) {
                    if (["INPUT", "TEXTAREA", "SELECT"].includes(u.target.tagName) || // https://github.com/vuetifyjs/vuetify/issues/4715
                    u.target.isContentEditable)
                      return;
                    var c = [o.keyCodes.up, o.keyCodes.pageup], h = [o.keyCodes.down, o.keyCodes.pagedown];
                    if (c.includes(u.keyCode))
                      u.deltaY = -1;
                    else if (h.includes(u.keyCode))
                      u.deltaY = 1;
                    else
                      return;
                  }
                  (u.target === this.overlay || u.type !== "keydown" && u.target === document.body || this.checkPath(u)) && u.preventDefault();
                },
                hasScrollbar: function(u) {
                  if (!u || u.nodeType !== Node.ELEMENT_NODE)
                    return !1;
                  var c = window.getComputedStyle(u);
                  return (["auto", "scroll"].includes(c.overflowY) || u.tagName === "SELECT") && u.scrollHeight > u.clientHeight || ["auto", "scroll"].includes(c.overflowX) && u.scrollWidth > u.clientWidth;
                },
                shouldScroll: function(u, c) {
                  if (u.hasAttribute("data-app"))
                    return !1;
                  var h = c.shiftKey || c.deltaX ? "x" : "y", p = h === "y" ? c.deltaY : c.deltaX || c.deltaY, g, m;
                  h === "y" ? (g = u.scrollTop === 0, m = u.scrollTop + u.clientHeight === u.scrollHeight) : (g = u.scrollLeft === 0, m = u.scrollLeft + u.clientWidth === u.scrollWidth);
                  var v = p < 0, y = p > 0;
                  return !g && v || !m && y ? !0 : (g || m) && u.parentNode ? this.shouldScroll(u.parentNode, c) : !1;
                },
                isInside: function(u, c) {
                  return u === c ? !0 : u === null || u === document.body ? !1 : this.isInside(u.parentNode, c);
                },
                checkPath: function(u) {
                  var c = Object(o.composedPath)(u);
                  if (u.type === "keydown" && c[0] === document.body) {
                    var h = this.$refs.dialog, p = window.getSelection().anchorNode;
                    return h && this.hasScrollbar(h) && this.isInside(p, h) ? !this.shouldScroll(h, u) : !0;
                  }
                  for (var g = 0; g < c.length; g++) {
                    var m = c[g];
                    if (m === document || m === document.documentElement || m === this.$refs.content)
                      return !0;
                    if (this.hasScrollbar(m))
                      return !this.shouldScroll(m, u);
                  }
                  return !0;
                },
                hideScroll: function() {
                  this.$vuetify.breakpoint.smAndDown ? document.documentElement.classList.add("overflow-y-hidden") : (Object(o.addPassiveEventListener)(window, "wheel", this.scrollListener, {
                    passive: !1
                  }), window.addEventListener("keydown", this.scrollListener));
                },
                showScroll: function() {
                  document.documentElement.classList.remove("overflow-y-hidden"), window.removeEventListener("wheel", this.scrollListener), window.removeEventListener("keydown", this.scrollListener);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/picker-button/index.ts": (
          /*!*******************************************!*\
            !*** ./src/mixins/picker-button/index.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            );
            r.default = Object(o.default)(a.default).extend({
              methods: {
                genPickerButton: function(d, u, c, h, p) {
                  var g = this;
                  h === void 0 && (h = !1), p === void 0 && (p = "");
                  var m = this[d] === u, v = function(E) {
                    E.stopPropagation(), g.$emit("update:" + Object(l.kebabCase)(d), u);
                  };
                  return this.$createElement("div", {
                    staticClass: ("v-picker__title__btn " + p).trim(),
                    class: {
                      "v-picker__title__btn--active": m,
                      "v-picker__title__btn--readonly": h
                    },
                    on: m || h ? void 0 : {
                      click: v
                    }
                  }, Array.isArray(c) ? c : [c]);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/picker/index.ts": (
          /*!************************************!*\
            !*** ./src/mixins/picker/index.ts ***!
            \************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../components/VPicker */
              "./src/components/VPicker/index.ts"
            ), o = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), l = i(
              /*! ../../mixins/elevatable */
              "./src/mixins/elevatable/index.ts"
            ), f = i(
              /*! ../themeable */
              "./src/mixins/themeable/index.ts"
            ), d = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            r.default = Object(d.default)(
              o.default,
              l.default,
              f.default
              /* @vue/component */
            ).extend({
              name: "picker",
              props: {
                flat: Boolean,
                fullWidth: Boolean,
                headerColor: String,
                landscape: Boolean,
                noTitle: Boolean,
                width: {
                  type: [Number, String],
                  default: 290
                }
              },
              methods: {
                genPickerTitle: function() {
                  return null;
                },
                genPickerBody: function() {
                  return null;
                },
                genPickerActionsSlot: function() {
                  return this.$scopedSlots.default ? this.$scopedSlots.default({
                    save: this.save,
                    cancel: this.cancel
                  }) : this.$slots.default;
                },
                genPicker: function(c) {
                  var h = [];
                  if (!this.noTitle) {
                    var p = this.genPickerTitle();
                    p && h.push(p);
                  }
                  var g = this.genPickerBody();
                  return g && h.push(g), h.push(this.$createElement("template", {
                    slot: "actions"
                  }, [this.genPickerActionsSlot()])), this.$createElement(a.default, {
                    staticClass: c,
                    props: {
                      color: this.headerColor || this.color,
                      dark: this.dark,
                      elevation: this.elevation,
                      flat: this.flat,
                      fullWidth: this.fullWidth,
                      landscape: this.landscape,
                      light: this.light,
                      width: this.width,
                      noTitle: this.noTitle
                    }
                  }, h);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/positionable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/positionable/index.ts ***!
            \******************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return d;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = {
              absolute: Boolean,
              bottom: Boolean,
              fixed: Boolean,
              left: Boolean,
              right: Boolean,
              top: Boolean
            };
            function d(u) {
              return u === void 0 && (u = []), o.a.extend({
                name: "positionable",
                props: u.length ? Object(l.filterObjectOnKeys)(f, u) : f
              });
            }
            r.default = d();
          }
        ),
        /***/
        "./src/mixins/proxyable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/proxyable/index.ts ***!
            \***************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(d, u) {
              var c, h;
              return d === void 0 && (d = "value"), u === void 0 && (u = "change"), o.a.extend({
                name: "proxyable",
                model: {
                  prop: d,
                  event: u
                },
                props: (c = {}, c[d] = {
                  required: !1
                }, c),
                data: function() {
                  return {
                    internalLazyValue: this[d]
                  };
                },
                computed: {
                  internalValue: {
                    get: function() {
                      return this.internalLazyValue;
                    },
                    set: function(g) {
                      g !== this.internalLazyValue && (this.internalLazyValue = g, this.$emit(u, g));
                    }
                  }
                },
                watch: (h = {}, h[d] = function(p) {
                  this.internalLazyValue = p;
                }, h)
              });
            }
            var f = l();
            r.default = f;
          }
        ),
        /***/
        "./src/mixins/registrable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/registrable/index.ts ***!
            \*****************************************/
          /*! exports provided: inject, provide */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "inject", function() {
              return d;
            }), i.d(r, "provide", function() {
              return u;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            );
            function f(c, h) {
              return function() {
                return Object(l.consoleWarn)("The " + c + " component must be used inside a " + h);
              };
            }
            function d(c, h, p) {
              var g, m = h && p ? {
                register: f(h, p),
                unregister: f(h, p)
              } : null;
              return o.a.extend({
                name: "registrable-inject",
                inject: (g = {}, g[c] = {
                  default: m
                }, g)
              });
            }
            function u(c, h) {
              return h === void 0 && (h = !1), o.a.extend({
                name: "registrable-provide",
                provide: function() {
                  var g;
                  return g = {}, g[c] = h ? this : {
                    register: this.register,
                    unregister: this.unregister
                  }, g;
                }
              });
            }
          }
        ),
        /***/
        "./src/mixins/returnable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/returnable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "returnable",
              props: {
                returnValue: null
              },
              data: function() {
                return {
                  isActive: !1,
                  originalValue: null
                };
              },
              watch: {
                isActive: function(f) {
                  f ? this.originalValue = this.returnValue : this.$emit("update:return-value", this.originalValue);
                }
              },
              methods: {
                save: function(f) {
                  var d = this;
                  this.originalValue = f, setTimeout(function() {
                    d.isActive = !1;
                  });
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/rippleable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/rippleable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), o = i(
              /*! vue */
              "vue"
            ), l = /* @__PURE__ */ i.n(o);
            r.default = l.a.extend({
              name: "rippleable",
              directives: {
                ripple: a.default
              },
              props: {
                ripple: {
                  type: [Boolean, Object],
                  default: !0
                }
              },
              methods: {
                genRipple: function(d) {
                  return d === void 0 && (d = {}), this.ripple ? (d.staticClass = "v-input--selection-controls__ripple", d.directives = d.directives || [], d.directives.push({
                    name: "ripple",
                    value: {
                      center: !0
                    }
                  }), this.$createElement("div", d)) : null;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/roundable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/roundable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function(f) {
              var d = typeof Symbol == "function" && Symbol.iterator, u = d && f[d], c = 0;
              if (u)
                return u.call(f);
              if (f && typeof f.length == "number")
                return {
                  next: function() {
                    return f && c >= f.length && (f = void 0), {
                      value: f && f[c++],
                      done: !f
                    };
                  }
                };
              throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            r.default = o.a.extend({
              name: "roundable",
              props: {
                rounded: [Boolean, String],
                tile: Boolean
              },
              computed: {
                roundedClasses: function() {
                  var d, u, c, h = [], p = typeof this.rounded == "string" ? String(this.rounded) : this.rounded === !0;
                  if (this.tile)
                    h.push("rounded-0");
                  else if (typeof p == "string") {
                    var g = p.split(" ");
                    try {
                      for (var m = l(g), v = m.next(); !v.done; v = m.next()) {
                        var y = v.value;
                        h.push("rounded-" + y);
                      }
                    } catch (E) {
                      d = {
                        error: E
                      };
                    } finally {
                      try {
                        v && !v.done && (u = m.return) && u.call(m);
                      } finally {
                        if (d)
                          throw d.error;
                      }
                    }
                  } else
                    p && h.push("rounded");
                  return h.length > 0 ? (c = {}, c[h.join(" ")] = !0, c) : {};
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/routable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/routable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../directives/ripple */
              "./src/directives/ripple/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = function() {
              return d = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, d.apply(this, arguments);
            };
            r.default = o.a.extend({
              name: "routable",
              directives: {
                Ripple: l.default
              },
              props: {
                activeClass: String,
                append: Boolean,
                disabled: Boolean,
                exact: {
                  type: Boolean,
                  default: void 0
                },
                exactPath: Boolean,
                exactActiveClass: String,
                link: Boolean,
                href: [String, Object],
                to: [String, Object],
                nuxt: Boolean,
                replace: Boolean,
                ripple: {
                  type: [Boolean, Object],
                  default: null
                },
                tag: String,
                target: String
              },
              data: function() {
                return {
                  isActive: !1,
                  proxyClass: ""
                };
              },
              computed: {
                classes: function() {
                  var c = {};
                  return this.to || (this.activeClass && (c[this.activeClass] = this.isActive), this.proxyClass && (c[this.proxyClass] = this.isActive)), c;
                },
                computedRipple: function() {
                  var c;
                  return (c = this.ripple) !== null && c !== void 0 ? c : !this.disabled && this.isClickable;
                },
                isClickable: function() {
                  return this.disabled ? !1 : !!(this.isLink || this.$listeners.click || this.$listeners["!click"] || this.$attrs.tabindex);
                },
                isLink: function() {
                  return this.to || this.href || this.link;
                },
                styles: function() {
                  return {};
                }
              },
              watch: {
                $route: "onRouteChange"
              },
              mounted: function() {
                this.onRouteChange();
              },
              methods: {
                generateRouteLink: function() {
                  var c, h = this.exact, p, g = (c = {
                    attrs: {
                      tabindex: "tabindex" in this.$attrs ? this.$attrs.tabindex : void 0
                    },
                    class: this.classes,
                    style: this.styles,
                    props: {},
                    directives: [{
                      name: "ripple",
                      value: this.computedRipple
                    }]
                  }, c[this.to ? "nativeOn" : "on"] = d(d({}, this.$listeners), "click" in this ? {
                    click: this.click
                  } : void 0), c.ref = "link", c);
                  if (typeof this.exact > "u" && (h = this.to === "/" || this.to === Object(this.to) && this.to.path === "/"), this.to) {
                    var m = this.activeClass, v = this.exactActiveClass || m;
                    this.proxyClass && (m = (m + " " + this.proxyClass).trim(), v = (v + " " + this.proxyClass).trim()), p = this.nuxt ? "nuxt-link" : "router-link", Object.assign(g.props, {
                      to: this.to,
                      exact: h,
                      exactPath: this.exactPath,
                      activeClass: m,
                      exactActiveClass: v,
                      append: this.append,
                      replace: this.replace
                    });
                  } else
                    p = this.href && "a" || this.tag || "div", p === "a" && this.href && (g.attrs.href = this.href);
                  return this.target && (g.attrs.target = this.target), {
                    tag: p,
                    data: g
                  };
                },
                onRouteChange: function() {
                  var c = this;
                  if (!(!this.to || !this.$refs.link || !this.$route)) {
                    var h = ((this.activeClass || "") + " " + (this.proxyClass || "")).trim(), p = ((this.exactActiveClass || "") + " " + (this.proxyClass || "")).trim() || h, g = "_vnode.data.class." + (this.exact ? p : h);
                    this.$nextTick(function() {
                      !Object(f.getObjectValueByPath)(c.$refs.link, g) === c.isActive && c.toggle();
                    });
                  }
                },
                toggle: function() {
                  this.isActive = !this.isActive;
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/scrollable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/scrollable/index.ts ***!
            \****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../../directives */
              "./src/directives/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! vue */
              "vue"
            ), f = /* @__PURE__ */ i.n(l);
            r.default = f.a.extend({
              name: "scrollable",
              directives: {
                Scroll: a.Scroll
              },
              props: {
                scrollTarget: String,
                scrollThreshold: [String, Number]
              },
              data: function() {
                return {
                  currentScroll: 0,
                  currentThreshold: 0,
                  isActive: !1,
                  isScrollingUp: !1,
                  previousScroll: 0,
                  savedScroll: 0,
                  target: null
                };
              },
              computed: {
                /**
                 * A computed property that returns
                 * whether scrolling features are
                 * enabled or disabled
                 */
                canScroll: function() {
                  return typeof window < "u";
                },
                /**
                 * The threshold that must be met before
                 * thresholdMet function is invoked
                 */
                computedScrollThreshold: function() {
                  return this.scrollThreshold ? Number(this.scrollThreshold) : 300;
                }
              },
              watch: {
                isScrollingUp: function() {
                  this.savedScroll = this.savedScroll || this.currentScroll;
                },
                isActive: function() {
                  this.savedScroll = 0;
                }
              },
              mounted: function() {
                this.scrollTarget && (this.target = document.querySelector(this.scrollTarget), this.target || Object(o.consoleWarn)("Unable to locate element with identifier " + this.scrollTarget, this));
              },
              methods: {
                onScroll: function() {
                  var u = this;
                  this.canScroll && (this.previousScroll = this.currentScroll, this.currentScroll = this.target ? this.target.scrollTop : window.pageYOffset, this.isScrollingUp = this.currentScroll < this.previousScroll, this.currentThreshold = Math.abs(this.currentScroll - this.computedScrollThreshold), this.$nextTick(function() {
                    Math.abs(u.currentScroll - u.savedScroll) > u.computedScrollThreshold && u.thresholdMet();
                  }));
                },
                /**
                 * The method invoked when
                 * scrolling in any direction
                 * has exceeded the threshold
                 */
                thresholdMet: function() {
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/selectable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/selectable/index.ts ***!
            \****************************************/
          /*! exports provided: prevent, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "prevent", function() {
              return d;
            });
            var a = i(
              /*! ../../components/VInput */
              "./src/components/VInput/index.ts"
            ), o = i(
              /*! ../rippleable */
              "./src/mixins/rippleable/index.ts"
            ), l = i(
              /*! ../comparable */
              "./src/mixins/comparable/index.ts"
            ), f = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function d(u) {
              u.preventDefault();
            }
            r.default = Object(f.default)(a.default, o.default, l.default).extend({
              name: "selectable",
              model: {
                prop: "inputValue",
                event: "change"
              },
              props: {
                id: String,
                inputValue: null,
                falseValue: null,
                trueValue: null,
                multiple: {
                  type: Boolean,
                  default: null
                },
                label: String
              },
              data: function() {
                return {
                  hasColor: this.inputValue,
                  lazyValue: this.inputValue
                };
              },
              computed: {
                computedColor: function() {
                  if (this.isActive)
                    return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                },
                isMultiple: function() {
                  return this.multiple === !0 || this.multiple === null && Array.isArray(this.internalValue);
                },
                isActive: function() {
                  var c = this, h = this.value, p = this.internalValue;
                  return this.isMultiple ? Array.isArray(p) ? p.some(function(g) {
                    return c.valueComparator(g, h);
                  }) : !1 : this.trueValue === void 0 || this.falseValue === void 0 ? h ? this.valueComparator(h, p) : !!p : this.valueComparator(p, this.trueValue);
                },
                isDirty: function() {
                  return this.isActive;
                },
                rippleState: function() {
                  return !this.isDisabled && !this.validationState ? void 0 : this.validationState;
                }
              },
              watch: {
                inputValue: function(c) {
                  this.lazyValue = c, this.hasColor = c;
                }
              },
              methods: {
                genLabel: function() {
                  var c = a.default.options.methods.genLabel.call(this);
                  return c && (c.data.on = {
                    // Label shouldn't cause the input to focus
                    click: d
                  }, c);
                },
                genInput: function(c, h) {
                  return this.$createElement("input", {
                    attrs: Object.assign({
                      "aria-checked": this.isActive.toString(),
                      disabled: this.isDisabled,
                      id: this.computedId,
                      role: c,
                      type: c
                    }, h),
                    domProps: {
                      value: this.value,
                      checked: this.isActive
                    },
                    on: {
                      blur: this.onBlur,
                      change: this.onChange,
                      focus: this.onFocus,
                      keydown: this.onKeydown,
                      click: d
                    },
                    ref: "input"
                  });
                },
                onClick: function(c) {
                  this.onChange(), this.$emit("click", c);
                },
                onChange: function() {
                  var c = this;
                  if (this.isInteractive) {
                    var h = this.value, p = this.internalValue;
                    if (this.isMultiple) {
                      Array.isArray(p) || (p = []);
                      var g = p.length;
                      p = p.filter(function(m) {
                        return !c.valueComparator(m, h);
                      }), p.length === g && p.push(h);
                    } else
                      this.trueValue !== void 0 && this.falseValue !== void 0 ? p = this.valueComparator(p, this.trueValue) ? this.falseValue : this.trueValue : h ? p = this.valueComparator(p, h) ? null : h : p = !p;
                    this.validate(!0, p), this.internalValue = p, this.hasColor = p;
                  }
                },
                onFocus: function(c) {
                  this.isFocused = !0, this.$emit("focus", c);
                },
                onBlur: function(c) {
                  this.isFocused = !1, this.$emit("blur", c);
                },
                /** @abstract */
                onKeydown: function(c) {
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/sizeable/index.ts": (
          /*!**************************************!*\
            !*** ./src/mixins/sizeable/index.ts ***!
            \**************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "sizeable",
              props: {
                large: Boolean,
                small: Boolean,
                xLarge: Boolean,
                xSmall: Boolean
              },
              computed: {
                medium: function() {
                  return !this.xSmall && !this.small && !this.large && !this.xLarge;
                },
                sizeableClasses: function() {
                  return {
                    "v-size--x-small": this.xSmall,
                    "v-size--small": this.small,
                    "v-size--default": this.medium,
                    "v-size--large": this.large,
                    "v-size--x-large": this.xLarge
                  };
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/ssr-bootable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/ssr-bootable/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "ssr-bootable",
              data: function() {
                return {
                  isBooted: !1
                };
              },
              mounted: function() {
                var f = this;
                window.requestAnimationFrame(function() {
                  f.$el.setAttribute("data-booted", "true"), f.isBooted = !0;
                });
              }
            });
          }
        ),
        /***/
        "./src/mixins/stackable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/stackable/index.ts ***!
            \***************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = function(u, c) {
              var h = typeof Symbol == "function" && u[Symbol.iterator];
              if (!h)
                return u;
              var p = h.call(u), g, m = [], v;
              try {
                for (; (c === void 0 || c-- > 0) && !(g = p.next()).done; )
                  m.push(g.value);
              } catch (y) {
                v = {
                  error: y
                };
              } finally {
                try {
                  g && !g.done && (h = p.return) && h.call(p);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return m;
            }, d = function(u, c, h) {
              if (h || arguments.length === 2)
                for (var p = 0, g = c.length, m; p < g; p++)
                  (m || !(p in c)) && (m || (m = Array.prototype.slice.call(c, 0, p)), m[p] = c[p]);
              return u.concat(m || Array.prototype.slice.call(c));
            };
            r.default = o.a.extend().extend({
              name: "stackable",
              data: function() {
                return {
                  stackElement: null,
                  stackExclude: null,
                  stackMinZIndex: 0,
                  isActive: !1
                };
              },
              computed: {
                activeZIndex: function() {
                  if (typeof window > "u")
                    return 0;
                  var c = this.stackElement || this.$refs.content, h = this.isActive ? this.getMaxZIndex(this.stackExclude || [c]) + 2 : Object(l.getZIndex)(c);
                  return h == null ? h : parseInt(h);
                }
              },
              methods: {
                getMaxZIndex: function(c) {
                  c === void 0 && (c = []);
                  for (var h = this.$el, p = [this.stackMinZIndex, Object(l.getZIndex)(h)], g = d(d([], f(document.getElementsByClassName("v-menu__content--active")), !1), f(document.getElementsByClassName("v-dialog__content--active")), !1), m = 0; m < g.length; m++)
                    c.includes(g[m]) || p.push(Object(l.getZIndex)(g[m]));
                  return Math.max.apply(Math, d([], f(p), !1));
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/themeable/index.ts": (
          /*!***************************************!*\
            !*** ./src/mixins/themeable/index.ts ***!
            \***************************************/
          /*! exports provided: default, functionalThemeClasses */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "functionalThemeClasses", function() {
              return d;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a), l = function() {
              return l = Object.assign || function(u) {
                for (var c, h = 1, p = arguments.length; h < p; h++) {
                  c = arguments[h];
                  for (var g in c)
                    Object.prototype.hasOwnProperty.call(c, g) && (u[g] = c[g]);
                }
                return u;
              }, l.apply(this, arguments);
            }, f = o.a.extend().extend({
              name: "themeable",
              provide: function() {
                return {
                  theme: this.themeableProvide
                };
              },
              inject: {
                theme: {
                  default: {
                    isDark: !1
                  }
                }
              },
              props: {
                dark: {
                  type: Boolean,
                  default: null
                },
                light: {
                  type: Boolean,
                  default: null
                }
              },
              data: function() {
                return {
                  themeableProvide: {
                    isDark: !1
                  }
                };
              },
              computed: {
                appIsDark: function() {
                  return this.$vuetify.theme.dark || !1;
                },
                isDark: function() {
                  return this.dark === !0 ? !0 : this.light === !0 ? !1 : this.theme.isDark;
                },
                themeClasses: function() {
                  return {
                    "theme--dark": this.isDark,
                    "theme--light": !this.isDark
                  };
                },
                /** Used by menus and dialogs, inherits from v-app instead of the parent */
                rootIsDark: function() {
                  return this.dark === !0 ? !0 : this.light === !0 ? !1 : this.appIsDark;
                },
                rootThemeClasses: function() {
                  return {
                    "theme--dark": this.rootIsDark,
                    "theme--light": !this.rootIsDark
                  };
                }
              },
              watch: {
                isDark: {
                  handler: function(c, h) {
                    c !== h && (this.themeableProvide.isDark = this.isDark);
                  },
                  immediate: !0
                }
              }
            });
            r.default = f;
            function d(u) {
              var c = l(l({}, u.props), u.injections), h = f.options.computed.isDark.call(c);
              return f.options.computed.themeClasses.call({
                isDark: h
              });
            }
          }
        ),
        /***/
        "./src/mixins/toggleable/index.ts": (
          /*!****************************************!*\
            !*** ./src/mixins/toggleable/index.ts ***!
            \****************************************/
          /*! exports provided: factory, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "factory", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(d, u) {
              var c, h;
              return d === void 0 && (d = "value"), u === void 0 && (u = "input"), o.a.extend({
                name: "toggleable",
                model: {
                  prop: d,
                  event: u
                },
                props: (c = {}, c[d] = {
                  required: !1
                }, c),
                data: function() {
                  return {
                    isActive: !!this[d]
                  };
                },
                watch: (h = {}, h[d] = function(p) {
                  this.isActive = !!p;
                }, h.isActive = function(p) {
                  !!p !== this[d] && this.$emit(u, p);
                }, h)
              });
            }
            var f = l();
            r.default = f;
          }
        ),
        /***/
        "./src/mixins/transitionable/index.ts": (
          /*!********************************************!*\
            !*** ./src/mixins/transitionable/index.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "transitionable",
              props: {
                mode: String,
                origin: String,
                transition: String
              }
            });
          }
        ),
        /***/
        "./src/mixins/translatable/index.ts": (
          /*!******************************************!*\
            !*** ./src/mixins/translatable/index.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            r.default = o.a.extend({
              name: "translatable",
              props: {
                height: Number
              },
              data: function() {
                return {
                  elOffsetTop: 0,
                  parallax: 0,
                  parallaxDist: 0,
                  percentScrolled: 0,
                  scrollTop: 0,
                  windowHeight: 0,
                  windowBottom: 0
                };
              },
              computed: {
                imgHeight: function() {
                  return this.objHeight();
                }
              },
              beforeDestroy: function() {
                window.removeEventListener("scroll", this.translate, !1), window.removeEventListener("resize", this.translate, !1);
              },
              methods: {
                calcDimensions: function() {
                  var f = this.$el.getBoundingClientRect();
                  this.scrollTop = window.pageYOffset, this.parallaxDist = this.imgHeight - this.height, this.elOffsetTop = f.top + this.scrollTop, this.windowHeight = window.innerHeight, this.windowBottom = this.scrollTop + this.windowHeight;
                },
                listeners: function() {
                  window.addEventListener("scroll", this.translate, !1), window.addEventListener("resize", this.translate, !1);
                },
                /** @abstract **/
                objHeight: function() {
                  throw new Error("Not implemented !");
                },
                translate: function() {
                  this.calcDimensions(), this.percentScrolled = (this.windowBottom - this.elOffsetTop) / (parseInt(this.height) + this.windowHeight), this.parallax = Math.round(this.parallaxDist * this.percentScrolled);
                }
              }
            });
          }
        ),
        /***/
        "./src/mixins/validatable/index.ts": (
          /*!*****************************************!*\
            !*** ./src/mixins/validatable/index.ts ***!
            \*****************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ../colorable */
              "./src/mixins/colorable/index.ts"
            ), o = i(
              /*! ../themeable */
              "./src/mixins/themeable/index.ts"
            ), l = i(
              /*! ../registrable */
              "./src/mixins/registrable/index.ts"
            ), f = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), d = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), u = i(
              /*! ../../util/mixins */
              "./src/util/mixins.ts"
            );
            function c(p) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? c = function(m) {
                return typeof m;
              } : c = function(m) {
                return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
              }, c(p);
            }
            var h = Object(u.default)(a.default, Object(l.inject)("form"), o.default);
            r.default = h.extend({
              name: "validatable",
              props: {
                disabled: {
                  type: Boolean,
                  default: null
                },
                error: Boolean,
                errorCount: {
                  type: [Number, String],
                  default: 1
                },
                errorMessages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                messages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                readonly: {
                  type: Boolean,
                  default: null
                },
                rules: {
                  type: Array,
                  default: function() {
                    return [];
                  }
                },
                success: Boolean,
                successMessages: {
                  type: [String, Array],
                  default: function() {
                    return [];
                  }
                },
                validateOnBlur: Boolean,
                value: {
                  required: !1
                }
              },
              data: function() {
                return {
                  errorBucket: [],
                  hasColor: !1,
                  hasFocused: !1,
                  hasInput: !1,
                  isFocused: !1,
                  isResetting: !1,
                  lazyValue: this.value,
                  valid: !1
                };
              },
              computed: {
                computedColor: function() {
                  if (!this.isDisabled)
                    return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary";
                },
                hasError: function() {
                  return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error;
                },
                // TODO: Add logic that allows the user to enable based
                // upon a good validation
                hasSuccess: function() {
                  return this.internalSuccessMessages.length > 0 || this.success;
                },
                externalError: function() {
                  return this.internalErrorMessages.length > 0 || this.error;
                },
                hasMessages: function() {
                  return this.validationTarget.length > 0;
                },
                hasState: function() {
                  return this.isDisabled ? !1 : this.hasSuccess || this.shouldValidate && this.hasError;
                },
                internalErrorMessages: function() {
                  return this.genInternalMessages(this.errorMessages);
                },
                internalMessages: function() {
                  return this.genInternalMessages(this.messages);
                },
                internalSuccessMessages: function() {
                  return this.genInternalMessages(this.successMessages);
                },
                internalValue: {
                  get: function() {
                    return this.lazyValue;
                  },
                  set: function(g) {
                    this.lazyValue = g, this.$emit("input", g);
                  }
                },
                isDisabled: function() {
                  var g;
                  return (g = this.disabled) !== null && g !== void 0 ? g : !!this.form && this.form.disabled;
                },
                isInteractive: function() {
                  return !this.isDisabled && !this.isReadonly;
                },
                isReadonly: function() {
                  var g;
                  return (g = this.readonly) !== null && g !== void 0 ? g : !!this.form && this.form.readonly;
                },
                shouldValidate: function() {
                  return this.externalError ? !0 : this.isResetting ? !1 : this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused;
                },
                validations: function() {
                  return this.validationTarget.slice(0, Number(this.errorCount));
                },
                validationState: function() {
                  if (!this.isDisabled) {
                    if (this.hasError && this.shouldValidate)
                      return "error";
                    if (this.hasSuccess)
                      return "success";
                    if (this.hasColor)
                      return this.computedColor;
                  }
                },
                validationTarget: function() {
                  return this.internalErrorMessages.length > 0 ? this.internalErrorMessages : this.successMessages && this.successMessages.length > 0 ? this.internalSuccessMessages : this.messages && this.messages.length > 0 ? this.internalMessages : this.shouldValidate ? this.errorBucket : [];
                }
              },
              watch: {
                rules: {
                  handler: function(g, m) {
                    Object(f.deepEqual)(g, m) || this.validate();
                  },
                  deep: !0
                },
                internalValue: function() {
                  this.hasInput = !0, this.validateOnBlur || this.$nextTick(this.validate);
                },
                isFocused: function(g) {
                  !g && !this.isDisabled && (this.hasFocused = !0, this.validateOnBlur && this.$nextTick(this.validate));
                },
                isResetting: function() {
                  var g = this;
                  setTimeout(function() {
                    g.hasInput = !1, g.hasFocused = !1, g.isResetting = !1, g.validate();
                  }, 0);
                },
                hasError: function(g) {
                  this.shouldValidate && this.$emit("update:error", g);
                },
                value: function(g) {
                  this.lazyValue = g;
                }
              },
              beforeMount: function() {
                this.validate();
              },
              created: function() {
                this.form && this.form.register(this);
              },
              beforeDestroy: function() {
                this.form && this.form.unregister(this);
              },
              methods: {
                genInternalMessages: function(g) {
                  return g ? Array.isArray(g) ? g : [g] : [];
                },
                /** @public */
                reset: function() {
                  this.isResetting = !0, this.internalValue = Array.isArray(this.internalValue) ? [] : null;
                },
                /** @public */
                resetValidation: function() {
                  this.isResetting = !0;
                },
                /** @public */
                validate: function(g, m) {
                  g === void 0 && (g = !1);
                  var v = [];
                  m = m || this.internalValue, g && (this.hasInput = this.hasFocused = !0);
                  for (var y = 0; y < this.rules.length; y++) {
                    var E = this.rules[y], C = typeof E == "function" ? E(m) : E;
                    C === !1 || typeof C == "string" ? v.push(C || "") : typeof C != "boolean" && Object(d.consoleError)("Rules should return a string or boolean, received '" + c(C) + "' instead", this);
                  }
                  return this.errorBucket = v, this.valid = v.length === 0, this.valid;
                }
              }
            });
          }
        ),
        /***/
        "./src/presets/default/index.ts": (
          /*!**************************************!*\
            !*** ./src/presets/default/index.ts ***!
            \**************************************/
          /*! exports provided: preset */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "preset", function() {
              return o;
            }), i(
              /*! ../../styles/main.sass */
              "./src/styles/main.sass"
            );
            var a = i(
              /*! ../../locale */
              "./src/locale/index.ts"
            ), o = {
              breakpoint: {
                // TODO: update to MD2 spec in v3 - 1280
                mobileBreakpoint: 1264,
                scrollBarWidth: 16,
                thresholds: {
                  xs: 600,
                  sm: 960,
                  md: 1280,
                  lg: 1920
                }
              },
              icons: {
                // TODO: remove v3
                iconfont: "mdi",
                values: {}
              },
              lang: {
                current: "en",
                locales: {
                  en: a.en
                },
                // Default translator exists in lang service
                t: void 0
              },
              rtl: !1,
              theme: {
                dark: !1,
                default: "light",
                disable: !1,
                options: {
                  cspNonce: void 0,
                  customProperties: void 0,
                  minifyTheme: void 0,
                  themeCache: void 0,
                  variations: !0
                },
                themes: {
                  light: {
                    primary: "#1976D2",
                    secondary: "#424242",
                    accent: "#82B1FF",
                    error: "#FF5252",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                  },
                  dark: {
                    primary: "#2196F3",
                    secondary: "#424242",
                    accent: "#FF4081",
                    error: "#FF5252",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                  }
                }
              }
            };
          }
        ),
        /***/
        "./src/services/application/index.ts": (
          /*!*******************************************!*\
            !*** ./src/services/application/index.ts ***!
            \*******************************************/
          /*! exports provided: Application */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Application", function() {
              return l;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = function() {
              var f = function(u, c) {
                return f = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(h, p) {
                  h.__proto__ = p;
                } || function(h, p) {
                  for (var g in p)
                    Object.prototype.hasOwnProperty.call(p, g) && (h[g] = p[g]);
                }, f(u, c);
              };
              return function(d, u) {
                if (typeof u != "function" && u !== null)
                  throw new TypeError("Class extends value " + String(u) + " is not a constructor or null");
                f(d, u);
                function c() {
                  this.constructor = d;
                }
                d.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
              };
            }(), l = (
              /** @class */
              function(f) {
                o(d, f);
                function d() {
                  var u = f !== null && f.apply(this, arguments) || this;
                  return u.bar = 0, u.top = 0, u.left = 0, u.insetFooter = 0, u.right = 0, u.bottom = 0, u.footer = 0, u.application = {
                    bar: {},
                    top: {},
                    left: {},
                    insetFooter: {},
                    right: {},
                    bottom: {},
                    footer: {}
                  }, u;
                }
                return d.prototype.register = function(u, c, h) {
                  this.application[c][u] = h, this.update(c);
                }, d.prototype.unregister = function(u, c) {
                  this.application[c][u] != null && (delete this.application[c][u], this.update(c));
                }, d.prototype.update = function(u) {
                  this[u] = Object.values(this.application[u]).reduce(function(c, h) {
                    return c + h;
                  }, 0);
                }, d.property = "application", d;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/breakpoint/index.ts": (
          /*!******************************************!*\
            !*** ./src/services/breakpoint/index.ts ***!
            \******************************************/
          /*! exports provided: Breakpoint */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Breakpoint", function() {
              return l;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = function() {
              var f = function(u, c) {
                return f = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(h, p) {
                  h.__proto__ = p;
                } || function(h, p) {
                  for (var g in p)
                    Object.prototype.hasOwnProperty.call(p, g) && (h[g] = p[g]);
                }, f(u, c);
              };
              return function(d, u) {
                if (typeof u != "function" && u !== null)
                  throw new TypeError("Class extends value " + String(u) + " is not a constructor or null");
                f(d, u);
                function c() {
                  this.constructor = d;
                }
                d.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
              };
            }(), l = (
              /** @class */
              function(f) {
                o(d, f);
                function d(u) {
                  var c = f.call(this) || this;
                  c.xs = !1, c.sm = !1, c.md = !1, c.lg = !1, c.xl = !1, c.xsOnly = !1, c.smOnly = !1, c.smAndDown = !1, c.smAndUp = !1, c.mdOnly = !1, c.mdAndDown = !1, c.mdAndUp = !1, c.lgOnly = !1, c.lgAndDown = !1, c.lgAndUp = !1, c.xlOnly = !1, c.name = "xs", c.height = 0, c.width = 0, c.mobile = !0, c.resizeTimeout = 0;
                  var h = u[d.property], p = h.mobileBreakpoint, g = h.scrollBarWidth, m = h.thresholds;
                  return c.mobileBreakpoint = p, c.scrollBarWidth = g, c.thresholds = m, c;
                }
                return d.prototype.init = function() {
                  this.update(), !(typeof window > "u") && window.addEventListener("resize", this.onResize.bind(this), {
                    passive: !0
                  });
                }, d.prototype.update = function(u) {
                  u === void 0 && (u = !1);
                  var c = u ? 0 : this.getClientHeight(), h = u ? 0 : this.getClientWidth(), p = h < this.thresholds.xs, g = h < this.thresholds.sm && !p, m = h < this.thresholds.md - this.scrollBarWidth && !(g || p), v = h < this.thresholds.lg - this.scrollBarWidth && !(m || g || p), y = h >= this.thresholds.lg - this.scrollBarWidth;
                  switch (this.height = c, this.width = h, this.xs = p, this.sm = g, this.md = m, this.lg = v, this.xl = y, this.xsOnly = p, this.smOnly = g, this.smAndDown = (p || g) && !(m || v || y), this.smAndUp = !p && (g || m || v || y), this.mdOnly = m, this.mdAndDown = (p || g || m) && !(v || y), this.mdAndUp = !(p || g) && (m || v || y), this.lgOnly = v, this.lgAndDown = (p || g || m || v) && !y, this.lgAndUp = !(p || g || m) && (v || y), this.xlOnly = y, !0) {
                    case p:
                      this.name = "xs";
                      break;
                    case g:
                      this.name = "sm";
                      break;
                    case m:
                      this.name = "md";
                      break;
                    case v:
                      this.name = "lg";
                      break;
                    default:
                      this.name = "xl";
                      break;
                  }
                  if (typeof this.mobileBreakpoint == "number") {
                    this.mobile = h < parseInt(this.mobileBreakpoint, 10);
                    return;
                  }
                  var E = {
                    xs: 0,
                    sm: 1,
                    md: 2,
                    lg: 3,
                    xl: 4
                  }, C = E[this.name], x = E[this.mobileBreakpoint];
                  this.mobile = C <= x;
                }, d.prototype.onResize = function() {
                  clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.update.bind(this), 200);
                }, d.prototype.getClientWidth = function() {
                  return typeof document > "u" ? 0 : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                }, d.prototype.getClientHeight = function() {
                  return typeof document > "u" ? 0 : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                }, d.property = "breakpoint", d;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/goto/easing-patterns.ts": (
          /*!**********************************************!*\
            !*** ./src/services/goto/easing-patterns.ts ***!
            \**********************************************/
          /*! exports provided: linear, easeInQuad, easeOutQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, easeInQuint, easeOutQuint, easeInOutQuint */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "linear", function() {
              return a;
            }), i.d(r, "easeInQuad", function() {
              return o;
            }), i.d(r, "easeOutQuad", function() {
              return l;
            }), i.d(r, "easeInOutQuad", function() {
              return f;
            }), i.d(r, "easeInCubic", function() {
              return d;
            }), i.d(r, "easeOutCubic", function() {
              return u;
            }), i.d(r, "easeInOutCubic", function() {
              return c;
            }), i.d(r, "easeInQuart", function() {
              return h;
            }), i.d(r, "easeOutQuart", function() {
              return p;
            }), i.d(r, "easeInOutQuart", function() {
              return g;
            }), i.d(r, "easeInQuint", function() {
              return m;
            }), i.d(r, "easeOutQuint", function() {
              return v;
            }), i.d(r, "easeInOutQuint", function() {
              return y;
            });
            var a = function(C) {
              return C;
            }, o = function(C) {
              return Math.pow(C, 2);
            }, l = function(C) {
              return C * (2 - C);
            }, f = function(C) {
              return C < 0.5 ? 2 * Math.pow(C, 2) : -1 + (4 - 2 * C) * C;
            }, d = function(C) {
              return Math.pow(C, 3);
            }, u = function(C) {
              return Math.pow(--C, 3) + 1;
            }, c = function(C) {
              return C < 0.5 ? 4 * Math.pow(C, 3) : (C - 1) * (2 * C - 2) * (2 * C - 2) + 1;
            }, h = function(C) {
              return Math.pow(C, 4);
            }, p = function(C) {
              return 1 - Math.pow(--C, 4);
            }, g = function(C) {
              return C < 0.5 ? 8 * C * C * C * C : 1 - 8 * --C * C * C * C;
            }, m = function(C) {
              return Math.pow(C, 5);
            }, v = function(C) {
              return 1 + Math.pow(--C, 5);
            }, y = function(C) {
              return C < 0.5 ? 16 * Math.pow(C, 5) : 1 + 16 * Math.pow(--C, 5);
            };
          }
        ),
        /***/
        "./src/services/goto/index.ts": (
          /*!************************************!*\
            !*** ./src/services/goto/index.ts ***!
            \************************************/
          /*! exports provided: default, Goto */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return u;
            }), i.d(r, "Goto", function() {
              return c;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ./easing-patterns */
              "./src/services/goto/easing-patterns.ts"
            ), l = i(
              /*! ./util */
              "./src/services/goto/util.ts"
            ), f = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), d = function() {
              return d = Object.assign || function(h) {
                for (var p, g = 1, m = arguments.length; g < m; g++) {
                  p = arguments[g];
                  for (var v in p)
                    Object.prototype.hasOwnProperty.call(p, v) && (h[v] = p[v]);
                }
                return h;
              }, d.apply(this, arguments);
            };
            function u(h, p) {
              p === void 0 && (p = {});
              var g = d({
                container: document.scrollingElement || document.body || document.documentElement,
                duration: 500,
                offset: 0,
                easing: "easeInOutCubic",
                appOffset: !0
              }, p), m = Object(l.getContainer)(g.container);
              if (g.appOffset && u.framework.application) {
                var v = m.classList.contains("v-navigation-drawer"), y = m.classList.contains("v-navigation-drawer--clipped"), E = u.framework.application, C = E.bar, x = E.top;
                g.offset += C, (!v || y) && (g.offset += x);
              }
              var b = performance.now(), P;
              typeof h == "number" ? P = Object(l.getOffset)(h) - g.offset : P = Object(l.getOffset)(h) - Object(l.getOffset)(m) - g.offset;
              var O = m.scrollTop;
              if (P === O)
                return Promise.resolve(P);
              var T = typeof g.easing == "function" ? g.easing : o[g.easing];
              if (!T)
                throw new TypeError('Easing function "' + g.easing + '" not found.');
              return new Promise(function(M) {
                return requestAnimationFrame(function L(A) {
                  var D = A - b, I = Math.abs(g.duration ? Math.min(D / g.duration, 1) : 1);
                  m.scrollTop = Math.floor(O + (P - O) * T(I));
                  var w = m === document.body ? document.documentElement.clientHeight : m.clientHeight, B = w + m.scrollTop >= m.scrollHeight;
                  if (I === 1 || // Need to go lower but reach bottom
                  P > m.scrollTop && B)
                    return M(P);
                  requestAnimationFrame(L);
                });
              });
            }
            u.framework = {}, u.init = function() {
            };
            var c = (
              /** @class */
              function(h) {
                f(p, h);
                function p() {
                  return h.call(this), u;
                }
                return p.property = "goTo", p;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/goto/util.ts": (
          /*!***********************************!*\
            !*** ./src/services/goto/util.ts ***!
            \***********************************/
          /*! exports provided: getOffset, getContainer */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "getOffset", function() {
              return a;
            }), i.d(r, "getContainer", function() {
              return o;
            });
            function a(d) {
              if (typeof d == "number")
                return d;
              var u = f(d);
              if (!u)
                throw typeof d == "string" ? new Error('Target element "' + d + '" not found.') : new TypeError("Target must be a Number/Selector/HTMLElement/VueComponent, received " + l(d) + " instead.");
              for (var c = 0; u; )
                c += u.offsetTop, u = u.offsetParent;
              return c;
            }
            function o(d) {
              var u = f(d);
              if (u)
                return u;
              throw typeof d == "string" ? new Error('Container element "' + d + '" not found.') : new TypeError("Container must be a Selector/HTMLElement/VueComponent, received " + l(d) + " instead.");
            }
            function l(d) {
              return d == null ? d : d.constructor.name;
            }
            function f(d) {
              return typeof d == "string" ? document.querySelector(d) : d && d._isVue ? d.$el : d instanceof HTMLElement ? d : null;
            }
          }
        ),
        /***/
        "./src/services/icons/index.ts": (
          /*!*************************************!*\
            !*** ./src/services/icons/index.ts ***!
            \*************************************/
          /*! exports provided: Icons */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Icons", function() {
              return d;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./presets */
              "./src/services/icons/presets/index.ts"
            ), f = function() {
              var u = function(h, p) {
                return u = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(g, m) {
                  g.__proto__ = m;
                } || function(g, m) {
                  for (var v in m)
                    Object.prototype.hasOwnProperty.call(m, v) && (g[v] = m[v]);
                }, u(h, p);
              };
              return function(c, h) {
                if (typeof h != "function" && h !== null)
                  throw new TypeError("Class extends value " + String(h) + " is not a constructor or null");
                u(c, h);
                function p() {
                  this.constructor = c;
                }
                c.prototype = h === null ? Object.create(h) : (p.prototype = h.prototype, new p());
              };
            }(), d = (
              /** @class */
              function(u) {
                f(c, u);
                function c(h) {
                  var p = u.call(this) || this, g = h[c.property], m = g.iconfont, v = g.values, y = g.component;
                  return p.component = y, p.iconfont = m, p.values = Object(o.mergeDeep)(l.default[m], v), p;
                }
                return c.property = "icons", c;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/icons/presets/fa-svg.ts": (
          /*!**********************************************!*\
            !*** ./src/services/icons/presets/fa-svg.ts ***!
            \**********************************************/
          /*! exports provided: convertToComponentDeclarations, default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "convertToComponentDeclarations", function() {
              return o;
            });
            var a = i(
              /*! ./fa */
              "./src/services/icons/presets/fa.ts"
            );
            function o(l, f) {
              var d = {};
              for (var u in f)
                d[u] = {
                  component: l,
                  props: {
                    icon: f[u].split(" fa-")
                  }
                };
              return d;
            }
            r.default = o("font-awesome-icon", a.default);
          }
        ),
        /***/
        "./src/services/icons/presets/fa.ts": (
          /*!******************************************!*\
            !*** ./src/services/icons/presets/fa.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "fas fa-check",
              cancel: "fas fa-times-circle",
              close: "fas fa-times",
              delete: "fas fa-times-circle",
              clear: "fas fa-times-circle",
              success: "fas fa-check-circle",
              info: "fas fa-info-circle",
              warning: "fas fa-exclamation-circle",
              error: "fas fa-exclamation-triangle",
              prev: "fas fa-chevron-left",
              next: "fas fa-chevron-right",
              checkboxOn: "fas fa-check-square",
              checkboxOff: "far fa-square",
              checkboxIndeterminate: "fas fa-minus-square",
              delimiter: "fas fa-circle",
              sort: "fas fa-sort-up",
              expand: "fas fa-chevron-down",
              menu: "fas fa-bars",
              subgroup: "fas fa-caret-down",
              dropdown: "fas fa-caret-down",
              radioOn: "far fa-dot-circle",
              radioOff: "far fa-circle",
              edit: "fas fa-edit",
              ratingEmpty: "far fa-star",
              ratingFull: "fas fa-star",
              ratingHalf: "fas fa-star-half",
              loading: "fas fa-sync",
              first: "fas fa-step-backward",
              last: "fas fa-step-forward",
              unfold: "fas fa-arrows-alt-v",
              file: "fas fa-paperclip",
              plus: "fas fa-plus",
              minus: "fas fa-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/fa4.ts": (
          /*!*******************************************!*\
            !*** ./src/services/icons/presets/fa4.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "fa fa-check",
              cancel: "fa fa-times-circle",
              close: "fa fa-times",
              delete: "fa fa-times-circle",
              clear: "fa fa-times-circle",
              success: "fa fa-check-circle",
              info: "fa fa-info-circle",
              warning: "fa fa-exclamation",
              error: "fa fa-exclamation-triangle",
              prev: "fa fa-chevron-left",
              next: "fa fa-chevron-right",
              checkboxOn: "fa fa-check-square",
              checkboxOff: "fa fa-square-o",
              checkboxIndeterminate: "fa fa-minus-square",
              delimiter: "fa fa-circle",
              sort: "fa fa-sort-up",
              expand: "fa fa-chevron-down",
              menu: "fa fa-bars",
              subgroup: "fa fa-caret-down",
              dropdown: "fa fa-caret-down",
              radioOn: "fa fa-dot-circle-o",
              radioOff: "fa fa-circle-o",
              edit: "fa fa-pencil",
              ratingEmpty: "fa fa-star-o",
              ratingFull: "fa fa-star",
              ratingHalf: "fa fa-star-half-o",
              loading: "fa fa-refresh",
              first: "fa fa-step-backward",
              last: "fa fa-step-forward",
              unfold: "fa fa-angle-double-down",
              file: "fa fa-paperclip",
              plus: "fa fa-plus",
              minus: "fa fa-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/index.ts": (
          /*!*********************************************!*\
            !*** ./src/services/icons/presets/index.ts ***!
            \*********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./mdi-svg */
              "./src/services/icons/presets/mdi-svg.ts"
            ), o = i(
              /*! ./md */
              "./src/services/icons/presets/md.ts"
            ), l = i(
              /*! ./mdi */
              "./src/services/icons/presets/mdi.ts"
            ), f = i(
              /*! ./fa */
              "./src/services/icons/presets/fa.ts"
            ), d = i(
              /*! ./fa4 */
              "./src/services/icons/presets/fa4.ts"
            ), u = i(
              /*! ./fa-svg */
              "./src/services/icons/presets/fa-svg.ts"
            );
            r.default = Object.freeze({
              mdiSvg: a.default,
              md: o.default,
              mdi: l.default,
              fa: f.default,
              fa4: d.default,
              faSvg: u.default
            });
          }
        ),
        /***/
        "./src/services/icons/presets/md.ts": (
          /*!******************************************!*\
            !*** ./src/services/icons/presets/md.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "check",
              cancel: "cancel",
              close: "close",
              delete: "cancel",
              clear: "clear",
              success: "check_circle",
              info: "info",
              warning: "priority_high",
              error: "warning",
              prev: "chevron_left",
              next: "chevron_right",
              checkboxOn: "check_box",
              checkboxOff: "check_box_outline_blank",
              checkboxIndeterminate: "indeterminate_check_box",
              delimiter: "fiber_manual_record",
              sort: "arrow_upward",
              expand: "keyboard_arrow_down",
              menu: "menu",
              subgroup: "arrow_drop_down",
              dropdown: "arrow_drop_down",
              radioOn: "radio_button_checked",
              radioOff: "radio_button_unchecked",
              edit: "edit",
              ratingEmpty: "star_border",
              ratingFull: "star",
              ratingHalf: "star_half",
              loading: "cached",
              first: "first_page",
              last: "last_page",
              unfold: "unfold_more",
              file: "attach_file",
              plus: "add",
              minus: "remove"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/mdi-svg.ts": (
          /*!***********************************************!*\
            !*** ./src/services/icons/presets/mdi-svg.ts ***!
            \***********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z",
              cancel: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              close: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
              delete: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              clear: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              success: "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z",
              info: "M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
              warning: "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
              error: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
              prev: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z",
              next: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z",
              checkboxOn: "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
              checkboxOff: "M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
              checkboxIndeterminate: "M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
              delimiter: "M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
              sort: "M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z",
              expand: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z",
              menu: "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z",
              subgroup: "M7,10L12,15L17,10H7Z",
              dropdown: "M7,10L12,15L17,10H7Z",
              radioOn: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z",
              radioOff: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
              edit: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
              ratingEmpty: "M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
              ratingFull: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z",
              ratingHalf: "M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
              loading: "M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12",
              first: "M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z",
              last: "M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z",
              unfold: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z",
              file: "M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z",
              plus: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z",
              minus: "M19,13H5V11H19V13Z"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/icons/presets/mdi.ts": (
          /*!*******************************************!*\
            !*** ./src/services/icons/presets/mdi.ts ***!
            \*******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = {
              complete: "mdi-check",
              cancel: "mdi-close-circle",
              close: "mdi-close",
              delete: "mdi-close-circle",
              clear: "mdi-close",
              success: "mdi-check-circle",
              info: "mdi-information",
              warning: "mdi-exclamation",
              error: "mdi-alert",
              prev: "mdi-chevron-left",
              next: "mdi-chevron-right",
              checkboxOn: "mdi-checkbox-marked",
              checkboxOff: "mdi-checkbox-blank-outline",
              checkboxIndeterminate: "mdi-minus-box",
              delimiter: "mdi-circle",
              sort: "mdi-arrow-up",
              expand: "mdi-chevron-down",
              menu: "mdi-menu",
              subgroup: "mdi-menu-down",
              dropdown: "mdi-menu-down",
              radioOn: "mdi-radiobox-marked",
              radioOff: "mdi-radiobox-blank",
              edit: "mdi-pencil",
              ratingEmpty: "mdi-star-outline",
              ratingFull: "mdi-star",
              ratingHalf: "mdi-star-half-full",
              loading: "mdi-cached",
              first: "mdi-page-first",
              last: "mdi-page-last",
              unfold: "mdi-unfold-more-horizontal",
              file: "mdi-paperclip",
              plus: "mdi-plus",
              minus: "mdi-minus"
            };
            r.default = a;
          }
        ),
        /***/
        "./src/services/index.ts": (
          /*!*******************************!*\
            !*** ./src/services/index.ts ***!
            \*******************************/
          /*! exports provided: Application, Breakpoint, Goto, Icons, Lang, Presets, Theme */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = i(
              /*! ./application */
              "./src/services/application/index.ts"
            );
            i.d(r, "Application", function() {
              return a.Application;
            });
            var o = i(
              /*! ./breakpoint */
              "./src/services/breakpoint/index.ts"
            );
            i.d(r, "Breakpoint", function() {
              return o.Breakpoint;
            });
            var l = i(
              /*! ./goto */
              "./src/services/goto/index.ts"
            );
            i.d(r, "Goto", function() {
              return l.Goto;
            });
            var f = i(
              /*! ./icons */
              "./src/services/icons/index.ts"
            );
            i.d(r, "Icons", function() {
              return f.Icons;
            });
            var d = i(
              /*! ./lang */
              "./src/services/lang/index.ts"
            );
            i.d(r, "Lang", function() {
              return d.Lang;
            });
            var u = i(
              /*! ./presets */
              "./src/services/presets/index.ts"
            );
            i.d(r, "Presets", function() {
              return u.Presets;
            });
            var c = i(
              /*! ./theme */
              "./src/services/theme/index.ts"
            );
            i.d(r, "Theme", function() {
              return c.Theme;
            });
          }
        ),
        /***/
        "./src/services/lang/index.ts": (
          /*!************************************!*\
            !*** ./src/services/lang/index.ts ***!
            \************************************/
          /*! exports provided: Lang */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Lang", function() {
              return g;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), f = function() {
              var m = function(y, E) {
                return m = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(C, x) {
                  C.__proto__ = x;
                } || function(C, x) {
                  for (var b in x)
                    Object.prototype.hasOwnProperty.call(x, b) && (C[b] = x[b]);
                }, m(y, E);
              };
              return function(v, y) {
                if (typeof y != "function" && y !== null)
                  throw new TypeError("Class extends value " + String(y) + " is not a constructor or null");
                m(v, y);
                function E() {
                  this.constructor = v;
                }
                v.prototype = y === null ? Object.create(y) : (E.prototype = y.prototype, new E());
              };
            }(), d = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, u = function(m, v, y) {
              if (y || arguments.length === 2)
                for (var E = 0, C = v.length, x; E < C; E++)
                  (x || !(E in v)) && (x || (x = Array.prototype.slice.call(v, 0, E)), x[E] = v[E]);
              return m.concat(x || Array.prototype.slice.call(v));
            }, c = "$vuetify.", h = Symbol("Lang fallback");
            function p(m, v, y, E) {
              y === void 0 && (y = !1);
              var C = v.replace(c, ""), x = Object(o.getObjectValueByPath)(m, C, h);
              return x === h && (y ? (Object(l.consoleError)('Translation key "' + C + '" not found in fallback'), x = v) : (Object(l.consoleWarn)('Translation key "' + C + '" not found, falling back to default'), x = p(E, v, !0, E))), x;
            }
            var g = (
              /** @class */
              function(m) {
                f(v, m);
                function v(y) {
                  var E = m.call(this) || this;
                  E.defaultLocale = "en";
                  var C = y[v.property], x = C.current, b = C.locales, P = C.t;
                  return E.current = x, E.locales = b, E.translator = P || E.defaultTranslator, E;
                }
                return v.prototype.currentLocale = function(y) {
                  var E = this.locales[this.current], C = this.locales[this.defaultLocale];
                  return p(E, y, !1, C);
                }, v.prototype.t = function(y) {
                  for (var E = [], C = 1; C < arguments.length; C++)
                    E[C - 1] = arguments[C];
                  return y.startsWith(c) ? this.translator.apply(this, u([y], d(E), !1)) : this.replace(y, E);
                }, v.prototype.defaultTranslator = function(y) {
                  for (var E = [], C = 1; C < arguments.length; C++)
                    E[C - 1] = arguments[C];
                  return this.replace(this.currentLocale(y), E);
                }, v.prototype.replace = function(y, E) {
                  return y.replace(/\{(\d+)\}/g, function(C, x) {
                    return String(E[+x]);
                  });
                }, v.property = "lang", v;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/presets/index.ts": (
          /*!***************************************!*\
            !*** ./src/services/presets/index.ts ***!
            \***************************************/
          /*! exports provided: Presets */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Presets", function() {
              return c;
            });
            var a = i(
              /*! ../../presets/default */
              "./src/presets/default/index.ts"
            ), o = i(
              /*! ../../util/console */
              "./src/util/console.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), d = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), u = function(h, p) {
              var g = {};
              for (var m in h)
                Object.prototype.hasOwnProperty.call(h, m) && p.indexOf(m) < 0 && (g[m] = h[m]);
              if (h != null && typeof Object.getOwnPropertySymbols == "function")
                for (var v = 0, m = Object.getOwnPropertySymbols(h); v < m.length; v++)
                  p.indexOf(m[v]) < 0 && Object.prototype.propertyIsEnumerable.call(h, m[v]) && (g[m[v]] = h[m[v]]);
              return g;
            }, c = (
              /** @class */
              function(h) {
                d(p, h);
                function p(g, m) {
                  var v = h.call(this) || this, y = Object(l.mergeDeep)({}, a.preset), E = m.userPreset, C = E.preset, x = C === void 0 ? {} : C, b = u(E, ["preset"]);
                  return x.preset != null && Object(o.consoleWarn)("Global presets do not support the **preset** option, it can be safely omitted"), m.preset = Object(l.mergeDeep)(Object(l.mergeDeep)(y, x), b), v;
                }
                return p.property = "presets", p;
              }(f.Service)
            );
          }
        ),
        /***/
        "./src/services/service/index.ts": (
          /*!***************************************!*\
            !*** ./src/services/service/index.ts ***!
            \***************************************/
          /*! exports provided: Service */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Service", function() {
              return a;
            });
            var a = (
              /** @class */
              function() {
                function o() {
                  this.framework = {};
                }
                return o.prototype.init = function(l, f) {
                }, o;
              }()
            );
          }
        ),
        /***/
        "./src/services/theme/index.ts": (
          /*!*************************************!*\
            !*** ./src/services/theme/index.ts ***!
            \*************************************/
          /*! exports provided: Theme */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "Theme", function() {
              return c;
            });
            var a = i(
              /*! ../service */
              "./src/services/service/index.ts"
            ), o = i(
              /*! ./utils */
              "./src/services/theme/utils.ts"
            ), l = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), f = i(
              /*! vue */
              "vue"
            ), d = /* @__PURE__ */ i.n(f), u = function() {
              var h = function(g, m) {
                return h = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function(v, y) {
                  v.__proto__ = y;
                } || function(v, y) {
                  for (var E in y)
                    Object.prototype.hasOwnProperty.call(y, E) && (v[E] = y[E]);
                }, h(g, m);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                h(p, g);
                function m() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
              };
            }(), c = (
              /** @class */
              function(h) {
                u(p, h);
                function p(g) {
                  var m = h.call(this) || this;
                  m.disabled = !1, m.isDark = null, m.unwatch = null, m.vueMeta = null;
                  var v = g[p.property], y = v.dark, E = v.disable, C = v.options, x = v.themes;
                  return m.dark = !!y, m.defaults = m.themes = x, m.options = C, E ? (m.disabled = !0, m) : (m.themes = {
                    dark: m.fillVariant(x.dark, !0),
                    light: m.fillVariant(x.light, !1)
                  }, m);
                }
                return Object.defineProperty(p.prototype, "css", {
                  // When setting css, check for element and apply new values
                  /* eslint-disable-next-line accessor-pairs */
                  set: function(m) {
                    if (this.vueMeta) {
                      this.isVueMeta23 && this.applyVueMeta23();
                      return;
                    }
                    this.checkOrCreateStyleElement() && (this.styleEl.innerHTML = m);
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "dark", {
                  get: function() {
                    return !!this.isDark;
                  },
                  set: function(m) {
                    var v = this.isDark;
                    this.isDark = m, v != null && this.applyTheme();
                  },
                  enumerable: !1,
                  configurable: !0
                }), p.prototype.applyTheme = function() {
                  if (this.disabled)
                    return this.clearCss();
                  this.css = this.generatedStyles;
                }, p.prototype.clearCss = function() {
                  this.css = "";
                }, p.prototype.init = function(g, m) {
                  this.disabled || (g.$meta ? this.initVueMeta(g) : m && this.initSSR(m), this.initTheme(g));
                }, p.prototype.setTheme = function(g, m) {
                  this.themes[g] = Object.assign(this.themes[g], m), this.applyTheme();
                }, p.prototype.resetThemes = function() {
                  this.themes.light = Object.assign({}, this.defaults.light), this.themes.dark = Object.assign({}, this.defaults.dark), this.applyTheme();
                }, p.prototype.checkOrCreateStyleElement = function() {
                  return this.styleEl = document.getElementById("vuetify-theme-stylesheet"), this.styleEl ? !0 : (this.genStyleElement(), !!this.styleEl);
                }, p.prototype.fillVariant = function(g, m) {
                  g === void 0 && (g = {});
                  var v = this.themes[m ? "dark" : "light"];
                  return Object.assign({}, v, g);
                }, p.prototype.genStyleElement = function() {
                  typeof document > "u" || (this.styleEl = document.createElement("style"), this.styleEl.type = "text/css", this.styleEl.id = "vuetify-theme-stylesheet", this.options.cspNonce && this.styleEl.setAttribute("nonce", this.options.cspNonce), document.head.appendChild(this.styleEl));
                }, p.prototype.initVueMeta = function(g) {
                  var m = this;
                  if (this.vueMeta = g.$meta(), this.isVueMeta23) {
                    g.$nextTick(function() {
                      m.applyVueMeta23();
                    });
                    return;
                  }
                  var v = typeof this.vueMeta.getOptions == "function" ? this.vueMeta.getOptions().keyName : "metaInfo", y = g.$options[v] || {};
                  g.$options[v] = function() {
                    y.style = y.style || [];
                    var E = y.style.find(function(C) {
                      return C.id === "vuetify-theme-stylesheet";
                    });
                    return E ? E.cssText = m.generatedStyles : y.style.push({
                      cssText: m.generatedStyles,
                      type: "text/css",
                      id: "vuetify-theme-stylesheet",
                      nonce: (m.options || {}).cspNonce
                    }), y;
                  };
                }, p.prototype.applyVueMeta23 = function() {
                  var g = this.vueMeta.addApp("vuetify").set;
                  g({
                    style: [{
                      cssText: this.generatedStyles,
                      type: "text/css",
                      id: "vuetify-theme-stylesheet",
                      nonce: this.options.cspNonce
                    }]
                  });
                }, p.prototype.initSSR = function(g) {
                  var m = this.options.cspNonce ? ' nonce="' + this.options.cspNonce + '"' : "";
                  g.head = g.head || "", g.head += '<style type="text/css" id="vuetify-theme-stylesheet"' + m + ">" + this.generatedStyles + "</style>";
                }, p.prototype.initTheme = function(g) {
                  var m = this;
                  typeof document > "u" || (this.unwatch && (this.unwatch(), this.unwatch = null), g.$once("hook:created", function() {
                    var v = d.a.observable({
                      themes: m.themes
                    });
                    m.unwatch = g.$watch(function() {
                      return v.themes;
                    }, function() {
                      return m.applyTheme();
                    }, {
                      deep: !0
                    });
                  }), this.applyTheme());
                }, Object.defineProperty(p.prototype, "currentTheme", {
                  get: function() {
                    var m = this.dark ? "dark" : "light";
                    return this.themes[m];
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "generatedStyles", {
                  get: function() {
                    var m = this.parsedTheme, v = this.options || {}, y;
                    return v.themeCache != null && (y = v.themeCache.get(m), y != null) || (y = o.genStyles(m, v.customProperties), v.minifyTheme != null && (y = v.minifyTheme(y)), v.themeCache != null && v.themeCache.set(m, y)), y;
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "parsedTheme", {
                  get: function() {
                    return o.parse(this.currentTheme || {}, void 0, Object(l.getNestedValue)(this.options, ["variations"], !0));
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(p.prototype, "isVueMeta23", {
                  // Is using v2.3 of vue-meta
                  // https://github.com/nuxt/vue-meta/releases/tag/v2.3.0
                  get: function() {
                    return typeof this.vueMeta.addApp == "function";
                  },
                  enumerable: !1,
                  configurable: !0
                }), p.property = "theme", p;
              }(a.Service)
            );
          }
        ),
        /***/
        "./src/services/theme/utils.ts": (
          /*!*************************************!*\
            !*** ./src/services/theme/utils.ts ***!
            \*************************************/
          /*! exports provided: parse, genStyles, genVariations, lighten, darken */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "parse", function() {
              return h;
            }), i.d(r, "genStyles", function() {
              return y;
            }), i.d(r, "genVariations", function() {
              return E;
            }), i.d(r, "lighten", function() {
              return C;
            }), i.d(r, "darken", function() {
              return x;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = i(
              /*! ../../util/colorUtils */
              "./src/util/colorUtils.ts"
            ), l = i(
              /*! ../../util/color/transformSRGB */
              "./src/util/color/transformSRGB.ts"
            ), f = i(
              /*! ../../util/color/transformCIELAB */
              "./src/util/color/transformCIELAB.ts"
            );
            function d(b) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? d = function(O) {
                return typeof O;
              } : d = function(O) {
                return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
              }, d(b);
            }
            var u = function(b, P) {
              var O = {};
              for (var T in b)
                Object.prototype.hasOwnProperty.call(b, T) && P.indexOf(T) < 0 && (O[T] = b[T]);
              if (b != null && typeof Object.getOwnPropertySymbols == "function")
                for (var M = 0, T = Object.getOwnPropertySymbols(b); M < T.length; M++)
                  P.indexOf(T[M]) < 0 && Object.prototype.propertyIsEnumerable.call(b, T[M]) && (O[T[M]] = b[T[M]]);
              return O;
            }, c = function(b, P) {
              var O = typeof Symbol == "function" && b[Symbol.iterator];
              if (!O)
                return b;
              var T = O.call(b), M, L = [], A;
              try {
                for (; (P === void 0 || P-- > 0) && !(M = T.next()).done; )
                  L.push(M.value);
              } catch (D) {
                A = {
                  error: D
                };
              } finally {
                try {
                  M && !M.done && (O = T.return) && O.call(T);
                } finally {
                  if (A)
                    throw A.error;
                }
              }
              return L;
            };
            function h(b, P, O) {
              P === void 0 && (P = !1), O === void 0 && (O = !0);
              for (var T = b.anchor, M = u(b, ["anchor"]), L = Object.keys(M), A = {}, D = 0; D < L.length; ++D) {
                var I = L[D], w = b[I];
                w != null && (O ? P ? (I === "base" || I.startsWith("lighten") || I.startsWith("darken")) && (A[I] = Object(o.colorToHex)(w)) : d(w) === "object" ? A[I] = h(w, !0, O) : A[I] = E(I, Object(o.colorToInt)(w)) : A[I] = {
                  base: Object(o.intToHex)(Object(o.colorToInt)(w))
                });
              }
              return P || (A.anchor = T || A.base || A.primary.base), A;
            }
            var p = function(P, O) {
              return `
.v-application .` + P + ` {
  background-color: ` + O + ` !important;
  border-color: ` + O + ` !important;
}
.v-application .` + P + `--text {
  color: ` + O + ` !important;
  caret-color: ` + O + ` !important;
}`;
            }, g = function(P, O, T) {
              var M = c(O.split(/(\d)/, 2), 2), L = M[0], A = M[1];
              return `
.v-application .` + P + "." + L + "-" + A + ` {
  background-color: ` + T + ` !important;
  border-color: ` + T + ` !important;
}
.v-application .` + P + "--text.text--" + L + "-" + A + ` {
  color: ` + T + ` !important;
  caret-color: ` + T + ` !important;
}`;
            }, m = function(P, O) {
              return O === void 0 && (O = "base"), "--v-" + P + "-" + O;
            }, v = function(P, O) {
              return O === void 0 && (O = "base"), "var(" + m(P, O) + ")";
            };
            function y(b, P) {
              P === void 0 && (P = !1);
              var O = b.anchor, T = u(b, ["anchor"]), M = Object.keys(T);
              if (!M.length)
                return "";
              var L = "", A = "", D = P ? v("anchor") : O;
              A += ".v-application a { color: " + D + "; }", P && (L += "  " + m("anchor") + ": " + O + `;
`);
              for (var I = 0; I < M.length; ++I) {
                var w = M[I], B = b[w];
                A += p(w, P ? v(w) : B.base), P && (L += "  " + m(w) + ": " + B.base + `;
`);
                for (var j = Object(a.keys)(B), k = 0; k < j.length; ++k) {
                  var X = j[k], rt = B[X];
                  X !== "base" && (A += g(w, X, P ? v(w, X) : rt), P && (L += "  " + m(w, X) + ": " + rt + `;
`));
                }
              }
              return P && (L = `:root {
` + L + `}

`), L + A;
            }
            function E(b, P) {
              for (var O = {
                base: Object(o.intToHex)(P)
              }, T = 5; T > 0; --T)
                O["lighten" + T] = Object(o.intToHex)(C(P, T));
              for (var T = 1; T <= 4; ++T)
                O["darken" + T] = Object(o.intToHex)(x(P, T));
              return O;
            }
            function C(b, P) {
              var O = f.fromXYZ(l.toXYZ(b));
              return O[0] = O[0] + P * 10, l.fromXYZ(f.toXYZ(O));
            }
            function x(b, P) {
              var O = f.fromXYZ(l.toXYZ(b));
              return O[0] = O[0] - P * 10, l.fromXYZ(f.toXYZ(O));
            }
          }
        ),
        /***/
        "./src/styles/components/_selection-controls.sass": (
          /*!********************************************************!*\
            !*** ./src/styles/components/_selection-controls.sass ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/styles/main.sass": (
          /*!******************************!*\
            !*** ./src/styles/main.sass ***!
            \******************************/
          /*! no static exports found */
          /***/
          function(s, r, i) {
          }
        ),
        /***/
        "./src/util/color/transformCIELAB.ts": (
          /*!*******************************************!*\
            !*** ./src/util/color/transformCIELAB.ts ***!
            \*******************************************/
          /*! exports provided: fromXYZ, toXYZ */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromXYZ", function() {
              return f;
            }), i.d(r, "toXYZ", function() {
              return d;
            });
            var a = 0.20689655172413793, o = function(c) {
              return c > Math.pow(a, 3) ? Math.cbrt(c) : c / (3 * Math.pow(a, 2)) + 4 / 29;
            }, l = function(c) {
              return c > a ? Math.pow(c, 3) : 3 * Math.pow(a, 2) * (c - 4 / 29);
            };
            function f(u) {
              var c = o, h = c(u[1]);
              return [116 * h - 16, 500 * (c(u[0] / 0.95047) - h), 200 * (h - c(u[2] / 1.08883))];
            }
            function d(u) {
              var c = l, h = (u[0] + 16) / 116;
              return [c(h + u[1] / 500) * 0.95047, c(h), c(h - u[2] / 200) * 1.08883];
            }
          }
        ),
        /***/
        "./src/util/color/transformSRGB.ts": (
          /*!*****************************************!*\
            !*** ./src/util/color/transformSRGB.ts ***!
            \*****************************************/
          /*! exports provided: fromXYZ, toXYZ */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "fromXYZ", function() {
              return u;
            }), i.d(r, "toXYZ", function() {
              return c;
            });
            var a = i(
              /*! ../../util/helpers */
              "./src/util/helpers.ts"
            ), o = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], l = function(p) {
              return p <= 31308e-7 ? p * 12.92 : 1.055 * Math.pow(p, 1 / 2.4) - 0.055;
            }, f = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], d = function(p) {
              return p <= 0.04045 ? p / 12.92 : Math.pow((p + 0.055) / 1.055, 2.4);
            };
            function u(h) {
              for (var p = Array(3), g = l, m = o, v = 0; v < 3; ++v)
                p[v] = Math.round(Object(a.clamp)(g(m[v][0] * h[0] + m[v][1] * h[1] + m[v][2] * h[2])) * 255);
              return (p[0] << 16) + (p[1] << 8) + (p[2] << 0);
            }
            function c(h) {
              for (var p = [0, 0, 0], g = d, m = f, v = g((h >> 16 & 255) / 255), y = g((h >> 8 & 255) / 255), E = g((h >> 0 & 255) / 255), C = 0; C < 3; ++C)
                p[C] = m[C][0] * v + m[C][1] * y + m[C][2] * E;
              return p;
            }
          }
        ),
        /***/
        "./src/util/colorUtils.ts": (
          /*!********************************!*\
            !*** ./src/util/colorUtils.ts ***!
            \********************************/
          /*! exports provided: isCssColor, colorToInt, classToHex, intToHex, colorToHex, HSVAtoRGBA, RGBAtoHSVA, HSVAtoHSLA, HSLAtoHSVA, RGBAtoCSS, RGBtoCSS, RGBAtoHex, HexToRGBA, HexToHSVA, HSVAtoHex, parseHex, parseGradient, RGBtoInt, contrastRatio */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "isCssColor", function() {
              return u;
            }), i.d(r, "colorToInt", function() {
              return c;
            }), i.d(r, "classToHex", function() {
              return h;
            }), i.d(r, "intToHex", function() {
              return p;
            }), i.d(r, "colorToHex", function() {
              return g;
            }), i.d(r, "HSVAtoRGBA", function() {
              return m;
            }), i.d(r, "RGBAtoHSVA", function() {
              return v;
            }), i.d(r, "HSVAtoHSLA", function() {
              return y;
            }), i.d(r, "HSLAtoHSVA", function() {
              return E;
            }), i.d(r, "RGBAtoCSS", function() {
              return C;
            }), i.d(r, "RGBtoCSS", function() {
              return x;
            }), i.d(r, "RGBAtoHex", function() {
              return b;
            }), i.d(r, "HexToRGBA", function() {
              return P;
            }), i.d(r, "HexToHSVA", function() {
              return O;
            }), i.d(r, "HSVAtoHex", function() {
              return T;
            }), i.d(r, "parseHex", function() {
              return M;
            }), i.d(r, "parseGradient", function() {
              return L;
            }), i.d(r, "RGBtoInt", function() {
              return A;
            }), i.d(r, "contrastRatio", function() {
              return D;
            });
            var a = i(
              /*! ./console */
              "./src/util/console.ts"
            ), o = i(
              /*! ./helpers */
              "./src/util/helpers.ts"
            ), l = i(
              /*! ./color/transformSRGB */
              "./src/util/color/transformSRGB.ts"
            ), f = function() {
              return f = Object.assign || function(I) {
                for (var w, B = 1, j = arguments.length; B < j; B++) {
                  w = arguments[B];
                  for (var k in w)
                    Object.prototype.hasOwnProperty.call(w, k) && (I[k] = w[k]);
                }
                return I;
              }, f.apply(this, arguments);
            }, d = function(I, w) {
              var B = typeof Symbol == "function" && I[Symbol.iterator];
              if (!B)
                return I;
              var j = B.call(I), k, X = [], rt;
              try {
                for (; (w === void 0 || w-- > 0) && !(k = j.next()).done; )
                  X.push(k.value);
              } catch (et) {
                rt = {
                  error: et
                };
              } finally {
                try {
                  k && !k.done && (B = j.return) && B.call(j);
                } finally {
                  if (rt)
                    throw rt.error;
                }
              }
              return X;
            };
            function u(I) {
              return !!I && !!I.match(/^(#|var\(--|(rgb|hsl)a?\()/);
            }
            function c(I) {
              var w;
              if (typeof I == "number")
                w = I;
              else if (typeof I == "string") {
                var B = I[0] === "#" ? I.substring(1) : I;
                B.length === 3 && (B = B.split("").map(function(j) {
                  return j + j;
                }).join("")), B.length !== 6 && Object(a.consoleWarn)("'" + I + "' is not a valid rgb color"), w = parseInt(B, 16);
              } else
                throw new TypeError("Colors can only be numbers or strings, recieved " + (I == null ? I : I.constructor.name) + " instead");
              return w < 0 ? (Object(a.consoleWarn)("Colors cannot be negative: '" + I + "'"), w = 0) : (w > 16777215 || isNaN(w)) && (Object(a.consoleWarn)("'" + I + "' is not a valid rgb color"), w = 16777215), w;
            }
            function h(I, w, B) {
              var j = d(I.toString().trim().replace("-", "").split(" ", 2), 2), k = j[0], X = j[1], rt = "";
              return k && k in w ? X && X in w[k] ? rt = w[k][X] : "base" in w[k] && (rt = w[k].base) : k && k in B && (rt = B[k]), rt;
            }
            function p(I) {
              var w = I.toString(16);
              return w.length < 6 && (w = "0".repeat(6 - w.length) + w), "#" + w;
            }
            function g(I) {
              return p(c(I));
            }
            function m(I) {
              var w = I.h, B = I.s, j = I.v, k = I.a, X = function(Z) {
                var dt = (Z + w / 60) % 6;
                return j - j * B * Math.max(Math.min(dt, 4 - dt, 1), 0);
              }, rt = [X(5), X(3), X(1)].map(function(et) {
                return Math.round(et * 255);
              });
              return {
                r: rt[0],
                g: rt[1],
                b: rt[2],
                a: k
              };
            }
            function v(I) {
              if (!I)
                return {
                  h: 0,
                  s: 1,
                  v: 1,
                  a: 1
                };
              var w = I.r / 255, B = I.g / 255, j = I.b / 255, k = Math.max(w, B, j), X = Math.min(w, B, j), rt = 0;
              k !== X && (k === w ? rt = 60 * (0 + (B - j) / (k - X)) : k === B ? rt = 60 * (2 + (j - w) / (k - X)) : k === j && (rt = 60 * (4 + (w - B) / (k - X)))), rt < 0 && (rt = rt + 360);
              var et = k === 0 ? 0 : (k - X) / k, Z = [rt, et, k];
              return {
                h: Z[0],
                s: Z[1],
                v: Z[2],
                a: I.a
              };
            }
            function y(I) {
              var w = I.h, B = I.s, j = I.v, k = I.a, X = j - j * B / 2, rt = X === 1 || X === 0 ? 0 : (j - X) / Math.min(X, 1 - X);
              return {
                h: w,
                s: rt,
                l: X,
                a: k
              };
            }
            function E(I) {
              var w = I.h, B = I.s, j = I.l, k = I.a, X = j + B * Math.min(j, 1 - j), rt = X === 0 ? 0 : 2 - 2 * j / X;
              return {
                h: w,
                s: rt,
                v: X,
                a: k
              };
            }
            function C(I) {
              return "rgba(" + I.r + ", " + I.g + ", " + I.b + ", " + I.a + ")";
            }
            function x(I) {
              return C(f(f({}, I), {
                a: 1
              }));
            }
            function b(I) {
              var w = function(j) {
                var k = Math.round(j).toString(16);
                return ("00".substr(0, 2 - k.length) + k).toUpperCase();
              };
              return "#" + [w(I.r), w(I.g), w(I.b), w(Math.round(I.a * 255))].join("");
            }
            function P(I) {
              var w = Object(o.chunk)(I.slice(1), 2).map(function(B) {
                return parseInt(B, 16);
              });
              return {
                r: w[0],
                g: w[1],
                b: w[2],
                a: Math.round(w[3] / 255 * 100) / 100
              };
            }
            function O(I) {
              var w = P(I);
              return v(w);
            }
            function T(I) {
              return b(m(I));
            }
            function M(I) {
              return I.startsWith("#") && (I = I.slice(1)), I = I.replace(/([^0-9a-f])/gi, "F"), (I.length === 3 || I.length === 4) && (I = I.split("").map(function(w) {
                return w + w;
              }).join("")), I.length === 6 ? I = Object(o.padEnd)(I, 8, "F") : I = Object(o.padEnd)(Object(o.padEnd)(I, 6), 8, "F"), ("#" + I).toUpperCase().substr(0, 9);
            }
            function L(I, w, B) {
              return I.replace(/([a-z]+(\s[a-z]+-[1-5])?)(?=$|,)/gi, function(j) {
                return h(j, w, B) || j;
              }).replace(/(rgba\()#[0-9a-f]+(?=,)/gi, function(j) {
                return "rgba(" + Object.values(P(M(j.replace(/rgba\(/, "")))).slice(0, 3).join(",");
              });
            }
            function A(I) {
              return (I.r << 16) + (I.g << 8) + I.b;
            }
            function D(I, w) {
              var B = d(Object(l.toXYZ)(A(I)), 2), j = B[1], k = d(Object(l.toXYZ)(A(w)), 2), X = k[1];
              return (Math.max(j, X) + 0.05) / (Math.min(j, X) + 0.05);
            }
          }
        ),
        /***/
        "./src/util/colors.ts": (
          /*!****************************!*\
            !*** ./src/util/colors.ts ***!
            \****************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r);
            var a = Object.freeze({
              base: "#f44336",
              lighten5: "#ffebee",
              lighten4: "#ffcdd2",
              lighten3: "#ef9a9a",
              lighten2: "#e57373",
              lighten1: "#ef5350",
              darken1: "#e53935",
              darken2: "#d32f2f",
              darken3: "#c62828",
              darken4: "#b71c1c",
              accent1: "#ff8a80",
              accent2: "#ff5252",
              accent3: "#ff1744",
              accent4: "#d50000"
            }), o = Object.freeze({
              base: "#e91e63",
              lighten5: "#fce4ec",
              lighten4: "#f8bbd0",
              lighten3: "#f48fb1",
              lighten2: "#f06292",
              lighten1: "#ec407a",
              darken1: "#d81b60",
              darken2: "#c2185b",
              darken3: "#ad1457",
              darken4: "#880e4f",
              accent1: "#ff80ab",
              accent2: "#ff4081",
              accent3: "#f50057",
              accent4: "#c51162"
            }), l = Object.freeze({
              base: "#9c27b0",
              lighten5: "#f3e5f5",
              lighten4: "#e1bee7",
              lighten3: "#ce93d8",
              lighten2: "#ba68c8",
              lighten1: "#ab47bc",
              darken1: "#8e24aa",
              darken2: "#7b1fa2",
              darken3: "#6a1b9a",
              darken4: "#4a148c",
              accent1: "#ea80fc",
              accent2: "#e040fb",
              accent3: "#d500f9",
              accent4: "#aa00ff"
            }), f = Object.freeze({
              base: "#673ab7",
              lighten5: "#ede7f6",
              lighten4: "#d1c4e9",
              lighten3: "#b39ddb",
              lighten2: "#9575cd",
              lighten1: "#7e57c2",
              darken1: "#5e35b1",
              darken2: "#512da8",
              darken3: "#4527a0",
              darken4: "#311b92",
              accent1: "#b388ff",
              accent2: "#7c4dff",
              accent3: "#651fff",
              accent4: "#6200ea"
            }), d = Object.freeze({
              base: "#3f51b5",
              lighten5: "#e8eaf6",
              lighten4: "#c5cae9",
              lighten3: "#9fa8da",
              lighten2: "#7986cb",
              lighten1: "#5c6bc0",
              darken1: "#3949ab",
              darken2: "#303f9f",
              darken3: "#283593",
              darken4: "#1a237e",
              accent1: "#8c9eff",
              accent2: "#536dfe",
              accent3: "#3d5afe",
              accent4: "#304ffe"
            }), u = Object.freeze({
              base: "#2196f3",
              lighten5: "#e3f2fd",
              lighten4: "#bbdefb",
              lighten3: "#90caf9",
              lighten2: "#64b5f6",
              lighten1: "#42a5f5",
              darken1: "#1e88e5",
              darken2: "#1976d2",
              darken3: "#1565c0",
              darken4: "#0d47a1",
              accent1: "#82b1ff",
              accent2: "#448aff",
              accent3: "#2979ff",
              accent4: "#2962ff"
            }), c = Object.freeze({
              base: "#03a9f4",
              lighten5: "#e1f5fe",
              lighten4: "#b3e5fc",
              lighten3: "#81d4fa",
              lighten2: "#4fc3f7",
              lighten1: "#29b6f6",
              darken1: "#039be5",
              darken2: "#0288d1",
              darken3: "#0277bd",
              darken4: "#01579b",
              accent1: "#80d8ff",
              accent2: "#40c4ff",
              accent3: "#00b0ff",
              accent4: "#0091ea"
            }), h = Object.freeze({
              base: "#00bcd4",
              lighten5: "#e0f7fa",
              lighten4: "#b2ebf2",
              lighten3: "#80deea",
              lighten2: "#4dd0e1",
              lighten1: "#26c6da",
              darken1: "#00acc1",
              darken2: "#0097a7",
              darken3: "#00838f",
              darken4: "#006064",
              accent1: "#84ffff",
              accent2: "#18ffff",
              accent3: "#00e5ff",
              accent4: "#00b8d4"
            }), p = Object.freeze({
              base: "#009688",
              lighten5: "#e0f2f1",
              lighten4: "#b2dfdb",
              lighten3: "#80cbc4",
              lighten2: "#4db6ac",
              lighten1: "#26a69a",
              darken1: "#00897b",
              darken2: "#00796b",
              darken3: "#00695c",
              darken4: "#004d40",
              accent1: "#a7ffeb",
              accent2: "#64ffda",
              accent3: "#1de9b6",
              accent4: "#00bfa5"
            }), g = Object.freeze({
              base: "#4caf50",
              lighten5: "#e8f5e9",
              lighten4: "#c8e6c9",
              lighten3: "#a5d6a7",
              lighten2: "#81c784",
              lighten1: "#66bb6a",
              darken1: "#43a047",
              darken2: "#388e3c",
              darken3: "#2e7d32",
              darken4: "#1b5e20",
              accent1: "#b9f6ca",
              accent2: "#69f0ae",
              accent3: "#00e676",
              accent4: "#00c853"
            }), m = Object.freeze({
              base: "#8bc34a",
              lighten5: "#f1f8e9",
              lighten4: "#dcedc8",
              lighten3: "#c5e1a5",
              lighten2: "#aed581",
              lighten1: "#9ccc65",
              darken1: "#7cb342",
              darken2: "#689f38",
              darken3: "#558b2f",
              darken4: "#33691e",
              accent1: "#ccff90",
              accent2: "#b2ff59",
              accent3: "#76ff03",
              accent4: "#64dd17"
            }), v = Object.freeze({
              base: "#cddc39",
              lighten5: "#f9fbe7",
              lighten4: "#f0f4c3",
              lighten3: "#e6ee9c",
              lighten2: "#dce775",
              lighten1: "#d4e157",
              darken1: "#c0ca33",
              darken2: "#afb42b",
              darken3: "#9e9d24",
              darken4: "#827717",
              accent1: "#f4ff81",
              accent2: "#eeff41",
              accent3: "#c6ff00",
              accent4: "#aeea00"
            }), y = Object.freeze({
              base: "#ffeb3b",
              lighten5: "#fffde7",
              lighten4: "#fff9c4",
              lighten3: "#fff59d",
              lighten2: "#fff176",
              lighten1: "#ffee58",
              darken1: "#fdd835",
              darken2: "#fbc02d",
              darken3: "#f9a825",
              darken4: "#f57f17",
              accent1: "#ffff8d",
              accent2: "#ffff00",
              accent3: "#ffea00",
              accent4: "#ffd600"
            }), E = Object.freeze({
              base: "#ffc107",
              lighten5: "#fff8e1",
              lighten4: "#ffecb3",
              lighten3: "#ffe082",
              lighten2: "#ffd54f",
              lighten1: "#ffca28",
              darken1: "#ffb300",
              darken2: "#ffa000",
              darken3: "#ff8f00",
              darken4: "#ff6f00",
              accent1: "#ffe57f",
              accent2: "#ffd740",
              accent3: "#ffc400",
              accent4: "#ffab00"
            }), C = Object.freeze({
              base: "#ff9800",
              lighten5: "#fff3e0",
              lighten4: "#ffe0b2",
              lighten3: "#ffcc80",
              lighten2: "#ffb74d",
              lighten1: "#ffa726",
              darken1: "#fb8c00",
              darken2: "#f57c00",
              darken3: "#ef6c00",
              darken4: "#e65100",
              accent1: "#ffd180",
              accent2: "#ffab40",
              accent3: "#ff9100",
              accent4: "#ff6d00"
            }), x = Object.freeze({
              base: "#ff5722",
              lighten5: "#fbe9e7",
              lighten4: "#ffccbc",
              lighten3: "#ffab91",
              lighten2: "#ff8a65",
              lighten1: "#ff7043",
              darken1: "#f4511e",
              darken2: "#e64a19",
              darken3: "#d84315",
              darken4: "#bf360c",
              accent1: "#ff9e80",
              accent2: "#ff6e40",
              accent3: "#ff3d00",
              accent4: "#dd2c00"
            }), b = Object.freeze({
              base: "#795548",
              lighten5: "#efebe9",
              lighten4: "#d7ccc8",
              lighten3: "#bcaaa4",
              lighten2: "#a1887f",
              lighten1: "#8d6e63",
              darken1: "#6d4c41",
              darken2: "#5d4037",
              darken3: "#4e342e",
              darken4: "#3e2723"
            }), P = Object.freeze({
              base: "#607d8b",
              lighten5: "#eceff1",
              lighten4: "#cfd8dc",
              lighten3: "#b0bec5",
              lighten2: "#90a4ae",
              lighten1: "#78909c",
              darken1: "#546e7a",
              darken2: "#455a64",
              darken3: "#37474f",
              darken4: "#263238"
            }), O = Object.freeze({
              base: "#9e9e9e",
              lighten5: "#fafafa",
              lighten4: "#f5f5f5",
              lighten3: "#eeeeee",
              lighten2: "#e0e0e0",
              lighten1: "#bdbdbd",
              darken1: "#757575",
              darken2: "#616161",
              darken3: "#424242",
              darken4: "#212121"
            }), T = Object.freeze({
              black: "#000000",
              white: "#ffffff",
              transparent: "transparent"
            });
            r.default = Object.freeze({
              red: a,
              pink: o,
              purple: l,
              deepPurple: f,
              indigo: d,
              blue: u,
              lightBlue: c,
              cyan: h,
              teal: p,
              green: g,
              lightGreen: m,
              lime: v,
              yellow: y,
              amber: E,
              orange: C,
              deepOrange: x,
              brown: b,
              blueGrey: P,
              grey: O,
              shades: T
            });
          }
        ),
        /***/
        "./src/util/console.ts": (
          /*!*****************************!*\
            !*** ./src/util/console.ts ***!
            \*****************************/
          /*! exports provided: consoleInfo, consoleWarn, consoleError, deprecate, breaking, removed */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "consoleInfo", function() {
              return l;
            }), i.d(r, "consoleWarn", function() {
              return f;
            }), i.d(r, "consoleError", function() {
              return d;
            }), i.d(r, "deprecate", function() {
              return u;
            }), i.d(r, "breaking", function() {
              return c;
            }), i.d(r, "removed", function() {
              return h;
            });
            var a = i(
              /*! ../framework */
              "./src/framework.ts"
            );
            function o(y, E, C) {
              if (!a.default.config.silent) {
                if (C && (E = {
                  _isVue: !0,
                  $parent: C,
                  $options: E
                }), E) {
                  if (E.$_alreadyWarned = E.$_alreadyWarned || [], E.$_alreadyWarned.includes(y))
                    return;
                  E.$_alreadyWarned.push(y);
                }
                return "[Vuetify] " + y + (E ? v(E) : "");
              }
            }
            function l(y, E, C) {
              var x = o(y, E, C);
              x != null && console.info(x);
            }
            function f(y, E, C) {
              var x = o(y, E, C);
              x != null && console.warn(x);
            }
            function d(y, E, C) {
              var x = o(y, E, C);
              x != null && console.error(x);
            }
            function u(y, E, C, x) {
              f("[UPGRADE] '" + y + "' is deprecated, use '" + E + "' instead.", C, x);
            }
            function c(y, E, C, x) {
              d("[BREAKING] '" + y + "' has been removed, use '" + E + "' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide", C, x);
            }
            function h(y, E, C) {
              f("[REMOVED] '" + y + "' has been removed. You can safely omit it.", E, C);
            }
            var p = /(?:^|[-_])(\w)/g, g = function(E) {
              return E.replace(p, function(C) {
                return C.toUpperCase();
              }).replace(/[-_]/g, "");
            };
            function m(y, E) {
              if (y.$root === y)
                return "<Root>";
              var C = typeof y == "function" && y.cid != null ? y.options : y._isVue ? y.$options || y.constructor.options : y || {}, x = C.name || C._componentTag, b = C.__file;
              if (!x && b) {
                var P = b.match(/([^/\\]+)\.vue$/);
                x = P && P[1];
              }
              return (x ? "<" + g(x) + ">" : "<Anonymous>") + (b && E !== !1 ? " at " + b : "");
            }
            function v(y) {
              if (y._isVue && y.$parent) {
                for (var E = [], C = 0; y; ) {
                  if (E.length > 0) {
                    var x = E[E.length - 1];
                    if (x.constructor === y.constructor) {
                      C++, y = y.$parent;
                      continue;
                    } else
                      C > 0 && (E[E.length - 1] = [x, C], C = 0);
                  }
                  E.push(y), y = y.$parent;
                }
                return `

found in

` + E.map(function(b, P) {
                  return "" + (P === 0 ? "---> " : " ".repeat(5 + P * 2)) + (Array.isArray(b) ? m(b[0]) + "... (" + b[1] + " recursive calls)" : m(b));
                }).join(`
`);
              } else
                return `

(found in ` + m(y) + ")";
            }
          }
        ),
        /***/
        "./src/util/dateTimeUtils.ts": (
          /*!***********************************!*\
            !*** ./src/util/dateTimeUtils.ts ***!
            \***********************************/
          /*! exports provided: weekNumber, isLeapYear */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "weekNumber", function() {
              return d;
            }), i.d(r, "isLeapYear", function() {
              return u;
            });
            function a(c, h, p) {
              h === void 0 && (h = 0), p === void 0 && (p = 1);
              var g;
              return c < 100 && c >= 0 ? (g = new Date(Date.UTC(c, h, p)), isFinite(g.getUTCFullYear()) && g.setUTCFullYear(c)) : g = new Date(Date.UTC(c, h, p)), g;
            }
            function o(c, h, p) {
              var g = 7 + h - p, m = (7 + a(c, 0, g).getUTCDay() - h) % 7;
              return -m + g - 1;
            }
            function l(c, h, p, g) {
              var m = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][h];
              return h > 1 && u(c) && m++, m + p;
            }
            function f(c, h, p) {
              var g = o(c, h, p), m = o(c + 1, h, p), v = u(c) ? 366 : 365;
              return (v - g + m) / 7;
            }
            function d(c, h, p, g, m) {
              var v = o(c, g, m), y = Math.ceil((l(c, h, p) - v) / 7);
              return y < 1 ? y + f(c - 1, g, m) : y > f(c, g, m) ? y - f(c, g, m) : y;
            }
            function u(c) {
              return c % 4 === 0 && c % 100 !== 0 || c % 400 === 0;
            }
          }
        ),
        /***/
        "./src/util/dedupeModelListeners.ts": (
          /*!******************************************!*\
            !*** ./src/util/dedupeModelListeners.ts ***!
            \******************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o) {
              if (o.model && o.on && o.on.input)
                if (Array.isArray(o.on.input)) {
                  var l = o.on.input.indexOf(o.model.callback);
                  l > -1 && o.on.input.splice(l, 1);
                } else
                  delete o.on.input;
            }
          }
        ),
        /***/
        "./src/util/dom.ts": (
          /*!*************************!*\
            !*** ./src/util/dom.ts ***!
            \*************************/
          /*! exports provided: attachedRoot */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "attachedRoot", function() {
              return a;
            });
            function a(o) {
              if (typeof o.getRootNode != "function") {
                for (; o.parentNode; )
                  o = o.parentNode;
                return o !== document ? null : document;
              }
              var l = o.getRootNode();
              return l !== document && l.getRootNode({
                composed: !0
              }) !== document ? null : l;
            }
          }
        ),
        /***/
        "./src/util/helpers.ts": (
          /*!*****************************!*\
            !*** ./src/util/helpers.ts ***!
            \*****************************/
          /*! exports provided: createSimpleFunctional, directiveConfig, addOnceEventListener, passiveSupported, addPassiveEventListener, getNestedValue, deepEqual, getObjectValueByPath, getPropertyFromItem, createRange, getZIndex, filterObjectOnKeys, convertToUnit, kebabCase, isObject, keyCodes, remapInternalIcon, keys, camelize, arrayDiff, upperFirst, groupItems, wrapInArray, sortItems, defaultFilter, searchItems, getSlotType, debounce, throttle, getPrefixedScopedSlots, getSlot, clamp, padEnd, chunk, humanReadableFileSize, camelizeObjectKeys, mergeDeep, fillArray, composedPath */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "createSimpleFunctional", function() {
              return c;
            }), i.d(r, "directiveConfig", function() {
              return h;
            }), i.d(r, "addOnceEventListener", function() {
              return p;
            }), i.d(r, "passiveSupported", function() {
              return g;
            }), i.d(r, "addPassiveEventListener", function() {
              return v;
            }), i.d(r, "getNestedValue", function() {
              return y;
            }), i.d(r, "deepEqual", function() {
              return E;
            }), i.d(r, "getObjectValueByPath", function() {
              return C;
            }), i.d(r, "getPropertyFromItem", function() {
              return x;
            }), i.d(r, "createRange", function() {
              return b;
            }), i.d(r, "getZIndex", function() {
              return P;
            }), i.d(r, "filterObjectOnKeys", function() {
              return O;
            }), i.d(r, "convertToUnit", function() {
              return T;
            }), i.d(r, "kebabCase", function() {
              return M;
            }), i.d(r, "isObject", function() {
              return L;
            }), i.d(r, "keyCodes", function() {
              return A;
            }), i.d(r, "remapInternalIcon", function() {
              return D;
            }), i.d(r, "keys", function() {
              return I;
            }), i.d(r, "camelize", function() {
              return B;
            }), i.d(r, "arrayDiff", function() {
              return j;
            }), i.d(r, "upperFirst", function() {
              return k;
            }), i.d(r, "groupItems", function() {
              return X;
            }), i.d(r, "wrapInArray", function() {
              return rt;
            }), i.d(r, "sortItems", function() {
              return et;
            }), i.d(r, "defaultFilter", function() {
              return Z;
            }), i.d(r, "searchItems", function() {
              return dt;
            }), i.d(r, "getSlotType", function() {
              return vt;
            }), i.d(r, "debounce", function() {
              return bt;
            }), i.d(r, "throttle", function() {
              return it;
            }), i.d(r, "getPrefixedScopedSlots", function() {
              return R;
            }), i.d(r, "getSlot", function() {
              return V;
            }), i.d(r, "clamp", function() {
              return tt;
            }), i.d(r, "padEnd", function() {
              return Y;
            }), i.d(r, "chunk", function() {
              return W;
            }), i.d(r, "humanReadableFileSize", function() {
              return z;
            }), i.d(r, "camelizeObjectKeys", function() {
              return at;
            }), i.d(r, "mergeDeep", function() {
              return ct;
            }), i.d(r, "fillArray", function() {
              return Mt;
            }), i.d(r, "composedPath", function() {
              return N;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l(S) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? l = function(F) {
                return typeof F;
              } : l = function(F) {
                return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
              }, l(S);
            }
            var f = function() {
              return f = Object.assign || function(S) {
                for (var _, F = 1, G = arguments.length; F < G; F++) {
                  _ = arguments[F];
                  for (var nt in _)
                    Object.prototype.hasOwnProperty.call(_, nt) && (S[nt] = _[nt]);
                }
                return S;
              }, f.apply(this, arguments);
            }, d = function(S, _) {
              var F = typeof Symbol == "function" && S[Symbol.iterator];
              if (!F)
                return S;
              var G = F.call(S), nt, lt = [], yt;
              try {
                for (; (_ === void 0 || _-- > 0) && !(nt = G.next()).done; )
                  lt.push(nt.value);
              } catch (Lt) {
                yt = {
                  error: Lt
                };
              } finally {
                try {
                  nt && !nt.done && (F = G.return) && F.call(G);
                } finally {
                  if (yt)
                    throw yt.error;
                }
              }
              return lt;
            }, u = function(S, _, F) {
              if (F || arguments.length === 2)
                for (var G = 0, nt = _.length, lt; G < nt; G++)
                  (lt || !(G in _)) && (lt || (lt = Array.prototype.slice.call(_, 0, G)), lt[G] = _[G]);
              return S.concat(lt || Array.prototype.slice.call(_));
            };
            function c(S, _, F) {
              return _ === void 0 && (_ = "div"), o.a.extend({
                name: F || S.replace(/__/g, "-"),
                functional: !0,
                props: {
                  tag: {
                    type: String,
                    default: _
                  }
                },
                render: function(nt, lt) {
                  var yt = lt.data, Lt = lt.props, Ft = lt.children;
                  return yt.staticClass = (S + " " + (yt.staticClass || "")).trim(), nt(Lt.tag, yt, Ft);
                }
              });
            }
            function h(S, _) {
              return _ === void 0 && (_ = {}), f(f(f(f({}, _), S.modifiers), {
                value: S.arg
              }), S.value || {});
            }
            function p(S, _, F, G) {
              G === void 0 && (G = !1);
              var nt = function lt(yt) {
                F(yt), S.removeEventListener(_, lt, G);
              };
              S.addEventListener(_, nt, G);
            }
            var g = !1;
            try {
              if (typeof window < "u") {
                var m = Object.defineProperty({}, "passive", {
                  get: function() {
                    g = !0;
                  }
                });
                window.addEventListener("testListener", m, m), window.removeEventListener("testListener", m, m);
              }
            } catch (S) {
              console.warn(S);
            }
            function v(S, _, F, G) {
              S.addEventListener(_, F, g ? G : !1);
            }
            function y(S, _, F) {
              var G = _.length - 1;
              if (G < 0)
                return S === void 0 ? F : S;
              for (var nt = 0; nt < G; nt++) {
                if (S == null)
                  return F;
                S = S[_[nt]];
              }
              return S == null || S[_[G]] === void 0 ? F : S[_[G]];
            }
            function E(S, _) {
              if (S === _)
                return !0;
              if (S instanceof Date && _ instanceof Date && S.getTime() !== _.getTime() || S !== Object(S) || _ !== Object(_))
                return !1;
              var F = Object.keys(S);
              return F.length !== Object.keys(_).length ? !1 : F.every(function(G) {
                return E(S[G], _[G]);
              });
            }
            function C(S, _, F) {
              return S == null || !_ || typeof _ != "string" ? F : S[_] !== void 0 ? S[_] : (_ = _.replace(/\[(\w+)\]/g, ".$1"), _ = _.replace(/^\./, ""), y(S, _.split("."), F));
            }
            function x(S, _, F) {
              if (_ == null)
                return S === void 0 ? F : S;
              if (S !== Object(S))
                return F === void 0 ? S : F;
              if (typeof _ == "string")
                return C(S, _, F);
              if (Array.isArray(_))
                return y(S, _, F);
              if (typeof _ != "function")
                return F;
              var G = _(S, F);
              return typeof G > "u" ? F : G;
            }
            function b(S) {
              return Array.from({
                length: S
              }, function(_, F) {
                return F;
              });
            }
            function P(S) {
              if (!S || S.nodeType !== Node.ELEMENT_NODE)
                return 0;
              var _ = +window.getComputedStyle(S).getPropertyValue("z-index");
              return _ || P(S.parentNode);
            }
            function O(S, _) {
              for (var F = {}, G = 0; G < _.length; G++) {
                var nt = _[G];
                typeof S[nt] < "u" && (F[nt] = S[nt]);
              }
              return F;
            }
            function T(S, _) {
              if (_ === void 0 && (_ = "px"), !(S == null || S === ""))
                return isNaN(+S) ? String(S) : "" + Number(S) + _;
            }
            function M(S) {
              return (S || "").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            }
            function L(S) {
              return S !== null && l(S) === "object";
            }
            var A = Object.freeze({
              enter: 13,
              tab: 9,
              delete: 46,
              esc: 27,
              space: 32,
              up: 38,
              down: 40,
              left: 37,
              right: 39,
              end: 35,
              home: 36,
              del: 46,
              backspace: 8,
              insert: 45,
              pageup: 33,
              pagedown: 34,
              shift: 16
            });
            function D(S, _) {
              var F = S.$vuetify.icons.component;
              if (_.startsWith("$")) {
                var G = "$vuetify.icons.values." + _.split("$").pop().split(".").pop(), nt = C(S, G, _);
                if (typeof nt == "string")
                  _ = nt;
                else
                  return nt;
              }
              return F == null ? _ : {
                component: F,
                props: {
                  icon: _
                }
              };
            }
            function I(S) {
              return Object.keys(S);
            }
            var w = /-(\w)/g, B = function(_) {
              return _.replace(w, function(F, G) {
                return G ? G.toUpperCase() : "";
              });
            };
            function j(S, _) {
              for (var F = [], G = 0; G < _.length; G++)
                S.indexOf(_[G]) < 0 && F.push(_[G]);
              return F;
            }
            function k(S) {
              return S.charAt(0).toUpperCase() + S.slice(1);
            }
            function X(S, _, F) {
              for (var G = _[0], nt = [], lt, yt = 0; yt < S.length; yt++) {
                var Lt = S[yt], Ft = C(Lt, G, null);
                lt !== Ft && (lt = Ft, nt.push({
                  name: Ft ?? "",
                  items: []
                })), nt[nt.length - 1].items.push(Lt);
              }
              return nt;
            }
            function rt(S) {
              return S != null ? Array.isArray(S) ? S : [S] : [];
            }
            function et(S, _, F, G, nt) {
              if (_ === null || !_.length)
                return S;
              var lt = new Intl.Collator(G, {
                sensitivity: "accent",
                usage: "sort"
              });
              return S.sort(function(yt, Lt) {
                for (var Ft, Jt, J = 0; J < _.length; J++) {
                  var ft = _[J], Ct = C(yt, ft), St = C(Lt, ft);
                  if (F[J] && (Ft = d([St, Ct], 2), Ct = Ft[0], St = Ft[1]), nt && nt[ft]) {
                    var Tt = nt[ft](Ct, St);
                    if (!Tt)
                      continue;
                    return Tt;
                  }
                  if (!(Ct === null && St === null)) {
                    if (Ct instanceof Date && St instanceof Date)
                      return Ct.getTime() - St.getTime();
                    if (Jt = d([Ct, St].map(function(kt) {
                      return (kt || "").toString().toLocaleLowerCase();
                    }), 2), Ct = Jt[0], St = Jt[1], Ct !== St)
                      return !isNaN(Ct) && !isNaN(St) ? Number(Ct) - Number(St) : lt.compare(Ct, St);
                  }
                }
                return 0;
              });
            }
            function Z(S, _, F) {
              return S != null && _ != null && typeof S != "boolean" && S.toString().toLocaleLowerCase().indexOf(_.toLocaleLowerCase()) !== -1;
            }
            function dt(S, _) {
              return !_ || (_ = _.toString().toLowerCase(), _.trim() === "") ? S : S.filter(function(F) {
                return Object.keys(F).some(function(G) {
                  return Z(C(F, G), _);
                });
              });
            }
            function vt(S, _, F) {
              if (S.$slots.hasOwnProperty(_) && S.$scopedSlots.hasOwnProperty(_) && S.$scopedSlots[_].name)
                return F ? "v-slot" : "scoped";
              if (S.$slots.hasOwnProperty(_))
                return "normal";
              if (S.$scopedSlots.hasOwnProperty(_))
                return "scoped";
            }
            function bt(S, _) {
              var F = 0;
              return function() {
                for (var G = [], nt = 0; nt < arguments.length; nt++)
                  G[nt] = arguments[nt];
                clearTimeout(F), F = setTimeout(function() {
                  return S.apply(void 0, u([], d(G), !1));
                }, _);
              };
            }
            function it(S, _) {
              var F = !1;
              return function() {
                for (var G = [], nt = 0; nt < arguments.length; nt++)
                  G[nt] = arguments[nt];
                if (!F)
                  return F = !0, setTimeout(function() {
                    return F = !1;
                  }, _), S.apply(void 0, u([], d(G), !1));
              };
            }
            function R(S, _) {
              return Object.keys(_).filter(function(F) {
                return F.startsWith(S);
              }).reduce(function(F, G) {
                return F[G.replace(S, "")] = _[G], F;
              }, {});
            }
            function V(S, _, F, G) {
              if (_ === void 0 && (_ = "default"), G === void 0 && (G = !1), S.$scopedSlots.hasOwnProperty(_))
                return S.$scopedSlots[_](F instanceof Function ? F() : F);
              if (S.$slots.hasOwnProperty(_) && (!F || G))
                return S.$slots[_];
            }
            function tt(S, _, F) {
              return _ === void 0 && (_ = 0), F === void 0 && (F = 1), Math.max(_, Math.min(F, S));
            }
            function Y(S, _, F) {
              return F === void 0 && (F = "0"), S + F.repeat(Math.max(0, _ - S.length));
            }
            function W(S, _) {
              _ === void 0 && (_ = 1);
              for (var F = [], G = 0; G < S.length; )
                F.push(S.substr(G, _)), G += _;
              return F;
            }
            function z(S, _) {
              _ === void 0 && (_ = !1);
              var F = _ ? 1024 : 1e3;
              if (S < F)
                return S + " B";
              for (var G = _ ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"], nt = -1; Math.abs(S) >= F && nt < G.length - 1; )
                S /= F, ++nt;
              return S.toFixed(1) + " " + G[nt] + "B";
            }
            function at(S) {
              return S ? Object.keys(S).reduce(function(_, F) {
                return _[B(F)] = S[F], _;
              }, {}) : {};
            }
            function ct(S, _) {
              S === void 0 && (S = {}), _ === void 0 && (_ = {});
              for (var F in _) {
                var G = S[F], nt = _[F];
                if (L(G) && L(nt)) {
                  S[F] = ct(G, nt);
                  continue;
                }
                S[F] = nt;
              }
              return S;
            }
            function Mt(S, _) {
              return Array(S).fill(_);
            }
            function N(S) {
              if (S.composedPath)
                return S.composedPath();
              for (var _ = [], F = S.target; F; ) {
                if (_.push(F), F.tagName === "HTML")
                  return _.push(document), _.push(window), _;
                F = F.parentElement;
              }
              return _;
            }
          }
        ),
        /***/
        "./src/util/mergeData.ts": (
          /*!*******************************!*\
            !*** ./src/util/mergeData.ts ***!
            \*******************************/
          /*! exports provided: default, mergeStyles, mergeClasses, mergeListeners */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return c;
            }), i.d(r, "mergeStyles", function() {
              return h;
            }), i.d(r, "mergeClasses", function() {
              return p;
            }), i.d(r, "mergeListeners", function() {
              return g;
            });
            var a = i(
              /*! ./helpers */
              "./src/util/helpers.ts"
            ), o = function() {
              return o = Object.assign || function(m) {
                for (var v, y = 1, E = arguments.length; y < E; y++) {
                  v = arguments[y];
                  for (var C in v)
                    Object.prototype.hasOwnProperty.call(v, C) && (m[C] = v[C]);
                }
                return m;
              }, o.apply(this, arguments);
            }, l = function(m) {
              var v = typeof Symbol == "function" && Symbol.iterator, y = v && m[v], E = 0;
              if (y)
                return y.call(m);
              if (m && typeof m.length == "number")
                return {
                  next: function() {
                    return m && E >= m.length && (m = void 0), {
                      value: m && m[E++],
                      done: !m
                    };
                  }
                };
              throw new TypeError(v ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, f = function(m, v) {
              var y = typeof Symbol == "function" && m[Symbol.iterator];
              if (!y)
                return m;
              var E = y.call(m), C, x = [], b;
              try {
                for (; (v === void 0 || v-- > 0) && !(C = E.next()).done; )
                  x.push(C.value);
              } catch (P) {
                b = {
                  error: P
                };
              } finally {
                try {
                  C && !C.done && (y = E.return) && y.call(E);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              return x;
            }, d = {
              styleList: /;(?![^(]*\))/g,
              styleProp: /:(.*)/
            };
            function u(m) {
              var v, y, E = {};
              try {
                for (var C = l(m.split(d.styleList)), x = C.next(); !x.done; x = C.next()) {
                  var b = x.value, P = f(b.split(d.styleProp), 2), O = P[0], T = P[1];
                  O = O.trim(), O && (typeof T == "string" && (T = T.trim()), E[Object(a.camelize)(O)] = T);
                }
              } catch (M) {
                v = {
                  error: M
                };
              } finally {
                try {
                  x && !x.done && (y = C.return) && y.call(C);
                } finally {
                  if (v)
                    throw v.error;
                }
              }
              return E;
            }
            function c() {
              for (var m, v, y = {}, E = arguments.length, C; E--; )
                try {
                  for (var x = (m = void 0, l(Object.keys(arguments[E]))), b = x.next(); !b.done; b = x.next())
                    switch (C = b.value, C) {
                      case "class":
                      case "directives":
                        arguments[E][C] && (y[C] = p(y[C], arguments[E][C]));
                        break;
                      case "style":
                        arguments[E][C] && (y[C] = h(y[C], arguments[E][C]));
                        break;
                      case "staticClass":
                        if (!arguments[E][C])
                          break;
                        y[C] === void 0 && (y[C] = ""), y[C] && (y[C] += " "), y[C] += arguments[E][C].trim();
                        break;
                      case "on":
                      case "nativeOn":
                        arguments[E][C] && (y[C] = g(y[C], arguments[E][C]));
                        break;
                      case "attrs":
                      case "props":
                      case "domProps":
                      case "scopedSlots":
                      case "staticStyle":
                      case "hook":
                      case "transition":
                        if (!arguments[E][C])
                          break;
                        y[C] || (y[C] = {}), y[C] = o(o({}, arguments[E][C]), y[C]);
                        break;
                      default:
                        y[C] || (y[C] = arguments[E][C]);
                    }
                } catch (P) {
                  m = {
                    error: P
                  };
                } finally {
                  try {
                    b && !b.done && (v = x.return) && v.call(x);
                  } finally {
                    if (m)
                      throw m.error;
                  }
                }
              return y;
            }
            function h(m, v) {
              return m ? v ? (m = Object(a.wrapInArray)(typeof m == "string" ? u(m) : m), m.concat(typeof v == "string" ? u(v) : v)) : m : v;
            }
            function p(m, v) {
              return v ? m && m ? Object(a.wrapInArray)(m).concat(v) : v : m;
            }
            function g() {
              for (var m = [], v = 0; v < arguments.length; v++)
                m[v] = arguments[v];
              if (!m[0])
                return m[1];
              if (!m[1])
                return m[0];
              for (var y = {}, E = 2; E--; ) {
                var C = m[E];
                for (var x in C)
                  C[x] && (y[x] ? y[x] = [].concat(C[x], y[x]) : y[x] = C[x]);
              }
              return y;
            }
          }
        ),
        /***/
        "./src/util/mixins.ts": (
          /*!****************************!*\
            !*** ./src/util/mixins.ts ***!
            \****************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return l;
            });
            var a = i(
              /*! vue */
              "vue"
            ), o = /* @__PURE__ */ i.n(a);
            function l() {
              for (var f = [], d = 0; d < arguments.length; d++)
                f[d] = arguments[d];
              return o.a.extend({
                mixins: f
              });
            }
          }
        ),
        /***/
        "./src/util/rebuildFunctionalSlots.ts": (
          /*!********************************************!*\
            !*** ./src/util/rebuildFunctionalSlots.ts ***!
            \********************************************/
          /*! exports provided: default */
          /***/
          function(s, r, i) {
            i.r(r), i.d(r, "default", function() {
              return a;
            });
            function a(o, l) {
              var f = [];
              for (var d in o)
                o.hasOwnProperty(d) && f.push(l("template", {
                  slot: d
                }, o[d]));
              return f;
            }
          }
        ),
        /***/
        vue: (
          /*!******************************************************************************!*\
            !*** external {"commonjs":"vue","commonjs2":"vue","amd":"vue","root":"Vue"} ***!
            \******************************************************************************/
          /*! no static exports found */
          /***/
          function(s, r) {
            s.exports = n;
          }
        )
        /******/
      }).default
    );
  });
})(U_);
var HG = U_.exports;
const W_ = /* @__PURE__ */ nl(HG);
var pf = { exports: {} };
pf.exports;
(function(e, t) {
  var n = 200, s = "__lodash_hash_undefined__", r = 800, i = 16, a = 9007199254740991, o = "[object Arguments]", l = "[object Array]", f = "[object AsyncFunction]", d = "[object Boolean]", u = "[object Date]", c = "[object Error]", h = "[object Function]", p = "[object GeneratorFunction]", g = "[object Map]", m = "[object Number]", v = "[object Null]", y = "[object Object]", E = "[object Proxy]", C = "[object RegExp]", x = "[object Set]", b = "[object String]", P = "[object Undefined]", O = "[object WeakMap]", T = "[object ArrayBuffer]", M = "[object DataView]", L = "[object Float32Array]", A = "[object Float64Array]", D = "[object Int8Array]", I = "[object Int16Array]", w = "[object Int32Array]", B = "[object Uint8Array]", j = "[object Uint8ClampedArray]", k = "[object Uint16Array]", X = "[object Uint32Array]", rt = /[\\^$.*+?()[\]{}|]/g, et = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, dt = {};
  dt[L] = dt[A] = dt[D] = dt[I] = dt[w] = dt[B] = dt[j] = dt[k] = dt[X] = !0, dt[o] = dt[l] = dt[T] = dt[d] = dt[M] = dt[u] = dt[c] = dt[h] = dt[g] = dt[m] = dt[y] = dt[C] = dt[x] = dt[b] = dt[O] = !1;
  var vt = typeof It == "object" && It && It.Object === Object && It, bt = typeof self == "object" && self && self.Object === Object && self, it = vt || bt || Function("return this")(), R = t && !t.nodeType && t, V = R && !0 && e && !e.nodeType && e, tt = V && V.exports === R, Y = tt && vt.process, W = function() {
    try {
      var H = V && V.require && V.require("util").types;
      return H || Y && Y.binding && Y.binding("util");
    } catch {
    }
  }(), z = W && W.isTypedArray;
  function at(H, st, ut) {
    switch (ut.length) {
      case 0:
        return H.call(st);
      case 1:
        return H.call(st, ut[0]);
      case 2:
        return H.call(st, ut[0], ut[1]);
      case 3:
        return H.call(st, ut[0], ut[1], ut[2]);
    }
    return H.apply(st, ut);
  }
  function ct(H, st) {
    for (var ut = -1, wt = Array(H); ++ut < H; )
      wt[ut] = st(ut);
    return wt;
  }
  function Mt(H) {
    return function(st) {
      return H(st);
    };
  }
  function N(H, st) {
    return H == null ? void 0 : H[st];
  }
  function S(H, st) {
    return function(ut) {
      return H(st(ut));
    };
  }
  var _ = Array.prototype, F = Function.prototype, G = Object.prototype, nt = it["__core-js_shared__"], lt = F.toString, yt = G.hasOwnProperty, Lt = function() {
    var H = /[^.]+$/.exec(nt && nt.keys && nt.keys.IE_PROTO || "");
    return H ? "Symbol(src)_1." + H : "";
  }(), Ft = G.toString, Jt = lt.call(Object), J = RegExp(
    "^" + lt.call(yt).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ft = tt ? it.Buffer : void 0, Ct = it.Symbol, St = it.Uint8Array, Tt = ft ? ft.allocUnsafe : void 0, kt = S(Object.getPrototypeOf, Object), fe = Object.create, Se = G.propertyIsEnumerable, Me = _.splice, xe = Ct ? Ct.toStringTag : void 0, We = function() {
    try {
      var H = Ms(Object, "defineProperty");
      return H({}, "", {}), H;
    } catch {
    }
  }(), bn = ft ? ft.isBuffer : void 0, Ye = Math.max, Hn = Date.now, pn = Ms(it, "Map"), Ne = Ms(Object, "create"), mn = function() {
    function H() {
    }
    return function(st) {
      if (!_s(st))
        return {};
      if (fe)
        return fe(st);
      H.prototype = st;
      var ut = new H();
      return H.prototype = void 0, ut;
    };
  }();
  function gn(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function we() {
    this.__data__ = Ne ? Ne(null) : {}, this.size = 0;
  }
  function vn(H) {
    var st = this.has(H) && delete this.__data__[H];
    return this.size -= st ? 1 : 0, st;
  }
  function ze(H) {
    var st = this.__data__;
    if (Ne) {
      var ut = st[H];
      return ut === s ? void 0 : ut;
    }
    return yt.call(st, H) ? st[H] : void 0;
  }
  function Tn(H) {
    var st = this.__data__;
    return Ne ? st[H] !== void 0 : yt.call(st, H);
  }
  function tn(H, st) {
    var ut = this.__data__;
    return this.size += this.has(H) ? 0 : 1, ut[H] = Ne && st === void 0 ? s : st, this;
  }
  gn.prototype.clear = we, gn.prototype.delete = vn, gn.prototype.get = ze, gn.prototype.has = Tn, gn.prototype.set = tn;
  function ae(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function gi() {
    this.__data__ = [], this.size = 0;
  }
  function Xe(H) {
    var st = this.__data__, ut = Nn(st, H);
    if (ut < 0)
      return !1;
    var wt = st.length - 1;
    return ut == wt ? st.pop() : Me.call(st, ut, 1), --this.size, !0;
  }
  function an(H) {
    var st = this.__data__, ut = Nn(st, H);
    return ut < 0 ? void 0 : st[ut][1];
  }
  function $e(H) {
    return Nn(this.__data__, H) > -1;
  }
  function Vn(H, st) {
    var ut = this.__data__, wt = Nn(ut, H);
    return wt < 0 ? (++this.size, ut.push([H, st])) : ut[wt][1] = st, this;
  }
  ae.prototype.clear = gi, ae.prototype.delete = Xe, ae.prototype.get = an, ae.prototype.has = $e, ae.prototype.set = Vn;
  function ii(H) {
    var st = -1, ut = H == null ? 0 : H.length;
    for (this.clear(); ++st < ut; ) {
      var wt = H[st];
      this.set(wt[0], wt[1]);
    }
  }
  function da() {
    this.size = 0, this.__data__ = {
      hash: new gn(),
      map: new (pn || ae)(),
      string: new gn()
    };
  }
  function Os(H) {
    var st = Zn(this, H).delete(H);
    return this.size -= st ? 1 : 0, st;
  }
  function Ps(H) {
    return Zn(this, H).get(H);
  }
  function Hr(H) {
    return Zn(this, H).has(H);
  }
  function Fn(H, st) {
    var ut = Zn(this, H), wt = ut.size;
    return ut.set(H, st), this.size += ut.size == wt ? 0 : 1, this;
  }
  ii.prototype.clear = da, ii.prototype.delete = Os, ii.prototype.get = Ps, ii.prototype.has = Hr, ii.prototype.set = Fn;
  function vi(H) {
    var st = this.__data__ = new ae(H);
    this.size = st.size;
  }
  function Yr() {
    this.__data__ = new ae(), this.size = 0;
  }
  function Ve(H) {
    var st = this.__data__, ut = st.delete(H);
    return this.size = st.size, ut;
  }
  function yi(H) {
    return this.__data__.get(H);
  }
  function Ei(H) {
    return this.__data__.has(H);
  }
  function Ze(H, st) {
    var ut = this.__data__;
    if (ut instanceof ae) {
      var wt = ut.__data__;
      if (!pn || wt.length < n - 1)
        return wt.push([H, st]), this.size = ++ut.size, this;
      ut = this.__data__ = new ii(wt);
    }
    return ut.set(H, st), this.size = ut.size, this;
  }
  vi.prototype.clear = Yr, vi.prototype.delete = Ve, vi.prototype.get = yi, vi.prototype.has = Ei, vi.prototype.set = Ze;
  function Yi(H, st) {
    var ut = ur(H), wt = !ut && es(H), pe = !ut && !wt && lo(H), be = !ut && !wt && !pe && ch(H), je = ut || wt || pe || be, ge = je ? ct(H.length, String) : [], Ke = ge.length;
    for (var Ri in H)
      (st || yt.call(H, Ri)) && !(je && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ri == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      pe && (Ri == "offset" || Ri == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      be && (Ri == "buffer" || Ri == "byteLength" || Ri == "byteOffset") || // Skip index properties.
      Zi(Ri, Ke))) && ge.push(Ri);
    return ge;
  }
  function Pr(H, st, ut) {
    (ut !== void 0 && !Jn(H[st], ut) || ut === void 0 && !(st in H)) && On(H, st, ut);
  }
  function Ss(H, st, ut) {
    var wt = H[st];
    (!(yt.call(H, st) && Jn(wt, ut)) || ut === void 0 && !(st in H)) && On(H, st, ut);
  }
  function Nn(H, st) {
    for (var ut = H.length; ut--; )
      if (Jn(H[ut][0], st))
        return ut;
    return -1;
  }
  function On(H, st, ut) {
    st == "__proto__" && We ? We(H, st, {
      configurable: !0,
      enumerable: !0,
      value: ut,
      writable: !0
    }) : H[st] = ut;
  }
  var ri = _e();
  function An(H) {
    return H == null ? H === void 0 ? P : v : xe && xe in Object(H) ? Qr(H) : Et(H);
  }
  function jn(H) {
    return fa(H) && An(H) == o;
  }
  function Je(H) {
    if (!_s(H) || K(H))
      return !1;
    var st = Au(H) ? J : et;
    return st.test(En(H));
  }
  function Yn(H) {
    return fa(H) && lh(H.length) && !!dt[An(H)];
  }
  function si(H) {
    if (!_s(H))
      return ot(H);
    var st = q(H), ut = [];
    for (var wt in H)
      wt == "constructor" && (st || !yt.call(H, wt)) || ut.push(wt);
    return ut;
  }
  function Sr(H, st, ut, wt, pe) {
    H !== st && ri(st, function(be, je) {
      if (pe || (pe = new vi()), _s(be))
        Xr(H, st, je, ut, Sr, wt, pe);
      else {
        var ge = wt ? wt(ie(H, je), be, je + "", H, st, pe) : void 0;
        ge === void 0 && (ge = be), Pr(H, je, ge);
      }
    }, ns);
  }
  function Xr(H, st, ut, wt, pe, be, je) {
    var ge = ie(H, ut), Ke = ie(st, ut), Ri = je.get(Ke);
    if (Ri) {
      Pr(H, ut, Ri);
      return;
    }
    var xi = be ? be(ge, Ke, ut + "", H, st, je) : void 0, is = xi === void 0;
    if (is) {
      var wu = ur(Ke), Vu = !wu && lo(Ke), dh = !wu && !Vu && ch(Ke);
      xi = Ke, wu || Vu || dh ? ur(ge) ? xi = ge : oh(ge) ? xi = Mr(ge) : Vu ? (is = !1, xi = Ci(Ke, !0)) : dh ? (is = !1, xi = Jr(Ke, !0)) : xi = [] : uh(Ke) || es(Ke) ? (xi = ge, es(ge) ? xi = al(ge) : (!_s(ge) || Au(ge)) && (xi = qr(Ke))) : is = !1;
    }
    is && (je.set(Ke, xi), pe(xi, Ke, wt, be, je), je.delete(Ke)), Pr(H, ut, xi);
  }
  function lr(H, st) {
    return yn(Rt(H, st, Ru), H + "");
  }
  var Xn = We ? function(H, st) {
    return We(H, "toString", {
      configurable: !0,
      enumerable: !1,
      value: hh(st),
      writable: !0
    });
  } : Ru;
  function Ci(H, st) {
    if (st)
      return H.slice();
    var ut = H.length, wt = Tt ? Tt(ut) : new H.constructor(ut);
    return H.copy(wt), wt;
  }
  function Zr(H) {
    var st = new H.constructor(H.byteLength);
    return new St(st).set(new St(H)), st;
  }
  function Jr(H, st) {
    var ut = st ? Zr(H.buffer) : H.buffer;
    return new H.constructor(ut, H.byteOffset, H.length);
  }
  function Mr(H, st) {
    var ut = -1, wt = H.length;
    for (st || (st = Array(wt)); ++ut < wt; )
      st[ut] = H[ut];
    return st;
  }
  function Xi(H, st, ut, wt) {
    var pe = !ut;
    ut || (ut = {});
    for (var be = -1, je = st.length; ++be < je; ) {
      var ge = st[be], Ke = wt ? wt(ut[ge], H[ge], ge, ut, H) : void 0;
      Ke === void 0 && (Ke = H[ge]), pe ? On(ut, ge, Ke) : Ss(ut, ge, Ke);
    }
    return ut;
  }
  function Li(H) {
    return lr(function(st, ut) {
      var wt = -1, pe = ut.length, be = pe > 1 ? ut[pe - 1] : void 0, je = pe > 2 ? ut[2] : void 0;
      for (be = H.length > 3 && typeof be == "function" ? (pe--, be) : void 0, je && ts(ut[0], ut[1], je) && (be = pe < 3 ? void 0 : be, pe = 1), st = Object(st); ++wt < pe; ) {
        var ge = ut[wt];
        ge && H(st, ge, wt, be);
      }
      return st;
    });
  }
  function _e(H) {
    return function(st, ut, wt) {
      for (var pe = -1, be = Object(st), je = wt(st), ge = je.length; ge--; ) {
        var Ke = je[H ? ge : ++pe];
        if (ut(be[Ke], Ke, be) === !1)
          break;
      }
      return st;
    };
  }
  function Zn(H, st) {
    var ut = H.__data__;
    return $(st) ? ut[typeof st == "string" ? "string" : "hash"] : ut.map;
  }
  function Ms(H, st) {
    var ut = N(H, st);
    return Je(ut) ? ut : void 0;
  }
  function Qr(H) {
    var st = yt.call(H, xe), ut = H[xe];
    try {
      H[xe] = void 0;
      var wt = !0;
    } catch {
    }
    var pe = Ft.call(H);
    return wt && (st ? H[xe] = ut : delete H[xe]), pe;
  }
  function qr(H) {
    return typeof H.constructor == "function" && !q(H) ? mn(kt(H)) : {};
  }
  function Zi(H, st) {
    var ut = typeof H;
    return st = st ?? a, !!st && (ut == "number" || ut != "symbol" && Z.test(H)) && H > -1 && H % 1 == 0 && H < st;
  }
  function ts(H, st, ut) {
    if (!_s(ut))
      return !1;
    var wt = typeof st;
    return (wt == "number" ? Du(ut) && Zi(st, ut.length) : wt == "string" && st in ut) ? Jn(ut[st], H) : !1;
  }
  function $(H) {
    var st = typeof H;
    return st == "string" || st == "number" || st == "symbol" || st == "boolean" ? H !== "__proto__" : H === null;
  }
  function K(H) {
    return !!Lt && Lt in H;
  }
  function q(H) {
    var st = H && H.constructor, ut = typeof st == "function" && st.prototype || G;
    return H === ut;
  }
  function ot(H) {
    var st = [];
    if (H != null)
      for (var ut in Object(H))
        st.push(ut);
    return st;
  }
  function Et(H) {
    return Ft.call(H);
  }
  function Rt(H, st, ut) {
    return st = Ye(st === void 0 ? H.length - 1 : st, 0), function() {
      for (var wt = arguments, pe = -1, be = Ye(wt.length - st, 0), je = Array(be); ++pe < be; )
        je[pe] = wt[st + pe];
      pe = -1;
      for (var ge = Array(st + 1); ++pe < st; )
        ge[pe] = wt[pe];
      return ge[st] = ut(je), at(H, this, ge);
    };
  }
  function ie(H, st) {
    if (!(st === "constructor" && typeof H[st] == "function") && st != "__proto__")
      return H[st];
  }
  var yn = Pn(Xn);
  function Pn(H) {
    var st = 0, ut = 0;
    return function() {
      var wt = Hn(), pe = i - (wt - ut);
      if (ut = wt, pe > 0) {
        if (++st >= r)
          return arguments[0];
      } else
        st = 0;
      return H.apply(void 0, arguments);
    };
  }
  function En(H) {
    if (H != null) {
      try {
        return lt.call(H);
      } catch {
      }
      try {
        return H + "";
      } catch {
      }
    }
    return "";
  }
  function Jn(H, st) {
    return H === st || H !== H && st !== st;
  }
  var es = jn(function() {
    return arguments;
  }()) ? jn : function(H) {
    return fa(H) && yt.call(H, "callee") && !Se.call(H, "callee");
  }, ur = Array.isArray;
  function Du(H) {
    return H != null && lh(H.length) && !Au(H);
  }
  function oh(H) {
    return fa(H) && Du(H);
  }
  var lo = bn || Is;
  function Au(H) {
    if (!_s(H))
      return !1;
    var st = An(H);
    return st == h || st == p || st == f || st == E;
  }
  function lh(H) {
    return typeof H == "number" && H > -1 && H % 1 == 0 && H <= a;
  }
  function _s(H) {
    var st = typeof H;
    return H != null && (st == "object" || st == "function");
  }
  function fa(H) {
    return H != null && typeof H == "object";
  }
  function uh(H) {
    if (!fa(H) || An(H) != y)
      return !1;
    var st = kt(H);
    if (st === null)
      return !0;
    var ut = yt.call(st, "constructor") && st.constructor;
    return typeof ut == "function" && ut instanceof ut && lt.call(ut) == Jt;
  }
  var ch = z ? Mt(z) : Yn;
  function al(H) {
    return Xi(H, ns(H));
  }
  function ns(H) {
    return Du(H) ? Yi(H, !0) : si(H);
  }
  var Lu = Li(function(H, st, ut) {
    Sr(H, st, ut);
  });
  function hh(H) {
    return function() {
      return H;
    };
  }
  function Ru(H) {
    return H;
  }
  function Is() {
    return !1;
  }
  e.exports = Lu;
})(pf, pf.exports);
var YG = pf.exports;
const Bc = /* @__PURE__ */ nl(YG);
var XG = 1 / 0, ZG = "[object Symbol]", JG = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, QG = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, z_ = "\\ud800-\\udfff", qG = "\\u0300-\\u036f\\ufe20-\\ufe23", tk = "\\u20d0-\\u20f0", K_ = "\\u2700-\\u27bf", G_ = "a-z\\xdf-\\xf6\\xf8-\\xff", ek = "\\xac\\xb1\\xd7\\xf7", nk = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ik = "\\u2000-\\u206f", rk = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", k_ = "A-Z\\xc0-\\xd6\\xd8-\\xde", sk = "\\ufe0e\\ufe0f", H_ = ek + nk + ik + rk, bE = "[']", UT = "[" + H_ + "]", Y_ = "[" + qG + tk + "]", X_ = "\\d+", ak = "[" + K_ + "]", Z_ = "[" + G_ + "]", J_ = "[^" + z_ + H_ + X_ + K_ + G_ + k_ + "]", ok = "\\ud83c[\\udffb-\\udfff]", lk = "(?:" + Y_ + "|" + ok + ")", uk = "[^" + z_ + "]", Q_ = "(?:\\ud83c[\\udde6-\\uddff]){2}", q_ = "[\\ud800-\\udbff][\\udc00-\\udfff]", Tl = "[" + k_ + "]", ck = "\\u200d", WT = "(?:" + Z_ + "|" + J_ + ")", hk = "(?:" + Tl + "|" + J_ + ")", zT = "(?:" + bE + "(?:d|ll|m|re|s|t|ve))?", KT = "(?:" + bE + "(?:D|LL|M|RE|S|T|VE))?", tI = lk + "?", eI = "[" + sk + "]?", dk = "(?:" + ck + "(?:" + [uk, Q_, q_].join("|") + ")" + eI + tI + ")*", fk = eI + tI + dk, pk = "(?:" + [ak, Q_, q_].join("|") + ")" + fk, mk = RegExp(bE, "g"), gk = RegExp(Y_, "g"), vk = RegExp([
  Tl + "?" + Z_ + "+" + zT + "(?=" + [UT, Tl, "$"].join("|") + ")",
  hk + "+" + KT + "(?=" + [UT, Tl + WT, "$"].join("|") + ")",
  Tl + "?" + WT + "+" + zT,
  Tl + "+" + KT,
  X_,
  pk
].join("|"), "g"), yk = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ek = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "ss"
}, Ck = typeof It == "object" && It && It.Object === Object && It, xk = typeof self == "object" && self && self.Object === Object && self, bk = Ck || xk || Function("return this")();
function Tk(e, t, n, s) {
  var r = -1, i = e ? e.length : 0;
  for (s && i && (n = e[++r]); ++r < i; )
    n = t(n, e[r], r, e);
  return n;
}
function Ok(e) {
  return e.match(JG) || [];
}
function Pk(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var Sk = Pk(Ek);
function Mk(e) {
  return yk.test(e);
}
function _k(e) {
  return e.match(vk) || [];
}
var Ik = Object.prototype, Dk = Ik.toString, GT = bk.Symbol, kT = GT ? GT.prototype : void 0, HT = kT ? kT.toString : void 0;
function Ak(e) {
  if (typeof e == "string")
    return e;
  if (wk(e))
    return HT ? HT.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -XG ? "-0" : t;
}
function Lk(e) {
  return function(t) {
    return Tk(Fk(Vk(t).replace(mk, "")), e, "");
  };
}
function Rk(e) {
  return !!e && typeof e == "object";
}
function wk(e) {
  return typeof e == "symbol" || Rk(e) && Dk.call(e) == ZG;
}
function nI(e) {
  return e == null ? "" : Ak(e);
}
function Vk(e) {
  return e = nI(e), e && e.replace(QG, Sk).replace(gk, "");
}
var Bk = Lk(function(e, t, n) {
  return e + (n ? "-" : "") + t.toLowerCase();
});
function Fk(e, t, n) {
  return e = nI(e), t = n ? void 0 : t, t === void 0 ? Mk(e) ? _k(e) : Ok(e) : e.match(t) || [];
}
var Nk = Bk;
const jk = /* @__PURE__ */ nl(Nk);
$t.use(W_);
const YT = {
  theme: {
    themes: {
      light: {
        primary: "#003064",
        primaryContrast: "#FFFFFF",
        secondary: "#FFFFFF",
        secondaryContrast: "#003064"
      }
    }
  },
  icons: {
    iconfont: "fa"
  }
};
function $k(e = {}) {
  var s, r;
  const t = Bc({}, YT, e);
  return Object.entries(
    (r = (s = t.theme) == null ? void 0 : s.themes) == null ? void 0 : r.light
  ).forEach(
    ([i, a]) => document.documentElement.style.setProperty(
      "--polar-" + jk(i),
      a
    )
  ), new W_(Bc({}, YT, e));
}
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function Uk(e) {
  var t = Number(e.version.split(".")[0]);
  if (t >= 2)
    e.mixin({ beforeCreate: s });
  else {
    var n = e.prototype._init;
    e.prototype._init = function(r) {
      r === void 0 && (r = {}), r.init = r.init ? [s].concat(r.init) : s, n.call(this, r);
    };
  }
  function s() {
    var r = this.$options;
    r.store ? this.$store = typeof r.store == "function" ? r.store() : r.store : r.parent && r.parent.$store && (this.$store = r.parent.$store);
  }
}
var Wk = typeof window < "u" ? window : typeof global < "u" ? global : {}, fl = Wk.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function zk(e) {
  fl && (e._devtoolHook = fl, fl.emit("vuex:init", e), fl.on("vuex:travel-to-state", function(t) {
    e.replaceState(t);
  }), e.subscribe(function(t, n) {
    fl.emit("vuex:mutation", t, n);
  }, { prepend: !0 }), e.subscribeAction(function(t, n) {
    fl.emit("vuex:action", t, n);
  }, { prepend: !0 }));
}
function Kk(e, t) {
  return e.filter(t)[0];
}
function Uv(e, t) {
  if (t === void 0 && (t = []), e === null || typeof e != "object")
    return e;
  var n = Kk(t, function(r) {
    return r.original === e;
  });
  if (n)
    return n.copy;
  var s = Array.isArray(e) ? [] : {};
  return t.push({
    original: e,
    copy: s
  }), Object.keys(e).forEach(function(r) {
    s[r] = Uv(e[r], t);
  }), s;
}
function Iu(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function iI(e) {
  return e !== null && typeof e == "object";
}
function Gk(e) {
  return e && typeof e.then == "function";
}
function kk(e, t) {
  return function() {
    return e(t);
  };
}
var Kr = function(t, n) {
  this.runtime = n, this._children = /* @__PURE__ */ Object.create(null), this._rawModule = t;
  var s = t.state;
  this.state = (typeof s == "function" ? s() : s) || {};
}, rI = { namespaced: { configurable: !0 } };
rI.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Kr.prototype.addChild = function(t, n) {
  this._children[t] = n;
};
Kr.prototype.removeChild = function(t) {
  delete this._children[t];
};
Kr.prototype.getChild = function(t) {
  return this._children[t];
};
Kr.prototype.hasChild = function(t) {
  return t in this._children;
};
Kr.prototype.update = function(t) {
  this._rawModule.namespaced = t.namespaced, t.actions && (this._rawModule.actions = t.actions), t.mutations && (this._rawModule.mutations = t.mutations), t.getters && (this._rawModule.getters = t.getters);
};
Kr.prototype.forEachChild = function(t) {
  Iu(this._children, t);
};
Kr.prototype.forEachGetter = function(t) {
  this._rawModule.getters && Iu(this._rawModule.getters, t);
};
Kr.prototype.forEachAction = function(t) {
  this._rawModule.actions && Iu(this._rawModule.actions, t);
};
Kr.prototype.forEachMutation = function(t) {
  this._rawModule.mutations && Iu(this._rawModule.mutations, t);
};
Object.defineProperties(Kr.prototype, rI);
var sl = function(t) {
  this.register([], t, !1);
};
sl.prototype.get = function(t) {
  return t.reduce(function(n, s) {
    return n.getChild(s);
  }, this.root);
};
sl.prototype.getNamespace = function(t) {
  var n = this.root;
  return t.reduce(function(s, r) {
    return n = n.getChild(r), s + (n.namespaced ? r + "/" : "");
  }, "");
};
sl.prototype.update = function(t) {
  sI([], this.root, t);
};
sl.prototype.register = function(t, n, s) {
  var r = this;
  s === void 0 && (s = !0);
  var i = new Kr(n, s);
  if (t.length === 0)
    this.root = i;
  else {
    var a = this.get(t.slice(0, -1));
    a.addChild(t[t.length - 1], i);
  }
  n.modules && Iu(n.modules, function(o, l) {
    r.register(t.concat(l), o, s);
  });
};
sl.prototype.unregister = function(t) {
  var n = this.get(t.slice(0, -1)), s = t[t.length - 1], r = n.getChild(s);
  r && r.runtime && n.removeChild(s);
};
sl.prototype.isRegistered = function(t) {
  var n = this.get(t.slice(0, -1)), s = t[t.length - 1];
  return n ? n.hasChild(s) : !1;
};
function sI(e, t, n) {
  if (t.update(n), n.modules)
    for (var s in n.modules) {
      if (!t.getChild(s))
        return;
      sI(
        e.concat(s),
        t.getChild(s),
        n.modules[s]
      );
    }
}
var Bi, ki = function(t) {
  var n = this;
  t === void 0 && (t = {}), !Bi && typeof window < "u" && window.Vue && lI(window.Vue);
  var s = t.plugins;
  s === void 0 && (s = []);
  var r = t.strict;
  r === void 0 && (r = !1), this._committing = !1, this._actions = /* @__PURE__ */ Object.create(null), this._actionSubscribers = [], this._mutations = /* @__PURE__ */ Object.create(null), this._wrappedGetters = /* @__PURE__ */ Object.create(null), this._modules = new sl(t), this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null), this._subscribers = [], this._watcherVM = new Bi(), this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var i = this, a = this, o = a.dispatch, l = a.commit;
  this.dispatch = function(c, h) {
    return o.call(i, c, h);
  }, this.commit = function(c, h, p) {
    return l.call(i, c, h, p);
  }, this.strict = r;
  var f = this._modules.root.state;
  up(this, f, [], this._modules.root), OE(this, f), s.forEach(function(u) {
    return u(n);
  });
  var d = t.devtools !== void 0 ? t.devtools : Bi.config.devtools;
  d && zk(this);
}, TE = { state: { configurable: !0 } };
TE.state.get = function() {
  return this._vm._data.$$state;
};
TE.state.set = function(e) {
};
ki.prototype.commit = function(t, n, s) {
  var r = this, i = mf(t, n, s), a = i.type, o = i.payload, l = { type: a, payload: o }, f = this._mutations[a];
  f && (this._withCommit(function() {
    f.forEach(function(u) {
      u(o);
    });
  }), this._subscribers.slice().forEach(function(d) {
    return d(l, r.state);
  }));
};
ki.prototype.dispatch = function(t, n) {
  var s = this, r = mf(t, n), i = r.type, a = r.payload, o = { type: i, payload: a }, l = this._actions[i];
  if (l) {
    try {
      this._actionSubscribers.slice().filter(function(d) {
        return d.before;
      }).forEach(function(d) {
        return d.before(o, s.state);
      });
    } catch {
    }
    var f = l.length > 1 ? Promise.all(l.map(function(d) {
      return d(a);
    })) : l[0](a);
    return new Promise(function(d, u) {
      f.then(function(c) {
        try {
          s._actionSubscribers.filter(function(h) {
            return h.after;
          }).forEach(function(h) {
            return h.after(o, s.state);
          });
        } catch {
        }
        d(c);
      }, function(c) {
        try {
          s._actionSubscribers.filter(function(h) {
            return h.error;
          }).forEach(function(h) {
            return h.error(o, s.state, c);
          });
        } catch {
        }
        u(c);
      });
    });
  }
};
ki.prototype.subscribe = function(t, n) {
  return aI(t, this._subscribers, n);
};
ki.prototype.subscribeAction = function(t, n) {
  var s = typeof t == "function" ? { before: t } : t;
  return aI(s, this._actionSubscribers, n);
};
ki.prototype.watch = function(t, n, s) {
  var r = this;
  return this._watcherVM.$watch(function() {
    return t(r.state, r.getters);
  }, n, s);
};
ki.prototype.replaceState = function(t) {
  var n = this;
  this._withCommit(function() {
    n._vm._data.$$state = t;
  });
};
ki.prototype.registerModule = function(t, n, s) {
  s === void 0 && (s = {}), typeof t == "string" && (t = [t]), this._modules.register(t, n), up(this, this.state, t, this._modules.get(t), s.preserveState), OE(this, this.state);
};
ki.prototype.unregisterModule = function(t) {
  var n = this;
  typeof t == "string" && (t = [t]), this._modules.unregister(t), this._withCommit(function() {
    var s = PE(n.state, t.slice(0, -1));
    Bi.delete(s, t[t.length - 1]);
  }), oI(this);
};
ki.prototype.hasModule = function(t) {
  return typeof t == "string" && (t = [t]), this._modules.isRegistered(t);
};
ki.prototype.hotUpdate = function(t) {
  this._modules.update(t), oI(this, !0);
};
ki.prototype._withCommit = function(t) {
  var n = this._committing;
  this._committing = !0, t(), this._committing = n;
};
Object.defineProperties(ki.prototype, TE);
function aI(e, t, n) {
  return t.indexOf(e) < 0 && (n && n.prepend ? t.unshift(e) : t.push(e)), function() {
    var s = t.indexOf(e);
    s > -1 && t.splice(s, 1);
  };
}
function oI(e, t) {
  e._actions = /* @__PURE__ */ Object.create(null), e._mutations = /* @__PURE__ */ Object.create(null), e._wrappedGetters = /* @__PURE__ */ Object.create(null), e._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var n = e.state;
  up(e, n, [], e._modules.root, !0), OE(e, n, t);
}
function OE(e, t, n) {
  var s = e._vm;
  e.getters = {}, e._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var r = e._wrappedGetters, i = {};
  Iu(r, function(o, l) {
    i[l] = kk(o, e), Object.defineProperty(e.getters, l, {
      get: function() {
        return e._vm[l];
      },
      enumerable: !0
      // for local getters
    });
  });
  var a = Bi.config.silent;
  Bi.config.silent = !0, e._vm = new Bi({
    data: {
      $$state: t
    },
    computed: i
  }), Bi.config.silent = a, e.strict && Qk(e), s && (n && e._withCommit(function() {
    s._data.$$state = null;
  }), Bi.nextTick(function() {
    return s.$destroy();
  }));
}
function up(e, t, n, s, r) {
  var i = !n.length, a = e._modules.getNamespace(n);
  if (s.namespaced && (e._modulesNamespaceMap[a], e._modulesNamespaceMap[a] = s), !i && !r) {
    var o = PE(t, n.slice(0, -1)), l = n[n.length - 1];
    e._withCommit(function() {
      Bi.set(o, l, s.state);
    });
  }
  var f = s.context = Hk(e, a, n);
  s.forEachMutation(function(d, u) {
    var c = a + u;
    Xk(e, c, d, f);
  }), s.forEachAction(function(d, u) {
    var c = d.root ? u : a + u, h = d.handler || d;
    Zk(e, c, h, f);
  }), s.forEachGetter(function(d, u) {
    var c = a + u;
    Jk(e, c, d, f);
  }), s.forEachChild(function(d, u) {
    up(e, t, n.concat(u), d, r);
  });
}
function Hk(e, t, n) {
  var s = t === "", r = {
    dispatch: s ? e.dispatch : function(i, a, o) {
      var l = mf(i, a, o), f = l.payload, d = l.options, u = l.type;
      return (!d || !d.root) && (u = t + u), e.dispatch(u, f);
    },
    commit: s ? e.commit : function(i, a, o) {
      var l = mf(i, a, o), f = l.payload, d = l.options, u = l.type;
      (!d || !d.root) && (u = t + u), e.commit(u, f, d);
    }
  };
  return Object.defineProperties(r, {
    getters: {
      get: s ? function() {
        return e.getters;
      } : function() {
        return Yk(e, t);
      }
    },
    state: {
      get: function() {
        return PE(e.state, n);
      }
    }
  }), r;
}
function Yk(e, t) {
  if (!e._makeLocalGettersCache[t]) {
    var n = {}, s = t.length;
    Object.keys(e.getters).forEach(function(r) {
      if (r.slice(0, s) === t) {
        var i = r.slice(s);
        Object.defineProperty(n, i, {
          get: function() {
            return e.getters[r];
          },
          enumerable: !0
        });
      }
    }), e._makeLocalGettersCache[t] = n;
  }
  return e._makeLocalGettersCache[t];
}
function Xk(e, t, n, s) {
  var r = e._mutations[t] || (e._mutations[t] = []);
  r.push(function(a) {
    n.call(e, s.state, a);
  });
}
function Zk(e, t, n, s) {
  var r = e._actions[t] || (e._actions[t] = []);
  r.push(function(a) {
    var o = n.call(e, {
      dispatch: s.dispatch,
      commit: s.commit,
      getters: s.getters,
      state: s.state,
      rootGetters: e.getters,
      rootState: e.state
    }, a);
    return Gk(o) || (o = Promise.resolve(o)), e._devtoolHook ? o.catch(function(l) {
      throw e._devtoolHook.emit("vuex:error", l), l;
    }) : o;
  });
}
function Jk(e, t, n, s) {
  e._wrappedGetters[t] || (e._wrappedGetters[t] = function(i) {
    return n(
      s.state,
      // local state
      s.getters,
      // local getters
      i.state,
      // root state
      i.getters
      // root getters
    );
  });
}
function Qk(e) {
  e._vm.$watch(function() {
    return this._data.$$state;
  }, function() {
  }, { deep: !0, sync: !0 });
}
function PE(e, t) {
  return t.reduce(function(n, s) {
    return n[s];
  }, e);
}
function mf(e, t, n) {
  return iI(e) && e.type && (n = t, t = e, e = e.type), { type: e, payload: t, options: n };
}
function lI(e) {
  Bi && e === Bi || (Bi = e, Uk(Bi));
}
var uI = hp(function(e, t) {
  var n = {};
  return cp(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      var o = this.$store.state, l = this.$store.getters;
      if (e) {
        var f = dp(this.$store, "mapState", e);
        if (!f)
          return;
        o = f.context.state, l = f.context.getters;
      }
      return typeof i == "function" ? i.call(this, o, l) : o[i];
    }, n[r].vuex = !0;
  }), n;
}), or = hp(function(e, t) {
  var n = {};
  return cp(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      for (var o = [], l = arguments.length; l--; )
        o[l] = arguments[l];
      var f = this.$store.commit;
      if (e) {
        var d = dp(this.$store, "mapMutations", e);
        if (!d)
          return;
        f = d.context.commit;
      }
      return typeof i == "function" ? i.apply(this, [f].concat(o)) : f.apply(this.$store, [i].concat(o));
    };
  }), n;
}), ee = hp(function(e, t) {
  var n = {};
  return cp(t).forEach(function(s) {
    var r = s.key, i = s.val;
    i = e + i, n[r] = function() {
      if (!(e && !dp(this.$store, "mapGetters", e)))
        return this.$store.getters[i];
    }, n[r].vuex = !0;
  }), n;
}), mi = hp(function(e, t) {
  var n = {};
  return cp(t).forEach(function(s) {
    var r = s.key, i = s.val;
    n[r] = function() {
      for (var o = [], l = arguments.length; l--; )
        o[l] = arguments[l];
      var f = this.$store.dispatch;
      if (e) {
        var d = dp(this.$store, "mapActions", e);
        if (!d)
          return;
        f = d.context.dispatch;
      }
      return typeof i == "function" ? i.apply(this, [f].concat(o)) : f.apply(this.$store, [i].concat(o));
    };
  }), n;
}), qk = function(e) {
  return {
    mapState: uI.bind(null, e),
    mapGetters: ee.bind(null, e),
    mapMutations: or.bind(null, e),
    mapActions: mi.bind(null, e)
  };
};
function cp(e) {
  return t8(e) ? Array.isArray(e) ? e.map(function(t) {
    return { key: t, val: t };
  }) : Object.keys(e).map(function(t) {
    return { key: t, val: e[t] };
  }) : [];
}
function t8(e) {
  return Array.isArray(e) || iI(e);
}
function hp(e) {
  return function(t, n) {
    return typeof t != "string" ? (n = t, t = "") : t.charAt(t.length - 1) !== "/" && (t += "/"), e(t, n);
  };
}
function dp(e, t, n) {
  var s = e._modulesNamespaceMap[n];
  return s;
}
function e8(e) {
  e === void 0 && (e = {});
  var t = e.collapsed;
  t === void 0 && (t = !0);
  var n = e.filter;
  n === void 0 && (n = function(d, u, c) {
    return !0;
  });
  var s = e.transformer;
  s === void 0 && (s = function(d) {
    return d;
  });
  var r = e.mutationTransformer;
  r === void 0 && (r = function(d) {
    return d;
  });
  var i = e.actionFilter;
  i === void 0 && (i = function(d, u) {
    return !0;
  });
  var a = e.actionTransformer;
  a === void 0 && (a = function(d) {
    return d;
  });
  var o = e.logMutations;
  o === void 0 && (o = !0);
  var l = e.logActions;
  l === void 0 && (l = !0);
  var f = e.logger;
  return f === void 0 && (f = console), function(d) {
    var u = Uv(d.state);
    typeof f > "u" || (o && d.subscribe(function(c, h) {
      var p = Uv(h);
      if (n(c, u, p)) {
        var g = JT(), m = r(c), v = "mutation " + c.type + g;
        XT(f, v, t), f.log("%c prev state", "color: #9E9E9E; font-weight: bold", s(u)), f.log("%c mutation", "color: #03A9F4; font-weight: bold", m), f.log("%c next state", "color: #4CAF50; font-weight: bold", s(p)), ZT(f);
      }
      u = p;
    }), l && d.subscribeAction(function(c, h) {
      if (i(c, h)) {
        var p = JT(), g = a(c), m = "action " + c.type + p;
        XT(f, m, t), f.log("%c action", "color: #03A9F4; font-weight: bold", g), ZT(f);
      }
    }));
  };
}
function XT(e, t, n) {
  var s = n ? e.groupCollapsed : e.group;
  try {
    s.call(e, t);
  } catch {
    e.log(t);
  }
}
function ZT(e) {
  try {
    e.groupEnd();
  } catch {
    e.log(" log end ");
  }
}
function JT() {
  var e = /* @__PURE__ */ new Date();
  return " @ " + Hh(e.getHours(), 2) + ":" + Hh(e.getMinutes(), 2) + ":" + Hh(e.getSeconds(), 2) + "." + Hh(e.getMilliseconds(), 3);
}
function n8(e, t) {
  return new Array(t + 1).join(e);
}
function Hh(e, t) {
  return n8("0", t - e.toString().length) + e;
}
var i8 = {
  Store: ki,
  install: lI,
  version: "3.6.2",
  mapState: uI,
  mapMutations: or,
  mapGetters: ee,
  mapActions: mi,
  createNamespacedHelpers: qk,
  createLogger: e8
};
const r8 = i8;
function s8(e) {
  return `set${e[0].toUpperCase()}${e.slice(1)}`;
}
function Or(e) {
  return Object.keys(e).reduce((t, n) => ({
    ...t,
    [s8(n)]: (s, r) => {
      s[n] = r;
    }
  }), {});
}
function Hi(e) {
  return Object.keys(e).reduce((t, n) => ({
    ...t,
    [n]: (s) => s[n]
  }), {});
}
const Vl = () => {
};
function jr(e) {
  "@babel/helpers - typeof";
  return jr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jr(e);
}
function Gr(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function a8(e, t) {
  if (jr(e) !== "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var s = n.call(e, t || "default");
    if (jr(s) !== "object")
      return s;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cI(e) {
  var t = a8(e, "string");
  return jr(t) === "symbol" ? t : String(t);
}
function QT(e, t) {
  for (var n = 0; n < t.length; n++) {
    var s = t[n];
    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, cI(s.key), s);
  }
}
function kr(e, t, n) {
  return t && QT(e.prototype, t), n && QT(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Wa(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Wv(e, t) {
  return Wv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, r) {
    return s.__proto__ = r, s;
  }, Wv(e, t);
}
function fp(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Wv(e, t);
}
function ah(e, t) {
  if (t && (jr(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Wa(e);
}
function bs(e) {
  return bs = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, bs(e);
}
function oo(e, t, n) {
  return t = cI(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function o8(e) {
  if (Array.isArray(e))
    return e;
}
function l8(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function qT(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, s = new Array(t); n < t; n++)
    s[n] = e[n];
  return s;
}
function u8(e, t) {
  if (e) {
    if (typeof e == "string")
      return qT(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return qT(e, t);
  }
}
function c8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function h8(e) {
  return o8(e) || l8(e) || u8(e) || c8();
}
function tO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function eO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
var d8 = {
  type: "logger",
  log: function(t) {
    this.output("log", t);
  },
  warn: function(t) {
    this.output("warn", t);
  },
  error: function(t) {
    this.output("error", t);
  },
  output: function(t, n) {
    console && console[t] && console[t].apply(console, n);
  }
}, f8 = function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Gr(this, e), this.init(t, n);
  }
  return kr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = s.prefix || "i18next:", this.logger = n || d8, this.options = s, this.debug = s.debug;
    }
  }, {
    key: "setDebug",
    value: function(n) {
      this.debug = n;
    }
  }, {
    key: "log",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++)
        s[r] = arguments[r];
      return this.forward(s, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(n, s, r, i) {
      return i && !this.debug ? null : (typeof n[0] == "string" && (n[0] = "".concat(r).concat(this.prefix, " ").concat(n[0])), this.logger[s](n));
    }
  }, {
    key: "create",
    value: function(n) {
      return new e(this.logger, eO(eO({}, {
        prefix: "".concat(this.prefix, ":").concat(n, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(n) {
      return n = n || this.options, n.prefix = n.prefix || this.prefix, new e(this.logger, n);
    }
  }]), e;
}(), ds = new f8(), ro = function() {
  function e() {
    Gr(this, e), this.observers = {};
  }
  return kr(e, [{
    key: "on",
    value: function(n, s) {
      var r = this;
      return n.split(" ").forEach(function(i) {
        r.observers[i] = r.observers[i] || [], r.observers[i].push(s);
      }), this;
    }
  }, {
    key: "off",
    value: function(n, s) {
      if (this.observers[n]) {
        if (!s) {
          delete this.observers[n];
          return;
        }
        this.observers[n] = this.observers[n].filter(function(r) {
          return r !== s;
        });
      }
    }
  }, {
    key: "emit",
    value: function(n) {
      for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
        r[i - 1] = arguments[i];
      if (this.observers[n]) {
        var a = [].concat(this.observers[n]);
        a.forEach(function(l) {
          l.apply(void 0, r);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(l) {
          l.apply(l, [n].concat(r));
        });
      }
    }
  }]), e;
}();
function Ku() {
  var e, t, n = new Promise(function(s, r) {
    e = s, t = r;
  });
  return n.resolve = e, n.reject = t, n;
}
function nO(e) {
  return e == null ? "" : "" + e;
}
function p8(e, t, n) {
  e.forEach(function(s) {
    t[s] && (n[s] = t[s]);
  });
}
function SE(e, t, n) {
  function s(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function r() {
    return !e || typeof e == "string";
  }
  for (var i = typeof t != "string" ? [].concat(t) : t.split("."); i.length > 1; ) {
    if (r())
      return {};
    var a = s(i.shift());
    !e[a] && n && (e[a] = new n()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {};
  }
  return r() ? {} : {
    obj: e,
    k: s(i.shift())
  };
}
function iO(e, t, n) {
  var s = SE(e, t, Object), r = s.obj, i = s.k;
  r[i] = n;
}
function m8(e, t, n, s) {
  var r = SE(e, t, Object), i = r.obj, a = r.k;
  i[a] = i[a] || [], s && (i[a] = i[a].concat(n)), s || i[a].push(n);
}
function gf(e, t) {
  var n = SE(e, t), s = n.obj, r = n.k;
  if (s)
    return s[r];
}
function rO(e, t, n) {
  var s = gf(e, n);
  return s !== void 0 ? s : gf(t, n);
}
function hI(e, t, n) {
  for (var s in t)
    s !== "__proto__" && s !== "constructor" && (s in e ? typeof e[s] == "string" || e[s] instanceof String || typeof t[s] == "string" || t[s] instanceof String ? n && (e[s] = t[s]) : hI(e[s], t[s], n) : e[s] = t[s]);
  return e;
}
function pl(e) {
  return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var g8 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function v8(e) {
  return typeof e == "string" ? e.replace(/[&<>"'\/]/g, function(t) {
    return g8[t];
  }) : e;
}
var pp = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, y8 = [" ", ",", "?", "!", ";"];
function E8(e, t, n) {
  t = t || "", n = n || "";
  var s = y8.filter(function(o) {
    return t.indexOf(o) < 0 && n.indexOf(o) < 0;
  });
  if (s.length === 0)
    return !0;
  var r = new RegExp("(".concat(s.map(function(o) {
    return o === "?" ? "\\?" : o;
  }).join("|"), ")")), i = !r.test(e);
  if (!i) {
    var a = e.indexOf(n);
    a > 0 && !r.test(e.substring(0, a)) && (i = !0);
  }
  return i;
}
function sO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Yh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function C8(e) {
  var t = x8();
  return function() {
    var s = bs(e), r;
    if (t) {
      var i = bs(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return ah(this, r);
  };
}
function x8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function dI(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (e) {
    if (e[t])
      return e[t];
    for (var s = t.split(n), r = e, i = 0; i < s.length; ++i) {
      if (!r || typeof r[s[i]] == "string" && i + 1 < s.length)
        return;
      if (r[s[i]] === void 0) {
        for (var a = 2, o = s.slice(i, i + a).join(n), l = r[o]; l === void 0 && s.length > i + a; )
          a++, o = s.slice(i, i + a).join(n), l = r[o];
        if (l === void 0)
          return;
        if (l === null)
          return null;
        if (t.endsWith(o)) {
          if (typeof l == "string")
            return l;
          if (o && typeof l[o] == "string")
            return l[o];
        }
        var f = s.slice(i + a).join(n);
        return f ? dI(l, f, n) : void 0;
      }
      r = r[s[i]];
    }
    return r;
  }
}
var b8 = function(e) {
  fp(n, e);
  var t = C8(n);
  function n(s) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return Gr(this, n), r = t.call(this), pp && ro.call(Wa(r)), r.data = s || {}, r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.options.ignoreJSONStructure === void 0 && (r.options.ignoreJSONStructure = !0), r;
  }
  return kr(n, [{
    key: "addNamespaces",
    value: function(r) {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }
  }, {
    key: "removeNamespaces",
    value: function(r) {
      var i = this.options.ns.indexOf(r);
      i > -1 && this.options.ns.splice(i, 1);
    }
  }, {
    key: "getResource",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, l = o.keySeparator !== void 0 ? o.keySeparator : this.options.keySeparator, f = o.ignoreJSONStructure !== void 0 ? o.ignoreJSONStructure : this.options.ignoreJSONStructure, d = [r, i];
      a && typeof a != "string" && (d = d.concat(a)), a && typeof a == "string" && (d = d.concat(l ? a.split(l) : a)), r.indexOf(".") > -1 && (d = r.split("."));
      var u = gf(this.data, d);
      return u || !f || typeof a != "string" ? u : dI(this.data && this.data[r] && this.data[r][i], a, l);
    }
  }, {
    key: "addResource",
    value: function(r, i, a, o) {
      var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, f = this.options.keySeparator;
      f === void 0 && (f = ".");
      var d = [r, i];
      a && (d = d.concat(f ? a.split(f) : a)), r.indexOf(".") > -1 && (d = r.split("."), o = i, i = d[1]), this.addNamespaces(i), iO(this.data, d, o), l.silent || this.emit("added", r, i, a, o);
    }
  }, {
    key: "addResources",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var l in a)
        (typeof a[l] == "string" || Object.prototype.toString.apply(a[l]) === "[object Array]") && this.addResource(r, i, l, a[l], {
          silent: !0
        });
      o.silent || this.emit("added", r, i, a);
    }
  }, {
    key: "addResourceBundle",
    value: function(r, i, a, o, l) {
      var f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, d = [r, i];
      r.indexOf(".") > -1 && (d = r.split("."), o = a, a = i, i = d[1]), this.addNamespaces(i);
      var u = gf(this.data, d) || {};
      o ? hI(u, a, l) : u = Yh(Yh({}, u), a), iO(this.data, d, u), f.silent || this.emit("added", r, i, a);
    }
  }, {
    key: "removeResourceBundle",
    value: function(r, i) {
      this.hasResourceBundle(r, i) && delete this.data[r][i], this.removeNamespaces(i), this.emit("removed", r, i);
    }
  }, {
    key: "hasResourceBundle",
    value: function(r, i) {
      return this.getResource(r, i) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(r, i) {
      return i || (i = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Yh(Yh({}, {}), this.getResource(r, i)) : this.getResource(r, i);
    }
  }, {
    key: "getDataByLanguage",
    value: function(r) {
      return this.data[r];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(r) {
      var i = this.getDataByLanguage(r), a = i && Object.keys(i) || [];
      return !!a.find(function(o) {
        return i[o] && Object.keys(i[o]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), n;
}(ro), fI = {
  processors: {},
  addPostProcessor: function(t) {
    this.processors[t.name] = t;
  },
  handle: function(t, n, s, r, i) {
    var a = this;
    return t.forEach(function(o) {
      a.processors[o] && (n = a.processors[o].process(n, s, r, i));
    }), n;
  }
};
function aO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Ti(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function T8(e) {
  var t = O8();
  return function() {
    var s = bs(e), r;
    if (t) {
      var i = bs(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return ah(this, r);
  };
}
function O8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var oO = {}, lO = function(e) {
  fp(n, e);
  var t = T8(n);
  function n(s) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Gr(this, n), r = t.call(this), pp && ro.call(Wa(r)), p8(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], s, Wa(r)), r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.logger = ds.create("translator"), r;
  }
  return kr(n, [{
    key: "changeLanguage",
    value: function(r) {
      r && (this.language = r);
    }
  }, {
    key: "exists",
    value: function(r) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (r == null)
        return !1;
      var a = this.resolve(r, i);
      return a && a.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(r, i) {
      var a = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator;
      a === void 0 && (a = ":");
      var o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, l = i.ns || this.options.defaultNS || [], f = a && r.indexOf(a) > -1, d = !this.options.userDefinedKeySeparator && !i.keySeparator && !this.options.userDefinedNsSeparator && !i.nsSeparator && !E8(r, a, o);
      if (f && !d) {
        var u = r.match(this.interpolator.nestingRegexp);
        if (u && u.length > 0)
          return {
            key: r,
            namespaces: l
          };
        var c = r.split(a);
        (a !== o || a === o && this.options.ns.indexOf(c[0]) > -1) && (l = c.shift()), r = c.join(o);
      }
      return typeof l == "string" && (l = [l]), {
        key: r,
        namespaces: l
      };
    }
  }, {
    key: "translate",
    value: function(r, i, a) {
      var o = this;
      if (jr(i) !== "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), i || (i = {}), r == null)
        return "";
      Array.isArray(r) || (r = [String(r)]);
      var l = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, f = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, d = this.extractFromKey(r[r.length - 1], i), u = d.key, c = d.namespaces, h = c[c.length - 1], p = i.lng || this.language, g = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (p && p.toLowerCase() === "cimode") {
        if (g) {
          var m = i.nsSeparator || this.options.nsSeparator;
          return l ? (v.res = "".concat(h).concat(m).concat(u), v) : "".concat(h).concat(m).concat(u);
        }
        return l ? (v.res = u, v) : u;
      }
      var v = this.resolve(r, i), y = v && v.res, E = v && v.usedKey || u, C = v && v.exactUsedKey || u, x = Object.prototype.toString.apply(y), b = ["[object Number]", "[object Function]", "[object RegExp]"], P = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, O = !this.i18nFormat || this.i18nFormat.handleAsObject, T = typeof y != "string" && typeof y != "boolean" && typeof y != "number";
      if (O && y && T && b.indexOf(x) < 0 && !(typeof P == "string" && x === "[object Array]")) {
        if (!i.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var M = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(E, y, Ti(Ti({}, i), {}, {
            ns: c
          })) : "key '".concat(u, " (").concat(this.language, ")' returned an object instead of string.");
          return l ? (v.res = M, v) : M;
        }
        if (f) {
          var L = x === "[object Array]", A = L ? [] : {}, D = L ? C : E;
          for (var I in y)
            if (Object.prototype.hasOwnProperty.call(y, I)) {
              var w = "".concat(D).concat(f).concat(I);
              A[I] = this.translate(w, Ti(Ti({}, i), {
                joinArrays: !1,
                ns: c
              })), A[I] === w && (A[I] = y[I]);
            }
          y = A;
        }
      } else if (O && typeof P == "string" && x === "[object Array]")
        y = y.join(P), y && (y = this.extendTranslation(y, r, i, a));
      else {
        var B = !1, j = !1, k = i.count !== void 0 && typeof i.count != "string", X = n.hasDefaultValue(i), rt = k ? this.pluralResolver.getSuffix(p, i.count, i) : "", et = i["defaultValue".concat(rt)] || i.defaultValue;
        !this.isValidLookup(y) && X && (B = !0, y = et), this.isValidLookup(y) || (j = !0, y = u);
        var Z = i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, dt = Z && j ? void 0 : y, vt = X && et !== y && this.options.updateMissing;
        if (j || B || vt) {
          if (this.logger.log(vt ? "updateKey" : "missingKey", p, h, u, vt ? et : y), f) {
            var bt = this.resolve(u, Ti(Ti({}, i), {}, {
              keySeparator: !1
            }));
            bt && bt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var it = [], R = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && R && R[0])
            for (var V = 0; V < R.length; V++)
              it.push(R[V]);
          else
            this.options.saveMissingTo === "all" ? it = this.languageUtils.toResolveHierarchy(i.lng || this.language) : it.push(i.lng || this.language);
          var tt = function(W, z, at) {
            var ct = X && at !== y ? at : dt;
            o.options.missingKeyHandler ? o.options.missingKeyHandler(W, h, z, ct, vt, i) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing(W, h, z, ct, vt, i), o.emit("missingKey", W, h, z, y);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && k ? it.forEach(function(Y) {
            o.pluralResolver.getSuffixes(Y, i).forEach(function(W) {
              tt([Y], u + W, i["defaultValue".concat(W)] || et);
            });
          }) : tt(it, u, et));
        }
        y = this.extendTranslation(y, r, i, v, a), j && y === u && this.options.appendNamespaceToMissingKey && (y = "".concat(h, ":").concat(u)), (j || B) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? y = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(h, ":").concat(u) : u, B ? y : void 0) : y = this.options.parseMissingKeyHandler(y));
      }
      return l ? (v.res = y, v) : y;
    }
  }, {
    key: "extendTranslation",
    value: function(r, i, a, o, l) {
      var f = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        r = this.i18nFormat.parse(r, Ti(Ti({}, this.options.interpolation.defaultVariables), a), o.usedLng, o.usedNS, o.usedKey, {
          resolved: o
        });
      else if (!a.skipInterpolation) {
        a.interpolation && this.interpolator.init(Ti(Ti({}, a), {
          interpolation: Ti(Ti({}, this.options.interpolation), a.interpolation)
        }));
        var d = typeof r == "string" && (a && a.interpolation && a.interpolation.skipOnVariables !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), u;
        if (d) {
          var c = r.match(this.interpolator.nestingRegexp);
          u = c && c.length;
        }
        var h = a.replace && typeof a.replace != "string" ? a.replace : a;
        if (this.options.interpolation.defaultVariables && (h = Ti(Ti({}, this.options.interpolation.defaultVariables), h)), r = this.interpolator.interpolate(r, h, a.lng || this.language, a), d) {
          var p = r.match(this.interpolator.nestingRegexp), g = p && p.length;
          u < g && (a.nest = !1);
        }
        a.nest !== !1 && (r = this.interpolator.nest(r, function() {
          for (var y = arguments.length, E = new Array(y), C = 0; C < y; C++)
            E[C] = arguments[C];
          return l && l[0] === E[0] && !a.context ? (f.logger.warn("It seems you are nesting recursively key: ".concat(E[0], " in key: ").concat(i[0])), null) : f.translate.apply(f, E.concat([i]));
        }, a)), a.interpolation && this.interpolator.reset();
      }
      var m = a.postProcess || this.options.postProcess, v = typeof m == "string" ? [m] : m;
      return r != null && v && v.length && a.applyPostProcessor !== !1 && (r = fI.handle(v, r, i, this.options && this.options.postProcessPassResolved ? Ti({
        i18nResolved: o
      }, a) : a, this)), r;
    }
  }, {
    key: "resolve",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o, l, f, d, u;
      return typeof r == "string" && (r = [r]), r.forEach(function(c) {
        if (!i.isValidLookup(o)) {
          var h = i.extractFromKey(c, a), p = h.key;
          l = p;
          var g = h.namespaces;
          i.options.fallbackNS && (g = g.concat(i.options.fallbackNS));
          var m = a.count !== void 0 && typeof a.count != "string", v = m && !a.ordinal && a.count === 0 && i.pluralResolver.shouldUseIntlApi(), y = a.context !== void 0 && (typeof a.context == "string" || typeof a.context == "number") && a.context !== "", E = a.lngs ? a.lngs : i.languageUtils.toResolveHierarchy(a.lng || i.language, a.fallbackLng);
          g.forEach(function(C) {
            i.isValidLookup(o) || (u = C, !oO["".concat(E[0], "-").concat(C)] && i.utils && i.utils.hasLoadedNamespace && !i.utils.hasLoadedNamespace(u) && (oO["".concat(E[0], "-").concat(C)] = !0, i.logger.warn('key "'.concat(l, '" for languages "').concat(E.join(", "), `" won't get resolved as namespace "`).concat(u, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), E.forEach(function(x) {
              if (!i.isValidLookup(o)) {
                d = x;
                var b = [p];
                if (i.i18nFormat && i.i18nFormat.addLookupKeys)
                  i.i18nFormat.addLookupKeys(b, p, x, C, a);
                else {
                  var P;
                  m && (P = i.pluralResolver.getSuffix(x, a.count, a));
                  var O = "".concat(i.options.pluralSeparator, "zero");
                  if (m && (b.push(p + P), v && b.push(p + O)), y) {
                    var T = "".concat(p).concat(i.options.contextSeparator).concat(a.context);
                    b.push(T), m && (b.push(T + P), v && b.push(T + O));
                  }
                }
                for (var M; M = b.pop(); )
                  i.isValidLookup(o) || (f = M, o = i.getResource(x, C, M, a));
              }
            }));
          });
        }
      }), {
        res: o,
        usedKey: l,
        exactUsedKey: f,
        usedLng: d,
        usedNS: u
      };
    }
  }, {
    key: "isValidLookup",
    value: function(r) {
      return r !== void 0 && !(!this.options.returnNull && r === null) && !(!this.options.returnEmptyString && r === "");
    }
  }, {
    key: "getResource",
    value: function(r, i, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(r, i, a, o) : this.resourceStore.getResource(r, i, a, o);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(r) {
      var i = "defaultValue";
      for (var a in r)
        if (Object.prototype.hasOwnProperty.call(r, a) && i === a.substring(0, i.length) && r[a] !== void 0)
          return !0;
      return !1;
    }
  }]), n;
}(ro);
function rg(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var P8 = function() {
  function e(t) {
    Gr(this, e), this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = ds.create("languageUtils");
  }
  return kr(e, [{
    key: "getScriptPartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return null;
      var s = n.split("-");
      return s.length === 2 || (s.pop(), s[s.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(s.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(n) {
      if (!n || n.indexOf("-") < 0)
        return n;
      var s = n.split("-");
      return this.formatLanguageCode(s[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(n) {
      if (typeof n == "string" && n.indexOf("-") > -1) {
        var s = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], r = n.split("-");
        return this.options.lowerCaseLng ? r = r.map(function(i) {
          return i.toLowerCase();
        }) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), s.indexOf(r[1].toLowerCase()) > -1 && (r[1] = rg(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), s.indexOf(r[1].toLowerCase()) > -1 && (r[1] = rg(r[1].toLowerCase())), s.indexOf(r[2].toLowerCase()) > -1 && (r[2] = rg(r[2].toLowerCase()))), r.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? n.toLowerCase() : n;
    }
  }, {
    key: "isSupportedCode",
    value: function(n) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (n = this.getLanguagePartFromCode(n)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(n) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(n) {
      var s = this;
      if (!n)
        return null;
      var r;
      return n.forEach(function(i) {
        if (!r) {
          var a = s.formatLanguageCode(i);
          (!s.options.supportedLngs || s.isSupportedCode(a)) && (r = a);
        }
      }), !r && this.options.supportedLngs && n.forEach(function(i) {
        if (!r) {
          var a = s.getLanguagePartFromCode(i);
          if (s.isSupportedCode(a))
            return r = a;
          r = s.options.supportedLngs.find(function(o) {
            if (o.indexOf(a) === 0)
              return o;
          });
        }
      }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
    }
  }, {
    key: "getFallbackCodes",
    value: function(n, s) {
      if (!n)
        return [];
      if (typeof n == "function" && (n = n(s)), typeof n == "string" && (n = [n]), Object.prototype.toString.apply(n) === "[object Array]")
        return n;
      if (!s)
        return n.default || [];
      var r = n[s];
      return r || (r = n[this.getScriptPartFromCode(s)]), r || (r = n[this.formatLanguageCode(s)]), r || (r = n[this.getLanguagePartFromCode(s)]), r || (r = n.default), r || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(n, s) {
      var r = this, i = this.getFallbackCodes(s || this.options.fallbackLng || [], n), a = [], o = function(f) {
        f && (r.isSupportedCode(f) ? a.push(f) : r.logger.warn("rejecting language code not found in supportedLngs: ".concat(f)));
      };
      return typeof n == "string" && n.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(n)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(n)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(n))) : typeof n == "string" && o(this.formatLanguageCode(n)), i.forEach(function(l) {
        a.indexOf(l) < 0 && o(r.formatLanguageCode(l));
      }), a;
    }
  }]), e;
}(), S8 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], M8 = {
  1: function(t) {
    return +(t > 1);
  },
  2: function(t) {
    return +(t != 1);
  },
  3: function(t) {
    return 0;
  },
  4: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  5: function(t) {
    return t == 0 ? 0 : t == 1 ? 1 : t == 2 ? 2 : t % 100 >= 3 && t % 100 <= 10 ? 3 : t % 100 >= 11 ? 4 : 5;
  },
  6: function(t) {
    return t == 1 ? 0 : t >= 2 && t <= 4 ? 1 : 2;
  },
  7: function(t) {
    return t == 1 ? 0 : t % 10 >= 2 && t % 10 <= 4 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  8: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t != 8 && t != 11 ? 2 : 3;
  },
  9: function(t) {
    return +(t >= 2);
  },
  10: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t < 7 ? 2 : t < 11 ? 3 : 4;
  },
  11: function(t) {
    return t == 1 || t == 11 ? 0 : t == 2 || t == 12 ? 1 : t > 2 && t < 20 ? 2 : 3;
  },
  12: function(t) {
    return +(t % 10 != 1 || t % 100 == 11);
  },
  13: function(t) {
    return +(t !== 0);
  },
  14: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : t == 3 ? 2 : 3;
  },
  15: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t % 10 >= 2 && (t % 100 < 10 || t % 100 >= 20) ? 1 : 2;
  },
  16: function(t) {
    return t % 10 == 1 && t % 100 != 11 ? 0 : t !== 0 ? 1 : 2;
  },
  17: function(t) {
    return t == 1 || t % 10 == 1 && t % 100 != 11 ? 0 : 1;
  },
  18: function(t) {
    return t == 0 ? 0 : t == 1 ? 1 : 2;
  },
  19: function(t) {
    return t == 1 ? 0 : t == 0 || t % 100 > 1 && t % 100 < 11 ? 1 : t % 100 > 10 && t % 100 < 20 ? 2 : 3;
  },
  20: function(t) {
    return t == 1 ? 0 : t == 0 || t % 100 > 0 && t % 100 < 20 ? 1 : 2;
  },
  21: function(t) {
    return t % 100 == 1 ? 1 : t % 100 == 2 ? 2 : t % 100 == 3 || t % 100 == 4 ? 3 : 0;
  },
  22: function(t) {
    return t == 1 ? 0 : t == 2 ? 1 : (t < 0 || t > 10) && t % 10 == 0 ? 2 : 3;
  }
}, _8 = ["v1", "v2", "v3"], uO = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function I8() {
  var e = {};
  return S8.forEach(function(t) {
    t.lngs.forEach(function(n) {
      e[n] = {
        numbers: t.nr,
        plurals: M8[t.fc]
      };
    });
  }), e;
}
var D8 = function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Gr(this, e), this.languageUtils = t, this.options = n, this.logger = ds.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = I8();
  }
  return kr(e, [{
    key: "addRule",
    value: function(n, s) {
      this.rules[n] = s;
    }
  }, {
    key: "getRule",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(n, {
            type: s.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[n] || this.rules[this.languageUtils.getLanguagePartFromCode(n)];
    }
  }, {
    key: "needsPlural",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = this.getRule(n, s);
      return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(n, s) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(n, r).map(function(i) {
        return "".concat(s).concat(i);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(n) {
      var s = this, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = this.getRule(n, r);
      return i ? this.shouldUseIntlApi() ? i.resolvedOptions().pluralCategories.sort(function(a, o) {
        return uO[a] - uO[o];
      }).map(function(a) {
        return "".concat(s.options.prepend).concat(a);
      }) : i.numbers.map(function(a) {
        return s.getSuffix(n, a, r);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(n, s) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = this.getRule(n, r);
      return i ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(i.select(s)) : this.getSuffixRetroCompatible(i, s) : (this.logger.warn("no plural rule found for: ".concat(n)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(n, s) {
      var r = this, i = n.noAbs ? n.plurals(s) : n.plurals(Math.abs(s)), a = n.numbers[i];
      this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 && (a === 2 ? a = "plural" : a === 1 && (a = ""));
      var o = function() {
        return r.options.prepend && a.toString() ? r.options.prepend + a.toString() : a.toString();
      };
      return this.options.compatibilityJSON === "v1" ? a === 1 ? "" : typeof a == "number" ? "_plural_".concat(a.toString()) : o() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && n.numbers.length === 2 && n.numbers[0] === 1 ? o() : this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !_8.includes(this.options.compatibilityJSON);
    }
  }]), e;
}();
function cO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Dr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
var A8 = function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Gr(this, e), this.logger = ds.create("interpolator"), this.options = t, this.format = t.interpolation && t.interpolation.format || function(n) {
      return n;
    }, this.init(t);
  }
  return kr(e, [{
    key: "init",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n.interpolation || (n.interpolation = {
        escapeValue: !0
      });
      var s = n.interpolation;
      this.escape = s.escape !== void 0 ? s.escape : v8, this.escapeValue = s.escapeValue !== void 0 ? s.escapeValue : !0, this.useRawValueToEscape = s.useRawValueToEscape !== void 0 ? s.useRawValueToEscape : !1, this.prefix = s.prefix ? pl(s.prefix) : s.prefixEscaped || "{{", this.suffix = s.suffix ? pl(s.suffix) : s.suffixEscaped || "}}", this.formatSeparator = s.formatSeparator ? s.formatSeparator : s.formatSeparator || ",", this.unescapePrefix = s.unescapeSuffix ? "" : s.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : s.unescapeSuffix || "", this.nestingPrefix = s.nestingPrefix ? pl(s.nestingPrefix) : s.nestingPrefixEscaped || pl("$t("), this.nestingSuffix = s.nestingSuffix ? pl(s.nestingSuffix) : s.nestingSuffixEscaped || pl(")"), this.nestingOptionsSeparator = s.nestingOptionsSeparator ? s.nestingOptionsSeparator : s.nestingOptionsSeparator || ",", this.maxReplaces = s.maxReplaces ? s.maxReplaces : 1e3, this.alwaysFormat = s.alwaysFormat !== void 0 ? s.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var n = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(n, "g");
      var s = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(s, "g");
      var r = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(r, "g");
    }
  }, {
    key: "interpolate",
    value: function(n, s, r, i) {
      var a = this, o, l, f, d = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function u(m) {
        return m.replace(/\$/g, "$$$$");
      }
      var c = function(v) {
        if (v.indexOf(a.formatSeparator) < 0) {
          var y = rO(s, d, v);
          return a.alwaysFormat ? a.format(y, void 0, r, Dr(Dr(Dr({}, i), s), {}, {
            interpolationkey: v
          })) : y;
        }
        var E = v.split(a.formatSeparator), C = E.shift().trim(), x = E.join(a.formatSeparator).trim();
        return a.format(rO(s, d, C), x, r, Dr(Dr(Dr({}, i), s), {}, {
          interpolationkey: C
        }));
      };
      this.resetRegExp();
      var h = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, g = [{
        regex: this.regexpUnescape,
        safeValue: function(v) {
          return u(v);
        }
      }, {
        regex: this.regexp,
        safeValue: function(v) {
          return a.escapeValue ? u(a.escape(v)) : u(v);
        }
      }];
      return g.forEach(function(m) {
        for (f = 0; o = m.regex.exec(n); ) {
          var v = o[1].trim();
          if (l = c(v), l === void 0)
            if (typeof h == "function") {
              var y = h(n, o, i);
              l = typeof y == "string" ? y : "";
            } else if (i && i.hasOwnProperty(v))
              l = "";
            else if (p) {
              l = o[0];
              continue;
            } else
              a.logger.warn("missed to pass in variable ".concat(v, " for interpolating ").concat(n)), l = "";
          else
            typeof l != "string" && !a.useRawValueToEscape && (l = nO(l));
          var E = m.safeValue(l);
          if (n = n.replace(o[0], E), p ? (m.regex.lastIndex += l.length, m.regex.lastIndex -= o[0].length) : m.regex.lastIndex = 0, f++, f >= a.maxReplaces)
            break;
        }
      }), n;
    }
  }, {
    key: "nest",
    value: function(n, s) {
      var r = this, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a, o, l = Dr({}, i);
      l.applyPostProcessor = !1, delete l.defaultValue;
      function f(h, p) {
        var g = this.nestingOptionsSeparator;
        if (h.indexOf(g) < 0)
          return h;
        var m = h.split(new RegExp("".concat(g, "[ ]*{"))), v = "{".concat(m[1]);
        h = m[0], v = this.interpolate(v, l);
        var y = v.match(/'/g), E = v.match(/"/g);
        (y && y.length % 2 === 0 && !E || E.length % 2 !== 0) && (v = v.replace(/'/g, '"'));
        try {
          l = JSON.parse(v), p && (l = Dr(Dr({}, p), l));
        } catch (C) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(h), C), "".concat(h).concat(g).concat(v);
        }
        return delete l.defaultValue, h;
      }
      for (; a = this.nestingRegexp.exec(n); ) {
        var d = [], u = !1;
        if (a[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(a[1])) {
          var c = a[1].split(this.formatSeparator).map(function(h) {
            return h.trim();
          });
          a[1] = c.shift(), d = c, u = !0;
        }
        if (o = s(f.call(this, a[1].trim(), l), l), o && a[0] === n && typeof o != "string")
          return o;
        typeof o != "string" && (o = nO(o)), o || (this.logger.warn("missed to resolve ".concat(a[1], " for nesting ").concat(n)), o = ""), u && (o = d.reduce(function(h, p) {
          return r.format(h, p, i.lng, Dr(Dr({}, i), {}, {
            interpolationkey: a[1].trim()
          }));
        }, o.trim())), n = n.replace(a[0], o), this.regexp.lastIndex = 0;
      }
      return n;
    }
  }]), e;
}();
function hO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function Ca(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function L8(e) {
  var t = e.toLowerCase().trim(), n = {};
  if (e.indexOf("(") > -1) {
    var s = e.split("(");
    t = s[0].toLowerCase().trim();
    var r = s[1].substring(0, s[1].length - 1);
    if (t === "currency" && r.indexOf(":") < 0)
      n.currency || (n.currency = r.trim());
    else if (t === "relativetime" && r.indexOf(":") < 0)
      n.range || (n.range = r.trim());
    else {
      var i = r.split(";");
      i.forEach(function(a) {
        if (a) {
          var o = a.split(":"), l = h8(o), f = l[0], d = l.slice(1), u = d.join(":").trim().replace(/^'+|'+$/g, "");
          n[f.trim()] || (n[f.trim()] = u), u === "false" && (n[f.trim()] = !1), u === "true" && (n[f.trim()] = !0), isNaN(u) || (n[f.trim()] = parseInt(u, 10));
        }
      });
    }
  }
  return {
    formatName: t,
    formatOptions: n
  };
}
function ml(e) {
  var t = {};
  return function(s, r, i) {
    var a = r + JSON.stringify(i), o = t[a];
    return o || (o = e(r, i), t[a] = o), o(s);
  };
}
var R8 = function() {
  function e() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Gr(this, e), this.logger = ds.create("formatter"), this.options = t, this.formats = {
      number: ml(function(n, s) {
        var r = new Intl.NumberFormat(n, s);
        return function(i) {
          return r.format(i);
        };
      }),
      currency: ml(function(n, s) {
        var r = new Intl.NumberFormat(n, Ca(Ca({}, s), {}, {
          style: "currency"
        }));
        return function(i) {
          return r.format(i);
        };
      }),
      datetime: ml(function(n, s) {
        var r = new Intl.DateTimeFormat(n, Ca({}, s));
        return function(i) {
          return r.format(i);
        };
      }),
      relativetime: ml(function(n, s) {
        var r = new Intl.RelativeTimeFormat(n, Ca({}, s));
        return function(i) {
          return r.format(i, s.range || "day");
        };
      }),
      list: ml(function(n, s) {
        var r = new Intl.ListFormat(n, Ca({}, s));
        return function(i) {
          return r.format(i);
        };
      })
    }, this.init(t);
  }
  return kr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, r = s.interpolation;
      this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(n, s) {
      this.formats[n.toLowerCase().trim()] = s;
    }
  }, {
    key: "addCached",
    value: function(n, s) {
      this.formats[n.toLowerCase().trim()] = ml(s);
    }
  }, {
    key: "format",
    value: function(n, s, r, i) {
      var a = this, o = s.split(this.formatSeparator), l = o.reduce(function(f, d) {
        var u = L8(d), c = u.formatName, h = u.formatOptions;
        if (a.formats[c]) {
          var p = f;
          try {
            var g = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, m = g.locale || g.lng || i.locale || i.lng || r;
            p = a.formats[c](f, m, Ca(Ca(Ca({}, h), i), g));
          } catch (v) {
            a.logger.warn(v);
          }
          return p;
        } else
          a.logger.warn("there was no format function for ".concat(c));
        return f;
      }, n);
      return l;
    }
  }]), e;
}();
function dO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function fO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function w8(e) {
  var t = V8();
  return function() {
    var s = bs(e), r;
    if (t) {
      var i = bs(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return ah(this, r);
  };
}
function V8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function B8(e, t) {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
}
var F8 = function(e) {
  fp(n, e);
  var t = w8(n);
  function n(s, r, i) {
    var a, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Gr(this, n), a = t.call(this), pp && ro.call(Wa(a)), a.backend = s, a.store = r, a.services = i, a.languageUtils = i.languageUtils, a.options = o, a.logger = ds.create("backendConnector"), a.waitingReads = [], a.maxParallelReads = o.maxParallelReads || 10, a.readingCalls = 0, a.maxRetries = o.maxRetries >= 0 ? o.maxRetries : 5, a.retryTimeout = o.retryTimeout >= 1 ? o.retryTimeout : 350, a.state = {}, a.queue = [], a.backend && a.backend.init && a.backend.init(i, o.backend, o), a;
  }
  return kr(n, [{
    key: "queueLoad",
    value: function(r, i, a, o) {
      var l = this, f = {}, d = {}, u = {}, c = {};
      return r.forEach(function(h) {
        var p = !0;
        i.forEach(function(g) {
          var m = "".concat(h, "|").concat(g);
          !a.reload && l.store.hasResourceBundle(h, g) ? l.state[m] = 2 : l.state[m] < 0 || (l.state[m] === 1 ? d[m] === void 0 && (d[m] = !0) : (l.state[m] = 1, p = !1, d[m] === void 0 && (d[m] = !0), f[m] === void 0 && (f[m] = !0), c[g] === void 0 && (c[g] = !0)));
        }), p || (u[h] = !0);
      }), (Object.keys(f).length || Object.keys(d).length) && this.queue.push({
        pending: d,
        pendingCount: Object.keys(d).length,
        loaded: {},
        errors: [],
        callback: o
      }), {
        toLoad: Object.keys(f),
        pending: Object.keys(d),
        toLoadLanguages: Object.keys(u),
        toLoadNamespaces: Object.keys(c)
      };
    }
  }, {
    key: "loaded",
    value: function(r, i, a) {
      var o = r.split("|"), l = o[0], f = o[1];
      i && this.emit("failedLoading", l, f, i), a && this.store.addResourceBundle(l, f, a), this.state[r] = i ? -1 : 2;
      var d = {};
      this.queue.forEach(function(u) {
        m8(u.loaded, [l], f), B8(u, r), i && u.errors.push(i), u.pendingCount === 0 && !u.done && (Object.keys(u.loaded).forEach(function(c) {
          d[c] || (d[c] = {});
          var h = u.loaded[c];
          h.length && h.forEach(function(p) {
            d[c][p] === void 0 && (d[c][p] = !0);
          });
        }), u.done = !0, u.errors.length ? u.callback(u.errors) : u.callback());
      }), this.emit("loaded", d), this.queue = this.queue.filter(function(u) {
        return !u.done;
      });
    }
  }, {
    key: "read",
    value: function(r, i, a) {
      var o = this, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, d = arguments.length > 5 ? arguments[5] : void 0;
      if (!r.length)
        return d(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: r,
          ns: i,
          fcName: a,
          tried: l,
          wait: f,
          callback: d
        });
        return;
      }
      return this.readingCalls++, this.backend[a](r, i, function(u, c) {
        if (o.readingCalls--, o.waitingReads.length > 0) {
          var h = o.waitingReads.shift();
          o.read(h.lng, h.ns, h.fcName, h.tried, h.wait, h.callback);
        }
        if (u && c && l < o.maxRetries) {
          setTimeout(function() {
            o.read.call(o, r, i, a, l + 1, f * 2, d);
          }, f);
          return;
        }
        d(u, c);
      });
    }
  }, {
    key: "prepareLoading",
    value: function(r, i) {
      var a = this, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), l && l();
      typeof r == "string" && (r = this.languageUtils.toResolveHierarchy(r)), typeof i == "string" && (i = [i]);
      var f = this.queueLoad(r, i, o, l);
      if (!f.toLoad.length)
        return f.pending.length || l(), null;
      f.toLoad.forEach(function(d) {
        a.loadOne(d);
      });
    }
  }, {
    key: "load",
    value: function(r, i, a) {
      this.prepareLoading(r, i, {}, a);
    }
  }, {
    key: "reload",
    value: function(r, i, a) {
      this.prepareLoading(r, i, {
        reload: !0
      }, a);
    }
  }, {
    key: "loadOne",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", o = r.split("|"), l = o[0], f = o[1];
      this.read(l, f, "read", void 0, void 0, function(d, u) {
        d && i.logger.warn("".concat(a, "loading namespace ").concat(f, " for language ").concat(l, " failed"), d), !d && u && i.logger.log("".concat(a, "loaded namespace ").concat(f, " for language ").concat(l), u), i.loaded(r, d, u);
      });
    }
  }, {
    key: "saveMissing",
    value: function(r, i, a, o, l) {
      var f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(i)) {
        this.logger.warn('did not save key "'.concat(a, '" as the namespace "').concat(i, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      a == null || a === "" || (this.backend && this.backend.create && this.backend.create(r, i, a, o, null, fO(fO({}, f), {}, {
        isUpdate: l
      })), !(!r || !r[0]) && this.store.addResource(r[0], i, a, o));
    }
  }]), n;
}(ro);
function N8() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(t) {
      var n = {};
      if (jr(t[1]) === "object" && (n = t[1]), typeof t[1] == "string" && (n.defaultValue = t[1]), typeof t[2] == "string" && (n.tDescription = t[2]), jr(t[2]) === "object" || jr(t[3]) === "object") {
        var s = t[3] || t[2];
        Object.keys(s).forEach(function(r) {
          n[r] = s[r];
        });
      }
      return n;
    },
    interpolation: {
      escapeValue: !0,
      format: function(t, n, s, r) {
        return t;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function pO(e) {
  return typeof e.ns == "string" && (e.ns = [e.ns]), typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), e;
}
function mO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function ss(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mO(Object(n), !0).forEach(function(s) {
      oo(e, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mO(Object(n)).forEach(function(s) {
      Object.defineProperty(e, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return e;
}
function j8(e) {
  var t = $8();
  return function() {
    var s = bs(e), r;
    if (t) {
      var i = bs(this).constructor;
      r = Reflect.construct(s, arguments, i);
    } else
      r = s.apply(this, arguments);
    return ah(this, r);
  };
}
function $8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Xh() {
}
function U8(e) {
  var t = Object.getOwnPropertyNames(Object.getPrototypeOf(e));
  t.forEach(function(n) {
    typeof e[n] == "function" && (e[n] = e[n].bind(e));
  });
}
var vf = function(e) {
  fp(n, e);
  var t = j8(n);
  function n() {
    var s, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    if (Gr(this, n), s = t.call(this), pp && ro.call(Wa(s)), s.options = pO(r), s.services = {}, s.logger = ds, s.modules = {
      external: []
    }, U8(Wa(s)), i && !s.isInitialized && !r.isClone) {
      if (!s.options.initImmediate)
        return s.init(r, i), ah(s, Wa(s));
      setTimeout(function() {
        s.init(r, i);
      }, 0);
    }
    return s;
  }
  return kr(n, [{
    key: "init",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0;
      typeof i == "function" && (a = i, i = {}), !i.defaultNS && i.defaultNS !== !1 && i.ns && (typeof i.ns == "string" ? i.defaultNS = i.ns : i.ns.indexOf("translation") < 0 && (i.defaultNS = i.ns[0]));
      var o = N8();
      this.options = ss(ss(ss({}, o), this.options), pO(i)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = ss(ss({}, o.interpolation), this.options.interpolation)), i.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = i.keySeparator), i.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = i.nsSeparator);
      function l(v) {
        return v ? typeof v == "function" ? new v() : v : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? ds.init(l(this.modules.logger), this.options) : ds.init(null, this.options);
        var f;
        this.modules.formatter ? f = this.modules.formatter : typeof Intl < "u" && (f = R8);
        var d = new P8(this.options);
        this.store = new b8(this.options.resources, this.options);
        var u = this.services;
        u.logger = ds, u.resourceStore = this.store, u.languageUtils = d, u.pluralResolver = new D8(d, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), f && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (u.formatter = l(f), u.formatter.init(u, this.options), this.options.interpolation.format = u.formatter.format.bind(u.formatter)), u.interpolator = new A8(this.options), u.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, u.backendConnector = new F8(l(this.modules.backend), u.resourceStore, u, this.options), u.backendConnector.on("*", function(v) {
          for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), C = 1; C < y; C++)
            E[C - 1] = arguments[C];
          r.emit.apply(r, [v].concat(E));
        }), this.modules.languageDetector && (u.languageDetector = l(this.modules.languageDetector), u.languageDetector.init(u, this.options.detection, this.options)), this.modules.i18nFormat && (u.i18nFormat = l(this.modules.i18nFormat), u.i18nFormat.init && u.i18nFormat.init(this)), this.translator = new lO(this.services, this.options), this.translator.on("*", function(v) {
          for (var y = arguments.length, E = new Array(y > 1 ? y - 1 : 0), C = 1; C < y; C++)
            E[C - 1] = arguments[C];
          r.emit.apply(r, [v].concat(E));
        }), this.modules.external.forEach(function(v) {
          v.init && v.init(r);
        });
      }
      if (this.format = this.options.interpolation.format, a || (a = Xh), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var h = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      h.forEach(function(v) {
        r[v] = function() {
          var y;
          return (y = r.store)[v].apply(y, arguments);
        };
      });
      var p = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      p.forEach(function(v) {
        r[v] = function() {
          var y;
          return (y = r.store)[v].apply(y, arguments), r;
        };
      });
      var g = Ku(), m = function() {
        var y = function(C, x) {
          r.isInitialized && !r.initializedStoreOnce && r.logger.warn("init: i18next is already initialized. You should call init just once!"), r.isInitialized = !0, r.options.isClone || r.logger.log("initialized", r.options), r.emit("initialized", r.options), g.resolve(x), a(C, x);
        };
        if (r.languages && r.options.compatibilityAPI !== "v1" && !r.isInitialized)
          return y(null, r.t.bind(r));
        r.changeLanguage(r.options.lng, y);
      };
      return this.options.resources || !this.options.initImmediate ? m() : setTimeout(m, 0), g;
    }
  }, {
    key: "loadResources",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Xh, o = a, l = typeof r == "string" ? r : this.language;
      if (typeof r == "function" && (o = r), !this.options.resources || this.options.partialBundledLanguages) {
        if (l && l.toLowerCase() === "cimode")
          return o();
        var f = [], d = function(h) {
          if (h) {
            var p = i.services.languageUtils.toResolveHierarchy(h);
            p.forEach(function(g) {
              f.indexOf(g) < 0 && f.push(g);
            });
          }
        };
        if (l)
          d(l);
        else {
          var u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          u.forEach(function(c) {
            return d(c);
          });
        }
        this.options.preload && this.options.preload.forEach(function(c) {
          return d(c);
        }), this.services.backendConnector.load(f, this.options.ns, function(c) {
          !c && !i.resolvedLanguage && i.language && i.setResolvedLanguage(i.language), o(c);
        });
      } else
        o(null);
    }
  }, {
    key: "reloadResources",
    value: function(r, i, a) {
      var o = Ku();
      return r || (r = this.languages), i || (i = this.options.ns), a || (a = Xh), this.services.backendConnector.reload(r, i, function(l) {
        o.resolve(), a(l);
      }), o;
    }
  }, {
    key: "use",
    value: function(r) {
      if (!r)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!r.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return r.type === "backend" && (this.modules.backend = r), (r.type === "logger" || r.log && r.warn && r.error) && (this.modules.logger = r), r.type === "languageDetector" && (this.modules.languageDetector = r), r.type === "i18nFormat" && (this.modules.i18nFormat = r), r.type === "postProcessor" && fI.addPostProcessor(r), r.type === "formatter" && (this.modules.formatter = r), r.type === "3rdParty" && this.modules.external.push(r), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(r) {
      if (!(!r || !this.languages) && !(["cimode", "dev"].indexOf(r) > -1))
        for (var i = 0; i < this.languages.length; i++) {
          var a = this.languages[i];
          if (!(["cimode", "dev"].indexOf(a) > -1) && this.store.hasLanguageSomeTranslations(a)) {
            this.resolvedLanguage = a;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(r, i) {
      var a = this;
      this.isLanguageChangingTo = r;
      var o = Ku();
      this.emit("languageChanging", r);
      var l = function(c) {
        a.language = c, a.languages = a.services.languageUtils.toResolveHierarchy(c), a.resolvedLanguage = void 0, a.setResolvedLanguage(c);
      }, f = function(c, h) {
        h ? (l(h), a.translator.changeLanguage(h), a.isLanguageChangingTo = void 0, a.emit("languageChanged", h), a.logger.log("languageChanged", h)) : a.isLanguageChangingTo = void 0, o.resolve(function() {
          return a.t.apply(a, arguments);
        }), i && i(c, function() {
          return a.t.apply(a, arguments);
        });
      }, d = function(c) {
        !r && !c && a.services.languageDetector && (c = []);
        var h = typeof c == "string" ? c : a.services.languageUtils.getBestMatchFromCodes(c);
        h && (a.language || l(h), a.translator.language || a.translator.changeLanguage(h), a.services.languageDetector && a.services.languageDetector.cacheUserLanguage(h)), a.loadResources(h, function(p) {
          f(p, h);
        });
      };
      return !r && this.services.languageDetector && !this.services.languageDetector.async ? d(this.services.languageDetector.detect()) : !r && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(d) : d(r), o;
    }
  }, {
    key: "getFixedT",
    value: function(r, i, a) {
      var o = this, l = function f(d, u) {
        var c;
        if (jr(u) !== "object") {
          for (var h = arguments.length, p = new Array(h > 2 ? h - 2 : 0), g = 2; g < h; g++)
            p[g - 2] = arguments[g];
          c = o.options.overloadTranslationOptionHandler([d, u].concat(p));
        } else
          c = ss({}, u);
        c.lng = c.lng || f.lng, c.lngs = c.lngs || f.lngs, c.ns = c.ns || f.ns, c.keyPrefix = c.keyPrefix || a || f.keyPrefix;
        var m = o.options.keySeparator || ".", v = c.keyPrefix ? "".concat(c.keyPrefix).concat(m).concat(d) : d;
        return o.t(v, c);
      };
      return typeof r == "string" ? l.lng = r : l.lngs = r, l.ns = i, l.keyPrefix = a, l;
    }
  }, {
    key: "t",
    value: function() {
      var r;
      return this.translator && (r = this.translator).translate.apply(r, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var r;
      return this.translator && (r = this.translator).exists.apply(r, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(r) {
      this.options.defaultNS = r;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(r) {
      var i = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var o = this.resolvedLanguage || this.languages[0], l = this.options ? this.options.fallbackLng : !1, f = this.languages[this.languages.length - 1];
      if (o.toLowerCase() === "cimode")
        return !0;
      var d = function(h, p) {
        var g = i.services.backendConnector.state["".concat(h, "|").concat(p)];
        return g === -1 || g === 2;
      };
      if (a.precheck) {
        var u = a.precheck(this, d);
        if (u !== void 0)
          return u;
      }
      return !!(this.hasResourceBundle(o, r) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || d(o, r) && (!l || d(f, r)));
    }
  }, {
    key: "loadNamespaces",
    value: function(r, i) {
      var a = this, o = Ku();
      return this.options.ns ? (typeof r == "string" && (r = [r]), r.forEach(function(l) {
        a.options.ns.indexOf(l) < 0 && a.options.ns.push(l);
      }), this.loadResources(function(l) {
        o.resolve(), i && i(l);
      }), o) : (i && i(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(r, i) {
      var a = Ku();
      typeof r == "string" && (r = [r]);
      var o = this.options.preload || [], l = r.filter(function(f) {
        return o.indexOf(f) < 0;
      });
      return l.length ? (this.options.preload = o.concat(l), this.loadResources(function(f) {
        a.resolve(), i && i(f);
      }), a) : (i && i(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(r) {
      if (r || (r = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !r)
        return "rtl";
      var i = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(r)) > -1 || r.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Xh, o = ss(ss(ss({}, this.options), i), {
        isClone: !0
      }), l = new n(o);
      (i.debug !== void 0 || i.prefix !== void 0) && (l.logger = l.logger.clone(i));
      var f = ["store", "services", "language"];
      return f.forEach(function(d) {
        l[d] = r[d];
      }), l.services = ss({}, this.services), l.services.utils = {
        hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
      }, l.translator = new lO(l.services, l.options), l.translator.on("*", function(d) {
        for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), h = 1; h < u; h++)
          c[h - 1] = arguments[h];
        l.emit.apply(l, [d].concat(c));
      }), l.init(o, a), l.translator.options = l.options, l.translator.backendConnector.services.utils = {
        hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
      }, l;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), n;
}(ro);
oo(vf, "createInstance", function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
  return new vf(e, t);
});
var qe = vf.createInstance();
qe.createInstance = vf.createInstance;
qe.createInstance;
var W8 = qe.init;
qe.loadResources;
qe.reloadResources;
var z8 = qe.use;
qe.changeLanguage;
qe.getFixedT;
var pI = qe.t;
qe.exists;
qe.setDefaultNamespace;
qe.hasLoadedNamespace;
qe.loadNamespaces;
qe.loadLanguages;
const K8 = new AU(), gO = () => ({
  capabilities: {}
}), G8 = {
  namespaced: !0,
  state: gO(),
  actions: {
    loadCapabilities({ commit: e, getters: t }, n) {
      const s = t.capabilities[n];
      if (typeof s < "u" && s !== null) {
        console.warn(
          `Re-fired loadCapabilities on id '${n}' albeit the GetCapabilities have already been successfully fetched. No re-fetch will occur.`
        );
        return;
      }
      e("addCapabilities", { id: n, string: null });
      const r = ea({ id: n });
      if (!r || !r.url || !r.version || !r.typ) {
        console.error(`Missing data for service with id '${n}': ${r}`);
        return;
      }
      const i = `${r.url}?service=${r.typ}&version=${r.version}&request=GetCapabilities`;
      fetch(i).then((a) => a.text()).then((a) => e("addCapabilities", { id: n, string: a })).catch((a) => {
        console.error(
          a,
          `Capabilities from ${i} could not be fetched.`
        ), e("addCapabilities", { id: n, string: null });
      });
    }
  },
  mutations: {
    addCapabilities(e, { id: t, string: n }) {
      e.capabilities[t] = n;
    }
  },
  getters: {
    ...Hi(gO()),
    wmsCapabilitiesAsJsonById: (e) => (t) => {
      const n = e.capabilities[t];
      if (n)
        try {
          return K8.read(n);
        } catch (s) {
          console.error(s, `Error reading xml for id '${t}': ${n}`);
        }
      return null;
    }
  }
}, Zh = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Jh extends Wi {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(t, n) {
    super(t), this.feature = n;
  }
}
function k8(e, t) {
  const n = [];
  for (let s = 0; s < t.length; ++s) {
    const i = t[s].getGeometry();
    mI(e, i, n);
  }
  return n;
}
function Qh(e, t) {
  return Xs(e[0], e[1], t[0], t[1]);
}
function Bl(e, t) {
  const n = e.length;
  return t < 0 ? e[t + n] : t >= n ? e[t - n] : e[t];
}
function qh(e, t, n) {
  let s, r;
  t < n ? (s = t, r = n) : (s = n, r = t);
  const i = Math.ceil(s), a = Math.floor(r);
  if (i > a) {
    const l = Fl(e, s), f = Fl(e, r);
    return Qh(l, f);
  }
  let o = 0;
  if (s < i) {
    const l = Fl(e, s), f = Bl(e, i);
    o += Qh(l, f);
  }
  if (a < r) {
    const l = Bl(e, a), f = Fl(e, r);
    o += Qh(l, f);
  }
  for (let l = i; l < a - 1; ++l) {
    const f = Bl(e, l), d = Bl(e, l + 1);
    o += Qh(f, d);
  }
  return o;
}
function mI(e, t, n) {
  if (t instanceof er) {
    td(e, t.getCoordinates(), !1, n);
    return;
  }
  if (t instanceof na) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r)
      td(e, s[r], !1, n);
    return;
  }
  if (t instanceof rr) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r)
      td(e, s[r], !0, n);
    return;
  }
  if (t instanceof ia) {
    const s = t.getCoordinates();
    for (let r = 0, i = s.length; r < i; ++r) {
      const a = s[r];
      for (let o = 0, l = a.length; o < l; ++o)
        td(e, a[o], !0, n);
    }
    return;
  }
  if (t instanceof fS) {
    const s = t.getGeometries();
    for (let r = 0; r < s.length; ++r)
      mI(e, s[r], n);
    return;
  }
}
const sg = { index: -1, endIndex: NaN };
function H8(e, t, n, s) {
  const r = e[0], i = e[1];
  let a = 1 / 0, o = -1, l = NaN;
  for (let u = 0; u < t.targets.length; ++u) {
    const c = t.targets[u], h = c.coordinates;
    let p = 1 / 0, g;
    for (let m = 0; m < h.length - 1; ++m) {
      const v = h[m], y = h[m + 1], E = gI(r, i, v, y);
      E.squaredDistance < p && (p = E.squaredDistance, g = m + E.along);
    }
    p < a && (a = p, c.ring && t.targetIndex === u && (c.endIndex > c.startIndex ? g < c.startIndex && (g += h.length) : c.endIndex < c.startIndex && g > c.startIndex && (g -= h.length)), l = g, o = u);
  }
  const f = t.targets[o];
  let d = f.ring;
  if (t.targetIndex === o && d) {
    const u = Fl(
      f.coordinates,
      l
    ), c = n.getPixelFromCoordinate(u);
    c1(c, t.startPx) > s && (d = !1);
  }
  if (d) {
    const u = f.coordinates, c = u.length, h = f.startIndex, p = l;
    if (h < p) {
      const g = qh(
        u,
        h,
        p
      );
      qh(
        u,
        h,
        p - c
      ) < g && (l -= c);
    } else {
      const g = qh(
        u,
        h,
        p
      );
      qh(
        u,
        h,
        p + c
      ) < g && (l += c);
    }
  }
  return sg.index = o, sg.endIndex = l, sg;
}
function td(e, t, n, s) {
  const r = e[0], i = e[1];
  for (let a = 0, o = t.length - 1; a < o; ++a) {
    const l = t[a], f = t[a + 1], d = gI(r, i, l, f);
    if (d.squaredDistance === 0) {
      const u = a + d.along;
      s.push({
        coordinates: t,
        ring: n,
        startIndex: u,
        endIndex: u
      });
      return;
    }
  }
}
const ag = { along: 0, squaredDistance: 0 };
function gI(e, t, n, s) {
  const r = n[0], i = n[1], a = s[0], o = s[1], l = a - r, f = o - i;
  let d = 0, u = r, c = i;
  return (l !== 0 || f !== 0) && (d = dn(((e - r) * l + (t - i) * f) / (l * l + f * f), 0, 1), u += l * d, c += f * d), ag.along = d, ag.squaredDistance = Lf(Xs(e, t, u, c), 10), ag;
}
function Fl(e, t) {
  const n = e.length;
  let s = Math.floor(t);
  const r = t - s;
  s >= n ? s -= n : s < 0 && (s += n);
  let i = s + 1;
  i >= n && (i -= n);
  const a = e[s], o = a[0], l = a[1], f = e[i], d = f[0] - o, u = f[1] - l;
  return [o + d * r, l + u * r];
}
class Y8 extends tl {
  /**
   * @param {Options} options Options.
   */
  constructor(t) {
    const n = (
      /** @type {import("./Pointer.js").Options} */
      t
    );
    n.stopDown || (n.stopDown = uu), super(n), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = t.source ? t.source : null, this.features_ = t.features ? t.features : null, this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    t.type, this.mode_ = Z8(this.type_), this.stopClick_ = !!t.stopClick, this.minPoints_ = t.minPoints ? t.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : t.maxPoints ? t.maxPoints : 1 / 0, this.finishCondition_ = t.finishCondition ? t.finishCondition : ms, this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
    let s = t.geometryFunction;
    if (!s) {
      const r = this.mode_;
      if (r === "Circle")
        s = function(i, a, o) {
          const l = a || new yS([NaN, NaN]), f = Ar(i[0]), d = u1(
            f,
            Ar(i[i.length - 1])
          );
          return l.setCenterAndRadius(
            f,
            Math.sqrt(d),
            this.geometryLayout_
          ), l;
        };
      else {
        let i;
        r === "Point" ? i = hi : r === "LineString" ? i = er : r === "Polygon" && (i = rr), s = function(a, o, l) {
          return o ? r === "Polygon" ? a[0].length ? o.setCoordinates(
            [a[0].concat([a[0][0]])],
            this.geometryLayout_
          ) : o.setCoordinates([], this.geometryLayout_) : o.setCoordinates(a, this.geometryLayout_) : o = new i(a, this.geometryLayout_), o;
        };
      }
    }
    this.geometryFunction_ = s, this.dragVertexDelay_ = t.dragVertexDelay !== void 0 ? t.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36, this.overlay_ = new sr({
      source: new Ur({
        useSpatialIndex: !1,
        wrapX: t.wrapX ? t.wrapX : !1
      }),
      style: t.style ? t.style : X8(),
      updateWhileInteracting: !0
    }), this.geometryName_ = t.geometryName, this.condition_ = t.condition ? t.condition : zy, this.freehandCondition_, t.freehand ? this.freehandCondition_ = Fd : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : Ky, this.traceCondition_, this.setTrace(t.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = t.traceSource || t.source || null, this.addChangeListener(Bd.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(t) {
    let n;
    t ? t === !0 ? n = Fd : n = t : n = Hg, this.traceCondition_ = n;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(t) {
    super.setMap(t), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(t) {
    t.originalEvent.type === Kt.CONTEXTMENU && t.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(t);
    let n = t.type === Pe.POINTERMOVE, s = !0;
    return !this.freehand_ && this.lastDragTime_ && t.type === Pe.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel, this.shouldHandle_ = !this.freehand_, n = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && t.type === Pe.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(t.coordinate), s = !1) : this.freehand_ && t.type === Pe.POINTERDOWN ? s = !1 : n && this.getPointerCount() < 2 ? (s = t.type === Pe.POINTERMOVE, s && this.freehand_ ? (this.handlePointerMove_(t), this.shouldHandle_ && t.originalEvent.preventDefault()) : (t.originalEvent.pointerType === "mouse" || t.type === Pe.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(t)) : t.type === Pe.DBLCLICK && (s = !1), super.handleEvent(t) && s;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(
      (function() {
        this.handlePointerMove_(
          new js(
            Pe.POINTERMOVE,
            t.map,
            t.originalEvent,
            !1,
            t.frameState
          )
        );
      }).bind(this),
      this.dragVertexDelay_
    ), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(t) {
    if (!this.traceSource_ || !this.traceCondition_(t))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const n = this.getMap(), s = n.getCoordinateFromPixel([
      t.pixel[0] - this.snapTolerance_,
      t.pixel[1] + this.snapTolerance_
    ]), r = n.getCoordinateFromPixel([
      t.pixel[0] + this.snapTolerance_,
      t.pixel[1] - this.snapTolerance_
    ]), i = Jl([s, r]), a = this.traceSource_.getFeaturesInExtent(i);
    if (a.length === 0)
      return;
    const o = k8(t.coordinate, a);
    o.length && (this.traceState_ = {
      active: !0,
      startPx: t.pixel.slice(),
      targets: o,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(t, n) {
    const s = t.startIndex <= t.endIndex, r = t.startIndex <= n;
    s === r ? s && n > t.endIndex || !s && n < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, n) : (s && n < t.endIndex || !s && n > t.endIndex) && this.removeTracedCoordinates_(n, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex), this.addTracedCoordinates_(t, t.startIndex, n));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(t, n) {
    if (t === n)
      return;
    let s = 0;
    if (t < n) {
      const r = Math.ceil(t);
      let i = Math.floor(n);
      i === n && (i -= 1), s = i - r + 1;
    } else {
      const r = Math.floor(t);
      let i = Math.ceil(n);
      i === n && (i += 1), s = r - i + 1;
    }
    s > 0 && this.removeLastPoints_(s);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(t, n, s) {
    if (n === s)
      return;
    const r = [];
    if (n < s) {
      const i = Math.ceil(n);
      let a = Math.floor(s);
      a === s && (a -= 1);
      for (let o = i; o <= a; ++o)
        r.push(Bl(t.coordinates, o));
    } else {
      const i = Math.floor(n);
      let a = Math.ceil(s);
      a === s && (a += 1);
      for (let o = i; o >= a; --o)
        r.push(Bl(t.coordinates, o));
    }
    r.length && this.appendCoordinates(r);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(t) {
    const n = this.traceState_;
    if (!n.active || n.targetIndex === -1 && c1(n.startPx, t.pixel) < this.snapTolerance_)
      return;
    const s = H8(
      t.coordinate,
      n,
      this.getMap(),
      this.snapTolerance_
    );
    if (n.targetIndex !== s.index) {
      if (n.targetIndex !== -1) {
        const l = n.targets[n.targetIndex];
        this.removeTracedCoordinates_(l.startIndex, l.endIndex);
      }
      const o = n.targets[s.index];
      this.addTracedCoordinates_(
        o,
        o.startIndex,
        s.endIndex
      );
    } else {
      const o = n.targets[n.targetIndex];
      this.addOrRemoveTracedCoordinates_(o, s.endIndex);
    }
    n.targetIndex = s.index;
    const r = n.targets[n.targetIndex];
    r.endIndex = s.endIndex;
    const i = Fl(
      r.coordinates,
      r.endIndex
    ), a = this.getMap().getPixelFromCoordinate(i);
    t.coordinate = i, t.pixel = [Math.round(a[0]), Math.round(a[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    let n = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t);
      const s = this.traceState_.active;
      if (this.toggleTraceState_(t), this.shouldHandle_) {
        const r = !this.finishCoordinate_;
        r && this.startDrawing_(t.coordinate), !r && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!r || this.mode_ === "Point") && (this.atFinish_(t.pixel, s) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)), n = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !n && this.stopClick_ && t.preventDefault(), n;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(t) {
    if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const n = this.downPx_, s = t.pixel, r = n[0] - s[0], i = n[1] - s[1], a = r * r + i * i;
      if (this.shouldHandle_ = this.freehand_ ? a > this.squaredClickTolerance_ : a <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(t.coordinate.slice());
      return;
    }
    this.updateTrace_(t), this.modifyDrawing_(t.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(t, n) {
    let s = !1;
    if (this.sketchFeature_) {
      let r = !1, i = [this.finishCoordinate_];
      const a = this.mode_;
      if (a === "Point")
        s = !0;
      else if (a === "Circle")
        s = this.sketchCoords_.length === 2;
      else if (a === "LineString")
        r = !n && this.sketchCoords_.length > this.minPoints_;
      else if (a === "Polygon") {
        const o = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        r = o[0].length > this.minPoints_, i = [
          o[0][0],
          o[0][o[0].length - 2]
        ], n ? i = [o[0][0]] : i = [
          o[0][0],
          o[0][o[0].length - 2]
        ];
      }
      if (r) {
        const o = this.getMap();
        for (let l = 0, f = i.length; l < f; l++) {
          const d = i[l], u = o.getPixelFromCoordinate(d), c = t[0] - u[0], h = t[1] - u[1], p = this.freehand_ ? 1 : this.snapTolerance_;
          if (s = Math.sqrt(c * c + h * h) <= p, s) {
            this.finishCoordinate_ = d;
            break;
          }
        }
      }
    }
    return s;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(t) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new Pi(new hi(t)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(t) {
    this.sketchLine_ || (this.sketchLine_ = new Pi());
    const n = t.getLinearRing(0);
    let s = this.sketchLine_.getGeometry();
    s ? (s.setFlatCoordinates(
      n.getLayout(),
      n.getFlatCoordinates()
    ), s.changed()) : (s = new er(
      n.getFlatCoordinates(),
      n.getLayout()
    ), this.sketchLine_.setGeometry(s));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(t) {
    const n = this.getMap().getView().getProjection(), s = xd(this.geometryLayout_);
    for (; t.length < s; )
      t.push(0);
    this.finishCoordinate_ = t, this.mode_ === "Point" ? this.sketchCoords_ = t.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Pi(new er(this.sketchLineCoords_)));
    const r = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      n
    );
    this.sketchFeature_ = new Pi(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(r), this.updateSketchFeatures_(), this.dispatchEvent(
      new Jh(Zh.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(t) {
    const n = this.getMap(), s = this.sketchFeature_.getGeometry(), r = n.getView().getProjection(), i = xd(this.geometryLayout_);
    let a, o;
    for (; t.length < i; )
      t.push(0);
    this.mode_ === "Point" ? o = this.sketchCoords_ : this.mode_ === "Polygon" ? (a = /** @type {PolyCoordType} */
    this.sketchCoords_[0], o = a[a.length - 1], this.atFinish_(n.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (a = this.sketchCoords_, o = a[a.length - 1]), o[0] = t[0], o[1] = t[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      s,
      r
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(t), s.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      s
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(t) {
    const n = this.sketchFeature_.getGeometry(), s = this.getMap().getView().getProjection();
    let r, i;
    const a = this.mode_;
    a === "LineString" || a === "Circle" ? (this.finishCoordinate_ = t.slice(), i = /** @type {LineCoordType} */
    this.sketchCoords_, i.length >= this.maxPoints_ && (this.freehand_ ? i.pop() : r = !0), i.push(t.slice()), this.geometryFunction_(i, n, s)) : a === "Polygon" && (i = /** @type {PolyCoordType} */
    this.sketchCoords_[0], i.length >= this.maxPoints_ && (this.freehand_ ? i.pop() : r = !0), i.push(t.slice()), r && (this.finishCoordinate_ = i[0]), this.geometryFunction_(this.sketchCoords_, n, s)), this.createOrUpdateSketchPoint_(t.slice()), this.updateSketchFeatures_(), r && this.finishDrawing();
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(t) {
    if (!this.sketchFeature_)
      return;
    const n = this.sketchFeature_.getGeometry(), s = this.getMap().getView().getProjection(), r = this.mode_;
    for (let i = 0; i < t; ++i) {
      let a;
      if (r === "LineString" || r === "Circle") {
        if (a = /** @type {LineCoordType} */
        this.sketchCoords_, a.splice(-2, 1), a.length >= 2) {
          this.finishCoordinate_ = a[a.length - 2].slice();
          const o = this.finishCoordinate_.slice();
          a[a.length - 1] = o, this.createOrUpdateSketchPoint_(o);
        }
        this.geometryFunction_(a, n, s), n.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          n
        );
      } else if (r === "Polygon") {
        a = /** @type {PolyCoordType} */
        this.sketchCoords_[0], a.splice(-2, 1);
        const o = this.sketchLine_.getGeometry();
        if (a.length >= 2) {
          const l = a[a.length - 2].slice();
          a[a.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        o.setCoordinates(a), this.geometryFunction_(this.sketchCoords_, n, s);
      }
      if (a.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const t = this.abortDrawing_();
    if (!t)
      return;
    let n = this.sketchCoords_;
    const s = t.getGeometry(), r = this.getMap().getView().getProjection();
    this.mode_ === "LineString" ? (n.pop(), this.geometryFunction_(n, s, r)) : this.mode_ === "Polygon" && (n[0].pop(), this.geometryFunction_(n, s, r), n = s.getCoordinates()), this.type_ === "MultiPoint" ? t.setGeometry(
      new Eu([
        /** @type {PointCoordType} */
        n
      ])
    ) : this.type_ === "MultiLineString" ? t.setGeometry(
      new na([
        /** @type {LineCoordType} */
        n
      ])
    ) : this.type_ === "MultiPolygon" && t.setGeometry(
      new ia([
        /** @type {PolyCoordType} */
        n
      ])
    ), this.dispatchEvent(new Jh(Zh.DRAWEND, t)), this.features_ && this.features_.push(t), this.source_ && this.source_.addFeature(t);
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const t = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), t;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const t = this.abortDrawing_();
    t && this.dispatchEvent(new Jh(Zh.DRAWABORT, t));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(t) {
    const n = this.mode_, s = !this.sketchFeature_;
    s && this.startDrawing_(t[0]);
    let r;
    if (n === "LineString" || n === "Circle")
      r = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (n === "Polygon")
      r = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    s && r.shift(), r.pop();
    for (let a = 0; a < t.length; a++)
      this.addToDrawing_(t[a]);
    const i = t[t.length - 1];
    this.addToDrawing_(i), this.modifyDrawing_(i);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(t) {
    const s = t.getGeometry();
    this.sketchFeature_ = t, this.sketchCoords_ = s.getCoordinates();
    const r = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = r.slice(), this.sketchCoords_.push(r.slice()), this.sketchPoint_ = new Pi(new hi(r)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Jh(Zh.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const t = [];
    this.sketchFeature_ && t.push(this.sketchFeature_), this.sketchLine_ && t.push(this.sketchLine_), this.sketchPoint_ && t.push(this.sketchPoint_);
    const n = this.overlay_.getSource();
    n.clear(!0), n.addFeatures(t);
  }
  /**
   * @private
   */
  updateState_() {
    const t = this.getMap(), n = this.getActive();
    (!t || !n) && this.abortDrawing(), this.overlay_.setMap(n ? t : null);
  }
}
function X8() {
  const e = B1();
  return function(t, n) {
    return e[t.getGeometry().getType()];
  };
}
function Z8(e) {
  switch (e) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + e);
  }
}
const J8 = Y8, Q8 = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class q8 extends Wi {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(t, n, s, r) {
    super(t), this.selected = n, this.deselected = s, this.mapBrowserEvent = r;
  }
}
const ed = {};
class ME extends du {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    super(), this.on, this.once, this.un, t = t || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = t.condition ? t.condition : MR, this.addCondition_ = t.addCondition ? t.addCondition : Hg, this.removeCondition_ = t.removeCondition ? t.removeCondition : Hg, this.toggleCondition_ = t.toggleCondition ? t.toggleCondition : Ky, this.multi_ = t.multi ? t.multi : !1, this.filter_ = t.filter ? t.filter : ms, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.style_ = t.style !== void 0 ? t.style : t6(), this.features_ = t.features || new Fi();
    let n;
    if (t.layers)
      if (typeof t.layers == "function")
        n = t.layers;
      else {
        const s = t.layers;
        n = function(r) {
          return s.includes(r);
        };
      }
    else
      n = ms;
    this.layerFilter_ = n, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(t, n) {
    this.featureLayerAssociation_[Xt(t)] = n;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(t) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[Xt(t)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(t) {
    this.hitTolerance_ = t;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(t) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(t), t ? (this.features_.addEventListener(
      zn.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      zn.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      zn.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      zn.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(t) {
    const n = t.element;
    if (this.style_ && this.applySelectedStyle_(n), !this.getLayer(n)) {
      const s = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(r) {
          if (r instanceof sr && r.getSource() && r.getSource().hasFeature(n))
            return r;
        })
      );
      s && this.addFeatureLayerAssociation_(n, s);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(t) {
    this.style_ && this.restorePreviousStyle_(t.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(t) {
    const n = Xt(t);
    n in ed || (ed[n] = t.getStyle()), t.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(t) {
    const n = this.getMap().getInteractions().getArray();
    for (let r = n.length - 1; r >= 0; --r) {
      const i = n[r];
      if (i !== this && i instanceof ME && i.getStyle() && i.getFeatures().getArray().lastIndexOf(t) !== -1) {
        t.setStyle(i.getStyle());
        return;
      }
    }
    const s = Xt(t);
    t.setStyle(ed[s]), delete ed[s];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(t) {
    delete this.featureLayerAssociation_[Xt(t)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {Select}
   */
  handleEvent(t) {
    if (!this.condition_(t))
      return !0;
    const n = this.addCondition_(t), s = this.removeCondition_(t), r = this.toggleCondition_(t), i = !n && !s && !r, a = t.map, o = this.getFeatures(), l = [], f = [];
    if (i) {
      cu(this.featureLayerAssociation_), a.forEachFeatureAtPixel(
        t.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (function(d, u) {
          if (!(!(d instanceof Pi) || !this.filter_(d, u)))
            return this.addFeatureLayerAssociation_(d, u), f.push(d), !this.multi_;
        }).bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = o.getLength() - 1; d >= 0; --d) {
        const u = o.item(d), c = f.indexOf(u);
        c > -1 ? f.splice(c, 1) : (o.remove(u), l.push(u));
      }
      f.length !== 0 && o.extend(f);
    } else {
      a.forEachFeatureAtPixel(
        t.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (function(d, u) {
          if (!(!(d instanceof Pi) || !this.filter_(d, u)))
            return (n || r) && !o.getArray().includes(d) ? (this.addFeatureLayerAssociation_(d, u), f.push(d)) : (s || r) && o.getArray().includes(d) && (l.push(d), this.removeFeatureLayerAssociation_(d)), !this.multi_;
        }).bind(this),
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = l.length - 1; d >= 0; --d)
        o.remove(l[d]);
      o.extend(f);
    }
    return (f.length > 0 || l.length > 0) && this.dispatchEvent(
      new q8(
        Q8.SELECT,
        f,
        l,
        t
      )
    ), !0;
  }
}
function t6() {
  const e = B1();
  return Kn(e.Polygon, e.LineString), Kn(e.GeometryCollection, e.LineString), function(t) {
    return t.getGeometry() ? e[t.getGeometry().getType()] : null;
  };
}
const e6 = ME, og = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: "translatestart",
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: "translating",
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: "translateend"
};
class lg extends Wi {
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<import("../Feature.js").default>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */
  constructor(t, n, s, r, i) {
    super(t), this.features = n, this.coordinate = s, this.startCoordinate = r, this.mapBrowserEvent = i;
  }
}
class n6 extends tl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(t) {
    t = t || {}, super(
      /** @type {import("./Pointer.js").Options} */
      t
    ), this.on, this.once, this.un, this.lastCoordinate_ = null, this.startCoordinate_ = null, this.features_ = t.features !== void 0 ? t.features : null;
    let n;
    if (t.layers && !this.features_)
      if (typeof t.layers == "function")
        n = t.layers;
      else {
        const s = t.layers;
        n = function(r) {
          return s.includes(r);
        };
      }
    else
      n = ms;
    this.layerFilter_ = n, this.filter_ = t.filter && !this.features_ ? t.filter : ms, this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0, this.condition_ = t.condition ? t.condition : Fd, this.lastFeature_ = null, this.addChangeListener(
      Bd.ACTIVE,
      this.handleActiveChanged_
    );
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(t) {
    if (!t.originalEvent || !this.condition_(t))
      return !1;
    if (this.lastFeature_ = this.featuresAtPixel_(t.pixel, t.map), !this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = t.coordinate, this.lastCoordinate_ = t.coordinate, this.handleMoveEvent(t);
      const n = this.features_ || new Fi([this.lastFeature_]);
      return this.dispatchEvent(
        new lg(
          og.TRANSLATESTART,
          n,
          t.coordinate,
          this.startCoordinate_,
          t
        )
      ), !0;
    }
    return !1;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(t) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null, this.handleMoveEvent(t);
      const n = this.features_ || new Fi([this.lastFeature_]);
      return this.dispatchEvent(
        new lg(
          og.TRANSLATEEND,
          n,
          t.coordinate,
          this.startCoordinate_,
          t
        )
      ), this.startCoordinate_ = null, !0;
    }
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleDragEvent(t) {
    if (this.lastCoordinate_) {
      const n = t.coordinate, s = n[0] - this.lastCoordinate_[0], r = n[1] - this.lastCoordinate_[1], i = this.features_ || new Fi([this.lastFeature_]);
      i.forEach(function(a) {
        const o = a.getGeometry();
        o.translate(s, r), a.setGeometry(o);
      }), this.lastCoordinate_ = n, this.dispatchEvent(
        new lg(
          og.TRANSLATING,
          i,
          n,
          this.startCoordinate_,
          t
        )
      );
    }
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  handleMoveEvent(t) {
    const n = t.map.getViewport();
    this.featuresAtPixel_(t.pixel, t.map) ? (n.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"), n.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab")) : n.classList.remove("ol-grab", "ol-grabbing");
  }
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../Map.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  featuresAtPixel_(t, n) {
    return n.forEachFeatureAtPixel(
      t,
      (function(s, r) {
        if (this.filter_(s, r) && (!this.features_ || this.features_.getArray().includes(s)))
          return s;
      }).bind(this),
      {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      }
    );
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(t) {
    this.hitTolerance_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(t) {
    const n = this.getMap();
    super.setMap(t), this.updateState_(n);
  }
  /**
   * @private
   */
  handleActiveChanged_() {
    this.updateState_(null);
  }
  /**
   * @param {import("../Map.js").default} oldMap Old map.
   * @private
   */
  updateState_(t) {
    let n = this.getMap();
    const s = this.getActive();
    (!n || !s) && (n = n || t, n && n.getViewport().classList.remove("ol-grab", "ol-grabbing"));
  }
}
const i6 = n6;
function r6(e, t) {
  return e ? [new Yg(), new Xg()] : [
    new Yg({
      condition: function() {
        return t ? this.getPointerCount() > 1 : !0;
      }
    }),
    new Xg({
      condition: _R
    })
  ];
}
const yf = 480, Ef = 768, s6 = "#008A8A", a6 = "#00A95C", vO = [23, 32], o6 = "data:image/svg+xml,", vI = ({ stroke: e = "#FFF", strokeWidth: t = "2", fill: n = "#005CA9" }) => `${o6}${encodeURIComponent(`
<svg width="${vO[0]}" height="${vO[1]}" viewBox="0 0 30 43" xmlns="http://www.w3.org/2000/svg">
  <title>DB6C494E-88E8-49F1-89CE-97CBEC3A5240</title>
  <path
    d="M14.584 1C7.101 1 1 7.101 1 14.584c0 8.103 7.865 20.448 11.63 25.93a2.36 2.36 0 0 0 3.908 0c3.766-5.482 11.63-17.922 11.63-25.93C28.168 7.054 22.068 1 14.584 1z"
    stroke="${e}"
    stroke-width="${t}"
    fill="${n}"
    fill-rule="nonzero"
  />
</svg>
`)}`, yI = [0.5, 1], l6 = (e = s6) => new Mn({
  image: new vs({
    src: vI({ fill: e }),
    anchor: yI
  })
}), u6 = (e = a6) => new Mn({
  image: new vs({
    src: vI({ fill: e }),
    anchor: yI
  })
});
let nd = null, yo = null, Bs = null;
function c6({ getters: e, commit: t }, {
  hoverFill: n,
  layers: s,
  selectionFill: r
}) {
  const { map: i } = e;
  i.on("pointermove", function(a) {
    const o = i.getFeaturesAtPixel(a.pixel, {
      layerFilter: (l) => s.includes(l.get("id"))
    })[0];
    o === Bs || o instanceof Tc || (yo !== null && yo !== Bs && (yo.setStyle(void 0), yo = null, t("setHovered", yo)), o && (yo = o, t("setHovered", yo), o.setStyle(l6(n))));
  }), i.on("click", function(a) {
    Bs !== null && (Bs.setStyle(void 0), Bs = null, t("setSelected", Bs));
    const o = i.getFeaturesAtPixel(a.pixel, {
      layerFilter: (l) => s.includes(l.get("id"))
    })[0];
    !o || o instanceof Tc || (Bs = o, t("setSelected", Bs), Bs.setStyle(u6(r)), nd = a, a.stopPropagation());
  }), i.on("singleclick", function(a) {
    (a == null ? void 0 : a.originalEvent) === (nd == null ? void 0 : nd.originalEvent) && a.stopPropagation();
  });
}
let as = null, yO = null, EO = null, ug = [], cg = [];
const h6 = (e) => {
};
$t.use(r8);
const hg = () => ({
  map: 1,
  clientHeight: 0,
  clientWidth: 0,
  components: 1,
  center: null,
  hovered: 1,
  selected: 1,
  zoomLevel: 0,
  // TODO: Add default values for epsg, layers, namedProjections, options and remove @ts-ignore for configuration
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  configuration: {},
  hasSmallDisplay: !1,
  errors: [],
  language: ""
}), dg = ({ map: e }) => mp.commit("setCenter", e.getView().getCenter()), fg = ({ map: e }) => mp.commit("setZoomLevel", e.getView().getZoom()), mp = new ki({
  state: hg(),
  plugins: [h6],
  // vuex plugins, not polar plugins
  modules: {
    capabilities: G8,
    /* reserved for plugins */
    plugin: {
      namespaced: !0
    }
  },
  getters: {
    ...Hi(hg()),
    // hack: deliver map (outside vuex) based on counter; see NOTE above
    map: (e) => (Vl(e.map), as),
    hovered: (e) => (Vl(e.hovered), yO),
    selected: (e) => (Vl(e.selected), EO),
    // hack: deliver components (outside vuex) based on counter; see NOTE above
    components: (e) => (Vl(e.components), ug),
    // TODO: Both will possibly be updated with different breakpoints
    hasSmallHeight: (e) => e.clientHeight <= yf,
    hasSmallWidth: (e) => e.clientWidth <= Ef,
    hasWindowSize(e) {
      return window.innerHeight === e.clientHeight && window.innerWidth === e.clientWidth;
    }
  },
  mutations: {
    ...Or(hg()),
    setMap: (e, t) => {
      as && (as.un("moveend", dg), as.un("moveend", fg)), as = t, as && (as.on("moveend", dg), as.on("moveend", fg), dg({ map: as }), fg({ map: as })), e.map = e.map + 1;
    },
    setHovered: (e, t) => {
      yO = t, e.hovered = e.hovered + 1;
    },
    setSelected: (e, t) => {
      EO = t, e.selected = e.selected + 1;
    },
    setComponents: (e, t) => {
      ug = t, e.components = e.components + 1;
    },
    addError: (e, t) => {
      e.errors.push(t);
    }
  },
  actions: {
    addComponent({ state: e, commit: t, dispatch: n }, s) {
      const { language: r, name: i, options: a, storeModule: o } = s;
      if (t("setConfiguration", {
        ...e.configuration,
        [i]: Bc({}, a, e.configuration[i] || {})
      }), o) {
        this.registerModule(["plugin", i], o);
        const l = `plugin/${i}/setupModule`;
        Object.keys(this._actions).includes(
          l
        ) && n(l, a);
      }
      r && r.forEach((l) => {
        qe.addResourceBundle(l.type, "common", l.resources, !0);
      }), e.configuration[i].displayComponent && t("setComponents", [...ug, s]);
    },
    updateDragAndZoomInteractions({ getters: e }) {
      cg.forEach((t) => e.map.removeInteraction(t)), cg = r6(
        e.hasWindowSize,
        window.innerHeight <= yf || window.innerWidth <= Ef
      ), cg.forEach((t) => e.map.addInteraction(t));
    },
    useExtendedMasterportalapiMarkers: c6
  }
});
qe.on("languageChanged", (e) => {
  mp.commit("setLanguage", e);
});
var EI = [], d6 = EI.forEach, f6 = EI.slice;
function p6(e) {
  return d6.call(f6.call(arguments, 1), function(t) {
    if (t)
      for (var n in t)
        e[n] === void 0 && (e[n] = t[n]);
  }), e;
}
var CO = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, m6 = function(t, n, s) {
  var r = s || {};
  r.path = r.path || "/";
  var i = encodeURIComponent(n), a = "".concat(t, "=").concat(i);
  if (r.maxAge > 0) {
    var o = r.maxAge - 0;
    if (Number.isNaN(o))
      throw new Error("maxAge should be a Number");
    a += "; Max-Age=".concat(Math.floor(o));
  }
  if (r.domain) {
    if (!CO.test(r.domain))
      throw new TypeError("option domain is invalid");
    a += "; Domain=".concat(r.domain);
  }
  if (r.path) {
    if (!CO.test(r.path))
      throw new TypeError("option path is invalid");
    a += "; Path=".concat(r.path);
  }
  if (r.expires) {
    if (typeof r.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    a += "; Expires=".concat(r.expires.toUTCString());
  }
  if (r.httpOnly && (a += "; HttpOnly"), r.secure && (a += "; Secure"), r.sameSite) {
    var l = typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite;
    switch (l) {
      case !0:
        a += "; SameSite=Strict";
        break;
      case "lax":
        a += "; SameSite=Lax";
        break;
      case "strict":
        a += "; SameSite=Strict";
        break;
      case "none":
        a += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return a;
}, xO = {
  create: function(t, n, s, r) {
    var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    s && (i.expires = /* @__PURE__ */ new Date(), i.expires.setTime(i.expires.getTime() + s * 60 * 1e3)), r && (i.domain = r), document.cookie = m6(t, encodeURIComponent(n), i);
  },
  read: function(t) {
    for (var n = "".concat(t, "="), s = document.cookie.split(";"), r = 0; r < s.length; r++) {
      for (var i = s[r]; i.charAt(0) === " "; )
        i = i.substring(1, i.length);
      if (i.indexOf(n) === 0)
        return i.substring(n.length, i.length);
    }
    return null;
  },
  remove: function(t) {
    this.create(t, "", -1);
  }
}, g6 = {
  name: "cookie",
  lookup: function(t) {
    var n;
    if (t.lookupCookie && typeof document < "u") {
      var s = xO.read(t.lookupCookie);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupCookie && typeof document < "u" && xO.create(n.lookupCookie, t, n.cookieMinutes, n.cookieDomain, n.cookieOptions);
  }
}, v6 = {
  name: "querystring",
  lookup: function(t) {
    var n;
    if (typeof window < "u") {
      var s = window.location.search;
      !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (s = window.location.hash.substring(window.location.hash.indexOf("?")));
      for (var r = s.substring(1), i = r.split("&"), a = 0; a < i.length; a++) {
        var o = i[a].indexOf("=");
        if (o > 0) {
          var l = i[a].substring(0, o);
          l === t.lookupQuerystring && (n = i[a].substring(o + 1));
        }
      }
    }
    return n;
  }
}, Gu = null, bO = function() {
  if (Gu !== null)
    return Gu;
  try {
    Gu = window !== "undefined" && window.localStorage !== null;
    var t = "i18next.translate.boo";
    window.localStorage.setItem(t, "foo"), window.localStorage.removeItem(t);
  } catch {
    Gu = !1;
  }
  return Gu;
}, y6 = {
  name: "localStorage",
  lookup: function(t) {
    var n;
    if (t.lookupLocalStorage && bO()) {
      var s = window.localStorage.getItem(t.lookupLocalStorage);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupLocalStorage && bO() && window.localStorage.setItem(n.lookupLocalStorage, t);
  }
}, ku = null, TO = function() {
  if (ku !== null)
    return ku;
  try {
    ku = window !== "undefined" && window.sessionStorage !== null;
    var t = "i18next.translate.boo";
    window.sessionStorage.setItem(t, "foo"), window.sessionStorage.removeItem(t);
  } catch {
    ku = !1;
  }
  return ku;
}, E6 = {
  name: "sessionStorage",
  lookup: function(t) {
    var n;
    if (t.lookupSessionStorage && TO()) {
      var s = window.sessionStorage.getItem(t.lookupSessionStorage);
      s && (n = s);
    }
    return n;
  },
  cacheUserLanguage: function(t, n) {
    n.lookupSessionStorage && TO() && window.sessionStorage.setItem(n.lookupSessionStorage, t);
  }
}, C6 = {
  name: "navigator",
  lookup: function(t) {
    var n = [];
    if (typeof navigator < "u") {
      if (navigator.languages)
        for (var s = 0; s < navigator.languages.length; s++)
          n.push(navigator.languages[s]);
      navigator.userLanguage && n.push(navigator.userLanguage), navigator.language && n.push(navigator.language);
    }
    return n.length > 0 ? n : void 0;
  }
}, x6 = {
  name: "htmlTag",
  lookup: function(t) {
    var n, s = t.htmlTag || (typeof document < "u" ? document.documentElement : null);
    return s && typeof s.getAttribute == "function" && (n = s.getAttribute("lang")), n;
  }
}, b6 = {
  name: "path",
  lookup: function(t) {
    var n;
    if (typeof window < "u") {
      var s = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (s instanceof Array)
        if (typeof t.lookupFromPathIndex == "number") {
          if (typeof s[t.lookupFromPathIndex] != "string")
            return;
          n = s[t.lookupFromPathIndex].replace("/", "");
        } else
          n = s[0].replace("/", "");
    }
    return n;
  }
}, T6 = {
  name: "subdomain",
  lookup: function(t) {
    var n = typeof t.lookupFromSubdomainIndex == "number" ? t.lookupFromSubdomainIndex + 1 : 1, s = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (s)
      return s[n];
  }
};
function O6() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"]
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
  };
}
var CI = /* @__PURE__ */ function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Gr(this, e), this.type = "languageDetector", this.detectors = {}, this.init(t, n);
  }
  return kr(e, [{
    key: "init",
    value: function(n) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n, this.options = p6(s, this.options || {}, O6()), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = r, this.addDetector(g6), this.addDetector(v6), this.addDetector(y6), this.addDetector(E6), this.addDetector(C6), this.addDetector(x6), this.addDetector(b6), this.addDetector(T6);
    }
  }, {
    key: "addDetector",
    value: function(n) {
      this.detectors[n.name] = n;
    }
  }, {
    key: "detect",
    value: function(n) {
      var s = this;
      n || (n = this.options.order);
      var r = [];
      return n.forEach(function(i) {
        if (s.detectors[i]) {
          var a = s.detectors[i].lookup(s.options);
          a && typeof a == "string" && (a = [a]), a && (r = r.concat(a));
        }
      }), this.services.languageUtils.getBestMatchFromCodes ? r : r.length > 0 ? r[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function(n, s) {
      var r = this;
      s || (s = this.options.caches), s && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(n) > -1 || s.forEach(function(i) {
        r.detectors[i] && r.detectors[i].cacheUserLanguage(n, r.options);
      }));
    }
  }]), e;
}();
CI.type = "languageDetector";
var P6 = function(t) {
  return S6(t) && !M6(t);
};
function S6(e) {
  return !!e && typeof e == "object";
}
function M6(e) {
  var t = Object.prototype.toString.call(e);
  return t === "[object RegExp]" || t === "[object Date]" || D6(e);
}
var _6 = typeof Symbol == "function" && Symbol.for, I6 = _6 ? Symbol.for("react.element") : 60103;
function D6(e) {
  return e.$$typeof === I6;
}
function A6(e) {
  return Array.isArray(e) ? [] : {};
}
function Cf(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? Fc(A6(e), e, t) : e;
}
function L6(e, t, n) {
  return e.concat(t).map(function(s) {
    return Cf(s, n);
  });
}
function R6(e, t, n) {
  var s = {};
  return n.isMergeableObject(e) && Object.keys(e).forEach(function(r) {
    s[r] = Cf(e[r], n);
  }), Object.keys(t).forEach(function(r) {
    !n.isMergeableObject(t[r]) || !e[r] ? s[r] = Cf(t[r], n) : s[r] = Fc(e[r], t[r], n);
  }), s;
}
function Fc(e, t, n) {
  n = n || {}, n.arrayMerge = n.arrayMerge || L6, n.isMergeableObject = n.isMergeableObject || P6;
  var s = Array.isArray(t), r = Array.isArray(e), i = s === r;
  return i ? s ? n.arrayMerge(e, t, n) : R6(e, t, n) : Cf(t, n);
}
Fc.all = function(t, n) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(s, r) {
    return Fc(s, r, n);
  }, {});
};
var OO = Fc, PO = {
  name: "i18next",
  functional: !0,
  props: {
    tag: {
      type: String,
      default: "span"
    },
    path: {
      type: String,
      required: !0
    },
    options: {
      type: Object
    }
  },
  render: function(t, n) {
    var s = n.props, r = n.data, i = n.children, a = n.parent, o = a.$i18n, l = a.$t.bind(a);
    if (!o || !l)
      return t(s.tag, r, i);
    var f = s.path, d = s.options || {}, u = o.i18next.services.interpolator.regexp, c = Object.assign(
      {},
      d,
      { interpolation: { prefix: "#$?", suffix: "?$#" } }
    ), h = l(f, c), p = [];
    return h.split(u).reduce(function(g, m, v) {
      var y;
      if (v % 2 === 0) {
        if (m.length === 0)
          return g;
        y = m;
      } else {
        var E = m.trim();
        isNaN(parseFloat(E)) || !isFinite(E) ? i.forEach(function(C) {
          !y && C.data.attrs && C.data.attrs.place && C.data.attrs.place === E && (y = C);
        }) : y = i[parseInt(m, 10)];
      }
      return g.push(y), g;
    }, p), t(s.tag, r, p);
  }
};
function xI(e) {
  typeof console < "u" && console.warn(e);
}
function xf(e) {
  xI("[vue-i18next warn]: " + e);
}
function w6(e) {
  xI("[vue-i18next deprecated]: " + e);
}
function V6(e, t) {
  var n = t.context;
  return e._i18nLanguage === n.$i18n.i18next.language;
}
function B6(e, t) {
  if (e === t)
    return !0;
  if (e && t)
    return e.path === t.path && e.language === t.language && e.args === t.args;
}
function F6(e) {
  var t = e.context;
  return t.$i18n ? !0 : (xf("No VueI18Next instance found in the Vue instance"), !1);
}
function N6(e) {
  var t, n, s, r;
  return typeof e == "string" ? n = e : toString.call(e) === "[object Object]" && (t = e, n = t.path, s = t.language, r = t.args), { path: n, language: s, args: r };
}
function bI(e, t, n) {
  var s = t.value, r = N6(s), i = r.path, a = r.language, o = r.args;
  if (!i && !a && !o) {
    xf("v-t: invalid value");
    return;
  }
  if (!i) {
    xf('v-t: "path" is required');
    return;
  }
  a && w6(`v-t: "language" is deprecated.Use the "lng" property in args.
      https://www.i18next.com/overview/configuration-options#configuration-options`);
  var l = n.context;
  e.textContent = l.$i18n.i18next.t(i, Object.assign(
    {},
    a ? { lng: a } : {},
    o
  )), e._i18nLanguage = l.$i18n.i18next.language;
}
function j6(e, t, n) {
  F6(n) && bI(e, t, n);
}
function $6(e, t, n, s) {
  V6(e, n) && B6(t.value, t.oldValue) || bI(e, t, n);
}
var U6 = {
  bind: j6,
  update: $6
};
function W6(e) {
  var t = e.context;
  return t.$i18n ? !0 : (xf("No VueI18Next instance found in the Vue instance"), !1);
}
function z6(e, t) {
  if (t.context.$i18n.i18next.isInitialized)
    e.hidden = !1;
  else {
    e.hidden = !0;
    var n = function() {
      t.context.$forceUpdate(), setTimeout(function() {
        t.context && t.context.$i18n && t.context.$i18n.i18next.off("initialized", n);
      }, 1e3);
    };
    t.context.$i18n.i18next.on("initialized", n);
  }
}
function K6(e, t, n) {
  W6(n) && z6(e, n);
}
function G6(e, t, n, s) {
  n.context.$i18n.i18next.isInitialized && (e.hidden = !1);
}
var k6 = {
  bind: K6,
  update: G6
}, Ji;
function zv(e) {
  if (!zv.installed) {
    zv.installed = !0, Ji = e;
    var t = function(s, r) {
      return function(i) {
        return s && s.keyPrefix && !i.includes(r.nsSeparator) ? s.keyPrefix + "." + i : i;
      };
    }, n = function(s) {
      var r = s.$options.name || s.$options._componentTag;
      return r ? {
        namespace: r,
        loadNamespace: !0
      } : {
        namespace: "" + Math.random()
      };
    };
    Ji.mixin({
      beforeCreate: function() {
        var r = this, i = this.$options;
        i.i18n ? this._i18n = i.i18n : i.parent && i.parent.$i18n && (this._i18n = i.parent.$i18n);
        var a = {};
        if (this._i18n) {
          var o = this._i18n.options.getComponentNamespace || n, l = o(this), f = l.namespace, d = l.loadNamespace;
          if (i.__i18n && i.__i18n.forEach(function(O) {
            a = OO(
              a,
              JSON.parse(O)
            );
          }), i.i18nOptions) {
            var u = this.$options.i18nOptions, c = u.lng;
            c === void 0 && (c = null);
            var h = u.keyPrefix;
            h === void 0 && (h = null);
            var p = u.messages, g = this.$options.i18nOptions, m = g.namespaces;
            m = m || this._i18n.i18next.options.defaultNS, typeof m == "string" && (m = [m]);
            var v = m.concat([f]);
            p && (a = OO(a, p)), this._i18nOptions = { lng: c, namespaces: v, keyPrefix: h }, this._i18n.i18next.loadNamespaces(m);
          } else
            i.parent && i.parent._i18nOptions ? (this._i18nOptions = Object.assign({}, i.parent._i18nOptions), this._i18nOptions.namespaces = [
              f
            ].concat(
              this._i18nOptions.namespaces
            )) : i.__i18n && (this._i18nOptions = { namespaces: [f] });
          d && this._i18n.options.loadComponentNamespace && this._i18n.i18next.loadNamespaces([f]);
          var y = Object.keys(a);
          y.forEach(function(O) {
            r._i18n.i18next.addResourceBundle(
              O,
              f,
              Object.assign({}, a[O]),
              !0,
              !1
            );
          });
        }
        var E = t(
          this._i18nOptions,
          this._i18n ? this._i18n.i18next.options : {}
        );
        if (this._i18nOptions && this._i18nOptions.namespaces) {
          var C = this._i18nOptions, x = C.lng, b = C.namespaces, P = this._i18n.i18next.getFixedT(x, b);
          this._getI18nKey = function(O, T) {
            return P(E(O), T, r._i18n.i18nLoadedAt);
          };
        } else
          this._getI18nKey = function(O, T) {
            return r._i18n.t(E(O), T, r._i18n.i18nLoadedAt);
          };
      }
    }), Object.prototype.hasOwnProperty.call(Ji.prototype, "$i18n") || Object.defineProperty(Ji.prototype, "$i18n", {
      get: function() {
        return this._i18n;
      }
    }), Ji.prototype.$t = function(r, i) {
      return this._getI18nKey(r, i);
    }, Ji.component(PO.name, PO), Ji.directive("t", U6), Ji.directive("waitForT", k6);
  }
}
var ha = function(t, n) {
  n === void 0 && (n = {});
  var s = Object.assign(
    {},
    {
      bindI18n: "languageChanged loaded",
      bindStore: "added removed",
      loadComponentNamespace: !1
    },
    n
  );
  this._vm = null, this.i18next = t, this.options = s, this.onI18nChanged = this.onI18nChanged.bind(this), s.bindI18n && this.i18next.on(s.bindI18n, this.onI18nChanged), s.bindStore && this.i18next.store && this.i18next.store.on(s.bindStore, this.onI18nChanged), this.resetVM({ i18nLoadedAt: /* @__PURE__ */ new Date() });
}, _E = { i18nLoadedAt: { configurable: !0 } };
ha.prototype.resetVM = function(t) {
  var n = this._vm, s = Ji.config, r = s.silent;
  Ji.config.silent = !0, this._vm = new Ji({ data: t }), Ji.config.silent = r, n && Ji.nextTick(function() {
    return n.$destroy();
  });
};
_E.i18nLoadedAt.get = function() {
  return this._vm.$data.i18nLoadedAt;
};
_E.i18nLoadedAt.set = function(e) {
  this._vm.$set(this._vm, "i18nLoadedAt", e);
};
ha.prototype.t = function(t, n) {
  return this.i18next.t(t, n);
};
ha.prototype.onI18nChanged = function() {
  this.i18nLoadedAt = /* @__PURE__ */ new Date();
};
Object.defineProperties(ha.prototype, _E);
ha.install = zv;
ha.version = "0.15.2";
typeof window < "u" && window.Vue && window.Vue.use(ha);
const H6 = {
  common: {
    canvas: {
      label: "Kartenanwendung"
    },
    error: {
      serviceUnavailable: 'Der Kartendienst "{{serviceName}}" (ID: {{serviceId}}) ist derzeit nicht verfgbar. Dies kann die Funktionalitt der Karte einschrnken.'
    },
    overlay: {
      noControlOnZoom: "Verwenden Sie Strg+Scrollen zum Zoomen der Karte",
      oneFingerPan: "Verwenden Sie mindestens zwei Finger zum Verschieben der Karte"
    }
  }
}, Y6 = {
  common: {
    canvas: {
      label: "Map application"
    },
    error: {
      serviceUnavailable: `Service  "{{serviceName}}" (ID: {{serviceId}}) is unavailable. This may limit the map's functionality.`
    },
    overlay: {
      noControlOnZoom: "Use Ctrl+Mousewheel to zoom into the map",
      oneFingerPan: "Use at least two fingers to pan the map"
    }
  }
};
z8(CI);
$t.use(ha);
function X6(e) {
  return W8({
    resources: { de: H6, en: Y6 },
    detection: {
      lookupQuerystring: "lng",
      order: ["querystring", "navigator", "htmlTag"]
    },
    load: "languageOnly",
    fallbackLng: "de",
    fallbackNS: "common",
    ns: ["common"],
    supportedLngs: ["de", "en"],
    ...e ? { lng: e } : {}
  }).then(() => {
    console.info("i18next: Successfully initialized.");
  }).catch((t) => {
    console.error("i18next: Error while initializing.", t);
  }), new ha(qe);
}
function Z6(e) {
  return Array.isArray(e.layers) ? e.layers : typeof e.layerConf > "u" || e.layerConf === fi.layerConf ? fi.layers : [];
}
let J6 = 0;
const Q6 = {
  wms: tS,
  wmts: hS,
  wfs: AS,
  geojson: BS,
  vectorBase: FS,
  vectortile: uM,
  oaf: dM
}, SO = ta.prototype.addLayer;
function TI(e) {
  return e.getLayers ? e.getLayers().getArray().map((t) => TI(t)).flat(1) : [e];
}
function MO(e, t) {
  TI(e).forEach((s) => {
    var i, a, o, l, f;
    const r = (i = s.getSource) == null ? void 0 : i.call(s);
    r ? ((a = r.on) == null || a.call(r, "tileloaderror", t), (o = r.on) == null || o.call(r, "imageloaderror", t), (l = r.on) == null || l.call(r, "featuresloaderror", t), (f = r.on) == null || f.call(r, "error", t)) : console.error("Could not register error callback on layer:", s);
  });
}
function q6(e, t = { visibility: !0, transparency: 0, errorCallback: console.error }) {
  const n = typeof t.errorCallback == "function" ? t.errorCallback : console.error;
  let s, r;
  if (typeof e == "string") {
    const i = ea({ id: e });
    return i ? (r = Q6[i.typ.toLowerCase()], r ? (s = r.createLayer(i, {}, { map: this }), s.setVisible(typeof t.visibility == "boolean" ? t.visibility : !0), s.setOpacity(typeof t.transparency == "number" ? (100 - t.transparency) / 100 : 1), MO(s, n), SO.call(this, s), s) : (console.error("Layer with id '" + e + "' has unknown type '" + i.typ + "'. No layer added to map."), null)) : (console.error("Layer with id '" + e + "' not found. No layer added to map."), null);
  }
  return MO(e, n), SO.call(this, e);
}
ta.prototype.addLayer = q6;
function tH(e = fi, { mapParams: t, callback: n, errorCallback: s } = {}) {
  NP(e.namedProjections), RM(e), q0(e.gazetteerUrl);
  const r = new ta(Object.assign({
    target: e.target || fi.target,
    interactions: Gy({ altShiftDragRotate: !1, pinchRotate: !1 }),
    controls: [],
    view: fP(e)
  }, t));
  return r.set("mapMode", "2D"), r.set("id", `map2D_${J6++}`), jP(e.layerConf, (i, a) => (Z6(e).forEach((o) => {
    r.addLayer(o.id, { errorCallback: s });
  }), typeof n == "function" ? n(i, a) : null)), r;
}
const nn = {};
nn.obj = function(e) {
  return e;
};
nn.supportsImageRenderingPixelatedResult_ = void 0;
nn.imageRenderingValueResult_ = void 0;
nn.supportsImageRenderingPixelated = function() {
  if (nn.supportsImageRenderingPixelatedResult_ === void 0) {
    const e = document.createElement("canvas");
    e.setAttribute("style", "image-rendering: -moz-crisp-edges; image-rendering: pixelated;");
    const t = e.style.imageRendering;
    nn.supportsImageRenderingPixelatedResult_ = !!t, nn.supportsImageRenderingPixelatedResult_ && (nn.imageRenderingValueResult_ = t);
  }
  return nn.supportsImageRenderingPixelatedResult_;
};
nn.imageRenderingValue = function() {
  return nn.supportsImageRenderingPixelated(), nn.imageRenderingValueResult_ || "";
};
nn.getSourceProjection = function(e) {
  return (
    /** @type {ol.proj.Projection} */
    e.get("olcs.projection") || e.getProjection()
  );
};
function Nl(e, t, n) {
  return (
    /** @type {!ol.events.EventsKey} */
    e.on(t, n)
  );
}
let eH = 0;
function Qe(e) {
  return e.olcs_uid || (e.olcs_uid = ++eH);
}
function nH(e, t) {
  const n = e.length, s = Array(e.length);
  for (let r = 0; r < n; r++)
    s[r] = { index: r, value: e[r] };
  s.sort((r, i) => t(r.value, i.value) || r.index - i.index);
  for (let r = 0; r < e.length; r++)
    e[r] = s[r].value;
}
function iH(e) {
  return e && e.parentNode ? e.parentNode.removeChild(e) : null;
}
function rH(e) {
  for (; e.lastChild; )
    e.removeChild(e.lastChild);
}
function pg(e) {
  const t = Cesium.GroundPolylinePrimitive;
  return t && t.isSupported(e);
}
class sH extends ZP {
  /**
   * @param {Options} options ImageStatic options.
   */
  constructor(t) {
    const n = t.crossOrigin !== void 0 ? t.crossOrigin : null, s = t.imageLoadFunction !== void 0 ? t.imageLoadFunction : a0;
    super({
      attributions: t.attributions,
      interpolate: t.interpolate,
      projection: Wt(t.projection)
    }), this.url_ = t.url, this.imageExtent_ = t.imageExtent, this.image_ = new W1(
      this.imageExtent_,
      void 0,
      1,
      this.url_,
      n,
      s
    ), this.imageSize_ = t.imageSize ? t.imageSize : null, this.image_.addEventListener(
      Kt.CHANGE,
      this.handleImageChange.bind(this)
    );
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  getImageExtent() {
    return this.imageExtent_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(t, n, s, r) {
    return hn(t, this.image_.getExtent()) ? this.image_ : null;
  }
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */
  handleImageChange(t) {
    if (this.image_.getState() == he.LOADED) {
      const n = this.image_.getExtent(), s = this.image_.getImage();
      let r, i;
      this.imageSize_ ? (r = this.imageSize_[0], i = this.imageSize_[1]) : (r = s.width, i = s.height);
      const a = Ee(n), o = In(n), l = a / r, f = o / i;
      let d = r, u = i;
      if (l > f ? d = Math.round(a / f) : u = Math.round(o / l), d !== r || u !== i) {
        const c = Di(d, u);
        this.getInterpolate() || (c.imageSmoothingEnabled = !1);
        const h = c.canvas;
        c.drawImage(
          s,
          0,
          0,
          r,
          i,
          0,
          0,
          h.width,
          h.height
        ), this.image_.setImage(h);
      }
    }
    super.handleImageChange(t);
  }
}
const OI = sH, aH = function() {
  const t = new kP({
    projection: "EPSG:3857",
    wrapX: !0
  }).getTileCoordForTileUrlFunction([6, -31, 22]);
  return t && t[1] === 33 && t[2] === 22;
}();
class PI {
  /**
   * Special class derived from Cesium.ImageryProvider
   * that is connected to the given ol.source.TileImage.
   * @param {!ol.Map} olMap
   * @param {!ol.source.TileImage} source
   * @param {ol.proj.Projection=} opt_fallbackProj Projection to assume if the
   *                                               projection of the source is not defined.
   * @constructor
   * @extends {Cesium.ImageryProvider}
   */
  constructor(t, n, s) {
    this.source_ = n, this.projection_ = null, this.fallbackProj_ = s || null, this.ready_ = !1, this.tilingScheme_ = null, this.rectangle_ = null, this.map_ = t, this.shouldRequestNextLevel = !1;
    const r = this.source_.get("olcs.proxy");
    r && (typeof r == "function" ? this.proxy_ = {
      getURL: r
    } : typeof r == "string" && (this.proxy_ = new Cesium.DefaultProxy(r))), this.errorEvent_ = new Cesium.Event(), this.emptyCanvas_ = document.createElement("canvas"), this.emptyCanvas_.width = 1, this.emptyCanvas_.height = 1, this.source_.on("change", (i) => {
      this.handleSourceChanged_();
    }), this.handleSourceChanged_();
  }
  /**
   * Checks if the underlying source is ready and cached required data.
   * @private
   */
  handleSourceChanged_(t) {
    if (!this.ready_ && this.source_.getState() == "ready") {
      this.projection_ = nn.getSourceProjection(this.source_) || this.fallbackProj_;
      const n = { numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1 };
      if (this.source_.tileGrid !== null && this.source_.tileGrid.forEachTileCoord(this.projection_.getExtent(), 0, ([s, r, i]) => {
        n.numberOfLevelZeroTilesX = r + 1, n.numberOfLevelZeroTilesY = i + 1;
      }), this.projection_.getCode() === "EPSG:4326")
        this.shouldRequestNextLevel = n.numberOfLevelZeroTilesX === 1 && n.numberOfLevelZeroTilesY === 1, this.tilingScheme_ = new Cesium.GeographicTilingScheme(n);
      else if (this.projection_.getCode() === "EPSG:3857")
        this.shouldRequestNextLevel = !1, this.tilingScheme_ = new Cesium.WebMercatorTilingScheme(n);
      else
        return;
      this.rectangle_ = this.tilingScheme_.rectangle, this.ready_ = !0;
    }
  }
  /**
   * Generates the proper attributions for a given position and zoom
   * level.
   * @export
   * @override
   */
  getTileCredits(t, n, s) {
    const r = this.source_.getAttributions();
    if (!r)
      return [];
    const i = this.map_.getView().calculateExtent(this.map_.getSize()), a = this.map_.getView().getCenter(), o = this.shouldRequestNextLevel ? s + 1 : s;
    return SI(r, o, a, i);
  }
  /**
   * @export
   * @override
   */
  requestImage(t, n, s) {
    const r = this.source_.getTileUrlFunction();
    if (r && this.projection_) {
      const i = this.shouldRequestNextLevel ? s + 1 : s;
      let a = n;
      aH || (a = -n - 1);
      let o = r.call(this.source_, [i, t, a], 1, this.projection_);
      return this.proxy_ && (o = this.proxy_.getURL(o)), o ? Cesium.ImageryProvider.loadImage(this, o) : this.emptyCanvas_;
    } else
      return this.emptyCanvas_;
  }
}
Object.defineProperties(PI.prototype, {
  ready: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.ready_;
      }
    )
  },
  rectangle: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.rectangle_;
      }
    )
  },
  tileWidth: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? Array.isArray(e.getTileSize(0)) ? e.getTileSize(0)[0] : e.getTileSize(0) : 256;
      }
    )
  },
  tileHeight: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? Array.isArray(e.getTileSize(0)) ? e.getTileSize(0)[1] : e.getTileSize(0) : 256;
      }
    )
  },
  maximumLevel: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        const e = this.source_.getTileGrid();
        return e ? e.getMaxZoom() : 18;
      }
    )
  },
  minimumLevel: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return 0;
      }
    )
  },
  tilingScheme: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.tilingScheme_;
      }
    )
  },
  tileDiscardPolicy: {
    get: function() {
    }
  },
  errorEvent: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.errorEvent_;
      }
    )
  },
  proxy: {
    get: (
      /** @this {olcs.core.OLImageryProvider} */
      function() {
        return this.proxy_;
      }
    )
  },
  hasAlphaChannel: {
    get: function() {
      return !0;
    }
  },
  pickFeatures: {
    get: function() {
    }
  }
});
const oH = new ES(), lH = [new Mn({
  stroke: new vr({
    color: "blue",
    width: 2
  })
})];
class uH {
  constructor(t) {
    this.urls = t.urls, this.ready = !0, this.readyPromise = Promise.resolve(!0), this.tileWidth = 256, this.tileHeight = 256, this.maximumLevel = t.maximumLevel || 20, this.minimumLevel = t.minimumLevel || 0, this.tilingScheme = new Cesium.WebMercatorTilingScheme(), this.rectangle = t.rectangle || this.tilingScheme.rectangle, this.errorEvent = new Cesium.Event(), this.credit = t.credit, this.hasAlphaChannel = !0, this.styleFunction_ = t.styleFunction || (() => lH), this.projection_ = Wt("EPSG:3857"), this.emptyCanvas_ = document.createElement("canvas"), this.emptyCanvas_.width = 1, this.emptyCanvas_.height = 1, this.tileRectangle_ = new Cesium.Rectangle();
    const n = t.cacheSize !== void 0 ? t.cacheSize : 50;
    this.tileCache = new Zg(n), this.featureCache = t.featureCache || new Zg(n);
    const s = n0(this.projection_);
    this.tileFunction_ = HP(this.urls, s);
  }
  getTileCredits() {
    return [];
  }
  pickFeatures() {
  }
  getTileFeatures(t, n, s) {
    const r = this.getCacheKey_(t, n, s);
    let i;
    if (this.featureCache.containsKey(r) && (i = this.featureCache.get(r)), !i) {
      const a = this.getUrl_(t, n, s);
      if (i = fetch(a).then((o) => o.ok ? o : Promise.reject(o)).then((o) => o.arrayBuffer()).then((o) => this.readFeaturesFromBuffer(o)), this.featureCache.set(r, i), this.featureCache.getCount() > 2 * this.featureCache.highWaterMark)
        for (; this.featureCache.canExpireCache(); )
          this.featureCache.pop();
    }
    return i;
  }
  readFeaturesFromBuffer(t) {
    let n;
    const s = oH.readFeatures(t, n), r = this.tileWidth / 4096;
    return s.forEach((i) => {
      const a = i.getFlatCoordinates();
      for (let o = 0; o < a.length; ++o)
        a[o] *= r;
    }), s;
  }
  getUrl_(t, n, s) {
    return this.tileFunction_([t, n, s]);
  }
  getCacheKey_(t, n, s) {
    return `${t}_${n}_${s}`;
  }
  requestImage(t, n, s, r) {
    if (s < this.minimumLevel)
      return this.emptyCanvas_;
    try {
      const i = this.getCacheKey_(s, t, n);
      let a;
      if (this.tileCache.containsKey(i) && (a = this.tileCache.get(i)), !a && (a = this.getTileFeatures(s, t, n).then((o) => {
        this.tilingScheme.tileXYToNativeRectangle(t, n, s, this.tileRectangle_);
        const l = (this.tileRectangle_.east - this.tileRectangle_.west) / this.tileWidth;
        return this.rasterizeFeatures(o, this.styleFunction_, l);
      }), this.tileCache.set(i, a), this.tileCache.getCount() > 2 * this.tileCache.highWaterMark))
        for (; this.tileCache.canExpireCache(); )
          this.tileCache.pop();
      return a;
    } catch (i) {
      console.trace(i), this.raiseEvent("could not render pbf to tile", i);
    }
  }
  rasterizeFeatures(t, n, s) {
    const r = document.createElement("canvas"), i = wL(r.getContext("2d"), { size: [this.tileWidth, this.tileHeight] });
    return t.forEach((a) => {
      const o = n(a, s);
      o && o.forEach((l) => {
        i.setStyle(l), i.drawGeometry(a);
      });
    }), r;
  }
}
const Vt = {};
Vt.computePixelSizeAtCoordinate = function(e, t) {
  const n = e.camera, s = e.canvas, r = n.frustum, i = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(
    n.position,
    t,
    new Cesium.Cartesian3()
  ));
  return r.getPixelDimensions(
    s.clientWidth,
    s.clientHeight,
    i,
    e.pixelRatio,
    new Cesium.Cartesian2()
  );
};
Vt.computeBoundingBoxAtTarget = function(e, t, n) {
  const s = Vt.computePixelSizeAtCoordinate(e, t), r = Cesium.Transforms.eastNorthUpToFixedFrame(t), i = Cesium.Matrix4.multiplyByPoint(
    r,
    new Cesium.Cartesian3(-s.x * n, -s.y * n, 0),
    new Cesium.Cartesian3()
  ), a = Cesium.Matrix4.multiplyByPoint(
    r,
    new Cesium.Cartesian3(s.x * n, s.y * n, 0),
    new Cesium.Cartesian3()
  );
  return Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(
    [i, a]
  );
};
Vt.applyHeightOffsetToGeometry = function(e, t) {
  e.applyTransform((n, s, r) => {
    if (console.assert(n === s), r !== void 0 && r >= 3)
      for (let i = 0; i < s.length; i += r)
        s[i + 2] = s[i + 2] + t;
    return s;
  });
};
Vt.createMatrixAtCoordinates = function(e, t = 0, n = Cesium.Cartesian3.ZERO, s = new Cesium.Cartesian3(1, 1, 1)) {
  const r = Vt.ol4326CoordinateToCesiumCartesian(e), i = Cesium.Transforms.eastNorthUpToFixedFrame(r), a = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -t), o = Cesium.Matrix4.fromTranslationQuaternionRotationScale(n, a, s);
  return Cesium.Matrix4.multiply(i, o, new Cesium.Matrix4());
};
Vt.rotateAroundAxis = function(e, t, n, s, r) {
  const i = Cesium.Math.clamp, a = Cesium.defaultValue, o = r || {}, l = a(o.duration, 500), f = a(o.easing, tP), d = o.callback;
  let u = 0;
  const c = new Cesium.Matrix4(), h = Date.now(), p = function() {
    const m = Date.now() - h, v = f(i(m / l, 0, 1));
    console.assert(v >= u), e.transform.clone(c);
    const y = (v - u) * t;
    u = v, e.lookAtTransform(s), e.rotate(n, y), e.lookAtTransform(c), v < 1 ? window.requestAnimationFrame(p) : d && d();
  };
  window.requestAnimationFrame(p);
};
Vt.setHeadingUsingBottomCenter = function(e, t, n, s) {
  const r = e.camera, i = Vt.computeAngleToZenith(e, n), a = r.right, o = Cesium.Quaternion.fromAxisAngle(a, i), l = Cesium.Matrix3.fromQuaternion(o), f = new Cesium.Cartesian3();
  Cesium.Cartesian3.subtract(r.position, n, f);
  const d = new Cesium.Cartesian3();
  Cesium.Matrix3.multiplyByVector(l, f, d), Cesium.Cartesian3.add(d, n, d);
  const u = Cesium.Matrix4.fromTranslation(d), c = Vt.rotateAroundAxis;
  c(r, t, d, u, s);
};
Vt.pickOnTerrainOrEllipsoid = function(e, t) {
  const n = e.camera.getPickRay(t);
  return e.globe.pick(n, e) || e.camera.pickEllipsoid(t);
};
Vt.pickBottomPoint = function(e) {
  const t = e.canvas, n = new Cesium.Cartesian2(
    t.clientWidth / 2,
    t.clientHeight
  );
  return Vt.pickOnTerrainOrEllipsoid(e, n);
};
Vt.pickCenterPoint = function(e) {
  const t = e.canvas, n = new Cesium.Cartesian2(
    t.clientWidth / 2,
    t.clientHeight / 2
  );
  return Vt.pickOnTerrainOrEllipsoid(e, n);
};
Vt.computeSignedTiltAngleOnGlobe = function(e) {
  const t = e.camera, n = new Cesium.Ray(t.position, t.direction);
  let s = e.globe.pick(n, e);
  if (!s) {
    const o = Cesium.Ellipsoid.WGS84, l = Cesium.IntersectionTests.rayEllipsoid(n, o);
    l && (s = Cesium.Ray.getPoint(n, l.start));
  }
  if (!s)
    return;
  const r = new Cesium.Cartesian3();
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(s, r);
  const i = Vt.signedAngleBetween, a = i(t.direction, r, t.right) - Math.PI;
  return Cesium.Math.convertLongitudeRange(a);
};
Vt.bottomFovRay = function(e) {
  const t = e.camera, n = t.frustum.fovy / 2, s = t.direction, r = Cesium.Quaternion.fromAxisAngle(t.right, n), i = Cesium.Matrix3.fromQuaternion(r), a = new Cesium.Cartesian3();
  return Cesium.Matrix3.multiplyByVector(i, s, a), new Cesium.Ray(t.position, a);
};
Vt.signedAngleBetween = function(e, t, n) {
  const s = new Cesium.Cartesian3(), r = new Cesium.Cartesian3(), i = new Cesium.Cartesian3();
  Cesium.Cartesian3.normalize(e, s), Cesium.Cartesian3.normalize(t, r), Cesium.Cartesian3.cross(s, r, i);
  const a = Cesium.Cartesian3.dot(s, r), o = Cesium.Cartesian3.magnitude(i), l = Cesium.Cartesian3.dot(n, i), f = Math.atan2(o, a);
  return l >= 0 ? f : -f;
};
Vt.computeAngleToZenith = function(e, t) {
  const n = e.camera, s = n.frustum.fovy / 2, r = Vt.bottomFovRay(e), i = Cesium.Cartesian3.clone(r.direction);
  Cesium.Cartesian3.negate(i, i);
  const a = new Cesium.Cartesian3();
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(t, a);
  const o = new Cesium.Cartesian3();
  return Cesium.Cartesian3.negate(n.right, o), Vt.signedAngleBetween(a, i, o) + s;
};
Vt.extentToRectangle = function(e, t) {
  if (e && t) {
    const n = Wc(e, t, "EPSG:4326");
    return Cesium.Rectangle.fromDegrees(n[0], n[1], n[2], n[3]);
  } else
    return null;
};
Vt.sourceToImageryProvider = function(e, t, n, s) {
  const r = t.get("olcs_skip");
  if (r)
    return null;
  let i = null;
  if (t instanceof o0 && t.getUrl() && t.getImageLoadFunction() === a0) {
    const a = {
      "olcs.proxy": t.get("olcs.proxy"),
      "olcs.extent": t.get("olcs.extent"),
      "olcs.projection": t.get("olcs.projection"),
      "olcs.imagesource": t
    };
    t = new s0({
      url: t.getUrl(),
      attributions: t.getAttributions(),
      projection: t.getProjection(),
      params: t.getParams()
    }), t.setProperties(a);
  }
  if (t instanceof r0) {
    let a = nn.getSourceProjection(t);
    if (a || (a = n), Vt.isCesiumProjection(a))
      i = new PI(e, t, n);
    else
      return null;
  } else if (t instanceof OI) {
    let a = nn.getSourceProjection(t);
    if (a || (a = n), Vt.isCesiumProjection(a))
      i = new Cesium.SingleTileImageryProvider({
        url: t.getUrl(),
        rectangle: new Cesium.Rectangle.fromDegrees(
          t.getImageExtent()[0],
          t.getImageExtent()[1],
          t.getImageExtent()[2],
          t.getImageExtent()[3]
        )
      });
    else
      return null;
  } else if (t instanceof NS) {
    let a = nn.getSourceProjection(t);
    if (a || (a = n), r === !1) {
      const o = a.getCode().split(":")[1], l = t.urls.map((g) => g.replace(o, "3857")), f = s.getExtent(), d = Vt.extentToRectangle(f, a), u = t.get("olcs_minimumLevel"), c = t.getAttributions(), h = s.getStyleFunction();
      let p;
      if (f && c) {
        const g = $i(f);
        p = SI(c, 0, g, f)[0];
      }
      return i = new uH({
        credit: p,
        rectangle: d,
        minimumLevel: u,
        styleFunction: h,
        urls: l
      }), i;
    }
    return null;
  } else
    return null;
  return i;
};
Vt.tileLayerToImageryLayer = function(e, t, n) {
  if (!(t instanceof Zc) && !(t instanceof Uf) && !(t instanceof O0))
    return null;
  const s = t.getSource();
  if (!s)
    return null;
  let r = s.get("olcs_provider");
  if (r || (r = this.sourceToImageryProvider(e, s, n, t)), !r)
    return null;
  const i = {}, o = /** @type {ol.Extent} */ t.get("olcs.extent") || t.getExtent();
  return o && (i.rectangle = Vt.extentToRectangle(o, n)), new Cesium.ImageryLayer(r, i);
};
Vt.updateCesiumLayerProperties = function(e, t) {
  let n = 1, s = !0;
  [e.layer].concat(e.parents).forEach((r) => {
    const i = r.getOpacity();
    i !== void 0 && (n *= i);
    const a = r.getVisible();
    a !== void 0 && (s &= a);
  }), t.alpha = n, t.show = s;
};
Vt.ol4326CoordinateToCesiumCartesian = function(e) {
  const t = e;
  return t.length > 2 ? Cesium.Cartesian3.fromDegrees(t[0], t[1], t[2]) : Cesium.Cartesian3.fromDegrees(t[0], t[1]);
};
Vt.ol4326CoordinateArrayToCsCartesians = function(e) {
  console.assert(e !== null);
  const t = Vt.ol4326CoordinateToCesiumCartesian, n = [];
  for (let s = 0; s < e.length; ++s)
    n.push(t(e[s]));
  return n;
};
Vt.olGeometryCloneTo4326 = function(e, t) {
  console.assert(t);
  const n = Wt("EPSG:4326"), s = Wt(t);
  if (s.getCode() !== n.getCode()) {
    const r = e.getProperties();
    e = e.clone(), e.transform(s, n), e.setProperties(r);
  }
  return e;
};
Vt.convertColorToCesium = function(e) {
  if (e = e || "black", Array.isArray(e))
    return new Cesium.Color(
      Cesium.Color.byteToFloat(e[0]),
      Cesium.Color.byteToFloat(e[1]),
      Cesium.Color.byteToFloat(e[2]),
      e[3]
    );
  if (typeof e == "string")
    return Cesium.Color.fromCssColorString(e);
  if (e instanceof CanvasPattern || e instanceof CanvasGradient) {
    const t = document.createElement("canvas"), n = t.getContext("2d");
    return t.width = t.height = 256, n.fillStyle = e, n.fillRect(0, 0, t.width, t.height), new Cesium.ImageMaterialProperty({
      image: t
    });
  }
  console.assert(!1, "impossible");
};
Vt.convertUrlToCesium = function(e) {
  let t = "";
  const n = /\{(\d|[a-z])-(\d|[a-z])\}/, s = n.exec(e);
  if (s) {
    e = e.replace(n, "{s}");
    const r = s[1].charCodeAt(0), i = s[2].charCodeAt(0);
    let a;
    for (a = r; a <= i; ++a)
      t += String.fromCharCode(a);
  }
  return {
    url: e,
    subdomains: t
  };
};
Vt.resetToNorthZenith = function(e, t) {
  return new Promise((n, s) => {
    const r = t.camera, i = Vt.pickBottomPoint(t);
    if (!i) {
      s("Could not get bottom pivot");
      return;
    }
    const a = e.getView().getRotation();
    if (a === void 0) {
      s("The view is not initialized");
      return;
    }
    const o = Vt.computeAngleToZenith(t, i);
    Vt.setHeadingUsingBottomCenter(t, a, i);
    const l = Cesium.Matrix4.fromTranslation(i), f = r.right, d = {
      callback: () => {
        const u = e.getView();
        Vt.normalizeView(u), n();
      }
    };
    Vt.rotateAroundAxis(r, -o, f, l, d);
  });
};
Vt.rotateAroundBottomCenter = function(e, t) {
  return new Promise((n, s) => {
    const r = e.camera, i = Vt.pickBottomPoint(e);
    if (!i) {
      s("could not get bottom pivot");
      return;
    }
    const a = { callback: n }, o = Cesium.Matrix4.fromTranslation(i), l = r.right, f = Vt.rotateAroundAxis;
    f(r, -t, l, o, a);
  });
};
Vt.normalizeView = function(e, t = 0) {
  const n = e.getResolution();
  e.setRotation(t), e.constrainResolution ? e.setResolution(e.constrainResolution(n)) : e.setResolution(e.getConstrainedResolution(n));
};
Vt.isCesiumProjection = function(e) {
  const t = e.getCode() === "EPSG:3857", n = e.getCode() === "EPSG:4326";
  return t || n;
};
function SI(e, t, n, s) {
  const r = {
    viewState: { zoom: t, center: n },
    extent: s
  };
  if (!e)
    return [];
  let i = e(r);
  return Array.isArray(i) || (i = [i]), i.map((a) => new Cesium.Credit(a, !0));
}
function cH(e, t, n, s) {
  const r = n.canvas, a = n.camera.frustum.fovy;
  console.assert(!isNaN(a));
  const o = s.getMetersPerUnit(), l = e * r.clientHeight, f = Math.cos(Math.abs(t));
  return l * o * f / 2 / Math.tan(a / 2);
}
function hH(e, t, n, s) {
  const r = n.canvas, a = n.camera.frustum.fovy;
  console.assert(!isNaN(a));
  const o = s.getMetersPerUnit(), l = 2 * e * Math.tan(a / 2), f = Math.cos(Math.abs(t));
  return l / o / f / r.clientHeight;
}
class dH {
  /**
   * @constructor
   * @param {olcs.OLCesium} ol3d
   */
  constructor(t) {
    this.ol3d = t, this.scene_ = t.getCesiumScene(), this.canvas_ = this.scene_.canvas, this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this), this.repaintEventNames_ = [
      "mousemove",
      "mousedown",
      "mouseup",
      "touchstart",
      "touchend",
      "touchmove",
      "pointerdown",
      "pointerup",
      "pointermove",
      "wheel"
    ], this.enable();
  }
  /**
   * Enable.
   */
  enable() {
    this.scene_.requestRenderMode = !0, this.scene_.maximumRenderTimeChange = 1e3;
    for (const t of this.repaintEventNames_)
      this.canvas_.addEventListener(t, this._boundNotifyRepaintRequired, !1);
    window.addEventListener("resize", this._boundNotifyRepaintRequired, !1), this.ol3d.getOlMap().getLayerGroup().on("change", this._boundNotifyRepaintRequired);
  }
  /**
   * Disable.
   */
  disable() {
    for (const t of this.repaintEventNames_)
      this.canvas_.removeEventListener(t, this._boundNotifyRepaintRequired, !1);
    window.removeEventListener("resize", this._boundNotifyRepaintRequired, !1), this.ol3d.getOlMap().getLayerGroup().un("change", this._boundNotifyRepaintRequired), this.scene_.requestRenderMode = !1;
  }
  /**
   * Restart render loop.
   * Force a restart of the render loop.
   * @api
   */
  restartRenderLoop() {
    this.notifyRepaintRequired();
  }
  notifyRepaintRequired() {
    this.scene_.requestRender();
  }
}
function id(e) {
  return e * 180 / Math.PI;
}
function Hu(e) {
  return e * Math.PI / 180;
}
class jl {
  /**
   * This object takes care of additional 3d-specific properties of the view and
   * ensures proper synchronization with the underlying raw Cesium.Camera object.
   * @param {!Cesium.Scene} scene
   * @param {!ol.Map} map
   * @api
   */
  constructor(t, n) {
    this.scene_ = t, this.cam_ = t.camera, this.map_ = n, this.view_ = null, this.viewListenKey_ = null, this.toLonLat_ = jl.identityProjection, this.fromLonLat_ = jl.identityProjection, this.tilt_ = 0, this.distance_ = 0, this.lastCameraViewMatrix_ = null, this.viewUpdateInProgress_ = !1, this.map_.on("change:view", (s) => {
      this.setView_(this.map_.getView());
    }), this.setView_(this.map_.getView());
  }
  /**
   * @param {Array.<number>} input Input coordinate array.
   * @param {Array.<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array.<number>} Input coordinate array (same array as input).
   */
  static identityProjection(t, n, s) {
    const r = s || t.length;
    if (n)
      for (let i = 0; i < r; ++i)
        n[i] = t[i];
    return t;
  }
  /**
   * @param {?ol.View} view New view to use.
   * @private
   */
  setView_(t) {
    if (this.view_ && (zs(this.viewListenKey_), this.viewListenKey_ = null), this.view_ = t, t) {
      const n = Ka(t.getProjection(), "EPSG:4326"), s = Ka("EPSG:4326", t.getProjection());
      console.assert(n && s), this.toLonLat_ = n, this.fromLonLat_ = s, this.viewListenKey_ = t.on("propertychange", (r) => this.handleViewEvent_(r)), this.readFromView();
    } else
      this.toLonLat_ = jl.identityProjection, this.fromLonLat_ = jl.identityProjection;
  }
  /**
   * @param {?} e
   * @private
   */
  handleViewEvent_(t) {
    this.viewUpdateInProgress_ || this.readFromView();
  }
  /**
   * @param {number} heading In radians.
   * @api
   */
  setHeading(t) {
    this.view_ && this.view_.setRotation(t);
  }
  /**
   * @return {number|undefined} Heading in radians.
   * @api
   */
  getHeading() {
    return this.view_ ? this.view_.getRotation() || 0 : void 0;
  }
  /**
   * @param {number} tilt In radians.
   * @api
   */
  setTilt(t) {
    this.tilt_ = t, this.updateCamera_();
  }
  /**
   * @return {number} Tilt in radians.
   * @api
   */
  getTilt() {
    return this.tilt_;
  }
  /**
   * @param {number} distance In meters.
   * @api
   */
  setDistance(t) {
    this.distance_ = t, this.updateCamera_(), this.updateView();
  }
  /**
   * @return {number} Distance in meters.
   * @api
   */
  getDistance() {
    return this.distance_;
  }
  /**
   * Shortcut for ol.View.setCenter().
   * @param {!ol.Coordinate} center Same projection as the ol.View.
   * @api
   */
  setCenter(t) {
    this.view_ && this.view_.setCenter(t);
  }
  /**
   * Shortcut for ol.View.getCenter().
   * @return {ol.Coordinate|undefined} Same projection as the ol.View.
   * @api
   */
  getCenter() {
    if (this.view_)
      return this.view_.getCenter();
  }
  /**
   * Sets the position of the camera.
   * @param {!ol.Coordinate} position Same projection as the ol.View.
   * @api
   */
  setPosition(t) {
    if (!this.toLonLat_)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = new Cesium.Cartographic(
      Hu(n[0]),
      Hu(n[1]),
      this.getAltitude()
    );
    this.cam_.setView({
      destination: Cesium.Ellipsoid.WGS84.cartographicToCartesian(s)
    }), this.updateView();
  }
  /**
   * Calculates position under the camera.
   * @return {!ol.Coordinate|undefined} Same projection as the ol.View.
   * @api
   */
  getPosition() {
    if (!this.fromLonLat_)
      return;
    const t = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position), n = this.fromLonLat_([
      id(t.longitude),
      id(t.latitude)
    ]);
    return console.assert(n), n;
  }
  /**
   * @param {number} altitude In meters.
   * @api
   */
  setAltitude(t) {
    const n = Cesium.Ellipsoid.WGS84.cartesianToCartographic(
      this.cam_.position
    );
    n.height = t, this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(n), this.updateView();
  }
  /**
   * @return {number} Altitude in meters.
   * @api
   */
  getAltitude() {
    return Cesium.Ellipsoid.WGS84.cartesianToCartographic(
      this.cam_.position
    ).height;
  }
  /**
   * Updates the state of the underlying Cesium.Camera
   * according to the current values of the properties.
   * @private
   */
  updateCamera_() {
    if (!this.view_ || !this.toLonLat_)
      return;
    const t = this.view_.getCenter();
    if (!t)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = new Cesium.Cartographic(
      Hu(n[0]),
      Hu(n[1])
    );
    if (this.scene_.globe) {
      const a = this.scene_.globe.getHeight(s);
      s.height = a || 0;
    }
    const r = Cesium.Ellipsoid.WGS84.cartographicToCartesian(s), i = {
      pitch: this.tilt_ - Cesium.Math.PI_OVER_TWO,
      heading: -this.view_.getRotation(),
      roll: void 0
    };
    this.cam_.setView({
      destination: r,
      orientation: i
    }), this.cam_.moveBackward(this.distance_), this.checkCameraChange(!0);
  }
  /**
   * Calculates the values of the properties from the current ol.View state.
   * @api
   */
  readFromView() {
    if (!this.view_ || !this.toLonLat_)
      return;
    const t = this.view_.getCenter();
    if (t == null)
      return;
    const n = this.toLonLat_(t);
    console.assert(n);
    const s = this.view_.getResolution();
    this.distance_ = this.calcDistanceForResolution(
      s || 0,
      Hu(n[1])
    ), this.updateCamera_();
  }
  /**
   * Calculates the values of the properties from the current Cesium.Camera state.
   * Modifies the center, resolution and rotation properties of the view.
   * @api
   */
  updateView() {
    if (!this.view_ || !this.fromLonLat_)
      return;
    this.viewUpdateInProgress_ = !0;
    const t = Cesium.Ellipsoid.WGS84, n = this.scene_, s = Vt.pickCenterPoint(n);
    let r = s;
    if (!r) {
      const a = n.globe, o = this.cam_.positionCartographic.clone(), l = a.getHeight(o);
      o.height = l || 0, r = Cesium.Ellipsoid.WGS84.cartographicToCartesian(o);
    }
    this.distance_ = Cesium.Cartesian3.distance(r, this.cam_.position);
    const i = t.cartesianToCartographic(r);
    if (this.view_.setCenter(this.fromLonLat_([
      id(i.longitude),
      id(i.latitude)
    ])), this.view_.setResolution(
      this.calcResolutionForDistance(
        this.distance_,
        i ? i.latitude : 0
      )
    ), s) {
      const a = this.cam_.position, o = new Cesium.Cartesian3();
      t.geocentricSurfaceNormal(s, o);
      const l = new Cesium.Cartesian3();
      Cesium.Cartesian3.subtract(a, s, l), Cesium.Cartesian3.normalize(l, l);
      const f = this.cam_.up, d = this.cam_.right, u = new Cesium.Cartesian3(-s.y, s.x, 0), c = Cesium.Cartesian3.angleBetween(d, u), p = Cesium.Cartesian3.cross(s, f, new Cesium.Cartesian3()).z;
      this.view_.setRotation(p < 0 ? c : -c);
      const g = Math.acos(
        Cesium.Cartesian3.dot(o, l)
      );
      this.tilt_ = isNaN(g) ? 0 : g;
    } else
      this.view_.setRotation(this.cam_.heading), this.tilt_ = -this.cam_.pitch + Math.PI / 2;
    this.viewUpdateInProgress_ = !1;
  }
  /**
   * Check if the underlying camera state has changed and ensure synchronization.
   * @param {boolean=} opt_dontSync Do not synchronize the view.
   */
  checkCameraChange(t) {
    const n = this.lastCameraViewMatrix_, s = this.cam_.viewMatrix;
    (!n || !Cesium.Matrix4.equalsEpsilon(n, s, 1e-5)) && (this.lastCameraViewMatrix_ = s.clone(), t !== !0 && this.updateView());
  }
  /**
   * calculate the distance between camera and centerpoint based on the resolution and latitude value
   * @param {number} resolution Number of map units per pixel.
   * @param {number} latitude Latitude in radians.
   * @return {number} The calculated distance.
   * @api
   */
  calcDistanceForResolution(t, n) {
    return cH(t, n, this.scene_, this.view_.getProjection());
  }
  /**
   * calculate the resolution based on a distance(camera to position) and latitude value
   * @param {number} distance
   * @param {number} latitude
   * @return {number} The calculated resolution.
   * @api
   */
  calcResolutionForDistance(t, n) {
    return hH(t, n, this.scene_, this.view_.getProjection());
  }
}
class IE {
  /**
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @template T
   * @abstract
   * @api
   */
  constructor(t, n) {
    this.map = t, this.view = t.getView(), this.scene = n, this.olLayers = t.getLayerGroup().getLayers(), this.mapLayerGroup = t.getLayerGroup(), this.layerMap = {}, this.olLayerListenKeys = {}, this.olGroupListenKeys_ = {};
  }
  /**
   * Destroy all and perform complete synchronization of the layers.
   * @api
   */
  synchronize() {
    this.destroyAll(), this.addLayers_(this.mapLayerGroup);
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @protected
   */
  orderLayers() {
  }
  /**
   * Add a layer hierarchy.
   * @param {ol.layer.Base} root
   * @private
   */
  addLayers_(t) {
    const n = [{
      layer: t,
      parents: []
    }];
    for (; n.length > 0; ) {
      const s = n.splice(0, 1)[0], r = s.layer, i = Qe(r).toString();
      this.olLayerListenKeys[i] = [], console.assert(!this.layerMap[i]);
      let a = null;
      if (r instanceof Ga)
        this.listenForGroupChanges_(r), r !== this.mapLayerGroup && (a = this.createSingleLayerCounterparts(s)), a || r.getLayers().forEach((o) => {
          if (o) {
            const l = {
              layer: o,
              parents: r === this.mapLayerGroup ? [] : [s.layer].concat(s.parents)
            };
            n.push(l);
          }
        });
      else if (a = this.createSingleLayerCounterparts(s), !a) {
        const o = i, l = s, f = (d) => {
          const u = this.createSingleLayerCounterparts(l);
          u && (l.layer.un("change", f), this.addCesiumObjects_(u, o, l.layer), this.orderLayers());
        };
        this.olLayerListenKeys[i].push(Nl(l.layer, "change", f));
      }
      a && this.addCesiumObjects_(a, i, r);
    }
    this.orderLayers();
  }
  /**
   * Add Cesium objects.
   * @param {Array.<T>} cesiumObjects
   * @param {string} layerId
   * @param {ol.layer.Base} layer
   * @private
   */
  addCesiumObjects_(t, n, s) {
    this.layerMap[n] = t, this.olLayerListenKeys[n].push(Nl(s, "change:zIndex", () => this.orderLayers())), t.forEach((r) => {
      this.addCesiumObject(r);
    });
  }
  /**
   * Remove and destroy a single layer.
   * @param {ol.layer.Layer} layer
   * @return {boolean} counterpart destroyed
   * @private
   */
  removeAndDestroySingleLayer_(t) {
    const n = Qe(t).toString(), s = this.layerMap[n];
    return s && (s.forEach((r) => {
      this.removeSingleCesiumObject(r, !1), this.destroyCesiumObject(r);
    }), this.olLayerListenKeys[n].forEach(zs), delete this.olLayerListenKeys[n]), delete this.layerMap[n], !!s;
  }
  /**
   * Unlisten a single layer group.
   * @param {ol.layer.Group} group
   * @private
   */
  unlistenSingleGroup_(t) {
    if (t === this.mapLayerGroup)
      return;
    const n = Qe(t).toString();
    this.olGroupListenKeys_[n].forEach((r) => {
      zs(r);
    }), delete this.olGroupListenKeys_[n], delete this.layerMap[n];
  }
  /**
   * Remove layer hierarchy.
   * @param {ol.layer.Base} root
   * @private
   */
  removeLayer_(t) {
    if (t) {
      const n = [t];
      for (; n.length > 0; ) {
        const s = n.splice(0, 1)[0], r = this.removeAndDestroySingleLayer_(s);
        s instanceof Ga && (this.unlistenSingleGroup_(s), r || s.getLayers().forEach((i) => {
          n.push(i);
        }));
      }
    }
  }
  /**
   * Register listeners for single layer group change.
   * @param {ol.layer.Group} group
   * @private
   */
  listenForGroupChanges_(t) {
    const n = Qe(t).toString();
    console.assert(this.olGroupListenKeys_[n] === void 0);
    const s = [];
    this.olGroupListenKeys_[n] = s;
    let r = [];
    const i = (function() {
      const a = t.getLayers();
      a && (r = [
        a.on("add", (o) => {
          this.addLayers_(o.element);
        }),
        a.on("remove", (o) => {
          this.removeLayer_(o.element);
        })
      ], s.push(...r));
    }).bind(this);
    i(), s.push(t.on("change:layers", (a) => {
      r.forEach((o) => {
        const l = s.indexOf(o);
        l >= 0 && s.splice(l, 1), zs(o);
      }), i();
    }));
  }
  /**
   * Destroys all the created Cesium objects.
   * @protected
   */
  destroyAll() {
    this.removeAllCesiumObjects(!0);
    let t;
    for (t in this.olGroupListenKeys_)
      this.olGroupListenKeys_[t].forEach(zs);
    for (t in this.olLayerListenKeys)
      this.olLayerListenKeys[t].forEach(zs);
    this.olGroupListenKeys_ = {}, this.olLayerListenKeys = {}, this.layerMap = {};
  }
  /**
   * Adds a single Cesium object to the collection.
   * @param {!T} object
   * @abstract
   * @protected
   */
  addCesiumObject(t) {
  }
  /**
   * @param {!T} object
   * @abstract
   * @protected
   */
  destroyCesiumObject(t) {
  }
  /**
   * Remove single Cesium object from the collection.
   * @param {!T} object
   * @param {boolean} destroy
   * @abstract
   * @protected
   */
  removeSingleCesiumObject(t, n) {
  }
  /**
   * Remove all Cesium objects from the collection.
   * @param {boolean} destroy
   * @abstract
   * @protected
   */
  removeAllCesiumObjects(t) {
  }
  /**
   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents
   * @return {?Array.<T>}
   * @abstract
   * @protected
   */
  createSingleLayerCounterparts(t) {
  }
}
class fH extends IE {
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers raster layers to the given Cesium globe.
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @constructor
   * @extends {olcsAbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   */
  constructor(t, n) {
    super(t, n), this.cesiumLayers_ = n.imageryLayers, this.ourLayers_ = new Cesium.ImageryLayerCollection();
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    this.cesiumLayers_.add(t), this.ourLayers_.add(t);
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    this.cesiumLayers_.remove(t, n), this.ourLayers_.remove(t, !1);
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    for (let n = 0; n < this.ourLayers_.length; ++n)
      this.cesiumLayers_.remove(this.ourLayers_.get(n), t);
    this.ourLayers_.removeAll(!1);
  }
  /**
   * Creates an array of Cesium.ImageryLayer.
   * May be overriden by child classes to implement custom behavior.
   * The default implementation handles tiled imageries in EPSG:4326 or
   * EPSG:3859.
   * @param {!ol.layer.Base} olLayer
   * @param {!ol.proj.Projection} viewProj Projection of the view.
   * @return {?Array.<!Cesium.ImageryLayer>} array or null if not possible
   * (or supported)
   * @protected
   */
  convertLayerToCesiumImageries(t, n) {
    const s = Vt.tileLayerToImageryLayer(this.map, t, n);
    return s ? [s] : null;
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer, s = Qe(n).toString(), r = this.view.getProjection();
    console.assert(r);
    const i = this.convertLayerToCesiumImageries(n, r);
    if (i) {
      const a = [];
      if ([t.layer].concat(t.parents).forEach((o) => {
        a.push(o.on(["change:opacity", "change:visible"], () => {
          console.assert(i);
          for (let l = 0; l < i.length; ++l)
            Vt.updateCesiumLayerProperties(t, i[l]);
        }));
      }), n.getStyleFunction) {
        let o = n.getStyleFunction();
        a.push(n.on("change", () => {
          const l = n.getStyleFunction();
          if (o !== l) {
            o = l;
            for (let f = 0; f < i.length; ++f) {
              const d = i[f];
              d._imageryCache && d.imageryProvider.cache_ && (d._imageryCache = {}, d.imageryProvider.cache_ = {}, d.imageryProvider.styleFunction_ = l);
            }
            this.scene.requestRender();
          }
        }));
      }
      for (let o = 0; o < i.length; ++o)
        Vt.updateCesiumLayerProperties(t, i[o]);
      a.push(n.on("change:extent", (o) => {
        for (let l = 0; l < i.length; ++l)
          this.cesiumLayers_.remove(i[l], !0), this.ourLayers_.remove(i[l], !1);
        delete this.layerMap[Qe(n)], this.synchronize();
      })), a.push(n.on("change", (o) => {
        for (let l = 0; l < i.length; ++l) {
          const f = this.cesiumLayers_.indexOf(i[l]);
          f >= 0 && (this.cesiumLayers_.remove(i[l], !1), this.cesiumLayers_.add(i[l], f));
        }
      })), this.olLayerListenKeys[s].push(...a);
    }
    return Array.isArray(i) ? i : null;
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @override
   * @protected
   */
  orderLayers() {
    const t = [], n = {}, s = [this.mapLayerGroup];
    for (; s.length > 0; ) {
      const r = s.splice(0, 1)[0];
      if (t.push(r), n[Qe(r)] = r.getZIndex() || 0, r instanceof Ga) {
        const i = r.getLayers();
        i && s.unshift(...i.getArray());
      }
    }
    nH(
      t,
      (r, i) => n[Qe(r)] - n[Qe(i)]
    ), t.forEach((r) => {
      const i = Qe(r).toString(), a = this.layerMap[i];
      a && a.forEach((o) => {
        this.raiseToTop(o);
      });
    });
  }
  /**
   * @param {Cesium.ImageryLayer} counterpart
   */
  raiseToTop(t) {
    this.cesiumLayers_.raiseToTop(t);
  }
}
class pH {
  /**
  * Result of the conversion of an OpenLayers layer to Cesium.
  * @param {!(ol.proj.Projection|string)} layerProjection
  * @param {!Cesium.Scene} scene
  */
  constructor(t, n) {
    const s = new Cesium.BillboardCollection({ scene: n }), r = new Cesium.PrimitiveCollection();
    this.olListenKeys = [], this.rootCollection_ = new Cesium.PrimitiveCollection(), this.context = {
      projection: t,
      billboards: s,
      featureToCesiumMap: {},
      primitives: r
    }, this.rootCollection_.add(s), this.rootCollection_.add(r);
  }
  /**
  * Unlisten.
  */
  destroy() {
    this.olListenKeys.forEach(zs), this.olListenKeys.length = 0;
  }
  /**
  * @return {!Cesium.Primitive}
  */
  getRootPrimitive() {
    return this.rootCollection_;
  }
}
class mH {
  /**
   * Concrete base class for converting from OpenLayers3 vectors to Cesium
   * primitives.
   * Extending this class is possible provided that the extending class and
   * the library are compiled together by the closure compiler.
   * @param {!Cesium.Scene} scene Cesium scene.
   * @constructor
   * @api
   */
  constructor(t) {
    this.scene = t, this.boundOnRemoveOrClearFeatureListener_ = this.onRemoveOrClearFeature_.bind(this), this.defaultBillboardEyeOffset_ = new Cesium.Cartesian3(0, 0, 10);
  }
  /**
   * @param {ol.source.Vector.Event} evt
   * @private
   */
  onRemoveOrClearFeature_(t) {
    const n = t.target;
    console.assert(n instanceof Ur);
    const s = nn.obj(n).olcs_cancellers;
    if (s) {
      const r = t.feature;
      if (r) {
        const i = Qe(r), a = s[i];
        a && (a(), delete s[i]);
      } else {
        for (const i in s)
          s.hasOwnProperty(i) && s[i]();
        nn.obj(n).olcs_cancellers = {};
      }
    }
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!Cesium.Primitive|Cesium.Label|Cesium.Billboard} primitive
   * @protected
   */
  setReferenceForPicking(t, n, s) {
    s.olLayer = t, s.olFeature = n;
  }
  /**
   * Basics primitive creation using a color attribute.
   * Note that Cesium has 'interior' and outline geometries.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.
   * @param {!Cesium.Geometry} geometry
   * @param {!Cesium.Color} color
   * @param {number=} opt_lineWidth
   * @return {Cesium.Primitive}
   * @protected
   */
  createColoredPrimitive(t, n, s, r, i, a) {
    const o = function(c, h) {
      const p = new Cesium.GeometryInstance({
        // always update Cesium externs before adding a property
        geometry: c
      });
      return h && !(h instanceof Cesium.ImageMaterialProperty) && (p.attributes = {
        color: Cesium.ColorGeometryInstanceAttribute.fromColor(h)
      }), p;
    }, l = {
      // always update Cesium externs before adding a property
      flat: !0,
      // work with all geometries
      renderState: {
        depthTest: {
          enabled: !0
        }
      }
    };
    a !== void 0 && (l.renderState || (l.renderState = {}), l.renderState.lineWidth = a);
    const f = o(r, i), d = this.getHeightReference(t, n, s);
    let u;
    if (d === Cesium.HeightReference.CLAMP_TO_GROUND) {
      const c = f.geometry.constructor;
      if (c && !c.createShadowVolume)
        return null;
      u = new Cesium.GroundPrimitive({
        geometryInstances: f
      });
    } else
      u = new Cesium.Primitive({
        geometryInstances: f
      });
    if (i instanceof Cesium.ImageMaterialProperty) {
      const c = i.image.getValue().toDataURL();
      u.appearance = new Cesium.MaterialAppearance({
        flat: !0,
        renderState: {
          depthTest: {
            enabled: !0
          }
        },
        material: new Cesium.Material({
          fabric: {
            type: "Image",
            uniforms: {
              image: c
            }
          }
        })
      });
    } else
      u.appearance = new Cesium.PerInstanceColorAppearance(l);
    return this.setReferenceForPicking(t, n, u), u;
  }
  /**
   * Return the fill or stroke color from a plain ol style.
   * @param {!ol.style.Style|ol.style.Text} style
   * @param {boolean} outline
   * @return {!Cesium.Color}
   * @protected
   */
  extractColorFromOlStyle(t, n) {
    const s = t.getFill() ? t.getFill().getColor() : null, r = t.getStroke() ? t.getStroke().getColor() : null;
    let i = "black";
    return r && n ? i = r : s && (i = s), Vt.convertColorToCesium(i);
  }
  /**
   * Return the width of stroke from a plain ol style.
   * @param {!ol.style.Style|ol.style.Text} style
   * @return {number}
   * @protected
   */
  extractLineWidthFromOlStyle(t) {
    const n = t.getStroke() ? t.getStroke().getWidth() : void 0;
    return n !== void 0 ? n : 1;
  }
  /**
   * Create a primitive collection out of two Cesium geometries.
   * Only the OpenLayers style colors will be used.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.
   * @param {!Cesium.Geometry} fillGeometry
   * @param {!Cesium.Geometry} outlineGeometry
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection}
   * @protected
   */
  wrapFillAndOutlineGeometries(t, n, s, r, i, a) {
    const o = this.extractColorFromOlStyle(a, !1), l = this.extractColorFromOlStyle(a, !0), f = new Cesium.PrimitiveCollection();
    if (a.getFill()) {
      const d = this.createColoredPrimitive(
        t,
        n,
        s,
        r,
        o
      );
      console.assert(!!d), f.add(d);
    }
    if (a.getStroke() && i) {
      const d = this.extractLineWidthFromOlStyle(a), u = this.createColoredPrimitive(
        t,
        n,
        s,
        i,
        l,
        d
      );
      u && f.add(u);
    }
    return f;
  }
  // Geometry converters
  /**
   * Create a Cesium primitive if style has a text component.
   * Eventually return a PrimitiveCollection including current primitive.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Style} style
   * @param {!Cesium.Primitive} primitive current primitive
   * @return {!Cesium.PrimitiveCollection}
   * @protected
   */
  addTextStyle(t, n, s, r, i) {
    let a;
    if (i instanceof Cesium.PrimitiveCollection ? a = i : (a = new Cesium.PrimitiveCollection(), a.add(i)), !r.getText())
      return a;
    const o = (
      /** @type {!ol.style.Text} */
      r.getText()
    ), l = this.olGeometry4326TextPartToCesium(
      t,
      n,
      s,
      o
    );
    return l && a.add(l), a;
  }
  /**
   * Add a billboard to a Cesium.BillboardCollection.
   * Overriding this wrapper allows manipulating the billboard options.
   * @param {!Cesium.BillboardCollection} billboards
   * @param {!Cesium.optionsBillboardCollectionAdd} bbOptions
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Style} style
   * @return {!Cesium.Billboard} newly created billboard
   * @api
   */
  csAddBillboard(t, n, s, r, i, a) {
    n.eyeOffset || (n.eyeOffset = this.defaultBillboardEyeOffset_);
    const o = t.add(n);
    return this.setReferenceForPicking(s, r, o), o;
  }
  /**
   * Convert an OpenLayers circle geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Circle} olGeometry OpenLayers circle geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olCircleGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "Circle");
    let a = s.getCenter();
    const o = a.length == 3 ? a[2] : 0;
    let l = a.slice();
    l[0] += s.getRadius(), a = Vt.ol4326CoordinateToCesiumCartesian(a), l = Vt.ol4326CoordinateToCesiumCartesian(l);
    const f = Cesium.Cartesian3.distance(a, l), d = new Cesium.CircleGeometry({
      // always update Cesium externs before adding a property
      center: a,
      radius: f,
      height: o
    });
    let u, c;
    if (this.getHeightReference(t, n, s) === Cesium.HeightReference.CLAMP_TO_GROUND) {
      const p = this.extractLineWidthFromOlStyle(i);
      if (p) {
        const g = P1(s.getCenter(), f), m = Vt.ol4326CoordinateArrayToCsCartesians(g.getLinearRing(0).getCoordinates());
        if (pg(this.scene))
          u = new Cesium.GroundPolylinePrimitive({
            geometryInstances: new Cesium.GeometryInstance({
              geometry: new Cesium.GroundPolylineGeometry({ positions: m, width: p })
            }),
            appearance: new Cesium.PolylineMaterialAppearance({
              material: this.olStyleToCesium(n, i, !0)
            }),
            classificationType: Cesium.ClassificationType.TERRAIN
          }), u.readyPromise.then(() => {
            this.setReferenceForPicking(t, n, u._primitive);
          });
        else {
          const v = this.extractColorFromOlStyle(i, !0);
          u = this.createStackedGroundCorridors(t, n, p, v, m);
        }
      }
    } else
      c = new Cesium.CircleOutlineGeometry({
        // always update Cesium externs before adding a property
        center: a,
        radius: f,
        extrudedHeight: o,
        height: o
      });
    const h = this.wrapFillAndOutlineGeometries(
      t,
      n,
      s,
      d,
      c,
      i
    );
    return u && h.add(u), this.addTextStyle(t, n, s, i, h);
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!number} width The width of the line.
   * @param {!Cesium.Color} color The color of the line.
   * @param {!Array<Cesium.Cartesian3>|Array<Array<Cesium.Cartesian3>>} positions The vertices of the line(s).
   * @return {!Cesium.GroundPrimitive} primitive
   */
  createStackedGroundCorridors(t, n, s, r, i) {
    Array.isArray(i[0]) || (i = [i]), s = Math.max(3, s);
    const a = [];
    let o = 0;
    for (const l of [1e3, 4e3, 16e3, 64e3, 254e3, 1e6, 1e7]) {
      s *= 2.14;
      const f = {
        // always update Cesium externs before adding a property
        width: s,
        vertexFormat: Cesium.VertexFormat.POSITION_ONLY
      };
      for (const d of i)
        f.positions = d, a.push(new Cesium.GeometryInstance({
          geometry: new Cesium.CorridorGeometry(f),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(r),
            distanceDisplayCondition: new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(o, l - 1)
          }
        }));
      o = l;
    }
    return new Cesium.GroundPrimitive({
      // always update Cesium externs before adding a property
      geometryInstances: a
    });
  }
  /**
   * Convert an OpenLayers line string geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.LineString} olGeometry OpenLayers line string geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olLineStringGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "LineString");
    const a = Vt.ol4326CoordinateArrayToCsCartesians(s.getCoordinates()), o = this.extractLineWidthFromOlStyle(i);
    let l;
    const f = this.getHeightReference(t, n, s);
    if (f === Cesium.HeightReference.CLAMP_TO_GROUND && !pg(this.scene)) {
      const d = this.extractColorFromOlStyle(i, !0);
      l = this.createStackedGroundCorridors(t, n, o, d, a);
    } else {
      const d = new Cesium.PolylineMaterialAppearance({
        // always update Cesium externs before adding a property
        material: this.olStyleToCesium(n, i, !0)
      }), u = {
        // always update Cesium externs before adding a property
        positions: a,
        width: o
      }, c = {
        // always update Cesium externs before adding a property
        appearance: d
      };
      if (f === Cesium.HeightReference.CLAMP_TO_GROUND) {
        const h = new Cesium.GroundPolylineGeometry(u);
        c.geometryInstances = new Cesium.GeometryInstance({
          geometry: h
        }), l = new Cesium.GroundPolylinePrimitive(c), l.readyPromise.then(() => {
          this.setReferenceForPicking(t, n, l._primitive);
        });
      } else {
        u.vertexFormat = d.vertexFormat;
        const h = new Cesium.PolylineGeometry(u);
        c.geometryInstances = new Cesium.GeometryInstance({
          geometry: h
        }), l = new Cesium.Primitive(c);
      }
    }
    return this.setReferenceForPicking(t, n, l), this.addTextStyle(t, n, s, i, l);
  }
  /**
   * Convert an OpenLayers polygon geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Polygon} olGeometry OpenLayers polygon geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @return {!Cesium.PrimitiveCollection} primitives
   * @api
   */
  olPolygonGeometryToCesium(t, n, s, r, i) {
    s = Vt.olGeometryCloneTo4326(s, r), console.assert(s.getType() == "Polygon");
    const a = this.getHeightReference(t, n, s);
    let o, l, f;
    if (s.getCoordinates()[0].length == 5 && n.getGeometry().get("olcs.polygon_kind") === "rectangle") {
      const u = s.getCoordinates()[0], c = Jl(u), h = Cesium.Rectangle.fromDegrees(
        c[0],
        c[1],
        c[2],
        c[3]
      );
      let p = 0;
      if (u[0].length == 3)
        for (let g = 0; g < u.length; g++)
          p = Math.max(p, u[g][2]);
      o = new Cesium.RectangleGeometry({
        ellipsoid: Cesium.Ellipsoid.WGS84,
        rectangle: h,
        height: p
      }), l = new Cesium.RectangleOutlineGeometry({
        ellipsoid: Cesium.Ellipsoid.WGS84,
        rectangle: h,
        height: p
      });
    } else {
      const u = s.getLinearRings(), c = {}, h = c;
      console.assert(u.length > 0);
      for (let p = 0; p < u.length; ++p) {
        const g = u[p].getCoordinates(), m = Vt.ol4326CoordinateArrayToCsCartesians(g);
        console.assert(m && m.length > 0), p == 0 ? c.positions = m : (c.holes || (c.holes = []), c.holes.push({
          positions: m
        }));
      }
      if (o = new Cesium.PolygonGeometry({
        // always update Cesium externs before adding a property
        polygonHierarchy: h,
        perPositionHeight: !0
      }), a === Cesium.HeightReference.CLAMP_TO_GROUND) {
        const p = this.extractLineWidthFromOlStyle(i);
        if (p > 0) {
          const g = [c.positions];
          if (c.holes)
            for (let m = 0; m < c.holes.length; ++m)
              g.push(c.holes[m].positions);
          if (pg(this.scene)) {
            const m = new Cesium.PolylineMaterialAppearance({
              // always update Cesium externs before adding a property
              material: this.olStyleToCesium(n, i, !0)
            }), v = [];
            for (const E of g) {
              const C = new Cesium.GroundPolylineGeometry({ positions: E, width: p });
              v.push(new Cesium.GeometryInstance({
                geometry: C
              }));
            }
            const y = {
              // always update Cesium externs before adding a property
              appearance: m,
              geometryInstances: v
            };
            f = new Cesium.GroundPolylinePrimitive(y), f.readyPromise.then(() => {
              this.setReferenceForPicking(t, n, f._primitive);
            });
          } else {
            const m = this.extractColorFromOlStyle(i, !0);
            f = this.createStackedGroundCorridors(t, n, p, m, g);
          }
        }
      } else
        l = new Cesium.PolygonOutlineGeometry({
          // always update Cesium externs before adding a property
          polygonHierarchy: c,
          perPositionHeight: !0
        });
    }
    const d = this.wrapFillAndOutlineGeometries(
      t,
      n,
      s,
      o,
      l,
      i
    );
    return f && d.add(f), this.addTextStyle(t, n, s, i, d);
  }
  /**
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @return {!Cesium.HeightReference}
   * @api
   */
  getHeightReference(t, n, s) {
    let r = s.get("altitudeMode");
    r === void 0 && (r = n.get("altitudeMode")), r === void 0 && (r = t.get("altitudeMode"));
    let i = Cesium.HeightReference.NONE;
    return r === "clampToGround" ? i = Cesium.HeightReference.CLAMP_TO_GROUND : r === "relativeToGround" && (i = Cesium.HeightReference.RELATIVE_TO_GROUND), i;
  }
  /**
   * Convert a point geometry to a Cesium BillboardCollection.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} style
   * @param {!ol.style.Image} imageStyle
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when the new billboard is added.
   * @api
   */
  createBillboardFromImage(t, n, s, r, i, a, o, l) {
    a instanceof vs && a.load();
    const f = a.getImage(1), d = function(c) {
      return c.src != "" && c.naturalHeight != 0 && c.naturalWidth != 0 && c.complete;
    }, u = (function() {
      if (!f || !(f instanceof HTMLCanvasElement || f instanceof Image || f instanceof HTMLImageElement))
        return;
      const c = s.getCoordinates(), h = Vt.ol4326CoordinateToCesiumCartesian(c);
      let p;
      const g = a.getOpacity();
      g !== void 0 && (p = new Cesium.Color(1, 1, 1, g));
      const m = a.getScale(), v = this.getHeightReference(t, n, s), y = (
        /** @type {Cesium.optionsBillboardCollectionAdd} */
        {
          // always update Cesium externs before adding a property
          image: f,
          color: p,
          scale: m,
          heightReference: v,
          position: h
        }
      );
      if (Object.assign(y, n.get("cesiumOptions")), a instanceof vs) {
        const C = a.getAnchor();
        C && (y.pixelOffset = new Cesium.Cartesian2((f.width / 2 - C[0]) * m, (f.height / 2 - C[1]) * m));
      }
      const E = this.csAddBillboard(o, y, t, n, s, i);
      l && l(E);
    }).bind(this);
    if (f instanceof Image && !d(f)) {
      let c = !1;
      const h = t.getSource(), p = function() {
        c = !0;
      };
      h.on(
        ["removefeature", "clear"],
        this.boundOnRemoveOrClearFeatureListener_
      );
      let g = nn.obj(h).olcs_cancellers;
      g || (g = nn.obj(h).olcs_cancellers = {});
      const m = Qe(n);
      g[m] && g[m](), g[m] = p;
      const v = function() {
        f.removeEventListener("load", v), !o.isDestroyed() && !c && u();
      };
      f.addEventListener("load", v);
    } else
      u();
  }
  /**
   * Convert a point geometry to a Cesium BillboardCollection.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} style
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when
   * the new billboard is added.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olPointGeometryToCesium(t, n, s, r, i, a, o) {
    console.assert(s.getType() == "Point"), s = Vt.olGeometryCloneTo4326(s, r);
    let l = null;
    const f = i.getImage();
    if (f) {
      const d = (
        /** @type {function():olcsx.ModelStyle} */
        s.get("olcs_model") || n.get("olcs_model")
      );
      if (d) {
        const u = d(), c = (
          /** @type {Cesium.ModelFromGltfOptions} */
          Object.assign({}, { scene: this.scene }, u.cesiumOptions)
        ), h = Cesium.Model.fromGltf(c);
        l = new Cesium.PrimitiveCollection(), l.add(h), u.debugModelMatrix && l.add(new Cesium.DebugModelMatrixPrimitive({
          modelMatrix: u.debugModelMatrix
        }));
      } else
        this.createBillboardFromImage(t, n, s, r, i, f, a, o);
    }
    return i.getText() ? this.addTextStyle(t, n, s, i, l || new Cesium.Primitive()) : l;
  }
  /**
   * Convert an OpenLayers multi-something geometry to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry OpenLayers geometry.
   * @param {!ol.ProjectionLike} projection
   * @param {!ol.style.Style} olStyle
   * @param {!Cesium.BillboardCollection} billboards
   * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when
   * the new billboard is added.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olMultiGeometryToCesium(t, n, s, r, i, a, o) {
    const l = function(d, u) {
      const c = new Cesium.PrimitiveCollection();
      return d.forEach((h) => {
        c.add(u(t, n, h, r, i));
      }), c;
    };
    let f;
    switch (s.getType()) {
      case "MultiPoint":
        if (s = /** @type {!ol.geom.MultiPoint} */
        s, f = s.getPoints(), i.getText()) {
          const d = new Cesium.PrimitiveCollection();
          return f.forEach((u) => {
            console.assert(u);
            const c = this.olPointGeometryToCesium(
              t,
              n,
              u,
              r,
              i,
              a,
              o
            );
            c && d.add(c);
          }), d;
        } else
          return f.forEach((d) => {
            console.assert(d), this.olPointGeometryToCesium(
              t,
              n,
              d,
              r,
              i,
              a,
              o
            );
          }), null;
      case "MultiLineString":
        return s = /** @type {!ol.geom.MultiLineString} */
        s, f = s.getLineStrings(), l(f, this.olLineStringGeometryToCesium.bind(this));
      case "MultiPolygon":
        return s = /** @type {!ol.geom.MultiPolygon} */
        s, f = s.getPolygons(), l(f, this.olPolygonGeometryToCesium.bind(this));
      default:
        console.assert(!1, `Unhandled multi geometry type${s.getType()}`);
    }
  }
  /**
   * Convert an OpenLayers text style to Cesium.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature..
   * @param {!ol.geom.Geometry} geometry
   * @param {!ol.style.Text} style
   * @return {Cesium.LabelCollection} Cesium primitive
   * @api
   */
  olGeometry4326TextPartToCesium(t, n, s, r) {
    const i = r.getText();
    if (!i)
      return null;
    const a = new Cesium.LabelCollection({ scene: this.scene }), o = $i(s.getExtent());
    if (s instanceof oa) {
      const p = s.getFirstCoordinate();
      o[2] = p.length == 3 ? p[2] : 0;
    }
    const l = (
      /** @type {Cesium.optionsLabelCollection} */
      {}
    );
    l.position = Vt.ol4326CoordinateToCesiumCartesian(o), l.text = i, l.heightReference = this.getHeightReference(t, n, s);
    const f = r.getOffsetX(), d = r.getOffsetY();
    if (f != 0 && d != 0) {
      const p = new Cesium.Cartesian2(f, d);
      l.pixelOffset = p;
    }
    l.font = r.getFont() || "10px sans-serif";
    let u;
    r.getFill() && (l.fillColor = this.extractColorFromOlStyle(r, !1), u = Cesium.LabelStyle.FILL), r.getStroke() && (l.outlineWidth = this.extractLineWidthFromOlStyle(r), l.outlineColor = this.extractColorFromOlStyle(r, !0), u = Cesium.LabelStyle.OUTLINE), r.getFill() && r.getStroke() && (u = Cesium.LabelStyle.FILL_AND_OUTLINE), l.style = u;
    let c;
    switch (r.getTextAlign()) {
      case "left":
        c = Cesium.HorizontalOrigin.LEFT;
        break;
      case "right":
        c = Cesium.HorizontalOrigin.RIGHT;
        break;
      case "center":
      default:
        c = Cesium.HorizontalOrigin.CENTER;
    }
    if (l.horizontalOrigin = c, r.getTextBaseline()) {
      let p;
      switch (r.getTextBaseline()) {
        case "top":
          p = Cesium.VerticalOrigin.TOP;
          break;
        case "middle":
          p = Cesium.VerticalOrigin.CENTER;
          break;
        case "bottom":
          p = Cesium.VerticalOrigin.BOTTOM;
          break;
        case "alphabetic":
          p = Cesium.VerticalOrigin.TOP;
          break;
        case "hanging":
          p = Cesium.VerticalOrigin.BOTTOM;
          break;
        default:
          console.assert(!1, `unhandled baseline ${r.getTextBaseline()}`);
      }
      l.verticalOrigin = p;
    }
    const h = a.add(l);
    return this.setReferenceForPicking(t, n, h), a;
  }
  /**
   * Convert an OpenLayers style to a Cesium Material.
   * @param {ol.Feature} feature OpenLayers feature..
   * @param {!ol.style.Style} style
   * @param {boolean} outline
   * @return {Cesium.Material}
   * @api
   */
  olStyleToCesium(t, n, s) {
    const r = n.getFill(), i = n.getStroke();
    if (s && !i || !s && !r)
      return null;
    let a = s ? i.getColor() : r.getColor();
    return a = Vt.convertColorToCesium(a), s && i.getLineDash() ? Cesium.Material.fromType("Stripe", {
      // always update Cesium externs before adding a property
      horizontal: !1,
      repeat: 500,
      // TODO how to calculate this?
      evenColor: a,
      oddColor: new Cesium.Color(0, 0, 0, 0)
      // transparent
    }) : Cesium.Material.fromType("Color", {
      // always update Cesium externs before adding a property
      color: a
    });
  }
  /**
   * Compute OpenLayers plain style.
   * Evaluates style function, blend arrays, get default style.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature
   * @param {ol.StyleFunction|undefined} fallbackStyleFunction
   * @param {number} resolution
   * @return {Array.<!ol.style.Style>} null if no style is available
   * @api
   */
  computePlainStyle(t, n, s, r) {
    const i = n.getStyleFunction();
    let a = null;
    return i && (a = i(n, r)), !a && s && (a = s(n, r)), a ? Array.isArray(a) ? a : [a] : null;
  }
  /**
   * @protected
   * @param {!ol.Feature} feature
   * @param {!ol.style.Style} style
   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.
   * @return {ol.geom.Geometry|undefined}
   */
  getGeometryFromFeature(t, n, s) {
    if (s)
      return s;
    const r = (
      /** @type {!ol.geom.Geometry} */
      t.get("olcs.3d_geometry")
    );
    if (r && r instanceof Cd)
      return r;
    if (n) {
      const i = n.getGeometryFunction()(t);
      if (i instanceof Cd)
        return i;
    }
    return t.getGeometry();
  }
  /**
   * Convert one OpenLayers feature up to a collection of Cesium primitives.
   * @param {ol.layer.Vector|ol.layer.Image} layer
   * @param {!ol.Feature} feature OpenLayers feature.
   * @param {!ol.style.Style} style
   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context
   * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.
   * @return {Cesium.Primitive} primitives
   * @api
   */
  olFeatureToCesium(t, n, s, r, i) {
    let a = this.getGeometryFromFeature(n, s, i);
    if (!a)
      return null;
    const o = r.projection, l = function(f) {
      const d = r.featureToCesiumMap[Qe(n)];
      d instanceof Array ? d.push(f) : r.featureToCesiumMap[Qe(n)] = [f];
    };
    switch (a.getType()) {
      case "GeometryCollection":
        const f = new Cesium.PrimitiveCollection();
        return /** @type {!ol.geom.GeometryCollection} */ a.getGeometries().forEach((p) => {
          if (p) {
            const g = this.olFeatureToCesium(
              t,
              n,
              s,
              r,
              p
            );
            g && f.add(g);
          }
        }), f;
      case "Point":
        a = /** @type {!ol.geom.Point} */
        a;
        const u = r.billboards, c = this.olPointGeometryToCesium(
          t,
          n,
          a,
          o,
          s,
          u,
          l
        );
        return c || null;
      case "Circle":
        return a = /** @type {!ol.geom.Circle} */
        a, this.olCircleGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "LineString":
        return a = /** @type {!ol.geom.LineString} */
        a, this.olLineStringGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "Polygon":
        return a = /** @type {!ol.geom.Polygon} */
        a, this.olPolygonGeometryToCesium(
          t,
          n,
          a,
          o,
          s
        );
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        const h = this.olMultiGeometryToCesium(
          t,
          n,
          a,
          o,
          s,
          r.billboards,
          l
        );
        return h || null;
      case "LinearRing":
        throw new Error("LinearRing should only be part of polygon.");
      default:
        throw new Error(`Ol geom type not handled : ${a.getType()}`);
    }
  }
  /**
   * Convert an OpenLayers vector layer to Cesium primitive collection.
   * For each feature, the associated primitive will be stored in
   * `featurePrimitiveMap`.
   * @param {!(ol.layer.Vector|ol.layer.Image)} olLayer
   * @param {!ol.View} olView
   * @param {!Object.<number, !Cesium.Primitive>} featurePrimitiveMap
   * @return {!olcs.core.VectorLayerCounterpart}
   * @api
   */
  olVectorLayerToCesium(t, n, s) {
    const r = n.getProjection(), i = n.getResolution();
    if (i === void 0 || !r)
      throw console.assert(!1, "View not ready"), new Error("View not ready");
    let a = t.getSource();
    a instanceof E0 && (a = a.getSource()), console.assert(a instanceof Ur);
    const o = a.getFeatures(), l = new pH(r, this.scene), f = l.context;
    for (let d = 0; d < o.length; ++d) {
      const u = o[d];
      if (!u)
        continue;
      const c = t.getStyleFunction(), h = this.computePlainStyle(
        t,
        u,
        c,
        i
      );
      if (!h || !h.length)
        continue;
      let p = null;
      for (let g = 0; g < h.length; g++) {
        const m = this.olFeatureToCesium(t, u, h[g], f);
        if (m) {
          if (!p)
            p = m;
          else if (m) {
            let v = 0, y;
            for (; y = m.get(v); )
              p.add(y), v++;
          }
        }
      }
      p && (s[Qe(u)] = p, l.getRootPrimitive().add(p));
    }
    return l;
  }
  /**
   * Convert an OpenLayers feature to Cesium primitive collection.
   * @param {!(ol.layer.Vector|ol.layer.Image)} layer
   * @param {!ol.View} view
   * @param {!ol.Feature} feature
   * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context
   * @return {Cesium.Primitive}
   * @api
   */
  convert(t, n, s, r) {
    const i = n.getProjection(), a = n.getResolution();
    if (a == null || !i)
      return null;
    const o = t.getStyleFunction(), l = this.computePlainStyle(t, s, o, a);
    if (!l || !l.length)
      return null;
    r.projection = i;
    let f = null;
    for (let d = 0; d < l.length; d++) {
      const u = this.olFeatureToCesium(t, s, l[d], r);
      if (!f)
        f = u;
      else if (u) {
        let c = 0, h;
        for (; h = u.get(c); )
          f.add(h), c++;
      }
    }
    return f;
  }
}
class MI extends IE {
  /**
   * Unidirectionally synchronize OpenLayers vector layers to Cesium.
   * @param {!ol.Map} map
   * @param {!Cesium.Scene} scene
   * @param {olcs.FeatureConverter=} opt_converter
   * @extends {olcs.AbstractSynchronizer.<olcs.core.VectorLayerCounterpart>}
   * @api
   */
  constructor(t, n, s) {
    super(t, n), this.converter = s || new mH(n), this.csAllPrimitives_ = new Cesium.PrimitiveCollection(), n.primitives.add(this.csAllPrimitives_), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    console.assert(t), t.getRootPrimitive().counterpart = t, this.csAllPrimitives_.add(t.getRootPrimitive());
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.getRootPrimitive().destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    t.destroy(), this.csAllPrimitives_.destroyPrimitives = n, this.csAllPrimitives_.remove(t.getRootPrimitive()), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    if (this.csAllPrimitives_.destroyPrimitives = t, t)
      for (let n = 0; n < this.csAllPrimitives_.length; ++n)
        this.csAllPrimitives_.get(n).counterpart.destroy();
    this.csAllPrimitives_.removeAll(), this.csAllPrimitives_.destroyPrimitives = !1;
  }
  /**
   * Synchronizes the layer visibility properties
   * to the given Cesium Primitive.
   * @param {import('olsc/core.js').LayerWithParents} olLayerWithParents
   * @param {!Cesium.Primitive} csPrimitive
   */
  updateLayerVisibility(t, n) {
    let s = !0;
    [t.layer].concat(t.parents).forEach((r) => {
      const i = r.getVisible();
      i !== void 0 ? s &= i : s = !1;
    }), n.show = s;
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer;
    if (!(n instanceof sr) || n instanceof O0)
      return null;
    console.assert(n instanceof hu);
    let s = n.getSource();
    if (s instanceof E0 && (s = s.getSource()), !s)
      return null;
    console.assert(s instanceof Ur), console.assert(this.view);
    const r = this.view, i = {}, a = this.converter.olVectorLayerToCesium(
      n,
      r,
      i
    ), o = a.getRootPrimitive(), l = a.olListenKeys;
    [t.layer].concat(t.parents).forEach((u) => {
      l.push(Nl(u, "change:visible", () => {
        this.updateLayerVisibility(t, o);
      }));
    }), this.updateLayerVisibility(t, o);
    const f = (function(u) {
      console.assert(
        n instanceof sr || n instanceof Uf
      );
      const c = a.context, h = this.converter.convert(n, r, u, c);
      h && (i[Qe(u)] = h, o.add(h));
    }).bind(this), d = (function(u) {
      const c = Qe(u), h = a.context, p = h.featureToCesiumMap[c];
      p && (delete h.featureToCesiumMap[c], p.forEach((m) => {
        m instanceof Cesium.Billboard && h.billboards.remove(m);
      }));
      const g = i[c];
      delete i[c], g && o.remove(g);
    }).bind(this);
    return l.push(Nl(s, "addfeature", (u) => {
      console.assert(u.feature), f(u.feature);
    })), l.push(Nl(s, "removefeature", (u) => {
      console.assert(u.feature), d(u.feature);
    })), l.push(Nl(s, "changefeature", (u) => {
      const c = u.feature;
      console.assert(c), d(c), f(c);
    })), a ? [a] : null;
  }
}
class gH extends ky {
  /**
   * @param {olcsx.SynchronizedOverlayOptions} options SynchronizedOverlay Options.
   * @api
   */
  constructor(t) {
    const n = t.parent;
    super(n.getOptions()), this.scenePostRenderListenerRemover_ = null, this.scene_ = t.scene, this.synchronizer_ = t.synchronizer, this.parent_ = n, this.positionWGS84_ = void 0, this.observer_ = new MutationObserver(this.handleElementChanged.bind(this)), this.attributeObserver_ = [], this.listenerKeys_ = [];
    const s = (r) => this.setPropertyFromEvent_(r);
    this.listenerKeys_.push(this.parent_.on("change:position", s)), this.listenerKeys_.push(this.parent_.on("change:element", s)), this.listenerKeys_.push(this.parent_.on("change:offset", s)), this.listenerKeys_.push(this.parent_.on("change:position", s)), this.listenerKeys_.push(this.parent_.on("change:positioning", s)), this.setProperties(this.parent_.getProperties()), this.handleMapChanged(), this.handleElementChanged();
  }
  /**
   * @param {Node} target
   * @private
   */
  observeTarget_(t) {
    if (this.observer_) {
      this.observer_.disconnect(), this.observer_.observe(t, {
        attributes: !1,
        childList: !0,
        characterData: !0,
        subtree: !0
      }), this.attributeObserver_.forEach((n) => {
        n.disconnect();
      }), this.attributeObserver_.length = 0;
      for (let n = 0; n < t.childNodes.length; n++) {
        const s = t.childNodes[n];
        if (s.nodeType === 1) {
          const r = new MutationObserver(this.handleElementChanged.bind(this));
          r.observe(s, {
            attributes: !0,
            subtree: !0
          }), this.attributeObserver_.push(r);
        }
      }
    }
  }
  /**
   *
   * @param {ol.Object.Event} event
   * @private
   */
  setPropertyFromEvent_(t) {
    t.target && t.key && this.set(t.key, t.target.get(t.key));
  }
  /**
   * Get the scene associated with this overlay.
   * @see ol.Overlay.prototype.getMap
   * @return {!Cesium.Scene} The scene that the overlay is part of.
   * @api
   */
  getScene() {
    return this.scene_;
  }
  /**
   * @override
   */
  handleMapChanged() {
    this.scenePostRenderListenerRemover_ && (this.scenePostRenderListenerRemover_(), iH(this.element)), this.scenePostRenderListenerRemover_ = null;
    const t = this.getScene();
    if (t) {
      this.scenePostRenderListenerRemover_ = t.postRender.addEventListener(this.updatePixelPosition.bind(this)), this.updatePixelPosition();
      const n = this.stopEvent ? this.synchronizer_.getOverlayContainerStopEvent() : this.synchronizer_.getOverlayContainer();
      this.insertFirst ? n.insertBefore(this.element, n.childNodes[0] || null) : n.appendChild(this.element);
    }
  }
  /**
   * @override
   */
  handlePositionChanged() {
    const t = this.getPosition();
    if (t) {
      const n = this.parent_.getMap().getView().getProjection();
      this.positionWGS84_ = Ui(t, n, "EPSG:4326");
    } else
      this.positionWGS84_ = void 0;
    this.updatePixelPosition();
  }
  /**
   * @override
   */
  handleElementChanged() {
    function t(s, r) {
      const i = s.cloneNode();
      s.nodeName === "CANVAS" && i.getContext("2d").drawImage(s, 0, 0), r && r.appendChild(i), s.nodeType != Node.TEXT_NODE && i.addEventListener("click", (o) => {
        s.dispatchEvent(new MouseEvent("click", o)), o.stopPropagation();
      });
      const a = s.childNodes;
      for (let o = 0; o < a.length; o++)
        a[o] && t(a[o], i);
      return i;
    }
    rH(this.element);
    const n = this.getElement();
    if (n && n.parentNode && n.parentNode.childNodes)
      for (const s of n.parentNode.childNodes) {
        const r = t(s, null);
        this.element.appendChild(r);
      }
    n.parentNode && this.observeTarget_(n.parentNode);
  }
  /**
   * @override
   */
  updatePixelPosition() {
    const t = this.positionWGS84_;
    if (!this.scene_ || !t) {
      this.setVisible(!1);
      return;
    }
    let n = 0;
    if (t.length === 2) {
      const u = this.scene_.globe.getHeight(Cesium.Cartographic.fromDegrees(t[0], t[1]));
      u && this.scene_.globe.tilesLoaded && (t[2] = u), u && (n = u);
    } else
      n = t[2];
    const s = Cesium.Cartesian3.fromDegrees(t[0], t[1], n), r = this.scene_.camera, i = new Cesium.BoundingSphere(new Cesium.Cartesian3(), 6356752);
    if (!new Cesium.Occluder(i, r.position).isPointVisible(s)) {
      this.setVisible(!1);
      return;
    }
    if (r.frustum.computeCullingVolume(r.position, r.direction, r.up).computeVisibility(new Cesium.BoundingSphere(s)) !== 1) {
      this.setVisible(!1);
      return;
    }
    this.setVisible(!0);
    const l = this.scene_.cartesianToCanvasCoordinates(s), f = [l.x, l.y], d = [this.scene_.canvas.width, this.scene_.canvas.height];
    this.updateRenderedPosition(f, d);
  }
  /**
   * Destroys the overlay, removing all its listeners and elements
   * @api
   */
  destroy() {
    this.scenePostRenderListenerRemover_ && this.scenePostRenderListenerRemover_(), this.observer_ && this.observer_.disconnect(), zs(this.listenerKeys_), this.listenerKeys_.splice(0), this.element.removeNode ? this.element.removeNode(!0) : this.element.remove(), this.element = null;
  }
}
class _I {
  /**
  * @param {!ol.Map} map
  * @param {!Cesium.Scene} scene
  * @constructor
  * @template T
  * @api
  */
  constructor(t, n) {
    this.map = t, this.overlays_ = this.map.getOverlays(), this.scene = n, this.overlayContainerStopEvent_ = document.createElement("DIV"), this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"].forEach((r) => {
      this.overlayContainerStopEvent_.addEventListener(r, (i) => i.stopPropagation());
    }), this.scene.canvas.parentElement.appendChild(this.overlayContainerStopEvent_), this.overlayContainer_ = document.createElement("DIV"), this.overlayContainer_.className = "ol-overlaycontainer", this.scene.canvas.parentElement.appendChild(this.overlayContainer_), this.overlayMap_ = {};
  }
  /**
  * Get the element that serves as a container for overlays that don't allow
  * event propagation. Elements added to this container won't let mousedown and
  * touchstart events through to the map, so clicks and gestures on an overlay
  * don't trigger any {@link ol.MapBrowserEvent}.
  * @return {!Element} The map's overlay container that stops events.
  */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
  * Get the element that serves as a container for overlays.
  * @return {!Element} The map's overlay container.
  */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
  * Destroy all and perform complete synchronization of the overlays.
  * @api
  */
  synchronize() {
    this.destroyAll(), this.addOverlays(), this.overlays_.on("add", this.addOverlayFromEvent_.bind(this)), this.overlays_.on("remove", this.removeOverlayFromEvent_.bind(this));
  }
  /**
  * @param {ol.Collection.Event} event
  * @private
  */
  addOverlayFromEvent_(t) {
    const n = (
      /** @type {ol.Overlay} */
      t.element
    );
    this.addOverlay(n);
  }
  /**
  * @api
  */
  addOverlays() {
    this.overlays_.forEach((t) => {
      this.addOverlay(t);
    });
  }
  /**
  * @param {ol.Overlay} overlay
  * @api
  */
  addOverlay(t) {
    if (!t)
      return;
    const n = new gH({
      scene: this.scene,
      synchronizer: this,
      parent: t
    }), s = Qe(t).toString();
    this.overlayMap_[s] = n;
  }
  /**
  * @param {ol.Collection.Event} event
  * @private
  */
  removeOverlayFromEvent_(t) {
    const n = (
      /** @type {ol.Overlay} */
      t.element
    );
    this.removeOverlay(n);
  }
  /**
  * Removes an overlay from the scene
  * @param {ol.Overlay} overlay
  * @api
  */
  removeOverlay(t) {
    const n = Qe(t).toString(), s = this.overlayMap_[n];
    s && (s.destroy(), delete this.overlayMap_[n]);
  }
  /**
  * Destroys all the created Cesium objects.
  * @protected
  */
  destroyAll() {
    Object.keys(this.overlayMap_).forEach((t) => {
      this.overlayMap_[t].destroy(), delete this.overlayMap_[t];
    });
  }
}
class DE {
  /**
   * @param {!OLCesiumOptions} options Options.
   * @constructor
   * @api
   */
  constructor(t) {
    this.autoRenderLoop_ = null, this.map_ = t.map, this.time_ = t.time || function() {
      return Cesium.JulianDate.now();
    }, this.to4326Transform_ = Ka(this.map_.getView().getProjection(), "EPSG:4326"), this.resolutionScale_ = 1, this.canvasClientWidth_ = 0, this.canvasClientHeight_ = 0, this.resolutionScaleChanged_ = !0;
    const n = "position:absolute;top:0;left:0;width:100%;height:100%;";
    this.container_ = document.createElement("DIV");
    const s = document.createAttribute("style");
    s.value = `${n}visibility:hidden;`, this.container_.setAttributeNode(s);
    let r = t.target || this.map_.getViewport();
    if (typeof r == "string" && (r = document.getElementById(r)), r.appendChild(this.container_), this.isOverMap_ = !t.target, this.isOverMap_ && t.stopOpenLayersEventsPropagation) {
      const u = ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"];
      for (let c = 0, h = u.length; c < h; ++c)
        this.container_.addEventListener(u[c], (p) => p.stopPropagation());
    }
    this.canvas_ = /** @type {!HTMLCanvasElement} */
    document.createElement("CANVAS");
    const i = document.createAttribute("style");
    i.value = n, this.canvas_.setAttributeNode(i), nn.supportsImageRenderingPixelated() && (this.canvas_.style.imageRendering = nn.imageRenderingValue()), this.canvas_.oncontextmenu = function() {
      return !1;
    }, this.canvas_.onselectstart = function() {
      return !1;
    }, this.container_.appendChild(this.canvas_), this.enabled_ = !1, this.pausedInteractions_ = [], this.hiddenRootGroup_ = null;
    const a = t.sceneOptions !== void 0 ? t.sceneOptions : (
      /** @type {Cesium.SceneOptions} */
      {}
    );
    a.canvas = this.canvas_, a.scene3DOnly = !0, this.scene_ = new Cesium.Scene(a);
    const o = this.scene_.screenSpaceCameraController;
    o.tiltEventTypes.push({
      eventType: Cesium.CameraEventType.LEFT_DRAG,
      modifier: Cesium.KeyboardEventModifier.SHIFT
    }), o.tiltEventTypes.push({
      eventType: Cesium.CameraEventType.LEFT_DRAG,
      modifier: Cesium.KeyboardEventModifier.ALT
    }), o.enableLook = !1, this.scene_.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z, this.camera_ = new jl(this.scene_, this.map_), this.globe_ = new Cesium.Globe(Cesium.Ellipsoid.WGS84), this.globe_.baseColor = Cesium.Color.WHITE, this.scene_.globe = this.globe_, this.scene_.skyAtmosphere = new Cesium.SkyAtmosphere();
    const l = new Cesium.SingleTileImageryProvider({
      url: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=",
      rectangle: Cesium.Rectangle.fromDegrees(0, 0, 1, 1)
      // the Rectangle dimensions are arbitrary
    });
    this.globe_.imageryLayers.addImageryProvider(l, 0), this.dataSourceCollection_ = new Cesium.DataSourceCollection(), this.dataSourceDisplay_ = new Cesium.DataSourceDisplay({
      scene: this.scene_,
      dataSourceCollection: this.dataSourceCollection_
    });
    const f = t.createSynchronizers ? t.createSynchronizers(this.map_, this.scene_, this.dataSourceCollection_) : [
      new fH(this.map_, this.scene_),
      new MI(this.map_, this.scene_),
      new _I(this.map_, this.scene_)
    ];
    this.handleResize_();
    for (let u = f.length - 1; u >= 0; --u)
      f[u].synchronize();
    this.lastFrameTime_ = 0, this.renderId_ = void 0, this.targetFrameRate_ = Number.POSITIVE_INFINITY, this.blockCesiumRendering_ = !1, this.warmingUp_ = !1, this.trackedFeature_ = null, this.trackedEntity_ = null, this.entityView_ = null, this.needTrackedEntityUpdate_ = !1, this.boundingSphereScratch_ = new Cesium.BoundingSphere(), new Cesium.EventHelper().add(this.scene_.postRender, DE.prototype.updateTrackedEntity_, this), Cesium.Camera.enableSuspendTerrainAdjustment = !1;
  }
  /**
   * Render the Cesium scene.
   * @private
   */
  render_() {
    this.renderId_ !== void 0 && (cancelAnimationFrame(this.renderId_), this.renderId_ = void 0), (this.enabled_ || this.warmingUp_) && !this.blockCesiumRendering_ && (this.renderId_ = requestAnimationFrame(this.onAnimationFrame_.bind(this)));
  }
  /**
   * Callback for `requestAnimationFrame`.
   * @param {number} frameTime The frame time, from `performance.now()`.
   * @private
   */
  onAnimationFrame_(t) {
    this.renderId_ = void 0;
    const n = 1e3 / this.targetFrameRate_;
    if (t - this.lastFrameTime_ < n) {
      this.render_();
      return;
    }
    this.lastFrameTime_ = t;
    const r = this.time_();
    if (this.scene_.initializeFrame(), this.handleResize_(), this.dataSourceDisplay_.update(r), this.entityView_) {
      const i = this.trackedEntity_;
      this.dataSourceDisplay_.getBoundingSphere(i, !1, this.boundingSphereScratch_) === Cesium.BoundingSphereState.DONE && (this.boundingSphereScratch_.radius = 1, this.entityView_.update(r, this.boundingSphereScratch_));
    }
    this.scene_.render(r), this.camera_.checkCameraChange(), this.render_();
  }
  /**
   * @private
   */
  updateTrackedEntity_() {
    if (!this.needTrackedEntityUpdate_)
      return;
    const t = this.trackedEntity_, n = this.scene_, s = this.dataSourceDisplay_.getBoundingSphere(t, !1, this.boundingSphereScratch_);
    if (s === Cesium.BoundingSphereState.PENDING)
      return;
    n.screenSpaceCameraController.enableTilt = !1;
    const r = s !== Cesium.BoundingSphereState.FAILED ? this.boundingSphereScratch_ : void 0;
    r && (r.radius = 1), this.entityView_ = new Cesium.EntityView(t, n, n.mapProjection.ellipsoid), this.entityView_.update(this.time_(), r), this.needTrackedEntityUpdate_ = !1;
  }
  /**
   * @private
   */
  handleResize_() {
    let t = this.canvas_.clientWidth, n = this.canvas_.clientHeight;
    if (t === 0 | n === 0 || t === this.canvasClientWidth_ && n === this.canvasClientHeight_ && !this.resolutionScaleChanged_)
      return;
    let s = this.resolutionScale_;
    nn.supportsImageRenderingPixelated() || (s *= window.devicePixelRatio || 1), this.resolutionScaleChanged_ = !1, this.canvasClientWidth_ = t, this.canvasClientHeight_ = n, t *= s, n *= s, this.canvas_.width = t, this.canvas_.height = n, this.scene_.camera.frustum.aspectRatio = t / n;
  }
  /**
   * @return {!olcs.Camera}
   * @api
   */
  getCamera() {
    return this.camera_;
  }
  /**
   * @return {!ol.Map}
   * @api
   */
  getOlMap() {
    return this.map_;
  }
  /**
   * @return {!ol.View}
   * @api
   */
  getOlView() {
    const t = this.map_.getView();
    return console.assert(t), t;
  }
  /**
   * @return {!Cesium.Scene}
   * @api
   */
  getCesiumScene() {
    return this.scene_;
  }
  /**
   * @return {!Cesium.DataSourceCollection}
   * @api
   */
  getDataSources() {
    return this.dataSourceCollection_;
  }
  /**
   * @return {!Cesium.DataSourceDisplay}
   * @api
   */
  getDataSourceDisplay() {
    return this.dataSourceDisplay_;
  }
  /**
   * @return {boolean}
   * @api
   */
  getEnabled() {
    return this.enabled_;
  }
  /**
   * Enables/disables the Cesium.
   * This modifies the visibility style of the container element.
   * @param {boolean} enable
   * @api
   */
  setEnabled(t) {
    if (this.enabled_ === t)
      return;
    this.enabled_ = t, this.container_.style.visibility = this.enabled_ ? "visible" : "hidden";
    let n;
    if (this.enabled_) {
      if (this.throwOnUnitializedMap_(), this.isOverMap_) {
        n = this.map_.getInteractions(), n.forEach((r, i, a) => {
          this.pausedInteractions_.push(r);
        }), n.clear(), this.map_.addInteraction = (r) => this.pausedInteractions_.push(r), this.map_.removeInteraction = (r) => this.pausedInteractions_ = this.pausedInteractions_.filter((i) => i !== r);
        const s = this.map_.getLayerGroup();
        s.getVisible() && (this.hiddenRootGroup_ = s, this.hiddenRootGroup_.setVisible(!1)), this.map_.getOverlayContainer().classList.add("olcs-hideoverlay");
      }
      this.camera_.readFromView(), this.render_();
    } else
      this.isOverMap_ && (n = this.map_.getInteractions(), this.pausedInteractions_.forEach((s) => {
        n.push(s);
      }), this.pausedInteractions_.length = 0, this.map_.addInteraction = (s) => this.map_.getInteractions().push(s), this.map_.removeInteraction = (s) => this.map_.getInteractions().remove(s), this.map_.getOverlayContainer().classList.remove("olcs-hideoverlay"), this.hiddenRootGroup_ && (this.hiddenRootGroup_.setVisible(!0), this.hiddenRootGroup_ = null)), this.camera_.updateView();
  }
  /**
   * Preload Cesium so that it is ready when transitioning from 2D to 3D.
   * @param {number} height Target height of the camera
   * @param {number} timeout Milliseconds after which the warming will stop
   * @api
  */
  warmUp(t, n) {
    if (this.enabled_)
      return;
    this.throwOnUnitializedMap_(), this.camera_.readFromView();
    const s = this.globe_.ellipsoid, r = this.scene_.camera, i = s.cartesianToCartographic(r.position);
    i.height < t && (i.height = t, r.position = s.cartographicToCartesian(i)), this.warmingUp_ = !0, this.render_(), setTimeout(() => {
      this.warmingUp_ = !1;
    }, n);
  }
  /**
   * Block Cesium rendering to save resources.
   * @param {boolean} block True to block.
   * @api
  */
  setBlockCesiumRendering(t) {
    this.blockCesiumRendering_ !== t && (this.blockCesiumRendering_ = t, this.render_());
  }
  /**
   * Render the globe only when necessary in order to save resources.
   * Experimental.
   * @api
   */
  enableAutoRenderLoop() {
    this.autoRenderLoop_ || (this.autoRenderLoop_ = new dH(this));
  }
  /**
   * Get the autorender loop.
   * @return {?olcs.AutoRenderLoop}
   * @api
  */
  getAutoRenderLoop() {
    return this.autoRenderLoop_;
  }
  /**
   * The 3D Cesium globe is rendered in a canvas with two different dimensions:
   * clientWidth and clientHeight which are the dimension on the screen and
   * width and height which are the dimensions of the drawing buffer.
   *
   * By using a resolution scale lower than 1.0, it is possible to render the
   * globe in a buffer smaller than the canvas client dimensions and improve
   * performance, at the cost of quality.
   *
   * Pixel ratio should also be taken into account; by default, a device with
   * pixel ratio of 2.0 will have a buffer surface 4 times bigger than the client
   * surface.
   *
   * @param {number} value
   * @this {olcs.OLCesium}
   * @api
   */
  setResolutionScale(t) {
    t = Math.max(0, t), t !== this.resolutionScale_ && (this.resolutionScale_ = Math.max(0, t), this.resolutionScaleChanged_ = !0, this.autoRenderLoop_ && this.autoRenderLoop_.restartRenderLoop());
  }
  /**
   * Set the target frame rate for the renderer. Set to `Number.POSITIVE_INFINITY`
   * to render as quickly as possible.
   * @param {number} value The frame rate, in frames per second.
   * @api
   */
  setTargetFrameRate(t) {
    this.targetFrameRate_ !== t && (this.targetFrameRate_ = t, this.render_());
  }
  /**
   * Check if OpenLayers map is not properly initialized.
   * @private
   */
  throwOnUnitializedMap_() {
    const n = this.map_.getView(), s = n.getCenter();
    if (!n.isDef() || isNaN(s[0]) || isNaN(s[1]))
      throw new Error(`The OpenLayers map is not properly initialized: ${s} / ${n.getResolution()}`);
  }
  /**
   * @type {ol.Feature}
   */
  get trackedFeature() {
    return this.trackedFeature_;
  }
  /**
   * @param {ol.Feature} feature
   */
  set trackedFeature(t) {
    if (this.trackedFeature_ !== t) {
      const n = this.scene_;
      if (!t || !t.getGeometry()) {
        this.needTrackedEntityUpdate_ = !1, n.screenSpaceCameraController.enableTilt = !0, this.trackedEntity_ && this.dataSourceDisplay_.defaultDataSource.entities.remove(this.trackedEntity_), this.trackedEntity_ = null, this.trackedFeature_ = null, this.entityView_ = null, n.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
        return;
      }
      this.trackedFeature_ = t, this.needTrackedEntityUpdate_ = !0;
      const s = this.to4326Transform_, r = function() {
        const a = t.getGeometry();
        console.assert(a instanceof hi);
        const o = a.getCoordinates(), l = s(o, void 0, o.length);
        return Vt.ol4326CoordinateToCesiumCartesian(l);
      }, i = {
        position: new Cesium.CallbackProperty((a, o) => r(), !1),
        point: {
          pixelSize: 1,
          color: Cesium.Color.TRANSPARENT
        }
      };
      this.trackedEntity_ = this.dataSourceDisplay_.defaultDataSource.entities.add(i);
    }
  }
}
class vH extends _I {
  /* eslint-disable no-useless-constructor */
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers WMS raster layers to the given Cesium globe. This Synchronizer
   * assumes that the given WMS supports EPSG Code 4326 (WGS84)
   * @param {!ol.Map} map -
   * @param {!Cesium.Scene} scene -
   * @constructor
   * @extends {olcs.AbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   * @struct
   */
  constructor(t, n) {
    super(t, n);
  }
  /**
   * @api
   * @returns {void}
   */
  addOverlays() {
    this.overlays_.forEach((t) => {
      t.getId() !== void 0 && this.addOverlay(t);
    });
  }
}
class yH extends IE {
  /**
   * This object takes care of one-directional synchronization of
   * Openlayers WMS raster layers to the given Cesium globe. This Synchronizer
   * assumes that the given WMS supports EPSG Code 4326 (WGS84)
   * @param {!ol.Map} map -
   * @param {!Cesium.Scene} scene -
   * @constructor
   * @extends {olcs.AbstractSynchronizer.<Cesium.ImageryLayer>}
   * @api
   * @struct
   */
  constructor(t, n) {
    super(t, n), this.cesiumLayers = n.imageryLayers, this.ourLayers = new Cesium.ImageryLayerCollection();
  }
  /**
   * @inheritDoc
   */
  addCesiumObject(t) {
    this.cesiumLayers.add(t), this.ourLayers.add(t);
  }
  /**
   * @inheritDoc
   */
  destroyCesiumObject(t) {
    t.destroy();
  }
  /**
   * @inheritDoc
   */
  removeSingleCesiumObject(t, n) {
    this.cesiumLayers.remove(t, n), this.ourLayers.remove(t, !1);
  }
  /**
   * @inheritDoc
   */
  removeAllCesiumObjects(t) {
    for (let n = 0; n < this.ourLayers.length; ++n)
      this.cesiumLayers.remove(this.ourLayers.get(n), t);
    this.ourLayers.removeAll(!1);
  }
  /**
   * Creates an array of Cesium.ImageryLayer.
   * May be overriden by child classes to implement custom behavior.
   * The default implementation handles tiled imageries in EPSG:4326 or
   * EPSG:3859.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @return {?Array.<!Cesium.ImageryLayer>} Array or null if not possible.
   * (or supported)
   * @protected
   */
  convertLayerToCesiumImageries(t, n) {
    const s = {
      show: !1
    };
    let r = {}, i = {}, a = null;
    if (!(t instanceof Zc) && !(t instanceof Uf))
      return null;
    if (r = t.getSource(), r instanceof s0)
      a = this.createProviderForTileWMS(r, n, t);
    else {
      if (r instanceof o0)
        return [this.createImageryLayerForImageWMS(t, n)];
      if (r instanceof OI)
        a = this.createProviderForStaticImageSource(r);
      else if (r instanceof zf)
        a = new Cesium.WebMapTileServiceImageryProvider({
          url: r.getUrls()[0],
          format: r.getFormat(),
          layer: r.getLayer(),
          style: r.getStyle(),
          tileMatrixSetID: r.getMatrixSet(),
          tileMatrixLabels: r.getTileGrid().getMatrixIds(),
          credit: r.getAttributions()
        });
      else
        return console.warn("Sources other than TileImage are currently not supported."), null;
    }
    return i = new Cesium.ImageryLayer(a, s), i ? [i] : null;
  }
  /**
   * Creates an Cesium.WebMapServiceImageryProvider for RasterLayer of the type TileWMS.
   * @param {module:ol/source/TileWMS} source The raster layer source.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @returns {WebMapServiceImageryProvider} The imagery provider.
   */
  createProviderForTileWMS(t, n, s) {
    const r = t.getParams(), i = {
      url: t.getUrls()[0],
      parameters: r,
      layers: r.LAYERS,
      show: !1
    }, a = t.getTileGrid();
    if (a) {
      const o = s.getExtent();
      if (o && n) {
        i.rectangle = Vt.extentToRectangle(o, n);
        const l = this.getMinMaxLevelFromTileGrid(a, o, n);
        i.tileWidth = a.getTileSize(0)[0], i.tileHeight = a.getTileSize(0)[1], i.minimumLevel = l[0], i.maximumLevel = l[1];
      }
    }
    return new Cesium.WebMapServiceImageryProvider(i);
  }
  /**
   * Creates an Cesium.ImageryLayer for RasterLayer of the type ImageWMS.
   * @param {module:ol/layer/Base~BaseLayer } olLayer The raster layer.
   * @param {module:ol/proj} viewProj Projection of the view.
   * @returns {Cesium.ImageryLayer} The imagery layer.
   */
  createImageryLayerForImageWMS(t, n) {
    return Vt.tileLayerToImageryLayer(this.map, t, n);
  }
  /**
   * Creates an Cesium.SingleTileImageryProvider for RasterLayer of the type StaticImageSource.
   * @param {module:ol/source/ImageStatic} source The raster layer source.
   * @returns {SingleTileImageryProvider} The imagery provider.
   */
  createProviderForStaticImageSource(t) {
    const n = t.getImageExtent(), s = {
      url: t.getUrl(),
      show: !1
    }, r = fn(t.getProjection().getCode(), "EPSG:4326", So(n)), i = fn(t.getProjection().getCode(), "EPSG:4326", Mo(n));
    return s.rectangle = Cesium.Rectangle.fromDegrees(r[0], r[1], i[0], i[1]), new Cesium.SingleTileImageryProvider(s);
  }
  /**
   *
   * @param {ol.Extent} extent -
   * @param {ol.ProjectionLike} projection -
   * @return {Array.<Cesium.Cartographic>} -
   * @private
   */
  getExtentPoints(t, n) {
    const s = Wc(t, n, "EPSG:4326");
    return [
      So(s),
      Ql(s),
      Mo(s),
      gs(s)
    ].map((i) => Cesium.Cartographic.fromDegrees(i[0], i[1]));
  }
  /**
   *
   * @param {ol.tilegrid.TileGrid} tilegrid -
   * @param {ol.Extent} extent -
   * @param {ol.ProjectionLike} projection -
   * @return {Array.<Number>} -
   */
  getMinMaxLevelFromTileGrid(t, n, s) {
    const r = [
      So(n),
      Ql(n),
      Mo(n),
      gs(n)
    ], i = t.getResolutions().slice(-1).pop(), a = r.map((h) => t.getTileCoordForCoordAndResolution(h, i)), o = Math.abs(a[0][1] - a[1][1]), l = Math.abs(a[0][2] - a[3][2]), f = this.getExtentPoints(n, s), d = new Cesium.GeographicTilingScheme({});
    let u = 0, c = 20;
    for (; u < c; ) {
      const h = f.map((g) => d.positionToTileXY(g, u)), p = [];
      if (p.push(Math.abs(h[0].x - h[1].x)), p.push(Math.abs(h[0].y - h[3].y)), p[0] > 1 || p[1] > 1) {
        u--;
        break;
      }
      u++;
    }
    for (; c > u; ) {
      const h = f.map((g) => d.positionToTileXY(g, c)), p = [];
      if (p.push(Math.abs(h[0].x - h[1].x)), p.push(Math.abs(h[0].y - h[3].y)), p[0] < o || p[1] < l) {
        c++;
        break;
      }
      c--;
    }
    return [u, c];
  }
  /**
   * @inheritDoc
   */
  createSingleLayerCounterparts(t) {
    const n = t.layer, s = Qe(n).toString(), r = this.view.getProjection(), i = this.convertLayerToCesiumImageries(n, r);
    if (i) {
      const a = [];
      [t.layer].concat(t.parents).forEach((o) => {
        a.push(o.on(["change:opacity", "change:visible"], () => {
          console.assert(i);
          for (let l = 0; l < i.length; ++l)
            Vt.updateCesiumLayerProperties(t, i[l]);
        }));
      });
      for (let o = 0; o < i.length; ++o)
        Vt.updateCesiumLayerProperties(t, i[o]);
      a.push(n.on("change:extent", function() {
        for (let o = 0; o < i.length; ++o)
          this.cesiumLayers.remove(i[o], !0), this.ourLayers.remove(i[o], !1);
        delete this.layerMap[Qe(n)], this.synchronize();
      }, this)), a.push(n.on("change", (function() {
        for (let o = 0; o < i.length; ++o) {
          const l = this.cesiumLayers.indexOf(i[o]);
          l >= 0 && (this.cesiumLayers.remove(i[o], !1), this.cesiumLayers.add(i[o], l));
        }
      }).bind(this))), this.olLayerListenKeys[s].push(...a);
    }
    return Array.isArray(i) ? i : null;
  }
  /**
   * Order counterparts using the same algorithm as the Openlayers renderer:
   * z-index then original sequence order.
   * @override
   * @protected
   */
  orderLayers() {
    const t = [], n = {}, s = [this.mapLayerGroup];
    for (; s.length > 0; ) {
      const r = s.splice(0, 1)[0];
      if (t.push(r), n[Qe(r)] = r.getZIndex(), r instanceof Ga) {
        const i = r.getLayers();
        i && s.unshift(...i.getArray());
      }
    }
    QI(t, (r, i) => n[Qe(r)] - n[Qe(i)]), t.forEach(function(r) {
      const i = Qe(r).toString(), a = this.layerMap[i];
      a && a.forEach(this.raiseToTop, this);
    }, this);
  }
  /**
   * @param {Cesium.ImageryLayer} counterpart -
   * @returns {void}
   */
  raiseToTop(t) {
    this.cesiumLayers.raiseToTop(t);
  }
}
let EH = 0;
function bf(e, t) {
  Object.keys(t).forEach((n) => {
    const s = t[n];
    typeof s == "object" ? Object.keys(s).forEach((r) => {
      r !== "heading" && r !== "tilt" && r !== "altitude" && (e[n][r] = s[r]);
    }) : e[n] = s;
  });
}
function II(e, t, n) {
  var o, l, f, d, u, c;
  let s, r, i, a;
  if (e && t)
    if (typeof e.heading < "u" ? a = parseFloat(e.heading) : typeof ((o = e.camera) == null ? void 0 : o.heading) < "u" && (a = parseFloat((l = e.camera) == null ? void 0 : l.heading)), e.cameraPosition)
      s = t.getCesiumScene().camera, r = n.Cartesian3.fromDegrees(e.cameraPosition[0], e.cameraPosition[1], e.cameraPosition[2]), i = {
        heading: n.Math.toRadians(a),
        pitch: n.Math.toRadians(parseFloat(e.pitch)),
        roll: n.Math.toRadians(parseFloat(e.roll))
      }, s.setView({
        destination: r,
        orientation: i
      });
    else {
      let h, p;
      typeof e.tilt < "u" ? h = parseFloat(e.tilt) : typeof ((f = e.camera) == null ? void 0 : f.tilt) < "u" && (h = parseFloat((d = e.camera) == null ? void 0 : d.tilt)), typeof e.altitude < "u" ? p = parseFloat(e.altitude) : typeof ((u = e.camera) == null ? void 0 : u.altitude) < "u" && (p = parseFloat((c = e.camera) == null ? void 0 : c.altitude)), s = t.getCamera(), h && s.setTilt(h), a && s.setHeading(a), p && s.setAltitude(p);
    }
}
function DI(e) {
  const t = new DE({
    map: e.map2D,
    time: e == null ? void 0 : e.shadowTime,
    stopOpenLayersEventsPropagation: !0,
    createSynchronizers: (n, s) => [new yH(n, s), new MI(n, s), new vH(n, s)]
  });
  return t.id = `map3D_${EH++}`, t.mapMode = "3D", bf(t.getCesiumScene(), fi.sceneOptions), e != null && e.cesiumParameter && (bf(t.getCesiumScene(), e.cesiumParameter), II(e.cesiumParameter, t, Cesium)), t;
}
function CH(e) {
  var g, m;
  const t = this.scene, n = t.camera.getPickRay(e.position), s = t.globe.pick(n, t), r = this.map3D.getOlView().getProjection();
  let i, a, o, l, f, d, u, c, h, p;
  if (s) {
    if ((g = document.querySelector(".nav li")) != null && g.classList.contains("open") && document.querySelector(".nav li").classList.remove("open"), o = t.globe.ellipsoid.cartesianToCartographic(s), a = [Cesium.Math.toDegrees(o.longitude), Cesium.Math.toDegrees(o.latitude)], i = t.globe.getHeight(o), i && (a = a.concat([i])), l = Cesium.Cartesian3.distance(s, t.camera.position), f = this.map3D.getCamera().calcResolutionForDistance(l, o.latitude), d = Ui(a, Wt("EPSG:4326"), r), u = null, t.pickPositionSupported) {
      const v = t.pick(e.position);
      c = t.pickPosition(e.position), !c && (v == null ? void 0 : v.primitive) instanceof window.Cesium.Billboard && (c = (m = v.primitive) == null ? void 0 : m.position), c && (h = t.globe.ellipsoid.cartesianToCartographic(c), u = Ui([Cesium.Math.toDegrees(h.longitude), Cesium.Math.toDegrees(h.latitude)], Wt("EPSG:4326"), r), u.push(h.height));
    }
    p = {
      map3D: this,
      position: e.position,
      pickedPosition: u,
      coordinate: d,
      latitude: a[0],
      longitude: a[1],
      resolution: f,
      originalEvent: e
    };
  }
  return this.callback(p);
}
function xH(e) {
  let t;
  Cesium && (t = new Cesium.ScreenSpaceEventHandler(e.scene.canvas), t.setInputAction(CH.bind(e), Cesium.ScreenSpaceEventType.LEFT_CLICK));
}
function bH(e, t, n) {
  const s = e.camera;
  let r = Object.prototype.hasOwnProperty.call(n, "cameraParameter") ? n.cameraParameter : {};
  return r = t != null && t.altitude ? Object.assign(r || {}, { altitude: t == null ? void 0 : t.altitude }) : r, r = t != null && t.heading ? Object.assign(r || {}, { heading: t == null ? void 0 : t.heading }) : r, r = t != null && t.tilt ? Object.assign(r || {}, { tilt: t == null ? void 0 : t.tilt }) : r, Object.keys(r).length > 0 && bf(e, { camera: r }), s;
}
const TH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createMap: DI,
  handle3DEvents: xH,
  prepareCamera: bH,
  setCameraParameter: II,
  setCesiumSceneParams: bf
}, Symbol.toStringTag, { value: "Module" })), OH = {
  /**
  * Creates a map and adds it to the mapCollection. Depending on param 'mapMode' a 2D or a 3D map is created. Default ist 2D.
  * @param {object} [config] - configuration object - falls back to defaults if none given
  * @param {string} [config.target="map"] - div id to render map to
  * @param {string} [config.namedProjections] - projections to create the map
  * @param {string} [config.backgroundImage] - background image for map; "" to use none
  * @param {string} [config.epsg] - CRS to use
  * @param {number[]} [config.extent] - extent to use
  * @param {Array.<{resolution: number, scale: number, zoomLevel: number}>} [config.options] - zoom level definition
  * @param {Array.<string[]>} [config.options] - each sub-array has two values: projection name, and projection description
  * @param {number} [config.startResolution] - initial resolution
  * @param {number[]} [config.startCenter] - initial position
  * @param {(string|object)} [config.layerConf] - services registry or URL thereof
  * @param {string} [config.gazetteerUrl] - url of gazetteer to use in searchAddress
  * @param {String} [mapMode = "2D"] The map mode. '2D' to create a 2D-map and '3D' to create a 3D-map.
  * @param {object}  [settings={}] - settings object
  * @param {object} [settings.mapParams] - additional parameter object that is spread into the ol.Map constructor object
  * @param {function} [settings.callback] - optional callback for layer list loading
  * @param {function} [settings.errorCallback] - optional callback for layer error events
  * @returns {module:ol/Map~Map} The map.
  */
  createMap: function(e, t = "2D", n = {}) {
    return {
      "2D": tH,
      "3D": DI
    }[t](e, n);
  },
  olcsMap: TH
}, PH = {
  map: OH
};
var AI = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(e) {
  (function(t, n, s, r) {
    var i = ["", "webkit", "Moz", "MS", "ms", "o"], a = n.createElement("div"), o = "function", l = Math.round, f = Math.abs, d = Date.now;
    function u($, K, q) {
      return setTimeout(E($, q), K);
    }
    function c($, K, q) {
      return Array.isArray($) ? (h($, q[K], q), !0) : !1;
    }
    function h($, K, q) {
      var ot;
      if ($)
        if ($.forEach)
          $.forEach(K, q);
        else if ($.length !== r)
          for (ot = 0; ot < $.length; )
            K.call(q, $[ot], ot, $), ot++;
        else
          for (ot in $)
            $.hasOwnProperty(ot) && K.call(q, $[ot], ot, $);
    }
    function p($, K, q) {
      var ot = "DEPRECATED METHOD: " + K + `
` + q + ` AT 
`;
      return function() {
        var Et = new Error("get-stack-trace"), Rt = Et && Et.stack ? Et.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", ie = t.console && (t.console.warn || t.console.log);
        return ie && ie.call(t.console, ot, Rt), $.apply(this, arguments);
      };
    }
    var g;
    typeof Object.assign != "function" ? g = function(K) {
      if (K === r || K === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var q = Object(K), ot = 1; ot < arguments.length; ot++) {
        var Et = arguments[ot];
        if (Et !== r && Et !== null)
          for (var Rt in Et)
            Et.hasOwnProperty(Rt) && (q[Rt] = Et[Rt]);
      }
      return q;
    } : g = Object.assign;
    var m = p(function(K, q, ot) {
      for (var Et = Object.keys(q), Rt = 0; Rt < Et.length; )
        (!ot || ot && K[Et[Rt]] === r) && (K[Et[Rt]] = q[Et[Rt]]), Rt++;
      return K;
    }, "extend", "Use `assign`."), v = p(function(K, q) {
      return m(K, q, !0);
    }, "merge", "Use `assign`.");
    function y($, K, q) {
      var ot = K.prototype, Et;
      Et = $.prototype = Object.create(ot), Et.constructor = $, Et._super = ot, q && g(Et, q);
    }
    function E($, K) {
      return function() {
        return $.apply(K, arguments);
      };
    }
    function C($, K) {
      return typeof $ == o ? $.apply(K && K[0] || r, K) : $;
    }
    function x($, K) {
      return $ === r ? K : $;
    }
    function b($, K, q) {
      h(M(K), function(ot) {
        $.addEventListener(ot, q, !1);
      });
    }
    function P($, K, q) {
      h(M(K), function(ot) {
        $.removeEventListener(ot, q, !1);
      });
    }
    function O($, K) {
      for (; $; ) {
        if ($ == K)
          return !0;
        $ = $.parentNode;
      }
      return !1;
    }
    function T($, K) {
      return $.indexOf(K) > -1;
    }
    function M($) {
      return $.trim().split(/\s+/g);
    }
    function L($, K, q) {
      if ($.indexOf && !q)
        return $.indexOf(K);
      for (var ot = 0; ot < $.length; ) {
        if (q && $[ot][q] == K || !q && $[ot] === K)
          return ot;
        ot++;
      }
      return -1;
    }
    function A($) {
      return Array.prototype.slice.call($, 0);
    }
    function D($, K, q) {
      for (var ot = [], Et = [], Rt = 0; Rt < $.length; ) {
        var ie = K ? $[Rt][K] : $[Rt];
        L(Et, ie) < 0 && ot.push($[Rt]), Et[Rt] = ie, Rt++;
      }
      return q && (K ? ot = ot.sort(function(Pn, En) {
        return Pn[K] > En[K];
      }) : ot = ot.sort()), ot;
    }
    function I($, K) {
      for (var q, ot, Et = K[0].toUpperCase() + K.slice(1), Rt = 0; Rt < i.length; ) {
        if (q = i[Rt], ot = q ? q + Et : K, ot in $)
          return ot;
        Rt++;
      }
      return r;
    }
    var w = 1;
    function B() {
      return w++;
    }
    function j($) {
      var K = $.ownerDocument || $;
      return K.defaultView || K.parentWindow || t;
    }
    var k = /mobile|tablet|ip(ad|hone|od)|android/i, X = "ontouchstart" in t, rt = I(t, "PointerEvent") !== r, et = X && k.test(navigator.userAgent), Z = "touch", dt = "pen", vt = "mouse", bt = "kinect", it = 25, R = 1, V = 2, tt = 4, Y = 8, W = 1, z = 2, at = 4, ct = 8, Mt = 16, N = z | at, S = ct | Mt, _ = N | S, F = ["x", "y"], G = ["clientX", "clientY"];
    function nt($, K) {
      var q = this;
      this.manager = $, this.callback = K, this.element = $.element, this.target = $.options.inputTarget, this.domHandler = function(ot) {
        C($.options.enable, [$]) && q.handler(ot);
      }, this.init();
    }
    nt.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && b(this.element, this.evEl, this.domHandler), this.evTarget && b(this.target, this.evTarget, this.domHandler), this.evWin && b(j(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && P(this.element, this.evEl, this.domHandler), this.evTarget && P(this.target, this.evTarget, this.domHandler), this.evWin && P(j(this.element), this.evWin, this.domHandler);
      }
    };
    function lt($) {
      var K, q = $.options.inputClass;
      return q ? K = q : rt ? K = mn : et ? K = gi : X ? K = Vn : K = bn, new K($, yt);
    }
    function yt($, K, q) {
      var ot = q.pointers.length, Et = q.changedPointers.length, Rt = K & R && ot - Et === 0, ie = K & (tt | Y) && ot - Et === 0;
      q.isFirst = !!Rt, q.isFinal = !!ie, Rt && ($.session = {}), q.eventType = K, Lt($, q), $.emit("hammer.input", q), $.recognize(q), $.session.prevInput = q;
    }
    function Lt($, K) {
      var q = $.session, ot = K.pointers, Et = ot.length;
      q.firstInput || (q.firstInput = J(K)), Et > 1 && !q.firstMultiple ? q.firstMultiple = J(K) : Et === 1 && (q.firstMultiple = !1);
      var Rt = q.firstInput, ie = q.firstMultiple, yn = ie ? ie.center : Rt.center, Pn = K.center = ft(ot);
      K.timeStamp = d(), K.deltaTime = K.timeStamp - Rt.timeStamp, K.angle = kt(yn, Pn), K.distance = Tt(yn, Pn), Ft(q, K), K.offsetDirection = St(K.deltaX, K.deltaY);
      var En = Ct(K.deltaTime, K.deltaX, K.deltaY);
      K.overallVelocityX = En.x, K.overallVelocityY = En.y, K.overallVelocity = f(En.x) > f(En.y) ? En.x : En.y, K.scale = ie ? Se(ie.pointers, ot) : 1, K.rotation = ie ? fe(ie.pointers, ot) : 0, K.maxPointers = q.prevInput ? K.pointers.length > q.prevInput.maxPointers ? K.pointers.length : q.prevInput.maxPointers : K.pointers.length, Jt(q, K);
      var Jn = $.element;
      O(K.srcEvent.target, Jn) && (Jn = K.srcEvent.target), K.target = Jn;
    }
    function Ft($, K) {
      var q = K.center, ot = $.offsetDelta || {}, Et = $.prevDelta || {}, Rt = $.prevInput || {};
      (K.eventType === R || Rt.eventType === tt) && (Et = $.prevDelta = {
        x: Rt.deltaX || 0,
        y: Rt.deltaY || 0
      }, ot = $.offsetDelta = {
        x: q.x,
        y: q.y
      }), K.deltaX = Et.x + (q.x - ot.x), K.deltaY = Et.y + (q.y - ot.y);
    }
    function Jt($, K) {
      var q = $.lastInterval || K, ot = K.timeStamp - q.timeStamp, Et, Rt, ie, yn;
      if (K.eventType != Y && (ot > it || q.velocity === r)) {
        var Pn = K.deltaX - q.deltaX, En = K.deltaY - q.deltaY, Jn = Ct(ot, Pn, En);
        Rt = Jn.x, ie = Jn.y, Et = f(Jn.x) > f(Jn.y) ? Jn.x : Jn.y, yn = St(Pn, En), $.lastInterval = K;
      } else
        Et = q.velocity, Rt = q.velocityX, ie = q.velocityY, yn = q.direction;
      K.velocity = Et, K.velocityX = Rt, K.velocityY = ie, K.direction = yn;
    }
    function J($) {
      for (var K = [], q = 0; q < $.pointers.length; )
        K[q] = {
          clientX: l($.pointers[q].clientX),
          clientY: l($.pointers[q].clientY)
        }, q++;
      return {
        timeStamp: d(),
        pointers: K,
        center: ft(K),
        deltaX: $.deltaX,
        deltaY: $.deltaY
      };
    }
    function ft($) {
      var K = $.length;
      if (K === 1)
        return {
          x: l($[0].clientX),
          y: l($[0].clientY)
        };
      for (var q = 0, ot = 0, Et = 0; Et < K; )
        q += $[Et].clientX, ot += $[Et].clientY, Et++;
      return {
        x: l(q / K),
        y: l(ot / K)
      };
    }
    function Ct($, K, q) {
      return {
        x: K / $ || 0,
        y: q / $ || 0
      };
    }
    function St($, K) {
      return $ === K ? W : f($) >= f(K) ? $ < 0 ? z : at : K < 0 ? ct : Mt;
    }
    function Tt($, K, q) {
      q || (q = F);
      var ot = K[q[0]] - $[q[0]], Et = K[q[1]] - $[q[1]];
      return Math.sqrt(ot * ot + Et * Et);
    }
    function kt($, K, q) {
      q || (q = F);
      var ot = K[q[0]] - $[q[0]], Et = K[q[1]] - $[q[1]];
      return Math.atan2(Et, ot) * 180 / Math.PI;
    }
    function fe($, K) {
      return kt(K[1], K[0], G) + kt($[1], $[0], G);
    }
    function Se($, K) {
      return Tt(K[0], K[1], G) / Tt($[0], $[1], G);
    }
    var Me = {
      mousedown: R,
      mousemove: V,
      mouseup: tt
    }, xe = "mousedown", We = "mousemove mouseup";
    function bn() {
      this.evEl = xe, this.evWin = We, this.pressed = !1, nt.apply(this, arguments);
    }
    y(bn, nt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(K) {
        var q = Me[K.type];
        q & R && K.button === 0 && (this.pressed = !0), q & V && K.which !== 1 && (q = tt), this.pressed && (q & tt && (this.pressed = !1), this.callback(this.manager, q, {
          pointers: [K],
          changedPointers: [K],
          pointerType: vt,
          srcEvent: K
        }));
      }
    });
    var Ye = {
      pointerdown: R,
      pointermove: V,
      pointerup: tt,
      pointercancel: Y,
      pointerout: Y
    }, Hn = {
      2: Z,
      3: dt,
      4: vt,
      5: bt
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, pn = "pointerdown", Ne = "pointermove pointerup pointercancel";
    t.MSPointerEvent && !t.PointerEvent && (pn = "MSPointerDown", Ne = "MSPointerMove MSPointerUp MSPointerCancel");
    function mn() {
      this.evEl = pn, this.evWin = Ne, nt.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    y(mn, nt, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(K) {
        var q = this.store, ot = !1, Et = K.type.toLowerCase().replace("ms", ""), Rt = Ye[Et], ie = Hn[K.pointerType] || K.pointerType, yn = ie == Z, Pn = L(q, K.pointerId, "pointerId");
        Rt & R && (K.button === 0 || yn) ? Pn < 0 && (q.push(K), Pn = q.length - 1) : Rt & (tt | Y) && (ot = !0), !(Pn < 0) && (q[Pn] = K, this.callback(this.manager, Rt, {
          pointers: q,
          changedPointers: [K],
          pointerType: ie,
          srcEvent: K
        }), ot && q.splice(Pn, 1));
      }
    });
    var gn = {
      touchstart: R,
      touchmove: V,
      touchend: tt,
      touchcancel: Y
    }, we = "touchstart", vn = "touchstart touchmove touchend touchcancel";
    function ze() {
      this.evTarget = we, this.evWin = vn, this.started = !1, nt.apply(this, arguments);
    }
    y(ze, nt, {
      handler: function(K) {
        var q = gn[K.type];
        if (q === R && (this.started = !0), !!this.started) {
          var ot = Tn.call(this, K, q);
          q & (tt | Y) && ot[0].length - ot[1].length === 0 && (this.started = !1), this.callback(this.manager, q, {
            pointers: ot[0],
            changedPointers: ot[1],
            pointerType: Z,
            srcEvent: K
          });
        }
      }
    });
    function Tn($, K) {
      var q = A($.touches), ot = A($.changedTouches);
      return K & (tt | Y) && (q = D(q.concat(ot), "identifier", !0)), [q, ot];
    }
    var tn = {
      touchstart: R,
      touchmove: V,
      touchend: tt,
      touchcancel: Y
    }, ae = "touchstart touchmove touchend touchcancel";
    function gi() {
      this.evTarget = ae, this.targetIds = {}, nt.apply(this, arguments);
    }
    y(gi, nt, {
      handler: function(K) {
        var q = tn[K.type], ot = Xe.call(this, K, q);
        ot && this.callback(this.manager, q, {
          pointers: ot[0],
          changedPointers: ot[1],
          pointerType: Z,
          srcEvent: K
        });
      }
    });
    function Xe($, K) {
      var q = A($.touches), ot = this.targetIds;
      if (K & (R | V) && q.length === 1)
        return ot[q[0].identifier] = !0, [q, q];
      var Et, Rt, ie = A($.changedTouches), yn = [], Pn = this.target;
      if (Rt = q.filter(function(En) {
        return O(En.target, Pn);
      }), K === R)
        for (Et = 0; Et < Rt.length; )
          ot[Rt[Et].identifier] = !0, Et++;
      for (Et = 0; Et < ie.length; )
        ot[ie[Et].identifier] && yn.push(ie[Et]), K & (tt | Y) && delete ot[ie[Et].identifier], Et++;
      if (yn.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          D(Rt.concat(yn), "identifier", !0),
          yn
        ];
    }
    var an = 2500, $e = 25;
    function Vn() {
      nt.apply(this, arguments);
      var $ = E(this.handler, this);
      this.touch = new gi(this.manager, $), this.mouse = new bn(this.manager, $), this.primaryTouch = null, this.lastTouches = [];
    }
    y(Vn, nt, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(K, q, ot) {
        var Et = ot.pointerType == Z, Rt = ot.pointerType == vt;
        if (!(Rt && ot.sourceCapabilities && ot.sourceCapabilities.firesTouchEvents)) {
          if (Et)
            ii.call(this, q, ot);
          else if (Rt && Os.call(this, ot))
            return;
          this.callback(K, q, ot);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function ii($, K) {
      $ & R ? (this.primaryTouch = K.changedPointers[0].identifier, da.call(this, K)) : $ & (tt | Y) && da.call(this, K);
    }
    function da($) {
      var K = $.changedPointers[0];
      if (K.identifier === this.primaryTouch) {
        var q = { x: K.clientX, y: K.clientY };
        this.lastTouches.push(q);
        var ot = this.lastTouches, Et = function() {
          var Rt = ot.indexOf(q);
          Rt > -1 && ot.splice(Rt, 1);
        };
        setTimeout(Et, an);
      }
    }
    function Os($) {
      for (var K = $.srcEvent.clientX, q = $.srcEvent.clientY, ot = 0; ot < this.lastTouches.length; ot++) {
        var Et = this.lastTouches[ot], Rt = Math.abs(K - Et.x), ie = Math.abs(q - Et.y);
        if (Rt <= $e && ie <= $e)
          return !0;
      }
      return !1;
    }
    var Ps = I(a.style, "touchAction"), Hr = Ps !== r, Fn = "compute", vi = "auto", Yr = "manipulation", Ve = "none", yi = "pan-x", Ei = "pan-y", Ze = Ss();
    function Yi($, K) {
      this.manager = $, this.set(K);
    }
    Yi.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function($) {
        $ == Fn && ($ = this.compute()), Hr && this.manager.element.style && Ze[$] && (this.manager.element.style[Ps] = $), this.actions = $.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var $ = [];
        return h(this.manager.recognizers, function(K) {
          C(K.options.enable, [K]) && ($ = $.concat(K.getTouchAction()));
        }), Pr($.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function($) {
        var K = $.srcEvent, q = $.offsetDirection;
        if (this.manager.session.prevented) {
          K.preventDefault();
          return;
        }
        var ot = this.actions, Et = T(ot, Ve) && !Ze[Ve], Rt = T(ot, Ei) && !Ze[Ei], ie = T(ot, yi) && !Ze[yi];
        if (Et) {
          var yn = $.pointers.length === 1, Pn = $.distance < 2, En = $.deltaTime < 250;
          if (yn && Pn && En)
            return;
        }
        if (!(ie && Rt) && (Et || Rt && q & N || ie && q & S))
          return this.preventSrc(K);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function($) {
        this.manager.session.prevented = !0, $.preventDefault();
      }
    };
    function Pr($) {
      if (T($, Ve))
        return Ve;
      var K = T($, yi), q = T($, Ei);
      return K && q ? Ve : K || q ? K ? yi : Ei : T($, Yr) ? Yr : vi;
    }
    function Ss() {
      if (!Hr)
        return !1;
      var $ = {}, K = t.CSS && t.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(q) {
        $[q] = K ? t.CSS.supports("touch-action", q) : !0;
      }), $;
    }
    var Nn = 1, On = 2, ri = 4, An = 8, jn = An, Je = 16, Yn = 32;
    function si($) {
      this.options = g({}, this.defaults, $ || {}), this.id = B(), this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = Nn, this.simultaneous = {}, this.requireFail = [];
    }
    si.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function($) {
        return g(this.options, $), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function($) {
        if (c($, "recognizeWith", this))
          return this;
        var K = this.simultaneous;
        return $ = lr($, this), K[$.id] || (K[$.id] = $, $.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function($) {
        return c($, "dropRecognizeWith", this) ? this : ($ = lr($, this), delete this.simultaneous[$.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function($) {
        if (c($, "requireFailure", this))
          return this;
        var K = this.requireFail;
        return $ = lr($, this), L(K, $) === -1 && (K.push($), $.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function($) {
        if (c($, "dropRequireFailure", this))
          return this;
        $ = lr($, this);
        var K = L(this.requireFail, $);
        return K > -1 && this.requireFail.splice(K, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function($) {
        return !!this.simultaneous[$.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function($) {
        var K = this, q = this.state;
        function ot(Et) {
          K.manager.emit(Et, $);
        }
        q < An && ot(K.options.event + Sr(q)), ot(K.options.event), $.additionalEvent && ot($.additionalEvent), q >= An && ot(K.options.event + Sr(q));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function($) {
        if (this.canEmit())
          return this.emit($);
        this.state = Yn;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var $ = 0; $ < this.requireFail.length; ) {
          if (!(this.requireFail[$].state & (Yn | Nn)))
            return !1;
          $++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function($) {
        var K = g({}, $);
        if (!C(this.options.enable, [this, K])) {
          this.reset(), this.state = Yn;
          return;
        }
        this.state & (jn | Je | Yn) && (this.state = Nn), this.state = this.process(K), this.state & (On | ri | An | Je) && this.tryEmit(K);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function($) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function Sr($) {
      return $ & Je ? "cancel" : $ & An ? "end" : $ & ri ? "move" : $ & On ? "start" : "";
    }
    function Xr($) {
      return $ == Mt ? "down" : $ == ct ? "up" : $ == z ? "left" : $ == at ? "right" : "";
    }
    function lr($, K) {
      var q = K.manager;
      return q ? q.get($) : $;
    }
    function Xn() {
      si.apply(this, arguments);
    }
    y(Xn, si, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function($) {
        var K = this.options.pointers;
        return K === 0 || $.pointers.length === K;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function($) {
        var K = this.state, q = $.eventType, ot = K & (On | ri), Et = this.attrTest($);
        return ot && (q & Y || !Et) ? K | Je : ot || Et ? q & tt ? K | An : K & On ? K | ri : On : Yn;
      }
    });
    function Ci() {
      Xn.apply(this, arguments), this.pX = null, this.pY = null;
    }
    y(Ci, Xn, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: _
      },
      getTouchAction: function() {
        var $ = this.options.direction, K = [];
        return $ & N && K.push(Ei), $ & S && K.push(yi), K;
      },
      directionTest: function($) {
        var K = this.options, q = !0, ot = $.distance, Et = $.direction, Rt = $.deltaX, ie = $.deltaY;
        return Et & K.direction || (K.direction & N ? (Et = Rt === 0 ? W : Rt < 0 ? z : at, q = Rt != this.pX, ot = Math.abs($.deltaX)) : (Et = ie === 0 ? W : ie < 0 ? ct : Mt, q = ie != this.pY, ot = Math.abs($.deltaY))), $.direction = Et, q && ot > K.threshold && Et & K.direction;
      },
      attrTest: function($) {
        return Xn.prototype.attrTest.call(this, $) && (this.state & On || !(this.state & On) && this.directionTest($));
      },
      emit: function($) {
        this.pX = $.deltaX, this.pY = $.deltaY;
        var K = Xr($.direction);
        K && ($.additionalEvent = this.options.event + K), this._super.emit.call(this, $);
      }
    });
    function Zr() {
      Xn.apply(this, arguments);
    }
    y(Zr, Xn, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ve];
      },
      attrTest: function($) {
        return this._super.attrTest.call(this, $) && (Math.abs($.scale - 1) > this.options.threshold || this.state & On);
      },
      emit: function($) {
        if ($.scale !== 1) {
          var K = $.scale < 1 ? "in" : "out";
          $.additionalEvent = this.options.event + K;
        }
        this._super.emit.call(this, $);
      }
    });
    function Jr() {
      si.apply(this, arguments), this._timer = null, this._input = null;
    }
    y(Jr, si, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [vi];
      },
      process: function($) {
        var K = this.options, q = $.pointers.length === K.pointers, ot = $.distance < K.threshold, Et = $.deltaTime > K.time;
        if (this._input = $, !ot || !q || $.eventType & (tt | Y) && !Et)
          this.reset();
        else if ($.eventType & R)
          this.reset(), this._timer = u(function() {
            this.state = jn, this.tryEmit();
          }, K.time, this);
        else if ($.eventType & tt)
          return jn;
        return Yn;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function($) {
        this.state === jn && ($ && $.eventType & tt ? this.manager.emit(this.options.event + "up", $) : (this._input.timeStamp = d(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function Mr() {
      Xn.apply(this, arguments);
    }
    y(Mr, Xn, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Ve];
      },
      attrTest: function($) {
        return this._super.attrTest.call(this, $) && (Math.abs($.rotation) > this.options.threshold || this.state & On);
      }
    });
    function Xi() {
      Xn.apply(this, arguments);
    }
    y(Xi, Xn, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: N | S,
        pointers: 1
      },
      getTouchAction: function() {
        return Ci.prototype.getTouchAction.call(this);
      },
      attrTest: function($) {
        var K = this.options.direction, q;
        return K & (N | S) ? q = $.overallVelocity : K & N ? q = $.overallVelocityX : K & S && (q = $.overallVelocityY), this._super.attrTest.call(this, $) && K & $.offsetDirection && $.distance > this.options.threshold && $.maxPointers == this.options.pointers && f(q) > this.options.velocity && $.eventType & tt;
      },
      emit: function($) {
        var K = Xr($.offsetDirection);
        K && this.manager.emit(this.options.event + K, $), this.manager.emit(this.options.event, $);
      }
    });
    function Li() {
      si.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    y(Li, si, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [Yr];
      },
      process: function($) {
        var K = this.options, q = $.pointers.length === K.pointers, ot = $.distance < K.threshold, Et = $.deltaTime < K.time;
        if (this.reset(), $.eventType & R && this.count === 0)
          return this.failTimeout();
        if (ot && Et && q) {
          if ($.eventType != tt)
            return this.failTimeout();
          var Rt = this.pTime ? $.timeStamp - this.pTime < K.interval : !0, ie = !this.pCenter || Tt(this.pCenter, $.center) < K.posThreshold;
          this.pTime = $.timeStamp, this.pCenter = $.center, !ie || !Rt ? this.count = 1 : this.count += 1, this._input = $;
          var yn = this.count % K.taps;
          if (yn === 0)
            return this.hasRequireFailures() ? (this._timer = u(function() {
              this.state = jn, this.tryEmit();
            }, K.interval, this), On) : jn;
        }
        return Yn;
      },
      failTimeout: function() {
        return this._timer = u(function() {
          this.state = Yn;
        }, this.options.interval, this), Yn;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == jn && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function _e($, K) {
      return K = K || {}, K.recognizers = x(K.recognizers, _e.defaults.preset), new Qr($, K);
    }
    _e.VERSION = "2.0.7", _e.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: Fn,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [Mr, { enable: !1 }],
        [Zr, { enable: !1 }, ["rotate"]],
        [Xi, { direction: N }],
        [Ci, { direction: N }, ["swipe"]],
        [Li],
        [Li, { event: "doubletap", taps: 2 }, ["tap"]],
        [Jr]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var Zn = 1, Ms = 2;
    function Qr($, K) {
      this.options = g({}, _e.defaults, K || {}), this.options.inputTarget = this.options.inputTarget || $, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = $, this.input = lt(this), this.touchAction = new Yi(this, this.options.touchAction), qr(this, !0), h(this.options.recognizers, function(q) {
        var ot = this.add(new q[0](q[1]));
        q[2] && ot.recognizeWith(q[2]), q[3] && ot.requireFailure(q[3]);
      }, this);
    }
    Qr.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function($) {
        return g(this.options, $), $.touchAction && this.touchAction.update(), $.inputTarget && (this.input.destroy(), this.input.target = $.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function($) {
        this.session.stopped = $ ? Ms : Zn;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function($) {
        var K = this.session;
        if (!K.stopped) {
          this.touchAction.preventDefaults($);
          var q, ot = this.recognizers, Et = K.curRecognizer;
          (!Et || Et && Et.state & jn) && (Et = K.curRecognizer = null);
          for (var Rt = 0; Rt < ot.length; )
            q = ot[Rt], K.stopped !== Ms && // 1
            (!Et || q == Et || // 2
            q.canRecognizeWith(Et)) ? q.recognize($) : q.reset(), !Et && q.state & (On | ri | An) && (Et = K.curRecognizer = q), Rt++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function($) {
        if ($ instanceof si)
          return $;
        for (var K = this.recognizers, q = 0; q < K.length; q++)
          if (K[q].options.event == $)
            return K[q];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function($) {
        if (c($, "add", this))
          return this;
        var K = this.get($.options.event);
        return K && this.remove(K), this.recognizers.push($), $.manager = this, this.touchAction.update(), $;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function($) {
        if (c($, "remove", this))
          return this;
        if ($ = this.get($), $) {
          var K = this.recognizers, q = L(K, $);
          q !== -1 && (K.splice(q, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function($, K) {
        if ($ !== r && K !== r) {
          var q = this.handlers;
          return h(M($), function(ot) {
            q[ot] = q[ot] || [], q[ot].push(K);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function($, K) {
        if ($ !== r) {
          var q = this.handlers;
          return h(M($), function(ot) {
            K ? q[ot] && q[ot].splice(L(q[ot], K), 1) : delete q[ot];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function($, K) {
        this.options.domEvents && Zi($, K);
        var q = this.handlers[$] && this.handlers[$].slice();
        if (!(!q || !q.length)) {
          K.type = $, K.preventDefault = function() {
            K.srcEvent.preventDefault();
          };
          for (var ot = 0; ot < q.length; )
            q[ot](K), ot++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && qr(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function qr($, K) {
      var q = $.element;
      if (q.style) {
        var ot;
        h($.options.cssProps, function(Et, Rt) {
          ot = I(q.style, Rt), K ? ($.oldCssProps[ot] = q.style[ot], q.style[ot] = Et) : q.style[ot] = $.oldCssProps[ot] || "";
        }), K || ($.oldCssProps = {});
      }
    }
    function Zi($, K) {
      var q = n.createEvent("Event");
      q.initEvent($, !0, !0), q.gesture = K, K.target.dispatchEvent(q);
    }
    g(_e, {
      INPUT_START: R,
      INPUT_MOVE: V,
      INPUT_END: tt,
      INPUT_CANCEL: Y,
      STATE_POSSIBLE: Nn,
      STATE_BEGAN: On,
      STATE_CHANGED: ri,
      STATE_ENDED: An,
      STATE_RECOGNIZED: jn,
      STATE_CANCELLED: Je,
      STATE_FAILED: Yn,
      DIRECTION_NONE: W,
      DIRECTION_LEFT: z,
      DIRECTION_RIGHT: at,
      DIRECTION_UP: ct,
      DIRECTION_DOWN: Mt,
      DIRECTION_HORIZONTAL: N,
      DIRECTION_VERTICAL: S,
      DIRECTION_ALL: _,
      Manager: Qr,
      Input: nt,
      TouchAction: Yi,
      TouchInput: gi,
      MouseInput: bn,
      PointerEventInput: mn,
      TouchMouseInput: Vn,
      SingleTouchInput: ze,
      Recognizer: si,
      AttrRecognizer: Xn,
      Tap: Li,
      Pan: Ci,
      Swipe: Xi,
      Pinch: Zr,
      Rotate: Mr,
      Press: Jr,
      on: b,
      off: P,
      each: h,
      merge: v,
      extend: m,
      assign: g,
      inherit: y,
      bindFn: E,
      prefixed: I
    });
    var ts = typeof t < "u" ? t : typeof self < "u" ? self : {};
    ts.Hammer = _e, typeof r == "function" && r.amd ? r(function() {
      return _e;
    }) : e.exports ? e.exports = _e : t[s] = _e;
  })(window, document, "Hammer");
})(AI);
var SH = AI.exports;
const MH = /* @__PURE__ */ nl(SH);
let LI = null;
const _H = (e) => {
  LI = e;
}, IH = () => LI, DH = $t.extend({
  data: () => ({
    resizeObserver: null
  }),
  computed: {
    ...ee(["components"]),
    layout() {
      return IH();
    }
  },
  mounted() {
    this.resizeObserver = new ResizeObserver(this.updateClientDimensions), this.resizeObserver.observe(this.$root.$el), this.updateClientDimensions();
  },
  beforeDestroy() {
    this.resizeObserver instanceof ResizeObserver && this.resizeObserver.unobserve(this.$root.$el);
  },
  methods: {
    ...or(["setClientWidth", "setClientHeight"]),
    updateClientDimensions() {
      this.setClientWidth(this.$root.$el.clientWidth), this.setClientHeight(this.$root.$el.clientHeight);
    }
  }
});
function Ce(e, t, n, s, r, i, a, o) {
  var l = typeof e == "function" ? e.options : e;
  t && (l.render = t, l.staticRenderFns = n, l._compiled = !0), s && (l.functional = !0), i && (l._scopeId = "data-v-" + i);
  var f;
  if (a ? (f = function(c) {
    c = c || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !c && typeof __VUE_SSR_CONTEXT__ < "u" && (c = __VUE_SSR_CONTEXT__), r && r.call(this, c), c && c._registeredComponents && c._registeredComponents.add(a);
  }, l._ssrRegister = f) : r && (f = o ? function() {
    r.call(
      this,
      (l.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : r), f)
    if (l.functional) {
      l._injectStyles = f;
      var d = l.render;
      l.render = function(h, p) {
        return f.call(p), d(h, p);
      };
    } else {
      var u = l.beforeCreate;
      l.beforeCreate = u ? [].concat(u, f) : [f];
    }
  return {
    exports: e,
    options: l
  };
}
var AH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.layout, { tag: "component", staticClass: "map-ui" });
}, LH = [], RH = /* @__PURE__ */ Ce(
  DH,
  AH,
  LH,
  !1,
  null,
  "d410bb1c",
  null,
  null
);
const wH = RH.exports;
const VH = $t.extend({
  components: {
    MapUi: wH
  },
  props: {
    mapConfiguration: {
      type: Object,
      required: !0
    }
  },
  data: () => ({
    lang: "de",
    noControlOnZoom: !1,
    noControlOnZoomTimeout: void 0,
    oneFingerPan: !1,
    oneFingerPanTimeout: void 0
  }),
  computed: {
    ...ee(["hasWindowSize"])
  },
  watch: {
    // NOTE: Updates can happen if a user resizes the window or the fullscreen plugin is used.
    //       Added as a watcher to trigger the update at the correct time.
    hasWindowSize: function(e) {
      this.updateDragAndZoomInteractions(), this.updateListeners(e);
    }
  },
  mounted() {
    var t, n;
    const e = PH.map.createMap(
      {
        target: this.$refs["polar-map-container"],
        ...this.mapConfiguration
      },
      "2D",
      {
        mapParams: {
          interactions: Gy({
            altShiftDragRotate: !1,
            pinchRotate: !1,
            dragPan: !1,
            mouseWheelZoom: !1
          })
        }
      }
    );
    this.setMap(e), this.updateDragAndZoomInteractions(), this.mapConfiguration.extendedMasterportalapiMarkers && this.useExtendedMasterportalapiMarkers(
      this.mapConfiguration.extendedMasterportalapiMarkers
    ), this.updateListeners(this.hasWindowSize), this.setConfiguration(this.mapConfiguration), (n = (t = this.mapConfiguration.locales) == null ? void 0 : t.forEach) == null || n.call(
      t,
      (s) => qe.addResourceBundle(s.type, "common", s.resources, !0)
    ), qe.on("languageChanged", (s) => {
      this.lang = s;
    }), this.mapConfiguration.checkServiceAvailability && this.checkServiceAvailability(), addEventListener("resize", this.updateHasSmallDisplay), this.updateHasSmallDisplay();
  },
  beforeDestroy() {
    removeEventListener("resize", this.updateHasSmallDisplay);
  },
  methods: {
    ...or(["setConfiguration", "setHasSmallDisplay", "setMap"]),
    ...mi([
      "updateDragAndZoomInteractions",
      "useExtendedMasterportalapiMarkers"
    ]),
    checkServiceAvailability() {
      this.mapConfiguration.layerConf.map((e) => ({
        ping: wM(e),
        service: e
      })).forEach(
        ({ ping: e, service: t }) => e.then((n) => {
          n !== 200 && (this.$store.hasModule(["plugin", "toast"]) && this.$store.dispatch("plugin/toast/addToast", {
            type: "warning",
            text: qe.t("common:error.serviceUnavailable", {
              serviceId: t.id,
              serviceName: t.name
            })
          }), console.error(
            `Ping to "${t.id}" returned "${n}".`
          ), this.$store.commit("setErrors", [
            ...this.$store.getters.errors,
            {
              type: "connection",
              statusCode: n,
              text: `Ping to "${t.id}" returned "${n}".`
            }
          ]));
        }).catch(console.error)
      );
    },
    updateHasSmallDisplay() {
      this.setHasSmallDisplay(
        window.innerHeight <= yf || window.innerWidth <= Ef
      );
    },
    updateListeners(e) {
      const t = this.$refs["polar-map-container"];
      !e && t && (t.addEventListener(
        "wheel",
        ({ ctrlKey: n }) => {
          clearTimeout(this.noControlOnZoomTimeout), this.noControlOnZoom = !n, this.noControlOnZoomTimeout = setTimeout(
            () => this.noControlOnZoom = !1,
            2e3
          );
        }
      ), (window.innerHeight <= yf || window.innerWidth <= Ef) && new MH(t).on("pan", (n) => {
        this.oneFingerPan = n.maxPointers === 1, setTimeout(() => this.oneFingerPan = !1, 2e3);
      }));
    }
  }
});
var BH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-app", { staticClass: "polar-wrapper", attrs: { lang: t.lang } }, [n("transition", { attrs: { name: "fade" } }, [!t.hasWindowSize && (t.noControlOnZoom || t.oneFingerPan) ? n("div", { staticClass: "polar-map-overlay" }, [t.noControlOnZoom ? [t._v(" " + t._s(t.$t("common:overlay.noControlOnZoom")) + " ")] : t.oneFingerPan ? [t._v(" " + t._s(t.$t("common:overlay.oneFingerPan")) + " ")] : t._e()], 2) : t._e()]), n("div", { ref: "polar-map-container", staticClass: "polar-map", attrs: { tabindex: "0", "aria-label": t.$t("common:canvas.label") } }), n("MapUi")], 1);
}, FH = [], NH = /* @__PURE__ */ Ce(
  VH,
  BH,
  FH,
  !1,
  null,
  "2e22d2cf",
  null,
  null
);
const jH = NH.exports, $H = Symbol("Path could not be resolved."), UH = (e, t) => t.reduce(
  (n, s) => n && Object.prototype.hasOwnProperty.call(n, s) ? n[s] : $H,
  e
);
function WH(e, t, n = !0) {
  const s = e.split("/");
  return this.$store.watch((r) => UH(r, s), t, {
    immediate: n
  });
}
function zH({
  containerId: e,
  mapConfiguration: t
}) {
  const n = $k(t == null ? void 0 : t.vuetify);
  n.framework.theme.checkOrCreateStyleElement = function() {
    return this.styleEl || this.genStyleElement(), !!this.styleEl;
  };
  const s = 500, r = 10;
  let i = document.getElementById(e), a = 0;
  return new Promise((o, l) => {
    const f = setInterval(() => {
      if (i) {
        clearInterval(f);
        const d = i.attachShadow({ mode: "open" }), { querySelector: u } = document;
        document.querySelector = function(C) {
          return C === "[data-app]" ? d : u.call(this, C);
        };
        const c = "link", h = [...document.getElementsByTagName(c)], p = "data-polar", g = h.filter(
          (C) => C.getAttribute(p)
        );
        g.length > 0 ? g.map((C) => C.cloneNode(!0)).forEach((C) => d.appendChild(C)) : console.error(
          `core.createMap: Couldn't find required stylesheets, map won' render. Please add "data-polar" to the respective link-tag. The use value for the attribute can be chosen arbitrarily.`
        );
        const m = new $t({
          vuetify: n,
          store: mp,
          i18n: X6(t == null ? void 0 : t.language),
          // use a fresh div injected to the shadow root
          el: d.appendChild(document.createElement("div")),
          render: (C) => C(jH, {
            props: {
              mapConfiguration: t
            }
          })
        }), v = document.getElementById("vuetify-theme-stylesheet");
        d.appendChild(v), m.subscribe = WH;
        let y = 0;
        const E = setInterval(() => {
          const C = m.$store.getters.map.getSize();
          y++ < 100 && (C[0] === 0 || C[1] === 0) ? m.$store.getters.map.updateSize() : clearInterval(E);
        }, 0);
        o(m);
      } else {
        if (a >= r) {
          clearInterval(f), l(
            new Error(`containerId "${e}" not found on website.
                        Map client won't render.
                        Giving up after ${a} ${r}.`)
          );
          return;
        }
        console.error(
          `containerId "${e}" not found on website.
            Map client won't render.
            Retrying in ${s}ms ...`
        ), i = document.getElementById(e), a++;
      }
    }, s);
  });
}
const KH = ta.prototype.addLayer;
ta.prototype.addLayer = function(...e) {
  KH.call(this, ...e), ta.prototype.getLayers.call(this).array_.forEach((t) => {
    const n = t.getSource();
    n.crossOrigin = "anonymous", t.setSource(n);
  });
};
const RI = /{(?<key>[^=]+)=(?<value>[^}]+)}/gm;
function GH(e, t) {
  const n = {}, s = t.replaceAll(RI, (r, i, a) => (n[i] = a, ""));
  fetch(s, { method: "GET", headers: n }).then(
    (r) => r.ok ? r.blob() : r.text().then((i) => {
      throw i;
    })
  ).then((r) => {
    r && (e.getImage().src = URL.createObjectURL(r));
  }).catch(console.error);
}
const kH = ta.prototype.addLayer;
ta.prototype.addLayer = function(...e) {
  kH.call(this, ...e), ta.prototype.getLayers.call(this).array_.forEach((t) => {
    var r;
    const n = t.getSource();
    ((r = n == null ? void 0 : n.urls) == null ? void 0 : r.some((i) => RI.test(i))) && typeof n.setTileLoadFunction == "function" && (n.setTileLoadFunction(GH), t.setSource(n));
  });
};
const HH = $t.extend({
  props: {
    pluginContainer: {
      type: Object,
      required: !0
    }
  }
});
var YH = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.pluginContainer.plugin, t._b({ tag: "component", staticClass: "polar-clickable" }, "component", t.pluginContainer.options.props, !1));
}, XH = [], ZH = /* @__PURE__ */ Ce(
  HH,
  YH,
  XH,
  !1,
  null,
  null,
  null,
  null
);
const JH = ZH.exports;
function QH(e, t) {
  const n = [];
  for (let s = 0; s < e.length; s++)
    e[s].options.layoutTag === t && n.push(e[s]);
  return n;
}
var Pa = /* @__PURE__ */ ((e) => (e.TOP_LEFT = "top-left top left nine-layout", e.TOP_MIDDLE = "top-mid mid top nine-layout", e.TOP_RIGHT = "top-right top right nine-layout", e.MIDDLE_LEFT = "mid-left mid left nine-layout", e.MIDDLE_MIDDLE = "mid-mid mid nine-layout", e.MIDDLE_RIGHT = "mid-right mid right nine-layout", e.BOTTOM_LEFT = "bottom-left bottom left nine-layout", e.BOTTOM_MIDDLE = "bottom-mid mid bottom nine-layout", e.BOTTOM_RIGHT = "bottom-right bottom right nine-layout", e))(Pa || {});
const _O = Object.values(Pa), qH = $t.extend({
  components: {
    PluginVessel: JH
  },
  data: () => ({
    tags: _O
  }),
  computed: {
    ...ee(["components", "hasWindowSize"]),
    // creating plugin lists for all enums
    //  reduces to list of functions, each returning a list of plugins which are sorted by layout
    ..._O.reduce((e, t) => (e[t] = function() {
      return QH(this.components, t);
    }, e), {})
  },
  methods: {
    getSortedTo(e) {
      return this[e];
    }
  }
});
var t7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "wrapper" }, t._l(t.tags, function(s, r) {
    return n("div", { key: r, class: {
      [s]: !0,
      "has-window-size": t.hasWindowSize
    } }, t._l(t.getSortedTo(s), function(i, a) {
      return n("plugin-vessel", t._b({ key: `${r}-${a}` }, "plugin-vessel", { pluginContainer: i }, !1));
    }), 1);
  }), 0);
}, e7 = [], n7 = /* @__PURE__ */ Ce(
  qH,
  t7,
  e7,
  !1,
  null,
  "ba51450e",
  null,
  null
);
const i7 = n7.exports, rd = {
  ...$5,
  addPlugins: U5,
  createMap: zH
}, r7 = "@polar/client-meldemichel", s7 = "1.0.0-alpaka.0", a7 = "Client Meldemichel", o7 = "EUPL-1.2", l7 = "Dataport AR <dataportpolarsupport@dataport.de>", u7 = "dist/client-meldemichel.mjs", c7 = {
  type: "git",
  url: "https://github.com/Dataport/polar.git",
  directory: "packages/clients/meldemichel"
}, h7 = [
  "dist/**/**.*",
  "docs/**/**.*",
  "example/**/**.*",
  "CHANGELOG.md",
  "API.md"
], d7 = {
  postversion: "npm run build",
  build: "rimraf dist && vite build && copyfiles -f src/html/**/* dist"
}, f7 = {
  "@polar/core": "^1.1.0",
  "@polar/lib-custom-types": "^1.1.0",
  "@polar/plugin-address-search": "^1.0.0",
  "@polar/plugin-attributions": "^1.0.0",
  "@polar/plugin-filter": "*",
  "@polar/plugin-fullscreen": "^1.0.0",
  "@polar/plugin-geo-location": "^1.1.0",
  "@polar/plugin-gfi": "^1.0.0",
  "@polar/plugin-icon-menu": "^1.0.1",
  "@polar/plugin-layer-chooser": "^1.0.0",
  "@polar/plugin-loading-indicator": "^1.0.0",
  "@polar/plugin-pins": "^1.1.0",
  "@polar/plugin-reverse-geocoder": "^1.0.0",
  "@polar/plugin-scale": "^1.0.0",
  "@polar/plugin-toast": "^1.0.0",
  "@polar/plugin-zoom": "^1.0.0"
}, p7 = {
  name: r7,
  version: s7,
  description: a7,
  license: o7,
  author: l7,
  main: u7,
  repository: c7,
  files: h7,
  scripts: d7,
  devDependencies: f7
}, ps = {
  // display everything
  COMPLETE: "COMPLETE",
  // do not display AfmButton, reports, filter, list
  REPORT: "REPORT",
  /* do not display AfmButton, reports, filter, list
   * do display a single (maybe movable) feature */
  SINGLE: "SINGLE"
}, wI = [
  "100",
  "101",
  "102",
  "103",
  "104",
  "105",
  "106",
  "111",
  "112",
  "113",
  "114",
  "115",
  "116",
  "117",
  "118",
  "119",
  "120",
  "200",
  "202",
  "203",
  "204",
  "205",
  "400",
  "401",
  "402",
  "500",
  "501",
  "502",
  "503"
], Kv = ["In Bearbeitung", "abgeschlossen"], sd = {
  NONE: 0,
  DAYS_7: 1,
  DAYS_30: 2,
  SELECTABLE: 3
}, m7 = $t.extend({
  name: "AddressSearchGroupSelect",
  computed: {
    ...ee("plugin/addressSearch", [
      "selectedGroupId",
      "groupSelectOptions",
      "hasMultipleGroups"
    ]),
    selectedItem: {
      get() {
        return this.selectedGroupId;
      },
      set(e) {
        this.setSelectedGroupId(e);
      }
    }
  },
  methods: {
    ...mi("plugin/addressSearch", ["setSelectedGroupId"])
  }
});
var g7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.hasMultipleGroups ? n("v-select", { staticClass: "polar-plugin-address-search-group-select", attrs: { dense: "", "aria-label": t.$t("common:plugins.addressSearch.groupSelector"), items: (
    // mapping in template to guarantee update on language change
    t.groupSelectOptions.map(({ value: s, text: r }) => ({ value: s, text: t.$t(r) }))
  ) }, model: { value: t.selectedItem, callback: function(s) {
    t.selectedItem = s;
  }, expression: "selectedItem" } }, [n("div", { attrs: { slot: "selection" }, slot: "selection" })]) : t._e();
}, v7 = [], y7 = /* @__PURE__ */ Ce(
  m7,
  g7,
  v7,
  !1,
  null,
  null,
  null,
  null
);
const E7 = y7.exports;
function Gv(e) {
  for (let t = 0; t < e; t++) {
    const n = (
      // @ts-expect-error | Type conversion is fine here as the querySelector method is monkeyPatched in core/createMap
      document.querySelector("[data-app]").getElementById(
        `polar-plugin-address-search-results-feature-${t}-0`
      )
    );
    if (n) {
      n.focus();
      break;
    }
  }
}
const C7 = (e, t) => {
  const n = e.toLowerCase().indexOf(t.toLowerCase());
  return n === -1 ? e : e.substring(0, n) + "<em>" + e.substring(n, n + t.length) + "</em>" + e.substring(n + t.length);
}, x7 = $t.extend({
  name: "AddressSearchResults",
  data: () => ({
    openCategories: []
  }),
  computed: {
    ...ee(["clientHeight", "hasWindowSize"]),
    ...ee("plugin/addressSearch", [
      "featuresAvailable",
      "featureListsWithCategory",
      "focusAfterSearch",
      "inputValue",
      "limitResults",
      "selectedGroupId",
      "selectedGroup"
    ]),
    maxHeight() {
      return this.hasWindowSize ? this.clientHeight * 0.6 : 400;
    }
  },
  watch: {
    featuresAvailable() {
      this.focusAfterSearch && this.$nextTick(
        () => Gv(this.featureListsWithCategory.length)
      );
    },
    /* reset opened categories on group change */
    selectedGroupId() {
      this.openCategories = [];
    }
  },
  methods: {
    ...mi("plugin/addressSearch", ["selectResult"]),
    toggle(e) {
      this.openCategories = this.openCategories.indexOf(e) === -1 ? [...this.openCategories, e] : this.openCategories.filter((t) => t !== e);
    },
    hasMaximum(e) {
      var t;
      return !!((t = e == null ? void 0 : e.queryParameters) != null && t.maxFeatures);
    },
    emTitleByInput: C7,
    isExpandButtonVisible(e) {
      return e > this.limitResults;
    },
    areResultsExpanded(e) {
      return this.openCategories.includes(e);
    },
    focusNextElement(e, { originalTarget: t }) {
      var a, o, l;
      const n = ["BUTTON", "LI"], s = e ? "nextElementSibling" : "previousElementSibling";
      let r = t, i = r[s];
      for (; i && !n.includes(i.tagName); )
        if (i = i[s], !i) {
          const f = (o = (a = r == null ? void 0 : r.parentElement) == null ? void 0 : a[s]) == null ? void 0 : o.children;
          f && (r = f[e ? 0 : f.length - 1], i = r);
        }
      if (i) {
        i.focus();
        return;
      }
      if (e) {
        Gv(this.featureListsWithCategory.length);
        return;
      }
      (l = document.querySelector("[data-app]").getElementById("polar-plugin-address-search-input")) == null || l.focus();
    }
  }
});
var b7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.featuresAvailable ? n("v-card", { staticClass: "mx-auto overflow-y-auto rounded-b-xl polar-plugin-address-search-toolbar-results", attrs: { tile: "", dense: "", "max-height": t.maxHeight, ripple: !1, tabindex: "-1" } }, t._l(t.featureListsWithCategory, function({ features: s, category: r, categoryId: i }, a) {
    return n("v-list", { key: ["results-list", a].join("-"), staticClass: "polar-plugin-address-search-results-list", attrs: { tag: "ul", subheader: "" } }, [r ? n("v-subheader", { key: ["results-category", a].join("-") }, [t._v(" " + t._s(t.$t(r)) + " " + t._s(t.$t("common:plugins.addressSearch.resultCount", { count: s.length })) + " ")]) : t._e(), t._l(s, function(o, l) {
      return [l < t.limitResults || t.areResultsExpanded(r) ? n("v-list-item", { key: ["results-feature", a, l].join("-"), class: {
        "polar-plugin-address-search-hidden-result": l >= (t.areResultsExpanded(r) ? Number.MAX_SAFE_INTEGER : t.limitResults)
      }, attrs: { id: [
        "polar-plugin-address-search-results-feature",
        a,
        l
      ].join("-"), ripple: !1, tag: "li", tabindex: "-1" }, on: { keydown: [function(f) {
        return !f.type.indexOf("key") && t._k(f.keyCode, "down", 40, f.key, ["Down", "ArrowDown"]) ? null : (f.preventDefault(), f.stopPropagation(), ((d) => t.focusNextElement(!0, d)).apply(null, arguments));
      }, function(f) {
        return !f.type.indexOf("key") && t._k(f.keyCode, "up", 38, f.key, ["Up", "ArrowUp"]) ? null : (f.preventDefault(), f.stopPropagation(), ((d) => t.focusNextElement(!1, d)).apply(null, arguments));
      }], click: function(f) {
        return t.selectResult({ feature: o, categoryId: i });
      } } }, [n("v-list-item-title", [n("span", { domProps: { innerHTML: t._s(t.emTitleByInput(o.title, t.inputValue)) } })])], 1) : t._e()];
    }), s.length > t.limitResults ? n("v-btn", { staticClass: "text-none", attrs: { id: `polar-plugin-address-search-results-feature-expand-button-${a}`, text: "", tile: "", block: "" }, on: { keydown: [function(o) {
      return !o.type.indexOf("key") && t._k(o.keyCode, "down", 40, o.key, ["Down", "ArrowDown"]) ? null : (o.preventDefault(), o.stopPropagation(), ((l) => t.focusNextElement(!0, l)).apply(null, arguments));
    }, function(o) {
      return !o.type.indexOf("key") && t._k(o.keyCode, "up", 38, o.key, ["Up", "ArrowUp"]) ? null : (o.preventDefault(), o.stopPropagation(), ((l) => t.focusNextElement(!1, l)).apply(null, arguments));
    }], click: function(o) {
      return t.toggle(r);
    } } }, [n("v-icon", { staticClass: "mr-1", attrs: { "x-small": "" } }, [t._v(" " + t._s(t.areResultsExpanded(r) ? "fa-chevron-up" : "fa-chevron-down") + " ")]), t._v(" " + t._s(t.$t(`common:plugins.addressSearch.resultList.${t.areResultsExpanded(r) ? "reduce" : `extend${t.hasMaximum(t.selectedGroup[a]) ? "Max" : ""}`}`, t.selectedGroup[a])) + " ")], 1) : t._e(), r ? n("v-divider", { key: ["results-divider", a].join("-") }) : t._e()], 2);
  }), 1) : t._e();
}, T7 = [], O7 = /* @__PURE__ */ Ce(
  x7,
  b7,
  T7,
  !1,
  null,
  "b6b9cc30",
  null,
  null
);
const P7 = O7.exports, S7 = $t.extend({
  name: "AddressSearchInput",
  computed: {
    ...ee("plugin/addressSearch", [
      "featureListsWithCategory",
      "label",
      "placeholder",
      "hint",
      "minLength",
      "loading",
      "inputValue"
    ])
  },
  methods: {
    ...mi("plugin/addressSearch", [
      "input",
      "abortAndRequest",
      "clear"
    ]),
    focusFirstResult: Gv
  }
});
var M7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-text-field", { attrs: { id: "polar-plugin-address-search-input", "prepend-icon": "fa-magnifying-glass", clearable: "", label: t.$t(t.label), placeholder: t.$t(t.placeholder), hint: t.$t(t.hint, { minLength: t.minLength }), "aria-description": t.$t(t.hint, { minLength: t.minLength }), loading: t.loading, value: t.inputValue }, on: { input: t.input, keydown: [function(s) {
    return !s.type.indexOf("key") && t._k(s.keyCode, "enter", 13, s.key, "Enter") ? null : t.abortAndRequest.apply(null, arguments);
  }, function(s) {
    return !s.type.indexOf("key") && t._k(s.keyCode, "down", 40, s.key, ["Down", "ArrowDown"]) ? null : (s.preventDefault(), s.stopPropagation(), t.focusFirstResult(t.featureListsWithCategory.length));
  }], "click:clear": t.clear } });
}, _7 = [], I7 = /* @__PURE__ */ Ce(
  S7,
  M7,
  _7,
  !1,
  null,
  null,
  null,
  null
);
const D7 = I7.exports, A7 = $t.extend({
  name: "AddressSearch",
  components: {
    GroupSelect: E7,
    Input: D7,
    Results: P7
  },
  computed: {
    ...ee(["clientWidth", "hasSmallWidth", "hasWindowSize"]),
    ...ee("plugin/addressSearch", ["featuresAvailable"]),
    style() {
      return "z-index: 1;" + (this.hasWindowSize && this.hasSmallWidth ? `max-width: ${this.clientWidth * 0.75}px` : "");
    },
    toolbarClass() {
      return this.featuresAvailable ? "rounded-t-xl" : "rounded-xl";
    }
  }
});
var L7 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-container", { style: t.style }, [n("v-toolbar", { staticClass: "polar-plugin-address-search-toolbar pt-1", class: t.toolbarClass, attrs: { height: "72" } }, [n("GroupSelect"), n("Input")], 1), n("Results")], 1);
}, R7 = [], w7 = /* @__PURE__ */ Ce(
  A7,
  L7,
  R7,
  !1,
  null,
  null,
  null,
  null
);
const V7 = w7.exports, B7 = [
  {
    type: "de",
    resources: {
      plugins: {
        addressSearch: {
          hint: {
            error: "Etwas ist bei der Suche schiefgegangen.",
            noResults: "Keine Ergebnisse gefunden.",
            loading: "Suche ...",
            tooShort: "Fr die Suche bitte mindestens {{minLength}} Zeichen eingeben."
          },
          defaultGroup: "Adresssuche",
          groupSelector: "Suchthema auswhlen",
          resultCount: "({{count}} Ergebnisse)",
          resultList: {
            extend: "Alle Ergebnisse anzeigen",
            extendMax: "Alle Ergebnisse (max. {{queryParameters.maxFeatures}}) anzeigen",
            reduce: "Ergebnisliste reduzieren"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        addressSearch: {
          hint: {
            error: "Something went wrong.",
            noResults: "No results for the current query.",
            loading: "Searching ...",
            tooShort: "Please enter at least {{minLength}} characters."
          },
          defaultGroup: "Address Search",
          groupSelector: "Select search topic",
          resultCount: "({{count}} results)",
          resultList: {
            extend: "Show all results",
            extendMax: "Show all results (max. {{queryParameters.maxFeatures}})",
            reduce: "Reduce result list"
          }
        }
      }
    }
  }
];
var F7 = "Expected a function", IO = 0 / 0, N7 = "[object Symbol]", j7 = /^\s+|\s+$/g, $7 = /^[-+]0x[0-9a-f]+$/i, U7 = /^0b[01]+$/i, W7 = /^0o[0-7]+$/i, z7 = parseInt, K7 = typeof It == "object" && It && It.Object === Object && It, G7 = typeof self == "object" && self && self.Object === Object && self, k7 = K7 || G7 || Function("return this")(), H7 = Object.prototype, Y7 = H7.toString, X7 = Math.max, Z7 = Math.min, mg = function() {
  return k7.Date.now();
};
function J7(e, t, n) {
  var s, r, i, a, o, l, f = 0, d = !1, u = !1, c = !0;
  if (typeof e != "function")
    throw new TypeError(F7);
  t = DO(t) || 0, kv(n) && (d = !!n.leading, u = "maxWait" in n, i = u ? X7(DO(n.maxWait) || 0, t) : i, c = "trailing" in n ? !!n.trailing : c);
  function h(b) {
    var P = s, O = r;
    return s = r = void 0, f = b, a = e.apply(O, P), a;
  }
  function p(b) {
    return f = b, o = setTimeout(v, t), d ? h(b) : a;
  }
  function g(b) {
    var P = b - l, O = b - f, T = t - P;
    return u ? Z7(T, i - O) : T;
  }
  function m(b) {
    var P = b - l, O = b - f;
    return l === void 0 || P >= t || P < 0 || u && O >= i;
  }
  function v() {
    var b = mg();
    if (m(b))
      return y(b);
    o = setTimeout(v, g(b));
  }
  function y(b) {
    return o = void 0, c && s ? h(b) : (s = r = void 0, a);
  }
  function E() {
    o !== void 0 && clearTimeout(o), f = 0, s = l = r = o = void 0;
  }
  function C() {
    return o === void 0 ? a : y(mg());
  }
  function x() {
    var b = mg(), P = m(b);
    if (s = arguments, r = this, l = b, P) {
      if (o === void 0)
        return p(l);
      if (u)
        return o = setTimeout(v, t), h(l);
    }
    return o === void 0 && (o = setTimeout(v, t)), a;
  }
  return x.cancel = E, x.flush = C, x;
}
function kv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Q7(e) {
  return !!e && typeof e == "object";
}
function q7(e) {
  return typeof e == "symbol" || Q7(e) && Y7.call(e) == N7;
}
function DO(e) {
  if (typeof e == "number")
    return e;
  if (q7(e))
    return IO;
  if (kv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = kv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(j7, "");
  var n = U7.test(e);
  return n || W7.test(e) ? z7(e.slice(2), n ? 2 : 8) : $7.test(e) ? IO : +e;
}
var t9 = J7;
const Hv = /* @__PURE__ */ nl(t9), Sa = {
  ERROR: Symbol("error"),
  NO_SEARCH: Symbol("noSearch")
};
function VI(e) {
  if (!e.ok)
    throw new Error(
      `getFeatures/parseGazetteerResponse: ${e.status === 418 ? "The server refuses to brew coffee because it is, permanently, a teapot." : `The received status code ${e.status} indicates an error.`}`
    );
}
function e9(e, t, n, s, r) {
  return e.text().then((i) => {
    const a = [], o = new DOMParser().parseFromString(i, "application/xml").getElementsByTagName(`wfs:${t}`), l = {
      type: "FeatureCollection",
      features: a
    };
    let f;
    if (o.length === 0)
      return l;
    const d = Array.from(o), u = d[0].getElementsByTagName("iso19112:position").length > 0 ? `EPSG:${// @ts-expect-error | The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
    d[0].getElementsByTagName("iso19112:position")[0].getElementsByTagName("gml:Point")[0].attributes[1].textContent.split("::")[1]}` : s;
    return d.forEach((c) => {
      const h = Object.values(
        ...n.map(
          (g) => c.getElementsByTagNameNS(g, "*")
        )
      ).reduce(
        (g, m) => ({ ...g, [m.localName]: m.textContent }),
        {}
      );
      if (c.getElementsByTagName("iso19112:position").length > 0) {
        const g = (
          // @ts-expect-error | The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
          c.getElementsByTagName("iso19112:position")[0].getElementsByTagName("gml:pos")[0].textContent.split(" ").map((m) => parseFloat(m))
        );
        f = {
          type: "Point",
          coordinates: u === s ? g : Ui(g, u, s)
        };
      }
      if (c.getElementsByTagName("iso19112:geographicExtent").length > 0) {
        const g = (
          // @ts-expect-error | The TS compiler says 'TS2531: Object is possibly 'null'.' which is valid, but not the case with this document
          c.getElementsByTagName("iso19112:geographicExtent")[0].getElementsByTagName("gml:posList")[0].textContent.split(" ").map((m) => parseFloat(m)).reduce(
            (m, v, y, E) => y % 2 === 0 ? [...m, [E[y], E[y + 1]]] : m,
            []
          )
        );
        h.geographicExtent = {
          type: "Polygon",
          coordinates: [
            u === s ? g : g.map(
              (m) => Ui(m, u, s)
            )
          ]
        };
      }
      const p = {
        epsg: s,
        type: "Feature",
        geometry: f,
        properties: h
      };
      r && r.length > 0 && (p.title = Array.isArray(r) ? r.reduce(
        (g, m) => g + h[m] + " ",
        ""
      ).slice(0, -1) : h[r]), a.push(p);
    }), l;
  });
}
function n9(e, t, n, s, r, i, a, o = {}) {
  let l = Object.entries(n).reduce(
    (f, d) => `${f}&${d[0]}=${d[1]}`,
    `${t}?service=WFS&request=GetFeature&version=${s}`
  );
  return l += o.maxFeatures ? `&${s === "2.0.0" ? "count" : "maxFeatures"}=${o.maxFeatures}` : "", l += o.storedQueryId ? `&StoredQuery_ID=${o.storedQueryId}` : "", fetch(encodeURI(l), { signal: e }).then((f) => (VI(f), e9(
    f,
    r,
    i,
    a,
    o == null ? void 0 : o.title
  )));
}
const gg = {}, BI = (e) => {
  if (gg[e])
    return gg[e];
  const t = Array.from(e.matchAll(/{{(.*?)}}/g)), n = [];
  let s = 0;
  for (const r of t)
    s < r.index && (n.push(e.substring(s, r.index)), s = r.index), n.push(r), s += r[0].length;
  return gg[e] = n, n;
}, i9 = (e, t) => e.uninterpreted > t.uninterpreted ? 1 : e.uninterpreted < t.uninterpreted ? -1 : e.index > t.index ? 1 : e.index < t.index ? -1 : 0, r9 = (e, t, n) => {
  const r = [...e.map((o, l) => ({
    match: o,
    uninterpreted: n[l],
    patternLengthDiff: (t[l].match(/{{/g) || []).length - o.length,
    index: l
  }))].sort(i9).map(({ match: o }) => o), i = [];
  return r.filter((o) => {
    if (o.length === 0)
      return !1;
    const l = JSON.stringify(o);
    return i.includes(l) ? !1 : (i.push(l), !0);
  });
}, s9 = (e, t, n) => {
  const s = [], r = [];
  return e.forEach((a) => {
    const o = BI(a), l = [];
    let f = n;
    o.forEach((d) => {
      let u = "";
      if (Array.isArray(d)) {
        const c = d[1], h = t[c], p = f.match(new RegExp("^" + h));
        if (p !== null) {
          const g = p[1];
          l.push([c, g.trim()]), u = p[0].trim();
        }
      } else
        u = d.trim();
      f.startsWith(u) && (f = f.substring(u.length).trim());
    }), r.push(f.length), s.push(l);
  }), r9(s, e, r);
}, a9 = (e, t) => e.fillPercentage > t.fillPercentage ? -1 : e.fillPercentage < t.fillPercentage ? 1 : e.keys.length > t.keys.length ? -1 : e.keys.length < t.keys.length ? 1 : e.index > t.index ? -1 : e.index < t.index ? 1 : 0, o9 = (e, t) => {
  const n = e.properties || {}, i = [...t.map((o, l) => {
    const d = BI(o).reduce(
      (c, h) => Array.isArray(h) ? [...c, h[1]] : c,
      []
    ), u = d.reduce(
      (c, h) => typeof n[h] < "u" && n[h] !== "" ? c + 1 : c,
      0
    );
    return {
      pattern: o,
      keys: d,
      index: l,
      fillPercentage: u / d.length
    };
  })].sort(a9)[0];
  return i.keys.reduce(
    (o, l) => o.replace(`{{${l}}}`, n[l] || ""),
    i.pattern
  );
};
function l9(e, t, n) {
  const s = [], r = {
    type: "FeatureCollection",
    features: s
  };
  return e.text().then((i) => {
    const a = new Qc(), o = new Wr(), l = a.readFeatures(i), { srsName: f } = a.readFeatureCollectionMetadata(i);
    return l.forEach((d) => {
      const u = JSON.parse(o.writeFeature(d));
      u.title = "", t && (n ? u.title = o9(
        u,
        t
      ) : u.title = Array.isArray(t) ? t.map((c) => u.properties[c]).join(" ") : u.properties[t]), f && (u.epsg = "EPSG:" + f.split("::")[1]), s.push(u);
    }), r;
  });
}
const u9 = (e) => e.replace(/\r?\n|\r/g, ""), c9 = ({ maxFeatures: e }) => `
<?xml version="1.0" encoding="UTF-8"?>
<wfs:GetFeature xmlns:wfs="http://www.opengis.net/wfs" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" service="WFS" version="1.1.0" xsi:schemaLocation="http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"${e ? ` maxFeatures="${e}"` : ""}>`, h9 = ({
  srsName: e,
  featurePrefix: t,
  typeName: n,
  xmlns: s
}) => `
<wfs:Query typeName="${t}:${n}" xmlns:${t}="${s}"${e ? ` srsName="${e}"` : ""}>
<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">`, AO = (e, t, { featurePrefix: n, useRightHandWildcard: s }) => `
<ogc:PropertyIsLike wildCard="*" singleChar="." escapeChar="!">
<ogc:PropertyName>${n}:${e}</ogc:PropertyName>
<ogc:Literal>${t}${typeof s == "boolean" && !s ? "" : "*"}</ogc:Literal>
</ogc:PropertyIsLike>`, d9 = "</ogc:Filter></wfs:Query>", f9 = "</wfs:GetFeature>", p9 = (e, t) => {
  let n = h9(t);
  if (e.length > 1)
    n += `<ogc:And>${e.map(([s, r]) => AO(s, r, t)).join("")}</ogc:And>`;
  else if (e.length === 1) {
    const [s, r] = e[0];
    n += AO(s, r, t);
  }
  return n + d9;
}, m9 = (e, t) => u9(
  c9(t) + e.map((n) => p9(n, t)).join("") + f9
);
function g9(e, t, n, s) {
  const { fieldName: r, patterns: i, patternKeys: a } = s;
  let o = [[[]]];
  r && i && console.error(
    "Using both fieldName and patterns for WFS search. These are mutually exclusive. Patterns will be ignored."
  ), r ? o = [[[r, n]]] : i && a ? o = s9(i, a, n) : console.error(
    'Incomplete WFS search configuration. Either "fieldName" or "patterns" and "patternKeys" are required.'
  );
  const l = m9(o, s);
  return fetch(encodeURI(t), { signal: e, method: "POST", body: l }).then(
    (f) => (VI(f), l9(f, r || i, !r))
  );
}
function v9(e, t, n, s) {
  let r = `${t}?query=${n.replace(" ", "+")}`;
  if (s) {
    for (const [a, o] of Object.entries(s).filter(
      ([l]) => l !== "filter" && l !== "epsg" && l !== "apiKey" && l !== "accessToken"
    ))
      r += `&${a}=${o}`;
    s.filter && Object.keys(s.filter).length > 0 && (r += "&filter=", r = Object.entries(s.filter).reduce((a, [o, l]) => `${a + o}:${l}&`, r).slice(0, -1));
  }
  const i = { signal: e };
  return s.accessToken ? i.headers = { Authorization: `Bearer ${s.accessToken}` } : s.apiKey && (i.headers = { "X-Api-Key": s.apiKey }), fetch(encodeURI(r), i).then((a) => a.json()).then((a) => ({
    ...a,
    features: a.features.map((o) => ({
      ...o,
      geometry: {
        ...o.geometry,
        coordinates: s.epsg === "EPSG:4326" ? o.geometry.coordinates : Ui(
          o.geometry.coordinates,
          "EPSG:4326",
          s.epsg
        )
      },
      epsg: s.epsg,
      title: o.properties.text
    }))
  }));
}
function y9(e, t) {
  if (Array.isArray(e)) {
    const n = t.split(" ");
    return e.reduce(
      (s, r, i) => ({
        ...s,
        [r]: n[i]
      }),
      {}
    );
  }
  return { [e]: t };
}
function E9(e, t, n, s) {
  const r = {
    title: s.fieldName,
    storedQueryId: s.storedQueryId
  };
  return s.maxFeatures && (r.maxFeatures = s.maxFeatures), n9(
    e,
    t,
    y9(s.fieldName, n),
    s.version || "2.0.0",
    s.memberSuffix,
    Array.isArray(s.namespaces) ? s.namespaces : [s.namespaces],
    s.epsg,
    r
  );
}
const C9 = (e, t, n, s) => e.map((r) => {
  const { name: i, geometry: a } = r, o = [
    parseInt(a.coordinates[0]),
    parseInt(a.coordinates[1])
  ], l = s === n ? o : Ui(o, s, n);
  return {
    ...r,
    signal: t,
    title: i,
    epsg: s,
    geometry: {
      ...a,
      coordinates: l
    }
  };
});
async function x9(e, t, n, s) {
  q0(t);
  try {
    const r = await LM(n, {
      ...s,
      // always trigger search  control done on a higher level as minLength
      minCharacters: 0
    });
    if (r.length === 0)
      return {
        type: "FeatureCollection",
        features: []
      };
    const a = r[0].properties.position.Point[0].$.srsName;
    let o;
    return a.includes("::") ? o = `EPSG:${a.split("::")[1]}` : a.includes(":") ? o = a : console.error("Unknown formatting of projection:", a), {
      type: "FeatureCollection",
      features: C9(r, e, s.epsg, o)
    };
  } catch (r) {
    throw console.error(r), new Error("An error occurred while fetching the feature collection.");
  }
}
const Yv = { bkg: v9, gazetteer: E9, wfs: g9, mpapi: x9 }, b9 = (e) => Object.entries(e).forEach(([t, n]) => {
  Yv[t] ? console.error(
    `AddressSearch: Method "${t}" already exists. Please choose a different name. Overrides are not allowed.`
  ) : Yv[t] = n;
});
function T9(e) {
  const t = Yv[e];
  if (t)
    return t;
  throw new Error(
    `AddressSearch: The given type "${e}" does not define a valid searchMethod.`
  );
}
let Fs, LO;
const O9 = {
  setupModule({ getters: e }) {
    LO = Hv(
      () => this.dispatch("plugin/addressSearch/load"),
      e.waitMs
    ).bind(this), e.searchMethods.filter(({ url: n }) => !n).forEach(
      (n) => console.error(
        `POLAR Plugin AddressSearch: A specification is missing an URL: (${JSON.stringify(
          n
        )})`
      )
    );
    const t = e.addressSearchConfiguration.customSearchMethods;
    t && b9(t);
  },
  setSelectedGroupId({ commit: e, dispatch: t, state: n }, s) {
    e("setSelectedGroupId", s), e("setSearchResults", Sa.NO_SEARCH), t("input", n.inputValue);
  },
  input({ commit: e, dispatch: t }, n) {
    e("setInputValue", n), t("abortAndRequest");
  },
  abortAndRequest() {
    Fs && (Fs.abort(), Fs = void 0), LO();
  },
  clear({ commit: e }) {
    e("setSearchResults", Sa.NO_SEARCH), e("setChosenAddress", null);
  },
  load({
    state: { inputValue: e },
    rootGetters: t,
    getters: n,
    commit: s,
    dispatch: r
  }) {
    const { minLength: i } = n.addressSearchConfiguration, a = n.selectedGroup;
    if (typeof e > "u" || e === null || e.length < i) {
      s("setSearchResults", Sa.NO_SEARCH), r("indicateLoading", !1);
      return;
    }
    r("indicateLoading", !0), Fs = new AbortController();
    const o = Fs, l = a.map(
      (f) => T9(f.type)(
        Fs.signal,
        f.url,
        e,
        {
          ...f.queryParameters,
          epsg: t.configuration.epsg,
          map: t.map
        }
      )
    );
    return Promise.allSettled(l).then((f) => {
      const d = f.reduce(
        (u, c, h) => c.status === "fulfilled" ? [
          ...u,
          {
            value: c.value,
            index: h
          }
        ] : u,
        []
      );
      o.signal.aborted || f.filter(
        ({ status: u }) => u === "rejected"
      ).forEach(
        ({ reason: u }) => console.error(
          "AddressSearch: An error occurred while sending a request: ",
          u
        )
      ), s("setSearchResults", d);
    }).catch((f) => {
      console.error(
        "AddressSearch: An error occurred while searching.",
        f
      ), s("setSearchResults", Sa.ERROR);
    }).finally(() => {
      r("indicateLoading", !1);
    });
  },
  indicateLoading({ getters: { addressSearchConfiguration: e }, commit: t }, n) {
    t("setLoading", n);
    const { addLoading: s, removeLoading: r } = e;
    n && s && s.length > 0 ? t(s, "AddressSearch", { root: !0 }) : !n && r && r.length > 0 && t(r, "AddressSearch", { root: !0 });
  },
  selectResult(e, t) {
    var o;
    const { commit: n, getters: s } = e, { feature: r, categoryId: i } = t, a = (o = s.addressSearchConfiguration.customSelectResult) == null ? void 0 : o[i];
    a ? a(e, t) : (n("setChosenAddress", r), n("setInputValue", r.title), n("setSearchResults", Sa.NO_SEARCH));
  },
  /**
   * `search` is meant for programmatic access. User search is triggered from
   * the `input` action effects and features a debouncing mechanism.
   * @param vuexParameters - vuex standard parameter object
   * @param payload - input to search for and an autoselect mode
   */
  async search({ state: e, commit: t, dispatch: n, getters: s }, {
    input: r,
    autoselect: i
  }) {
    var l;
    if (t("setInputValue", r), Fs && (Fs.abort(), Fs = void 0), await n("load"), typeof e.searchResults == "symbol")
      return;
    const a = e.searchResults.find(
      ({ value: f }) => f.features.length
    ), o = ((l = a == null ? void 0 : a.value) == null ? void 0 : l.features) || [];
    (i === "first" && o.length >= 1 || i === "only" && o.length === 1) && n("selectResult", {
      feature: o[0],
      categoryId: s.selectedGroup[(a == null ? void 0 : a.index) || 0].categoryId || ""
    });
  }
}, Xv = () => ({
  chosenAddress: null,
  inputValue: "",
  loading: !1,
  searchResults: Sa.NO_SEARCH,
  selectedGroupId: null
}), Zv = {
  label: "common:plugins.addressSearch.defaultGroup",
  placeholder: "",
  hint: "",
  resultDisplayMode: "mixed",
  limitResults: Number.MAX_SAFE_INTEGER
}, P9 = {
  minLength: 0,
  waitMs: 0,
  searchMethods: []
}, ad = ({
  searchMethodsByGroupId: e,
  selectedGroupProperties: t,
  selectedGroupId: n,
  key: s
}) => t[s] || // if not set, first entry defines [key] value
e[n][0][s] || Zv[s], S9 = {
  ...Hi(Xv()),
  /** true if any service of selected group yielded features */
  featuresAvailable(e, { searchResults: t }) {
    return Array.isArray(t) && t.length > 0 && t.some(
      ({ value: n }) => {
        var s;
        return Array.isArray(n == null ? void 0 : n.features) && ((s = n.features) == null ? void 0 : s.length) > 0;
      }
    );
  },
  addressSearchConfiguration(e, t, n, s) {
    var r;
    return {
      ...P9,
      ...((r = s.configuration) == null ? void 0 : r.addressSearch) || {}
    };
  },
  minLength(e, { addressSearchConfiguration: t }) {
    return t.minLength;
  },
  waitMs(e, { addressSearchConfiguration: t }) {
    return t.waitMs;
  },
  searchMethods(e, { addressSearchConfiguration: t }) {
    return t.searchMethods;
  },
  searchMethodsByGroupId(e, { searchMethods: t }) {
    const n = {};
    return t.forEach((s) => {
      const r = s.groupId || "defaultGroup";
      n[r] ? n[r].push(s) : n[r] = [s];
    }), n;
  },
  groupIds(e, { searchMethodsByGroupId: t }) {
    return Object.keys(t);
  },
  selectedGroupId({ selectedGroupId: e }, { groupIds: t }) {
    return e || t[0];
  },
  selectedGroup(e, { searchMethodsByGroupId: t, selectedGroupId: n }) {
    return t[n];
  },
  getGroupProperties(e, { addressSearchConfiguration: t }) {
    return (n) => {
      var r;
      const s = ((r = t.groupProperties) == null ? void 0 : r[n]) || {};
      return n === "defaultGroup" ? {
        ...Zv,
        ...s
      } : s;
    };
  },
  selectedGroupProperties(e, { selectedGroupId: t, getGroupProperties: n }) {
    return n(t);
  },
  limitResults(e, { selectedGroupProperties: t }) {
    return t.limitResults || Zv.limitResults;
  },
  categoryProperties(e, { addressSearchConfiguration: t }) {
    return t.categoryProperties || {};
  },
  label(e, { searchMethodsByGroupId: t, selectedGroupProperties: n, selectedGroupId: s }) {
    return ad({
      searchMethodsByGroupId: t,
      selectedGroupProperties: n,
      selectedGroupId: s,
      key: "label"
    });
  },
  placeholder(e, { searchMethodsByGroupId: t, selectedGroupProperties: n, selectedGroupId: s }) {
    return ad({
      searchMethodsByGroupId: t,
      selectedGroupProperties: n,
      selectedGroupId: s,
      key: "placeholder"
    });
  },
  selectedGroupHint(e, { searchMethodsByGroupId: t, selectedGroupId: n, selectedGroupProperties: s }) {
    return ad({
      searchMethodsByGroupId: t,
      selectedGroupProperties: s,
      selectedGroupId: n,
      key: "hint"
    });
  },
  hint({ inputValue: e, searchResults: t }, { selectedGroupHint: n, minLength: s, featuresAvailable: r, loading: i }) {
    return i ? "common:plugins.addressSearch.hint.loading" : t === Sa.ERROR ? "common:plugins.addressSearch.hint.error" : e && e.length > 0 && e.length < s ? "common:plugins.addressSearch.hint.tooShort" : t !== Sa.NO_SEARCH && !r ? "common:plugins.addressSearch.hint.noResults" : n;
  },
  hasMultipleGroups(e, { groupIds: t }) {
    return t.length > 1;
  },
  groupSelectOptions(e, { searchMethodsByGroupId: t, getGroupProperties: n }) {
    return Object.keys(t).map((s) => ({
      value: s,
      text: ad({
        searchMethodsByGroupId: t,
        selectedGroupProperties: n(s),
        selectedGroupId: s,
        key: "label"
      })
    }));
  },
  featureListsWithCategory({ searchResults: e }, { selectedGroup: t, categoryProperties: n }) {
    return typeof e == "symbol" ? [] : e.map((s) => {
      var r, i, a;
      return {
        features: s.value.features,
        categoryId: ((r = t[s.index]) == null ? void 0 : r.categoryId) || "",
        category: ((a = n[((i = t[s.index]) == null ? void 0 : i.categoryId) || ""]) == null ? void 0 : a.label) || ""
      };
    });
  },
  focusAfterSearch: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.addressSearch) == null ? void 0 : i.focusAfterSearch) || !1;
  }
}, M9 = {
  namespaced: !0,
  state: Xv(),
  actions: O9,
  getters: S9,
  mutations: {
    ...Or(Xv())
  }
}, _9 = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "addressSearch",
  plugin: V7,
  language: B7,
  storeModule: M9,
  options: e
}), I9 = $t.extend({
  name: "GeoLocation",
  computed: {
    ...ee(["hasSmallDisplay"]),
    ...ee("plugin/geoLocation", [
      "geolocation",
      "renderType",
      "tracking",
      "isGeolocationDenied"
    ]),
    tooltipMessage() {
      return this.isGeolocationDenied ? "common:plugins.geoLocation.button.tooltip.locationAccessDenied" : this.tracking ? "common:plugins.geoLocation.button.tooltip.removeLocationMarker" : "common:plugins.geoLocation.button.tooltip.placeLocationMarker";
    }
  },
  methods: {
    ...mi("plugin/geoLocation", ["track", "untrack"])
  }
});
var D9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-tooltip", { attrs: { left: "", disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: {
      "ma-2": t.renderType !== "iconMenu"
    }, attrs: { color: "primary", small: "", fab: "", disabled: t.isGeolocationDenied }, on: { click: function(i) {
      t.geolocation === null ? t.track() : t.untrack();
    } } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v("fa-map-pin")])], 1)];
  } }]) }, [n("span", [t._v(t._s(t.$t(t.tooltipMessage)))])])], 1);
}, A9 = [], L9 = /* @__PURE__ */ Ce(
  I9,
  D9,
  A9,
  !1,
  null,
  "661199ad",
  null,
  null
);
const R9 = L9.exports, w9 = [
  {
    type: "de",
    resources: {
      plugins: {
        geoLocation: {
          markerText: "Aktuelle Position",
          button: {
            tooltip: {
              placeLocationMarker: "Eigene Position markieren",
              removeLocationMarker: "Positionsmarker entfernen",
              locationAccessDenied: "Standortzugriff nutzerseitig abgelehnt"
            }
          },
          toast: {
            notInBoundary: "Sie befinden sich nicht im Kartengebiet.",
            boundaryError: "Die berprfung Ihrer Position ist fehlgeschlagen. Bitte versuchen Sie es spter erneut oder wenden Sie sich an einen Administrator, wenn das Problem bestehen bleibt."
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        geoLocation: {
          markerText: "Current location",
          button: {
            tooltip: {
              placeLocationMarker: "Mark own location",
              removeLocationMarker: "Remove location marker",
              locationAccessDenied: "Location access denied by user"
            }
          },
          toast: {
            notInBoundary: "You are not within the map's boundaries.",
            boundaryError: "Validating your position failed. Please try later again or contact an administrator if the issue persists."
          }
        }
      }
    }
  }
], Jv = () => ({
  geolocation: null,
  position: [],
  tracking: !1,
  isGeolocationDenied: !1
});
let RO = 0;
const V9 = 100, B9 = 100, vg = {
  undefinedBoundaryLayer: Symbol.for("Boundary Layer undefined"),
  undefinedBoundarySource: Symbol.for("Boundary Source undefined"),
  sourceNotReady: Symbol.for("Source not ready")
}, F9 = async (e) => {
  for (; e.getState() !== "ready" || e.getFeatures().length === 0; )
    if (RO++ < V9)
      await new Promise((t) => {
        setTimeout(t, B9);
      });
    else
      return !1;
  return RO = 0, !0;
}, FI = async (e, t, n) => {
  if (typeof t > "u")
    return Promise.resolve(!0);
  const s = e.getLayers().getArray().find(
    (o) => o.get("id") === t
  );
  if (!s)
    return console.error(
      `POLAR Map Client: No layer configured to match boundaryLayerId "${t}" in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(vg.undefinedBoundaryLayer);
  const r = s.getSource();
  if (!r)
    return console.error(
      `POLAR Map Client: Layer with boundaryLayerId "${t}" missing source in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(vg.undefinedBoundarySource);
  if (!await F9(r))
    return console.error(
      `POLAR Map Client: Layer with boundaryLayerId "${t}" did not load or is featureless in plugins/GeoLocation/src/utils/isWithinBoundary.ts.`
    ), Promise.resolve(vg.sourceNotReady);
  const a = r.getFeatures() || [];
  return Promise.resolve(
    a.some(
      (o) => {
        var l;
        return (l = o.getGeometry()) == null ? void 0 : l.intersectsCoordinate(n);
      }
    )
  );
}, N9 = (e, t) => () => e.innerHTML = t.map(
  ([n, s]) => `<${n}>${qe.t(s)}</${n}>`
).join(""), j9 = `
  background: rgba(255, 255, 255, 0.8);
  padding: 0.2em 0.5em;
  border-radius: 4px;
  color: #16161d;
  box-shadow: 0px 0px 3px 2px rgba(0, 0, 0, 0.5);
`, NI = ({
  style: e = j9,
  localeKeys: t
}) => {
  const n = document.createElement("div");
  n.style.cssText = e;
  const s = N9(n, t);
  return qe.on("languageChanged", s), qe.store.on("added", s), s(), {
    element: n,
    unregister: () => {
      qe.off("languageChanges", s), qe.store.off("added", s);
    }
  };
}, $9 = '<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512"><path d="M320 64A64 64 0 1 0 192 64a64 64 0 1 0 128 0zm-96 96c-35.3 0-64 28.7-64 64v48c0 17.7 14.3 32 32 32h1.8l11.1 99.5c1.8 16.2 15.5 28.5 31.8 28.5h38.7c16.3 0 30-12.3 31.8-28.5L318.2 304H320c17.7 0 32-14.3 32-32V224c0-35.3-28.7-64-64-64H224zM132.3 394.2c13-2.4 21.7-14.9 19.3-27.9s-14.9-21.7-27.9-19.3c-32.4 5.9-60.9 14.2-82 24.8c-10.5 5.3-20.3 11.7-27.8 19.6C6.4 399.5 0 410.5 0 424c0 21.4 15.5 36.1 29.1 45c14.7 9.6 34.3 17.3 56.4 23.4C130.2 504.7 190.4 512 256 512s125.8-7.3 170.4-19.6c22.1-6.1 41.8-13.8 56.4-23.4c13.7-8.9 29.1-23.6 29.1-45c0-13.5-6.4-24.5-14-32.6c-7.5-7.9-17.3-14.3-27.8-19.6c-21-10.6-49.5-18.9-82-24.8c-13-2.4-25.5 6.3-27.9 19.3s6.3 25.5 19.3 27.9c30.2 5.5 53.7 12.8 69 20.5c3.2 1.6 5.8 3.1 7.9 4.5c3.6 2.4 3.6 7.2 0 9.6c-8.8 5.7-23.1 11.8-43 17.3C374.3 457 318.5 464 256 464s-118.3-7-157.7-17.9c-19.9-5.5-34.2-11.6-43-17.3c-3.6-2.4-3.6-7.2 0-9.6c2.1-1.4 4.8-2.9 7.9-4.5c15.3-7.7 38.8-14.9 69-20.5z" /></svg>', U9 = {
  setupModule({ getters: e, commit: t, dispatch: n }) {
    n("addMarkerLayer"), navigator.permissions.query({ name: "geolocation" }).then((s) => {
      s.state === "denied" && t("setIsGeolocationDenied", !0);
    }), e.checkLocationInitially && n("track"), n("setupTooltip");
  },
  setupTooltip({ getters: e, rootGetters: t }) {
    if (e.showTooltip) {
      const { map: n } = t, s = new ky({
        element: NI({
          localeKeys: [["h2", "plugins.geoLocation.markerText"]]
        }).element,
        positioning: "bottom-center",
        offset: [0, -5]
      });
      n.addOverlay(s), n.on("pointermove", ({ pixel: r, dragging: i }) => {
        if (i)
          return;
        const o = n.getFeaturesAtPixel(r, {
          layerFilter: (l) => l.get("name") === "geoLocationMarkerLayer"
        }).length ? n.getCoordinateFromPixel(r) : void 0;
        s.setPosition(o);
      });
    }
  },
  /** Enable tracking of geo position */
  track({ getters: { isGeolocationDenied: e, geolocation: t }, commit: n, dispatch: s }) {
    e === !1 ? (t === null ? (t = new lA({
      tracking: !0,
      projection: Wt("EPSG:4326")
    }), n("setGeolocation", t)) : s("positioning"), t.on("change:position", () => s("positioning")), t.on("error", (r) => s("onError", r)), n("setTracking", !0)) : s("onError");
  },
  /**
   * Stop tracking of geo position
   */
  untrack({ getters: { geolocation: e }, commit: t, dispatch: n }) {
    e == null || e.setTracking(!1), n("removeMarker"), t("setTracking", !1), t("setGeolocation", null);
  },
  /**
   * Adds the geoLocationMarkerLayer to the map which also has a feature
   * called geoLocationMarker for visualising the geoLocation of a user.
   * Until the tracking is initiated the style of the layer will be null and
   * gets only changed when the addMarker function gets called.
   */
  addMarkerLayer({ rootGetters: { map: e } }) {
    const t = new sr({
      source: new Ur({
        features: [
          new Pi({
            type: "point",
            name: "geoLocationMarker"
          })
        ]
      }),
      style: null,
      properties: { name: "geoLocationMarkerLayer" }
    });
    e.addLayer(t), t.setZIndex(1 / 0);
  },
  /**
   * Setting the current map on the position
   */
  async positioning({
    rootGetters: { map: e },
    getters: {
      boundaryLayerId: t,
      boundaryOnError: n,
      geolocation: s,
      configuredEpsg: r,
      position: i
    },
    commit: a,
    dispatch: o
  }) {
    const l = Ui(
      s == null ? void 0 : s.getPosition(),
      Wt("EPSG:4326"),
      r
    ), f = await FI(
      e,
      t,
      l
    ), d = typeof f == "symbol";
    if (f === !1 || d && n !== "permissive") {
      o("printPositioningFailed", d), o("untrack");
      return;
    }
    (i[0] !== l[0] || i[1] !== l[1]) && (a("setPosition", l), o("addMarker", l));
  },
  printPositioningFailed({ dispatch: e, getters: { toastAction: t } }, n) {
    t ? e(t, n ? {
      type: "error",
      text: "plugins.geoLocation.toast.boundaryError"
    } : {
      type: "info",
      text: "plugins.geoLocation.toast.notInBoundary",
      timeout: 1e4
    }, { root: !0 }) : console[n ? "error" : "log"](
      n ? "Checking boundary layer failed." : "User position outside of boundary layer."
    );
  },
  /**
   * Adds a marker to the map, which indicates the users geoLocation.
   * This happens by applying a style to the geoLocationMarkerLayer and
   * a geometry to the geoLocationMarker.
   */
  addMarker({
    getters: { geoLocationMarkerLayer: e, markerFeature: t, keepCentered: n },
    dispatch: s
  }, r) {
    const i = !!t.getGeometry();
    t.setGeometry(new hi(r)), e == null || e.setStyle(
      new Mn({
        image: new vs({
          // TODO: It might be interesting to be able to change the color.
          src: `data:image/svg+xml;utf8,${$9}`,
          scale: 0.08,
          opacity: 1
        })
      })
    ), (n || !i) && s("zoomAndCenter");
  },
  /**
   * Removes the geoLocation marker from the map by setting style property
   * of the geoLocationMarkerLayer to null.
   */
  removeMarker({
    getters: { geoLocationMarkerLayer: e, markerFeature: t },
    commit: n
  }) {
    e == null || e.setStyle(null), t.setGeometry(void 0), n("setPosition", []);
  },
  /**
   * Zooms to the configured zoomLevel and centers the map
   * according to a users coordinates
   */
  zoomAndCenter({ rootGetters: e, getters: { position: t, zoomLevel: n } }) {
    e.map.getView().setCenter(t), e.map.getView().setZoom(n);
  },
  /**
   * Show error information and stop tracking if there are errors by tracking the position
   */
  onError({ commit: e, dispatch: t, getters: { toastAction: n } }, s) {
    n ? t(n, {
      type: "error",
      text: "common:plugins.geoLocation.button.tooltip.locationAccessDenied"
    }, { root: !0 }) : console.error("Location access denied by user"), console.error(s.message), e("setIsGeolocationDenied", !0), e("setTracking", !1), t("removeMarker");
  }
}, W9 = {
  ...Hi(Jv()),
  boundaryLayerId: (e, t, n, s) => {
    var r, i;
    return (i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.boundaryLayerId;
  },
  boundaryOnError: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.boundaryOnError) || "permissive";
  },
  configuredEpsg: (e, t, n, s) => {
    var r;
    return (r = s.configuration) == null ? void 0 : r.epsg;
  },
  checkLocationInitially: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.checkLocationInitially) || !1;
  },
  keepCentered: (e, t, n, s) => {
    var i, a;
    const r = (a = (i = s.configuration) == null ? void 0 : i.geoLocation) == null ? void 0 : a.keepCentered;
    return typeof r == "boolean" ? r : !1;
  },
  renderType: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.renderType) || "independent";
  },
  showTooltip: (e, t, n, s) => {
    var r, i;
    return !!((i = (r = s.configuration) == null ? void 0 : r.geoLocation) != null && i.showTooltip);
  },
  toastAction: (e, t, n, s) => {
    var r, i;
    return (i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.toastAction;
  },
  zoomLevel: (e, t, n, s) => {
    var r, i;
    return ((i = (r = s.configuration) == null ? void 0 : r.geoLocation) == null ? void 0 : i.zoomLevel) || 7;
  },
  geoLocationMarkerLayer(e, t, n, s) {
    return s == null ? void 0 : s.map.getLayers().getArray().find((r) => r.get("name") === "geoLocationMarkerLayer");
  },
  markerFeature(e, { geoLocationMarkerLayer: t }) {
    var n, s, r, i, a;
    return ((a = (i = (r = (s = (n = t == null ? void 0 : t.getSource) == null ? void 0 : n.call(t)) == null ? void 0 : s.getFeatures) == null ? void 0 : r.call(s)) == null ? void 0 : i.find) == null ? void 0 : a.call(i, (o) => o.get("name") === "geoLocationMarker")) || null;
  }
}, z9 = {
  namespaced: !0,
  state: Jv(),
  actions: U9,
  getters: W9,
  mutations: {
    ...Or(Jv())
  }
}, K9 = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "geoLocation",
  plugin: R9,
  language: w9,
  storeModule: z9,
  options: e
}), G9 = $t.extend({
  name: "IconMenu",
  data: () => ({
    maxWidth: "inherit"
  }),
  computed: {
    ...ee([
      "hasSmallDisplay",
      "hasSmallHeight",
      "hasWindowSize",
      "clientHeight"
    ]),
    ...ee("plugin/iconMenu", ["menus", "open"]),
    asList() {
      return this.menus.length > 1;
    },
    wrapperComponent() {
      return this.asList ? "ul" : "div";
    },
    itemComponent() {
      return this.asList ? "li" : "div";
    },
    isHorizontal() {
      return this.hasSmallHeight && this.hasWindowSize;
    },
    maxHeight() {
      return this.hasWindowSize ? `calc(${this.clientHeight}px - ${this.isHorizontal ? "calc(100% + 1.5em)" : "1em"})` : "inherit";
    }
  },
  mounted() {
    addEventListener("resize", this.updateMaxSize), this.updateMaxSize();
  },
  beforeDestroy() {
    removeEventListener("resize", this.updateMaxSize);
  },
  methods: {
    ...or("plugin/iconMenu", ["setOpen"]),
    toggle(e) {
      this.open === e ? this.setOpen(null) : this.setOpen(e), this.updateMaxSize();
    },
    updateMaxSize() {
      const e = this.$refs["item-component"];
      if (!this.hasWindowSize && (e != null && e[0])) {
        const { width: t, left: n } = e[0].$el.getBoundingClientRect();
        this.maxWidth = `${t + n}px`;
      } else
        this.maxWidth = "inherit";
    }
  }
});
var k9 = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n(t.wrapperComponent, { tag: "component", staticClass: "icon-menu-list ma-2" }, t._l(t.menus, function({ plugin: s, icon: r, id: i, hint: a }, o) {
    return n(t.itemComponent, { key: o, tag: "component", class: t.isHorizontal ? "icon-menu-list-item-horizontal" : "icon-menu-list-item" }, [r === void 0 ? n(s, { tag: "component", attrs: { "is-horizontal": t.isHorizontal } }) : [n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal, disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: l, attrs: f }) {
      return [n("v-btn", t._g(t._b({ attrs: { color: t.open === o ? "primaryContrast" : "primary", fab: "", small: "", "aria-label": t.$t(a || `common:plugins.iconMenu.hints.${i}`) }, on: { click: function(d) {
        t.toggle(Number(o));
      } } }, "v-btn", f, !1), l), [n("v-icon", { attrs: { color: t.open === o ? "primary" : "primaryContrast" } }, [t._v(" " + t._s(r) + " ")])], 1)];
    } }], null, !0) }, [n("span", [t._v(t._s(t.$t(a || `common:plugins.iconMenu.hints.${i}`)))])]), t.open === o ? n(s, { ref: "item-component", refInFor: !0, tag: "component", class: [
      t.isHorizontal ? "icon-menu-list-item-content-horizontal" : "icon-menu-list-item-content",
      "icon-menu-list-item-content-scrollable-y"
    ], style: `max-height: ${t.maxHeight}; max-width: ${t.maxWidth}` }) : t._e()]], 2);
  }), 1);
}, H9 = [], Y9 = /* @__PURE__ */ Ce(
  G9,
  k9,
  H9,
  !1,
  null,
  "4839adc8",
  null,
  null
);
const X9 = Y9.exports, Z9 = [
  {
    type: "de",
    resources: {
      plugins: {
        iconMenu: {
          hints: {
            attributions: "Quellennachweis",
            draw: "Zeichenwerkzeuge",
            filter: "Filter",
            layerChooser: "Kartenauswahl",
            gfi: "Objektliste"
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        iconMenu: {
          hints: {
            attributions: "Attributions",
            draw: "Draw tools",
            filter: "Filter",
            layerChooser: "Choose map",
            gfi: "Feature list"
          }
        }
      }
    }
  }
], yg = () => ({
  menus: [],
  open: null
}), J9 = {
  namespaced: !0,
  state: yg(),
  actions: {
    setupModule({ commit: e, rootGetters: t }) {
      var a, o, l, f;
      const s = (((o = (a = t.configuration) == null ? void 0 : a.iconMenu) == null ? void 0 : o.menus) || []).filter(({ id: d }) => {
        var c, h;
        const u = (h = (c = t.configuration) == null ? void 0 : c[d]) == null ? void 0 : h.displayComponent;
        return typeof u == "boolean" ? u : !0;
      }).map((d) => {
        let u;
        const c = {
          $store: {
            ...this,
            dispatch: (h, p) => {
              this.dispatch(h, p), u = p.plugin;
            }
          }
        };
        return d.plugin(c), {
          ...d,
          plugin: u
        };
      });
      e("setMenus", s);
      const r = ((f = (l = t.configuration) == null ? void 0 : l.iconMenu) == null ? void 0 : f.initiallyOpen) || "", i = s.findIndex(({ id: d }) => d === r);
      i !== -1 && e("setOpen", i);
    }
  },
  mutations: {
    ...Or(yg())
  },
  getters: {
    ...Hi(yg())
  }
}, Q9 = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "iconMenu",
  plugin: X9,
  language: Z9,
  storeModule: J9,
  options: e
});
const q9 = {
  name: "DefaultIndicator",
  props: {
    showLoader: {
      type: Boolean,
      default: !1
    }
  }
};
var tY = function() {
  var t = this, n = t._self._c;
  return t.showLoader ? n("div", [n("v-card", [n("v-card-text", [t._v(" " + t._s(t.$t("common:plugins.loadingIndicator.loading")) + " "), n("v-progress-linear", { staticClass: "mb-0", attrs: { indeterminate: "", color: "primary" } })], 1)], 1)], 1) : t._e();
}, eY = [], nY = /* @__PURE__ */ Ce(
  q9,
  tY,
  eY,
  !1,
  null,
  "667d4f83",
  null,
  null
);
const iY = nY.exports, rY = $t.extend({
  name: "LoadingIndicator",
  components: { DefaultIndicator: iY },
  computed: {
    ...ee("plugin/loadingIndicator", ["showLoader"])
  }
});
var sY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("DefaultIndicator", { attrs: { "show-loader": t.showLoader } });
}, aY = [], oY = /* @__PURE__ */ Ce(
  rY,
  sY,
  aY,
  !1,
  null,
  "e82c649c",
  null,
  null
);
const lY = oY.exports, uY = [
  {
    type: "de",
    resources: {
      plugins: {
        loadingIndicator: {
          loading: "Ldt..."
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        loadingIndicator: {
          loading: "Loading..."
        }
      }
    }
  }
], cY = () => ({
  loadKeys: /* @__PURE__ */ new Set()
}), hY = {
  namespaced: !0,
  state: cY(),
  mutations: {
    addLoadingKey(e, t) {
      e.loadKeys = /* @__PURE__ */ new Set([...e.loadKeys, t]);
    },
    removeLoadingKey(e, t) {
      const n = new Set(e.loadKeys);
      n.delete(t), e.loadKeys = n;
    }
  },
  getters: {
    showLoader: ({ loadKeys: e }) => e.size > 0
  }
}, dY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "loadingIndicator",
  plugin: lY,
  language: uY,
  storeModule: hY,
  options: e
}), fY = {
  Circle: yS,
  LinearRing: Td,
  LineString: er,
  MultiLineString: na,
  MultiPoint: Eu,
  MultiPolygon: ia,
  Point: hi,
  Polygon: rr
};
function pY(e, t, n, s) {
  const r = fY[n || "Point"], i = new r(s);
  let a = $i(i.getExtent());
  return (n === "Polygon" || n === "MultiPolygon") && !i.intersectsCoordinate(a) && (a = n === "Polygon" ? i.getInteriorPoint().getFirstCoordinate() : i.getInteriorPoints().getFirstCoordinate()), e === t ? a : Ui(a, e, t);
}
const mY = ({ fill: e = "#005CA9", stroke: t = "#FFF" }) => `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="-1 -1 25 25"
  >
    <path
      d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5z"
      fill="${e}"
      stroke="${t}"
      stroke-width="1"
    />
  </svg>
`, gY = (e) => new Mn({
  image: new vs({
    src: `data:image/svg+xml;base64,${btoa(mY(e))}`,
    scale: 2,
    anchor: [0.5, 1]
  })
}), Eg = () => ({
  isActive: !1,
  transformedCoordinate: [],
  latLon: [],
  coordinatesAfterDrag: [],
  getsDragged: !1,
  toZoomLevel: 0,
  atZoomLevel: 0
});
let Ol;
const wO = new e6({
  layers: (e) => e === Ol,
  style: null,
  condition: SR
}), vY = {
  namespaced: !0,
  state: Eg(),
  actions: {
    /**
     * Responsible for setting up the module by adding a watcher. This watcher
     * calls removeMarker and showMarker if the store for addressSearch changes
     * its value for the chosenAddress.
     */
    setupModule({ getters: e, rootGetters: t, dispatch: n, commit: s }) {
      const { appearOnClick: r, coordinateSource: i, initial: a, movable: o, toZoomLevel: l } = t.configuration.pins || {}, f = t.map.getInteractions();
      l && s("setToZoomLevel", l), r != null && r.atZoomLevel && s("setAtZoomLevel", r.atZoomLevel);
      const d = r === void 0 ? !0 : r.show;
      if (typeof o == "boolean" && console.warn(
        "Pins: Using a boolean for the configuration parameter 'movable' has been deprecated and will be removed in the next major release."
      ), t.map.on("singleclick", async ({ coordinate: u }) => {
        const c = f.getArray().some((h) => h instanceof J8);
        if ((typeof o == "boolean" && o || o === "drag" || o === "click") && d && // NOTE: It is assumed that getZoom actually returns the currentZoomLevel, thus the view has a constraint in the resolution.
        t.map.getView().getZoom() >= e.atZoomLevel && !c && await n("isCoordinateInBoundaryLayer", u)) {
          const h = { coordinates: u, clicked: !0 };
          n("removeMarker"), n("showMarker", h), s("setCoordinatesAfterDrag", u), n("updateCoordinates", u);
        }
      }), i && this.watch(
        () => t[i],
        (u) => {
          if (u && u.type !== "reverse_geocoded") {
            const c = {
              coordinates: u.geometry.coordinates,
              type: u.geometry.type,
              clicked: !1,
              epsg: u.epsg
            };
            n("removeMarker"), n("showMarker", c);
          }
        },
        { deep: !0 }
      ), (!o || o === "none") && (t.map.addInteraction(wO), wO.on(
        "select",
        ({ selected: u }) => document.body.style.cursor = u.length ? "not-allowed" : ""
      )), a) {
        const { coordinates: u, centerOn: c, epsg: h } = a, p = typeof h == "string" ? Ui(u, h, t.configuration.epsg) : u;
        n("removeMarker"), n("showMarker", {
          coordinates: p,
          clicked: !0
        }), s("setCoordinatesAfterDrag", p), n("updateCoordinates", p), c && (t.map.getView().setCenter(e.transformedCoordinate), t.map.getView().setZoom(e.toZoomLevel));
      }
    },
    /**
     * Builds a vectorLayer which contains the mapMarker as
     * a vectorFeature and adds it to the map.
     * @param payload - an object with a boolean that shows if the coordinate
     * was submitted via click and the corresponding coordinates.
     */
    showMarker({ getters: e, rootGetters: t, commit: n, dispatch: s }, r) {
      var i, a;
      if (e.isActive === !1) {
        const { configuration: o, map: l } = t;
        r.clicked === !1 && (s(
          "updateCoordinates",
          pY(
            r.epsg,
            o.epsg,
            r.type,
            r.coordinates
          )
        ), l.getView().setCenter(e.transformedCoordinate), l.getView().setZoom(e.toZoomLevel));
        const f = r.clicked === !0 ? r.coordinates : e.transformedCoordinate;
        Ol = new sr({
          source: new Ur({
            features: [
              new Pi({
                geometry: new hi(f),
                type: "point",
                name: "mapMarker",
                zIndex: 100
              })
            ]
          }),
          style: gY(((i = o == null ? void 0 : o.pins) == null ? void 0 : i.style) || {})
        }), Ol.set("polarInternalId", "mapMarkerVectorLayer"), l.addLayer(Ol), Ol.setZIndex(100), n("setIsActive", !0);
        const d = (a = o.pins) == null ? void 0 : a.movable;
        (typeof d == "boolean" && d || d === "drag") && s("makeMarkerDraggable");
      }
    },
    /**
     * Makes the mapMarker draggable
     */
    makeMarkerDraggable({
      rootGetters: { map: e },
      getters: t,
      commit: n,
      dispatch: s
    }) {
      const { atZoomLevel: r } = t, i = e.getInteractions().getArray().find((o) => o.get("_polar_plugin_pins")), a = new i6({
        condition: () => e.getView().getZoom() >= r,
        layers: [Ol]
      });
      a.set("_polar_plugin_pins", !0), i && e.removeInteraction(i), e.addInteraction(a), a.on("translatestart", () => {
        n("setGetsDragged", !0);
      }), a.on("translateend", (o) => {
        n("setGetsDragged", !1), o.features.forEach(async (l) => {
          const f = l.getGeometry();
          let d = f == null ? void 0 : f.getCoordinates();
          await s("isCoordinateInBoundaryLayer", d) || (d = t.transformedCoordinate, s("removeMarker"), s("showMarker", {
            coordinates: d,
            clicked: !0
          })), n("setCoordinatesAfterDrag", d), s("updateCoordinates", d);
        });
      });
    },
    /**
     * Removes the mapMarker from the map by removing its vectorLayer
     */
    removeMarker({ rootGetters: { map: e }, commit: t }) {
      e.getLayers().forEach(function(n) {
        n !== void 0 && n.get("polarInternalId") === "mapMarkerVectorLayer" && e.removeLayer(n);
      }), t("setIsActive", !1);
    },
    /**
     * Set the value for the transformed coordinate and save it as latLon as well.
     * @param coordinates - Coordinates of the pin.
     */
    updateCoordinates({ commit: e, rootGetters: t }, n) {
      const s = ND(n, t.configuration.epsg), r = [s[1], s[0]];
      e("setTransformedCoordinate", n), e("setLatLon", r);
    },
    /**
     * Checks if boundary layer conditions are met; returns false if not and
     * toasts to the user about why the action was blocked, if `toastAction` is
     * configured. If no boundaryLayer configured, always returns true.
     */
    async isCoordinateInBoundaryLayer({ rootGetters: e, dispatch: t }, n) {
      var l;
      const { boundaryLayerId: s, toastAction: r, boundaryOnError: i } = ((l = e.configuration) == null ? void 0 : l.pins) || {}, a = await FI(
        e.map,
        s,
        n
      );
      if (!s || // if a setup error occurred, client will act as if no boundaryLayerId specified
      a === !0 || typeof a == "symbol" && i !== "strict")
        return !0;
      const o = typeof a == "symbol";
      return r ? t(r, o ? {
        type: "error",
        text: "plugins.pins.toast.boundaryError"
      } : {
        type: "info",
        text: "plugins.pins.toast.notInBoundary",
        timeout: 1e4
      }, { root: !0 }) : console[o ? "error" : "log"](
        o ? "Checking boundary layer failed." : ["Pin position outside of boundary layer:", n]
      ), !1;
    }
  },
  mutations: {
    ...Or(Eg())
  },
  getters: {
    ...Hi(Eg())
  }
}, yY = [
  {
    type: "de",
    resources: {
      plugins: {
        pins: {
          toast: {
            notInBoundary: "Diese Koordinate kann nicht gewhlt werden.",
            boundaryError: "Die berprfung der Koordinate ist fehlgeschlagen. Bitte versuchen Sie es spter erneut oder wenden Sie sich an einen Administrator, wenn das Problem bestehen bleibt."
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        pins: {
          toast: {
            notInBoundary: "It is not possible to select this coordinate.",
            boundaryError: "Validating the coordinate failed. Please try again later or contact an administrator if the issue persists."
          }
        }
      }
    }
  }
], EY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "pins",
  language: yY,
  storeModule: vY,
  options: e
});
var Tf = { exports: {} };
Tf.exports;
(function(e, t) {
  var n = 200, s = "Expected a function", r = "__lodash_hash_undefined__", i = 1, a = 2, o = 1 / 0, l = 9007199254740991, f = "[object Arguments]", d = "[object Array]", u = "[object Boolean]", c = "[object Date]", h = "[object Error]", p = "[object Function]", g = "[object GeneratorFunction]", m = "[object Map]", v = "[object Number]", y = "[object Object]", E = "[object Promise]", C = "[object RegExp]", x = "[object Set]", b = "[object String]", P = "[object Symbol]", O = "[object WeakMap]", T = "[object ArrayBuffer]", M = "[object DataView]", L = "[object Float32Array]", A = "[object Float64Array]", D = "[object Int8Array]", I = "[object Int16Array]", w = "[object Int32Array]", B = "[object Uint8Array]", j = "[object Uint8ClampedArray]", k = "[object Uint16Array]", X = "[object Uint32Array]", rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, et = /^\w*$/, Z = /^\./, dt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, vt = /[\\^$.*+?()[\]{}|]/g, bt = /\\(\\)?/g, it = /^\[object .+?Constructor\]$/, R = /^(?:0|[1-9]\d*)$/, V = {};
  V[L] = V[A] = V[D] = V[I] = V[w] = V[B] = V[j] = V[k] = V[X] = !0, V[f] = V[d] = V[T] = V[u] = V[M] = V[c] = V[h] = V[p] = V[m] = V[v] = V[y] = V[C] = V[x] = V[b] = V[O] = !1;
  var tt = typeof It == "object" && It && It.Object === Object && It, Y = typeof self == "object" && self && self.Object === Object && self, W = tt || Y || Function("return this")(), z = t && !t.nodeType && t, at = z && !0 && e && !e.nodeType && e, ct = at && at.exports === z, Mt = ct && tt.process, N = function() {
    try {
      return Mt && Mt.binding("util");
    } catch {
    }
  }(), S = N && N.isTypedArray;
  function _(U, Q) {
    for (var pt = -1, Ot = U ? U.length : 0; ++pt < Ot; )
      if (Q(U[pt], pt, U))
        return !0;
    return !1;
  }
  function F(U) {
    return function(Q) {
      return Q == null ? void 0 : Q[U];
    };
  }
  function G(U, Q) {
    for (var pt = -1, Ot = Array(U); ++pt < U; )
      Ot[pt] = Q(pt);
    return Ot;
  }
  function nt(U) {
    return function(Q) {
      return U(Q);
    };
  }
  function lt(U, Q) {
    return U == null ? void 0 : U[Q];
  }
  function yt(U) {
    var Q = !1;
    if (U != null && typeof U.toString != "function")
      try {
        Q = !!(U + "");
      } catch {
      }
    return Q;
  }
  function Lt(U) {
    var Q = -1, pt = Array(U.size);
    return U.forEach(function(Ot, re) {
      pt[++Q] = [re, Ot];
    }), pt;
  }
  function Ft(U, Q) {
    return function(pt) {
      return U(Q(pt));
    };
  }
  function Jt(U) {
    var Q = -1, pt = Array(U.size);
    return U.forEach(function(Ot) {
      pt[++Q] = Ot;
    }), pt;
  }
  var J = Array.prototype, ft = Function.prototype, Ct = Object.prototype, St = W["__core-js_shared__"], Tt = function() {
    var U = /[^.]+$/.exec(St && St.keys && St.keys.IE_PROTO || "");
    return U ? "Symbol(src)_1." + U : "";
  }(), kt = ft.toString, fe = Ct.hasOwnProperty, Se = Ct.toString, Me = RegExp(
    "^" + kt.call(fe).replace(vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), xe = W.Symbol, We = W.Uint8Array, bn = Ct.propertyIsEnumerable, Ye = J.splice, Hn = Ft(Object.keys, Object), pn = es(W, "DataView"), Ne = es(W, "Map"), mn = es(W, "Promise"), gn = es(W, "Set"), we = es(W, "WeakMap"), vn = es(Object, "create"), ze = ns(pn), Tn = ns(Ne), tn = ns(mn), ae = ns(gn), gi = ns(we), Xe = xe ? xe.prototype : void 0, an = Xe ? Xe.valueOf : void 0, $e = Xe ? Xe.toString : void 0;
  function Vn(U) {
    var Q = -1, pt = U ? U.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Ot = U[Q];
      this.set(Ot[0], Ot[1]);
    }
  }
  function ii() {
    this.__data__ = vn ? vn(null) : {};
  }
  function da(U) {
    return this.has(U) && delete this.__data__[U];
  }
  function Os(U) {
    var Q = this.__data__;
    if (vn) {
      var pt = Q[U];
      return pt === r ? void 0 : pt;
    }
    return fe.call(Q, U) ? Q[U] : void 0;
  }
  function Ps(U) {
    var Q = this.__data__;
    return vn ? Q[U] !== void 0 : fe.call(Q, U);
  }
  function Hr(U, Q) {
    var pt = this.__data__;
    return pt[U] = vn && Q === void 0 ? r : Q, this;
  }
  Vn.prototype.clear = ii, Vn.prototype.delete = da, Vn.prototype.get = Os, Vn.prototype.has = Ps, Vn.prototype.set = Hr;
  function Fn(U) {
    var Q = -1, pt = U ? U.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Ot = U[Q];
      this.set(Ot[0], Ot[1]);
    }
  }
  function vi() {
    this.__data__ = [];
  }
  function Yr(U) {
    var Q = this.__data__, pt = Ci(Q, U);
    if (pt < 0)
      return !1;
    var Ot = Q.length - 1;
    return pt == Ot ? Q.pop() : Ye.call(Q, pt, 1), !0;
  }
  function Ve(U) {
    var Q = this.__data__, pt = Ci(Q, U);
    return pt < 0 ? void 0 : Q[pt][1];
  }
  function yi(U) {
    return Ci(this.__data__, U) > -1;
  }
  function Ei(U, Q) {
    var pt = this.__data__, Ot = Ci(pt, U);
    return Ot < 0 ? pt.push([U, Q]) : pt[Ot][1] = Q, this;
  }
  Fn.prototype.clear = vi, Fn.prototype.delete = Yr, Fn.prototype.get = Ve, Fn.prototype.has = yi, Fn.prototype.set = Ei;
  function Ze(U) {
    var Q = -1, pt = U ? U.length : 0;
    for (this.clear(); ++Q < pt; ) {
      var Ot = U[Q];
      this.set(Ot[0], Ot[1]);
    }
  }
  function Yi() {
    this.__data__ = {
      hash: new Vn(),
      map: new (Ne || Fn)(),
      string: new Vn()
    };
  }
  function Pr(U) {
    return En(this, U).delete(U);
  }
  function Ss(U) {
    return En(this, U).get(U);
  }
  function Nn(U) {
    return En(this, U).has(U);
  }
  function On(U, Q) {
    return En(this, U).set(U, Q), this;
  }
  Ze.prototype.clear = Yi, Ze.prototype.delete = Pr, Ze.prototype.get = Ss, Ze.prototype.has = Nn, Ze.prototype.set = On;
  function ri(U) {
    var Q = -1, pt = U ? U.length : 0;
    for (this.__data__ = new Ze(); ++Q < pt; )
      this.add(U[Q]);
  }
  function An(U) {
    return this.__data__.set(U, r), this;
  }
  function jn(U) {
    return this.__data__.has(U);
  }
  ri.prototype.add = ri.prototype.push = An, ri.prototype.has = jn;
  function Je(U) {
    this.__data__ = new Fn(U);
  }
  function Yn() {
    this.__data__ = new Fn();
  }
  function si(U) {
    return this.__data__.delete(U);
  }
  function Sr(U) {
    return this.__data__.get(U);
  }
  function Xr(U) {
    return this.__data__.has(U);
  }
  function lr(U, Q) {
    var pt = this.__data__;
    if (pt instanceof Fn) {
      var Ot = pt.__data__;
      if (!Ne || Ot.length < n - 1)
        return Ot.push([U, Q]), this;
      pt = this.__data__ = new Ze(Ot);
    }
    return pt.set(U, Q), this;
  }
  Je.prototype.clear = Yn, Je.prototype.delete = si, Je.prototype.get = Sr, Je.prototype.has = Xr, Je.prototype.set = lr;
  function Xn(U, Q) {
    var pt = Is(U) || Ru(U) ? G(U.length, String) : [], Ot = pt.length, re = !!Ot;
    for (var Ut in U)
      (Q || fe.call(U, Ut)) && !(re && (Ut == "length" || oh(Ut, Ot))) && pt.push(Ut);
    return pt;
  }
  function Ci(U, Q) {
    for (var pt = U.length; pt--; )
      if (hh(U[pt][0], Q))
        return pt;
    return -1;
  }
  var Zr = Rt();
  function Jr(U, Q) {
    return U && Zr(U, Q, is);
  }
  function Mr(U, Q) {
    Q = lo(Q, U) ? [Q] : Et(Q);
    for (var pt = 0, Ot = Q.length; U != null && pt < Ot; )
      U = U[al(Q[pt++])];
    return pt && pt == Ot ? U : void 0;
  }
  function Xi(U) {
    return Se.call(U);
  }
  function Li(U, Q) {
    return U != null && Q in Object(U);
  }
  function _e(U, Q, pt, Ot, re) {
    return U === Q ? !0 : U == null || Q == null || !pe(U) && !be(Q) ? U !== U && Q !== Q : Zn(U, Q, _e, pt, Ot, re);
  }
  function Zn(U, Q, pt, Ot, re, Ut) {
    var Ie = Is(U), Ge = Is(Q), on = d, $n = d;
    Ie || (on = ur(U), on = on == f ? y : on), Ge || ($n = ur(Q), $n = $n == f ? y : $n);
    var bi = on == y && !yt(U), wi = $n == y && !yt(Q), Un = on == $n;
    if (Un && !bi)
      return Ut || (Ut = new Je()), Ie || ge(U) ? ie(U, Q, pt, Ot, re, Ut) : yn(U, Q, on, pt, Ot, re, Ut);
    if (!(re & a)) {
      var cr = bi && fe.call(U, "__wrapped__"), hr = wi && fe.call(Q, "__wrapped__");
      if (cr || hr) {
        var pa = cr ? U.value() : U, Ds = hr ? Q.value() : Q;
        return Ut || (Ut = new Je()), pt(pa, Ds, Ot, re, Ut);
      }
    }
    return Un ? (Ut || (Ut = new Je()), Pn(U, Q, pt, Ot, re, Ut)) : !1;
  }
  function Ms(U, Q, pt, Ot) {
    var re = pt.length, Ut = re, Ie = !Ot;
    if (U == null)
      return !Ut;
    for (U = Object(U); re--; ) {
      var Ge = pt[re];
      if (Ie && Ge[2] ? Ge[1] !== U[Ge[0]] : !(Ge[0] in U))
        return !1;
    }
    for (; ++re < Ut; ) {
      Ge = pt[re];
      var on = Ge[0], $n = U[on], bi = Ge[1];
      if (Ie && Ge[2]) {
        if ($n === void 0 && !(on in U))
          return !1;
      } else {
        var wi = new Je();
        if (Ot)
          var Un = Ot($n, bi, on, U, Q, wi);
        if (!(Un === void 0 ? _e(bi, $n, Ot, i | a, wi) : Un))
          return !1;
      }
    }
    return !0;
  }
  function Qr(U) {
    if (!pe(U) || lh(U))
      return !1;
    var Q = ut(U) || yt(U) ? Me : it;
    return Q.test(ns(U));
  }
  function qr(U) {
    return be(U) && wt(U.length) && !!V[Se.call(U)];
  }
  function Zi(U) {
    return typeof U == "function" ? U : U == null ? Vu : typeof U == "object" ? Is(U) ? K(U[0], U[1]) : $(U) : dh(U);
  }
  function ts(U) {
    if (!_s(U))
      return Hn(U);
    var Q = [];
    for (var pt in Object(U))
      fe.call(U, pt) && pt != "constructor" && Q.push(pt);
    return Q;
  }
  function $(U) {
    var Q = Jn(U);
    return Q.length == 1 && Q[0][2] ? uh(Q[0][0], Q[0][1]) : function(pt) {
      return pt === U || Ms(pt, U, Q);
    };
  }
  function K(U, Q) {
    return lo(U) && fa(Q) ? uh(al(U), Q) : function(pt) {
      var Ot = Ri(pt, U);
      return Ot === void 0 && Ot === Q ? xi(pt, U) : _e(Q, Ot, void 0, i | a);
    };
  }
  function q(U) {
    return function(Q) {
      return Mr(Q, U);
    };
  }
  function ot(U) {
    if (typeof U == "string")
      return U;
    if (je(U))
      return $e ? $e.call(U) : "";
    var Q = U + "";
    return Q == "0" && 1 / U == -o ? "-0" : Q;
  }
  function Et(U) {
    return Is(U) ? U : ch(U);
  }
  function Rt(U) {
    return function(Q, pt, Ot) {
      for (var re = -1, Ut = Object(Q), Ie = Ot(Q), Ge = Ie.length; Ge--; ) {
        var on = Ie[U ? Ge : ++re];
        if (pt(Ut[on], on, Ut) === !1)
          break;
      }
      return Q;
    };
  }
  function ie(U, Q, pt, Ot, re, Ut) {
    var Ie = re & a, Ge = U.length, on = Q.length;
    if (Ge != on && !(Ie && on > Ge))
      return !1;
    var $n = Ut.get(U);
    if ($n && Ut.get(Q))
      return $n == Q;
    var bi = -1, wi = !0, Un = re & i ? new ri() : void 0;
    for (Ut.set(U, Q), Ut.set(Q, U); ++bi < Ge; ) {
      var cr = U[bi], hr = Q[bi];
      if (Ot)
        var pa = Ie ? Ot(hr, cr, bi, Q, U, Ut) : Ot(cr, hr, bi, U, Q, Ut);
      if (pa !== void 0) {
        if (pa)
          continue;
        wi = !1;
        break;
      }
      if (Un) {
        if (!_(Q, function(Ds, uo) {
          if (!Un.has(uo) && (cr === Ds || pt(cr, Ds, Ot, re, Ut)))
            return Un.add(uo);
        })) {
          wi = !1;
          break;
        }
      } else if (!(cr === hr || pt(cr, hr, Ot, re, Ut))) {
        wi = !1;
        break;
      }
    }
    return Ut.delete(U), Ut.delete(Q), wi;
  }
  function yn(U, Q, pt, Ot, re, Ut, Ie) {
    switch (pt) {
      case M:
        if (U.byteLength != Q.byteLength || U.byteOffset != Q.byteOffset)
          return !1;
        U = U.buffer, Q = Q.buffer;
      case T:
        return !(U.byteLength != Q.byteLength || !Ot(new We(U), new We(Q)));
      case u:
      case c:
      case v:
        return hh(+U, +Q);
      case h:
        return U.name == Q.name && U.message == Q.message;
      case C:
      case b:
        return U == Q + "";
      case m:
        var Ge = Lt;
      case x:
        var on = Ut & a;
        if (Ge || (Ge = Jt), U.size != Q.size && !on)
          return !1;
        var $n = Ie.get(U);
        if ($n)
          return $n == Q;
        Ut |= i, Ie.set(U, Q);
        var bi = ie(Ge(U), Ge(Q), Ot, re, Ut, Ie);
        return Ie.delete(U), bi;
      case P:
        if (an)
          return an.call(U) == an.call(Q);
    }
    return !1;
  }
  function Pn(U, Q, pt, Ot, re, Ut) {
    var Ie = re & a, Ge = is(U), on = Ge.length, $n = is(Q), bi = $n.length;
    if (on != bi && !Ie)
      return !1;
    for (var wi = on; wi--; ) {
      var Un = Ge[wi];
      if (!(Ie ? Un in Q : fe.call(Q, Un)))
        return !1;
    }
    var cr = Ut.get(U);
    if (cr && Ut.get(Q))
      return cr == Q;
    var hr = !0;
    Ut.set(U, Q), Ut.set(Q, U);
    for (var pa = Ie; ++wi < on; ) {
      Un = Ge[wi];
      var Ds = U[Un], uo = Q[Un];
      if (Ot)
        var RE = Ie ? Ot(uo, Ds, Un, Q, U, Ut) : Ot(Ds, uo, Un, U, Q, Ut);
      if (!(RE === void 0 ? Ds === uo || pt(Ds, uo, Ot, re, Ut) : RE)) {
        hr = !1;
        break;
      }
      pa || (pa = Un == "constructor");
    }
    if (hr && !pa) {
      var fh = U.constructor, ph = Q.constructor;
      fh != ph && "constructor" in U && "constructor" in Q && !(typeof fh == "function" && fh instanceof fh && typeof ph == "function" && ph instanceof ph) && (hr = !1);
    }
    return Ut.delete(U), Ut.delete(Q), hr;
  }
  function En(U, Q) {
    var pt = U.__data__;
    return Au(Q) ? pt[typeof Q == "string" ? "string" : "hash"] : pt.map;
  }
  function Jn(U) {
    for (var Q = is(U), pt = Q.length; pt--; ) {
      var Ot = Q[pt], re = U[Ot];
      Q[pt] = [Ot, re, fa(re)];
    }
    return Q;
  }
  function es(U, Q) {
    var pt = lt(U, Q);
    return Qr(pt) ? pt : void 0;
  }
  var ur = Xi;
  (pn && ur(new pn(new ArrayBuffer(1))) != M || Ne && ur(new Ne()) != m || mn && ur(mn.resolve()) != E || gn && ur(new gn()) != x || we && ur(new we()) != O) && (ur = function(U) {
    var Q = Se.call(U), pt = Q == y ? U.constructor : void 0, Ot = pt ? ns(pt) : void 0;
    if (Ot)
      switch (Ot) {
        case ze:
          return M;
        case Tn:
          return m;
        case tn:
          return E;
        case ae:
          return x;
        case gi:
          return O;
      }
    return Q;
  });
  function Du(U, Q, pt) {
    Q = lo(Q, U) ? [Q] : Et(Q);
    for (var Ot, re = -1, Ie = Q.length; ++re < Ie; ) {
      var Ut = al(Q[re]);
      if (!(Ot = U != null && pt(U, Ut)))
        break;
      U = U[Ut];
    }
    if (Ot)
      return Ot;
    var Ie = U ? U.length : 0;
    return !!Ie && wt(Ie) && oh(Ut, Ie) && (Is(U) || Ru(U));
  }
  function oh(U, Q) {
    return Q = Q ?? l, !!Q && (typeof U == "number" || R.test(U)) && U > -1 && U % 1 == 0 && U < Q;
  }
  function lo(U, Q) {
    if (Is(U))
      return !1;
    var pt = typeof U;
    return pt == "number" || pt == "symbol" || pt == "boolean" || U == null || je(U) ? !0 : et.test(U) || !rt.test(U) || Q != null && U in Object(Q);
  }
  function Au(U) {
    var Q = typeof U;
    return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? U !== "__proto__" : U === null;
  }
  function lh(U) {
    return !!Tt && Tt in U;
  }
  function _s(U) {
    var Q = U && U.constructor, pt = typeof Q == "function" && Q.prototype || Ct;
    return U === pt;
  }
  function fa(U) {
    return U === U && !pe(U);
  }
  function uh(U, Q) {
    return function(pt) {
      return pt == null ? !1 : pt[U] === Q && (Q !== void 0 || U in Object(pt));
    };
  }
  var ch = Lu(function(U) {
    U = Ke(U);
    var Q = [];
    return Z.test(U) && Q.push(""), U.replace(dt, function(pt, Ot, re, Ut) {
      Q.push(re ? Ut.replace(bt, "$1") : Ot || pt);
    }), Q;
  });
  function al(U) {
    if (typeof U == "string" || je(U))
      return U;
    var Q = U + "";
    return Q == "0" && 1 / U == -o ? "-0" : Q;
  }
  function ns(U) {
    if (U != null) {
      try {
        return kt.call(U);
      } catch {
      }
      try {
        return U + "";
      } catch {
      }
    }
    return "";
  }
  function Lu(U, Q) {
    if (typeof U != "function" || Q && typeof Q != "function")
      throw new TypeError(s);
    var pt = function() {
      var Ot = arguments, re = Q ? Q.apply(this, Ot) : Ot[0], Ut = pt.cache;
      if (Ut.has(re))
        return Ut.get(re);
      var Ie = U.apply(this, Ot);
      return pt.cache = Ut.set(re, Ie), Ie;
    };
    return pt.cache = new (Lu.Cache || Ze)(), pt;
  }
  Lu.Cache = Ze;
  function hh(U, Q) {
    return U === Q || U !== U && Q !== Q;
  }
  function Ru(U) {
    return st(U) && fe.call(U, "callee") && (!bn.call(U, "callee") || Se.call(U) == f);
  }
  var Is = Array.isArray;
  function H(U) {
    return U != null && wt(U.length) && !ut(U);
  }
  function st(U) {
    return be(U) && H(U);
  }
  function ut(U) {
    var Q = pe(U) ? Se.call(U) : "";
    return Q == p || Q == g;
  }
  function wt(U) {
    return typeof U == "number" && U > -1 && U % 1 == 0 && U <= l;
  }
  function pe(U) {
    var Q = typeof U;
    return !!U && (Q == "object" || Q == "function");
  }
  function be(U) {
    return !!U && typeof U == "object";
  }
  function je(U) {
    return typeof U == "symbol" || be(U) && Se.call(U) == P;
  }
  var ge = S ? nt(S) : qr;
  function Ke(U) {
    return U == null ? "" : ot(U);
  }
  function Ri(U, Q, pt) {
    var Ot = U == null ? void 0 : Mr(U, Q);
    return Ot === void 0 ? pt : Ot;
  }
  function xi(U, Q) {
    return U != null && Du(U, Q, Li);
  }
  function is(U) {
    return H(U) ? Xn(U) : ts(U);
  }
  function wu(U, Q) {
    var pt = {};
    return Q = Zi(Q), Jr(U, function(Ot, re, Ut) {
      pt[re] = Q(Ot, re, Ut);
    }), pt;
  }
  function Vu(U) {
    return U;
  }
  function dh(U) {
    return lo(U) ? F(al(U)) : q(U);
  }
  e.exports = wu;
})(Tf, Tf.exports);
var CY = Tf.exports;
const xY = /* @__PURE__ */ nl(CY), { parseString: bY, processors: TY } = os, OY = ([e, t]) => `
  <wps:Execute xmlns:wps='http://www.opengis.net/wps/1.0.0' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:ows='http://www.opengis.net/ows/1.1' service='WPS' version='1.0.0' xsi:schemaLocation='http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsExecute_request.xsd'>
    <ows:Identifier>ReverseGeocoder.fmw</ows:Identifier>
      <wps:DataInputs>
        <wps:Input>
          <ows:Identifier>X</ows:Identifier>
          <wps:Data>
            <wps:LiteralData dataType='float'>${e}</wps:LiteralData>
          </wps:Data>
        </wps:Input>
        <wps:Input>
        <ows:Identifier>Y</ows:Identifier>
        <wps:Data>
          <wps:LiteralData dataType='float'>${t}</wps:LiteralData>
        </wps:Data>
      </wps:Input>
    </wps:DataInputs>
  </wps:Execute>
`, PY = (e) => new Promise(
  (t, n) => bY(
    e,
    { tagNameProcessors: [TY.stripPrefix] },
    (s, r) => s ? n(s) : t(r)
  )
), SY = async (e, t) => {
  const n = await fetch(e, {
    method: "POST",
    body: OY(t)
  }), s = await PY(await n.text()), r = xY(
    // @ts-expect-error | no types for WPS output defined
    s.ExecuteResponse.ProcessOutputs[0].Output[0].Data[0].ComplexData[0].ReverseGeocoder[0].Ergebnis[0].Adresse[0],
    (o) => o[0]
  ), i = {
    Distanz: parseFloat(r.Distanz),
    Hausnr: parseInt(r.Hausnr, 10),
    Plz: parseInt(r.Plz, 10),
    Strasse: r.Strasse,
    XKoordinate: parseFloat(r.XKoordinate),
    YKoordinate: parseFloat(r.YKoordinate),
    Zusatz: r.Zusatz
  };
  return {
    type: "reverse_geocoded",
    title: `${i.Strasse} ${i.Hausnr}${i.Zusatz}`,
    properties: i,
    geometry: {
      // as clicked by user - usually want to keep this since user is pointing at something
      coordinates: t,
      type: "Point"
    },
    addressGeometry: {
      // as returned by reverse geocoder
      coordinates: [i.XKoordinate, i.YKoordinate],
      type: "Point"
    }
  };
};
let VO = 0;
const MY = {
  namespaced: !0,
  state: {},
  actions: {
    setupModule({ rootGetters: e, dispatch: t }) {
      const { coordinateSource: n } = e.configuration.reverseGeocoder || {};
      n && this.watch(
        () => e[n],
        (s) => {
          s && s.length && t("resolveCoordinate", s);
        },
        { deep: !0 }
      );
    },
    async resolveCoordinate({ rootGetters: e, commit: t, dispatch: n }, s) {
      const { url: r, addressTarget: i, addLoading: a, removeLoading: o, zoomTo: l } = e.configuration.reverseGeocoder || {}, { map: f } = e;
      if (!r)
        throw new Error(
          "POLAR ReverseGeocoder#resolveCoordinate: No URL specified."
        );
      const d = ++VO, u = `reverse-geocoder-load-${d}`;
      a && t(a, u, { root: !0 });
      let c = null;
      try {
        c = await SY(r, s), d === VO && (i && n(i, { feature: c }, { root: !0 }), typeof l == "number" && f.getView().fit(new hi(s), {
          maxZoom: l,
          duration: 400,
          easing: qo
        }));
      } catch (h) {
        console.error(
          "An error occurred in POLAR ReverseGeocoder#resolveCoordinate:"
        ), console.error(h);
      } finally {
        o && t(o, u, { root: !0 });
      }
      return c;
    }
  },
  getters: {},
  mutations: {}
}, _Y = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "reverseGeocoder",
  storeModule: MY,
  options: e
}), IY = $t.extend({
  name: "PolarScale",
  computed: {
    ...ee("plugin/scale", ["scaleToOne", "scaleWithUnit"])
  }
});
var DY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-plugin-scales", title: t.$t("common:plugins.scale.label"), "aria-label": t.$t("common:plugins.scale.label") } }, [n("span", { staticClass: "scale-as-a-ratio" }, [t._v(" " + t._s(t.scaleToOne) + " ")]), n("span", { staticClass: "scale-line" }, [t._v(" " + t._s(t.scaleWithUnit) + " ")])]);
}, AY = [], LY = /* @__PURE__ */ Ce(
  IY,
  DY,
  AY,
  !1,
  null,
  null,
  null,
  null
);
const RY = LY.exports, wY = [
  {
    type: "de",
    resources: {
      plugins: {
        scale: {
          toOneNegative: "Skalierung muss eine positive Zahl sein",
          label: "Skala"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        scale: {
          toOneNegative: "scale must be a positive number",
          label: "Scale"
        }
      }
    }
  }
];
function VY(e, t = ".", n = ",") {
  const s = typeof e != "string" ? e.toString() : e, r = s.indexOf("."), a = (r > -1 ? s.substring(0, r) : s).replace(/\B(?=(\d{3})+(?!\d),?.*)/g, t), o = r > -1 ? s.substring(r + 1) : !1;
  return o ? a + n + o : a;
}
function BY() {
  let e = 96;
  try {
    const t = document.createElement("div"), n = document.body;
    t.id = "programmatical-dpidiv", t.setAttribute(
      "style",
      "position: absolute; height: 1in; width: 1in; top: -100%; left: -100%;"
    ), n.appendChild(t), e = t.offsetWidth * (window.devicePixelRatio || 1), n.removeChild(t);
  } catch (t) {
    console.error(t), console.warn(
      `Since the dpi could not be inferred, the default value ${e} will be used.`
    );
  }
  return e;
}
const Cg = () => ({
  scaleValue: 0,
  scaleToOne: "",
  scaleWithUnit: ""
}), FY = {
  namespaced: !0,
  state: Cg(),
  actions: {
    setupModule({ rootGetters: { map: e }, dispatch: t }) {
      e.on("moveend", () => t("getScale"));
    },
    /**
     * gets the current scale and sets it to the state variable scaleValue
     */
    getScale({ rootGetters: { map: e }, commit: t, dispatch: n }) {
      const s = e.getView().getProjection().getUnits(), r = e.getView().getResolution(), i = 39.37, a = Math.round(
        r * ql[s] * i * BY()
      );
      t("setScaleValue", a), n("scaleWithUnit"), n("scaleToOne");
    },
    /**
     * generates a beautified state in format "1 : scale" where scale is rounded based on its value
     */
    scaleToOne({ getters: e, commit: t }) {
      let n = e.scaleValue;
      if (typeof n != "number" || n <= 0)
        return `1 : ${pI("common:plugins.scale.toOneNegative")}`;
      n > 1e4 ? n = Math.round(n / 500) * 500 : n > 1e3 && (n = Math.round(n / 50) * 50);
      const s = "1 : " + VY(n);
      t("setScaleToOne", s);
    },
    /**
     * generates a beautified scale with a km or m unit
     */
    scaleWithUnit({ getters: e, commit: t }) {
      const n = Math.round(0.02 * e.scaleValue), s = n >= 1e3 ? `${Math.round(n / 100) / 10} km` : `${n} m`;
      t("setScaleWithUnit", s);
    }
  },
  mutations: {
    ...Or(Cg())
  },
  getters: {
    ...Hi(Cg())
  }
}, NY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "scale",
  plugin: RY,
  language: wY,
  storeModule: FY,
  options: e
}), jY = $t.extend({
  name: "PolarToast",
  computed: {
    ...ee("plugin/toast", ["toasts", "types"])
  },
  methods: {
    ...or("plugin/toast", ["removeToast"]),
    ...mi("plugin/toast", ["addToast"])
  }
});
var $Y = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "polar-alert-invert" }, t._l(t.toasts, function(s, r) {
    return n("v-alert", { key: s.type + "-" + r + "-" + s.text, staticClass: "v-alert", attrs: { dismissible: "", dense: "", "close-label": t.$t("common:plugins.toast.close"), type: s.type, color: s.color, icon: s.icon }, on: { input: function(i) {
      return t.removeToast(s);
    } } }, [t._v(" " + t._s(t.$t(s.text)) + " ")]);
  }), 1);
}, UY = [], WY = /* @__PURE__ */ Ce(
  jY,
  $Y,
  UY,
  !1,
  null,
  "98b4ed40",
  null,
  null
);
const zY = WY.exports, KY = [
  {
    type: "de",
    resources: {
      plugins: {
        toast: {
          close: "Benachrichtigung ausblenden"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        toast: {
          close: "Hide notification"
        }
      }
    }
  }
], xg = () => ({
  toasts: [],
  types: {
    success: {
      color: void 0,
      icon: void 0
    },
    warning: {
      color: void 0,
      icon: void 0
    },
    info: {
      color: void 0,
      icon: void 0
    },
    error: {
      color: void 0,
      icon: void 0
    }
  }
}), GY = {
  namespaced: !0,
  state: xg(),
  actions: {
    setupModule({ state: e, commit: t, rootGetters: n }) {
      const s = n.configuration.toast || xg().types, r = Bc({}, e.types, {
        error: s.error || {},
        warning: s.warning || {},
        info: s.info || {},
        success: s.success || {}
      });
      t("setTypes", r);
    },
    addToast({ state: e, commit: t }, n) {
      const s = {
        ...e.types[n.type] || {},
        ...n
      };
      t("addToast", s), n.timeout && (n.type !== "error" ? setTimeout(() => {
        t("removeToast", s);
      }, n.timeout) : console.warn(
        "@polar/plugin.toast: Timeouts for error messages are disabled, they can only be dismissed manually."
      ));
    }
  },
  getters: {
    ...Hi(xg())
  },
  mutations: {
    setTypes(e, t) {
      e.types = t;
    },
    addToast(e, t) {
      e.toasts = [...e.toasts, t];
    },
    removeToast(e, t) {
      e.toasts = e.toasts.filter((n) => n !== t);
    }
  }
}, kY = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "toast",
  plugin: zY,
  language: KY,
  options: e,
  storeModule: GY
}), HY = $t.extend({
  name: "AttributionButton",
  computed: {
    ...ee("plugin/attributions", ["windowIsOpen"]),
    mapInfoIcon() {
      return this.windowIsOpen ? "fa-chevron-right" : "fa-regular fa-copyright";
    }
  },
  methods: {
    ...or("plugin/attributions", ["setWindowIsOpen"]),
    toggleMapInfo() {
      this.setWindowIsOpen(!this.windowIsOpen);
    }
  }
});
var YY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-btn", { staticClass: "buttonSecondary", attrs: { "x-small": "", fab: "", color: "secondary", title: t.$t(
    `common:plugins.attributions.button.${t.windowIsOpen ? "close" : "open"}Title`
  ) }, on: { click: t.toggleMapInfo } }, [n("v-icon", { attrs: { color: "secondaryContrast" } }, [t._v(t._s(t.mapInfoIcon))])], 1);
}, XY = [], ZY = /* @__PURE__ */ Ce(
  HY,
  YY,
  XY,
  !1,
  null,
  "2d4c700a",
  null,
  null
);
const JY = ZY.exports, QY = $t.extend({
  name: "AttributionContent",
  computed: {
    ...ee([
      "clientWidth",
      "hasSmallWidth",
      "hasWindowSize",
      "language"
    ]),
    ...ee("plugin/attributions", ["mapInfo", "windowWidth"]),
    maxWidth() {
      return this.hasWindowSize && this.hasSmallWidth ? this.clientWidth * 0.85 : 1080;
    },
    cardText() {
      return Vl(this.language), this.mapInfo.map(
        (e) => pI(e, {
          MONTH: `${(/* @__PURE__ */ new Date()).getMonth() + 1}`.padStart(2, "0"),
          YEAR: (/* @__PURE__ */ new Date()).getFullYear().toString()
        })
      ).join("<br>");
    }
  },
  mounted() {
    this.$refs.sources.getElementsByTagName("a").length > 0 && this.$nextTick(
      () => this.$refs.sources.getElementsByTagName("a")[0].focus({ focusVisible: !0 })
    );
  }
});
var qY = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-scroll-x-reverse-transition", [n("v-card", { attrs: { dir: "ltr", dense: "", filled: "", width: t.windowWidth, color: "#ffffffdd", "max-width": t.maxWidth } }, [n("v-card-title", [t._v(" " + t._s(t.$t("common:plugins.attributions.title")) + " ")]), n("v-card-text", { ref: "sources", domProps: { innerHTML: t._s(t.cardText) } })], 1)], 1)], 1);
}, tX = [], eX = /* @__PURE__ */ Ce(
  QY,
  qY,
  tX,
  !1,
  null,
  "dd52a37d",
  null,
  null
);
const nX = eX.exports, iX = $t.extend({
  name: "AttributionsPlugin",
  components: {
    AttributionButton: JY,
    AttributionContent: nX
  },
  computed: {
    ...ee("plugin/attributions", ["renderType", "windowIsOpen"])
  }
});
var rX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.renderType === "independent" ? n("div", { staticClass: "polar-plugin-attributions-wrapper" }, [t.windowIsOpen ? n("AttributionContent", { staticClass: "mr-2" }) : t._e(), n("AttributionButton")], 1) : n("AttributionContent");
}, sX = [], aX = /* @__PURE__ */ Ce(
  iX,
  rX,
  sX,
  !1,
  null,
  "4419ce0e",
  null,
  null
);
const oX = aX.exports, lX = [
  {
    type: "de",
    resources: {
      plugins: {
        attributions: {
          button: {
            closeTitle: "Quellennachweis ausblenden",
            openTitle: "Quellennachweis einblenden"
          },
          sourceCode: '<span><a href="https://github.com/Dataport/polar" target="_blank">Quellcode</a> lizenziert unter <a href="https://github.com/Dataport/polar/blob/main/LICENSE" target="_blank">EUPL v1.2</a></span>',
          title: "Quellennachweis"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        attributions: {
          button: {
            closeTitle: "Hide Attributions",
            openTitle: "Show Attributions"
          },
          sourceCode: '<span><a href="https://github.com/Dataport/polar" target="_blank">Source code</a> licensed under <a href="https://github.com/Dataport/polar/blob/main/LICENSE" target="_blank">EUPL v1.2</a></span>',
          title: "Attributions"
        }
      }
    }
  }
];
function uX(e, t, n) {
  return hX(
    dX(e, t),
    n
  );
}
function cX(e) {
  const t = [];
  return e.forEach((n) => {
    n.getVisible() && n.get("id") && t.push(n.get("id"));
  }), t;
}
function hX(e, t = []) {
  const n = [];
  return e.forEach((s) => {
    n.push(s.title);
  }), t.forEach((s) => n.push(s)), n.push("plugins.attributions.sourceCode"), n;
}
function dX(e, t) {
  const n = [];
  return t.forEach((s) => {
    e.includes(s.id) && n.push(s);
  }), n;
}
function fX(e) {
  const t = /* @__PURE__ */ new Date();
  return e.replaceAll("{{YEAR}}", t.getFullYear().toString()).replaceAll("{{MONTH}}", `${t.getMonth() + 1}`.padStart(2, "0"));
}
const bg = () => ({
  layer: [],
  attributions: [],
  windowIsOpen: !1
}), pX = {
  namespaced: !0,
  state: bg(),
  actions: {
    setupModule({
      commit: e,
      dispatch: t,
      getters: { listenToChanges: n, renderType: s },
      rootGetters: r
    }) {
      var o, l;
      const { map: i } = r;
      n.forEach(
        (f) => this.watch(
          () => r[f],
          () => t("setLayer"),
          {
            deep: !0
          }
        )
      );
      const a = i.getLayers();
      a.on("add", () => t("setLayer")), a.on("add", () => t("setAttributions")), a.on("change", () => t("setLayer")), t("setLayer"), t("setAttributions"), typeof ((l = (o = r.configuration) == null ? void 0 : o.attributions) == null ? void 0 : l.initiallyOpen) == "boolean" && s === "independent" && e(
        "setWindowIsOpen",
        r.configuration.attributions.initiallyOpen
      );
    },
    setLayer({ rootGetters: { map: e }, commit: t }) {
      t("setLayer", cX(e.getLayers()));
    },
    setAttributions({ rootGetters: { configuration: e }, commit: t }) {
      var n;
      t(
        "setAttributions",
        ((n = e.attributions) == null ? void 0 : n.layerAttributions) === void 0 ? [] : e.attributions.layerAttributions.map((s) => ({
          ...s,
          title: fX(s.title)
        }))
      );
    }
  },
  mutations: {
    ...Or(bg())
  },
  getters: {
    ...Hi(bg()),
    listenToChanges: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.listenToChanges) || [];
    },
    mapInfo: (e, { layer: t, attributions: n, staticAttributions: s }) => uX(t, n, s),
    renderType: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.renderType) || "independent";
    },
    staticAttributions: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.staticAttributions) || [];
    },
    windowWidth: (e, t, n, s) => {
      var r, i;
      return ((i = (r = s.configuration) == null ? void 0 : r.attributions) == null ? void 0 : i.windowWidth) || 500;
    }
  }
}, mX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "attributions",
  plugin: oX,
  language: lX,
  storeModule: pX,
  options: e
}), gX = $t.extend({
  name: "PolarFilter",
  computed: {
    ...ee("plugin/filter", [
      "filterConfiguration",
      "getActiveCategory",
      "getActiveCategoryAll",
      "getActiveTime",
      "getCategories",
      "getTimeConfig",
      "getTimeOptions"
    ]),
    layers() {
      return Object.keys(this.filterConfiguration.layers);
    }
  },
  methods: {
    ...mi("plugin/filter", [
      "toggleCategory",
      "toggleCategoryAll",
      "changeTimeRadio"
    ])
  }
});
var vX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-card", { staticClass: "polar-plugin-filter-wrapper" }, [t._l(t.layers, function(s, r) {
    return [n("v-card-title", { key: `plugin-filter-layer-title-${r}` }, [t._v(" " + t._s(t.$t(`common:plugins.filter.layerName.${s}`)) + " ")]), n("v-divider", { key: `plugin-filter-divider-${r}` }), n("v-expansion-panels", { key: `plugin-filter-accordion-${r}`, attrs: { accordion: "" } }, [t.getCategories(s) ? t._l(t.getCategories(s), function({ targetProperty: i, knownValues: a, selectAll: o }, l) {
      return n("v-expansion-panel", { key: `plugin-filter-panel-${r}-${l}` }, [n("v-expansion-panel-header", [t._v(" " + t._s(t.$t(`common:plugins.filter.category.${s}.title.${i}`)) + " ")]), n("v-expansion-panel-content", [o ? n("v-checkbox", { attrs: { dense: "", "hide-details": "", label: t.$t("common:plugins.filter.category.deselectAll"), indeterminate: t.getActiveCategoryAll({ layerId: s, targetProperty: i }) === "indeterminate", "input-value": t.getActiveCategoryAll({ layerId: s, targetProperty: i }) }, on: { change: function(f) {
        return t.toggleCategoryAll({ layerId: s, targetProperty: i });
      } } }) : t._e(), t._l(a, function(f, d) {
        return n("v-checkbox", { key: `plugin-filter-checkbox-${r}-${l}-${d}`, attrs: { dense: "", "hide-details": "", label: t.$t(
          `common:plugins.filter.category.${s}.${i}.${f}`
        ), "input-value": t.getActiveCategory({
          layerId: s,
          targetProperty: i,
          knownValue: f
        }) }, on: { change: function(u) {
          return t.toggleCategory({ layerId: s, targetProperty: i, knownValue: f });
        } } });
      })], 2)], 1);
    }) : t._e(), t.getTimeConfig(s) ? n("v-expansion-panel", [n("v-expansion-panel-header", { staticClass: "polar-plugin-filter-expansion" }, [t._v(" " + t._s(t.$t("common:plugins.filter.time.header")) + " ")]), n("v-expansion-panel-content", [n("v-radio-group", { attrs: { value: t.getActiveTime({
      layerId: s
    }), dense: "", "hide-details": "" }, on: { change: (i) => t.changeTimeRadio({
      radioId: i,
      layerId: s
    }) } }, [n("v-radio", { attrs: { label: t.$t("common:plugins.filter.time.noRestriction"), value: 0 } }), t._l(t.getTimeOptions(s), function({ label: i, component: a, amount: o, now: l }, f) {
      return [n("v-radio", { key: `plugin-filter-checkbox-${r}-${f}`, attrs: { label: t.$t(i, { count: o }), value: f + 1 } }), a && t.getActiveTime({ layerId: s }) === f + 1 ? n(a, { key: `plugin-filter-checkbox-${r}-${f}-options`, tag: "component", attrs: { "layer-id": s, now: l } }) : t._e()];
    })], 2)], 1)], 1) : t._e()], 2)];
  })], 2)], 1);
}, yX = [], EX = /* @__PURE__ */ Ce(
  gX,
  vX,
  yX,
  !1,
  null,
  "df7d1c22",
  null,
  null
);
const CX = EX.exports, xX = [
  {
    type: "de",
    resources: {
      plugins: {
        filter: {
          category: {
            deselectAll: "Alle an-/abwhlen"
          },
          time: {
            header: "Zeitraum",
            noRestriction: "Keine Einschrnkung",
            last: {
              days_one: "Der letzte Tag",
              days_other: "Die letzten {{ count }} Tage"
            },
            next: {
              days_one: "Der nchste Tag",
              days_other: "Die nchsten {{ count }} Tage"
            },
            chooseTimeFrame: {
              label: "Zeitraum whlen",
              info: "Bitte whlen Sie ein Einzeldatum oder das erste und letzte Datum eines Zeitraums."
            },
            vuetify: {
              aria: {
                nextMonth: "Nchsten Monat auswhlen",
                nextYear: "Nchstes Jahr auswhlen",
                prevMonth: "Vorherigen Monat auswhlen",
                prevYear: "Vorheriges Jahr auswhlen"
              }
            }
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        filter: {
          category: {
            deselectAll: "De-/select all"
          },
          time: {
            header: "Time frame",
            noRestriction: "No restriction",
            last: {
              days_one: "The last day",
              days_other: "The last {{ count }} days"
            },
            next: {
              days_one: "The next day",
              days_other: "The next {{ count }} days"
            },
            chooseTimeFrame: {
              label: "Choose time frame",
              info: "Please choose a singular date or the first and last date of a time frame."
            },
            vuetify: {
              aria: {
                nextMonth: "Choose next month",
                nextYear: "Choose next year",
                prevMonth: "Choose previous month",
                prevYear: "Choose previous year"
              }
            }
          }
        }
      }
    }
  }
], bX = $t.extend({
  name: "PolarFilterChooseTimeFrame",
  props: {
    layerId: {
      type: String,
      required: !0
    },
    now: {
      type: String,
      required: !0,
      validator: function(e) {
        return ["until", "from", void 0].includes(e);
      }
    }
  },
  computed: {
    ...ee("plugin/filter", ["getFreeSelection"]),
    ...ee(["language"]),
    dates: {
      get() {
        return this.getFreeSelection(this.layerId);
      },
      set(e) {
        this.changeFreeSelection({
          freeSelection: e,
          layerId: this.layerId
        });
      }
    },
    minDate() {
      if (this.now === "from")
        return new Date(Date.now()).toISOString().split("T")[0];
    },
    maxDate() {
      if (this.now === "until")
        return new Date(Date.now()).toISOString().split("T")[0];
    }
  },
  methods: {
    ...mi("plugin/filter", ["changeFreeSelection"])
  }
});
var TX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("v-date-picker", { attrs: { range: "", "no-title": "", scrollable: "", elevation: "5", min: t.minDate, max: t.maxDate, "first-day-of-week": 1, locale: t.language, "next-month-aria-label": t.$t("common:plugins.filter.time.vuetify.aria.nextMonth"), "next-year-aria-label": t.$t("common:plugins.filter.time.vuetify.aria.nextYear"), "prev-month-aria-label": t.$t("common:plugins.filter.time.vuetify.aria.prevMonth"), "prev-year-aria-label": t.$t("common:plugins.filter.time.vuetify.aria.prevYear") }, model: { value: t.dates, callback: function(s) {
    t.dates = s;
  }, expression: "dates" } }), n("p", { staticClass: "polar-filter-time-frame-explanation" }, [t._v(" " + t._s(t.$t("common:plugins.filter.time.chooseTimeFrame.info")) + " ")])], 1);
}, OX = [], PX = /* @__PURE__ */ Ce(
  bX,
  TX,
  OX,
  !1,
  null,
  "ebb8f52c",
  null,
  null
);
const SX = PX.exports, jI = new Mn(), MX = (e) => e.getStyle() !== jI, _X = (e, t, n, s) => (e || []).every(
  ({ targetProperty: r }) => t[s][r][n.get(r)]
), IX = (e) => {
  const t = e.slice(0, 2).sort().map((n) => new Date(n));
  return t[1] || (t[1] = t[0]), t;
}, DX = (e, t) => {
  const n = [], s = [], r = [], i = {
    Y: n,
    M: s,
    D: r
  };
  [...t].forEach((o, l) => {
    var f, d;
    return (d = (f = i[o]) == null ? void 0 : f.push) == null ? void 0 : d.call(f, l);
  });
  function a(o) {
    return e[o];
  }
  return new Date(
    Number(n.map(a).join("")),
    Number(s.map(a).join("")) - 1,
    Number(r.map(a).join(""))
  );
}, AX = (e, t, n, s) => {
  if (!t || t[e].radioId === 0)
    return !0;
  const { targetProperty: r, radioId: i, pattern: a } = t[e], o = n[i - 1], l = s.get(r), f = DX(l, a), { type: d, amount: u, unit: c } = o, h = {
    days: 24 * 60 * 60 * 1e3
  }[c || "days"], p = [];
  if (d === "freeSelection") {
    const g = t[e].freeSelection;
    if (g.length === 0)
      return !0;
    [p[0], p[1]] = IX(g);
  } else
    p[d === "last" ? 0 : 1] = new Date(
      // @ts-expect-error | amount is number in last/next case
      Date.now() - u * h
    ), p[d === "last" ? 1 : 0] = new Date(Date.now());
  return p[0].setHours(0, 0, 0, 0), p[1].setHours(24, 0, 0, 0), p[0] <= f && f <= p[1];
}, LX = (e, { category: t, time: n }, s, r, i) => t && !_X(s, t, e, r) ? !1 : !!(n && AX(r, n, i, e)), RX = ({
  map: e,
  layerId: t,
  state: n,
  categories: s,
  timeOptions: r
}) => {
  const i = e.getLayers().getArray().find((a) => a.get("id") === t);
  if (!i)
    throw new Error(
      `Layer ${t} undefined in Filter.utils.updateFeatureVisibility.`
    );
  i.getSource().getFeatures().forEach((a) => {
    const o = LX(
      a,
      n,
      s,
      t,
      r
    ) ? null : jI;
    a.getStyle() !== o && a.setStyle(o);
  });
}, $I = (e, t, n) => {
  if (t.length === 1) {
    $t.set(e, t[0], n);
    return;
  }
  const [s, ...r] = t;
  e[s] || $t.set(e, s, {}), $I(e[s], r, n);
}, BO = (e, t) => e.reduce((n, s) => n && s === t, !0), FO = (e) => (t) => t.amounts.map((n) => ({
  label: `common:plugins.filter.time.${e}.${t.unit || "days"}`,
  component: null,
  amount: n,
  unit: t.unit || "days",
  now: null,
  type: e
})), Tg = () => ({
  category: {},
  time: {}
}), wX = {
  namespaced: !0,
  state: Tg(),
  actions: {
    setupModule({ getters: { filterConfiguration: e }, commit: t }) {
      Object.entries(e.layers).forEach(
        ([n, { categories: s, time: r }]) => {
          if (s && s.forEach(
            ({ targetProperty: i, knownValues: a }) => t("setupState", {
              path: ["category", n, i],
              value: a.reduce((o, l) => (o[l] = !0, o), {})
            })
          ), r) {
            const { targetProperty: i, freeSelection: a, pattern: o } = r;
            t("setupState", {
              path: ["time", n],
              value: {
                targetProperty: i,
                pattern: o || "YYYY-MM-DD",
                radioId: 0,
                freeSelection: a ? [] : null
              }
            });
          }
        }
      );
    },
    toggleCategory({ getters: e, commit: t, dispatch: n }, s) {
      const r = !e.getActiveCategory(s);
      t("setCategory", { ...s, value: r }), n("updateFeatureVisibility", s.layerId);
    },
    toggleCategoryAll({ getters: e, commit: t, dispatch: n }, s) {
      const r = !e.getActiveCategoryAll(s), { layerId: i } = s;
      e.getCategories(i).find(({ targetProperty: a }) => a === s.targetProperty).knownValues.forEach((a) => {
        t("setCategory", { ...s, knownValue: a, value: r });
      }), n("updateFeatureVisibility", s.layerId);
    },
    changeTimeRadio({ commit: e, dispatch: t }, n) {
      e("setTimeRadio", n), t("updateFeatureVisibility", n.layerId);
    },
    changeFreeSelection({ commit: e, dispatch: t }, { layerId: n, freeSelection: s }) {
      e("setFreeSelection", { layerId: n, freeSelection: s }), t("updateFeatureVisibility", n);
    },
    updateFeatureVisibility({ state: e, rootGetters: t, getters: n }, s) {
      RX({
        map: t.map,
        layerId: s,
        categories: n.getCategories(s),
        timeOptions: n.getTimeOptions(s),
        state: JSON.parse(JSON.stringify(e))
      });
    }
  },
  mutations: {
    ...Or(Tg()),
    setCategory(e, {
      layerId: t,
      targetProperty: n,
      knownValue: s,
      value: r
    }) {
      e.category[t][n][s] = r;
    },
    setupState(e, { path: t, value: n }) {
      $I(e, t, n);
    },
    setTimeRadio(e, { layerId: t, radioId: n }) {
      e.time[t].radioId = n;
    },
    setFreeSelection(e, { layerId: t, freeSelection: n }) {
      e.time[t].freeSelection = n;
    }
  },
  getters: {
    ...Hi(Tg()),
    filterConfiguration(e, t, n, s) {
      var r;
      return ((r = s.configuration) == null ? void 0 : r.filter) || { layers: {} };
    },
    getActiveCategory: (e) => ({ layerId: t, targetProperty: n, knownValue: s }) => e.category[t][n][s],
    getActiveCategoryAll: (e) => ({ layerId: t, targetProperty: n }) => {
      const s = Object.values(e.category[t][n]);
      return BO(s, !0) ? !0 : BO(s, !1) ? !1 : "indeterminate";
    },
    getActiveTime: (e) => ({ layerId: t }) => e.time[t].radioId,
    getCategories: (e, t) => (n) => {
      var s;
      return ((s = t.filterConfiguration.layers[n]) == null ? void 0 : s.categories) || [];
    },
    getTimeConfig: (e, { filterConfiguration: t }) => (n) => {
      var s;
      return ((s = t.layers[n]) == null ? void 0 : s.time) || null;
    },
    getTimeOptions: (e, { getTimeConfig: t }) => (n) => {
      const s = t(n);
      return s ? [
        ...(s.last || []).map(FO("last")).flat(1),
        ...(s.next || []).map(FO("next")).flat(1),
        ...s.freeSelection ? [
          {
            label: "common:plugins.filter.time.chooseTimeFrame.label",
            component: SX,
            amount: null,
            unit: s.freeSelection.unit || "days",
            now: s.freeSelection.now,
            type: "freeSelection"
          }
        ] : []
      ] : [];
    },
    getFreeSelection: (e) => (t) => e.time[t].freeSelection
  }
}, VX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "filter",
  plugin: CX,
  language: xX,
  storeModule: wX,
  options: e
}), BX = $t.extend({
  name: "FullscreenPlugin",
  props: {
    isHorizontal: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    ...ee(["hasSmallDisplay", "map"]),
    ...ee("plugin/fullscreen", [
      "isInFullscreen",
      "renderType",
      "targetContainerId"
    ]),
    targetContainer() {
      if (this.targetContainerId.length > 0) {
        if (document.getElementById(this.targetContainerId))
          return document.getElementById(this.targetContainerId);
        console.error(
          `Fullscreen.vue: The given targetContainerId ${this.targetContainerId} does not refer to a valid html element.`
        );
      }
      return this.$root.$el;
    }
  },
  mounted() {
    document.addEventListener("webkitfullscreenchange", this.escapeHandler), document.addEventListener("fullscreenchange", this.escapeHandler);
  },
  methods: {
    ...or("plugin/fullscreen", ["setIsInFullscreen"]),
    /**
     * function that gets fired on changes to the fullscreen mode via the F11 or ESC keys.
     * Sets the state variable accordingly.
     */
    escapeHandler() {
      this.setIsInFullscreen(this.checkForFullscreen());
    },
    /**
     * checks if the browser is in fullscreen
     * @returns true if the fullscreen is activated
     */
    checkForFullscreen() {
      return !!// @ts-expect-error | Error: 'TS2339: Property 'webkitFullscreenElement' does not exist on type 'Element'.'; For information refer to https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API#browser_compatibility
      (document.fullscreenElement || document.webkitFullscreenElement);
    },
    /**
     * Toggles the fullscreen mode
     * As there is currently only support from Chrome, Edge and FireFox for the FullScreen-API
     * without vendor prefix there must be a case distinction.
     */
    toggleFullscreen() {
      this.isInFullscreen ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : (this.targetContainer.requestFullscreen ? this.targetContainer.requestFullscreen() : this.targetContainer.webkitRequestFullscreen && this.targetContainer.webkitRequestFullscreen(), setTimeout(() => this.map.updateSize(), 200)), this.setIsInFullscreen(!this.isInFullscreen);
    }
  }
});
var FX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal, disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: { "ma-2": t.renderType === "independent" }, attrs: { color: "primary", small: "", fab: "" }, on: { click: t.toggleFullscreen } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" " + t._s(t.isInFullscreen ? "fa-compress" : "fa-expand") + " ")])], 1)];
  } }]) }, [n("span", [t._v(t._s(t.isInFullscreen ? t.$t("common:plugins.fullscreen.button.tooltip.deactivate") : t.$t("common:plugins.fullscreen.button.tooltip.activate")))])]);
}, NX = [], jX = /* @__PURE__ */ Ce(
  BX,
  FX,
  NX,
  !1,
  null,
  "45f6b486",
  null,
  null
);
const $X = jX.exports, UX = [
  {
    type: "de",
    resources: {
      plugins: {
        fullscreen: {
          button: {
            tooltip: {
              activate: "Vollbildmodus aktivieren",
              deactivate: "Vollbildmodus deaktivieren"
            }
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        fullscreen: {
          button: {
            tooltip: {
              activate: "Activate fullscreen",
              deactivate: "Deactivate fullscreen"
            }
          }
        }
      }
    }
  }
], Og = () => ({
  isInFullscreen: !1
}), WX = {
  namespaced: !0,
  state: Og(),
  mutations: {
    ...Or(Og())
  },
  getters: {
    ...Hi(Og()),
    renderType: (e, t, n, s) => {
      var r, i;
      return (i = (r = s.configuration) == null ? void 0 : r.fullscreen) != null && i.renderType ? s.configuration.fullscreen.renderType : "independent";
    },
    targetContainerId(e, t, n, s) {
      var r, i, a, o;
      return (i = (r = s.configuration) == null ? void 0 : r.fullscreen) != null && i.targetContainerId ? (o = (a = s.configuration) == null ? void 0 : a.fullscreen) == null ? void 0 : o.targetContainerId : "";
    }
  }
}, zX = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "fullscreen",
  plugin: $X,
  language: UX,
  storeModule: WX,
  options: e
});
function NO(e) {
  return !isNaN(e) && typeof e == "number" && e >= 0;
}
const KX = $t.extend({
  name: "MoveHandle",
  props: {
    minHeight: {
      type: Number,
      default: 0.1,
      validator: NO
    },
    maxHeight: {
      type: Number,
      default: 1,
      validator: NO
    }
  },
  data: () => ({
    handleElement: null,
    initialCursorY: 0,
    isMoving: !1,
    preMoveHandleTop: 0,
    touchDevice: !1,
    timeoutReference: 0
  }),
  computed: {
    moveEventNames() {
      return this.touchDevice ? { move: "touchmove", end: "touchend" } : { move: "mousemove", end: "mouseup" };
    }
  },
  watch: {
    isMoving(e) {
      const { move: t, end: n } = this.moveEventNames;
      if (e) {
        this.handleElement.classList.add("polar-move-handle-is-moving"), document.addEventListener(t, this.onMove), document.addEventListener(n, this.onMoveEnd, { once: !0 });
        return;
      }
      this.handleElement.classList.remove("polar-move-handle-is-moving"), document.removeEventListener(t, this.onMove), document.removeEventListener(n, this.onMoveEnd);
    },
    maxHeight(e, t) {
      e < t && (this.savePreMoveHandleTop(), this.setNewPosition(0));
    }
  },
  mounted() {
    if (this.$el.parentElement) {
      this.handleElement = this.$el.parentElement;
      return;
    }
    console.error(
      "MoveHandle: No parent element used, using MoveHandle container."
    ), this.handleElement = this.$el;
  },
  methods: {
    moveHandle(e) {
      (e === "ArrowUp" || e === "ArrowDown") && (this.savePreMoveHandleTop(), this.setNewPosition(e === "ArrowUp" ? -5 : 5));
    },
    onMouseDown(e) {
      this.touchDevice = !1, this.startMoving(e);
    },
    onMove(e) {
      const t = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, n = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY, s = n - this.initialCursorY;
      (t < 0 || t > window.innerWidth || n < 0 || n > window.innerHeight) && (this.isMoving = !1), this.setNewPosition(s);
    },
    onMoveEnd() {
      this.isMoving = !1;
    },
    onTouchStart(e) {
      this.touchDevice = !0, this.startMoving(e);
    },
    saveInitialCursorCoordinates(e) {
      this.initialCursorY = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;
    },
    savePreMoveHandleTop() {
      this.preMoveHandleTop = this.handleElement.offsetTop;
    },
    setNewPosition(e) {
      const t = this.$root.$el.clientHeight;
      let n = Math.round(this.preMoveHandleTop + e);
      t - n < t * this.minHeight && (n = t - t * this.minHeight), t - n > t * this.maxHeight && (n = t - t * this.maxHeight), this.handleElement.style.top = n + "px";
    },
    startMoving(e) {
      this.saveInitialCursorCoordinates(e), this.savePreMoveHandleTop(), this.isMoving = !0;
    }
  }
});
var GX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { staticClass: "polar-move-handle", attrs: { tabindex: "0" }, on: { focus: function(s) {
    return t.moveHandle(s.key);
  }, keydown: function(s) {
    return t.moveHandle(s.key);
  }, mousedown: function(s) {
    return s.stopPropagation(), t.onMouseDown.apply(null, arguments);
  }, touchstart: function(s) {
    return s.stopPropagation(), t.onTouchStart.apply(null, arguments);
  } } }, [t._t("default")], 2);
}, kX = [], HX = /* @__PURE__ */ Ce(
  KX,
  GX,
  kX,
  !1,
  null,
  "979c5207",
  null,
  null
);
const YX = HX.exports, XX = $t.extend({
  name: "GfiFeatureSwitchButtons",
  computed: {
    ...ee("plugin/gfi", [
      "windowFeatures",
      "visibleWindowFeatureIndex"
    ])
  },
  methods: {
    ...or("plugin/gfi", ["setVisibleWindowFeatureIndex"]),
    /** switch to next or previous feature */
    switchFeature(e) {
      const {
        visibleWindowFeatureIndex: t,
        windowFeatures: n,
        setVisibleWindowFeatureIndex: s
      } = this, r = n.length - 1, i = t + e;
      if (i < 0) {
        s(n.length - 1);
        return;
      }
      if (i > r) {
        s(0);
        return;
      }
      s(i);
    }
  }
});
var ZX = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-gfi-switch-buttons" } }, [n("v-btn", { staticClass: "ma-2", attrs: { elevation: "2", fab: "", "x-small": "", "aria-label": t.$t("common:plugins.gfi.switch.previous") }, on: { click: function(s) {
    return t.switchFeature(-1);
  } } }, [n("v-icon", [t._v("fa-chevron-left")])], 1), n("v-btn", { staticClass: "ma-2", attrs: { elevation: "2", fab: "", "x-small": "", "aria-label": t.$t("common:plugins.gfi.switch.next") }, on: { click: function(s) {
    return t.switchFeature(1);
  } } }, [n("v-icon", [t._v("fa-chevron-right")])], 1)], 1);
}, JX = [], QX = /* @__PURE__ */ Ce(
  XX,
  ZX,
  JX,
  !1,
  null,
  "1d5ed60d",
  null,
  null
);
const qX = QX.exports, tZ = $t.extend({
  name: "GfiFeatureButtonGroup",
  components: {
    FeatureSwitchButtons: qX
  },
  props: {
    exportProperty: {
      type: String,
      default: ""
    },
    showSwitchButtons: {
      type: Boolean,
      default: !1
    }
  }
});
var eZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", { attrs: { id: "polar-plugin-gfi-button-group" } }, [n("div", [t.exportProperty ? n("v-btn", { staticClass: "ma-2 text-none reticent-button primaryContrast--text", attrs: { id: "polar-plugin-gfi-export-link", elevation: "2", color: "primary", href: t.exportProperty, target: "_blank", title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.export"), onmousedown: "return false" } }, [t._v(" " + t._s(t.$t("common:plugins.gfi.property.export")) + " ")]) : t._e()], 1), t.showSwitchButtons ? n("FeatureSwitchButtons") : t._e()], 1);
}, nZ = [], iZ = /* @__PURE__ */ Ce(
  tZ,
  eZ,
  nZ,
  !1,
  null,
  "e9a5fdc2",
  null,
  null
);
const rZ = iZ.exports;
function sZ(e) {
  let t;
  try {
    t = new URL(e);
  } catch {
    return !1;
  }
  return t.protocol === "http:" || t.protocol === "https:";
}
const aZ = $t.extend({
  name: "GfiFeatureTableBody",
  props: {
    currentProperties: {
      type: Object,
      required: !0
    },
    photoHeight: {
      type: Number,
      default: 250
    }
  },
  computed: {
    /** Removes polarInternalLayerKey as it shouldn't be displayed to the user. */
    filteredProperties() {
      return this.currentProperties ? Object.fromEntries(
        Object.entries(this.currentProperties).filter(
          ([e]) => e !== "polarInternalLayerKey"
        )
      ) : {};
    }
  },
  methods: {
    isValidHttpUrl: sZ
  }
});
var oZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("tbody", t._l(Object.entries(t.filteredProperties), function([s, r]) {
    return n("tr", { key: s }, [n("td", [t._v(t._s(s))]), r.match(/\.(jpeg|jpg|gif|png)$/) !== null ? n("td", [n("a", { attrs: { href: r, target: "_blank" } }, [n("img", { attrs: { src: r, alt: t.$t("common:plugins.gfi.property.imageAlt"), title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.linkTitle"), height: t.photoHeight < 200 ? 200 : t.photoHeight, width: "auto" } })])]) : t.isValidHttpUrl(r) ? n("td", [n("a", { attrs: { href: r, target: "_blank", title: t.$t("common:plugins.gfi.property.linkTitle"), "aria-label": t.$t("common:plugins.gfi.property.linkTitle") } }, [t._v(" " + t._s("Link") + " ")])]) : n("td", [t._v(" " + t._s(r) + " ")])]);
  }), 0);
}, lZ = [], uZ = /* @__PURE__ */ Ce(
  aZ,
  oZ,
  lZ,
  !1,
  null,
  "c316fd15",
  null,
  null
);
const cZ = uZ.exports, hZ = $t.extend({
  name: "GfiFeatureTableHead"
});
var dZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("thead", [n("tr", [n("th", { staticClass: "text-left" }, [t._v(t._s(t.$t("common:plugins.gfi.header.field")))]), n("th", { staticClass: "text-left" }, [t._v(t._s(t.$t("common:plugins.gfi.header.value")))])])]);
}, fZ = [], pZ = /* @__PURE__ */ Ce(
  hZ,
  dZ,
  fZ,
  !1,
  null,
  "c79d5a23",
  null,
  null
);
const mZ = pZ.exports, gZ = $t.extend({
  name: "GfiFeature",
  components: {
    FeatureButtonGroup: rZ,
    FeatureTableBody: cZ,
    FeatureTableHead: mZ
  },
  props: {
    currentProperties: {
      type: Object,
      required: !0
    },
    clientWidth: {
      type: Number,
      required: !0
    },
    exportProperty: {
      type: String,
      default: ""
    },
    showSwitchButtons: {
      type: Boolean,
      default: !1
    }
  },
  data: () => ({ closeLabel: "common:plugins.gfi.header.close" }),
  computed: {
    ...ee(["hasSmallWidth", "hasWindowSize"]),
    photoHeight() {
      return this.clientWidth * 0.15;
    }
  },
  methods: {
    ...mi("plugin/gfi", ["close"])
  }
});
var vZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("div", [n("div", { staticClass: "polar-plugin-gfi-button-container" }, [t.hasWindowSize && t.hasSmallWidth ? n("v-icon", { attrs: { id: "polar-plugin-gfi-grip-icon" } }, [t._v(" fa-grip-lines ")]) : t._e(), n("v-btn", { attrs: { id: "polar-plugin-gfi-close-button", icon: "", small: "", "aria-label": t.$t(t.closeLabel) }, on: { click: t.close } }, [n("v-icon", [t._v("fa-xmark")])], 1)], 1), n("v-simple-table", { staticClass: "polar-edgy-table", attrs: { dense: "" }, scopedSlots: t._u([{ key: "default", fn: function() {
    return [n("FeatureTableHead"), n("FeatureTableBody", { attrs: { "current-properties": t.currentProperties, "photo-height": t.photoHeight } })];
  }, proxy: !0 }]) }), t.exportProperty || t.showSwitchButtons ? n("FeatureButtonGroup", { attrs: { "export-property": t.exportProperty, "show-switch-buttons": t.showSwitchButtons } }) : t._e()], 1);
}, yZ = [], EZ = /* @__PURE__ */ Ce(
  gZ,
  vZ,
  yZ,
  !1,
  null,
  "61a3f521",
  null,
  null
);
const CZ = EZ.exports, xZ = $t.extend({
  name: "GfiList",
  computed: {
    ...ee("plugin/gfi", [
      "listFeatures",
      "listText",
      "page",
      "gfiConfiguration"
    ]),
    _page: {
      get() {
        return this.page + 1;
      },
      set(e) {
        this.setPage(e - 1);
      }
    },
    pageLength() {
      return this.gfiConfiguration.featureList.pageLength || Number.MAX_SAFE_INTEGER;
    },
    maxPage() {
      return Math.ceil(this.listFeatures.length / this.pageLength);
    },
    visibleListFeatures() {
      return this.listFeatures.slice(
        (this._page - 1) * this.pageLength,
        this._page * this.pageLength
      );
    }
  },
  watch: {
    maxPage: function(e) {
      this._page > e && (this._page = Math.max(e, 1));
    }
  },
  methods: {
    ...mi("plugin/gfi", ["setOlFeatureInformation", "setPage"]),
    ...or("plugin/gfi", ["setPage"]),
    applyListText(e, t) {
      const n = this.listText[t];
      return n === void 0 ? (console.error(
        "Missing text entry in GFI configuration. See documentation of gfi.featureList.text for more information. Fallback to ol_uid."
      ), e.ol_uid) : typeof n == "string" ? e.get(n) : n(e);
    }
  }
});
var bZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-scroll-x-reverse-transition", [n("v-card", { staticClass: "plugin-gfi-list" }, [n("v-card-title", [n("v-icon", [t._v("fa-list")]), t._v(" " + t._s(t.$t("common:plugins.gfi.list.header")) + " ")], 1), t.maxPage > 1 ? n("v-card-subtitle", [t._v(" " + t._s(`${t.$t("common:plugins.gfi.list.entry")} ${t.page * t.pageLength + 1} ${t.$t("common:plugins.gfi.list.to")} ${Math.min((t.page + 1) * t.pageLength, t.listFeatures.length)} ${t.$t("common:plugins.gfi.list.of")} ${t.listFeatures.length}`) + " "), n("v-pagination", { attrs: { color: "primary", length: t.maxPage, "current-page-aria-label": t.$t("common:plugins.gfi.list.pagination.currentPage", {
    page: t._page,
    maxPage: t.maxPage
  }), "page-aria-label": t.$t("common:plugins.gfi.list.pagination.page", {
    page: t._page,
    maxPage: t.maxPage
  }), "next-aria-label": t.$t("common:plugins.gfi.list.pagination.next"), "previous-aria-label": t.$t("common:plugins.gfi.list.pagination.previous"), "wrapper-aria-label": t.$t("common:plugins.gfi.list.pagination.wrapper") }, model: { value: t._page, callback: function(s) {
    t._page = s;
  }, expression: "_page" } })], 1) : t._e(), n("v-list", [t.visibleListFeatures.length ? t._e() : n("v-list-item", [t._v(" " + t._s(t.$t("common:plugins.gfi.list.emptyView")) + " ")]), t._l(t.visibleListFeatures, function(s) {
    return n("v-list-item", { key: `gfi-feature-list-${s.ol_uid}`, attrs: { "two-line": t.listText.length === 2, "three-line": t.listText.length === 3 }, on: { click: function(r) {
      return t.setOlFeatureInformation(s);
    } } }, [n("v-list-item-content", t._l(t.listText, function(r, i) {
      return n(i === 0 ? "v-list-item-title" : "v-list-item-subtitle", { key: `gfi-feature-list-${s.ol_uid}-${i}`, tag: "component" }, [t._v(" " + t._s(t.$t(t.applyListText(s, i))) + " ")]);
    }), 1)], 1);
  })], 2)], 1)], 1);
}, TZ = [], OZ = /* @__PURE__ */ Ce(
  xZ,
  bZ,
  TZ,
  !1,
  null,
  "32c8f053",
  null,
  null
);
const PZ = OZ.exports, SZ = $t.extend({
  name: "GfiPlugin",
  components: {
    MoveHandle: YX
  },
  data: () => ({ clientWidth: 0, maxMobileHeight: 1 }),
  computed: {
    ...ee(["hasSmallWidth", "hasWindowSize"]),
    ...ee("plugin/gfi", [
      "exportPropertyLayerKeys",
      "windowFeatures",
      "windowLayerKeysActive",
      "visibleWindowFeatureIndex",
      "gfiContentComponent",
      "showList"
    ]),
    contentComponent() {
      return this.showList ? PZ : this.gfiContentComponent || CZ;
    },
    contentProps() {
      return this.showList ? {} : {
        currentProperties: this.currentProperties,
        clientWidth: this.clientWidth,
        exportProperty: this.exportProperty,
        showSwitchButtons: this.showSwitchButtons
      };
    },
    currentProperties() {
      const e = {
        ...this.windowFeatures[this.visibleWindowFeatureIndex]
      }, t = this.exportPropertyLayerKeys[e.polarInternalLayerKey];
      return (t == null ? void 0 : t.length) > 0 && delete e[t], e;
    },
    exportProperty() {
      if (this.currentProperties) {
        const e = this.exportPropertyLayerKeys[this.currentProperties.polarInternalLayerKey];
        return e.length > 0 ? this.windowFeatures[this.visibleWindowFeatureIndex][e] : "";
      }
      return "";
    },
    renderUi() {
      return this.windowFeatures.length > 0 || this.showList;
    },
    renderMoveHandle() {
      return this.hasWindowSize && this.hasSmallWidth;
    },
    /** only show switch buttons if multiple property sets are available */
    showSwitchButtons() {
      return this.windowFeatures.length > 1;
    }
  },
  mounted() {
    window.addEventListener("resize", () => {
      this.updateClientWidth(), this.updateMaxMobileHeight();
    }), this.updateClientWidth();
  },
  updated() {
    this.$nextTick(this.updateMaxMobileHeight);
  },
  methods: {
    updateClientWidth() {
      this.clientWidth = this.$root.$el.clientWidth;
    },
    updateMaxMobileHeight() {
      this.$el.clientHeight && (this.maxMobileHeight = this.$el.clientHeight / this.$root.$el.clientHeight);
    }
  }
});
var MZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.renderUi ? n("div", { class: {
    "polar-plugin-gfi-move-handle": t.renderMoveHandle,
    "polar-plugin-gfi-fullscreen": t.hasWindowSize
  }, attrs: { id: "polar-plugin-gfi" } }, [t.windowLayerKeysActive ? t.renderMoveHandle ? n("MoveHandle", { attrs: { "min-height": 0.1, "max-height": t.maxMobileHeight } }, [n(t.contentComponent, t._b({ tag: "component" }, "component", t.contentProps, !1))], 1) : n(t.contentComponent, t._b({ tag: "component" }, "component", t.contentProps, !1)) : n("v-card", [n("v-card-text", [t._v(t._s(t.$t("common:plugins.gfi.noActiveLayer")))])], 1)], 1) : t._e();
}, _Z = [], IZ = /* @__PURE__ */ Ce(
  SZ,
  MZ,
  _Z,
  !1,
  null,
  "544dcfa7",
  null,
  null
);
const DZ = IZ.exports, AZ = [
  {
    type: "de",
    resources: {
      plugins: {
        gfi: {
          header: {
            close: "Informationsfenster schlieen",
            field: "Feld",
            value: "Wert"
          },
          property: {
            export: "Export als PDF",
            imageAlt: "Bitte entnehmen Sie Informationen zum Inhalt des Bildes aus den umliegenden Tabellenfeldern",
            linkTitle: "In neuem Tab ffnen"
          },
          switch: {
            previous: "Vorangehender Datensatz",
            next: "Nchster Datensatz"
          },
          noActiveLayer: "Derzeit ist kein Kartenmaterial mit passenden Objekten eingeschaltet.",
          list: {
            header: "Objektliste",
            entry: "Eintrag",
            to: "bis",
            of: "von",
            emptyView: "Im aktuellen Kartenausschnitt sind keine Objekte enthalten.",
            pagination: {
              currentPage: "Aktuelle Seite, Seite {{page}}",
              page: "Seite {{page}}",
              next: "Nchste Seite",
              previous: "Vorherige Seite",
              wrapper: "Seitenauswahl"
            }
          }
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        gfi: {
          header: {
            close: "Close information window",
            field: "Field",
            value: "Value"
          },
          property: {
            export: "Export as a PDF document",
            imageAlt: "Please refer to the other table fields for further information about the topics of the displayed picture",
            link: "Open in a new tab"
          },
          switch: {
            previous: "Previous data",
            next: "Next data"
          },
          noActiveLayer: "Currently, no map layer with fitting objects is active.",
          list: {
            header: "Feature list",
            entry: "Entry",
            to: "to",
            of: "of",
            emptyView: "There are no features in the current view.",
            pagination: {
              currentPage: "Current page, page {{page}}",
              page: "Page {{page}}",
              next: "Next page",
              previous: "Previous page",
              wrapper: "Pagination"
            }
          }
        }
      }
    }
  }
], AE = () => ({
  featureInformation: {},
  visibleWindowFeatureIndex: 0,
  visibilityChangeIndicator: 0,
  defaultHighlightStyle: {
    stroke: {
      color: "#003064",
      width: 3
    },
    fill: {
      color: "rgb(255, 255, 255, 0.7)"
    }
  },
  page: 0
}), LZ = new Wr(), lu = new sr({
  source: new Ur({
    features: []
  })
});
lu.set("polarInternalId", "pluginGfiFeatureDisplay");
lu.setZIndex(90);
function UI(e) {
  return e instanceof Ur;
}
function od() {
  const e = lu.getSource();
  UI(e) && e.clear();
}
function RZ(e) {
  const t = lu.getSource();
  UI(t) && t.addFeature(LZ.readFeature(e));
}
const jO = {
  GML: mS,
  GML2: el,
  GML3: se,
  GML32: Jc
};
function wZ(e) {
  const t = e.split(`
`), n = [];
  let s;
  for (const r of t)
    if (!(r === "" || r.startsWith("GetFeatureInfo results") || r.startsWith("Layer"))) {
      if (r.startsWith("    ")) {
        if (typeof s < "u") {
          const i = r.indexOf("="), [a, o] = [
            r.substring(0, i),
            r.substring(i + 3, r.length - 1)
          ].map((l) => l.trim());
          s.set(a, o);
        } else
          console.error(
            "Found property before feature declaration in readTextFeatures.",
            r,
            "Skipping ..."
          );
        continue;
      }
      if (r.startsWith("  ")) {
        if (r.includes("Search returned no results"))
          break;
        const i = r.substring(0, r.length - 2).trim();
        s = new Pi(), s.setId(i), n.push(s);
      }
    }
  return n;
}
function VZ(e) {
  const t = e.includes('xmlns:gml="http://www.opengis.net/gml/3.2"') ? Jc : e.includes('xmlns:gml="http://www.opengis.net/gml"') ? mS : e.includes('xmlns:gml="http://www.opengis.net/gml/2') ? el : se;
  return new Qc({
    gmlFormat: new t()
  });
}
function BZ(e) {
  if (jO[e])
    return new Qc({
      gmlFormat: new jO[e]()
    });
  if (e === "text")
    return {
      readFeatures: wZ
    };
  throw new Error(`Format '${e}' not yet implemented in requestGfiWms.ts.`);
}
function FZ({
  map: e,
  layer: t,
  coordinate: n
}, { infoFormat: s }) {
  const r = t.getSource(), i = e.getView(), a = r.getFeatureInfoUrl(
    n,
    i.getResolution(),
    i.getProjection(),
    {
      feature_count: 10
    }
  ), o = s ? `&info_format=${s}` : "";
  return a + o;
}
const NZ = (e) => {
  const { coordinate: t, layerConfiguration: n, layerSpecification: s } = e, { filterBy: r, geometryName: i, format: a } = n, o = FZ(e, s);
  return fetch(o).then((l) => l.text()).then((l) => {
    const d = (s.infoFormat === "application/geojson" ? new Wr() : a ? BZ(a) : VZ(l)).readFeatures(l), u = new Wr();
    return i && d.forEach((h) => h.setGeometryName("geometry")), d.filter(
      (h) => {
        var p;
        return r === "clickPosition" ? (p = h.getGeometry()) == null ? void 0 : p.intersectsCoordinate(t) : !0;
      }
    ).map((h) => JSON.parse(u.writeFeature(h)));
  }).catch((l) => Promise.reject(l));
}, jZ = (e, t) => {
  const n = new Qc({ version: t }), s = new Wr();
  return n.readFeatures(e).map(
    (a) => JSON.parse(s.writeFeature(a))
  );
}, $Z = ({
  map: e,
  coordinate: t,
  layerConfiguration: n,
  layerSpecification: s,
  mode: r
}) => {
  const { featureType: i, url: a, version: o } = s, { geometryName: l } = n, f = e.getView().getProjection().getCode();
  let u = `${a}?service=WFS&version=${o}&request=GetFeature&${o === "2.0.0" ? "typeNames" : "typename"}=${i}&srsName=${f}`;
  if (r === "bboxDot")
    u += `&bbox=${[
      [t[0] - 0.1, t[1] - 0.1],
      [t[0] + 0.1, t[1] + 0.1]
    ]},${f}`;
  else if (r === "intersects") {
    const c = `<gml:Point srsName="${f}"><gml:coordinates>${t[0]},${t[1]}</gml:coordinates></gml:Point>`;
    u += "&FILTER=" + // NOTE: fes as a namespace and ValueReference for a property has been introduced in 2.0.0
    (o === "2.0.0" ? `<fes:Filter><fes:Intersects><fes:ValueReference>${l}</fes:ValueReference>` + c + "</fes:Intersects></fes:Filter>" : `<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"><ogc:Intersects><ogc:PropertyName>${l}</ogc:PropertyName>` + c + "</fes:Intersects></fes:Filter>");
  } else
    return Promise.reject(
      new Error(
        `Type error in requestGfiWfs.ts: mode must be "intersects" or "bboxDot", but was "${r}".`
      )
    );
  return fetch(u, { method: "GET" }).then((c) => c.text()).then((c) => jZ(c, o));
}, UZ = new Wr(), WZ = ({
  map: e,
  coordinate: t,
  layer: n
}) => Promise.resolve(
  e.getFeaturesAtPixel(e.getPixelFromCoordinate(t), {
    layerFilter: (s) => s === n
  }).map(
    (s) => s instanceof Pi ? JSON.parse(UZ.writeFeature(s)) : !1
  ).filter((s) => s)
);
function zZ({
  map: e,
  layer: t,
  coordinate: n,
  layerConfiguration: s,
  layerSpecification: r,
  mode: i
}) {
  var a;
  try {
    const o = { map: e, coordinate: n, layerConfiguration: s, layerSpecification: r };
    return t instanceof Zc ? NZ({ ...o, layer: t }) : ((a = ea({ id: t.get("id") })) == null ? void 0 : a.typ) === "GeoJSON" ? WZ({ ...o, layer: t }) : t instanceof sr ? $Z({ ...o, mode: i }) : Promise.reject(
      new Error(
        `Layer ${t.get(
          "id"
        )} was neither a Tile- nor a VectorLayer. GFI not implemented.`
      )
    );
  } catch {
    return Promise.reject(
      new Error(
        `An error occurred while requesting features from layer with the id ${t.get(
          "id"
        )}.`
      )
    );
  }
}
function KZ(e, t, n) {
  const s = new Wr({
    dataProjection: n,
    featureProjection: n
  }), r = s.readGeometry(e.geometry), i = s.readGeometry(t.geometry), a = r instanceof rr || r instanceof ia, o = i instanceof rr || i instanceof ia;
  if (a && o)
    return i.getArea() - r.getArea();
  if (a)
    return -1;
  if (o)
    return 1;
  const l = r instanceof er || r instanceof na, f = i instanceof er || i instanceof na;
  return l && f ? 0 : l ? -1 : f ? 1 : 0;
}
const GZ = new Wr();
let $O;
const kZ = {
  /**
   * Responsible for setting up the module by
   * - adding watchers to configured coordinate sources. Whenever one of these
   *   sources changes, the module is reset and all information is fetched
   *   anew.
   * - adding the geometry display layer to the map.
   */
  setupModule({
    getters: { gfiConfiguration: e, defaultHighlightStyle: t },
    rootGetters: n,
    dispatch: s
  }) {
    const { coordinateSources: r, customHighlightStyle: i } = e, { map: a } = n, o = (l) => {
      od(), l && l.length && s("getFeatureInfo", l);
    };
    r.forEach(
      (l) => this.watch(() => n[l], o)
    ), a.addLayer(lu), lu.setStyle(
      new Mn({
        stroke: new vr(
          (i == null ? void 0 : i.stroke) || t.stroke
        ),
        fill: new wr(
          (i == null ? void 0 : i.fill) || t.fill
        )
      })
    ), s("setupTooltip"), s("setupFeatureVisibilityUpdates");
  },
  setupTooltip({ getters: { gfiConfiguration: e }, rootGetters: { map: t } }) {
    const n = Object.keys(e.layers).filter(
      (a) => e.layers[a].showTooltip
    );
    if (!n.length)
      return;
    let s, r;
    const i = new ky({
      positioning: "bottom-center",
      offset: [0, -5]
    });
    t.addOverlay(i), t.on("pointermove", ({ pixel: a, dragging: o }) => {
      if (o)
        return;
      let l = !1;
      t.forEachFeatureAtPixel(
        a,
        (f, d) => f instanceof Pi ? (l = !0, i.setPosition(t.getCoordinateFromPixel(a)), r && r(), { element: s, unregister: r } = NI({
          localeKeys: (
            // @ts-expect-error | it exists by virtue of layerFilter below
            e.layers[d.get("id")].showTooltip(f)
          )
        }), i.setElement(s), !0) : !1,
        {
          layerFilter: (f) => n.includes(f.get("id"))
        }
      ), l || i.setPosition(void 0);
    });
  },
  setupFeatureVisibilityUpdates({ commit: e, state: t, getters: n, rootGetters: s }) {
    $O = Hv(
      () => e(
        "setVisibilityChangeIndicator",
        t.visibilityChangeIndicator + 1
      ),
      10
    );
    const r = Object.keys(n.gfiConfiguration.layers);
    s.map.getLayers().getArray().forEach((i) => {
      r.includes(i.get("id")) && i.getSource().on("changefeature", $O);
    });
  },
  close({ commit: e, dispatch: t }) {
    e("clearFeatureInformation"), t("plugin/pins/removeMarker", null, { root: !0 }), od();
  },
  /**
   * Action getFeatureInfo
   * 1. resets the module state
   * 2. fetches new feature information for each configured layer
   * 3. adds features to the display layer optionally (if configured)
   */
  async getFeatureInfo({ commit: e, dispatch: t }, n) {
    return e("clearFeatureInformation"), e("setVisibleWindowFeatureIndex", 0), od(), await t("debouncedGfiRequest", n);
  },
  /**
   * Code from `getFeatureInfo`, pulled to avoid overly requesting feature
   * information. Since sources in Pins plugin update right after each other
   * (and such effects are to be expected across the system), we're debouncing
   * this *after* resetting the module state, as something is bound to happen.
   */
  debouncedGfiRequest: Hv(
    // TODO: Types are not properly displayed here as it is wrapped through debounce
    async ({
      commit: e,
      rootGetters: { map: t, configuration: n },
      getters: { layerKeys: s, geometryLayerKeys: r, afterLoadFunction: i }
    }, a) => {
      const o = s.map(
        (h) => {
          const p = t.getLayers().getArray().find((E) => E.getProperties().id === h);
          if (!p)
            return console.error(
              `No layer with id "${h}" found during run-time. GFI skipped.`
            ), [];
          const g = n.gfi.layers[h] || {}, m = ea({ id: h }), y = n.layers.find(
            (E) => E.id === h
          ).gfiMode || n.gfi.mode || "bboxDot";
          return zZ({
            map: t,
            layer: p,
            coordinate: a,
            layerConfiguration: g,
            layerSpecification: m,
            mode: y
          });
        }
      ), l = (h) => Symbol(h), f = (await Promise.allSettled(o)).map(
        (h) => h.status === "fulfilled" ? h.value : l(h.reason.message)
      ), d = n.gfi.maxFeatures || Number.POSITIVE_INFINITY, u = t.getView().getProjection().getCode();
      let c = s.reduce(
        (h, p, g) => ({
          ...h,
          [p]: Array.isArray(f[g]) ? f[g].slice(
            0,
            n.gfi.layers[p].maxFeatures || d
          ) : f[g]
        }),
        {}
      );
      c = Object.entries(c).reduce(
        (h, [p, g]) => ({
          ...h,
          [p]: Array.isArray(g) && g.length >= 2 ? g.sort((m, v) => KZ(m, v, u)) : g
        }),
        {}
      ), typeof i == "function" && (c = await i(c, u)), e("setFeatureInformation", c), r.filter((h) => Array.isArray(c[h])).forEach((h) => c[h].forEach(RZ));
    },
    50
  ),
  setOlFeatureInformation({ commit: e }, t) {
    e("clearFeatureInformation"), e("setVisibleWindowFeatureIndex", 0), od(), e("setFeatureInformation", {
      [t.get("_gfiLayerId")]: [JSON.parse(GZ.writeFeature(t))]
    });
  }
}, HZ = {
  ...Or(AE()),
  clearFeatureInformation(e) {
    e.featureInformation = {};
  }
}, YZ = {
  ...Hi(AE()),
  gfiConfiguration(e, t, n, s) {
    var r;
    return ((r = s.configuration) == null ? void 0 : r.gfi) || {
      afterLoadFunction: null,
      coordinateSources: [],
      layers: {}
    };
  },
  gfiContentComponent(e, { gfiConfiguration: t }) {
    return t.gfiContentComponent || null;
  },
  afterLoadFunction(e, { gfiConfiguration: t }) {
    return typeof (t == null ? void 0 : t.afterLoadFunction) == "function" ? t.afterLoadFunction : null;
  },
  layerKeys(e, { gfiConfiguration: t }) {
    return Object.keys((t == null ? void 0 : t.layers) || {});
  },
  exportPropertyLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { exportProperty: r }]) => ({
        ...n,
        [s]: typeof r == "string" ? r : ""
      }),
      {}
    );
  },
  windowLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { window: r }]) => r ? [...n, s] : n,
      []
    );
  },
  windowLayerKeysActive(e, { windowLayerKeys: t, gfiConfiguration: n }, s, r) {
    const { activeLayerPath: i } = n;
    return i ? (Vl(r[i]), !!r.map.getLayers().getArray().filter(
      (a) => t.includes(a.get("id")) && a.getVisible()
    ).length) : !0;
  },
  geometryLayerKeys(e, { gfiConfiguration: t }) {
    return Object.entries((t == null ? void 0 : t.layers) || {}).reduce(
      (n, [s, { geometry: r }]) => r ? [...n, s] : n,
      []
    );
  },
  windowFeatures(e, { featureInformation: t, windowLayerKeys: n, gfiConfiguration: s }) {
    return Object.entries(t).map(
      ([r, i]) => (
        /*
          NOTE: When displaying the features in the map, the first feature is rendered first
            thus lying under every other following feature. However, when using the gfi window,
            the first feature is initially displayed in the window.
            To have both in line, the feature displayed on top, the order of the features is reversed here for the window.
         */
        n.includes(r) && Array.isArray(i) ? i.reverse().map(({ properties: a }) => {
          const o = { polarInternalLayerKey: r }, l = s.layers[r].properties;
          if (Array.isArray(l))
            return {
              ...Object.fromEntries(
                Object.entries(a || {}).filter(
                  ([f]) => l.includes(f)
                )
              ),
              ...o
            };
          if (typeof l == "object") {
            const f = Object.keys(l);
            return {
              ...Object.fromEntries(
                Object.entries(a || {}).filter(([d]) => f.includes(d)).map(([d, u]) => [l[d], u])
              ),
              ...o
            };
          }
          return { ...a, ...o };
        }) : []
      )
    ).flat(1);
  },
  listMode(e, { gfiConfiguration: t }) {
    var n;
    return t.featureList && !t.featureList.mode && console.error(
      "POLAR: When using featureList in GFI plugin, a mode must be chosen."
    ), (n = t.featureList) == null ? void 0 : n.mode;
  },
  listText(e, { gfiConfiguration: t }) {
    var n;
    return ((n = t.featureList) == null ? void 0 : n.text) || [];
  },
  showList(e, { windowFeatures: t, gfiConfiguration: n }) {
    return !!(n.featureList && !t.length);
  },
  listFeatures({ visibilityChangeIndicator: e }, { listMode: t, layerKeys: n }, s, r) {
    const { map: i, clientHeight: a, clientWidth: o, center: l, zoomLevel: f } = r;
    return i.getLayers().getArray().filter((d) => n.includes(d.get("id"))).filter(
      (d) => d instanceof sr || console.warn(
        `Layer ${d.get(
          "id"
        )} in GFI plugin will not produce list results since it is not a vector layer.`
      )
    ).map((d) => {
      const u = d.getSource();
      return (t === "loaded" ? u.getFeatures() : u.getFeaturesInExtent(
        i.getView().calculateExtent(i.getSize()),
        i.getView().getProjection()
      )).filter(MX).map((c) => (c.set("_gfiLayerId", d.get("id")), c));
    }).flat(1);
  }
}, XZ = {
  namespaced: !0,
  state: AE(),
  actions: kZ,
  mutations: HZ,
  getters: YZ
}, ZZ = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "gfi",
  plugin: DZ,
  language: AZ,
  storeModule: XZ,
  options: e
}), JZ = $t.extend({
  name: "LayerChooserOptions",
  props: {
    maxWidth: {
      type: Number,
      required: !0
    }
  },
  computed: {
    ...ee(["clientWidth"]),
    ...ee("plugin/layerChooser", [
      "openedOptionsService",
      "openedOptionsServiceLayers",
      "activeLayerIds"
    ]),
    activeLayers: {
      get() {
        return this.activeLayerIds[this.openedOptionsService.id];
      },
      set(e) {
        this.toggleOpenedOptionsServiceLayer(e);
      }
    },
    cardActionStyle() {
      return this.clientWidth === this.maxWidth ? "" : `
        width: ${this.maxWidth}px;
        white-space: normal;
      `;
    }
  },
  methods: {
    ...or("plugin/layerChooser", ["setOpenedOptions"]),
    ...mi("plugin/layerChooser", ["toggleOpenedOptionsServiceLayer"])
  }
});
var QZ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-card", { staticClass: "layer-chooser-options", attrs: { "max-width": t.maxWidth } }, [n("v-card-actions", { style: t.cardActionStyle }, [n("v-btn", { attrs: { icon: "", small: "", "aria-label": t.$t("common:plugins.layerChooser.returnToLayers") }, on: { click: function(s) {
    return t.setOpenedOptions(null);
  } } }, [n("v-icon", { attrs: { small: "" } }, [t._v("fa-chevron-left")])], 1), n("v-card-title", { staticClass: "layer-chooser-options-card-title" }, [t._v(t._s(t.$t("common:plugins.layerChooser.optionsHeader", t.openedOptionsService)))])], 1), t.openedOptionsService.options.layers && t.openedOptionsServiceLayers ? [n("v-card-title", { attrs: { id: "polar-label-options-layer-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.layerHeader")))]), n("v-card-text", [t._l(t.openedOptionsServiceLayers, function({
    layerName: s,
    displayName: r,
    layerImage: i
  }) {
    return [n("v-checkbox", { key: `layer-chooser-layer-option-${s}`, attrs: { label: t.$t(r), value: s, "aria-describedby": "polar-label-options-layer-title", dense: "", "hide-details": "", disabled: t.activeLayers.length === 1 && t.activeLayers.includes(s) }, scopedSlots: t._u([i ? { key: "prepend", fn: function() {
      return [n("img", { attrs: { src: i } })];
    }, proxy: !0 } : null], null, !0), model: { value: t.activeLayers, callback: function(a) {
      t.activeLayers = a;
    }, expression: "activeLayers" } })];
  })], 2)] : t._e()], 2);
}, qZ = [], tJ = /* @__PURE__ */ Ce(
  JZ,
  QZ,
  qZ,
  !1,
  null,
  "b8eec4bb",
  null,
  null
);
const eJ = tJ.exports, nJ = $t.extend({
  name: "LayerChooserLayerWrapper",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabledLayers: {
      type: Array,
      required: !0
    },
    layerId: {
      type: String,
      required: !0
    }
  },
  computed: {
    ...ee(["hasSmallDisplay"]),
    ...ee("plugin/layerChooser", ["idsWithOptions"]),
    hasOptions() {
      return this.idsWithOptions.includes(this.layerId);
    }
  },
  methods: {
    ...or("plugin/layerChooser", ["setOpenedOptions"])
  }
});
var iJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-tooltip", { attrs: { left: "", disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s }) {
    return [n("div", t._g({ staticClass: "polar-layer-chooser-option-line" }, t.disabledLayers[t.index] && s), [t._t("default"), n("v-btn", { staticClass: "ml-1", class: !t.hasOptions && "polar-layer-chooser-option-invisible", attrs: { "aria-label": t.$t("common:plugins.layerChooser.layerOptions"), icon: "", small: "" }, on: { click: function(r) {
      return t.setOpenedOptions(t.layerId);
    } } }, [n("v-icon", { attrs: { small: "" } }, [t._v("fa-gear")])], 1)], 2)];
  } }], null, !0) }, [t._v(" " + t._s(t.$t("common:plugins.layerChooser.tooltipDisabledLayer")) + " ")]);
}, rJ = [], sJ = /* @__PURE__ */ Ce(
  nJ,
  iJ,
  rJ,
  !1,
  null,
  "8387efb8",
  null,
  null
);
const aJ = sJ.exports, oJ = $t.extend({
  name: "LayerChooserSelection",
  components: { LayerWrapper: aJ },
  props: {
    maxWidth: {
      type: Number,
      required: !0
    }
  },
  computed: {
    ...ee("plugin/layerChooser", [
      "activeBackgroundId",
      "activeMaskIds",
      "backgrounds",
      "disabledBackgrounds",
      "disabledMasks",
      "shownMasks"
    ]),
    activeBackground: {
      get() {
        return this.activeBackgroundId;
      },
      set(e) {
        this.setActiveBackgroundId(e);
      }
    },
    activeMasks: {
      get() {
        return this.activeMaskIds;
      },
      set(e) {
        this.setActiveMaskIds(e);
      }
    }
  },
  methods: {
    ...mi("plugin/layerChooser", [
      "setActiveBackgroundId",
      "setActiveMaskIds"
    ])
  }
});
var lJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-card", { staticClass: "layer-chooser-selection", attrs: { "max-width": t.maxWidth } }, [t.backgrounds.length ? n("v-card-title", { attrs: { id: "polar-label-background-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.backgroundTitle")))]) : t._e(), t.backgrounds.length ? n("v-card-text", [n("v-radio-group", { attrs: { dense: "", "hide-details": "" }, model: { value: t.activeBackground, callback: function(s) {
    t.activeBackground = s;
  }, expression: "activeBackground" } }, [t._l(t.backgrounds, function({ name: s, id: r }, i) {
    return [n("LayerWrapper", { key: "disabled-background-" + i, attrs: { index: i, "disabled-layers": t.disabledBackgrounds, "layer-id": r } }, [n("v-radio", { key: i, attrs: { "aria-describedby": "polar-label-background-title", dense: "", "hide-details": "", label: t.$t(s), value: r, disabled: t.disabledBackgrounds[i] } })], 1)];
  })], 2)], 1) : t._e(), t.shownMasks.length ? n("v-card-title", { attrs: { id: "polar-label-mask-title" } }, [t._v(t._s(t.$t("common:plugins.layerChooser.maskTitle")))]) : t._e(), t.shownMasks.length ? n("v-card-text", [t._l(t.shownMasks, function({ name: s, id: r }, i) {
    return [n("LayerWrapper", { key: "disabled-mask-" + i, attrs: { index: i, "disabled-layers": t.disabledMasks, "layer-id": r } }, [n("v-checkbox", { staticClass: "cut-off-top-space", attrs: { label: t.$t(s), value: r, "aria-describedby": "polar-label-mask-title", dense: "", "hide-details": "", disabled: t.disabledMasks[i] }, model: { value: t.activeMasks, callback: function(a) {
      t.activeMasks = a;
    }, expression: "activeMasks" } })], 1)];
  })], 2) : t._e()], 1);
}, uJ = [], cJ = /* @__PURE__ */ Ce(
  oJ,
  lJ,
  uJ,
  !1,
  null,
  "35e295c7",
  null,
  null
);
const hJ = cJ.exports, dJ = $t.extend({
  name: "LayerChooser",
  components: {
    Options: eJ,
    Selection: hJ
  },
  computed: {
    ...ee(["clientWidth", "hasSmallWidth", "hasWindowSize"]),
    ...ee("plugin/layerChooser", ["openedOptions"]),
    displaySelection() {
      return this.openedOptions === null;
    },
    maxWidth() {
      return this.clientWidth * (this.hasWindowSize && this.hasSmallWidth ? 0.75 : 1);
    }
  }
});
var fJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-scroll-x-reverse-transition", [n("div", [t.displaySelection ? n("Selection", { attrs: { "max-width": t.maxWidth } }) : n("Options", { attrs: { "max-width": t.maxWidth } })], 1)]);
}, pJ = [], mJ = /* @__PURE__ */ Ce(
  dJ,
  fJ,
  pJ,
  !1,
  null,
  null,
  null,
  null
);
const gJ = mJ.exports, vJ = [
  {
    type: "de",
    resources: {
      plugins: {
        layerChooser: {
          backgroundTitle: "Hintergrundkarte",
          maskTitle: "Fachdaten",
          tooltipDisabledLayer: "Auf der aktuellen Zoomstufe nicht verfgbar.",
          optionsHeader: 'Optionen fr Layer "{{name}}"',
          layerHeader: "Auswahl sichtbarer Ebenen",
          layerOptions: "Optionen fr Kartenmaterial",
          returnToLayers: "Zurck zur Auswahl"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        layerChooser: {
          backgroundTitle: "Background maps",
          maskTitle: "Subject data",
          tooltipDisabledLayer: "Not available on the current zoom level.",
          optionsHeader: '"{{name}}" layer options',
          layerHeader: "Visible layer selection",
          layerOptions: "Map data options",
          returnToLayers: "Return to selection"
        }
      }
    }
  }
];
function UO(e, t) {
  return e.filter((n) => {
    let { minZoom: s, maxZoom: r } = n;
    return typeof s > "u" && (s = 0), typeof r > "u" && (r = Number.MAX_SAFE_INTEGER), s <= t && t <= r;
  });
}
function Pg(e, t = (n) => n) {
  const n = e.map(({ id: s }) => String(s));
  return t(n);
}
const Of = (e, t) => {
  if (Array.isArray(e))
    return e.map((n) => Of(n, t)).find((n) => n !== null) || null;
  if (typeof e == "object") {
    if (e.Name === t)
      return e;
    if (e.Layer)
      return Of(e.Layer, t);
  }
  return null;
}, yJ = (e) => (Array.isArray(e) ? e : [e]).map(
  (t) => (Array.isArray(t.LegendURL) ? t.LegendURL : typeof t.LegendURL == "object" ? [t.LegendURL] : []).map((n) => n.OnlineResource)
).flat(1), EJ = (e, t) => {
  const n = Of(e.Capability.Layer, t);
  return (n == null ? void 0 : n.Title) || "";
}, CJ = (e, t) => {
  const n = Of(e.Capability.Layer, t), s = n == null ? void 0 : n.Style;
  return s && yJ(s)[0] || "";
}, Sg = () => ({
  openedOptions: null,
  backgrounds: [],
  masks: [],
  availableBackgrounds: [],
  availableMasks: [],
  activeBackgroundId: "",
  activeMaskIds: [],
  activeLayerIds: {}
}), xJ = {
  namespaced: !0,
  state: Sg(),
  actions: {
    setupModule({
      state: e,
      rootGetters: { configuration: t, map: n },
      commit: s,
      dispatch: r
    }) {
      const [i, a] = t.layers.reduce(
        ([f, d], u) => u.type === "background" ? [[...f, u], d] : u.type === "mask" ? [f, [...d, u]] : (console.error(
          `Unknown layer type ${u.type} in Plugin LayerChooser. Layer is ignored by plugin.`
        ), [f, d]),
        [[], []]
      ), o = i.find(({ visibility: f }) => f), l = a.filter(({ visibility: f }) => f);
      s("setBackgrounds", i), s("setMasks", a), r("setActiveBackgroundId", (o == null ? void 0 : o.id) || null), r("setActiveMaskIds", Pg(l)), r("updateActiveAndAvailableLayersByZoom"), n.on("moveend", () => r("updateActiveAndAvailableLayersByZoom")), t.layers.forEach((f) => {
        var u, c, h, p, g;
        const d = ea({
          id: f.id
        });
        if (d.typ !== "WMS" && !f.hideInMenu) {
          console.warn(
            `Used configuration 'layers' on layer with type '${d.typ}', but only 'WMS' is supported. Ignoring configuration for ${JSON.stringify(
              d
            )}.`
          );
          return;
        }
        (u = f == null ? void 0 : f.options) != null && u.layers && s("setActiveLayerIds", {
          ...e.activeLayerIds,
          [f.id]: d.layers.split(",")
        }), (((h = (c = f == null ? void 0 : f.options) == null ? void 0 : c.layers) == null ? void 0 : h.title) === !0 || ((g = (p = f == null ? void 0 : f.options) == null ? void 0 : p.layers) == null ? void 0 : g.legend) === !0) && r("capabilities/loadCapabilities", f.id, { root: !0 });
      });
    },
    setActiveBackgroundId({ rootGetters: { map: e }, getters: { backgrounds: t }, commit: n }, s) {
      e.getLayers().getArray().forEach((r) => {
        t.find(({ id: i }) => i === r.get("id")) && r.setVisible(r.get("id") === s);
      }), n("setActiveBackgroundId", s);
    },
    setActiveMaskIdsVisibility({ rootGetters: { map: e }, getters: { masks: t } }, n) {
      e.getLayers().getArray().forEach((s) => {
        t.find(({ id: r }) => r === s.get("id")) && s.setVisible(n.includes(s.get("id")));
      });
    },
    setActiveMaskIds({ commit: e, dispatch: t }, n) {
      t("setActiveMaskIdsVisibility", n), e("setActiveMaskIds", n);
    },
    // when the zoom changes, it does what needs to be done
    updateActiveAndAvailableLayersByZoom({
      rootGetters: { map: e },
      getters: { backgrounds: t, masks: n },
      commit: s,
      dispatch: r,
      getters: { activeBackgroundId: i, activeMaskIds: a }
    }) {
      const o = e.getView().getZoom(), l = UO(
        t,
        o
      ), f = UO(n, o), d = Pg(l), u = Pg(f);
      d.includes(i) || r("setActiveBackgroundId", d[0] || ""), r(
        "setActiveMaskIdsVisibility",
        u.filter((c) => a.includes(c))
      ), s("setAvailableBackgrounds", l), s("setAvailableMasks", f);
    },
    toggleOpenedOptionsServiceLayer({
      commit: e,
      rootGetters: t,
      getters: {
        openedOptionsService: n,
        openedOptionsServiceLayers: s,
        activeLayerIds: r
      }
    }, i) {
      var u;
      const a = s === null ? i : s.filter(({ layerName: c }) => i.includes(c)).map(({ layerName: c }) => c).reverse(), l = (t == null ? void 0 : t.map).getLayers().getArray().find((c) => c.get("id") === n.id), f = (u = l == null ? void 0 : l.getSource) == null ? void 0 : u.call(l);
      if (!l || !f) {
        console.error(
          `Action 'toggleOpenedOptionsServiceLayer' failed on ${n.id} with value ${a}: Layer not found in OL, or source not initialized in OL.`
        );
        return;
      }
      const d = { ...f.getParams(), LAYERS: a };
      f.updateParams(d), e("setActiveLayerIds", {
        ...r,
        [n.id]: a
      });
    }
  },
  mutations: {
    ...Or(Sg())
  },
  getters: {
    ...Hi(Sg()),
    disabledBackgrounds(e, { availableBackgrounds: t, backgrounds: n }) {
      return n.map(
        ({ id: s }) => t.findIndex((r) => r.id === s)
      ).map((s) => s === -1);
    },
    disabledMasks(e, { availableMasks: t, masks: n }) {
      return n.filter(({ hideInMenu: s }) => !s).map(
        ({ id: s }) => t.findIndex((r) => r.id === s)
      ).map((s) => s === -1);
    },
    shownMasks({ masks: e }) {
      return e.filter(({ hideInMenu: t }) => !t);
    },
    idsWithOptions(e, { backgrounds: t, masks: n }) {
      return [...t, ...n].filter((s) => !!s.options).map((s) => s.id);
    },
    openedOptionsService(e, { backgrounds: t, masks: n, openedOptions: s }) {
      return [...t, ...n].find(
        (r) => r.id === s
      );
    },
    openedOptionsServiceLayers(e, { openedOptionsService: t }, n, s) {
      var l, f, d;
      const r = (l = t == null ? void 0 : t.options) == null ? void 0 : l.layers;
      if (typeof r > "u")
        return null;
      const i = ea({
        id: t.id
      });
      if (!i.layers)
        return console.error(
          'Trying to configure layers of a layer without "layers" field.',
          i
        ), null;
      const a = s == null ? void 0 : s["capabilities/wmsCapabilitiesAsJsonById"](t.id);
      return a === null ? (console.error(
        `CapabilitiesJson for layer ${JSON.stringify(
          t
        )} is null.`
      ), null) : (((d = (f = r.order) == null ? void 0 : f.split) == null ? void 0 : d.call(f, ",")) || i.layers.split(",")).map((u) => {
        var c;
        return {
          layerName: u,
          displayName: ((r == null ? void 0 : r.title) === !0 ? EJ(
            a,
            u
          ) : (r == null ? void 0 : r.title) === !1 ? u : r == null ? void 0 : r.title[u]) || u,
          layerImage: r.legend === !1 ? null : r.legend === !0 ? CJ(
            a,
            u
          ) : ((c = r.legend) == null ? void 0 : c[u]) || null
        };
      });
    }
  }
}, bJ = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "layerChooser",
  plugin: gJ,
  language: vJ,
  storeModule: xJ,
  options: e
}), TJ = $t.extend({
  name: "PolarZoom",
  props: {
    isHorizontal: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    ...ee(["hasSmallDisplay", "hasSmallHeight"]),
    ...ee("plugin/zoom", [
      "maximumZoomLevelActive",
      "minimumZoomLevelActive",
      "renderType",
      "showMobile"
    ]),
    showZoomButtons() {
      return this.hasSmallHeight ? this.showMobile : !0;
    }
  },
  methods: {
    ...mi("plugin/zoom", ["increaseZoomLevel", "decreaseZoomLevel"])
  }
});
var OJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, t.showZoomButtons ? n("div", { staticClass: "polar-zoom-wrap" }, [n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal, disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: t.renderType === "iconMenu" ? `polar-zoom-dependent${t.isHorizontal ? "-horizontal" : ""}` : "ma-2", attrs: { "aria-label": t.$t("common:plugins.zoom.in"), color: "primary", small: "", fab: "", disabled: t.maximumZoomLevelActive }, on: { click: t.increaseZoomLevel } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" fa-plus ")])], 1)];
  } }], null, !1, 1658946353) }, [n("span", [t._v(t._s(t.$t("common:plugins.zoom.in")))])]), n("v-tooltip", { attrs: { left: !t.isHorizontal, bottom: t.isHorizontal, disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [n("v-btn", t._g(t._b({ class: { "ma-2": t.renderType === "independent" }, attrs: { "aria-label": t.$t("common:plugins.zoom.out"), color: "primary", small: "", fab: "", disabled: t.minimumZoomLevelActive }, on: { click: t.decreaseZoomLevel } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { color: "primaryContrast" } }, [t._v(" fa-minus ")])], 1)];
  } }], null, !1, 2549324567) }, [n("span", [t._v(t._s(t.$t("common:plugins.zoom.out")))])])], 1) : t._e();
}, PJ = [], SJ = /* @__PURE__ */ Ce(
  TJ,
  OJ,
  PJ,
  !1,
  null,
  "29ff08db",
  null,
  null
);
const MJ = SJ.exports, _J = [
  {
    type: "de",
    resources: {
      plugins: {
        zoom: {
          in: "Hinein zoomen",
          out: "Heraus zoomen"
        }
      }
    }
  },
  {
    type: "en",
    resources: {
      plugins: {
        zoom: {
          in: "Zoom in",
          out: "Zoom out"
        }
      }
    }
  }
], Mg = () => ({
  zoomLevel: 0,
  maximumZoomLevel: 12,
  minimumZoomLevel: 0
}), IJ = {
  namespaced: !0,
  state: Mg(),
  actions: {
    setupModule({ rootGetters: { map: e }, commit: t, dispatch: n }) {
      const s = e.getView();
      e.on("moveend", () => n("setZoomLevel", s.getZoom())), n("setZoomLevel", s.getZoom()), t("setMaximumZoomLevel", s.getMaxZoom()), t("setMinimumZoomLevel", s.getMinZoom());
    },
    setZoomLevel({
      getters: { maximumZoomLevel: e, minimumZoomLevel: t, zoomLevel: n },
      rootGetters: { map: s },
      commit: r
    }, i) {
      i !== n && n <= e && n >= t && s && (r("setZoomLevel", i), s.getView().setZoom(i));
    },
    increaseZoomLevel({ dispatch: e, getters: { zoomLevel: t } }) {
      e("setZoomLevel", t + 1);
    },
    decreaseZoomLevel({ dispatch: e, getters: { zoomLevel: t } }) {
      e("setZoomLevel", t - 1);
    }
  },
  mutations: {
    ...Or(Mg())
  },
  getters: {
    ...Hi(Mg()),
    maximumZoomLevelActive: (e, { zoomLevel: t, maximumZoomLevel: n }) => t >= n,
    minimumZoomLevelActive: (e, { zoomLevel: t, minimumZoomLevel: n }) => t <= n,
    renderType: (e, t, n, s) => {
      var r, i;
      return (i = (r = s.configuration) == null ? void 0 : r.zoom) != null && i.renderType ? s.configuration.zoom.renderType : "independent";
    },
    showMobile: (e, t, n, s) => {
      var r, i;
      return typeof ((i = (r = s.configuration) == null ? void 0 : r.zoom) == null ? void 0 : i.showMobile) == "boolean" ? s.configuration.zoom.showMobile : !1;
    }
  }
}, DJ = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "zoom",
  plugin: MJ,
  language: _J,
  storeModule: IJ,
  options: e
}), AJ = $t.extend({
  name: "MeldemichelGfiFeature",
  props: {
    currentProperties: {
      type: Object,
      required: !0
    },
    clientWidth: {
      type: Number,
      required: !0
    },
    exportProperty: {
      type: String,
      default: ""
    },
    showSwitchButtons: {
      type: Boolean,
      default: !1
    }
  },
  data: () => ({
    infoFields: ["skat", "start", "statu"]
  }),
  computed: {
    ...ee(["hasSmallWidth", "hasWindowSize"]),
    ...ee("plugin/gfi", [
      "windowFeatures",
      "visibleWindowFeatureIndex"
    ]),
    displayImage() {
      return this.currentProperties.pic;
    }
  },
  methods: {
    ...or("plugin/gfi", ["setVisibleWindowFeatureIndex"]),
    ...mi("plugin/gfi", ["close"]),
    formatProperty(e, t) {
      return t ? e === "skat" ? `meldemichel.skat.${t}` : e === "start" ? `${t.substring(6, 8)}.${t.substring(
        4,
        6
      )}.${t.substring(0, 4)}` : e === "statu" ? `meldemichel.status.${t}` : t : "";
    },
    resize() {
      window.dispatchEvent(new Event("resize"));
    },
    /** switch to next or previous feature */
    switchFeature(e) {
      const {
        visibleWindowFeatureIndex: t,
        windowFeatures: n,
        setVisibleWindowFeatureIndex: s
      } = this, r = n.length - 1, i = t + e;
      i < 0 ? s(n.length - 1) : i > r ? s(0) : s(i);
    }
  }
});
var LJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-card", [t.hasWindowSize && t.hasSmallWidth ? n("v-icon", { staticClass: "meldemichel-gfi-grip-icon" }, [t._v(" fa-grip-lines ")]) : t._e(), n("v-card-actions", [n("v-spacer"), n("v-btn", { attrs: { icon: "", small: "", "aria-label": t.$t("common:plugins.gfi.header.close") }, on: { click: t.close } }, [n("v-icon", { attrs: { small: "" } }, [t._v("fa-xmark")])], 1)], 1), n("v-card-title", { staticClass: "meldemichel-gfi-title" }, [t._v(" " + t._s(t.$t("meldemichel.gfi.title"))), n("br"), t._v(" " + t._s(`${t.currentProperties.str} ${t.currentProperties.hsnr}`) + " ")]), t.displayImage ? n("img", { staticClass: "meldemichel-gfi-img", attrs: { src: t.currentProperties.pic, draggable: "false" }, on: { load: t.resize } }) : t._e(), n("v-card-text", [n("v-simple-table", { attrs: { dense: "" }, scopedSlots: t._u([{ key: "default", fn: function() {
    return [n("tbody", t._l(t.infoFields, function(s) {
      return n("tr", { key: s }, [n("td", { staticClass: "meldemichel-fat-cell" }, [t._v(" " + t._s(t.$t(`meldemichel.gfi.${s}`)) + " ")]), n("td", [t._v(" " + t._s(t.$t(t.formatProperty(s, t.currentProperties[s]))) + " ")])]);
    }), 0)];
  }, proxy: !0 }]) })], 1), n("v-card-title", [t._v(t._s(t.$t("meldemichel.gfi.beschr")))]), n("v-card-text", [t._v(t._s(t.currentProperties.beschr))]), n("v-card-title", [t._v(t._s(t.$t("meldemichel.gfi.rueck")))]), n("v-card-text", [t._v(t._s(t.currentProperties.rueck))])], 1);
}, RJ = [], wJ = /* @__PURE__ */ Ce(
  AJ,
  LJ,
  RJ,
  !1,
  null,
  "87e4d33a",
  null,
  null
);
const VJ = wJ.exports;
function BJ(e) {
  return [
    {
      plugin: bJ({}),
      icon: "fa-book-atlas",
      id: "layerChooser"
    },
    e === ps.COMPLETE && {
      plugin: VX({}),
      icon: "fa-filter",
      id: "filter"
    },
    {
      plugin: ZZ({
        gfiContentComponent: VJ,
        coordinateSources: [
          "plugin/pins/transformedCoordinate",
          "plugin/pins/coordinatesAfterDrag"
        ],
        featureList: {
          mode: "visible",
          pageLength: 10,
          text: [
            (t) => `${t.get("str")} ${t.get("hsnr")}`,
            (t) => `meldemichel.skat.${t.get("skat")}`,
            "beschr"
          ]
        }
      }),
      icon: "fa-location-pin",
      id: "gfi"
    },
    {
      plugin: DJ({ renderType: "iconMenu" }),
      id: "zoom"
    },
    e !== ps.REPORT && {
      plugin: zX({ renderType: "iconMenu" }),
      id: "fullscreen"
    },
    {
      plugin: mX({
        renderType: "iconMenu",
        windowWidth: 550,
        listenToChanges: [
          "plugin/zoom/zoomLevel",
          "plugin/layerChooser/activeBackgroundId",
          "plugin/layerChooser/activeMaskIds"
        ]
      }),
      icon: "fa-regular fa-copyright",
      id: "attributions"
    }
  ].filter(
    (t) => t
    /* remove `false` entries */
  );
}
const FJ = (e, t) => {
  const n = Q9({
    initiallyOpen: "layerChooser",
    displayComponent: !0,
    menus: BJ(t),
    layoutTag: Pa.TOP_RIGHT
  });
  _H(i7), e.addPlugins(
    [
      t !== ps.SINGLE && _9({
        displayComponent: !0,
        layoutTag: Pa.TOP_LEFT,
        addLoading: "plugin/loadingIndicator/addLoadingKey",
        removeLoading: "plugin/loadingIndicator/removeLoadingKey"
      }),
      EY({
        displayComponent: !0,
        appearOnClick: { show: !0, atZoomLevel: 0 },
        coordinateSource: "plugin/addressSearch/chosenAddress",
        toastAction: "plugin/toast/addToast"
      }),
      n,
      dY({
        displayComponent: !0,
        layoutTag: Pa.MIDDLE_MIDDLE
      }),
      NY({ displayComponent: !0, layoutTag: Pa.BOTTOM_RIGHT }),
      kY({
        displayComponent: !0,
        layoutTag: Pa.BOTTOM_MIDDLE
      }),
      t !== ps.SINGLE && K9({
        displayComponent: !1,
        toastAction: "plugin/toast/addToast"
      }),
      _Y({
        url: "https://geodienste.hamburg.de/HH_WPS",
        addLoading: "plugin/loadingIndicator/addLoadingKey",
        removeLoading: "plugin/loadingIndicator/removeLoadingKey",
        zoomTo: 7
      })
    ].filter(
      (s) => s
      /* remove `false` entries */
    )
  );
}, LE = {
  100: "Wege und Straen",
  101: "Schlagloch und Wegeschaden",
  102: "Verunreinigung und Vandalismus",
  103: "Wildwuchs und berwuchs",
  104: "Beschdigtes Verkehrszeichen",
  105: "Beschdigte Brcke, Tunnel, Mauer, Treppe",
  106: "Beschdigte Gelnder, Poller, Fahrradstnder, Sitzgelegenheit",
  111: "Schrottfahrrder",
  112: "Abgemeldete Fahrzeuge",
  113: "Radverkehr",
  114: "Stadtwald Hamburg",
  115: "Stadtwald: Schden am Baumbestand",
  116: "Stadtwald: Schden an Einrichtungen",
  117: "Stadtwald: Wegeschden",
  118: "Stadtwald: Verschmutzung / Mll",
  119: "Stadtwald: Illegale Aktivitten",
  120: "Stadtwald: Sonstige Schden",
  200: "Ampeln und Leuchten",
  202: "Ampel gestrt",
  203: "beleuchtetes Schild gestrt",
  204: "Straenbeleuchtung ausgefallen",
  205: "Straenbeleuchtung tagsber in Betrieb",
  400: "Grnanlagen und Spielpltze",
  401: "Baumschaden",
  402: "Spielgerteschaden",
  500: "Siele und Gewsser",
  501: "Gully-Schaden",
  502: "Graben",
  503: "Gewsserverunreinigung"
}, WI = {
  [Kv[0]]: "In Bearbeitung",
  [Kv[1]]: "Bearbeitet"
}, WO = {
  skat: LE,
  statu: WI,
  title: { skat: "Kategorien", statu: "Status" }
}, zI = [
  {
    type: "de",
    resources: {
      meldemichel: {
        attributions: {
          stadtplan: 'Kartografie Stadtplan: <a target="_blank" href="https://www.hamburg.de/bsw/landesbetrieb-geoinformation-und-vermessung/">Landesbetrieb Geoinformation und Vermessung</a>',
          luftbilder: 'Kartografie Luftbilder: <a target="_blank" href="https://www.hamburg.de/bsw/landesbetrieb-geoinformation-und-vermessung/">Landesbetrieb Geoinformation und Vermessung</a>',
          reports: "Meldungen durch Brger"
        },
        gfi: {
          title: "Meldung",
          skat: "Kategorie",
          beschr: "Beschreibung",
          rueck: "Rckmeldung",
          start: "Gemeldet am",
          statu: "Status"
        },
        layers: {
          stadtplan: "Stadtplan",
          luftbilder: "Luftbildansicht",
          reports: "Meldungen",
          hamburgBorder: "Stadtgrenze Hamburg"
        },
        skat: LE,
        status: WI,
        time: {
          [sd.NONE]: "Keine Einschrnkung",
          [sd.DAYS_7]: "Die letzten 7 Tage",
          [sd.DAYS_30]: "Die letzten 30 Tage",
          [sd.SELECTABLE]: "Zeitraum whlen"
        }
      },
      plugins: {
        filter: {
          layerName: {
            6059: "Meldungen  Filter",
            6061: "Meldungen (Stage)  Filter"
          },
          category: {
            6059: WO,
            6061: WO
          }
        },
        geoLocation: {
          toast: {
            notInBoundary: "Das System konnte Sie leider nicht in Hamburg verorten. Bitte benutzen Sie Karte und Suche, um einen Schaden innerhalb von Hamburg zu melden.",
            boundaryError: "Die Verortung ist fehlgeschlagen. Bitte benutzen Sie Karte und Suche, um einen Schaden innerhalb von Hamburg zu melden."
          }
        },
        gfi: {
          header: {
            close: "Zurck zur Listenansicht der Meldungen"
          },
          list: {
            header: "Meldungsliste",
            entry: "Meldung",
            emptyView: "Im aktuellen Kartenausschnitt sind keine Meldungen enthalten.",
            pagination: {
              currentPage: "Aktuelle Seite, Seite {{page}} von {{maxPage}} der Schadensmeldungen",
              page: "ffne Seite {{page}} von {{maxPage}} der Schadensmeldungen",
              next: "Nchste Seite ffnen",
              previous: "Vorherige Seite ffnen",
              wrapper: "Seitenauswahl"
            }
          },
          noActiveLayer: "Die Meldungen sind derzeit ausgeschaltet. Sie knnen Sie ber die Kartenauswahl (Buch-Symbol in der Werkzeugleiste) wieder einschalten."
        },
        iconMenu: {
          hints: {
            filter: "Filter",
            gfi: "Meldungsliste"
          }
        },
        pins: {
          toast: {
            notInBoundary: "Es knnen nur Koordinaten innerhalb von Hamburg gewhlt werden."
          }
        }
      }
    }
  }
];
zI.forEach((e) => {
  const t = Object.keys(LE), n = wI.map((s) => String(s));
  if (t.sort().join(",") !== n.sort().join(","))
    throw new Error(
      `POLAR Meldemichel: Error in language.ts/enums.ts: SKAT and Locales not in sync for language "${e.type}". Affected SKAT: ${t.filter((s) => !n.includes(s)).concat(n.filter((s) => !t.includes(s)))}`
    );
});
const KI = "453", GI = "452", gp = "1693", zO = "#ffffff", KO = "#003063", NJ = "#ff0019", _g = {
  checkServiceAvailability: !1,
  // service register too long
  epsg: "EPSG:25832",
  locales: zI,
  vuetify: {
    theme: {
      themes: {
        light: {
          primary: KO,
          primaryContrast: zO,
          secondary: zO,
          secondaryContrast: KO
        }
      }
    }
  },
  namedProjections: [
    [
      "EPSG:25832",
      "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    ],
    [
      "EPSG:4326",
      "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
    ]
  ]
}, Ig = [
  {
    id: KI,
    visibility: !0,
    type: "background",
    name: "meldemichel.layers.stadtplan"
  },
  {
    id: GI,
    type: "background",
    name: "meldemichel.layers.luftbilder"
  },
  {
    id: gp,
    visibility: !0,
    hideInMenu: !0,
    type: "mask",
    name: "meldemichel.layers.hamburgBorder"
  }
], ld = {
  initiallyOpen: !1,
  layerAttributions: [
    {
      id: KI,
      title: "meldemichel.attributions.stadtplan"
    },
    {
      id: GI,
      title: "meldemichel.attributions.luftbilder"
    }
  ]
}, GO = {
  searchMethods: [
    {
      // @ts-expect-error | missing field "epsg" filled later in process
      queryParameters: {
        searchAddress: !0,
        searchStreets: !0,
        searchHouseNumbers: !0
      },
      type: "mpapi",
      url: "https://geodienste.hamburg.de/HH_WFS_GAGES?service=WFS&request=GetFeature&version=2.0.0"
    }
  ],
  minLength: 3,
  waitMs: 300,
  focusAfterSearch: !0
}, Dg = {
  toZoomLevel: 7,
  movable: !0,
  style: {
    fill: NJ
  },
  boundaryLayerId: gp
}, kO = {
  coordinateSource: "plugin/pins/transformedCoordinate",
  addressTarget: "plugin/addressSearch/selectResult"
}, jJ = (e) => ({
  layers: {
    [e]: {
      categories: [
        {
          selectAll: !0,
          targetProperty: "skat",
          knownValues: [...wI]
        },
        {
          targetProperty: "statu",
          knownValues: [...Kv]
        }
      ],
      time: {
        targetProperty: "start",
        pattern: "YYYYMMDD",
        last: [
          {
            amounts: [7, 30]
          }
        ],
        freeSelection: {
          now: "until"
        }
      }
    }
  }
}), HO = {
  checkLocationInitially: !0,
  zoomLevel: 7,
  boundaryLayerId: gp,
  boundaryOnError: "strict",
  showTooltip: !0
}, $J = {
  [ps.COMPLETE]: (e, t) => ({
    ..._g,
    extendedMasterportalapiMarkers: {
      layers: [e]
    },
    addressSearch: GO,
    layers: [
      ...Ig,
      {
        // TODO implement grouping & spider for this one
        // TODO features visible as single, group, selected (green)
        id: e,
        visibility: !0,
        distance: 30,
        type: "mask",
        name: "meldemichel.layers.reports"
      }
    ],
    attributions: {
      ...ld,
      layerAttributions: [
        ...ld.layerAttributions,
        {
          id: e,
          title: "meldemichel.attributions.reports"
        }
      ],
      staticAttributions: [
        '<a href="https://www.hamburg.de/impressum/" target="_blank">Impressum</a>'
      ]
    },
    filter: jJ(e),
    geoLocation: HO,
    gfi: {
      mode: "bboxDot",
      activeLayerPath: "plugin/layerChooser/activeMaskIds",
      layers: {
        [e]: {
          geometry: !1,
          window: !0,
          // translation in meldemichel's local gfi override
          properties: [
            "str",
            "hsnr",
            "pic",
            "skat",
            "beschr",
            "rueck",
            "start",
            "statu"
          ],
          showTooltip: (n) => [
            ["h2", `${n.get("str")} ${n.get("hsnr")}`],
            ["span", `meldemichel.skat.${n.get("skat")}`]
          ]
        }
      }
    },
    pins: Dg,
    reverseGeocoder: kO,
    meldemichel: {
      afmButton: { afmUrl: t }
    }
  }),
  [ps.REPORT]: () => ({
    ..._g,
    addressSearch: GO,
    layers: Ig,
    attributions: {
      ...ld
    },
    geoLocation: HO,
    pins: Dg,
    reverseGeocoder: kO
  }),
  [ps.SINGLE]: () => ({
    ..._g,
    layers: Ig,
    attributions: {
      ...ld
    },
    pins: Dg
  })
}, UJ = ({
  mode: e,
  afmUrl: t,
  reportServiceId: n
}) => {
  if (e === ps.COMPLETE && typeof n > "u")
    throw new Error(
      "POLAR Meldemichel Client: Missing reportServiceId configuration in mode COMPLETE."
    );
  return {
    // @ts-expect-error | reportServiceId might be undefined, but that's caught above for relevant cases
    ...$J[e](n, t)
  };
}, WJ = (e) => {
  const t = document.getElementById(e);
  t.shadowRoot.children.app.style.backgroundImage = "url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCADIAMgBAREA/8QAGAABAQEBAQAAAAAAAAAAAAAAAQACAwf/xAAtEAEAAQQCAgEDAwQDAQEAAAABEQACITFBURJhInGBsTKRoQPB4fBCUtHxE//aAAgBAQAAPwD0u0CWRjnqpgwsTzNVuF23VNsSIE5c5olBRzS4PK7rlx7oYu7R1FUqkMnJNURdwz2YqTLBl65pV3xQ+UQJK0WihJrqtW9SgYoZUtG6eYd1lZUhj3Tlxr7VolHPqqDxlUXdBzMNPmMeT6qVYjB75rNt5/UtLw8SMTsrQ+EigvM1m0uwuc4jqkFPjvnqtIIDCdVnnE6kEqiMZZ3VHjPvqiVunnGasl05n1zUYvGDOa1cDdqPrUpno7ap8oFFirF1x79UBcPXcVLGdRqrcOk6ao6ldk1pc/pYCj0/pHFFylzcxg3OioAFnj96Ui2fKgiJZXj1S/IJtlXii4PGFPfqkuAQzJzQWxdvW+qYFflxJG6tTvU0Plzg3k3SsyO+u6BAlqhv+IRNXi+2Kkx8UgKVxMSR1NGJ0fYqtVVHihbonY02l2uefpUm4MmdVWyS4jodU2o5PKHiamCYtn1qqRcZ+lULyfah0g5NHfdTPjjxXpqXGSU5mjEfjOqVXUB3WrY8uxrORwy+qde5qkXOA7qtvidS41RFyxz9P7VlPJAfFMjWm5iTNFxBKxT5luGDFJb5dH1qfjMG+qQkzRuV1rFMgZFjWay3MR45jNXk4D7+qWwbZhfvVgt8hxxUxzucwVW/G7xecjsakXj7TWoG1Qd66rKH0c/esw+Jhlrd1sQuH8+6Fhh5qFykMchSWxasbrDZcXeU/G3Y80wwcPdMy9PGOKhlzyUoBME6azEZYOZjNMzaDtOOKhnh1UhrDFZtDxM6aXLGz1j+aolmWefVEIpdcZ6pUP0lNq58gj8VlW53AalrdrGAl96KocZpbpjQGfrQDLIQdNZyzDEUa3zTx3ButBLEgB1qpi1PG7Vcy5uvzLbnKQTW741rv3WfJFdMdUn6dJ1S4AZDuKhh8QcVnx8rsQxz1WlLdywRrmif1I/vRsB+lazEaE0O6yipgJ420r8o1GMVcz5YqvbfEPE9tQZhj7UkIbx1Vd/pFUNWeB1UCHlGCsmUwDyVoQmc45ocEcPVNkEL+qZcUtrpd6JqWMxkx9ayAg/udVGY3/aqc+SDGsVKMobcZ1VI5HO0CgnAbnbSF25J6Ki1swEfWpAVnI67qwywz0d1ottFxP4pbV0D6awowZ3VEWdT/FQ+Oz1WjKa1MUZHyImKr1MH/lHjbdA5qVuDaTUCXQz3NQzdPkY0VGcuzorSyGddlZS4B8RR1dRdbbDC5ctJ4hCpDVbaeLMk+6k43Ufokz6ijK7z3qtSCGj8UKjthpZCEmOYqMOPvxU4cpG4eaS6b4P/AJWZvlgliaMCuPZ7rWAJMNUpn+KyomDXfdITx6qyKY/alu3hezqoQe/R1VdafpCGc1eLEAWx3hKzreIqLlUkX603Hx49RUsp61Uq3YIHG6hYz3qozI4OpqG1XEp+amc2yk1oYwk9NEfKBzzPFIlxrfqhuAJ55oXPlOTTV5RJMHVUSOATjmrBCzvlpULsTn1SiXTEMUGpmi61SXjROarrpcy/iguFQAOmoYcIRjG2tT/xXfdQyxl6ol8tTVPxnxfpH4quMGdmqfHgQnP1rJKsQLo4rVyBjnc1LIMH3oQU0y/elkSCX6UnXj+9SluDPbqhugJCV45omJtLj3HFUHBHa1E5MYOaRtj9M46oRLhSE0/Wp+R9OatpqXia1Lb9eqxcxbAb3DVvEDB+1SCCTBrHNBFseGCcrxWkh1I7pZSYxxV3ID+KzwZmOfValX42/egwMcaocRNabhhn7VJBagysoVYl8mCMDurQxaBxQeR44Uf4/wAU3MLIZ4KxaWjd4gqxdWsto880tt2Cec/5qmFOPpWVufJUbVg8SMVDhzEUjmXyXmaQZ8rpUrMSkYnlpSZyZ1NXjj9WZ3zUgGev3qQ8flvf1qepJTXB/mjFuCcbaUAHn00z5RjWqkbhtzPHusxBaR9onFSeHtrSvjO3/d0WkTcC9+6eJd/2+tEI9RmoZmcxzGK1ZYE5iWZ7qCcWkQ7otuLZxkZqZbZGZZfVQAYxnFZU8tbyUh7fWagLrZVgz96rrZ6jT9al8g0J/s1W3AwAcFOmXjjdUKuZkmogTX0ayiytzCa5qtRgiSOSlwFsm81AzJD3ndCxCsxqlW0JC5dd05bf0y9UFxcYYYqgLrruWMPqm4yzmcuaglnUvdGlh1yUkrLE8UML+acKoGPWqizDh9RqhmIiU9VSbOOJ56pIhYwU48Rd/tWW2fU6qgtcHNZm7UwdpWhLcwXTVEBnD1Wm3Jn49NZvsH4qg5kpYcEQ6KnYaXdVtg7JjNC6ExOKn+oluWIMfSguW21QIMhzWrmYXCOaszz/AHpLgt8Tj+KxbkWWX3RkkP5rWLsyv0pEwc8TuibtTk/3FSxl26qcjgGNlJaMs6zujyTZKGqWMCOs5zVi1zdlzFICREn+5qwbycRisyYMAbKSbpFy4KQRi2Digy5zjir/AJE4oBLYGc8VWrLOnjqpsz8kCdpWtTienis8ymt4pW4UotlZDEc7aC6bcHGqS0Y6oTJE555rQ5lifbQCqmHsqi7cGezihxIh/mtAFsmGsDiboDXutlpHlMnVQW+fkC3XERUXAYfKq7KPBzUxMRAbpwEEM98Vl+Mdd1eUTA0Al2CJ9VsxMd5fdZtwYitbtGdUXtuPk4xWSR8ne6VnOXWqY5zQ/wDZj1QCRHWa3L5CBvE1lMzLimUt3t/alRc8MeqEeH0zUmohDisWJdba3TkGH8VudRbjmsrkkjr1TI3OYd0XXhZM/dpBCGPGnx4cEYxUHw3n05ohCFnycFIOhzWbX+nfd8Ue4d1tIlUjvWayXZ4lNVR5EYz3VdhLeA3RawzOq1MTGn9qLVwMYdUtjOPiboFJP1Y31US48j3NMsgYDdACCQsxFUxJK8w9UltzmMHMZmq6MO0z9aBW2cHZOqp+ZYGeINUkXEQMUZmWIHB7pT/i6e6uNa3FUk9lXkuNDQM3+Qq9904SLUOcFKCQu9cRWbrcTxOXVatLZ+L7nmsXShH/ACcU3W4zga14niDjr60JGFmOmpi1Pe81fqJ6rLbcP6sPCVruef4oWAOJx7a0r45H0RUhoWdxNFrCqZ6oYnAQ6pBjbJyVl/pjyT/2MfatzFpLHGeaypGJy1YGUia1PrFZulOx/FQqPi6OabLi+4tuAd/Wm79XjcTFZZMBIPDQG7cRFJcXQOQx9KkgcT9eaLcEriIStsG7c8fShtByRRmYnH9qB4dPNawWyrnkrN1gtrK+Oj60o29n+7qiTAy+6dDb+89VlYu+Mx0cVpuLrfi5GRGrKo4d63VBpymsa90Iughf4q99d8VoWEgmNViFJVE0U22+SXTCaqwQrLa4qYdrJVk+S490hAafzUO5jNATzD7rWbXxQXVEAZUoE8YzBxzVNsXMRHFZS5y87rQq6d4p2fLng/8Aax5hdb/TuW6+OfzT5TMGfxVp5A/NKRa7z+am6ScdYpFVt4MxVOc3JJM8lZH5RmXn33WpfHBvvdTLgJj3UZiCkCcsPbUkQ5fUVm5wtuCdFPkXW4idYqCGFy7qmBdxzFAwpEwTmpZSILuyrRv7JSYEU+rWTD43ZzxWkRhZzMlLJBJIT+9Zws5ijwtcIazcfilxmPrmabiWMp+aM+KCQe9UWltwKqDS+QLMe6Lk51y7qEny44qjykFBPvXQ+V2Zja1hZxbkjbSoRjPM6qJHHX7VW6hZiq2S2YmKriBlybRmn9RF13xSGiA8jJDC1kZzMYgpWYgWqEzOAzjdBMaqbJj0zWrULkCQmKkFwzP5qBLZYPVBPlqWMVN28566qlQ/6vdF07XAaqFbRzbIY5qJTxYl91CkzEnvf0rYl1uVIqC7EqZw0eNsrbEu4/NVpMSS80WkXXDNx3+aIM/KI/mtmSIbfw0P/YmTclCLmSeKYuBOI1RduIxilJPjcWo6rEwMcsTTPiguuO6Rtbuo59VX3Ns3XQB0USJ8dJM0t9yfH6TWQxh+7WpLWXPdMpmMVktibj/7USKXBIww/tWgHj/PdCQDHP71M8YOa1lRHiInFSKTj6m4o/S5ymdYqfGFMR7qH5RGXRvNGVPJZODXutH6iHEaqJGQgoWbY16mgFhgl94qZtSXDw0gDiMnNZ/Xs3/NagnMpS2ihiWhwJjcTQ+QrDgiKLxLRxMxjih28BqkCDRT5eLnTureJ31TO/XFBGWCHcuaS60jxDqGhnxkSOMUiafxVd/ULbfjZ5RmAzRbc3ApCmR4qZk8WAckbP7VeRrGde/pWVVgYQ3zNMv/AOahN09wNFzIP8clabQCNUCj44baj+phgdyRxSErj6UyyZx3FSWrMrHNEFykueT+1V183wikbjFa8Sdsclf/2Q==')";
}, YO = (e) => e.split(",").map((t) => Number(t)), zJ = {
  namespaced: !0,
  state: {},
  actions: {
    // setupModule({ getters }): void {},
    setMapState: ({ commit: e, dispatch: t, rootGetters: { map: n } }, {
      mapCenter: s,
      mapZoomLevel: r,
      mapBaseLayer: i,
      vendor_maps_position: a,
      vendor_maps_address_str: o,
      vendor_maps_address_hnr: l
    }) => {
      s && n.getView().setCenter(YO(s)), r && t("plugin/zoom/setZoomLevel", Number(r), {
        root: !0
      }), i && t(
        "plugin/layerChooser/setActiveBackgroundId",
        String(i),
        {
          root: !0
        }
      ), o && l && e(
        "plugin/addressSearch/setInputValue",
        `${o} ${l}`,
        { root: !0 }
      ), a && t(
        "plugin/pins/showMarker",
        {
          clicked: !0,
          epsg: "EPSG:25832",
          type: "Point",
          coordinates: YO(a)
        },
        { root: !0 }
      );
    }
  },
  mutations: {},
  getters: {
    mapState(e, t, n) {
      var r, i, a, o, l, f, d, u, c, h, p, g, m, v;
      let s = (i = (r = n == null ? void 0 : n.plugin) == null ? void 0 : r.addressSearch) == null ? void 0 : i.chosenAddress;
      return (s == null ? void 0 : s.type) !== "reverse_geocoded" && (s = null), {
        mapCenter: ((a = n.center) == null ? void 0 : a.join(",")) || "",
        mapZoomLevel: (l = (o = n == null ? void 0 : n.plugin) == null ? void 0 : o.zoom) == null ? void 0 : l.zoomLevel,
        mapBaseLayer: (d = (f = n == null ? void 0 : n.plugin) == null ? void 0 : f.layerChooser) == null ? void 0 : d.activeBackgroundId,
        vendor_maps_position: ((p = (h = (c = (u = n == null ? void 0 : n.plugin) == null ? void 0 : u.pins) == null ? void 0 : c.transformedCoordinate) == null ? void 0 : h.join) == null ? void 0 : p.call(h, ",")) || void 0,
        vendor_maps_address_str: (g = s == null ? void 0 : s.properties) == null ? void 0 : g.Strasse,
        vendor_maps_address_hnr: s ? `${s.properties.Hausnr}${s.properties.Zusatz}` : void 0,
        vendor_maps_address_plz: (m = s == null ? void 0 : s.properties) == null ? void 0 : m.Plz,
        vendor_maps_distance_to: (v = s == null ? void 0 : s.properties) == null ? void 0 : v.Distanz
      };
    }
  }
};
const KJ = $t.extend({
  name: "MeldemichelAfmButton",
  computed: {
    ...ee(["configuration", "hasSmallDisplay", "hasSmallWidth"]),
    ...ee("meldemichel", ["mapState"]),
    mapStateReady() {
      return !!(this.mapState && !Object.values(this.mapState).includes(void 0));
    },
    afmUrl() {
      const e = this.configuration.meldemichel.afmButton.afmUrl;
      return e ? `${e}?${Object.entries(this.mapState).map(([t, n]) => `${t}=${n}`).join("&")}&charset=utf-8` : (console.error(
        "Missing afmUrl parameter in `configuration.meldemichel.afmButton.afmUrl`."
      ), "");
    }
  },
  methods: {
    click() {
      this.mapStateReady || this.$store.dispatch("plugin/toast/addToast", {
        type: "info",
        text: "plugins.meldemichel.afmButton.missingAddress",
        timeout: 1e4
      });
    }
  }
});
var GJ = function() {
  var t = this, n = t._self._c;
  return t._self._setupProxy, n("v-tooltip", { attrs: { left: !t.hasSmallWidth, top: t.hasSmallWidth, disabled: t.hasSmallDisplay }, scopedSlots: t._u([{ key: "activator", fn: function({ on: s, attrs: r }) {
    return [t.afmUrl ? n("v-btn", t._g(t._b({ staticClass: "meldemichel-afm-button", attrs: { target: t.mapStateReady ? "_blank" : "", color: "primary", href: t.mapStateReady ? t.afmUrl : "#", large: "" }, on: { click: t.click, keydown: function(i) {
      return !i.type.indexOf("key") && t._k(i.keyCode, "space", 32, i.key, [" ", "Spacebar"]) ? null : t.click.apply(null, arguments);
    } } }, "v-btn", r, !1), s), [n("v-icon", { attrs: { small: "" } }, [t._v("fa-map-location")]), t._v(" " + t._s(t.$t("common:plugins.meldemichel.afmButton.buttonText")) + " ")], 1) : t._e()];
  } }]) }, [n("span", [t._v(t._s(t.$t("common:plugins.meldemichel.afmButton.hint")))])]);
}, kJ = [], HJ = /* @__PURE__ */ Ce(
  KJ,
  GJ,
  kJ,
  !1,
  null,
  null,
  null,
  null
);
const YJ = HJ.exports, XJ = [
  {
    type: "de",
    resources: {
      plugins: {
        meldemichel: {
          afmButton: {
            buttonText: "Neues Anliegen",
            missingAddress: "Bitte geben Sie eine Adresse ein oder whlen Sie eine Position durch Klick in die Karte.",
            hint: "Einen neuen Schaden melden"
          }
        }
      }
    }
  }
], ZJ = (e) => (t) => t.$store.dispatch("addComponent", {
  name: "meldemichelAfmButton",
  plugin: YJ,
  language: XJ,
  options: e
});
console.log(`POLAR Meldemichel loaded in version ${p7.version}.`);
const JJ = "https://geoportal-hamburg.de/lgv-config/services-internet.json", QJ = (e) => {
  e.getLayers().getArray().find((t) => t.get("id") === gp).setStyle(null);
}, aQ = {
  ...rd,
  // TODO API is probably not complete; worked out as part of project
  // how do we identify which marker is moved? by coordinate?
  // movable = false // NOTE relevant for SINGLE mode later  map to Pins config
  createMap: ({
    containerId: e,
    mode: t,
    afmUrl: n,
    reportServiceId: s,
    configOverride: r
  }) => new Promise((i) => {
    Object.keys(ps).includes(t) || console.error(
      `POLAR Meldemichel: Critical error. Unknown mode "${t}" configured. Please use 'COMPLETE', 'REPORT', or 'SINGLE'.`
    ), FJ(rd, t), rd.rawLayerList.initializeLayerList(
      JJ,
      async (a) => {
        const o = await rd.createMap({
          containerId: e,
          mapConfiguration: Bc(
            {
              ...UJ({ mode: t, afmUrl: n, reportServiceId: s }),
              layerConf: a
            },
            r || {}
          )
        });
        o.$store.registerModule("meldemichel", zJ), t === ps.COMPLETE && ZJ({
          displayComponent: !0,
          layoutTag: Pa.BOTTOM_RIGHT
        })(o), QJ(o.$store.getters.map), WJ(e), i(o);
      }
    );
  })
};
export {
  aQ as default
};
