{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is POLAR?","text":"<p>POLAR is ...</p> <ul> <li>... a configurable map client package.</li> <li>... a flexible map client factory.</li> <li>... an extensible library.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>About configuration, integration, and common use cases.</p>"},{"location":"configuration/#client-documentation","title":"Client documentation","text":"<p>For special usecases, there are specialized clients based on POLAR.</p> <p>The following specialized clients are managed by the POLAR core team: - Style preview documentation \u2197</p> <p>Not sure where to start? Use the package <code>@polar/polar</code> and its documentation for an unspecialized client including all plugins.</p>"},{"location":"configuration/#usage-pattern","title":"Usage pattern","text":"<p>All clients come with instructions documented above. However, they all mostly share how their integration works. Overall, these parts are required:</p> <ul> <li>TODO</li> </ul>"},{"location":"contact/","title":"Contact","text":"<p>Mail us at polar@dataport.de</p>"},{"location":"development/","title":"Development","text":"<p>Hint: Developing yourself is optional. POLAR supplies ready-made clients for many use cases, and you may commission us to write additional features.</p>"},{"location":"development/#where-to-code","title":"Where to code","text":"<p>POLAR clients run everywhere. To develop plugins and clients anew, a certain setup is required. To avoid redoing it, it is advised to create additional plugins and clients in a fork of the project.</p> <p>There are no further requirements. If you aim to merge back, please contact us before starting to put in work.</p> <p>TODO: Update this section, especially for clients</p>"},{"location":"development/#required-skills","title":"Required skills","text":"<p>Depending on what exactly you plan to write anew, the required skills may vary. POLAR is a purely front-end solution and as such general knowledge about web development is advisable.</p> <p>We are especially writing the client with the following libraries, to which additional knowledge is helpful for contributions.</p> 100 <p>OpenLayers</p> 90 <p>Vue</p> 80 <p>Vuex</p> 80 <p>TypeScript</p> 10 <p>SCSS</p>"},{"location":"legal-notice/","title":"Dataport","text":"<p>Altenholzer Stra\u00dfe 10-14 24161 Altenholz</p> <p>Telefon: 0431 3295-0 E-Mail: poststelle[at]dataport.de De-Mail: poststelle[at]dataport.de-mail.de</p> <p>Dataport ist eine Anstalt des \u00f6ffentlichen Rechts. Sie wird vertreten durch den Vorstand:</p> <p>Dr. Johann Bizer (Vorsitzender) Silke Tessmann-Storch Andreas Reichel Torsten Ko\u00df</p> <p>USt-IdNr. gem\u00e4\u00df \u00a7 27a Umsatzsteuergesetz: DE813840400</p>"},{"location":"architecture/","title":"Architecture documentation","text":""},{"location":"architecture/#user-perspective","title":"User perspective","text":"<p>When using POLAR, it behaves a simple fragment that can be used in any web-based setting. It may either work standalone, in which case there are only inputs for configuration, or as a part of a process, in which case there are both inputs and outputs for further processing.</p> <p>The purpose of POLAR is to handle all geospatial interactions of a user and utilize the decentralized geospatial infrastructure for that end.</p> <p></p> <p>Viewn from the outside, POLAR is just a component</p>"},{"location":"architecture/#usage-examples","title":"Usage examples","text":"<p>POLAR is designed to increase application efficiency and correctness for the public sector, but may be used in any form process or as a standalone map client. The provided visualisations ease communication between citizens and administrative staff, allowing them to effectively share the where.</p> <p>POLAR is already in use for ...</p> <ul> <li>... citizens to ...<ul> <li>communicate parcel data in applications.</li> <li>mark their current position for reports.</li> <li>read information on water levels, bathing spots, and much other public information.</li> </ul> </li> <li>... officials in charge to ...<ul> <li>coordinate city services regarding reports.</li> <li>present governmental data to the public.</li> <li>manage and update department geospatial data.</li> </ul> </li> <li>... developers to ...<ul> <li>heavily reduce implementation time.</li> <li>easily use geospatial systems without domain expertise.</li> <li>use POLAR as component in low code platforms.</li> </ul> </li> </ul>"},{"location":"architecture/#inner-architecture","title":"Inner architecture","text":"<p>On the inside, POLAR is constructed from many smaller and isolated packages that each encapsulate a specific part of the business logic. These parts can be mixed and matched, and are easily replacable for situations where further extension would make them overly complicated.</p> <p>For client-specific business logic, this can be placed in the very client itself to prevent bloat in other parts of the product.</p> <p>All in all, this makes POLAR a versatile map client factory.</p> <p></p> <p>Viewn from the inside, POLAR is a map client factory</p>"},{"location":"architecture/decisions/ADR-0001/","title":"We write ADRs from now on","text":""},{"location":"architecture/decisions/ADR-0001/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0001/#context","title":"Context","text":"<p>As time goes by, it becomes unclear whether architectural decisions have been made accidentally or on purpose, and, if on purpose, what the motivations were.</p>"},{"location":"architecture/decisions/ADR-0001/#decision","title":"Decision","text":"<p>From now on, all greater or debatable architectural decisions shall be denoted as an ADR within this document, like the \"example ADR\" you are currently reading. The used template is from here. Also, questions arising about architecture shall be answered in such an ADR format to procude future references.</p> <p>If certain points change while not obsoleting the ADR as such, ADRs may be modified later.</p>"},{"location":"architecture/decisions/ADR-0001/#consequences","title":"Consequences","text":"<ul> <li>(+) Architecture decisions will become more transparent and understandable.</li> <li>(+) A truth base is defined and referencable.</li> <li>(-) Time needed for documentation.</li> </ul>"},{"location":"architecture/decisions/ADR-0002/","title":"Plugin-based architecture","text":""},{"location":"architecture/decisions/ADR-0002/#status","title":"Status","text":"<p>Revoked by ADR 0009.</p>"},{"location":"architecture/decisions/ADR-0002/#context","title":"Context","text":"<p>With recurring requirements, a desire grows to avoid repetition and reuse components. This can be implemented with a plugin-based architecture to create new map clients and have the most common features already done.</p>"},{"location":"architecture/decisions/ADR-0002/#decision","title":"Decision","text":"<p>An architecture for the client has been designed that models how we get to re-use functionality without re-writing it while still being open for extensions. The following graphic explains the architecture in further detail.</p> <p></p>"},{"location":"architecture/decisions/ADR-0002/#consequences","title":"Consequences","text":"<ul> <li>(+) Higher quality of features since multiple parties use them.</li> <li>(+) Implement once, use multiple times.</li> <li>(+) Parts are easier to exchange/develop, and not all clients are required to update immediately.</li> <li>(-) More difficult to understand the codebase.</li> </ul>"},{"location":"architecture/decisions/ADR-0003/","title":"Error toasts have to be dismissed manually","text":""},{"location":"architecture/decisions/ADR-0003/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0003/#context","title":"Context","text":"<p>Information relevant for the user is displayed in toasts which close automatically after a custom timeout.</p>"},{"location":"architecture/decisions/ADR-0003/#decision","title":"Decision","text":"<p>A timeout set for toasts that contain error messages will be ignored. Such toasts can only be closed manually by clicking the close button.</p>"},{"location":"architecture/decisions/ADR-0003/#consequences","title":"Consequences","text":"<ul> <li>(+) The user is forced to handle error messages and thus is more aware of errors that occur.</li> </ul>"},{"location":"architecture/decisions/ADR-0004/","title":"Vuex mutations have no map side effects","text":""},{"location":"architecture/decisions/ADR-0004/#status","title":"Status","text":"<p>Obsoleted (Vuex is replaced with Pinia).</p>"},{"location":"architecture/decisions/ADR-0004/#context","title":"Context","text":"<p>OL Map interactions are usually side effects by nature, but are not asynchronous. It was unclear whether such changes belong to actions or mutations.</p>"},{"location":"architecture/decisions/ADR-0004/#decision","title":"Decision","text":"<p>It has been decided that map side effects do not belong to mutations, but to actions.</p>"},{"location":"architecture/decisions/ADR-0004/#consequences","title":"Consequences","text":"<ul> <li>(+) Mutations stay clean of side effects.</li> <li>(+) On potential extension of such map calls, asynchronous behaviour may be required; in that case, actions are already the correct position.</li> <li>(-) This restriction must be manually enforced.</li> </ul>"},{"location":"architecture/decisions/ADR-0005/","title":"Difference between actions, utils and lib-packages","text":""},{"location":"architecture/decisions/ADR-0005/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0005/#context","title":"Context","text":"<p><code>actions</code>, <code>utils</code> and <code>lib</code>-packages can often consist of very similar code. It was not always clear enough where to place certain functionality, which was ultimately up to each developers own preference.</p>"},{"location":"architecture/decisions/ADR-0005/#decision","title":"Decision","text":"<p>When deciding on where to place code (when writing or refactoring), the following ordered list should be followed:</p> <ul> <li>Does the functionality also change some part of the state? <code>action</code></li> <li>Should the functionality be usable outside of an integrated client? <code>action</code></li> <li>Does the functionality not have state changes, but belongs to a certain <code>action</code>? Either locally in the same file as the <code>action</code> or in a folder named after the <code>action</code> in the path <code>store/ACTIONNAME</code></li> <li>Does the functionality not have state changes, but be reusable in the plugin / core? <code>utils</code></li> <li>Should the functionality be reusable for multiple plugins / the core? <code>lib</code>-package </li> </ul>"},{"location":"architecture/decisions/ADR-0005/#consequences","title":"Consequences","text":"<ul> <li>(+) Gives clarity on where specific code fragments should reside.</li> <li>(-) This restriction must be manually enforced.</li> </ul>"},{"location":"architecture/decisions/ADR-0006/","title":"<code>console</code> statement standardization","text":""},{"location":"architecture/decisions/ADR-0006/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0006/#context","title":"Context","text":"<p>In production environments it may seem unclear if an error or warning message is shown in the console from which part of the application they occurred.</p>"},{"location":"architecture/decisions/ADR-0006/#decision","title":"Decision","text":"<p>All <code>console.warn</code> and <code>console.error</code> messages have to show the application's part in which they are invoked. We add the location to the console messages at compile-time using Vite.</p>"},{"location":"architecture/decisions/ADR-0006/#consequences","title":"Consequences","text":"<ul> <li>(+) Errors and warnings can more easily be tracked back to the place in which they occur.</li> <li>(+) This restriction is enforced automatically.</li> <li>(-) Console messages are more verbose.</li> </ul>"},{"location":"architecture/decisions/ADR-0007/","title":"How to expose additional exports of a package","text":""},{"location":"architecture/decisions/ADR-0007/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0007/#context","title":"Context","text":"<p>There are multiple ways of exposing additional exports of a package. They can either be exposed in the main file or configured as additional export nodes via rollup and the package.json.</p>"},{"location":"architecture/decisions/ADR-0007/#decision","title":"Decision","text":"<p>All exports should be exposed through the main file of the package as additional named exports.</p>"},{"location":"architecture/decisions/ADR-0007/#consequences","title":"Consequences","text":"<ul> <li>(+) A package consumer does not need to know additional paths to import.</li> <li>(+) This pattern is established by most major frameworks.</li> <li>(-) This restriction must be manually enforced.</li> </ul>"},{"location":"architecture/decisions/ADR-0008/","title":"Configuration parameters in tables have to be ordered by a) required and b) alphabetically.","text":""},{"location":"architecture/decisions/ADR-0008/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0008/#context","title":"Context","text":"<p>If a developer is reading the docs, having the configuration parameters order first by required values then alphabetically makes it easier to find relevant parameters.</p>"},{"location":"architecture/decisions/ADR-0008/#decision","title":"Decision","text":"<p>All docs shall be sorted as proposed.</p>"},{"location":"architecture/decisions/ADR-0008/#consequences","title":"Consequences","text":"<ul> <li>(+) Better readability of documentation.</li> <li>(+) Clear placement of new parameters.</li> <li>(-) This restriction must be manually enforced.</li> </ul>"},{"location":"architecture/decisions/ADR-0009/","title":"Revoke \"ADR 0002: Plugin-based architecture\" regarding packaging","text":""},{"location":"architecture/decisions/ADR-0009/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0009/#context","title":"Context","text":"<p>The current structure uses NPM packages so segment the codebase into reusable parts. These packages have no known outside usage and slow down development in various positions as well as make documentation and changelogs a burden. Instead of a differentiation of core, plugins, and libs, all of these parts shall reside in a single package whilst maintaining the current pluginability feature. This single package shall also offer a default modulith client with all parts readymade for instantiating that can optionally be used.</p> <p>If accepted, the original ADR shall gain an additional sentence linking to this ADR regarding this future change, as this won't be executed easily, in a short time, or in a single step.</p>"},{"location":"architecture/decisions/ADR-0009/#decision","title":"Decision","text":"<p>We will restructure the architecture as shown in the next big major version.</p>"},{"location":"architecture/decisions/ADR-0009/#consequences","title":"Consequences","text":"<ul> <li>(+) Easier maintenance (no superfluous changelogs, easier type access, less boilerplate, faster releases).</li> <li>(+) Easier to understand the codebase.</li> <li>(-) It's not possible to use different versions of packages in the same client, especially old versions.</li> <li>(+) We never did this anyway and it may have produced complex fix scenarios (LTS for majors?) that no longer may occur.</li> <li>(-) We'll have to introduce technical limitations (architecture checks) regarding imports to prevent the codebase structure from degrading to spaghetti.</li> </ul>"},{"location":"architecture/decisions/ADR-0010/","title":"Manage ADRs with Git","text":""},{"location":"architecture/decisions/ADR-0010/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0010/#context","title":"Context","text":"<p>Currently, ADRs are managed in a single GitHub wiki page of POLAR.</p>"},{"location":"architecture/decisions/ADR-0010/#decision","title":"Decision","text":"<p>We move the ADRs to the repository in a documentation folder. We write one file per ADR.</p>"},{"location":"architecture/decisions/ADR-0010/#consequences","title":"Consequences","text":"<ul> <li>(+) Changes to ADRs can more comfortably be tracked via Git.</li> <li>(o) There is more overhead in creating and updating ADRs, which may lead to writing less of them.</li> </ul>"},{"location":"architecture/decisions/ADR-0011/","title":"Split customer-specific clients into separate repositories","text":""},{"location":"architecture/decisions/ADR-0011/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"architecture/decisions/ADR-0011/#context","title":"Context","text":"<p>The new architecture, as introduced by ADR 0009, has a generic NPM package (@polar/polar, which replaces the packages @polar/core, @polar/lib-X, @polar/plugin-X and @polar/client-generic) and several customer-specific clients (@polar/client-X).</p> <p>The customer-specific clients are developed because of individual contracts and are (usually) not of major interest for other users. The maintenance of these clients is done primarily for the customers and does not contribute to the project's vision.</p>"},{"location":"architecture/decisions/ADR-0011/#decision","title":"Decision","text":"<p>Customer-specific clients (i.e., clients that are not the snowbox or the generic client) are moved to separate repositories (one repository per client).</p> <p>The new structure shall ensure that core changes can still be developed against a customer-specific client using HMR.</p>"},{"location":"architecture/decisions/ADR-0011/#consequences","title":"Consequences","text":"<ul> <li>(+) The repository structure is easier to understand (no monorepo).</li> <li>(+) Rules for contributions can be different between core and clients.</li> <li>(+) Contributors do not have to deal with customer-specific clients.</li> <li>(+) Real-world examples for implementing your own client in your own repository are provided.</li> <li>(+) Generating SBOMs is easier.</li> <li>(-) Following up with updates needs to be done in different repositories.</li> <li>(+) However, SemVer is used and helpers such as renovate exist.</li> <li>(o) Documentation of breaking changes including a migration guide is necessary.</li> </ul>"}]}